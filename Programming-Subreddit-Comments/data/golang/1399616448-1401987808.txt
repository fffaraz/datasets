Cool. When you get ready for ppc32 I might be able to set up an old mac mini headless for you to ssh into. 
One thing we've seen is using Nginx to serve static assets and allowing Go to serve dynamic content works best. Go *can* do all of that but it feels like more of a hack dealing with the templates than anything else (revel in my opinion does a really good job at remedying that complaint). One thing Go sucks at (my opinion) is SSL termination, again we've found Nginx to be the perfect friend. 
The amazing [Dmitry Vyukov](http://www.1024cores.net) does a lot of the optimization on Go's runtime. If you're interested in the low level details of multicore parallelism, I highly recommend looking at his work.
Thanks. I want to clear something up. &gt;&gt; Can one OS thread run on two processors at the same time? &gt; Yes. [...] I'm sorry to sound confrontational but that *can't* be correct. To be clear, I'm asking if an OS-level thread can be *simultaneously* scheduled for immediate execution (active or moving-to-active) on two processors *at the same time*. That can't possibly be true, can it? I'm aware that a thread can move from processor to processor, and I'm also aware that most OS's try not to do that very much, but what I'm asking is different - I'm asking if one thread can be running two Program Counters (PCs) at the same time, simultaneously, non-interleaved. Can't be, right? The same objection is then raised for the third point. If a thread can only be executing one 'instruction' at a time (for now, ignore code branch prediction, piplineing, etc. - unless it's relevant here of course) then surely only one coroutine can be executing at a time. My understanding is that a single Go thread can be multiplexing multiple coroutines, but only one coroutine is running per thread at any one moment.
martini for routing/sessions/web stuff; squirrel with database/sql (also used beego/orm)
Ok, may I ask you why the initial wiki is holding you back from learning the basics? Not detailed enough you think?!
Great! Does connecting to a web api like "Twitter" sounds interesting? Or maybe deal with cloud based platforms like amazon aws and so on?
Ok sounds interesting. I can cover the basics, but I don't think I qualify to be "a master" in that domain. These flaws are more "process" oriented by design rather than technical. Though I can talk about that as introductions.
This. I have a hard time understanding why so many seem to feel the need to use frameworks when writing web stuff in Go. In many other languages it is complicated or hard to write even simple things like "hello world" for the web, but with Go you can with a minimum of effort write complex and large systems using only the standard library. If you need some more candy to solve specific problems (sessions, clever routing etc) there are excellent libraries like http://www.gorillatoolkit.org/ and others where you can get help with only the bits you need without having to conform to an entire dogmatic framework. Of course, maybe the dogmas are what brings people to the frameworks. I admit to liking a bit of opinionated frameworking when I do stuff that I feel insecure about, but for people with experience writing web backends there is really no reason to use the straightjacket of a framework for these things.
Wow!! Ok it's on my agenda for advanced! panic/recover is ok for beginners since sometime... you can't do without it!! In brief for concurrency I would say that in Go you have "Channels" to catch parallel routines. So you can distribute/model routines and control their flow/order in an easy maintainable way. It can be done with other Python or Java, but it's a bit harder and unconventional, while in Go it's all about 2 lines of code... I have to admit I've never done performance tuning runtime for the moment. Go handles it quite perfectly, but I never faced a situation where I had to throw rockets with Go for the moment... haha! ;)
Right now I'm using goji + upper.io/db - it's very simple and powerful.
Checkout tweepy written in python. It can be implemented in Go.
You are quite right and I think /u/zhemao has what you were asking muddled up. Indeed, one core, effectively runs one thread of execution at a time, and yes, one core will be given one thread at a time, and for the time that the core is executing that thread, that thread won't be executing on any other cores. And indeed, once the OS puts a different thread on that same core, the original thread stops executing, the OS is then free to resume execution of the original thread on a different core, but will often prefer the last core it used for that thread.
&gt; which means that Go is effectively limited to one processor by default Yes, that's correct. This setting is ofcourse per program instance (process). GOMAXPROCS=1 behaves much the same as a single thread C program. GOMAXPROCS &gt; 1 behaves as a multi threaded C program, with goroutines distributed among the threads. 
Just use the gorilla toolkit and the json encoder. Go is a wonderful language you don't need a framework. Some of my api's have been under a 100 lines 
&gt;so i'm not sure why you even bothered to compare apples and oranges in the first place. That was my whole point when I said: &gt;Python and Go are 2 different animals. I understand that go has many things that python doesn't, but there are some things that, to implement in go, are too cumbersome. The example i gave isn't that bad, but there are many things that i wouldn't attempt in go, but are trivial in python. You shouldn't be so abrasive, we are all here to help each other, not to be pricks.
Please don't. The C compilers are scheduled to be retired some time in the future and your code will break. You seem to be concerned with cgo overhead, so you care about performance. You will not get any performance out of 6c, it's even less performant compared to 6g. The only reason to use 6c is to do things which are very hard to do from Go. Also you won't get any C library, you only get access to the runtime. Porting any code to this environment is PITA. PS: The mailing list is a good place to ask these questions. 
I would like some more information about passing pointers vs passing the actual value to functions, including best practices. As a long-time Ruby developer, I'm loving Go, but still find myself hesitating at times trying to determine which approach is best in which situation.
As you said, writing web stuff in other languages with only stdlib is pretty complicated and that's why i asked the question, as i'm new to Go and still have the habits of other languages (Python, Ruby ...). As so many people pointed me to net/http, Gorilla &amp; Martini, i'm taking the time to test each of them. Having a little experience writing web backends from scratch, i think i will face some issues with security and probably write very ugly code. (But at least for learning, i will try net/http)
Thank you for this answer. I expected something like this. What is going to happen when the C compilers are retired? Will Go switch over to the platform's native ABI?
Follow up questions: what does changing GOMAXPROCS during execution do? Can you change it back and forth when you know parts of your program are faster in single vs multi-core mode? What happens if there are executing go routines and you decrease it?
Or at least contains an embedding. I'm not sure "bugginess" is guaranteed, though. Now, if you'll excuse me, I need to get back to working on my Erlang-like cluster message sending implementation. I hope to actually send a message over a socket today. (No joke.)
The huge problem with this is that Go requires a rather complex runtime environment. A Go program basically contains its own user space scheduler which is required to implement Go routines. Before you can use any Go code you would need to start that runtime environment so the Go code can run. An additional consideration is the fact that Go assumes to know the entire program before it runs. This is needed to correctly compute the initialization order. What happens if your program uses more than one shared library written in Go? Will there be two simultaneously existing Go environments? Will both libraries share one environment? What happens if one of these libraries is loaded during the execution of your program? Go mandates that all initializers be run before the main() function starts. This is impossible if new packages can be added during the programs runtime. What you try to do is currently not really possible as the Go specification is not designed to consider the corner-cases that may appear for such code.
Sorry to wake up an old thread, but I stumbled in here looking for web framework advice. $0.02: and please correct me if I'm wrong here. I'm still wrapping my head around some of this stuff. I think Revel can be a poor fit for some environments only because it's not possible to compile the application down into a single binary, like other Go web frameworks do. Instead, it's a lot like PHP, Python, or ASP, in that your deployment posture requires you to ship the app sourcecode and go compiler.
You *did* say *dream* syllabus: - Building blocks - Databases and ORM - How to use Go to talk to Postgres - Using Postgres as a relational database - Using Postgres as a NoSql database - [Postgres 9.2](http://www.postgresql.org/about/news/1415/) - How to use Go to talk to [Riak](http://basho.com/riak/) - User management - using token-based authentication instead of session-based authentication. - authentication, using hashed and salted passwords - authentication, using OAuth2 with google/ twitter/ facebook - authorisation, allowing/ denying access to certain endpoints based on user roles - user sign up - protecting against cross site request forgery - Building functionality - APIs - Tweet something/ post something to facebook/ post something to Google+ - Accept dollar payments using Stripe/ Braintree - Accept bitcoin payments using Coinbase - Building a server which conforms to the [JSON API spec](http://jsonapi.org/) - Other - Notifications: Server to push a notification to an iOS device, and an Android device - WebRTC: broker a connection between two browser clients to transfer a file between them Rationale: - Focus on building real world applications - the parts of it that are not usually covered - Most tutorials focus on MySQL for relational databases and MongoDb for NoSQL, I would like to see less common databases that I have heard good things about, get some coverage. - Most tutorials default to session-based authentication, and assume that clients are browser clients, and I would like to see sme coverage for token-based authentication, as they would be more at home with native apps or single page web apps, and also have not been given as much coverage as it should be - Most real world applications will need to at some point accept payments, why not make it intresting and cover how to accept cryptocurrency as well? 
I started with net/http and found it tedious to have to wrap all my handlers for a bunch of different "middleware." My app exposes a JSON API, so I want things like logging, panic handling, telemetry and other performance metrics, encoding all responses in a standard JSON format, decoding JSON requests, OAuth or client ID authentication, handles for my database and the system config and the current user, etc. etc. I switched to Martini and that solved most of those problems by simply adding middleware functions and injecting what I need on the handler functions, but it encourages sloppy coding. I quickly find myself with handlers taking 6 arguments in completely random and inconsistent order. You have to be extremely disciplined to enforce consistency. I'd rather not have to worry about that. I find myself wishing I had a (statically typed!) context struct type on my handlers instead, and accessing what I need on that object. It would make my handler functions a lot cleaner. http://github.com/gocraft/web looks like a nice step in that direction by using method expressions -- very clever -- but I haven't played around with it to know how it works in practice. I'm not planning on ripping Martini out and replacing it, but I don't think I'd choose it again for this sort of thing.
No. Nothing will happen. The C bits of the runtime will be rewritten in Go and assembly. So instead of assembly, C, and Go, the runtime will only be Go and assembly. 
I am looking at beego for an api. I love the extras, especially performance monitoring. I am torn between beego and go-tigertonic. Though, I am leaning to beego due to the super active community.
The [goandroid](https://github.com/eliasnaur/goandroid) toolchain contains patches that make this possible, and like others have already said gccgo might enable this as well.
Oh sorry, I misinterpreted your questions. I thought you were saying that a group of OS threads can only run on a single processor. You are right, one thread cannot be running on two different processors simultaneously. One thread cannot simultaneously run two coroutines.
Don't have to be a master at the moment. No one has done anything close to what I am proposing. So you would be the master by default, even if what you propose isn't "the best", because there is no one else doing this. The other bonus is that there is not really anything out there like this in ANY language, as far as I could find. So make sure your host can support being slashdoted ;-P
Go has a lot of C in its lineage. It is very bare bones and it does not prevent you from shooting yourself in the foot. It does however, through goroutines and channels, make writing safe concurrent code really easy.
In addition to what stcredzero said, the plan's always been to deprecate/remove GOMAXPROCS, once the goroutine scheduler is smarter. Part of the Go philosophy is that knobs/tunables are bad and things should be automatic. But GOMAXPROCS == 1 has advantages still, sometimes/usually, depending on the program. 
This
Thanks for playing the game of dream course. There's plenty of really feasible things here like the whole user-management part... quite easy when you know what you do. Using APIs may surprise you. I admit I don't know much the technology to push iOS notifications but I shall find it somewhere. However, what surprise me is the point with databases. Not because it's hard or whatever but because of "Postgres or Riak but not MongoDB". Could you elaborate?! I regularly use MongoDB as a NOSQL "caching" system and it works just great. I agree on MySQL deficiencies in production though.
On 1, I haven't actually had this problem yet, but I imagine that if you have two projects that must use different versions of the same package, the easiest solution would be separate GOPATHs.
1 &lt; GOMAXPROCS &lt; runtime.NumCPU() has advantages as well. I run a lot of CPU intensive code. If I'm running on my laptop, I'll often run at NumCPU - 2 so that my computer doesn't slow to a crawl otherwise. Also, if I'm running on a shared resource, it's nice to be able to set a specific number of cores so that another program can run on the same node (if I don't need all of them). Also, all of my concurrent codes run faster with GOMAXPROCS &gt; 1. It's excellent how easy it is.
Spend at least a few paragraphs reminding experienced programmers that Go has `struct`, you don't need to build all your data structures out of hashes. Like you do in, say, Perl.
I have my game server rewritten in Go now. I took more and more shared things and gave each goroutine their own. Now, I have to fix bugs. 
Yes, that definitely can be a problem. One would hope that the maintainers of the packages wouldn't break your stuff that way, but reality is often different from the ideal. In Juju, we use Roger Peppe's godeps, which keeps a record of the specific commits for each external dependency, and can update the various branches as necessary. We really only ever need to do that when going back in time to an old release branch that needs some fixes. Most of the time, head of each branch just works. We also wouldn't need that if we were more careful about versioning our external repos, but I think because we have godeps, we've had less need to do so.
Hi, thanks for posting our project here. It's really exciting to see so much interest. We're kind of new to go, so if anyone has time to do a code review, we would appreciate it. Also, if you're looking to contribute to an open source project..
Interesting because we went through exactly the same process with [botbot.me](https://botbot.me/) where we rewrote the [realtime endpoint](https://github.com/BotBotMe/botbot-eventsource) in go.
I'm not changing GOMAXPROCS, but I am spawning goroutines and waiting for them to complete in such a way that I am handling part of my processing serially and part of it in parallel. 
All abstractions are leaky, and we as a field aren't yet good enough with multicore parallelism to prevent abstraction leaks -- even at the hardware level! Hardware performance optimizations are seemingly leaky at a fundamental level.
On choice of database: I have nothing against mongodb or myself, it is just that tutorials for using go with those are numerous. Just wanted the less popular/ well known alternatives to get some love too. Edit to add: Btw, do you have any concrete plans for these tutorials - when do you plan to start, etc? Now that I have laid out the dream course, I'm keen!
gorilla/mux
I don't think the C compiler (6c) is going be retired, I think it's used for CGO. What's happening is that the Go runtime is gonna be re-written (converted, really) in Go.
Thanks. I can't take credit for originally writing it, that was Rodrigo Moraes, but i have been maintaining (most) of the toolkit for last couple of years.
We are using go to host thrift interfaces for back end services. It works pretty amazingly.
I'm trying to build something like this. What did you do for search? Are you planning / may you open source it or at least the search part ? Or, if not, give me advice on how to accomplish the search part. What algorithm did you use for the search? Thanks in Advance!
I don't see which part of cgo would or could use 6c. cgo relies on gcc/clang and a number of hacks.
We are mostly using Martini, but looking at this thread, I will play a bit more with net/http and gorilla. Martini is nice, but the contrib middlewares don't always play well together, and we often write our own.
cgo needs 6c to create glue between native-ABI C code and Go ABI C code.
Its role in cgo is trivial and can easily replaced by assembly. 
Not too sure about the lightweight part (might appear so from the API, but it does a lot of heavy lifting to give you the magic.)
A Go framework for developing HTTP application rapidly 
I see that for each recipient you fire off a go routine. All at once. This is a bad idea. You will likely overload the SMTP server with a large enough number of recipients or make it run out of sockets. You probably want to rate limit things and make sure that not more than N number of SMTP connections are open at any time. 
cool. thanks for the help.
Don't. There needn't be a *heated discussion*, because that was the end of it. &gt; What's the "standard" or "recommended" way on handling those import paths? Use abs paths &gt; Should libraries be written in one style and standalone apps in the other? No, that's madness. Be consistent.
The whole thing started because I do have my code in the $GOPATH, but he doesn't. I don't think there's a workaround for that so everyone can be happy.
Might be useful, might be over-engineering, over-architecting. 
At the end of the keynote, Pike said that there won't be more changes in the language, right? And that there aren't plans for generics either, is that right? I think that the language can get some improvements, for example on dictionaries (it would be awesome to have dictionaries for types that suport the "Comparable" interface or something like that). 
Upon trying it, the relative import of library B in library A breaks when some application uses library A. (sadpanda). What is the best way to manage this dependency? 
Spf13 created the exact same thing: https://github.com/spf13/viper
Wouldn't creating a daemon service in the other language and passing the data to the process be more idomatic? 
I took over a project with plenty of relative imports. I eliminated those rather quickly, for one particular reason: relative imports break quite a bit of the tooling, IIRC I had issues with go test -cover and/or go tool cover, and gocode refused to do any autocompletion with code from relatively imported packages.
After playing a lot more with net/http, it's just amazing. But for a (relatively) bigger project, i got stuck with code organization issue. Don't know if there are some best practices about it or not, but if so, please post some resources.
I'd say Go is a great second language. Teach Python or Lua first, just to get across the idea of for-loops and all that, then in the second semester, use Go to teach about the stack v. heap, static typing, etc. 
Along with all the other reasons give for "don't" - some handy tooling, for example oracle, does not play well with relative import paths.
This is backwards. Teach stack, heap and static typing first. Looping in go has the same fundamentals. you are just able to accomplish more with a single statement but different semantics. Basic c is still a good foundation for all programming I believe.
Putting too much stuff up front will discourage students. Students need to learn those things eventually, but you can push it off for a semester or two. 
A language that is nor purely imperative (or OO) is better for basics, because it doesn't lock the students in one way of thinking. So scheme or ML are great imho.
I don't believe there's any way to do this. Maybe some more context as to why you want this and we could provide some direction. Generally speaking you run your ruby code with the ruby interpreter and compile your go code with the go compiler and narry in betwixt do they meet.
That would be a transpiler and it's very unlikely you'll find something like that for Ruby -&gt; Go unless you write your own... and good luck with that, because Ruby would be quite complicated to transpile to a static-type language like Go.
Save yourself the world of pain you will experience if you attempt to do this.
CPU caching and prefetching is very, very fast, so my naive guess would be that slices are much faster. Other people seem to agree: https://groups.google.com/forum/#!msg/golang-nuts/mPKCoYNwsoU/tLefhE7tQjMJ If you feel like it, you could abstract the underlying container away(list/slice), and then compare both in a benchmark ;)
Yeah, benchmarking/profiling would really be a good way to answer this, but I like Dave Cheney's simple response in that post, "Always use a slice." :P. Thanks 7sins!
&gt; "Why would that be" "Do not communicate by sharing memory; instead, share memory by communicating." 
One additional thing to keep in mind is that Go's linked list can't be serialized via gob encoding due to the private variables. If your application is likely to serialize, using slices would make your life easier. Off topic, the fact that the standard [errorString](http://golang.org/src/pkg/errors/errors.go) can't be serialized is really annoying.
Media is only required to implement GetDuration() so any type that implements GetDuration() is a Media interface even if it doesn't have Source. I've used the factory pattern in go a few times, but generally you have to explicitly declare everything you need to use in the interface.
 type MediaFile struct { Source string } type AviMediaFile MediaFile type Mp4MediaFile MediaFile There is no subtyping in the classical OOP sense, so you are not really sharing code here; you are just creating new types that have another underlying type. What you want to do (share some code between several MediaFile types) can be done with struct embedding: type MediaFile struct { Source string } type AviMediaFile struct { MediaFile } type Mp4MediaFile struct { MediaFile } Then you can use the embedded MediaFile, explicitly: func DoSomethingWithSource(mediaFile MediaFile) { ... mediaFile.Source ... } DoSomethingWithSource(avi.MediaFile) DoSomethingWithSource(mp3.MediaFile) But, better yet, you would have an interface for things that have a source and perhaps other media-related stuff, and your concrete type values could be used as this interface values _implicitly_: type MediaFile interface { Media // interface embedding; all MediaFiles also must be Medias Source() string } func BaseMediaFile struct { Source string } func (mf *BaseMediaFile) Source() string { return mf.Source } type AviMediaFile struct { BaseMediaFile } type Mp4MediaFile struct { BaseMediaFile } func DoSomethingWithSource(mediaFile MediaFile) { ... mediaFile.Source() ... } DoSomethingWithSource(avi) DoSomethingWithSource(mp3) As for your `New` function, looks pretty Goish to me. In the standard library, the `net.Listener` case comes to my mind. You have a common interface [`net.Listener`](http://godoc.org/net#Listener), that several types implement: [`net.TCPListener`](http://godoc.org/net#TCPListener), [`net.UnixListener`](http://godoc.org/net#UnixListener) (kind of like your `AviMediaFile`, `Mp4MediaFile`). Then you have the "factory" function [`net.Listen`](https://code.google.com/p/go/source/browse/src/pkg/net/dial.go?name=release#248), whose implementation is pretty much like your `New`; it returns a `Listener` interface value, just as your function returns a `Media`.
Right. I wasn't sure how to get access to `Source` if it's a `Media` type, because `Media` doesn't imply having a `Source` property. That's why it felt weird and why I came here to ask.
Oh hey, I'm also working on a media renaming utility, but for music. I'm nowhere near as far along.
Ah, I see. But this isn't a "sharing memory between multiple actors" problem - there's no reason the low-level libraries shouldn't be used directly from goroutines, and act as a *part* of those goroutines. Also remember that the philosophy you cite is based on having simple, fast, sane ways to share memory by communicating. Without good actor communication mechanisms, the idea just becomes a cargo cult doctrine. Within Go, we have channels and goroutines, which make up a fantastic actor model. If you really want to create an artificial barrier between the C part and the Go part by running them in separate processes - erecting a layer of system calls and message packing/unpacking on each side - you will not only fuck your performance and lose any benefit to the low level language, but you will block your own development time implementing a large and complex IPC system in a blind attempt to appease the gods.
I haven't made a whole lot of progress either, but a lot of the Go standard library trivialized the process. It's been pretty clear sailing minus this question; this project is mostly for me to learn Go anyway. Good luck!
s/Ask/Question/ I'm sorry, but I'm allergic to this.
Sorry. Saw something else in the sub with that prefix and thought it might be a convention that wasn't posted in the sidebar.
Thanks for the feedback, these are good suggestions.
Easy solution: keep your code wherever you want to keep it and create a symlink from $GOPATH to your code. e.g. for me, $GOPATH/src/github.com/me/myproject is a symlink to ~/myproject. From my code, all my imports are the full path including github.com. Works great.
Constant challenges with small problems designed to teach one concept. If you're lecturing for more than 2 minutes without forcing your students to "rehearse" what you've just taught them, you're doing it wrong.
Slices are "views" onto arrays. Naive (in the computer science sense, not the insulting sense :) ) use of slices where you use `append` and reslice the array down one element to "pop" will work almost perfectly. `append` has good amortized characteristics for growing the array. It'll be faster, for several reasons, and also more space efficient since you don't need pointers to the next element (which is also a reason to be faster, but a small one). The only real danger is that the combination of reslicing and using `append` will never _shrink_ the underlying array, which is what is "really" consuming the RAM (the slice itself is just a handful of pointers and numbers, no matter how "big" a chunk of the array it is currently representing). If for some reason some stack usually has single-digit numbers of "things", but for one brief moment has a hundred million things pushed on to it, it shall forever consume however much RAM the last underlying array got allocated. If this isn't likely to be a problem, don't worry about it. If it is, use the `cap` the slice returns to decide to occasionally shrink down, bearing in mind you really don't want to "thrash" the underlying array if you keep shrinking it, only for `append` to grow it again. A simple, off-the-cuff heuristic that should work out OK is "if my `cap` is above a certain threshold[1] and I'm going below 1/4 of my current `cap` with my "pop", create a new underlying slice with 1/2 the size and re-`copy` my stack elements into that new slice". Yes, you recopy at 1/4th onto 1/2 the size... you don't want to copy into 1/4th the size, fitting "perfectly", because then you will thrash if the next operation is a "push". You can optimize further if you can make more guarantees about local usage, of course... this is a very generic answer. (You can also play with things like "linked lists of arrays/slices, but you're looking at significantly more lines and more complexity for what may be marginal gain... benchmark and be sure you need it.) [1]: Tens or hundreds should be fine. There's no point screwing around with reallocating an array and copying stuff just to save 6 element's worth of RAM.
Using function as struct member may be an alternative? Simplifies the type system a bit. http://hastebin.com/oziqowajur.go
I knew this would not be a sane approach. But having read the concurrency presentations and reading about the rise in micro service architectures it begged the question. I never appease gods without testing and profiling first; even the politically correct or en vogue ones : ) 
There's a slew of documentation I still need to write, so please hit me up here if you have any questions not answered in the docs.
Additionally, if I just do: ResourceId int `bson:"resource_id"` It works fine.
If you copy and pasted my answer, I am missing a closing " on the json:"resource_id" I will edit and fix. You were missing this initially as well.
yup I see it now. Thanks.
Well done!
I like this solution. It's a bit like a pragmatic take on C++ style polymorphism.
great
Agreed in full that industrial strength is overkill, but when learning a language I like to do it in the most canonically and idiomatically correct way I can just for the practice. Its mostly because issues like this come up and then I actually learn something new :)
I haven't measured lately, but here is [one fast solution](https://github.com/karalabe/cookiejar/tree/master/stack). Regarding efficiency there is also the question, how you are going to use it. Depending on the use the implementation can vary a bit.
HackerRank or CodeEval
https://projecteuler.net
You shouldn't be afraid to read the std library code. It is extremely approachable and is a great source of engineering ideas. This alone is my number 1 thing I like about go, how easy it is to read through the std library and understand it.
Avoid using channels to communicate fine-grained data. There's a cost to a send, and when you are sending each token separately then it might not be a good idea. The reader probably won't bottleneck, but the hard drive might.
Don't use different types unless there's a benefit... adding an abstraction layer can also add complexity. type Info struct { Filename string Duration time.Duration } func New(filename string) *Info { return &amp;Info{ Filename: filename, Duration: extractDuration(filename), } } func extractDuration(filename string) time.Duration { switch filepath.Ext(filename) { case ".avi": return extractDuration_avi(filename) case ".mp4": return extractDuration_mp4(filename) default: return 0 } } It depends how everything works together... you may need to do: // package media type Info struct { Filename string Duration time.Duration } func New(filename string) *Info { f := format.Find(filename) return &amp;Info{ Filename: filename, Duration: f.Duration(filename), } } // package format type Format interface { Duration(filename string) time.Duration } type unknown struct{} func (u unknown) Duration(filename string) time.Duration { return 0 } var formats map[string]Format func Register(ext string, f Format) { formats[ext] = f } func Find(filename string) Format { f, ok := formats[filepath.Ext(filename)] if ok { return f } return unknown{} } // package format/avi type Format struct{} func (f Format) Duration() time.Duration { return ... } func init() { format.Register(".avi", Format{}) }
It's funny you should mention it, my Travis builds are failing when they attempt to `go get` mgo. I thought it might've been a Bazaar or Travis issue, but maybe not. Their main site also times out.
http://rosalind.info http://exercism.io
Gustavo tweeted earlier that his hosting company had changed the ip address. Could that be the reason? https://twitter.com/gniemeyer/status/465590694401544193
The two "failed" posts I've added to GoUsers: https://news.ycombinator.com/item?id=4159654 https://www.braintreepayments.com/braintrust/gotchas-irritants-and-warts-in-go-web-development 
This probably has something to do with it, although a simple change to IP address should have already propagated from last night.
I sent Gustavo an email about it, it's still early morning for him, but I suspect he'll see it sometime in the next hour or two. Hopefully it's something that can get fixed quickly... he was aware of it last night, but it sounds like he expected it to resolve itself as the DNS change propagated. 
I'm not a fan of Martini, but I have to admit that [the way the `mgo.Session` gets cleaned up in the middleware chain](https://github.com/modocache/signatures/blob/master/signatures/database.go#L62) is pretty handy. Some feedback: * `fetchAllSignatures` has unchecked errors * `GET /signatures` with an empty result set probably shouldn't render `null` as the response. I've run into this one a few times and have had to explicitly instruct Go to distinguish between `nil` and empty slices when rendering. 
Thanks for the links!
Awesome, thanks for the tips! I'll make some edits.
Great answer. Provided not only the idiomatic approach, but also an example, and suggestions for future improvement. Thankyou.
This looks great after a quick glance. Saved for later reading. I've been looking for a blog post which brings everything together for a REST API, like tests and project structure. Looks exactly like what I've wanted to read for a while!
I was trying to use go for remote controlling devices via ssh but the ssh library doesn't support some older encryption algorithms.
Whoever downmodded dgryski, please don't do that. You know what's better for a programming language than blind advocacy? Honest advocacy. Go will not be advanced by pretending it is already perfect in every way... Go will be advanced by taking an honest look at its current weaknesses, so you can fix them where you can, and perhaps tell people where it isn't appropriate where necessary (i.e., I don't really think Go is ever going to be a great scientific computing language and I recommend against trying, personally). If you close your eyes to the weaknesses, you will never fix them... it's an easy, but fatal, mistake. Blind advocacy is bad because you get people to pick up the language, then they hit a problem you basically promised them didn't exist, then they drop it and never trust you again. Don't do that. Tell the truth; then they may not pick it up until later, when it is ready, or they may hit a problem and table it for now, but at least you still have another chance later. Blind advocacy burns that chance.
Do I need to do anything other than a git pull to update the plugin? I'm a pathogen user if that matters.
I think json and xml serialization with the standard libraries is by far the best thing in Go, ha. Have you tried defining the types that make up the json (like I have done [here](https://github.com/rce/statboard/blob/65d37817d61a255cf449d6a6a760b67a7cec797b/main.go#L44-L59)) and then simply calling `json.NewDecoder(resp.Body).Decode(&amp;data)`? That allows you to iterate over the data just like any other simple Go struct and all the `interface{}` things are done in the `json` package. That's probably the best approach assuming the data is consistent. Also feel free to PM me if you have more problems with that!
Have you read the [blog post about the json package](http://blog.golang.org/json-and-go)? 
I still don't get the appeal of Docker though. Is it sandboxing for security?
Yes, git pull is enough :) For vundle just do a `:PluginUpdate`
Not that I know of in pure Go. However, there are pretty complete ImageMagick MagickWand API bindings for Go and you can use SetImageProperty. See: https://github.com/gographics/imagick and http://www.imagemagick.org/api/magick-property.php#MagickSetImageProperty You'll have to deal with the encoding of the values for the "exif:GPSLatitude" and "exif:GPSLongitude" properties yourself. Be sure to use it with a pretty recent ImageMagick with it. 
I was (am?) building a project that go seemed really suited to, but the lack of having any way to create a GUI had temporarily killed that. A shame there's no real language independent toolkit...
Hmm, aren't most of those for reading/parsing EXIF, not for adding or writing out new tags?
"havy"? I'm hip to this lingo. I assume that it is not the urban dictionary's definition. Maybe it is "have you"? Can someone confirm that for me? Taken as "Where have you tried to use Go but failed?", I think it is a good question to raise. I've not tried it out of networked services talking over tcp based protocols really. It shines there. I'd not use it for anything with a GUI (any libs I should know about?), and I've heard it has issues with "mathy" type applications (lack of native matrix support or some such). When I first started, arbitrary json was a pain. The simplejson package (https://github.com/bitly/go-simplejson) helped with that. 
i also don't know of any go library for editing/inserting exif data. Last time i changed some exif data on a folders of jpegs i used the command line tool that comes with the [libexif](http://libexif.sourceforge.net/docs.html) c library, maybe that work around will work for you too. Making a tool for writing Exif data to a jpeg will cost you a lot of time, thats why i opted for using libexif. If you feel like working on a golang solution to your problem, look for the exif specifications also this [stackoverflow answer](http://stackoverflow.com/questions/1821515/how-is-exif-info-encoded#answer-14115795) might get you started. Good Luck!
Just as a note that one of them is 2-years old and the other 1-year. The Atlassian is quite a good example why you wouldn't want to use Go; i.e. if your majority of code base is already in some other language, and everyone else is familiar with that other language. The reinventing is still valid to some things, but it is getting better year by year. Regarding gotchas and stuff... every language/library has them.
godoc.org if pretty good to search for packages. There are quite a few listed on there.
That's understandable. For what it's worth this article might help with JSON that isn't flat out arbitrary but inconsisten: [JSON decoding in Go](http://attilaolah.eu/2013/11/29/json-decoding-in-go/)
You don't necessarily need to create types to do the difference. You could have a `func Duration() time.Duration` as a field in your MediaFile, which you set in `New` depending on the extension. type MediaFile struct { Source string duration func(string) time.Duration } func (m *MediaFile) Duration() time.Duration { return m.duration(m.Source) } type Media interface { Duration() time.Duration } func New(filename string) (Media, error) { var durFunc switch filepath.Ext(filename) { case ".avi": durFunc = aviDuration case ".mp4": durFunc = mp4Duration default: return nil, fmt.Errorf("extension %s is not supported", filepath.Ext(filename)) } return &amp;MediaType{ Source: filename, duration: durFunc, } } func mp4Duration(src string) time.Duration { // ... } func aviDuration(src string) time.Duration { // ... } Also, nitpicks: * should skip the `GetXxx` and just write `Xxx()`. See http://golang.org/doc/effective_go.html#Getters * shouldn't capitalize error strings.
In addition to henryheikkinen's point, you may also want to make sure you know what json.RawMessage is and how it works, which has saved me before, and you will probably get a good response if you isolate the problem down to a test case and post something here on /r/golang asking for suggestions. However, I do agree that it is not perfect at the moment... in particular, it really doesn't like one of my favorite patterns, the "distinguished key", which uses this structure: {"type": "message", "author": "...", "date": "..."} where a key in the object itself identifies the type. I still don't have a _slick_ way of dealing with that. You can unmarshal that into a struct with just the value "type", then go from there, but that's fully parsing twice, which bothers me (and I occasionally have JSON of a size that it bothers my program, too, though not yet fatally). I haven't tried any of the other approaches to see if they are any better yet... this is not yet anywhere near my biggest problem at the moment.
Just use a slice: type stack []int func (s stack) Empty() bool { return len(s) == 0 } func (s stack) Peek() int { return s[len(s)-1] } func (s *stack) Put(i int) { (*s) = append((*s), i) } func (s *stack) Pop() int { d := (*s)[len(*s)-1] (*s) = (*s)[:len(*s)-1] return d } Use it like this: http://play.golang.org/p/5LdPGqpdt0. If the pointer stuff annoys you, you can do the same by storing the slice in a struct: type stack struct{ vec []int } func (s stack) Empty() bool { return len(s.vec) == 0 } func (s stack) Peek() int { return s.vec[len(s.vec)-1] } func (s stack) Len() int { return len(s.vec) } func (s *stack) Put(i int) { s.vec = append(s.vec, i) } func (s *stack) Pop() int { d := s.vec[len(s.vec)-1] s.vec = s.vec[:len(s.vec)-1] return d }
Great first effort! Needs a bit of editing, but otherwise really great material. I almost wonder if it may not be better to make it in Mandarin (or Japanese for the anime fans ;-P) and use subtitles... That way people won't get hung up on accents and other nonsense... Good work bees!!
short story: I dont think there are... there are a couple of projects around but they don't seem to move that much. i think it'll take a while before we see complete libs for gamedev in go... but it'll eventually happen. We need some more gamedevs involved with Go with time available to write code in Go with an OpenGL binding as only dependency (maybe an audio lib too). As much as possible should be implemented in the Go side, physics, texture and model loaders, vector/matrix stuff. I would love to work on something like XNA for Go. It will take a couple of projects that show that "it can be done" before we see real movement and interest from gamedevs.. Go is very server side oriented at the moment.. client side, not much interest... I am trying to do what I can in my very limited free time plus I am not a developer used to work on open source. Go has the same problem on the GUI side.. and there as well, I dont think starting to bring in bindings over bindings and dependencies is the solution.. again should be an OpenGL binding and a WPF/QML re implementation in Go. 
So create a series of decoders and have logic to decode at each level? I guess it's not horrible, but it's a lot of code compared to the simple case in ruby, python, or clojure. I'm used to having a lot of convenient automatic magic happening around this.
Yeah, pretty much. It's not like some good DSL could be but once it's written, reading and manipulating the data is simple and clean.
Indeed, they are a bit out of date. However, I haven't found any other case studies for failures. If anybody has more detailed blog posts for deployments that didn't work, I'll be glad to add them.
Very nice! Well done!
I use this for SDL2: https://github.com/veandco/go-sdl2 And this OGL wrap http://godoc.org/github.com/chsc/gogl/gl33
The "net" package has everything you need. On one app, make a server, on the other app, make a client that connects to the server. Then send your bytes over the wire. http://golang.org/pkg/net/
You can write a web service that listens for a POST request or using web sockets or something similar to torrent. Look at https://github.com/jackpal/Taipei-Torrent
&gt; Go has the same problem on the GUI side Well, at least there's some development there with [Go-QML](https://github.com/go-qml/qml).
I checked that out, but as far as I could see it didn't have anything for contacts: https://code.google.com/p/google-api-go-client/source/browse/
A file transfer, might be helpful in code level: https://github.com/Unknwon/rpp/tree/master/cmd
Still supporting OpenSSL when LibreSSL will be portable and be handled by a competent team is not really the best idea. 
It's available for OpenBSD now but other OS support will come soon.
AngularJS.
Also, LibreSSL should be largely API-compatible with OpenSSL so updating the wrapper to support it shouldn't be a big deal.
Have you tried go-qml?
That SDL binding looks really good, and also active. Very cool.
The "Haunts" one seemed like a case of someone picking a "new" tech with no regard for the rest of the team, future maintenance or whether it was suited to the task (libraries &amp; tools).
They have been working on this for at least 4 months, also LibreSSL doesn't work on Linux yet or windows or anything else besides OpenBSD pretty much.... 
I'm impressed by the monitoring and error packages. With monitoring, what kind of overheads (CPU time and memory) are introduced by the call to `Task()` etc? Obviously you wouldn't do it in a tight loop, but some benchmarks would be cool. Maybe also a demo on how best to prepare this data for writing to statsd as gauges and counts etc. I assume it does but I'll ask anyway - does it play nice with goroutines? Also, defer mon.Task()(&amp;err) very clever, I like it :)
Don't forget to lock threads if you're going to run the program on more than 1 core.
Which ones are you missing ? Assuming they aren't insecure we can add them.
fantastic project I know.. but, it's bringing in Qt as dependency.. and that's a HUGE one both at compile and runtime. Building on Windows was a total pain.. not because of the Go part that was flawless, but I had to fiddle with more than one .h in Qt to make it finally compile... trying a couple of Qt versions.. and we're talking about 900Mb of SDK here. I think Go needs something LIKE QML, but implemented in Go.. not yet another binding to a C/C++ monster... In my opinion the Go team and community did a fantastic job focused at what their experiences and needs are... they are the "server, services, cloud" guys... it's now up to us, the "client desktop" guys to come in and do our part, not by binding (only) but by writing idiomatic Go code and libs that compile fast and have minimal (or zero) dependencies. 
You might like http://godoc.org/github.com/mitchellh/mapstructure.
How do validate forms in React.js? I mean it is not impossible but so much nicer in angular.
Here's the result of my work: https://github.com/pcn/gonetact I'd love a code review, because it's not done, but it's already got a face only a mother could love.
The go compiler error message is heavenly compare to clojure's.
Looked quickly: * The project is not go gettable. * The import paths aren't standard. * Why `git-go-something`? Why no just `something`? * You shouldn't reload/reparse templates at each request[1]. * You should render/execute your template on a byte buffer, then copy that buffer to the http.ResponseWriter. Otherwise you will lose either IO errors or template errors. Either way, a bad idea. [2] [1]: https://github.com/jadekler/git-go-websiteskeleton/blob/master/app/user/view.go#L26 [2]: https://github.com/jadekler/git-go-websiteskeleton/blob/master/app/home/home.go#L20
+ lead dev having to leave half way through. + way too optimistic with money. + failing to learn how to manage projects in Go.
Communicating with the Java EE world is painful. Accessing JAX-WS Webservices is painful. Enterprise like XML processing is a general problem by many languages. JSON-RPC works pretty good. (Relational)Database access with serializable transactions is also a bit hacky. Realizing an interface to ActiveMQ or RabbitMQ takes a lot of time. The most problems I had is communication with other (SW) environments.
Oddly enough, this was the first crack I had at it (it's a very JS thing to do and that's what I [sadly] write most of my professional code in), but I was worried that the `init` function random call order would invalidate this solution. Specifically, I thought I had to call `mediaFileCreators = make(map[string]MediaFileCreator)` before registering any implementors with it, and I thought I could only call the `make` function in an `init` function... and you can see why I incorrectly discarded this solution. I don't know why I didn't bother to try it before just automatically assuming it didn't work, but it's good to know I can go this path! This definitely makes the most sense to me, since it *is* an "extendable" dispatch and `switch` statements have always seemed like the solution statically typed languages use for that case (pun not intended). Thanks!
in fact it's quite simple there : http://www.clever-cloud.com/en/pricing.html
We are combining Angular.js with reactjs for the performance parts. 
I was thinking of doing some rest apis in Go instead of some Java EE beast but at least back then even connecting to Oracle database was a lot of trouble in Go. I don't know what's the status nowadays though.
None, but my site isn't that large and more of an interactive website than an app. All features can easily be programmed in Go.
A few questions more if you don't mind - the choice of React.js was conscious I assume. What type of architecture are you using (single page app only, server-side rendering only or a combined approach - that'd be super insightful if you could share some your design decisions)? I personally, don't fancy the SPA approach - but being a web newbie, I don't have much experience with React, but I'm attracted to it. I'm planning to use react.js for components (like a gallery with infinite scroll or paged) but fall back to angular for forms. Also, if you're authenticating, are you using (secure) cookies or a token approach? How's that working from Go?
Nothing other than not using `camelCase` which is pretty much the standard comes immediately to mind. Also I sent you a pull request on the JSON issue!
I've found the section on dependency management from SoundCloud [Best Practices for Production Environments](http://peter.bourgon.org/go-in-production/) quite interesting. 
It's not only easy, you have to do it only once. There's no reason to use relative paths, even for fiddling around.
+1 for this. It is what I do for a command-line tool that sometimes needs visualizations. There is such a robust ecosystem in Javascript for graphs and visualizations, and starting a web server in Go is trivial. (This is what [Convey](https://github.com/smartystreets/goconvey) does too) Also, maybe Go's pending support for NaCl will allow the creation of [Chrome apps](https://developer.chrome.com/apps/about_apps) (or even just plug-ins). I don't know much about the Chrome/NaCl ecosystem unfortunately.
The nice thing about Go on the server side is that it totally doesn't matter what front end you use. I've used Angular and really like it, but you can use whatever you want. I am working on a personal site that's just going to use Hugo - http://hugo.spf13.com/ for a statically generated site and close to zero javascript.
the same as why CGO may not be robust or efficient - function call overhead
1. Sure it is. go get github.com/jadekler/git-go-websiteskeleton 2, 3. This skeleton does not aim at being a 'package', and therefore does not sit inside /src/github.com and nor do I recommend using go get. The go get use case is for importable + updateable packages, not standalone applications. This project does not recommend that method and it should not reside in github.com - it should sit under /src, which would mean that the import paths are correct. The only thing 'non-standard' about them currently are the lack of github.com, non? 4, 5. These are valid concerns - thanks for the links. I'll add that as a question and look into it Thanks again for your feedback, it's very valuable.
Yes, but (and please correct me of I'm wrong! I'd like to be) qml gives you more of a canvas that you can draw primitives on, but not an easy way to use system themes and look native.
I'm really looking for a native, themeable toolkit. 
Theoretically, it is possible, and there are successful cases (nuitka: python -&gt; c++, but still needs python library to run). But I think your example is not applied to this case, deigning a programming language that can be translate to another one is way much easier than designing a translator that can translate a matured, rich-featured language to another. I suggest don't even think about doing a such job, cause translate an interpreted, dynamic language to a static, compiled one need to much work to do, it's not worth it.
I've been using Angular for a while but lately I've been experimenting with Backbone + React for a few projects that require large amounts of DOM modifications.
Yes. I'd actually like to see the encoding/json package break out its internal implementation of that and offer it separately... I think I ought to be able to use the workflow you're implying without leaving the encoding/json package itself. Then you wouldn't have issues with deviations between an external package and the internal implementation.
See also: "Defmacro for C: Lightweight, Ad Hoc Code Generation" in http://www.reddit.com/r/lisp/comments/25f6nz/els_2014_proceedings_pdf/
With efficiency, there's a possibility the read/write operations may result in disk read/writes. Also, file access contention is likely to handled by file locking, which may not be particularly speedy. And there's also a possible issue of hosts having to traverse the subfolders under the '/circuit' folder, which may impact performance. I don't think it'd be difficult to test this. I'm keen to give Go Circuit a go
for me the "function call overhead" per-se is not a real issue at all - I just tried to mind-read /u/fungussa
I haven't had the time to see the detail of the implementation of the circuit, but isn't it possible to use some kind of (ramfs/tmpfs) for the /circuit folder? 
I don't agree with the 'not robust'. The file-system concept and API's have been around for quite some time, and FuseFS - which is uses to 'create' the file-system, has been around for quite some time now, and it works very well. I don't really see the problem on this level. FuseFS is a LOT older and more mature than Go... And efficiency - yup there is some overhead, but every distributed system has overhead. The moment you need a distributed application, this overhead should be minimal compared to the gains you get by making it distributed. Would there be more efficient mechanisms? Absolutely - but then you would need to implement libraries and bindings for every language out-there. This uses an API every language out-there knows, which makes it very useful. Also let's not exaggerate the overhead, there is network i/o involved, which on it's own is a lot more overhead than some local function calls - even if they add a few context switches - it will be nowhere near the cost of sending data over TCP (or UDP if they really really wanted) - which in the end any distributed mechanism will use as a backend. Also - put things in perspective a bit. REST API's is something nobody cries about anymore, and that uses HTTP as a transport layer, which adds way more overhead than a simple file-system call. Now I don't know what the communication backend uses, it's possible they do use a REST api internally, but even then, this shouldn't be a real problem imho.
Ooo, thanks for spacelog. I've poked around at a number of logging libraries and haven't liked any of them. I actually implemented my own `GetLogger`-ish thing around an existing log system; it looks like I can rip out that code now and replace it with this. OpenSSL is also going to be pretty useful.
I'll definitely look into it. Is it good for quick prototyping?
I wasn't questioning the robustness of the FS.
&gt; Using the filesystem for IPC doesn't sound like it would be robust 
So here is a question I have about interfaces and the Go paradigm. I have been playing around with making a game server in Go. There are many different messages that the server can receive. I have created an interface called 'GameMessage' that is the type I use for the channel into the game. I then do a switch on the type of the message in order to route the message to different handler functions. This design seems very C++/C#/Java/etc style of design (that is my background). Is there a more 'Go' way of handling the scenario of many different input types and values? I could try to create separate channels for each message type but I think that I could have maybe 10-20 different message types and that seems like a lot of channels. Another thought I had was to have an interface with a 'HandleThisMessage' function that I could pass in the current game state. Then the network handler function just calls each messages handle function. Does anyone have thoughts on how to handle this? Or does my current approach work? 
That's interesting. Does it have anything to do with legacy SSL support? The recent post about CodeMoney's FOSS offerings has an OpenSSL wrapper for that reason: https://www.spacemonkey.com/blog/posts/go-open-source That still doesn't get you an alternate SSH implementation, but perhaps it's a start.
I added a quick doc mention of the Stats method.
Yeah, it would obviously no longer have persistence. But it's as simple as: mkfs -q /dev/ram1 8192 mkdir -p /ramcache mount /dev/ram1 /ramcache 
Best site I know: http://codeforces.com I actually asked for Go and they added it!!
Take a look at the html/template package http://golang.org/pkg/html/template/ it should help you do what you need. A really quick dirty example: http://play.golang.org/p/s8hOuzI-3F
This is not really a very good use of interfaces. Even in C++/C#/Java etc, you wouldn't want to check the implementation type of an interface and do different things based on the type... that defeats the purpose of the interface in the first place. You MIGHT want to have a method that returns a flag of some sort that tells you how to handle the message, but even that is not really a good design. I'd have to know more about what kind of messages these are and what is expected to happen when they're handled to know what to suggest.
~~http://www.reddit.com/r/golang/comments/1p0bwd/htmltemplate_in_go_12_brings_comparison_operators/~~ http://stackoverflow.com/questions/14179359/conditional-statement-in-gae-go-template-package
I like Ember.js, but angular is great too. Often, though, I'll stick to small module stuff along with require.js - angular and ember are great (as are other MV-somethings), but not always necessary.
thank you for help me, I modify this code to fit with what I want to do, i want get value from URL if I submit *Text1 for example* I get this result *&lt;option value="Value1" id="Id1" selected&gt;Text1&lt;/option&gt;* http://play.golang.org/p/32uiOuZhCC
One small suggestion: create some more robust examples around your products. Reading the [spacelog](http://godoc.org/github.com/spacemonkeygo/spacelog) godoc, for instance, is pretty unenlightening. Just a thought. Thanks for open sourcing! =)
Here are a few other good resources for learning Go interfaces: http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go http://www.onebigfluke.com/2014/04/gos-power-is-in-emergent-behavior.html
I like it because its the only framework that makes sense to me structurally.
Spacelog looks really nice. I have been looking for a nice, unobtrusive buffered logging solution, and was about to roll my own. It doesn't work for me though because we run on windows and linux, and it pulls in a dependency on log/syslog which is not implemented on windows. Would it be horrible to pull the SyslogOutput stuff into a conditional file that is ignored on windows?
Glancing through the source code here, it's a perfect bite-sized pull request. It is not deeply used throughout the code and at first glance should be easy to pull out. I can't promise you won't hit a minor snag or two, but it shouldn't be hard.
The use of FUSE implies it's a virtual file system. FUSE can offer anything as a file system, it need not involve disks or files at all. If one wishes to critique the use of a file system, given that FUSE is involved one would first need to establish that actual disk files are being used. I'd bet not.
There's *usually* a better way to use interfaces than doing a big type switch. Not always. The two uses in that file could have been done without type switches, but it would have required additional methods on the interface that they probably decided were better not to expose to the consumer.
Yeah, I definitely did better with examples for the errors and monitoring packages. I'll give that a shot in a bit
Thanks for this. Interfaces have been confusing me for a while. This cleared up some my misconceptions.
pull request made :)
I wouldn't brag about "260 lines of code", when you had to install 7 packages, which probably included tens of thousands of lines of code under the covers.
Thanks for your kind compliment! 
This site is amazing, I'm happy that good advice is being perpetuated this way (although perhaps to the dismay of site's creators), and on a more personal note I'm very happy to see I am leading! That being said it's quite unfortunate e-mail addresses are not redacted out as a measure against web crawlers. 
Some of this is also covered here: http://blog.golang.org/laws-of-reflection
I always forget that post has interface stuff in it. 
Very glad it helped someone. :)
Well, [this was harsh](http://shitgonutssays.tumblr.com/post/81500648864/on-the-results-of-careful-deliberation-and-voting). What's so wrong with gopkg.in that warrants this? :(
like [this](http://play.golang.org/p/ynjyBaO9zg)?
Check out the tomb package: https://godoc.org/launchpad.net/tomb
thank you ! this is probably the best one which matches what i was actually looking for. from the website "Codeforces is a project joining people interested in and taking part in programming contests" very much appreciated.
This issue is on our radar and we're considering how we can approach the goal of building a single binary. Thanks for your thoughts!
I would do something like this: http://play.golang.org/p/rvkqfjbHPT Because I like to receive input on a channel and not keep recreating the worker goroutines.
I would use a select statement with a shared channel. Close the channel and all go routines will get the signal. Use that to set a bool or whatever to shut down the go routine. 
I agree that it is not a useful use of interfaces. I just am having trouble envisioning a better way to handle this. I could possibly try to abstract game messages into just a few message types and have a channel for each. "SetupMessages" -&gt; Login, Make/Join/Leave game "InGameMessages" -&gt; Fly ship, Shoot, Buy, Outfit, Move player, Route energy, etc But then I have very large objects in order to handle all the parameters that those objects will store. Or would you recommend what xuu0 suggested?
Oh no, not another S*S, and of course, it's on tumblr.
Build Qt on windows is a pain, but in my experience I have never needed to do any kind of "fiddling with .h files". Only find the correct build options and wait for like a day.. (my laptop is pretty old ) I think that the main problem with writing a new toolkit just for Go is that it will take years to even get stable and work, but will do practically the same thing Qt does. 
Why do you defer the `wg.Done()` via an anonymous function rather than defer the direct call?
It sure does. Depending on sizes of files you may need to send files in byte chunks and tell the receiving computer how many bytes to read. 
Cool, I didn't know that.
well, imagine if the Go team thought on those lines: "It'd take years to even get stable and work and do practically the same things C++ does" ;) luckily for us, they did not. 
thank you, it's work my example http://play.golang.org/p/wcFFcSulb-
But it doesn't do the same. Go is a completely different beast and was written with specific [purpose](http://golang.org/doc/faq#What_is_the_purpose_of_the_project). 
Having just read carefully through all the linked threads, I conclude that this really should be renamed "Slighty snarky comments regular go-nuts contributors occasionally make". Hardly worth the "Shit" label, really.
Does the package come with examples for that? Probably would be a valuable tutorial, even beyond just this framework.
and with some signal handling: http://play.golang.org/p/cVTi5YAa2J
What's the performance of spacelog? Are there statistics similar to seelog? https://github.com/cihub/seelog/wiki/Performance
um, [toml](https://github.com/BurntSushi/toml)?
I have a dumb question: If I equate Go's interfaces to Python's duck-typing, am I misleading myself? Because this really sounds *a lot* like duck-typing where I just have to declare some type of duck ahead of time.
Note: your use of the `WaitGroup.Add` introduces a race condition. You should call `Add()` *before* starting the goroutine
Here's another example http://play.golang.org/p/2-_rJgeY-S (doesn't work on the playground)
Interesting benchmarks but without the wrk command you ran, it is impossible to reproduce the results locally. I would share software versions and commands used to run the benchmarks so we can download the code and run it for ourselves. 
In fact, it's _so much_ "ways of expressing the same thing" that trying to draw some sort of distinction between "sync" and "async" IO is a waste of time, really, because there _is_ no difference in the way that most developers seem to understand it. It's a distinction the Node community did not create, but they've tried to promote it because the arguing about the non-distinction gives them a way of trying to make themselves look better by falsely labeling the better alternatives as "sync" and logically leaping from there to "and therefore bad". Regardless of how your code expresses it, while you are waiting for bytes to come in from a file, you can't compute based on those bytes, and therefore all such computations will be suspended until the bytes come in, and in the meantime, the program may do other things. The only real difference is the degree of disruption that your program experiences when having to wait for something. With conventional Node, that degree of disruption is high; stack traces discarded, huge amounts of context destroyed. "Fibers" eliminate a lot of that disruption, but, once the Node community agrees that's the best way to do things the very reasons that they've been claiming up to this point are the reasons to use Node are destroyed, because there's plenty of other things (including, topically, Go) that do those things much better. (For instance, consider the Node community's claim to awesome, mind-blowing performance, and compare that with the numbers you see at the bottom there.) If Fibers are the correct and best way to use Node, Node should not be used. (Unless you're forced to by other external concerns, but the use of Node should then be seen as a negative that you are forced to deal with, not a positive on its own.)
No, you're absolutely wrong. Go code is synchronous, node.js code is asynchonous. The models are extremely different. These words have precise technical meaning, you can't just pretend they mean something else because you don't know what they mean. For regular I/O, Go doesn't even use non-blocking I/O in the implementation (unlike node.js). Only network I/O is polled. 
Is it case sensitive? It seems like it should be case insensitive. I can just imagine a user of my application banging their head against a wall because they have "port = 8000" instead of "Port = 8000". 
At work, my current show-stopper is the lack of industry-quality **SQL driver for Oracle**. Both [go-oci8](https://github.com/mattn/go-oci8) and [go-db-oracle](https://code.google.com/p/go-db-oracle/) failed to convince (got either compilation or cryptic runtime panic errors), and looking at their current lists of reported defects, they seem to lack features and high-performance stability. To be honest, I did not even give a try to the [odbc](https://code.google.com/p/odbc/) driver, as my work environment discourages the use of ODBC (in favour of the native OCI libs). Compared to the builtin driver for Oracle in PHP, or the DBD driver for Perl, or the de-facto cx_Oracle driver for Python, which I managed to get working straight out of the box (compile, install, run), I feel that the golang equivalents lack far behind. Money-wise, my company is unfortunately not going to move to alternate opensource database systems anytime soon...
Yeah, experimenting with multiple hit-or-miss libraries feels like a huge waste of time for small project and a plain stupid idea for larger one. I have a VM at home running Oracle and waiting for me to find or create a Go driver but I'm on the Go far too much. If I ever get around doing that, I'll make sure it stays maintained and supported, haha. We have used Oracle for like decades so there's no way we could switch unless something like Oracle going out of business happens.
First: vim-go is fantastic! I love it! Thanks to the developer and contributors! Is there any way to make it not overwrite errors on the same line? I liked the ability to see errors by going to the line instead of using the quickfix window (which interacts weirdly with tagbar).
ractivejs
/u/lordlarm Is it a student project?
I'm currently experimenting with [Viper](http://github.com/spf13/viper), which does toml+json+xml under the hood. So far so good. I'm not sure of the consequences of its design, since it supposedly supports them all via a unified interface. I *think* Viper makes it possible for a user to swap a .toml file out for a compatible .json file, without your app even caring about the difference. Meanwhile, Viper's companion lib [Cobra](http://github.com/spf13/cobra) is fantastic. Edit x10: Can't reddit today.
No need to get nasty here. I may be absolutely wrong, but explaining to people way normally gets them thinking. As far as I know, the moment is goroutine is blocked on a IO call, the scheduler whisks it away and gives chance to any other goroutine to run on the same thread. In node.js, the callback achieves the same effect. Please correct me if I am wrong?
I used to use XML for configurations, because JSON is just meh for such things IMHO. Luckily toml for Go arrived, and loving it! I especially like BurntSushi's implementation with reflection and all. 
Have added a para to the summary clarifying the point raised by you Thanks for the feedback
The article is updated with the versions
Thanks :-)
How the hell is there any performance hit to defer? Wouldn't the compiler simply optimize it to the bottom?
&gt;runtime.GOMAXPROCS(runtime.NumCPU()) I'd never recommend using all threads on a system with many, you want at least 1 free to do other work.
the function may exit before, it's not that simple
:)
Ah, christ, why do I even bother to come here. I did the Solaris port, I wrote one fucking network poller you're trying to teach me about, I even gave a talk about how all of this actually works. But here you are, giving other lessons and spreading misinformation. As I already mentioned, non-blocking I/O is only done for network I/O right now. Every other system call for I/O uses a thread. Read the damn code before speaking. Begone.
Node.js uses libuv for I/O. libuv uses a combination of polling and non-blocking I/O, and a threadpool to do its thing. The Go scheduler does none of these things for non-network I/O, it uses regular blocking system calls ensuring a thread is always available for running other Go code (in effect this looks like using a thread outside the normal GOMAXPROCS accounting). For network I/O, for every system except Plan 9 Go uses an epoll (linux)/kqueue (BSD, Darwin)/iocp (Windows)/event ports (Solaris)-based poller along with non-blocking socket operations, just like node.js. This is done because it allows to limit the number of threads required at a moment in time to the number of simultaneous connections that exchange I/O at that particular moment in time. Otherwise, you'd have to have as many threads as there are waiting clients. There was a discussion of using a poller for all I/O, in effect making Go's implementation more similar to node.js, but it's not done. Why does all this matter? It doesn't. That's the point. Go is not like node.js, either in semantics and in implementation, and it does't need to be.
Hey schmichael. Could open an issue about this with more detail? We can discuss it in more detail and I think we can find a fix/solution for your option :)
Slapping it in leading every exit point generally isn't too hard.
"every exit point" needs to include every statement that might panic. That could get hard. Then there are cases where defer is in the body of an if, or in a loop. Those couldn't be optimized that way, and they would need to be called in the correct order.
A C way of doing things is having a stack of things to defer bundled into a function so you don't have a big pile of repeating things everywhere.
Almost everything in Go can panic. It's almost impossible to statically prove a statement won't panic. Anyway, the example in the article can certainly panic, there's nothing to optimise. 
http://southpawlife.github.io/tongs/
&gt;Rob Commander Pike &gt;"Aside from that, everybody knows a tab is 8 spaces wide." Except thats not true. Its measured in units of the width of a numeral. Only in a fixed-width font (who uses those nowadays? Wow, flashback to a teletype!) are those the same thing. &gt;-rob is an interesting contrast to &gt;Rob Commander Pike &gt;Syntax highlighting is juvenile. When I was a child, I was taught arithmetic using colored rods. I grew up and today I use monochromatic numerals. &gt;-rob 
I was expecting a little more of a breakdown, maybe some analysis of generated code or something. Mildly disappointed.
Defer doesn't have to create a real closure though. It's bound to that stack frame. It doesn't have to do anything like copying things out to the heap or anything like a real closure would have to in order to survive a stack unwind.
I was just modifying the OP's code.
a loop?
http://play.golang.org/p/q3pUD0vClT
Easy big guy. I was referring to the net poller. How are the network io models (at a low level) different between node and Go then? Which was the part of misinformation? sorry if that's what came out. I wanted to point out they both end up using kqueue / epoll / IoCompletionPort / etc for network io. 
Eek. I use `defer` for readability, guess I'll have to think twice about doing that.
using defer is only noticeably slower because the example does very little work in each function. If you did some actual work in the function it would still be slower, but the difference wouldn't seem so significant.
Worry when the profiler tells you to worry, and not before.
It's possible to optimize in most cases. The current compilers just don't do it yet. It's one optimization on a long list of optimizations the current compilers don't perform. It's probably out of the question until the compiler is written in Go and has a decent IR. I think there are basically three cases. Here they are from easiest to hardest (and coincidentally most common to least common): 1) An unconditional defer. This can be optimized basically the same way compilers for other languages optimize finally blocks, and it can be very cheap or even free depending upon the implementation. 2) A conditional defer (such as one that's inside an if block). This is trickier than case #1 since we might need to track the conditions that led to the defer depending on where the return points are. 3) A defer inside a loop. Here we might need to allocate somewhere on the heap similar to what happens today. Defer inside a loop is pretty uncommon, though, and usually the wrong thing to do.
It kind of sounds like you're not returning your connections for reuse. There's a good writeup on that here: http://jmoiron.net/blog/gos-database-sql/ This could explain why you had to set the MaxIdleConnections so high and why you were making a new connection for each query.
I hope Go's performance matches Java as soon as possible so I can more easily convince people to switch to it, it's such a pain but muh getting work done(because managers like to see lots of lines in a day) and muh synthetic benchmarks.
You're right. I was thinking along the lines of closure vs downward funarg as having to do with capturing the environment, but the latter is an instance of the former, and not itself indicating an upward funarg situation. I was trying to express that it doesn't have to capture the environment in any way ( the defer itself at least, it's entirely possible to capture the environment via a lambda which is passed through the defer and back up the stack, setting the return value by name perhaps ). This is a mostly irrelevant point however. Regarding the actual topic at hand, the loop is pretty much the one time that anything on the heap would *have* to be used for the defer itself, because the compiler might not know how many items are needed. For large types, or types that are always pushed to the heap, the need would be there as well. For anything that isn't a loop, the stack frame can set aside extra space for the closures variable values, and then run them in the appropriate order. I'd say that in most cases `dev-disk` would be mostly correct, that there should be little consequence for using a defer. Figuring out which are those cases, and then handling the non-simple cases makes defer the semantically complex element you are describing. It may also be possible to place all of this into dynamically acquired memory via `alloca` as well, putting `dev-disk` in the clear. The "at the bottom" statement would make sense in this sense.
http://play.golang.org/p/_CtiLD1Ae6
A statement won't panic? Is this because of out-of-memory errors? Seems like with an integer i i++ won't panic
I was just doing some reddit API work myself in go for a small project. The one thing I learned was that the Unmarshall function requires the struct you're unmarshalling into to have exported variable names (upper case). 
&gt; this example of defer in a loop So out of interest, if defer were bound to the current scope instead of the function, *then* it would be possible to do something compile-time right? In this case they'd be more or less exactly like C++ destructors of stack-allocated objects, which don't create any closures.
That was my reaction as well. I don't like the idea of abusing channels for other non-channely things (like a semaphore), but this code example is really a solution looking for a problem that is already handily served by a channel. A channel is also implemented as a mutex guarded linked-list, and its implementation is rather robust, and written in C. The aforementioned Queue type here really is inferior on a lot of different levels. That said, I'm sure there's good reason to want to use a mutex over a full-blown channel, and this Queue example is a rather compact way to represent that problem space. IMO, a more academic example with do-nothing defers might have achieved a solid benchmark, demonstrating the overhead in using defer statements under different circumstnaces.
Solid advice. Never optimize before you measure. Otherwise, you're just making a guess.
`~/D/g/s/b/f/l/test % go version go version go1.2.2 darwin/amd64` Its the same on both my mac and arch machine.
I take the carpet bombing approach, rather than the tactical strike.
If the fields arent exported, the json packkge cant get at them. It follows the same rules as the rest of the language -- it's just a regular package.
Thanks for the info... that was good to know. I had read about Go using threads for blocking IO calls: "The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit." in http://golang.org/pkg/runtime/ But did not have this detailed information about how/when it actually took effect. But I still have a follow up question for you if you are game. Maybe over email?
Whats with all the downvotes? Please let me know so that I am not spreading mis-information
Sorry for my laziness,I agree with you that GOTO is wart in golang
I really wanted to use Go for the work I am doing. But we need really sophisticated image processing libraries (I use OpenCV and PIL), and Go still isn't there. Would have loved to use the built-in concurrency and easy-to-use channels. Sadly I will have to wait.
It's ruby. Thank you, that works.
This is wrong: q.Lock() defer q.Unlock(); Instead, do this: defer q.Unlock(); q.Lock(); Defer does have a small runtime performance impact (as in, it's not "free") but you're unnecessarily penalizing your code by moving that performance impact into the critical section of your function.
Fantastic! thank you to share the code. I'm curious what is the hardware behind http://shooter.io?
It's not very hard to understand. "defer f()" actually *does* something. It attaches a closure to a chain that the function runs on exit. q.Lock() defer q.Unlock() This does that work *after* locking the mutex. It enlarges the critical section during which the mutex is locked. defer q.Unlock() q.Lock() This does the work before locking q. q.Unlock() still runs at the same time it was going to run before, but your critical section is minimized. You don't need to hold the lock before you can defer. EDIT: Formatting
Anything that takes more than a day, management wants to see work being done, and since they're retards all they understand is how big the wall of text is. Also some are so stupid they think commenting is "fluff", "padding" your work to increase your lines, and want it separate.
I think you are right. 
I wrote this little `try` function as somewhat generic wrapper for running a function a few times or until it succeeds. I think it came out pretty neat. Basically it takes a function that returns an error. If the function takes arguments, it can be wrapped inside an anonymous function. Support for recovering from panics should be fairly straightforward to add there. http://play.golang.org/p/5C14MnNi5d
No, you can most certainly determine if a function doesn't panic. The inliner for example, only inlines leaf functions that don't panic 
You're dead wrong. : iridium:a; cat a.go package main // foo will panic func foo() { var p *int *p = 42 } func main() { foo() } : iridium:a; : iridium:a; go tool 6g -m a.go a.go:4: can inline foo a.go:10: inlining call to foo : iridium:a; : iridium:a; go tool 6g -S a.go | grep -A10 'TEXT.*main' 000000 00000 (a.go:9) TEXT "".main+0(SB),4,$8-0 000000 00000 (a.go:9) SUBQ $8,SP 0x0004 00004 (a.go:9) FUNCDATA $2,gclocals3280bececceccd33cb74587feedb1f9f+0(SB) 0x0004 00004 (a.go:9) FUNCDATA $3,gclocalsa7a3692b8e27e823add69ec4239ba55f+0(SB) 0x0004 00004 (a.go:10) MOVQ $0,AX 0x0007 00007 (a.go:10) NOP , 0x0007 00007 (a.go:10) MOVQ $42,(AX) 0x000e 00014 (a.go:11) ADDQ $8,SP 0x0012 00018 (a.go:11) RET , 000000 48 83 ec 08 48 31 c0 48 c7 00 2a 00 00 00 48 83 H...H1.H..*...H. 0x0010 c4 08 c3 : iridium:a; : iridium:a; go tool 6l a.6 : iridium:a; 6.out panic: runtime error: invalid memory address or nil pointer dereference [signal 0xb code=0x1 addr=0x0 pc=0x2007] goroutine 16 [running]: runtime.panic(0x26980, 0x54664) /Users/aram/go/src/pkg/runtime/panic.c:279 +0xf5 main.main() /tmp/a/a.go:10 +0x7 goroutine 17 [runnable]: runtime.MHeap_Scavenger() /Users/aram/go/src/pkg/runtime/mheap.c:507 runtime.goexit() /Users/aram/go/src/pkg/runtime/proc.c:1426 
A heads up to anyone looking at this: the software repositories haven't been touched in 3 years, and were targeting go's weekly release branches at the time, before we even had a 1.0. They are likely to not work at all with the current versions of Go, or work particularly poorly. Their documentation clearly says that the performance of using it was quite bad, and nothing suggests it has improved on its own in the last 3 years. 
&gt; There's a pointer dereference. That wouldn't get inlined either right now. Not everything can panic. You're either stupid or can't read, because that function *is* inlined (as I showed you using two different methods) and *does* panic. This is pathetic. The whole test took 30 seconds of my time. You could have checked yourself before posting, but why check when you can just spew nonsense? Now it seems I have wasted 30 seconds of my life in vain, because even if I showed in two different way that the function is inlined, you still don't get it and still continue to spew nonsense. edit: and now you changed your post to say something else (still wrong), fuck off. 
Well, that does have a pointer dereference, which means there could be a panic, and it is detectable. The inliner must either ignore that (possibly for primitive types?), or it has gotten more lenient. 
Dude chill out. I'm on mobile and misread your post, so I corrected it. 
Why read code and correct your assumptions when you can just continue to guess (wrongly) how it works? 
It's a game server that creates a universe for ships that can attack other ships firing their lasers. This server can receive connections from rendering clients (a HTML5 client exists), the client emits orders to control a single ship and also renders a portion of the universe.
really, I don't care to argue with you, and I don't dive into the compiler source for every question, especially when this is what I was told by multiple core developers, as recently as a couple weeks ago.
Ah, ok. And who said Go couldn't be used for gaming? :)
I remember the discussion the latter came from; he was quite likely just trying to troll people a bit.
But what does that really mean? Does it only online functions that do not do array accesses, since they could possibly panic? And, does it online functions that don't have pointers, since a pointer could be sit to nil?
In general that's a good idea, but in practice it might not be the right choice all the time. The improved ordering you propose relies q.Lock() to never panic, and always return with the mutex locked. Hypothetically, if q.Lock() were to fail to acquire the mutex for some reason, then q.Unlock() might panic or lead to unpredictable behavior on defer (attempting to unlock someone else's acquired lock). And my experience with C++ tells me that panicking inside a defer chain is probably best avoided in Go.
I too thought the compiler would just put it into every exit point of a function, oops.
 type Queue struct { sync.Mutex arr []int } Wait so Queue inherits the sync.Mutex properties? I didn't know about that! Nice. 
Yeah, that would severely restrict what could be inlined if that were the case, and makes the defer optimization somewhat harder. However from the example 4ad posted below and some others, it looks common panics like out-of-bounds and nil pointer dereference aren't counted, and still can inline. Which isn't necessarily bad, but has to be taken into account for a stacktrace. 
I'm a really new programmer so the concept was a great learning experience for me. Initially I thought that the names of the struct variables would have be identical to the json fields, but there's flexibility in the package for case insensitivity, (although it would get parsed secondarily to something matching case, if present)
Yes, the full rules are laid out in the package documentation and http://blog.golang.org/json-and-go
Sure. It's just not clear to me why it's "almost impossible to statically prove a statement won't panic". The two easy places to panic are nil pointer dereferences and array bounds overflow. It would seem that if your statement is doing neither of those, it's pretty easy to won't panic. I agree it's hard to prove an entire program won't panic, but it seems pretty straightforward to prove many statements won't panic.
Running in the jvm means added features like.. security diagnostics monitoring increased fault tollerance 
Also correct. So, I think I just need to clarify what I mean by "general". A "general" algorithm would work for every case that you try it on. For example, array := []string{"hello", "world"} x := 0 y := x + 1 fmt.Println(array[x], array[y]) _We_ (as humans) could reason that the program doesn't panic, but the algorithm that you suggest (throwing out array references and pointer dereferences) couldn't correctly reason about this code sample. It would have to cautiously state that the program _could_ panic. Since the program panicking is a non-trivial property, it is [likely undecidable](https://en.wikipedia.org/wiki/Rice's_theorem) in the general case. So, any algorithm that solves it likely suffers from false-positives or false-negatives. edit: Sorry for misunderstanding what you were trying to ask. What I gather you were actually talking about is why not _just_ prove that simple statements don't panic? That would render it "not impossible". The only reason that we mention impossibility is because it is so difficult in the general case. You can absolutely prove that certain simple statements _will not_ panic - you are correct in asserting that.
History doesn't seem to establish much confidence for any of the things you mention as advantages. 
Your original statement was &gt; It's almost impossible to statically prove a statement won't panic I thought you were suggesting that every statement is hard to prove it won't panic (as opposed to 'it's impossible to prove that any statement in a program won't panic'). I see now that your phrasing is like the halting problem, but the halting problem must consider the whole program. Anyway, glad we agree. 
Yes. It ought to be possible someday to "do something" to optimize this in cases where the compiler can show that the defer is being used that way, and use a rewrite instead of a closure, but at the moment Go probably has more pressing optimization needs. (I mean, it's pretty good, but as near as I can see there's no particular reason the language shouldn't ultimately be able to converge around 1.25x-1.5x slower than C. It's not there yet.)
Yup! Apologies about the confusion.
Don't think about it as inheritance, it's more like automatic delegation. http://golang.org/doc/effective_go.html#embedding
What is a Docker? Edit: Why am I voted down for asking a question on the article?
Just because we haven't got them right yet does not imply we do not desire those features. Security, diagnostics, monitoring, increased fault tolerance are features all serious production systems would want if not required.
Docker is one of the most famous Go projects.
Not sure if you read what I wrote, exactly? I'm simply saying that the jvm hasn't confidently delivered on these features.
Go apps are mostly sort of run and forget. Try that with Java... most of its bloated ecosystem needs constant babysitting, that's why so many devs defend it. Babysitting = more money.
So, you're pretty close. The difference is that an interface is an independent type. In python, if you pass a WhiteDuck or a BlackDuck into the Quack(duck) function, it's still a WhiteDuck or a BlackDuck inside that function. Also, the checks for what functions the value has are done at runtime. In Go, the checks are done at compile time, and when you pass the value into the function, it actually becomes a value of type Duck, which is subtly different than WhiteDuck or BlackDuck, in that it only publicly exposes the Quack() function (if that's how you defined the interface). For the most part, thinking of it like python's duck typing is mostly correct. There's a lot of stuff you can do in python that won't work in Go, like you can take values of any number type in python, and make a function that adds them together. In Go, that won't work, because you can't make an interface that supports arithmetic operations (+ - etc). Go's interfaces are nice precisely because of the static typing and compile-time checking. You never have to worry that you might be passing the wrong value into a function - that's impossible. I don't know if this helps at all, hopefully a little bit.
I am, unfortunately, not a game programmer, so I don't have a lot of experience writing this kind of software. My thought on how this could be done is just to treat the messages externally as functions, and let the implementation handle synchronization. So, you have a ship, it has a method Fly(distance, direction). Outside callers don't need to know how Fly is implemented, they just call it as appropriate. Internally, it can queue up a struct with the proper information, and send it on a channel.... somewhere for the ship you have a big select statement across all channels, one per action it can take. This then works like a message loop... you wait until you get a message on one of the channels, and then handle that message, then wait again. Yes, you might have like 10-20 channels per object... that doesn't *really* hurt anything unless you're controlling very large numbers of objects at the same time.... in which case you're too far out of my experience for me to be able to help.
It's amazing how many questions about Go can be answered by "write a loop".
As it states in the docs: Allows, in contrast to JSON, comments in your files - just prepend them with a #. Edit: And I think you mean json.Unmarshal
These are the reasonably of the apps running and overall system architecture, not a product of the jvm. You can't say "well I'll write my application in Java so is automatically secure and fault tolerant and blah blah blah". 
GOTO is really useful for specific use cases, but not in normal code. GOTO is extremely useful in a compiler for example, or if you need to always to go to a specific piece of code on error. There are otherways to accomplish these things, but GOTO is really the best way in some cases.
I agree. I actually originally had in my comment that GOTO is only useful in like 1 case, and compiler writing was it. However, unless one is writing a compiler, GOTO is probably not a good thing to go with...even for error handling there is probably a cleaner way... Though, I am genuinely interested in seeing a use-case for GOTO for error handling, where a loop would not work...
I didn't mean specifically on error, but rather if you have some cleanup you need to do, and dont want to wrap a lot of code in a bunch of separate function calls, goto can be used to get out of a loop, and go to the cleanup (especially when you have many nested loops). It's easier than setting a flag, and breaking out of a loop, checking the flag, breaking out of another loop, checking the flag, ect. Goto let's you just get immediately all the way out of a loop. Of course you could wrap your entire looping in a function call and return, but maybe this code is executed a lot and you don't want the overhead of a function call every time you get an early return. It's all super niche.
Such as the "my critical section is several ns too slow" bogeyman? :) Your proposed version is confusing to read because it's the wrong way around, and will not actually have a benefit that matters in most scenarios.
It's not confusing to read; it's just an idiom. You learn it like you learn everything else in a language. &gt; Such as the "my critical section is several ns too slow" bogeyman? If you're using mutexes in Go, you're doing it because you need their efficiency over the much more natural channels. If cycles don't matter in your critical sections, you shouldn't be using mutexes in the first place.
Please don't call it golang in general conversation. It's called Go. Golang is a useful hash tag, but it's not the name of the language.
You shouldn't use apt-get to install, they tend to lag behind. Just as easy to download and unpack.
Excellent article and some good tips on tooling. I write Go everyday. I also try to convert devs who have gone to the dark side (NodeJs). Not a lot of luck there. :)
I'll be an opposing voice and request people call it golang. It is far easier to search for golang.
http://research.swtch.com/goabstract
No. Just No.
I don't disagree, I'm sorta turned off by Perl/Python/Ruby-style frameworks. http://godoc.org/github.com/julienschmidt/httprouter ...is a pretty nice layer over the stock http stuff.
Perhaps, but then there are probably many other places that could benefit from such utilities. On the other hand, I guess that uses of WaitGroups are likely statically analyzable, i.e. `Add` is called with a constant so a tool like `go vet` could find potential miss-uses. I know it already got support for reporting when you copy (some of) the `sync.*` types.
goji.io is a great alternative to martini that I'm using in production right now.
The article dwells on points that seem a bit overblown to me, but I do agree that I don't get a goish vibe from Martini. I've been very happy with [Gorilla](http://www.gorillatoolkit.org/) across several projects. It feels like it's steering you in the right direction with a minimalist approach, while still offering some powerful tools.
Great article! I've been using [web](https://github.com/hoisie/web) and it's probably in the same boat as Martini. I'll be checking out muxchain.
As someone new to Go I found this article very helpful. I recently decided to look into Go web frameworks in order to get an idea of what others considered "idiomatic Go". I'll keep in mind that the jury's out on Martini. I'll try taking a look at some of the other frameworks mentioned in the article and in this thread.
Thanks! That does clear things up quite a bit actually. 
Nice! It was one of the better talks I've recently seen. I also liked the practical example you showed. 
I had this going through my mind for some time as well and the other day another 'value not found' at runtime made me snap... While the injection stuff is powerful I hate giving up the confidence at compile time that my handlers work. I crawled through the slides of [Building web services in Go by Richard Crowley](http://rcrowley.org/talks/gophercon-2014.html) yesterday and I think, that's what I'll try next.
This. ``net/http`` has all I need, and when it hasn't, Gorilla Toolkit has.
This is why you use golang as a hashtag/keyword/label. But in the title/body of your text, call it Go. Google is pretty damn smart, it'll figure it out, I promise. Calling it golang in the title or body of your text just makes you sound like a newbie. 
I agree. When Martini first became popular I had a look at it's source and learned how it all relies on a dependency injection scheme, no thanks. 
&gt; for ideological purity reasons. It has more to do with correctness than ideology.
&gt; I see no reason to switch to something else for ideological purity reasons. I don't think it's ideological purity to want type safety.
Anyone given [gocraft/web](https://github.com/gocraft/web) a decent crack? Does it suffer from the same shortcomings? I remember starring it on Github a few months ago, looks like development may have stalled.
I was going to argue against it *as a Java developer*, but it's too early for that. But I I'll bite, how does the jvm provide that? 
I want to give it a try. I very much like the idea of providing your own statically typed context type. That, I think, is the best approach to building a framework on top of net/http.
There are a lot of problems where channels are not a natural solution. Sharing memory is, quite often, the simpler and more readable solution. Efficiency comes second. And it may be an "idiom" in your code base, but it's certainly not an idiom in the Go community, the standard library being a prime example of not using it.
Yet it removes most of the magic (it does not use the reflect package), only supports two types of handlers (web.HandlerFunc and web.CHandlerFunc IIRC) and instantly crashes whenever the passed function does not match either of the interface. Additionally, nobody stops you from using a custom main "goji" package with handlers swapped out, so you end up with type safety and a little bit uglier code if you want to reuse standard http library handlers.
I actually wrote a little library because of this exact issue when i was building the backend for a new app https://github.com/emilsjolander/rest It only uses the http.Handler interface
There's a very similar project called "Go by example" at https://gobyexample.com .
I'm curious as to how the interface{} (and [resulting type assertions](https://github.com/zenazn/goji/blob/master/web/router.go#L116-L135)) could be worked around *while still maintaining a simple API*. You could of course only accept anything that satisfies the http.Handler interface but I'm not sure what that might cost you: a more complex request context? More boilerplate in having to create custom types that have a ServeHTTP method? Although it won't be caught at compile time the panic can be turned into a HTTP 500 error with the included middleware, which you can at least test for using http/httptest. 
The biggest problem with martini in my mind is the runtime type reflection as part of the normal/happy path. This seems bonkers to me in a strongly typed language like Go. If you want a martini like experience use Javascript or Ruby, you'll be writing idiomatic code in those languages. Idiomatic Go on the other hand should utilize interfaces to be dynamic.
I've been exploring Go by implementing the data structures in CLRS. I've been implementing them to store arbitrary data, namely `interface{}`. Doing so has led to heavy use of the `reflect` package, but one thing that I'm picking up on in this thread is that heavy use of `reflect` throws away the benefits of type safety, and is generally frowned upon. Most of my development experience comes from Objective-C, a typed language with a runtime that allows for reflection and dynamism. It's interesting to see how many trade-offs Objective-C shares with Go--that is, you can use the Objective-C runtime to do some far out stuff, but doing so leads to a greater risk of run-time (as opposed to compile-time) errors, which is generally considered a Bad Thing. Very illuminating.
Care to explain (for blind people like me) what the contrast is?
^^^ This! Great framework, great team, great results
Thanks for the link! I'll check it out. Here's a test from my CLRS repository: https://github.com/modocache/cargo/blob/master/trees/binary_search_tree_test.go In the case of inserting into a binary search tree, I require the user to pass a function used to compare elements in the tree (since we cannot compare two `interface{}` types). When searching within the tree, I use `reflect.DeepEqual`. I use a similar approach for graphs, etc. I'd be very interested in feedback on what I've written so far, but the repo itself is very shoddy work, so I've hesitated to ask anyone until now.
Google isn't the only search engine. Try searching "Go" on reddit.
And the first 2 results have nothing to do with golang.
Serving up an image seems like a perfect time to use something like [http.ServeContent](http://golang.org/pkg/net/http/#ServeContent). From the docs: &gt;ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Modified-Since requests. &gt; &gt;If the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response. &gt; &gt;If modtime is not the zero time, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. &gt; &gt;The content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. &gt; &gt;If the caller has set w's ETag header, ServeContent uses it to handle requests using If-Range and If-None-Match. &gt; &gt;Note that *os.File implements the io.ReadSeeker interface.
If I ever get time, I might do something with this at work. Thanks!
Take a look at the sort package and the interface it provides. http://golang.org/pkg/sort/#Interface. Here I mocked up this on golang.org (didn't realize you could share code snippets until now, freaking awesome). http://play.golang.org/p/7IBS6LKISi edit: I don't know if this will or won't work in your situation, but this is what I would be trying first. I think interfaces are one of the super freaking awesome part about Go. I edited the play link to fix some issues I had not thought of at first, should look good now. Mind you it does use type assertions. 
I think DI is fine, but why not try to use interfaces instead of reflection? Either way, no one is wrong. There are trade offs either way and I can understand why someone would want to use martini, it is pretty slick.
I'm going to shamelessly plug my [Allegro 5 bindings](https://github.com/dradtke/go-allegro), which have 100% API coverage as of Allegro 5.0.10 (minus blacklisted functions that are too low-level or redundant). I haven't used SDL or OpenGL that much, but I like Allegro, and is worth checking out for 2D games.
you'd still need to use reflection for the mechanism to perform the injection though. Making use of interfaces facilitates this DI, but you still need a way of automatically matching concrete implementations into matching interface fields. Otherwise it'd have to be done by hand. Or am I missing another really good way to do this? Reflection is just kind of a necessary evil for DI frameworks in, well, any language I've ever used a DI framework in. 
I think goji provides a good balance of interface{}. There is no runtime cost. Interfaces are used when initializing only IIRC. This is a good tradeoff 
I am still bitter to myself that I didn't go to gophercon. Would be funner watching it live.
I am with you on Richard's library. Though, recently I have been impressed with Beego due to the fact that it has support for the same king of metrics gathering. Plus its completely modular. The thing I like about tigertonic is that it really uses handlers for everything
I'm a big fan of Go, but the article's graph of the stacks seem to be drawn quite arbitrarily &amp; self-serving.
That nested thing at the end looks horrible.
I don't think a stable version of Docker has been release. It's still young, so I think it will expand it's support as time goes on.
Maybe not JVM's implementation, but would you disagree that features like security diagnostics monitoring increased fault tollerance are not advantageous to a production system?
C# works "like" C++ templates only when used with value types. When dealing with reference types, C# generics are like Java's (but without erasure).
Of all Rails-like full-stack frameworks, Beego looks like the most active and promising. (There is also Revel, which is nice too, but Beego has its own out-of-box ORM, while Revel is "[BYOORM](http://revel.github.io/#wishlist)".) May I propose a small change to the docs? I see you use ``this`` as a name for a method receiver. [The Style Guide](https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Receiver_Names) does not recommend this. This func (ctr *AddController) Get() { /* ... */ } is more Go to me than func (this *AddController) Get() { /* ... */ } Other than that nitpick, I wish all the best to the Beego team!
thanks for your feedback, I will update the document like this: func (a *AddController) Get() { /* ... */ } also the sublime suggest that name.
thanks
Obviously, yes. Who would disagree with that? I just meant that the JVM doesn't provide these. In some cases it's actually hurting these by making it less secure, stable, etc. 
&gt; horrible I like the jquery. So write like this, you can also write like this: ns := beego.NewNamespace("/admin") ns.Register("helpers", &amp;AdminHelpers{}) ns.Cond(func(ctx *context.Context)bool{ if ctx.Input.Domain() == "www.beego.me" { return true } return false }) ns.Filter("before", Authenticate) ns.Router("/order", &amp;admin.OrderController{}) ns.Get("/dashboard",func (ctx *context.Context) { fmt.Println("dashboard") }) ns.Post("/login",func (ctx *context.Context) { if ctx.Query("username") == "admin" &amp;&amp; ctx.Query("username") == "password" { // auth } }) ns.Delete("/:username",func (ctx *context.Context) { if ctx.Params[":username"] != "" { ctx.GetRegister("helpers").Call("Delete",ctx.Params[":username"]) } })
Looking at the Beego source code, there's a lot of commented out code, really long methods with deeply nested statements. The apparent low quality of the code, judging from a quick survey, leaves me doubting that Beego is a platform I should build against. With one caveat: I only looked at Beego's code for 30min at most.
So how does Revel reflect against all this? People claim that it's also "non-gooey" in its own way. 
Wow, I hope you're not this unnecessarily rude in real life as well.
What happens most often is a firewall that blocks websockets. &gt; I should add based on your other comments that I am using fiber optics with ~100mbps dl speed, Speed of connection is not that big a deal. The quality of the connections, in terms of % of dropped packets is more of a factor. Since websockets have to be across TCP, when packets are lost, there is a lot of overhead in TCP managing that, which can result in *really* big lags. This is why many games use UDP instead. &gt; 64bit laptop with 16gb of ram and an i7 processor. 32 vs. 64 bit seems to make a difference, but it may all be through Javascript GC. I think 32 bit versions of various JS GC aren't as carefully tuned as the 64 bit version. I am updating 8 times a second, and despite my best efforts, the calculations produce garbage collector pressure. 
 shit is not a shit pkg name
"Using a variety of very advanced heuristic engines, [...]" &gt; https://github.com/aybabtme/pkgname#pkgname =)
I wrote container/list, and I'm not proud of it. It came from an earlier time before we had a good feel for how to write good Go code, and we should not have included it (or container/ring) in Go 1. In almost every situation you'd want to use container/list, a slice is a better option, and in the few cases where container/list would be better it would be better still to simply write your own linked list.
" django is a shit pkg name" -&gt; Better not use it for the next Go web framework, I guess :(
http://www.codingame.com/
&gt;  algorithms is a shit pkg name &gt; Don't mention 'go' in your package name. Go is implicit in any package. Go is absolute and infinitesimal. Other languages should rename their packages; for instance 'rails-ruby' and 'python-django' would remove any ambiguity. Everything including "go" is shit, so also everything having "algorithm" in it.
I think you could still call your package 'algorithms', unless you feel forced to abide by all the rules of our funny tool =).
In addition to the storage methods you've described, you can also store data directly in the cookie, optionally with encryption. That is the purpose of cookiestore.
**Go-Learn** Information: Author: skippednote Description: Get going with Go Main Language: None Number of Forks: 0 Number of Watchers: 0 Number of Stars: 0 
If there's a C library then it shouldn't be a hard or time wasting job to build a Go wrapper. Just start implementing the methods you need.
Oh wow. That is interesting to hear. What critiques do you have with container/list?
What about [testing/quick](https://godoc.org/testing/quick), does anyone use it? It looks like it did not gain much popularity: https://godoc.org/testing/quick?importers.
Testify: https://github.com/stretchr/testify
I'm using the Tideland Go Testing Support (http://github.com/tideland/gots). It provides two packages with a number of different assertions and several test data generators.
I use this too. Simple assertions to condense if a != b{ t.Errorf("%v is not %v",a,b) } type code are really nice. I also use their suite things, but I am not super in love with it.
Just found this article in a round about way, came here to post it but found your link. this is a fantastic piece of technical literature of a real world software problem solved by Go. This says it all: "We're confident that Roshi will accommodate our exponential growth for years. It took about six developer months to build, and we're in the process of rolling it out now." 
Thanks ;)
Note that this is typically the "default" for many sessions implementations, because it does not require any storage space on the server side and reduces complexity as a result. The downside to a cookie store is that you have a size limit of 4K per domain, which can make it harder to store some things in the session (i.e. repopulating forms; although you can do that another way too), plus the cost to send 4K over the wire each time. 
&gt; where the server can look for this exact identifier and also check whether the browser agent, IP range and so on are the same (which is also stored server side) to minimize possibility of identity theft. Just the identifier (usually a securely generated random string). There's typically no IP check (which is unreliable given mobile devices) or browser agent check (same again). Some implementations may do thisand require you to relog if your IP changes or at least re-auth for sensitive actionsbut it's not the default in any major web frameworks that I'm aware of. Hence why if you are serving sensitive content you should serve it over HTTPS, which prevents the cookie from being 'stolen' and used by an attacker.
A linked list is one of those data structures that is simple enough to write out as required. Forcing everything through interface{} is a bad idea unless you have no other option. Also, a linked list is usually really bad in a garbage collected language, since it massively increases the number of references you have just for the data structure (e.g. O(N) for a list, versus O(1) for a slice), and has lots of small allocations instead of a single larger allocation. Since modern computers are very good at copying memory around there is very little practical overhead when a slice needs reallocating.
There's really two distinct issues here. One is protecting the data in a session, which is pretty straightforward with encryption for cookie-based session storage, or generally by using filesystem permissions with file-based session storage. A second issue is the security of the session itself, and the ability to hijack it. Thousands of PHP developers treat sessions as an all-inclusive solutions, when it is trivial to steal that PHPSESSID and take over another user's session. With any mechanism, you really need multi-factor validation. IP address is a prety common one to use, but is a really bad idea. If someone sniffs your session ID at a starbucks, they'll still have the same IP.
It's almost always true that reddit posts are opinions, but I'm going to extra-super label that is just is my opinion, and you're free to disagree without me thinking you're a bad person, and I hope you extend me the same courtesy. Also I'm completely unaffiliated with the authors of this... tool? toy? whatever it is. But I've thought this myself for a while now. That said. I've used a lot of languages at a lot of stages of development over the years, and I've come to learn that a language community tends to stick their language name all over everything at the phase where they lack confidence in their language and it's popularity. You know a language has hit maturity when major libraries and packages start being released that don't nervously stick the implementation language in the name, but just confidently go out there and name themselves something distinct. It's time, if not a bit past time, for more Go authors to act with confidence and drop Go from the name of their package. It's Docker, not GoDocker. Go's ready. Let it fly free. And of course, there are exceptions. Bindings in particular, or libraries that basically just implement network protocols... there's nothing wrong with go-qml or go-mysql. (Also, yes, I sort of regret my package name with Go in it.)
I use this also. Simple, straightforward and provides a nice control flow. 
Initially I was looking for the same but almost all of them were outdated for more than 6 months.
I'm a minimalist, I use the standard library. 
thanks. actually beego is popular in China. Many big company use beego in there system. Also many startup use beego to develop API &amp; Web.
+1
So who else is *extremely* curious about the "difficult to explain" goto statement? (about 17 minutes in)
If it's good enough for the Go authors, it's good enough for me.
I am a little split on gocheck. The suites make it easy to compose sets of unit tests to be run against different chunks of code. For example, I have a "Database" interface and a single suite of tests that test multiple database backends without needing to cut-and-paste code. The assert shorthands are nice, but could be written by hand if you wanted. On the other hand, it doesn't play well with parallel test runs, and it doesn't support benchmarks very well.
would i be crucified if i said i don't run unit tests? not because i don't want to but because i never have and don't really know where to start. i have a [public github repo](https://github.com/jayrox/gopixelrelay) on my current project if anyone wants to give advice.
You could always grep through the compiler code base and by process of elimination see if you can figure out which one it is. Report back!
Intimidation also kept me from writing unit tests for a long time. I would recommend starting with a small project from the beginning. You could watch this ~6min video to see how test-driven development works: https://www.youtube.com/watch?v=vL_UD1oAF0E -- and yes, it's a dummy FizzBuzz project, but you could learn how to write tests on another toy project of yours, for example, a bowling game, or a simple parser or utility or something. (The video uses GoConvey. You can use GoConvey's web UI even if you don't want to use its DSL, though using `So()` assertions are more expressive than `t.Errorf()`.) Testing takes a lot of practice, though, so don't be discouraged if you're having a hard time writing tests for some of your code. A lot of pain can be alleviated by using interfaces rather than concrete types, like structs. Even still, some code is just not easily put under test. For example, GoConvey is definitely under test, but some of the system/shell things are not covered by tests at all, because mocking the shell is hard or rather involved.
thanks, i'll have a look at that video when i get home tonight.
The basics of unit testing are to have small bits of logic that are separated into functions with well-defined behavior for specific inputs. You then run different inputs through the function and test that the outputs are what you expect them to be. Everything else flows from that. So, like, your generateInput function - https://github.com/jayrox/gopixelrelay/blob/master/utils/generateform.go#L48 This seems like a nice unit of functionality that would be easy to test. This is actually a great use for table driven tests, which is just making a slice of inputs and expected outputs and running them through the function and asserting that the actual outputs match the expected outputs. Make sure you test negative cases as well, like, what happens if valueField is an empty string? What happens if the struct tag doesn't have anything defined? etc etc. This makes your code a lot more robust, because you know it's covering the corner cases. You can probably do this for a lot of functions in your code. For ones that aren't this simple, you can often refactor them slightly to make them easier to test... often times this makes your code easier to refactor in general later on, because you have better-defined units of logic, and fewer inter-dependencies in the code. Don't worry about getting 100% code coverage... it's generally impossible without the tests being completely meaningless. Code coverage is a tool to give you an idea of what's been tested and what hasn't, but it can never tell you how *well* the code is tested. Concentrate on getting *some* tests, and then concentrate on getting any *new* code tested as well as possible. Don't test other people's code if you can help it... like you don't need to test that http.Listen does the right thing, assume other people's code works (unless you have reason to believe it doesn't and/or that it might change out from under you).
I got it too. Fortunately, it appears to have started only on the last slide, and be little more than annoying.
I get your point, but the sarcasm isn't really warranted, and doesn't lend itself to spurring actual dialogue. It's a perculiar typo that the compiler doesn't warn you about, because of the oddity of having methods that can be used as values (note that this is also a relatively new feature in Go, so not all developers will realize it). I think it's well worth pointing out. That being said, I do particularly dislike the Field_ naming convention, and it's not one I'd recommend. Not only is it ugly and prone to typos, the more egregious problem is that it's just downright confusing. Both are exported names, and so the developer has to decide whether to use the getter or the Field directly. Certainly, this is not a good pattern to follow. I don't know the exact code that Dave was talking about, but I've seen the pattern, and I'm not a fan.
I just imagined she was doing sign language when the video got out of sync ;)
I played around with Go a little, coming from a computational science background, where most of my data analysis is performed in python. It was fun, speedy and there were a lot of things I liked. But I can't really imagine replacing my current python workflow with Go anytime soon. Numpy/Scipy/IPython/Pandas plus libraries like h5py are just too convenient, and there are things like Cython and Numba to fall back on for speed. I imagine that a lot of non-computational python people would and are switching. I sense though, that people doing numerical and statistical data crunching would move to Julia before Go because its a language with the needs of those communities baked into the language. Julia does suffer from your standard jit-ed language issues like slow startup (maybe that will improve in the future). That said, I can imagine use cases where I would turn to Go, and I probably will from time to time. I'd certainly love to see the scientific and computational libraries mature. Python has certainly proven that once you have a solid n-dimensional array library to build a foundation on top of, the ecosystem can really flourish.
Looks fantastic! I stayed away from martini for the reasons you outlined. Your new framework is perfect for what I need. Thank you for all your contributions to the go community!
What do you want to use a k:v store for? There are many, but most serve particular niches. Better to outline your problem so we can offer a more precise solution.
Martini's "Hello world" is averaging about 60-90 microseconds on my machine. Negroni clocks in at 30-50. I think both libraries have their advantages.
SSDB is my favorite.
How do those compare to the official http helloworld in the docs out of curiosity?
Depending on your usage scenario, there are etcd, kv, tiedot, and bunch of others. 
Ive been very happy with BoltDB (inspired by LMDB)
https://github.com/cznic/kv
I really enjoyed your talk and thank you for furthering the cause of wiping out shell scripting (don't get me wrong, shell has its place but solving problems with 3000 lines of bash is not it).
Blown away by the positive attitude of the author. 
Yes, RESP is a nice and well documented protocol I also discovered during the development of my Go Redis client (https://github.com/tideland/godm, v3 of the client is currently under development). It is pretty clean and has no overhead.
I just saw a talk from the author of [bolt](https://github.com/boltdb/bolt) at gophercon, which should be a k:v store in pure go. No experience with it though...
I should try that benchmark on raspberry pi to make the measurement more noticeable
One of the great take-home points - "Go's greatest asset is its structural simplicity."
Not sure if the benchmark I hacked together late last night was fair and comparable, but plain net/http was about 4-10 microseconds.
+1 Haven't used kv yet but have been using cznic's ql (pure go database/sql driver) for some time and the code and feedback response is top.
https://github.com/jmhodges/levigo
Love how you're just ripping off videos originally posted by confreaks.
Fast and simple, pure Go: https://github.com/boltdb/bolt
ruby farmers with the hope of growing magic beans in go land will be disappointed. this land was made to grow no magic. when you remove the magic in your framework to be idiomatic, then your framework: * is no more a framework. * in the rich context of net/http, is just some 'added value'. what you call _middleware_ here, is nothing but a set of wrapped go functions called http handlers. the majority of supporters of this type of solutions in go, are refugees from dynamic languages, specially ruby, who are looking for the rails of the golang. 
Are you using Read() or ReadAll() ?
Not sure if that's normal or not, but I found the built-in csv module to not be very optimized. A much faster approached I used when writing a utility to clean up some large tab-separated files was passing a custom function to bufio.Split(). Here's some code; it's tab-specific and doing two things at once (for efficiency), but hopefully is clear enough to give you an idea. https://gist.github.com/dilap/46ef747dbd642ef6e834 Caveat: Still new to Go, only played with it a bit, could be doing all sorts of stupid things. 
I built this library because somehow, even among all of the existing logging libraries, there was not a single one that captured all of the use cases I needed. The core focus of this library was to enable all of these features with an incredibly simple API. What I ended up with is, I think, a very simple set of primitives that can be composed together and extended to enable very custom, but powerful logging configurations. Would love any feedback on the design.
It's hard to diagnose the problem without seeing the code.
thx for the reply. I use Read()
thx for the kind reply and help
not trying to troll, but what's wrong with using regular ol' Go maps and writing/reading those maps to/from disk as gob files? as long as you wrap your map access(es) with appropriate mutex locks, it's about as fast and thread/concurrent-safe as you can get. 
If your map is small (fits in a few kb on disk) it would work. But if your map is large, you would have to rewrite the whole map to disk after each update, even if only one key is added/modified/removed. It's not efficient. This is the reason why people use key-value stores like LMDB, LevelDB, Bolt, cznic/kv, etc.
Now this is getting exciting... I can finally mix this great middleware system with a mux like https://github.com/rcrowley/go-tigertonic and get the best of both worlds!! Great job Codegansta!! 
How are you measuring the memory usage and what Go version are you running?
This looks fantastic. I'd actually started writing a package for logging with logfmt style the other day, but it looks like there's no reason to finish it. One thing I don't understand about the design is why Logger is an interface. There's only one type that implements it and there are no functions in the package that accept a Logger as an argument. As it stands, it would make more sense to me to simply expose the struct and if clients need an interface for some reason, they can make their own.
go version is 1.2 for memory usage, I just watch the activity monitor in mac :)
Hrm, there were two reasons, but I'm uncertain whether they justify the decision: When I write packages for my use only I tend to side on structs *until* there are two implementations and then I will factor out into an interface. For packages I publish as libraries for public use, I tend to side on interfaces because it gives me more flexibility to change the package internals without breaking the API. I'm also considering having a "registry" of loggers so that you could configure a 3rd party package's logging by name alone, but I haven't settled on a good, non-intrusive design for that yet, but it could involve handing around Logger objects.
Interfaces are more flexible in that you can add other implementations later, but are less flexible in that you can't add methods later without breaking compatibility.
I would assume that once you add some middleware to net/http that the performance would be almost identical to Negroni (assuming you are using negroni.Classic()). 
i think the key types which can be used to rbt,have implement the interface like less,equal,great.channel maybe can not implement these.
I agree that the logging packages are lacking. One thing I'm not 100% on is the dynamic nature of the key+value pairing. Any mismatches will only be found at runtime. An alternative might be something like: log.Warn("Message", log.M{"key": value, "key2": value2})
I figured some people might prefer that style, so log15 supports it as well: log.Warn("Message", log.Ctx{"key": value, "key2": value2})
Read my mind! :) Awesome.
Good job and great attitude sir!
Is there a recording to go with these slides? It would be much easier to follow what's going on and I'm interested in the topic.
BenchmarkStdParser 500 5289195 ns/op 22.69 MB/s 625129 B/op 16036 allocs/op BenchmarkYacrParser 5000 669959 ns/op 179.12 MB/s 4288 B/op 5 allocs/op go get github.com/gwenn/yacr Disclaimer: I'm the author. 
No sense of humor? Anyone?
&gt; You might want to watch this talk from gophercon14. It's about doing high performance protocol decoding and goes into details on benchmarking and that the stdlib might not be as fast as you think. &gt; there is bug in the csv, some comma missing, spaces, but I skip then. Actually, the program jumps from 500mb when the missing comma occured to 1.2gb 
450MB more than 1 milion records
Hm, that's odd. Could you try to place a call to [runtime.GC()](http://golang.org/pkg/runtime/#GC) near the end of the for-loop for me? I suspect the garbage collector does not run. Consider filing a bug for this. Also, what version of Go are you running on? Do you use the 32-bit or 64-bit Go runtime?
OARCH="amd64" GOBIN="" GOCHAR="6" GOEXE="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" add runtime.GC() to the end of the last loop, memory usage remain the same, also time increase from 1.3 minutes to 3 minutes
Can you show me the output of go version too?
Hm... that's strange and unexpected.
go version go1.2 darwin/amd64
I was actually doing some work with encoding/csv yesterday and I also ended up comparing the strings too. The problem I had was that you can't do err == csv.ErrFieldCount (because err is never equal to csv.ErrFieldCount), and you can't do err.Err == csv.ErrFieldCount (because err is an error as far as Go is concerned despite the fact that it's actually a csv.ParseError, and error doesn't have an Err field). And trying to cast it using csv.ParseError(err) didn't work either.
So, what prompted you to create this? Just for fun or is there something you don't like about go's builtin flag parser?
You want an assertion `err.(*csv.ParseError)`, not a conversion http://play.golang.org/p/fDpGrLtaZ4
A whole bunch of little things really, but the most useful to me are: - Subcommands. - Type-safe positional arguments. - Required flags and positional arguments. - Short flag combining. - Automatically generated, nice-looking help. While *most* of these things are possible with the builtin flags package, they involve tedious manual work. This package automates it all away.
I report a bug to golang, maybe in 1.4
this only deploys code and requires a git repo on the server, adjust your expectations
I laughed, but in some cases, this can be useful
I have found [diskv](https://github.com/peterbourgon/diskv) to be very nice when I just need a quick on-machine key/value store.
great logo!
That's nice! For the record, could you link to the bug report so we can follow it?
the link for the issue: https://code.google.com/p/go/issues/detail?id=8059 go code: http://play.golang.org/p/umPlzvVcc1 ruby code: http://play.golang.org/p/y5SqrIW87Z time to process: ruby: 12 seconds go: 10 seconds Will be very very difficult to convince my boss to move the processing and api to golang :|
Very nice work, those are the things that have annoyed me too. What also has annoyed me is `-long` format which is different to gnu and unix style `--long` and one dash for short
Very nice work, those are the things that have annoyed me too. What also has annoyed me is `-long` format which is different to gnu and unix style `--long` and one dash for short
Does it require that you host your code on GitHub? Why not any Git-repo? I could actually use something like this, but not if it's GitHub only.
I realize that OP meant this as a joke, but the bitter irony is he's entirely right, this can be useful. I can't begin to tell you how many problems I've solved by having the following conversation with myself: "Hmm. This needs to [happen in parallel/be out of order/happen serially while allowing for parallelism under the hood/return later/potentially never return/timeout after a certain time/be handled exclusively of other conditions]. I know, I'll introduce a channel [and a select], and make [no new/one/several/a rabid swarm of] goroutine[s] to deal with it. Hey, problem solved! Wow, Go is awesome!" The fact that this can be encapsulated as a repeatable pattern just tells me there's low hanging fruit for refactoring tools in IDEs... right click on a variable, refactor, decouple with channel. Right click on a block of code, refactor, move into goroutine. Now if someone would take this example, and move it into Eclipse, I'd be ecstatic! It may not make your code faster, but more times than not it makes your code correct, AND easier to reason about.
This is a big win for anyone writing daemons or system utils for a production environment. Key=value parings work incredibly well when fed through syslog to a SEIM system of some kind, like Splunk. Your typical, "human readable" log-lines are hell on wheels to process by comparison. The distinction is how well your friends in the NOC are able to digest and respond to failures in your svelte go programs, vs reams of Java stack traces from someone else's project.
I just deleted a reply that about the very same thing. This needs to go in the Readme - the vararg style is a big turn-off as its obviously on the brittle side. :)
&gt; now with a new awesome logo! What a great feature! In terms of the tool, it's nearly as simple as scp.
Aha. This makes it clear. From your comment about pointers, I will conclude that keys should be immutable (value types). Thanks.
It's featured early on in the godocs, but I'll add it to the readme as well. 
/agree There's a blog post I'm going to write about this
Nice work, thanks for continuing contributing. I'm a fan of keeping things in go simple, and avoiding complex things like Martini. The go language was built with just about all the tools you need to be successful, unlike many languages, and the little that is missing (database, routing, and so on) can be pretty easily accounted for in small - often opinionated, which is probably why go lacks the implementation - auxiliary packages. That said, the more people using go the better, and so if martini works for others and the net result is more people using the language, all the better!
Makes solid sense. Compiler results can be cached and parallelized so do as much there as possible. 
I made https://github.com/ImJasonH/csvstruct which might help. If you try it out I'd love your feedback!
[Index page screenshot](https://camo.githubusercontent.com/15188ce53bd910d5551efb67ed23985e6eab2c2b/687474703a2f2f747279696d672e636f6d2f342f676f7368692e706e67) returns Not found.
I will try it today :)
It took me a while to find out why this is a good idea. From a repo manager standpoint, I can't see much use to it. Redundancy is nice, but it's not terribly hard to achieve with the way Git is designed. A convenience at best. From a contributor or end user standpoint though, this is great. It might do away with desynchronization and other woes. At best it can act as a decentralized repository. If coupled with a script that automates compiling and installation we would have something akin to the Yaourt/AUR dynamic from Arch, but better. Best of luck to you.
Thanks!
[This](http://tour.golang.org/#1) is the best start.
Thank you. Any book you'd recommend for a novice?
Go is still somewhat infant so there isn't exactly a vast repertoire like with other languages, but [this](http://www.golang-book.com/) seems pretty decent.
Right now that is the requirement, yes, and the only reason is that I originally built it to use at my company, which uses git and GitHub. I am thinking of ways I could make it more generic so I hope you keep an eye on it in the future.
I recently found https://github.com/skippednote/Go-Learn/ and https://github.com/SimonWaldherr/golang-examples maybe they will help you. Especially take a look at the first one, it has a lot of links.
For some reason this image works in Japan but not in other parts of the world. I contacted GitHub support about that.
I wonder if they will attempt to write a parallel linker. Some of the algorithms involved should be parallelizeable with some effort.
Yes, once it's in Go (in-progress), then we can profile it with Go profiling tools, and use goroutines easily. That's exactly why the C version is being killed. It wasn't ready for Go 1.3, but should be ready for Go 1.4. 
I wish your team good luck with this amazing effort! Here, have this piece of gold as a token of gratitude.
I've used the following code: c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) go func(){ for sig := range c { // sig is a ^C, handle it } }()
This bit from: http://golang.org/doc/faq#variant_types seems to clarify this particular question! Why does Go not have variant types? Variant types, also known as algebraic types, provide a way to specify that a value might take one of a set of other types, but only those types. A common example in systems programming would specify that an error is, say, a network error, a security error or an application error and allow the caller to discriminate the source of the problem by examining the type of the error. Another example is a syntax tree in which each node can be a different type: declaration, statement, assignment and so on. We considered adding variant types to Go, but after discussion decided to leave them out because they overlap in confusing ways with interfaces. What would happen if the elements of a variant type were themselves interfaces? Also, some of what variant types address is already covered by the language. The error example is easy to express using an interface value to hold the error and a type switch to discriminate cases. The syntax tree example is also doable, although not as elegantly.
I didn't look at all the producer/consumer stuff, but the signal handling looks right. Best way to know: test it.
I am more interested if Im using sync.Waitgroup correctly (no race conditions) and if the whole pattern is at least somewhat sound.
I think the article skips over a few real pain points when writing "web applications" (what a broad term, but in my case I usually mean: serving HTML on some endpoints and potentially JSON on others): * Middleware, and being able to *order* it and apply it in a granular fashion (i.e. on a per-subrouter or per-route basis) so I'm not adding overhead and unnecessary logic where I don't need it; * Request context so I can pass data (CSRF tokens, userIDs, initialised sessions, errors, etc) between middleware and the "handler" at the end of the chain and getting some type safety around it. * A relatively sane API to tie all of this together that doesn't involve really(long(function(chains(whoa(myHandler)))))) Goji (https://goji.io/) is a really nice middle ground between bare net/http (and writing your own boilerplate over and over) without any dependency injection, fairly sane middleware chaining and no global request context map (so no need for locks!). It's also [pretty darned fast](https://gist.github.com/zenazn/c5c8528efe1a00634096), although if you're hitting a DB your router/mux/middleware chain isn't going to be noticeable. I also like gocraft/web (https://github.com/gocraft/web), which is a little heavier (only just) but provides type-safe contexts (read: no map[string]interface{}!) at the cost of a little more "up front" complexity to get it all started. But I guess you don't need to write getters/setters to get your types in- and out- of your request context, so it's a bit of wash. I see benefits in both their approaches, and may end up porting over a gorilla/* + net/http project to really test them out. Ultimately the most well suited "framework"[1] comes down to your use-case, your team (if any) and perhaps even the community behind it. [1]: Framework is such a loaded word and often sees a bit of scorn in the Go community. I think it's often associated with "bloat" or at least a "kitchen sink" approach ala Django or Rails, even if something like Goji, the various bits of Gorilla and even Martini are a long way off that size. There's a tendency to say "net/http is all you need", forgetting that for any moderately complex application, you're going to need to reinvent your own mux, context, middleware (logging, panic recovery, etc.), custom handlers, and so on. It's in my opinion that Go "frameworks" should aim to align with net/http as much as possible and expose as much as they *reasonably* can, but using one of the aforementioned frameworks in Go from day one won't cause you the kind of pain a big, kitchen sink framework will if you try to move away from it a year later. 
That sync.WaitGroup usage looks fine to me. As long as you are making sure Add completes before you Wait (which you are doing via defer) it should generally be ok. The select statement could be improved though. Signal handling is delayed if a signal comes in when blocked on a send to the channel "work". The solution is to make the send operation a case in the select and remove the default case. Then if a signal comes in while blocked on send you just drop the value on the floor (or do whatever you would do to be responsible in the real world). http://play.golang.org/p/e0LKrWFSDr (I did "format"/gofmt the example so it looks a little different). I didn't actually run it either because the syscall stuff doesn't compile in the playground.
It doesn't perfectly align with your use-case, but Goji has a graceful sub-package that provides graceful shutdown of a HTTP server. The signal and channel code in there may be of use: https://github.com/zenazn/goji/tree/master/graceful
I get a 404 when trying to visit the link.
Note that you cannot handle/intercept SIGKILL, it is handled by the OS which stops the process. I think you meant SIGINT.
No mention of beego? 
Nice comparison, would love to see beego too, it's popular framework too, especially in china
yes.
I'm a fan of doing it the simple way. I maintain a simple net/http skeleton over at https://github.com/jadekler/git-go-websiteskeleton for people who feel the same and just want to jump in. Check it out if that sounds good to you - contributions welcome!
Cool man. When you get it all finished, post up a working demo
Will do, probably going to use it as an opportunity to learn the net/http library and may or may not host something
Thanks for posting. I'm just learning about Go and reading your code helped me think through how I'd do it myself.
Thanks for your reply. I've already done this kind of test: https://github.com/gwenn/yacr/blob/master/load.go with this file: http://download.geonames.org/export/dump/allCountries.zip (The standard csv parser (slow and buggy) cannot read this file properly: https://code.google.com/p/go/issues/detail?id=3150)
I love those blog posts which are supposed to bring traffic and attention to certain company using the hotness of the day. Neither gocraft/web nor gorilla is framework and beego is missing. Shame on Square
are you part of #go core developer?
I think so.
Thank you I'll fix it ;)
hm, yeah someone mentioned that, I am not using the database for anything online, it's just a local server for my own use. But I will keep it under consideration if I ever do*.
Glad it helped, I've been doing the same exact thing with other projects, it's definitely a great way to learn. Don't take my code as a best practice though haha, I'm sure there are a ton of things I could of done differently in the Go Way.
Or, y'know, just use `go version` ...
jzelinskie built a pretty complete Go API for Reddit: https://github.com/jzelinskie/reddit
Are you changing versions that often?
It's not working if you have compiled Go on your own. In my case "go version" outputs: go version go1.3beta2 +708e129e91a9 Wed May 21 16:01:54 2014 -0700 linux/amd64
You should add setup instructions to you readme.
ok thank you
what's the status of this project?
I am a developer on the west coast, and my choice for a JSON HTTP API library has always been between beego &amp; tigertonic. The benefits of Beego are numerous, including that it has the widest community of users &amp; developers of any of the http/net wrapper/addon libs out there. Tiger tonic is great because it is specifically built for JSON HTTP API dev.
Are you thinking of using net/http to build a site?
I dunno exactly what your issue is, but my advice is to install https://github.com/fatih/vim-go It really does take away all the complexity of setting up the go dev environment yourself. I installed it expecting to have some level of suffering to deal with, but it literally just works. Goimports is integrated there, as well as a bunch of other very awesome stuff.
possibly, if I did anything more complicated than a static one pager though, I'd probably use a framework like beego or martini. That being said, you can do a lot with net/http, angular js, and bootstrap.. as per this talk that I loved, and slowly digested line by line: [campoy](https://www.youtube.com/watch?v=wB1hoUJDbk0) But even he implemented the router with gorilla/mux 
You forgot to add `alias emacs=vim` in `bashrc`.
I'll second this - vim-go just works. and it's really, really nice.
Thanks for the gold, but I'm not personally working on the linker bits. Side bit of amusement: gold is the name of the linker that gccgo uses. :)
as mentioned already, I'm building the project out, what I have here is a skeleton of what I'm going to need.
That's a cpu profile. I was referring to your benchmarks. My data sets are all properly formed (escaped quotes etc), so it doesn't really help me decide what package to use just because you tried messy data and it failed... Anyways, I'm not trying to start something here... But if you want to go around advocating your package you should be a little more measured in your benchmarks if you plan on getting anywhere with it.
It does (as in it stalls) or returns the output of --help if I add it. 
Oh wow, I didn't see that either. That was written by the author of that static blogging system I'm using (also in Go). That's really cool.
I didn't know about number 1. That's neat. 
So what is this, a micro-distro indented for VMs to run Go programs with Go deployment tools?
Looks like Clive wouldn't be able to run most off-the-shelf Go apps due to it redefining how to interact with the file system. I only skimmed the document, but I think Clive has two main goals: 1. Get rid of a heavy operating system, your app would contain the kernel itself. 2. Make it easier for programs to communicate with each other - pretty much everything is a channel, so you wouldn't have to worry about marshalling between some sort of RPC/serialization format (REST,SOAP,JSON,XML,etc) and Go native types.
that's a good idea. we already have a google group https://groups.google.com/forum/#!forum/beego-framework. but in china they can't access the group directly for the FUCK GFW. welcome all the beego developer join this group.
thanks. I recently do some video tutorial in Chinese. and CaoLei is doing the English tutorial. I hope all this will let the developer easy to learn beego
I was a little confused by that point. The example code of what not to do isn't equivalent to what net/http does, is it? The example code would cause the request to immediately close, while the goroutine continues to run. The way net/http works is that the request handler function is run in a goroutine and the request is closed when the function returns. There could be perfectly valid reasons for creating a goroutine from within a request handler.
Doesn't the client wait to disconnect until the http handler has finished? If so, doesn't it actually make sense to launch a goroutine for a particularly expensive (non-response-returning) background task?
I guess it helps to point out that if all you're interested in doing is returning a HTTP error or redirecting, the helper functions [http.Error](http://golang.org/pkg/net/http/#Error), [http.NotFound](http://golang.org/pkg/net/http/#NotFound) and [http.Redirect](http://golang.org/pkg/net/http/#Redirect) might be more appropriate.
On the surface, it sounds like a terrible idea (compared to docker, CoreOS, what-have-you these days) especially if it requires full virtualization. 
It's what some people call a "joke". Obviously humour is lost on emacs users.
For a expensive operation which doesnt change the response, yes. But not for handling the entire request.
This would actually be interesting if it targeted embedded systems.
kind of go/plan9/openmirage. am I the only one that can't find the newsgroup? been seaerching. 
Precisely, sorry if that was a bit unclear. I saw it in a go-nuts thread awhile back (can't find it right now) and just figured I'd put it in. Obviously spinning off goroutines from within a request handler is just fine, but handling it all in a different goroutine is a no-no.
"Bad" and "Good" are too simplistic. Most people writing HTTP code are familiar with a subset of codes, like 200, 404 and 500. Code isn't necessarily improved by using http.StatusOK, http.StatusNotFound and http.StatusInternalServerError, which are all much longer to read.
nice post! while this example may have been hypothetical in order to demonstrate `var` usage, I did want to point out the `append` function is variadic (you probably know this, leaving it here for those who don't). [Gist](https://gist.github.com/chuckpreslar/da41d7000ac2a1282a40) Results in fewer calls to append and less moving parts.
What makes it a terrible idea ?
well I, at least, did not know this! Thanks.
ThingCreator() returns a chan Thing, if it returned a []Thing then the example would not compile. Edit: it could also return a map of Things to something else, but that is still not compatible with the variadic append function.
On cloud servers, you will have some degree of virtualization (that's the way servers can flexibly add new loads and don't crash hard). If you use something like LXC, you reuse the "host" linux kernel. If you write your own OS (maybe it's just your app linked with kernel services), you need a full fat VM with it's own abstraction of the system. Now why would you want that, if it uses more memory, and is slower?
I wish you would have gone into more technical detail regarding how it has affected you.
pdjMMO = Procedural Death Jam Massively Multiplayer Online. It's not really a roguelike, as it's real-time. Hence "Procedural Death Jam." Though I'm playing around with a power that would let uses time-stop a single room. http://raidSPHERE.com Can't vouch for browsers other than Chrome, Firefox, and Safari.
&gt; Go has several ways to declare a variable. Possibly there are more ways than are strictly required I know this comes from Rob, but I can't figure out what could be pruned. We have //v is the zero-value of T var v T //this one seems redundant until you consider var v uint16 = 0 var v T = r //Redundant with v := r, unless it's a declaration var v = r //Redundant with v, v1 := r, r1 unless it's a declaration var v, v1 = r, r1 //Again, consider var v, v1 int32 = 1, 2 var v, v1 T = r, r1 //Redundant with v, v1 := f(), unless it's a declaration var v, v1 = f() //Redundant with var v = r v := r //Redundant with var v, v1 = r, r1, unless v or v1 but not both is declared in a previous scope v, v1 := r, r1 //Redundant with var v, v1 = f(), unless v or v1 but not both is declared in a previous scope v, v1 := f() There are 9 ways, and perhaps that's a lot, but they all seem necessary. You can't get rid of the var family because you need that to keep the syntax regular for declarations and each of its variations are completely valid and useful. Since the var family is required the only real expendables seems like the := family, but aside from the mild annoyance stemming from newVar, oldErr := f() you can't get rid of that because of the case: v := pkg.F() //F returns an unexported type. I guess it can be confusing to have all these different versions, but despite the proliferation of cases it's all very regular and symmetric so there aren't any surprises. I don't see how it could be made simpler without coming up something that replaced both var and := completely, and I think any attempt to do so would just introduce more confusion like the pre-Go1 attempts to marry make and new. I think it's a necessary complexity.
It also makes it more likely the compiler will catch a typo for you.
When I started out with Go, myself, I found it all quite daunting. I couldn't figure out the syntax, I couldn't find documentation, and the toolchain was quite scary. It's been a while since then, and my familiarity with Go has increased greatly. I've done some pretty crazy shit with it, and Go can take anything I could possibly throw at it. The biggest thing I could suggest to newcomers, though, is to read the language spec. You don't have to go through it all at once, but when you hit a language question,that's where you go. Have a bizarre question about map keys? Take a look, it's probably there. Secondly, [GoDoc](http://godoc.org) is invaluable for all package documentation, both stdlib and not.
Hi, I came up with this idea the other day and am kind of stunned how easy it was to put this together. The interface based implementation of [bazil's fuse](http://bazil.org/fuse/) package made it really easy. I think I will fork this and build it around the blogging engine I'm working on. Displaying posts as markdown files and being able to edit them, something like that. I'd also love to get some feedback on this idea and my code.
I really wonder how many of those who advice using bare `net/http` for everything, have really written an HTTP server, with CORS, and tokens, and sessions and granular authentication for different parts. Some people like reinventing the wheel every time though.
`Ticker.Stop` only stops generating ticks but doesn't close the channel (see [the documentation](http://golang.org/pkg/time/#Ticker.Stop)). Therefore the goroutine still exists but can't get out of the for loop.
I was just trying to show how much the memory allocation can be reduced. And I can't reasonably put big CSV file in a go getable repository. I would have preferred not to write yet another CSV parser in Go. But I need to parse big realistic messy data... All benchmarks are flawed (especially mines).
Needlessly complicated. All you need is two channels and a waitgroup. - Channel "work": Used by the producer to send jobs to the consumers. Producer closes channel to signal the consumers that they should terminate. - Channel "term": Used to signal the producer that it should terminate early - Waitgroup "mu": Used by "main" goroutine to wait for ALL other goroutines (be they consumers, or producers, or anything) to terminate. **Before** starting a goroutine (ANY goroutine) you do "mu.Add(1)". Once a goroutine starts (ANY goroutine) it does a "defer mu.Done()". That's all. See: http://play.golang.org/p/B4S6-iSecd 
I have included a time.Sleep for precisely that purpose.
Mentioning a pain point (wrapping default middlewares to make them Alice-middleware-compatible) in a post about painless middleware strikes me as a bit ironic. Alice is however much nicer to read. I'd like to see some ability to push and pull middlewares from the chain after creation, though I'm not sure how easy that would be to implement.
Sure, but there's no hiding it. If a handler requires configuration, you've got no choice. To some, separating configuration of specific handlers and the stack itself might even seem cleaner.
Alice in Chains? EDIT: By the way, the link to Alice is pretty well hidden in your post. You may want to make it more prominent so we can actually look at the code.
Of course not, but I thought since these were separate goroutines, if I keep main alive long enough, eventually, the other one would go ahead.
Yes! I have to admit, I don't really listen to the band, but I like being oh-so-witty with names for my software :) Added a more prominent link, thanks.
Alice is nice... much better than "*go*middlewarechain" or some such nonsense
While you can do that, the thing you're talking about doing and the thing I'm talking about doing are two different things. Mine lists all funcs that contain the word quote - a fuzzy search - and yours strictly returns the Quote function. Make sure you know the intent of the thing you call unnecessary before you call it unnecessary :)
Correct. That is idiomatic Go. A package is comprised of multiple files. The "main" package is an application. Any project of any reasonable size is going to have multiple files to implement a given package. The btcd daemon itself, not including the myriad modular core packages which it makes use of like btcwire, btcchain, btcscript, and btcutil, is almost 10000 lines of code. I don't think it would be reasonable to expect a single file for that. Would you? From cloc: Language files blank comment code ------------------------------------------------------------------------------- Go 23 1701 3410 9341
I guess I just don't see why you would search for an identifier by name if you didn't already know its name. Searching by keyword (with `godoc -q` which is a much more complete search) or type (argument types in the case of functions - idk if Go has a tool for this) makes a lot more sense to me.
&gt; Take python for example. &gt; &gt; Each file is its own scope. How do you know where in the file the function is defined? You search for it - same with Go except instead of searching the contents of a file you're searching the contents of several files. &gt; What happens when another developer comes along and doesn't use a unique variable or function name in this monster main package. gofmt complains, golint complains, goimports complains. If you're using something like vim-go then several of those commands get run every time you save the buffer. Even if you're not using something like that you're still not going to get far before you have to run "go test" or "go build".
I see your point. But it's a trade-off. If each file was a package then that would encourage people to put thousands and thousands of lines in an individual file because one package can't access the non-exported functions/variables of another package.
It is a bit like python directory packages. But without the __init__.py and related complexity. For smaller packages it makes sense to have them all in one file. But with larger projects it can help to break them out in other files. Typically I will have a file for each type and it's related methods. godoc will combine the package and link to the source file where they are defined. It helps to locate things quickly. 
Thank you for your contribution, and for pointing out that this is an issue in the go landscape at the moment! I noticed this when I looked at go-tigertonic, and it reminded me of what I didn't like in javascript with chaining...
&gt; I don't really listen to the band Go listen you some Alice in Chains. (see what I did there?) Seriously, one of the best bands of the 90s. Vocals and harmonies like no other. Suggested listening order: 1. Dirt 2. Sap 3. Facelift 4. Jar of Flies 5. Alice in Chains 6. Stuff without Layne in any order And back on topic... great looking library. Starred in GH. 
A method declared func (t *Type) takes a pointer receiver: the given Type is modifiable by the function, which would not be the case if it would be func (t Type) - in this case, the method would work on a copy of the given type. The conversion between a value and a pointer is done automatically, so func(t *Type) method1() {} func(t Type) method2() {} t1 := Type() t1.method1() // implicitly converting Type to *Type t2 := &amp;Type() t2.method2() // implicitly converting *Type to Type by creating a copy edit: note that you can not do this - Go will interpret these as being the same function and will not compile: func(t Type) method() {} func(t *Type) method() {}
They basically mean just the opposite of each other. This will create a user struct and store the pointer to it in the variable: &gt; var user1 = &amp;User{"John Doe", "johndoe@example.com"} The next example means that the method will take the address of the User struct - allowing you to modify it -, but inside the function it will work on the data, not the address/pointer. The later is convenient since go doesn't support pointer arithmetics, so you will usually want to access the data, not the address. &gt; func (u *User) sayHello() 
I like to think about * and &amp; in terms of what they originally mean in C, which was my first pointer-ed language. Back then, what I made to think about them: *(sth) means "contents of". Like "that thing" &amp;(sth) means "address of". Like "over there" So, &amp;S is the address of S, whatever S is and given an address A, \*A is the corresponding "thing" which the address refers to. If you understand pass by reference and value, then most of the complex parts are already understood (essentially, what you can modify.) When defining a function you usually do it in terms of the object, hence the \*. So you say \*Type to refer to an address of an entity of type Type. In some sense, \* is passive (\*Type means something refers to type), &amp;something is active (give me the address of something!) and have to be used accordingly. Edit: \\* !!!!
I attempted to answer the question, but wondered, what an idiomatic way to solve this would look like. 
I got some good comments on this question before. http://www.reddit.com/r/golang/comments/1372mh/eli5_pointers_example_usage/ The takeaway I got from that was that if you want to have a struct that can change properties then use pointers. Then further research I learned that they are necessary on all your method receivers if any of them use pointers. http://stackoverflow.com/questions/19433050/go-methods-sets-calling-method-for-pointer-type-t-with-receiver-t 
Haha, I got [this](http://play.golang.org/p/QpgFDoGAg0) shitty implementation. I just realized what he wants can't be done with a set.
Nice! Considering you're using two for-loops to my three, I'd say yours is better.
Well it's also doing unnecessary operations with the map, so that all items in both lists end up in the map.
[Integer overflow](http://en.wikipedia.org/wiki/Integer_overflow).
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 490 time(s), representing 2.3061% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
Is it best to always use int64? I wanted to make that a general function I can reuse but couldn't work out how to enable it to take a variable array rather than a hard coded one.
[Here](http://code.google.com/p/go/issues/detail?id=4803)'s an old real-life example of an integer overflow bug in the bcrypt package.
**CODE**: http://play.golang.org/p/nbO5pUakEH I think of it like this: * Do you want to pass a copy of the obj/arg and then return it? Don't use pointers * Do you want to work on the original obj, not copy of it (more efficient for big objects)? Use pointer. If your using a pointer, you can only assign a memory address to it (aka reference via &amp;). In other words. If I do the following: &gt;var number int &gt;number = 1337 and I want to pass "number" to a function, I have to do the following if function is: &gt;func ptr(num *int){ *num = *num * 2 } I can only do: &gt;ptr(&amp;number) By using a pointer, I avoid making a copy of "number", and I also avoid having to return anything, as I am directly modifying "number", rather than a copy of it that I then have to return. 
It's a fantastic library (not framework). Beego is a framework, and it is also great for building web services. I like that Tigertonic is very simple. I like that Beego is very feature rich, has way more contributors, and is more actively developed. My fear with Tigertonic is that it will die away because there isn't much community momentum behind it. It really seems to be kept alive by a handful of people, and 1 company that is using it as their back-end. Having said that, Tigertonic is complete as it is, and the only thing that would be missing if the current core developers leave it is feature additions. Beego is constantly adding new features. However, my fear with Beego is security, especially with the prior release that had a security bug in it. Furthermore, although they did correct it immediately, I feel they don't have a good security auditing process in place yet.
Had forgotten about Pascal! I actually learnt pointers with it, but had a 5 years delay between Pascal and C...
I don't think Tigertonic is doomed, actually the opposite. Frameworks like martini, goji, beego or revel are targeted at different goals - building web sites. Just like Dropwizard is still alive and developed, people use it along with web frameworks like Play for building **web services**
http://golang.org/doc/articles/wiki/ edit: use gorilla for routing &amp; sessions http://www.gorillatoolkit.org/
Welcome to the world of static types ;-)
First: I'd spend some time with Go well before thinking about convincing anyone. You'll also have to weigh up whether the gains of Go (performance, maintainability) are worth the trade-offs over Ruby for web dev (libraries, community) - if it's a case where you're only doing 1000/hits a day, then the cost of migrating, retraining staff, etc may not be worth it. Go could instead stand alone and look after your API, or provide internal tooling - look to use Go in small, non-critical parts of your infrastructure until you're comfortable (and capable with it). It is not a hard language to learn, but as with anything you have no experience with, there is still the opportunity to Break Stuff. Anyway, without much context about what kind of "stack" you are trying to move to Go, it's hard to distil advice. If you *are* building some kind of user-facing web application, I'd recommend using a framework like Goji or gocraft/web, or a library like Negroni. All three tie in with existing net/http idioms (http.Handler or http.HandlerFunc), expose a fair bit of net/http and play nicely with other useful libraries (gorilla/sessions, schema, nosurf, etc). 
Nailed it. Tigertonic is designed around [JSON] web services: it says it right there in the README. For this reason alone it won't ever be as "popular" as some of the other frameworks, because user-facing frameworks are historically the ones that get attention. As for Beego, I'm not a fan of the API. On the mention of security I also had a quick look through the source at some "typical" culprits and found: * CSRF cookies with 60s timers. This could be secure, but unusable: the cookie will likely expire before user finishes completing a form or tabbing back to your site. Unless you replace the token via AJAX they'll likely get an error and be unable to submit their content unless they do a hard reload. It's configurable, but strongly prefer *sane* and sensible defaults. Also no mention of generating a crytographically strong key (using either crypto/rand to save to file, or openssl's CLI). * in session/session.go: // generate session id with rand string, unix nano time, remote addr by hash function. func (manager *Manager) sessionId(r *http.Request) (sid string) Whoa. Not good. Session IDs seeded with time and hashed with SHA1? They're already using crypto/rand there, too. gorilla/sessions [https://github.com/gorilla/sessions/blob/master/store.go#L190-L197] gets it right here, thankfully. (I'd submit issues against beego now)
Go Google "Go". Go on! Go for it!
Please just call it "Er", not "Erlang".
Don't try to make everything generic. Go is not Python, etc. If you go down that route, you'll waste a lot of time. (Don't try to solve the generic problem, just solve the problem at hand.)
To be fair on Martini, it's been "hot" for a while and I think it will continue to be. There's some magic there, but it does solve some real problems (namely, exposing services to your handlers easily). Negroni isn't really the same thing, although it does address a pain point (middleware).
If you want kind of an intro tutorial here is one based off net/http and gorilla. http://joshua.themarshians.com/hardcore-google-communicating-go.html I'm building REST services in goweb, but before I could really get productive or grok what was going on, I had to learn the net/http basics. Most of the various frameworks are implementing the interfaces defined in net/http and follow the same request lifecycle. Gorilla is kind of a good choice because it just provides libraries that enhance net/http instead of being an all-in-one framework appoach. goweb is killer for my application, but isn't documented very well and occasionally have had to go in and make changes. I rely on being able to understand the source code, rather than tutorials and documentation. In my opinion, Go is a programmers platform. Many people seem to be using mostly stdlib, rolling their own modules, and relying on as few external libraries as possible. There is a bit of pain involved with getting your environment and testing set up just right, but once you get over that hump it is incredibly productive. Stability - stdlib is pretty darn stable. If something changes, the compiler is good at telling you what broke. Frameworks - avoid where possible. Rack/Sinatra/Etc - Go tends to be explicit rather than expressive. Don't expects DSLs or other Ruby-isms. To me, writing Go feels like a cross between C and Java. Idiomatic Go uses small focused modules and no magic.
beego!
Hop over to the (http://golang.org/doc/articles/wiki/)[gowiki tutorial] and run through that. That'll give you a basic understanding of how net/http works. Next up, try your hand at something like martini / revel if you want to start popping right into large applications, or expand on the gowiki tutorial if you prefer doing things bit by bit. I host a net/http skeleton over at https://github.com/jadekler/git-go-websiteskeleton if you're interested in something a little simpler and quicker to jump into than those frameworks you mentioned. Either way, the gowiki is a good place to start and from there on just go based on how you're feeling.
If you are new to Go I recommend building a basic web framework from scratch (at least once), it helps you learn a **ton**! I wrote it up on my blog, but it's actually easier than you think to just write it your self.
crypto/rand is week http://security.stackexchange.com/questions/31643/how-to-predict-c-rand &amp; http://www.onlamp.com/pub/a/onlamp/excerpt/PUIS3_chap16/index4.html?page=2 I think add unix nano time, remote addr by hash function is much better than crypto/rand please refer to https://github.com/php/php-src/blob/master/ext/session/session.c#L284 about the issue detail please refer to https://github.com/astaxie/beego/issues/620#issuecomment-44230931 CSRF cookies with 60s timers should you make a misunderstanding. 
good articles. Crypto/rand has the comments here: // On Unix-like systems, Reader reads from /dev/urandom. // On Windows systems, Reader uses the CryptGenRandom API. Maybe it's safely in Unix. but I don't know the windows wherther is safely. but I think import the unix nano time, remote addr by hash function will make the sessionID much security &amp; uniqueness
It does not. I'm going to repeat what I said in my [issue on GitHub](https://github.com/astaxie/beego/issues/620#issuecomment-44235350), but don't "think" that using `time.UnixNano` will provide "security" or "uniqueness". The Windows CryptGenRandom API can be considered more than capable. Realise that much smarter people than either of us have contributed to Go's crypto implementations (i.e. Adam Langley) :)
you meaning no need to add `time.UnixNano`? And all rely on the `Crypto/rand`? how to guarantee the uniqueness? 
`rand.Read` provides all the entropy you will need. Just use it, and base32/64 encode the output (base32 is nicer because you don't have to worry about non-alphanumeric characters).
my another concern is :when I get the Crypto/rand get empty. rely on the unix nano &amp; sha1 I still can confirm the SessionID security&amp; uniqueness
I think that's a concern for the entire platform and not one you should be trying to solve in your framework.
That's fairly true. A few weeks ago, if you wrote "go" in the search box, you got nothing. So that's why I become used to write "golang" instead, even when "go" should be right. Just from a few weeks ago that Google became "that" smart enough to understand the difference between the action and the programming language. 
I think you got the point I didn't understand... &gt; Go does that for you automagically, though, so you don't have to. That was exactly the thing bothering me what I couldn't understand but now it makes sense. Thank you!
Erlang is the actual name of that language. Go's name is just "Go".
Well, this raises an interesting point: wouldn't Python's integer overflow as well? Edit: to me this isn't a static vs dynamic type issue, but rather a possible distinction in terms of how one language implements an overflow condition vs another language. I know that the typical C/C++ behavior here is the gold standard, but that doesn't mean that all other languages, including Go, do the same things in these cases.
I agree, but I really wish that every time I read this, that it was followed with helpful resources about how to get started. link ?
The best fit for a Go component in a PHP app would be doing asynchronous work via a Message Queue like [beanstalkd](http://kr.github.io/beanstalkd/). Push messages to queue from PHP then consume them through Go and do the specified work. I personally like [Laravel's](http://laravel.com/docs/queues) approach to queueing jobs in PHP, but you can definitely roll your own using the various beanstalkd wrappers for both languages. The disadvantage here is that PHP wouldn't be able to directly access the results of a Go operation, you'd have to check an intermediate data store for results (I personally like Redis for this), but I've always thought Go would be a great fit for computationally intense, asynchronous tasks on a web server. 
I'd forward you to the other active discussion on the /r/golang front page, [Building Web Services in Go](http://www.reddit.com/r/golang/comments/26j5wq/building_web_services_in_go/), because you're looking to build a web service there, which you will access by making HTTP requests of a running server. As fast as Go may be to run, you still don't want to be "exec"ing things very often in a web page. As for minimizing round trips, well, that'll be up to you. :)
Word of advice: don't try to do that. Go is *not* great at "generic" solutions to problems. Yet. It might be never. It's hard, if not impossible, to do higher-order-functions, or types - reflection and/or boxing/unboxing will come into play sooner or later and you'll wish you hadn't gone down that road. Go is really good at specific solutions to specific problems. This bugs a lot of people. Others move on. You'll have to decide eventually what kind of programmer you are - a perfect-world-or-nothing programmer or a pragmatic "yes, this kind of sucks, but no biggie" type of a guy. I find a lot of people in the first camp struggle to "accept" Go and eventually go down the rabbit hole of trying to make Go's type system play nicely with their ideas and either kill readability, performance, or both, then come out bitter and confused and flood golang-nuts with how Go's type system sucks. For your *specific* example, you need to decide if your calculations will fit into 32 bits or 64 bits and use the appropriate type. On a 64-bit machine, the type "int" is just an alias for "int64", which should be fine for most stuff. If you want arbitrary precision - import math/big. 
I like your approach, particularly how minimal the implementation is. Just a correction though: It's not true that you can't refer to the following handlers in [Muxchain](https://github.com/stephens2424/muxchain/). Take a look at how the [panic recovery](https://github.com/stephens2424/muxchain/blob/master/muxchainutil/panic.go) example works. Given that, I think the difference between something like Alice and something like Muxchain becomes primarily semantic. I think there's some advantages to an approach like Alice, but with Muxchain, you only need to use a special interface in the rare case when something like `defer` is required.
One of my posts, rest of the links are near the bottom of the post: http://austingwalters.com/building-a-web-server-in-go-handling-page-requests/ To be honest, going to golang.org and walking through some examples plus reading the docs and just jumping in would work.
Thanks for posting these videos! Looking forward to more
&gt;I find a lot of people in the first camp struggle to "accept" Go and eventually go down the rabbit hole of trying to make Go's type system play nicely with their ideas and either kill readability, performance, or both, then come out bitter and confused and flood golang-nuts with how Go's type system sucks. I find myself in this camp when I first started with Go (except posting about how it sucks). I've come to really appreciate the constraints Go puts out there. Those constraints really force you to focus on the problem in front you, rather than taking a tangent off to Architecture Astronaut land. And really, if you *still* need to make something generic to get something done, you can of course still do that.
Why not just making one function with this signature: func chain(middleware ...http.Handler) http.Handler { ... }
I'm not sure Go's simplicity attracts functional programmers more than othersI think its simplicity just attracts _everyone_ more. Also, first-class functions a functional language does not make. Generally, Go takes some great features from functional languages, but I don't see many people taking advantage of those features by implementing recursive algorithms, although that could just be from the high rate of imperative programmers adopting Go. If you want to see a systems lang that really takes aim at function programmers, look at [Rust](http://www.rust-lang.org/) (/r/rust) with its pattern matching, linked lists, closures, generics (ooh!) and general functional feel.
How is this reflectionless if you have a [giant switch-on-type block](https://github.com/mholt/binding/blob/master/binding.go#L263 )? switch t := fieldPointer.(type) { I think what you mean is data binding without the "reflect" package, but this still uses runtime reflection. 
[Parametricity in Go](http://www.jerf.org/iri/post/2923). A Haskell developer wouldn't consider that parametricity... and they'd be right. But it's a "good enough" sort of version of it.
This is what Negroni does and I've outlined in the blog post why this is not desirable. This way, a handler doesn't get any reference to the following one (you usually can not pass the next one to an already constructed handler. Also, you have to implement your own logic(a for loop running all the handlers for a request). Again, there are already solutions doing this. Alice tries to be different.
It's a real bummer the audio is so shitty! 
I would argue that go is great for almost everything other than shell scripting. The GUI libraries are also limited but I think that will change in time. 
I have to disagree here. I think that type assertions, if reflection at all, are compile-time reflection, because you get compile-time safety. There's no dynamic examinations happening here. In fact, the first thing the [reflect documentation](http://golang.org/pkg/reflect/) says is: &gt; Package reflect implements *run-time* reflection (emphasis added) Calling type assertions "reflection" is a bit of a stretch, even if the operation is similar in kind.
I disagree. Go is not mature enough for sophisticated image processing yet.
I don't know a ton about that particular field. Could you be more specific?
I'm sorry, but I don't see the point of adding another dependency to a project just to replace final := gzipHandler( rateLimitHandler( securityHandler( authHandler( myApp)))) with final := alice.New( gzipHandler, ratelimitHandler, securityHandler, authHandler, ).Then(myApp) Is it just me?
&gt; It's slower to write, without a doubt. I'm not sure about run-time performance; it's probably not much different. Sorry to say, but you sir sound to be an ignorant. Your code still uses reflection.
There isn't much use for first class functions if you can't even express simple higher order functions like: ('a -&gt; 'b) -&gt; []'a -&gt; []'b The lack of Algebraic datatypes and proper pattern matching doesn't make it particularly appealing eiher. As it was already mentioned earlier Rust is really the language to look at in case of functional programming.
Yeah, using `*bools`, at least (no obvious zero value), is pretty much mandatory for any serious REST API implemented in Go. To be honest this is a huge pain in Go compared to dynamically-typed languages.
I agree command-line tools is great, easy to use and once compiled it won't break if a dependency gets updated. I've had issues coming back to both Ruby and Python scripts after several months and broke due to dependencies 
Thanks for the post. Good discussion. I hope you find some time to provide a full example, though - a lot of people would benefit =)
I know some people have done some implementation of their own, but I'd really like to see encoding/json export its conversion of map[string]interface{} and such back to objects, because it would really help with advanced uses like this if you could marshal things into or out of map[string]interface{} to examine the original raw JSON, then take that and marshal it into an object again without much hassle. I'd like to see encoding/json export it, rather than someone reimplement it externally, so it doesn't go out-of-sync.
&gt; compared to dynamically-typed languages. Or any statically-typed language with an [option type](http://en.wikipedia.org/wiki/Option_type) (ML, Haskell, Scala, F#) or generics and value types so that you can implement your own (C++ and C#).
Are the slides available online?
I think it is useful to remember why google and rob pike felt it was necessary to create a new language. The [FAQ](http://talks.golang.org/2012/splash.article#TOC_6.) states: &gt;It was believed to be worth trying to design a new language suitable for writing large Google programs such as web servers, with software engineering considerations that would improve the quality of life of Google programmers. 
I guess it's up to one to decide. I've simply seen some people really annoyed by deep nesting of function calls. The library is certainly small enough to vendor or even roll out on your own based on this example.
There are a few links I've gathered over time, but I'm sure others will post them. I want to chime in and recommend that you read the documentation for the standard library itself, It's literally all you may need if you're not a beginner. It's concise, yet detailed, intelligent and well thought out reading. A lot of times I look for tutorials on a specific library, but find myself back in the documentation for the most helpful answers. [link](http://golang.org/pkg/)
Not sure why this is getting down voted. But Go still cannot compete against OpenCV or PIL. Thats what I meant and it has a long way to go.
http://hpcugent.github.io/easybuild/files/FOSDEM14/FOSDEM14_HPC_devroom_14_GoCUDA.pdf
I feel like this blog is incomplete without any piece of (contrived) code to demonstrate the in-built Go Api. Nonetheless, intriguing. Thanks 
Is this something like http://www.gorillatoolkit.org/pkg/schema?
This hasn't been updated much in the past year but [here it is](http://thestandardlibrary.com/go.html).
what do you mean by a full example? The [go-github](https://github.com/google/go-github) library uses this style throughout, so provides a pretty good example. Or were you referring to something else?
Hey, author here. The post was already really long/dense so I didn't want to try to include code in there too. To get the desired effect, you can create a MultipartReader and start reading the input in a goroutine. Here's an example of how to get a MultipartReader to stream a POST body: http://sanatgersappa.blogspot.com/2013/03/handling-multiple-file-uploads-in-go.html To get this uploading file to stream into ffmpeg, I wrote a handy class (UploadingFile), which allows one goroutine (with the MultipartReader) to write to the file, while another goroutine is blocked Read()ing from the file as it becomes available. This along with an example of starting the piped command is available here: https://gist.github.com/taylorhughes/9861cce37d9a5f1974a1 Hope that is helpful!
I think it's likely that Google learned about that time that *you* want Go when you type "go". The same happened for me a few months ago.
There are [multiple](https://github.com/quirkey/magick) [wrappers](https://github.com/rainycape/magick) for ImageMagick which should be sufficient (or overkill) for most uses too.
I am not a native speaker, but "negroni" does not sound like a good name for a project.
I use [go-bindata](https://github.com/jteeuwen/go-bindata), which looks similar at first glance.
tebeka's solution works, but I prefer go-bindata because: 1. nrsc has a dependency on the "zip" executable during compilation. People will compile my programs on all sorts of environments, and this is another dependency I don't want to worry about. This could presumably be baked into the nrsc tool but isn't yet. 2. nrsc has to find and read the executable *at runtime*. This is a dangerous operation because it's entirely possible that your program could be invoked in such a way that it can't find itself (what if the binary got deleted from the file system? Or ARGV[0] isn't what you expect? Or your program dropped privileges and doesn't have read permission on its own executable anymore, etc.) There are some ways nrsc could alleviate this like using osext and reading the archive at init() time to minimize the chance that it won't be there. Thoughts on this tebeka? Edit: Just to counterpoint, I haven't run into this myself, but the go compiler can have trouble with the way go-bindata embeds binary data into your program when dealing with very large asset files. It can greatly slow down the compiler and cause its memory footprint to blow up if you don't ask it to use the .rodata hack. 
&gt; nrsc has a dependency on the "zip" executable during compilation &gt; (...) Thoughts on this tebeka? Then rewrite it with archive/zip and send PR back to the author instead of wanting him to address your use-cases.
&gt; Edit: Just to counterpoint, I haven't run into this myself, but the go compiler can have trouble with the way go-bindata embeds binary data into your program when dealing with very large asset files. It can greatly slow down the compiler and cause its memory footprint to blow up if you don't ask it to use the .rodata hack. I have, and it's a pain in the ass. The go toolchain is super lean, but does not deal well with embedding resources like this. Compiling drone requires 1G+ RAM due to this very reason, and it blows.
&gt; GP has the mistaken belief that a type assertion is reflection Agreed, I was wrong indeed.
[Go 1.3+ Compiler Overhaul](https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8/preview?sle=true) by Russ Cox, December 2013. &gt; The Go compiler today is written in C. It is time to move to Go.
The go team had made a big deal out of wanting there to be two independent implementations of the language, to make sure that development is guided by a formal spec rather than there being an informal spec defined by the One True Implementation.
Slowness of gccgo is largely due to lack of escape analysis. gccgo uses standard calling conventions, and has nothing to do with gc "mojo" As for LLVM based go compiler, stay tuned for [llgo](https://github.com/go-llvm/llgo) (libgo branch).
One major goal of the Go toolchain is extremely fast and efficient builds. The team isn't even happy with the current compilation speed, and a benefit of moving the compiler to Go is that we have very good profiling tools for Go (the current compiler has never been instrumented and profiled). There are definitely improvements to the current compiler that will be rejected only because of impact on the time to compile, but other implementation are free to explore these avenues. I would be very happy to have the choice of a near instantaneous build using the Go toolchain, and a much slower building high-performance LLVM backend.
Of course, rust is not suitable for doing much of anything until it stabilizes. It's unfair to compare it to Go 1.0. As for the standard libraries, rust doesn't even have a good http client or server lib at this point. I'm not sure rust will _ever_ be suitable for webdev, but it sure [isn't there yet](http://arewewebyet.com/).
I'm about to deal with this problem, and I think the approach I'm going to take is to have the assets downloaded by the application during init if they're not present. Greatly simplifies the entire process. Download tarball, extract, run baby run. Works for my use case, at least.
It means gophers, the people most likely to want to contribute to the compiler, can now contribute without having to know GCC or LLVM or anything else really. It also means things that are taken for granted in Go can be used again - for example profiling and testing. I think it's Russ that mentions somewhere that the current compiler cannot be profiled easily.
Diagrams were super useful though!
E.g. http://blog.golang.org/gccgo-in-gcc-471
So... you implemented function composition with http handlers?
Thank you! I am actually working on something along the same lines, and your code will be a huge help in sorting things out in my library :-)
Go's standard library hasn't actually changed *too* much since I discovered it in 2010 or so. Even as a pre-1.0 language, Go already had: 1. Standard tooling 2. Interactive web playground for trying code 3. Excellent documentation. 4. Excellent guides, tutorials, videos, and the amazing wealth of information and help that is the golang-nuts newsgroup. And here's another huge difference between Go and Rust. Go is *not* just a language. It's a language+environment+eco-system+tooling+documentation. It's all those things. *All* of those are given very high priority by the Go team. I've never seen anything like it before, honestly. Rust is a typical Geek-driven project. I can spot it from a mile away. Spit out mountains of code now, worry about documentation later. They keep trying to create some "perfect" core language, and it's still quite unclear to me, what idiomatic Rust code is supposed to look like. Their own tutorials/documentation is either inaccurate/outdated, incomplete, or incomprehensible. I've suffered through their tutorials/docs multiple times and actually have a pretty good handle on what I think Rust is *supposed* to look like, but I have no *clue* if I'm on the right track. They refuse, like all engineers usually do when left unsupervised, to focus on the non-language-compiler bits. Cause they're boring. But I think they're going to realize, eventually, what a crucial mistake it was to just leave those until "after". And that makes me sad and angry, honestly. I don't see Go replacing the horrible drudgery and misunderstanding that C++ was/is, but Rust had a decent chance - if they had made a splash. Instead, it's been this whimper - "look at us - awesome language we got! Too bad you can't write more than trivial applications in it, but you will, some day, maybe, trust us, we promise, kinda, after 1.0...When is 1.0?.....ummm...when we say it's ...perfect? Until then, we'll break all your code, every week. Have fun, guys!" 
If you're interested in the write up: http://blog.chewxy.com/2014/05/30/the-nanjing-taxi/
[**@_rsc**](https://twitter.com/_rsc): &gt;[2014-05-30 02:24:56 UTC](https://twitter.com/_rsc/status/472201965565247488) &gt;pprof_mac_fix is not 100% reliable on OS X 10.9. If you've applied it, undo it unless you're okay with an occasional reboot. Sorry. [#golang](https://twitter.com/search?q=%23golang) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/26ue94%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I was about to suggest something similar, though more like func (self *Person) Initialize() { if self.Foo == nil { self.Foo = "Person" } } 
It gets many downvotes and would love to know, why?
I never thought about it that way, but I think it is a valid way to describe it. Although I think it is a more of an implementation detail.
I am curious, may you tell what are you working on or is it not for the public?
Yep, that might be true, given how good is Google showing custom results when you're logged in. 
It's simple and easy to use. I wrote it for practice.
My take: /r/golang reached some time ago the point of tolerance against discussions about yet-another-http-handler solution. Now I guess starting a one is the best way to score down-votes.
Far Cry 2's fire propagation was (essentially) done with cellular automata, so I could see an iteration of this approach turning out great. Far Cry 2 article: http://jflevesque.com/2012/12/06/far-cry-how-the-fire-burns-and-spreads/
Nice README, with the examples and all. I wrote a graph structure that also offers an A* search: https://github.com/sauerbraten/graph
hmm, maybe it is better to take a look first, before voting. But thanks for feeling the pain... :-)
but maybe you have more insight, if my solution has already been made? I did it some time ago and it was the result of several rewrites. Then all of the sudden there are all these zillions of microframeworks..... Have no time to keep track of them...
Here is a blog post about some selected middlewares: http://metakeule.github.io/article/tour-de-wrap-middleware.html Enjoy!
You just have to find a framework that has a good documentation and appeals the most to you. Apart maybe for the user base and ORM maturity I don't think that there are major disadvantages. 
I think I'll keep it as Conway's life. I'll let people set up gliders or whatever they want. Edit: So, by implication, what's bad about it?
&gt; but maybe you have more insight, if my solution has already been made? I'm not actually following all of those, I remember muxchain and goji - all of these are built upon the very same idea. To be honest I wouldn't use your library as I couldn't afford making external dependency to import "just 13 LOC" - what you've posted is good for a blog post or a gist, definitely not for a library. 
As a Java programmer, I find that Go's simplicity is hard to use. I think Go's simplicity will be a tremendous advantage for large, long-term codebases, but I have no experience to back that up. I can say from experience that Java's every-feature-under-the-sun tool box is a huge danger to the health of long-term codebases.
What do you mean, "hard to use"?
Holy fuck that's a long time away.
Very good. I am a big fan of truly distributed systems and especially the kademlia algorithm. I see that you focus on security (privacy? anonymity?).
There's nothing bad about the Game of Life. But, I think there's still work left to integrate it into the game -- as-is, I can't see what the area attack you showed us *was* in context of the game world. So, one example of iterating on the system that wouldn't involve changing the rules: frame it as spell scrolls, and introduce the players to patterns in-game. So, you'd create a a 'barber pole' pattern, and call it a "wall of fire" spell. (http://www.ericweisstein.com/encyclopedias/life/Barberpole.html) That little push can help players enjoy the system without understanding the game of life, while leaving room for advanced players to make their own "spells." I'm enjoying seeing your progress -- thanks for posting this! Also, don't take any of these comments as demands/suggestions that you do X or Y. My point was just that there are plenty of games that use cellular automata (for terrain generation *and* in realtime), and I liked seeing how you're integrating it.
The 13 LOC are just the core. But you may simply copy it for your projects. It might as well be nice for the standard library. Well the real benefit would be the reuse of the middleware repository. If it grows. But I agree, library dependencies are currently a pain with go and everyone wants to avoid them. There are solutions being made, however.
&gt; There's nothing bad about the Game of Life. But, I think there's still work left to integrate it into the game -- as-is, I can't see what the area attack you showed us was in context of the game world. Granted. This was the result of a one-day programming experiment in my game world. Basically, it's burning down the grid section you're in. &gt; So, one example of iterating on the system that wouldn't involve changing the rules: frame it as spell scrolls I was thinking of this. I'm going to introduce a Minecraft style crafting system with a procedurally generated tech tree. Crafting "Cnwylf" devices (scrolls) could be a parallel system. I would make initial cells cost "Bio" resources and also add a cost for things like delay fuses. &gt; I'm enjoying seeing your progress -- thanks for posting this! Thanks as well. I appreciate it. 
I dislike Go's template system for two reasons: - Dot syntax is weird. - Creating base templates and being able to just render one template without having to know what it's base is is annoying (i.e. it would be a lot easier if you could just parse a single file and have it's parent template defined in the actual template rather than having to supply the `ParseFiles` method with all of the templates. The latter is handy, but creates annoyances when you want to write an abstract renderer) After using Twig at my job, it feels way more powerful than `html/template`. One of these days I'm going to get around to trying Pongo.
&gt; Go is not just a language. It's a language+environment+eco-system+tooling+documentation. It's all those things. All of those are given very high priority by the Go team. I've never seen anything like it before, honestly. You mean except java, .NET or Python? Or XCode on mac. Or Borland Delphi from 1995. Or even [Haskell Platform](http://www.haskell.org/platform/). Basically except almost every other programming platform currently available.
I would say pointless for the most part. I dont think go was intended to run rails-like frameworks. Go is still far too verbose to be able to benefit from those rails-like frameworks that give you everything out of the box and the performance hit is really not there in terms of performance/expressiveness. For me the use case for go is to maybe write the API server that serves JSON and then consume it with angular or use it as the language to write your worker layer in and still have something like laravel or rails on the front. I think those "fast prototyping" frameworks are best coupled with fast prototyping languages, hence for example why play is so much better / more intuitive if you use the Scala version instead of Java...Its the same with the frameworks you mention, they use reflection and all other types of trickery to make it feel like dynamic language when its not. 
Why not just make testing a branch of the main repository?
Yeah, that YAML parsing is a bit of a mess. Thanks, I will try to refactor it.
Thanks for the links, those are interesting projects. The caching I am doing is more of a caching of thumbnails (once an image is transformed the derived version is stored) rather than actual in-memory caching. I will have a look at what I could do about it to at least keep some images in memory and make their retrieval faster.
That's great, Doug.
That's great! 
Well, *I* for one had a good laugh reading this.
This is exactly what I'm looking into go for (feeding JSON to Angular). Not because it couldn't be done in other languages, but more as an excuse to learn go.
1 - It has to do with how much memory the integer uses, and thus how high (or low) of a number the typed variable can represent. int32 uses 32 bits of memory and has a range of -2147483648 to 2147483647. int64 uses 64 bits of memory and has a range of -9223372036854775808 to 9223372036854775807. The size of int is "implementation specific" and could be 32 bits or 64 bits. Currently, it's 32 bits on x86 and x86_64 implementations of Go I believe. I could be wrong about that, though.
It's hard to answer that question. I'm not sure what those frameworks are like, but after taking a quick peek at their project pages I would say that most of Go's web frameworks are not like them. Most of Go's frameworks are built upon the spartan net/http package in the Go system library. It's a very simple interface that a lot of Go programmers enjoy, thus many frameworks stick to those ideals. I think there are a couple of Go web frameworks that will provide you with varying levels of sugar and magic, but you reach a point where Go is probably not the right language for that kind of thing.
Ok, that has me wondering - what application would that have? Why would I ever need such a big (or small) number when programming?
Well, here's a real example. Most services assign unique IDs to entities for storage in databases, and they're often incrementing (1, 2, 3, ...). Twitter had so many users that their user IDs grew larger than the size of a 32 bit integer, causing several Twitter clients to break. Now, Twitter clients must use 64 bit integers to properly store user IDs that are larger than the maximum positive 32 bit integer. In other cases where you don't need to go that high, you could stick with an "int" or "int32". There's also the concept of signed and unsigned integers. I explained the limits of a signed integer (an integer that can be positive or negative) in my other comment, but if an integer is designated as unsigned (can only be positive), it has a higher maximum value. In Go, an unsigned integer is designated as uint, uint32, uint64, etc.
From a learning perspective there's no real advantage to using Go. The resources in terms of community and educational materials are very good, and will only get better, but still don't compare to what's out there for Ruby/Rails, Python, and the myriad other "web app" languages. How this effects you will depend on your effort. Someone will make the argument that you learn things "closer to the metal" with Go and you'll be more aware of how a web app actually works, but you can do this with any of the other languages. The main disadvantage is you don't get all of the rapid protoyping facilities the more established languages and frameworks have. You will also need to learn how to interact with a SQL database as well, as wrappers are sparse(which can actually be a good thing to learn early on, it's just more to learn). Go's an interesting first choice for a web development language to say the least. If you decide to go with it you'll probably put some more effort in than if you went with a dynamic language, but there's no doubt you'll come out with some very solid knowledge to build off of.
Thanks! That's made the most sense to me so far.
Awesome! I'll check those out tomorrow.
Take a look at https://gobyexample.com/
I wrote an all code introduction available on Github https://github.com/mkaz/working-with-go I welcome any feedback or suggestions on how to improve, what to include more
Actually I had just this idea some time ago, but in a different context. I think we should introduce a single P2P platform to allow synergy between projects. Imagine you had your social network, photo sharing and git hosting on top of one DHT. You could post a git branch just like a photo or text. Along with some pub sub, this is the future(TM).
You know, a bit like camlistore, but global and encrypted.
I released [Alice](http://justinas.org/alice-painless-middleware-chaining-for-go/) just a few days ago. It's really similar, yet subtly different to your approach. The main difference is that in Wrap, handlers require to satisfy a completely new interface, even if it's just the `Wrap()` method. Thus, a new ecosystem of handlers must be built and the approach is not directly compatible with existing middleware (throttled, nosurf, etc.). Alice deals with it in a different way: it advocates writing constructors where needed (and some handlers are compatible out-of-the-box). Whereas adding a new method to an existing type is hard (you have to at least alias the type), making a function is easier. I'm not here to boast of my own library, but just wanted to highlight how Wrap seems a bit more like another micro-framework, especially with its own wrap-contrib. But what I (and many others, I believe) would like to see is more framework-independent middleware that can be used with anything. Matadi puts it quite right: &gt;In short - a lot of gophers, especially beginners, became so obsessed with organizing middleware, that they forgot to actually write any. 
whenever i am working on a go project when i go into the root path i run export GOPATH=`pwd` i could probably make it an alias.. infact i will. 
unsigned int also wrap around to zero, but the overflow of signed int is undefined. i = uint32(4294967295) &lt;- max value for 32 bits unsigned int, 2^32-1 println(i+1) &lt;- prints 0 
Good to know, thanks
nice and high-quality only thing missing is script support and some annotations about which functions are safe to be called from a go-routine
You may want to take a look at: https://godoc.org/github.com/npat-efault/bundle https://godoc.org/github.com/npat-efault/bundle/mkbundle 
Amusing writing style - wat?
Hello ayajibo, I may be a little late, but just wanted to refer you to something on my [Github](https://github.com/PrikPrak/Go_101) that I've been working on that might help out. It's not much, but it's getting there. I'm currently working on detailed writeups for each exercise which also includes summaries. Just wanted to point that out since I am aiming for the summaries to be effective to people who aren't new to programming but would still like to get the big picture. I'm hoping that if you do take a look, please provide me with any feedback that may improve it and be useful to you! Thanks and I hope it was helpful.
Cool, I would mention this fact in doc.go at the beginning. Yea, looks good to me but might not be worth the effort after all. You are right, it is easily achievable from the connection.Do* methods. 
Hi! I'm the guy who wrote the post. I'm really a newbie when it comes to all this (as I'm sure the post highlighted quite nicely!) so apologies in advance if I say something stupid (it's a chronic problem I've been battling for years) :D The middleware problem is something I've yet to solve -- in fact it's currently on today's todo. I've seen a few ways of dealing with middleware for a basic net/http stack (I think a middleware chainer called [Alice](http://www.reddit.com/r/golang/comments/26giug/alice_painless_middleware_chaining_for_go/) cropped up a few days ago that looks promising. Worst comes to the worst, I could always just do something hacky and prepend a function to each route handler that contains typical middleware stuff; not the way I'd want to do it but it would get me by for the moment considering my project is still very small. That code snippet is actually really cool; I love the idea of the handlers returning on an error and the proper error conditions getting invoked in a switch. I'll have to give this a whir a bit later. Cheers!
Nice trick but for i := 0; i &lt; 4; i++ { } works just as well. This trick does make the for loop more like a python loop. 
It uses 12 bytes actually. | http://play.golang.org/p/9h2QjLGLRm And []interface{} will do too. | http://play.golang.org/p/6LRNrfD2kn See also: http://stackoverflow.com/questions/2113751/sizeof-struct-in-go
A slice header [is always 12 bytes](http://play.golang.org/p/1LRgd8RjGg) on a 32-bit system. 32 bits (one word) for each of: the pointer to array, the length and the capacity. This does not reflect the actual memory allocated for elements. An empty struct really [does take zero bytes](http://play.golang.org/p/9Fb3UnQOL7) though. An interface variable [takes two words](http://play.golang.org/p/2dgnD3-QKR): one for a pointer to the vtable, another one for a pointer to data. ([more info](http://research.swtch.com/interfaces))
Oh, I see.
Well I just touched the core of wrap. There is for example also a shortcut to use a http.Handler as wrapper: wrap.Handler If you think about it, a wrapper can act as a http.Handler generator which is much more powerful as you can see by the middleware. I am not obsessed with organizing middleware and would not consider me to be a beginner gopher either. wrap settled some time ago and most of my middleware is application specific and therefor not part of wrap-contrib. I just found it an elegant solution, compared with others I stumpled upon. But it also integrates fine with rest of my web framework, I am going to publish module by modul as they stabilize.
You're calling panic.. Please fix this terrible example or at least note that you're doing it wrong for others that come across this.
Allocating memory then throwing it to the garbage collector after the loop finishes isn't "no memory overhead". It's the very definition of memory overhead. Even with the garbage collector, what if, inside the loop, a reference to the empty array underneath gets assigned to the variable? Now the whole array sticks around. All you're doing is trying to make Go more Python-like, and that's a sign that you don't quite understand the language all that well yet.
I was more referring to how every new stack required adjustments to existing middleware or creating entirely new ones. If anyone, it's probably me that's obsessed with every package being cooperating with the standard interfaces. Thanks for bearing with me and making the interoperability a bit better. :)
I got quite the chuckle out of this. Made mah day 
Did some joke just go over my head? Dammit...
You have to do it in the the ParseForm() method for the *Request object that gets passed in (at least that's how I'm doing it)
Brad Fitzpatrick is one of the main guys writing the Go language.
Brad Fitzpatrick is one of the primary Go authors and is largely responsible for net/http: https://code.google.com/u/bradfitz@golang.org/ By the way, this whole package fits in a single tweet.
Disclaimer: I posted it just for the value of the cool trick and the lesson that struct{} has a size of 0, and I've never used this nor do I intend to use it in real code . Having said that - consider a loop of millions of iterations. Compared to that, and compared to iterating over [1000000]int - the memory overhead can be considered zero. Of course if you use it as an inner loop, things might be different, but if you have millions of inner loops you might have other optimization problems to tackle.
Escape analysis will figure out that the []struct{} never leaves the function it is created in. The []struct{} will be placed on the stack where 12 bytes isn't that much of an overhead. Even then, the compiler might disassemble the struct into individual variables (and thus throw away 8 of the 12 bytes) once it sees that the struct lies on the stack.
So what's the disadvantage of this? Why isn't it used by default to iterate?
It's not idiomatic.
a. It's redundant. For the sake of saving a few keystrokes and some syntactic sugar that doesn't give you any real simplicity, you'r calling an extra function and complicating things a bit. b. If used in a tight loop just the tiny allocation overhead of the slice header itself, plus the overhead of an extra stack frame, will slow things down a bit. 
No; There is an important difference: In your example, it is possible to modify the value of i _inside the loop_, skipping certain values, or iterating over some multiple times. That is not possible with the iter.N version the op linked, because the iterator value will be reset at the start of each iteration. Basically, the iter version hides the internals of how the i's are generated and which condition is evaluated for the loop to finish; Those things are still 'bare' in your version. Both have their use cases, sometimes you want to intentionally skip values, sometimes you want to prevent exactly that. Edit: Not only could the i be modified inside the loop, the upper boundary, here '4', could also be changed(if it was variable). And the initial value for i could also be a variable, while the range iter.N version makes it explicit that _all_ values from _0_ to _N-1_ will appear _exactly once_, without jumps and in the correct order. That are a lot more guarantees than what the simple loop gives you.
See my reply above: http://www.reddit.com/r/golang/comments/270vzu/nice_trick_iterate_ranges_with_no_memory_overhead/chwqs66 Any of the things I mentioned range iter.N prevents you from are actually also the things you can't do with it, even when you need/want to.
That's pretty cool, thanks!
I'm not precisely sure what you're asking, since the example code is not runnable (nor even valid). Guessing a bit, you probably want to do something like this: http://play.golang.org/p/wxxNB6nxQQ This uses indexed arguments to fmt formatters [introduced in Go 1.2](http://golang.org/doc/go1.2#fmt_indexed_arguments): fmt.Printf("%[3]s, %[1]s, %[2]s\n", "vidi", "vici", "veni") // veni, vidi, vici
Why the hashtag for #golang? Just curious
Nice - this is sorely needed!
It's not quite this fancy. An empty struct value requires no memory, so a slice of them also requires no memory (aside from the slice header which, like all returns, is kept on the stack). The allocator has a [special case](https://code.google.com/p/go/source/browse/src/pkg/runtime/malloc.goc#50) that doesn't actually allocate for zero-sized allocations.
I use LiteIDE for Go and I love it... Right out of the box it has good intellisense, very good project navigation, jump to definition.. the only thing I don't like is that makes Visual Studio feel so slow when I go back to it :P 
LiteIDE is fantastic for Debugging. I use VIM 7.4 with VIM-GO plugin for actual coding. It takes a bit of work to get working, but once it's working, it's fantastic. Let me just say that "YouCompleteMe" plugin makes Vim into something really special...nothing like NEOcomp... way less intrusive. Relevant Links: * https://github.com/fatih/vim-go * https://github.com/fatih/dotfiles/blob/master/vimrc # I was lazy so I used his vimrc to get going quickly Otherwise, if you want to try VIM but are new to it, use this: * http://vim.spf13.com/
The most common editors used are vim, sublime text, and emacs. Although not supported out of the box, they all have plugins that make editing Go as good as any IDE. I use sublime text - there's practically 0 learning curve to get started, but there's still a great depth of customizability.
Atom.IO has golang support. There is also a plugin that has some features that sublime doesn't support.
I am a vim/vim-go user - to answer your original inquiry, it seems visual studio has some basic support for the Go language [link](http://visualstudiogallery.msdn.microsoft.com/bd7675ba-1bf5-4395-8c5a-4fc19dfc0d76)
I use emacs, myself. It's easy to pull the Go docs into an editor window, and refer to them whilst coding (and in fact there's some relatively easy work that could be done to make this even better; I've just not done it yet).
With this code, you could just do i = iter.N(n). Or do i = i[n:] to skip an arbitrary number of iterations. I'm 55% sure this is a joke package... The pretty-sure-its-snark in the README and package comment are just earnest enough to make me question it... Damn it, /u/bradfitz.
I've tried Atom just yesterday. Two main shortcomings: 1. It's slow (there is a lag when typing/scrolling, which is to be expected as it's based on webkit AFAIK). 2. It doesn't have any real context sensitive completion. It just completes tokens and highlights the syntax but has no real understanding of the language. 
Too many bugs :(
* Sublime Text + GoSublime for package completion, error checking &amp; gofmt on save. * vim + NeoComplete + the contents of $GOROOT/misc/vim to do all of that within vim. 
I'm checking out Atom now, It fronts a good presentation, I'll see how I actually feel about it. Building now.
Thanks for your analysis, really appreciated. Yeah, you're right with the buffering. Somehow too blindly copied patterns. Will change it. And reading the connection directly in pub/sub sounds better, yes. It even is better in a scenario where multiple clients subscribed to one channel. Good hint, like the one with the returning of the resp. Will change that too. `StringSlice`and `StringMap` are very simple own formats with strings separated by CRLF and, in case of a map, those strings in the format key:value. So it's only a little pre-interpretation of string values. For more complex structures I want to add JSON support in future releases. In case of `Unpack` I have to think by myself. In earlier versions I had a situation where data has been in square braces. Maybe it isn't needed anymore. Will check. The `monitor` command is really interesting, it returns a non-standard return value. Also here thanks again, will check how I can handle it in a good way.
This is **exactly** what I was looking for. Thanks!
I pray to see the day that JetBrains does a full-blown IDE for Go, C/C++ and Haskell. C/C++ IDE is on the way.
+1 on fatih/vim-go. It ties everything together quite nicely. Sidenote: I feel like vim with [B/V/NeoB]undle and a *few* packages is all anyone needs to start out with. Writing your own vimrc is the best way to learn about vim - and making it your own is way more satisfying.. 
no showstopper here.. intellisense sometimes gets confused and doesnt show up.. but I havent found any serious bug honestly... so I don't know what you refer to. I am on Windows and I use it occasionally on Linux.
I have same like [this](https://code.google.com/p/golangide/issues/detail?id=53). And some others. 
I'm not sure if I get what you mean; of course you can do i = iter.N(n), but then the type of i will be a []struct{}. And in this case, the n will be fixed at the start of the loop, and changing the value of the n variable afterwards will not change how often the loop runs. If you change the slice boundaries inside the loop it will also not affect how often the loop runs. The only way you can manipulate it is by changing the size of the slice _before_ the loop. I have tested all of that here: http://play.golang.org/p/kb8bWmp84l And if you do not put the result of the iter.N() call into an extra variable, it is becomes even more difficult to change the size of the slice in a hard-to-detect way. Please tell me if I'm wrong somewhere, but I can't see what you mean.
Atom's go plugin builds and shows errors, something vim-go also does but GoSublime doesn't. http://i.imgur.com/bWqVbA3.png 
BTW you can get everything you need from a Python style range iterator, actually a real generator with interntal state, by using channels - here's a simple example: http://play.golang.org/p/0jXFy2UDAW however this comes at a terrible performance cost, about 200 times slower than using an ordinary boring for loop.
I use JetBrains's IntelliJ IDEA with the Golang plugin, and works really well. I noticed very few bugs (none at all for a fact) and responsiveness is amazing.
All existing functions shall stay how they are. Only thought about additional helpers. But maybe it's better to let the user do the serializing/deserializing and simply store or return that data as []byte as it already works today.
Agreed, I also have autocmds set up in vim so run go fmt and goimports on a save. I would also add go-code to the mix if you want tab completion.
It was very slow for me like a week ago but I just tried it again today and it works really well. You can use the plugin auto complete plus which will improve the suggestions. The thing I like most about it is you can style anything through a less stylesheet.
Sequence diagrams cover this. Here is a (non-go) example: http://www.umlgraph.org/doc/dist-52.html However, I usually think of channels in a similar manner as unix pipes. Channels can pass the data from task to another, so there should only be one owner. Race conditions can also be exposed with go run -race
I run code in my brain - it detects most problems. For everything else there are tools: profiler, race detector etc.
this is probably a stupid question, but does VIM-GO install Go as well? Is that included in the "all necessary binaries if they are not found"?
While I don't mind the dot syntax particularly, I do agree with you that the way that base templates are handled in html/template is not optimal. I created a version of it that provides Django-style template inhertance that feels much more natural to me. https://bitbucket.org/adamcrossland/mtemplate/wiki/Home
I heard about it but is it available for download? last time I checked didn't seem so
Not yet, they just showed off a beta build at that conference.
There is but obviously it's not as good as a dedicated IDE would be
I am new to Go and want to use Redis. What are the advantages and disadvantages of this client compared the others listed at http://redis.io/clients#Go?
It's in private beta. You can download it here: * Linux: http://download.jetbrains.com/cpp/cppide-peap-5.tar.gz * OSX: http://download.jetbrains.com/cpp/CppIDE-PEAP-5.dmg * Windon't: http://download.jetbrains.com/cpp/cppide-peap-5.zip
[Thanks!](https://i.imgur.com/UiaK1sP.gif)
Not a stupid question. You need to install golang separately. Though, installing Go is super easy. Just search google for "Your OS" + "Install Golang"
Does this mean that Go uses the same optimization for chan(struct{}, x) ?
Yup, emacs is pretty nice for golang development. I wrote up a 2 part blog series on customizing emacs - http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/ if you have any tips on better integrating godocs, pls leave a comment.
Thanks. Yeah I already have Go installed in my vm. Didn't want vim-go to mess with my installation. I'd prefer use LiteIDE but I don't think I can if my Go install is in a vm :/
I use LiteIDE + Vim-Go in a VMWARE VM (Debian XFCE4) running on an SSD.
Ubuntu may have issues, especially the newer version. My old dev VM was an Ubuntu 12 install. I dumped it for Debian because I found it ran slow and the new Gnome Unity interface is too bloated for what I need to do (write code &amp; browse web). If you are comfortable going through console, just install a minimal Debian desktop (Gnome or XFCE4), and use that. It's faster than Ubuntu and you get a fast fully working desktop system. Seriously...Ubuntu has gone down hill ever since unity. My Ubuntu install can't even save the session state (open windows, etc...) Also, I find VMWARE Player to run better than Virtualbox for me...I have both, though. Both are free.
-race is a great utility, however it will not detect every scenario. I think it'd be better to model your scenario and hopefully reason out any race conditions, and then use -race as a bumper to prevent them from happening by accident.
Emacs or vim with the applicable go plugins are all you need. 
Thanks again for this great review. Helps me to improve the client (already done).Sometimes feeling too blind. ;)
Cannot really say. Started development to got one that behaves like I want when I there haven't been so many. Take a deeper look at the APIs on GoDoc (like here http://godoc.org/github.com/tideland/godm/v3/redis), compare them, choose two or three that look good for you and do some tests. My focus has been on flexibility and convenience.
That MapToJSON func is backwards if all or most of your handlers are going to be returning JSON. Try something like this sketch: http://play.golang.org/p/QCiNUM43SJ Essentially you create your own version of http.Handler tailored to your application that takes care of all the things you have to always do so your handlers are just doing what's important. 
I'm pretty sure the first Gophercon had an equal or longer plan time.
Awesome!!!
I use chrome plugin that save bits from stackoverflow into a file. No need for a editor really. If it doesnt compile i send it off to some bloke in India.
I've tried sublime text and intellij but lately I've been sticking with lite ide. Each has their strengths and things I like about them as well as things I think are missing. 
vim-go author here. It's an awesome feeling that it's picked up like that and lots of people like it. Thanks for all the support. Just for autocompletion: * Autocompletion in Vim kinda sucks, that's why you need to install several other plugins like YCM or NeoComplete. If you install them you get a better experience (like completion on the go), otherwise autocompletion is still supported, just you have to call it in vim-style (C-x C-o). 
Komodo IDE has a [golang addon](http://komodoide.com/resources/languages/komodo--golang/), it will likely become a natively supported language in Komodo 9. So far it supports; - Syntax highlighting (including folding) - File-type detection for .go files - Linting - Codeintel via Gocode - Jump to definition via godef It was originally developed by Trent Mick, who was the lead Komodo developer before he left to work at joyent.
This is awesome! Thank you! I'll be taking a closer look at it tonight. Do you mind adding a 'How to contribute' section to your README? Some authors are open to anything, others are opinionated =) edit: One more thing - hop over to [golang-nuts](https://groups.google.com/forum/#!forum/golang-nuts) and crosspost it there, too!
On Windows the Zeus IDE has support for Go: http://www.zeusedit.com/go.html It does the stock standard syntax highlighting, code folding, smart indenting etc. But Zeus also understands go code so it also does class browsing and code navigation (i.e go to defintions). It also supports gocode autocomplete, automatic goimport on file save and has debugger support via gdb. *Jussi Jumppanen* *Author: Zeus IDE*
You're welcome :)
Nice talk, Brad... I enjoyed reading the deck. One thing is bothering me still. GC overhead is killer, I simply cannot afford to stop the world for even 5ms. I hear a lot about Go being better about not creating garbage, and you mentioned this in the context of gccgo and RT motion control. Could you give any sort of intuitive rundown of Go's GC overhead? Am I going pay out the nose in the high percentiles, like with Java?
I've seen go sublime show errors. But now as nicely as what you show from atom. I've heard that there are some performance issues with atom. But I do like that it is open. And because of that I think it will overtake sublime in a year or so.
Assuming it continues to improve of course.
Anecdote: a group at Google rewrote a service from Java to Go. The group monitoring it expressed disappointment to us that the GC pause times were 2-3 times higher once they switched to Go. We pointed out that was not true: their Y axis was now labeled microseconds instead of milliseconds. In summary, it's not that bad. You really can avoid making much garbage and keeping your pointer-containing heap small. And Go will parallelize GC. And it's all getting better with each release. 
Just cringe a little every time you allocate memory (calling make or using &amp;StructType{}). It's not bad to allocate memory (indeed, at the start of the program you have to), but many times you can reuse memory you have rather than allocate new ones. If you cringe a little every time you allocate, you at least think about it.
Honestly don't worry about it until there's a problem or you want to make something faster. Then profile. The memory profiler will tell you where you're allocating.
So, it worked!
Unlike Java, Go lets you control memory layout. You can allocate objects on the stack*, and you can create array of objects, where in Java you can only create array of references to objects. *Even if an object seems to be allocated on the stack, the compiler will allocate it on the heap, unless it can prove that no reference to it can escape. This is required prevent dangling pointers and ensure memory safety.
So, is it purely a joke or did you ever use it or meant it to be used by others?
Take-home points for new gophers - [point #1](http://i.imgur.com/TqP9N3S.png) [point #2](http://i.imgur.com/KlHV12Y.png)
You'll leak if you `break` or `return` inside the loop as well.
Has the Go team considered something like automatic reference counting? It seems like that could further reduce the pressure on the GC for things like []byte to string conversions.
I strongly disagree that Javascript is more fun than Go or as fun as Ruby and Python. 
.NET, Java, Obj-C are corporate-backed languages with lots of investment in them. From what I can tell, the core Go team is less than a dozen people with few resources provided by Google other than some server infrastructure. It's basically a hobby OS community-driven project, and I'm not aware of any other ones like it. Again, Rust, a close competitor, doesn't come close to offering the support for new programmers that Go does. Python? I first came across it in the 1.5.x days, RedHat 5.x or something, and there was no real community behind it. That language languished in obscurity for a decade on Guido's hard drives before it got "noticed". Heck, when I first started playing with it, people were still comparing it (unfavorably) to Perl! "Yeah it's kinda cool, but Perl has so much more community backing". Well, the tables sure have turned, haven't they. Same with Ruby - I remember people didn't understand that it was older than the Rails framework, which is when it came into the mainstream, and again, that was probably close to a decade after it was first released. I learned Ruby from an extremely shitty free ebook that was already "too old". But it's all I had on the language. Go had tutorials, videos, FAQ's, guides, references, docs from *day one*. 
I wanted that the import path reflects wether it is blessed middleware or unstable. It is also easy to grep the source code for it to find places where unstable repo is used.
see github.com/go-on/wrap-contrib and github.com/go-on/wrap-contrib-testing
What's the roadmap for Go gc development? Parallel M&amp;S? Concurrent? Generational? 
Automatic reference counting can't be used as direct replacement of the GC, because programmers will be forced to reason about loop dependencies and a language will need another type of pointer - weak pointer. And by the way, ref-counting can easily kill performance very much like GC, because runtime will need to allocate two memory blocks for each object - memory for object itself and memory for ref-counter. If GOMAXPROC is not 1, ref-counter must be incremented/decremented using atomic operations, this can result in further slowdown in high contention scenario (when one object used frequently by many goroutines).
Can you explain your use case where a 5ms pause creates an issue for you? I've done industrial automation for years, and whenever I have something that's latency critical, I wind up using a PLC to control the process and the software on a computer simply updates setpoints on the PLC. Even in voice processing (telephony) a 20ms gap is difficult to hear. 
Automatic reference counting is really just a variation on GC. In some cases it performs better, in others worse, especially if locking or atomic operations are needed, or cycle-detection is required. The main point to it is the runtime cost is spread out, rather than all at once. There are other approaches to GC that do that as well.
That axis says _'fast, fun_ for humans'
IMHO, Javascript is neither 
Looking at your comment history, the same can be said for you
Perl is definitely not fun for humans. It's only fun for a human subspecies , namely the Perlmonks, the gatekeepers who possess infinite Perl wisdom. You can't place Perl and Python at the same fun level.
Simon Peyton Jones - Haskell is Useless https://www.youtube.com/watch?v=iSmkqocn0oQ
I don't have audio. Is there a good summary available?
LiteIDE is the best thing I have also found, I've tried many other things too. Note that I'm on Windows 100% of the time (except deploy on linux boxes). Coming from Visual Studio LiteIDE feels like home. Conf F7 to build and run the app inside LiteIDE, I don't want random terminals laying around and configuring watchers to see when I save a file as reboot my app. That being said, on my work related VS things, I never run the app inside VS :) It does have bugs and annoyances. If you can get past those things or learn how to live with them its a great tool for go. One big problem for me is contributing. I know C++ and Qt quite well and would like to help out, but the repo structure and all of its quirks just made me give up after 30 minutes...
yeah, of course, you need to use select pushing down the channel or something as a safety mechanism. I just wrote it in a couple of minutes to demonstrate the principle. 
If you are importing local libraries and you aren't getting intellisense on them do a go install of those libraries.
Practically speaking, is Go really faster than Java 7 for real world systems? I know that theoretically it can be, but is it really? According to these toy benchmarks it isn't: http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=go&amp;lang2=java&amp;data=u64q And according to these, more real world cloud tests (check the EC2 numbers), Java seems to be leading the pack again: http://www.techempower.com/benchmarks/#section=data-r9&amp;hw=ec2&amp;test=json It might be more fair to say that Go is on par or slightly behind Java, although I'm sure it will catch up. This isn't a strike against Go, after all Java has had a decade of research poured into optimizing its GC and JIT.
Thanks for the hints. Looking forward to your feedbacks.
In my experience, yes, for real servers, largely because it doesn't GC as much. In loops in microbenchmarks, the Java JIT often wins.
Is there an audio/video recording to go with the slides?
If GC wasn't a problem in your Perlythonubyscript program, it won't be a problem in a similar Go program. It's just that now that the program logic runs 50x faster, the GC pauses are a higher *percentage* of the CPU time it uses.
This is the right answer. While we all should try to code smart, moving into optimization areas like this is where you really should measure first; inefficiencies can manifest in very unintuitive ways. Otherwise, you're just guessing.
Unfortunately not. It wasn't recorded. 
&gt; Automatic reference counting can't be used as direct replacement of the GC, because programmers will be forced to reason about loop dependencies and a language will need another type of pointer - weak pointer. Well, it *could* be introduced as such, but it would either be a new kind of pointer or you would just make all pointers ref-counted and generate code that is incompatible with older versions of Go. Neither of these are very compelling reasons to do so. &gt; And by the way, ref-counting can easily kill performance very much like GC, because runtime will need to allocate two memory blocks for each object - memory for object itself and memory for ref-counter. If GOMAXPROC is not 1, ref-counter must be incremented/decremented using atomic operations, this can result in further slowdown in high contention scenario (when one object used frequently by many goroutines). Those are also deal-breakers. FWIW, mark &amp; sweep garbage collection also needs the same atomic concession, but it typically does so by "stopping the world" to figure out what blocks of memory are in use; this is like having one big mutex on the entire heap, rather than atomic locks on every object. There are ways to do concurrent collection, but it's not clear to me how Go is doing this, if at all. The best way I've heard it all explained is: * Ref-counting == pay now * Mark&amp;Sweep == pay later They're *both* Garbage Collection algorithms, and are opposite sides of the same coin. M&amp;S is centralized ref-counting where you never count above one, and ref-counting is decentralized M&amp;S where you always sweep a graph of one object. They're both general purpose algorithms that have drawbacks in certain domains.
AFAIK, M&amp;S can be implemented on x86 with only two memory barriers. RC is much more work overall. It can be easily seen in C++ code, create vector of shared_ptr-s and than delete this vector. If vector is large enough - your program hangs for a long time - much longer than equivalent (if it's possible to say that) GC phase. GC problem isn't a number of collected objects per second - it is pauses. But many things in your program can cause pauses like that - page fault or dynamic library loading.
Just musing, it might be nice to have weakref's as an option, so you can do things like "thread local variables" (or in this case, goroutine local)...
While we're on the subject of labelling Y-axes, what are the units of the "fun for humans" axis?
GC's are only a problem for people coming from languages without them (C/C++).
If you return `(int, error)` it's returned on the stack instead of the heap. If speed is an issue do some profileing and seem how much allocation you are actually doing.
Exact rooting either is about to be introduced or just was. I think exact rooting can be used to move to Generational.
No, of course it isn't. People are just intimidated by it.
Games are one area where 5ms is unacceptable, since you have a total of ~17ms per frame to work with, so taking an extra 5 will almost certainly push you into the next frame. I don't recall offhand how bad a single dropped frame looks, but it's supposed to be a Bad Thing.
Hasn't it been in go for awhile? https://github.com/heroku/hk
In my (admittedly limited) experience, motion control seems to depend more on deterministic scheduling than latency, as long as the latency is "sufficiently" low, as in, within the time constant of the device under control. So a motion control loop at 50ms and 0ms stdev is "better" than 25ms with 25ms stdev, where "better" means easier to write, smoother/more predictable in performance, or both. I deal with network IO processing, so it's all stochastic. I would rather lose 1ms on all operations (and know about it up front) than 5ms but only in the p95ile. Once you have more than one server in the mix, GCs can be coincident, so a 5ms p95ile in one server could translate to a 10ms+ p99ile across multiple servers. Basically, PLCs are "real time" but simple. Network processing is "QoS"-able but complex.
&gt; Anecdote: a group at Google rewrote a service from Java to Go. The group monitoring it expressed disappointment to us that the GC pause times were 2-3 times higher once they switched to Go. We pointed out that was not true: their Y axis was now labeled microseconds instead of milliseconds. So you're saying Go will break my monitoring. /thanksobama Alright, so that point of anecdata is more than I had before. It would be really sweet if there were some sort of published comparison specifically focused on GC or high-percentile performance... obviously it won't be apples to apples, but really any apples-to-apple shaped fruits would be helpful to develop buy-in. Do you happen to know if there are any upcoming papers or talks to keep an eye out for?
And a good one. I'm currently writing a CLI for gemnasium.com in GO, and this project has been very inspiring. Our project will soon be open-sourced btw. We would be glad to help, if you're looking for contractors.
Is there a reason you're returning a pointer to the status? Status is a small struct, so why not just return status{200, nil}
To be honest, this is where my knowledge falls through (not a programmer by trade): I'd taken this pattern from Andrew's code on the Go blog - http://blog.golang.org/error-handling-and-go I had assumed a pointer would be more efficient here given that there may be hundreds of instances of *appError at any one time. 
Indeed, pipelining is not yet supported. Nevertheless transactions can be done using the current connection type. But a first look showed that pipelines seem to be easy implementable. So I'll try to add it today or tomorrow.
I got about 5 seconds in and encountered lag. Maybe there's a mirror somewhere? Edit: No mirror, but found this from the same event: [Panel on systems programming (inc. Rob Pike) ] (http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond)
Code looks good glancing at it, but you should totally put a screenshot in the Readme! On my phone and can't just give it a whirl. 
Not to mention he'll probably have to implement it 3 or more times if he wants it to be platform independent.
Blog automatically posts to twitter. Just was a bit of laziness on my part :)
That's pretty awesome! Thanks for sharing :)
Done!
Nice - I see you've adapted your [flask app](https://github.com/vinceprignano/chatapp) into go. Good way to target learning specific parts of new languages without having to reinvent the wheel each time. =)
If you google "golang sql" it will take you to the database/sql package. It shows you how to install driver(s). There are links to a wiki article for basic usage as well. Also, in the sqlite driver on github, under the simple file in the examples folder, is a lot of good code for your queries etc.. 
Unfortunately this is an area where Go is pretty weak. There do not exist any mature ORMs / toolkits (as far as I've seen so far). However, if you're willing to tread on thin ice, you could check out [gorp](https://github.com/coopernurse/gorp), [hood](https://github.com/eaigner/hood), or [qbs](https://github.com/coocood/qbs). I'm partial to gorp, and you can see some of my (not particularly good) use of it here: https://github.com/jadekler/git-go-d3-concertsap. (check out things like app/band/bandModel.go and app/database/database.go) Again, there are many immature solutions right now - it may be best to simply use the golang sql package. Your call. =)
Might I suggest a few of the Go tutorials I did over at http://www.metacasts.tv/?keywords=golang There's one on Go and SQL in there as well.
I'm the author of the go-plus (https://atom.io/packages/go-plus) package for Atom (https://atom.io) that others have alluded to earlier. I agree that the default autocomplete plugin sucks - I want to integrate gocode with the plugin but will probably end up rewriting much of the core autocomplete plugin and then upstream it. In particular, it needs a provider / suggestion API (autocomplete-plus has one) and it needs to be asynchronous. Check back on that front in a month. As an active vim and sublime user, I think each has it's pros and cons, and Atom has a way to go before it's mature - but Atom has been quite easy to work with from the perspective of a plugin author. I'm actively adding features and you can see a list of thing we're focused on next here: https://github.com/joefitzgerald/go-plus/issues. If something you want isn't on the list, please add it!
Excellent! Thank you. Clean and simple, looks like a great candidate for embedding somewhere.
Or more succinctly: always test/guard your typecasts. Just like with Java or C++, a dynamic up-cast like that is never guaranteed.
See current discussions on the golang-dev mailing list. 
I used that gophercasts tutorial to get go working with postgres, and then afterwards you can strip out all the martini/web server stuff you may not want, it was helpful.
any reason Go doesn't have sum types, btw? Now it looks like even swift have those...
Why the down votes? The docs are great where I pointed OP too...
It looks like you could do this which is a *little* better imo cmd := exec.Command(...) cmd.Run() if w, ok := cmd.ProcessState.Sys().(syscall.WaitStatus); ok { w.ExitStatus() } Only one type assertion.
With a proper test too, that's quite attractive.
why aren't these 0-indexed?! 
100 - (% time wearing pants)
I understood the context FWIW. I'm rooting for Haskell and Rust. And Swift. But so far none give me all of what I want. I love all the progress and competition though.
Purely a guess but the format string itself is the 0th function arg
I've wondered that before, but how would it interact with interfaces?
It's not that fork doesn't work; you just can't keep running the same program with the shared instance of the Go runtime without causing problems. Cmd.Start immediately calls something in the exec family after forking, which creates an entirely separate runtime.
Ah! Good catch. That is, indeed, better. I'll update the post when I get back.
&gt; This is not a normal thing. yes, if this were normal it'd be pretty much unusable. It seems to come from an attempt to make portable things that really aren't, maybe drawing the portability line a bit too far down the stack. I don't feel I'm experienced enough yet with the language (and in language I'm glomming the standard library, as is usual for me) to say that with certainty, however.
Aren't command-line tools a bit 90s? Are you sure you want them in Go and not Logo? http://en.wikipedia.org/wiki/Logo_(programming_language)
I actually regret forgetting to mention QML and its bindings for desktop and phone that Canonical has been working on. I haven't used them but I hear good things. Even though Google uses Go purely as a server language, I see no reason that Go couldn't be a great language for the desktop.
[Interfaces can be somewhat effectively used to make sum types](http://www.jerf.org/iri/post/2917). It's not a perfect conversion, but "simple that gets ~90% of the way there" is pretty much Go's _modus operandi_.
But this app is pretty useless then there is no one to chat with. Is it meant for schizophrenic developers?
forking generally refers to duplicating the existing process and letting one or both of them continue. That's not what you're doing, you're executing a new program. (Which on *nixes is implemented by a fork() + exec() call, but that's an implementation detail in this case)
Would you say that "doesn't GC as much" is mostly by virtue of allowing more fine-grained control over data structures (like simple ways to pre-allocate slices)? Or is it because in Go you can use unsafe pointers to really drive your own memory management schemes?
Wow, great job, and very inspiring!
In parallel, Conformal has been developing good-quality [gtk3 bindings](https://github.com/conformal/gotk3/) which seems to be going nicely.
The new program should be indepedent of the original though, correct? I thought that the problem was that terminating the parent process also killed the child process. In this case, the Cmd.Start process seems able to keep running independently.
The project description needs some serious help. What can I do with it?