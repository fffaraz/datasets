I recommend you choosing a good name for it, L as a name for type constructor in a real project can be very confusing.
Type is a way of defining tagged unions: types that could have multiple variants, which we tag with a constructor. It just so happens that you've used it with one variant. The compiler needs to know, for example, when it sees a list of pairs, whether to treat it as a List or as a T. The constructor tells it to treat it as a T. For non receive types you can use type alias, but they just do substitution at compile time, do any recursion would cause infinite looping.
How and when is it useful to use the &lt;&lt; and &gt;&gt; operators?
Aha, brilliant - now it makes sense and will stick! I thought Union types were the exception but in actual fact it's the opposite. Brilliant.
&gt;React is well behind Elm in terms of performance: [http://elm-lang.org/blog/blazing-fast-html-round-two](http://elm-lang.org/blog/blazing-fast-html-round-two) Currently with the same library size footprint but with 0.19 it'll be much smaller.
What are you basing the policies and code of conduct on? Can the community contribute or vote on some way? Do we have access to these documents somewhere?
Sent you a PM as well.
Elm allows you to chain actions by default, so you should be good. I think the difference you will find is that you chain at the `update` function, which is like the reducer to redux. It works great for Elm.
Is it because `Time.every 1000` executes every second starting from the time it was first scheduled? Or does it execute when current timestamp gives no reminder even divided by 1000? If it's the first case, you could try to remove the subscription for a single event loop run and then assign it again. If it's the second case I can see no solution other than custom JS scheduler (setTimeout or setInterval).
Richard's code was primarily an example of how to organize the structure of an SPA; I wouldn't read too much into the organization of requests &amp; data since that wasn't his main focus. Views.* is not a root organization level. The Views dir contains view elements that are shared across pages. A View element may happen to display a data type (ie Data.User), but that's not its reason for living in the Views directory. Generally speaking, the Data, Requests &amp; Decoders involved in communicating with a backend service won't live in the SPA at all. They will be wrapped up into a separate module (e.g. "Client" module), stored elsewhere (e.g. in the backend service repository) , and imported into the SPA project.
I believe it's the first case. How would I remove and immediately reassign the subscription? Would I have to use a Cmd?
&gt; I find it helpful to remember that Elm doesn't really have encapsulated state. Worth noting that you can totally encapsulate state in Elm, you just do it with modules and union types. For example, if I write `type State = EncapsulatedState { ... }` and then at the top of the module I have `exposing (State)` rather than `exposing (State(EncapsulatedState))` or `exposing (State(..))` then I have encapsulated that state within the current module. Other modules can pass these `State` values around, but they cannot read, create, or modify them directly. I talked about this technique more here: https://youtu.be/IcgmSRJHu_8 - hope it's helpful!
&gt; Worth noting that you can totally encapsulate state in Elm, you just do it with modules and union types. You're right, thanks for the reminder :)
Views are simply a function that take some data as input and return Html. The logic you're asking for requires at least two values that need to be tracked: the original text value and the current value displayed in the text field. On first pass you might have something like this.. type alias Model = { ... , originalValue : String , displayValue : String , isValid : Bool } But a better approach might be to use a union type since the above three values are so tightly coupled. type alias Model = { ... , entry : UserEntry } type UserEntry = Valid String | Invalid String String And your view might do something like view : Model -&gt; Html Msg view model = let (inputValue, originalValue) = case model.entry of Valid value -&gt; (value, value) Invalid displayValue originalValue (displayValue, originalValue) in input [ value inputValue, ...] [onSubmit &lt;| MyMsg inputValue originalValue] And when the user hits enter the update function would `case..of` the `model.entry` again. If it's valid then `Valid inputValue` would be returned. Otherwise, you would return `Valid` with the original model value. There are perhaps cleaner ways that aren't occurring to me at the moment. Someone will chime in if there is.
Look at: - http://elm-lang.org/examples/time - simple example I've created https://ellie-app.com/39kwkcNPF49a1/0 - http://stackoverflow.com/questions/40599512/how-to-achieve-behavior-of-settimeout-in-elm Maybe this will help https://github.com/panosoft/elm-cmd-retry Also ask on https://elmlang.slack.com #beginners
Their coupling is made explicit in the update function in your example. When one value changes then one of the other values might change too. Re: impossible states - It depends. For example when the user hits enter the update function could return this. { inputContent = "definitely not a number" , lastValue = Just 100 , error = Just "Input must be a number" } Per the OP's requirements when the user hits enter that above resulting record should be impossible but the data is modeled in a way to allow for it.
Thanks, I'll try this out. I think "Valid" and "Invalid" correspond more to "Unchanged" and "Changed" states than valid/invalid, and I should attach an onChange event handler as well that makes entry into a Changed value with the most recent text and the stored Int, if I'm understanding this correctly.
This is great, I had planned on doing something similar. I'm interested in seeing some of the optimizations prepack is capable of.
worked perfectly. Thank you
I wrote [this library](http://package.elm-lang.org/packages/ericgj/elm-validation/1.0.0/Validation) for form validation, it might be useful to you. There are some examples in the docs. It's based on a type that looks like this: ``` type ValidationResult a = Initial | Valid a | Invalid String String ``` - Initial - No input yet. - Valid - Input is valid, and here is the valid (parsed) data. - Invalid - Input is invalid, and here is the error message and your last input. 
Good work! Keep at it.
Check out [`Process#sleep`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Process#sleep). You could execute the request and if it fails, sleep for 1 second and then execute the request again. Keep doing that until the request succeeds.
Did you find the time to see how they compare on size or performance?
Below is a comparison of uncompressed, non-minified code. Some of the size difference on elm's long variable &amp; function names, compared to prepack's extremely short names, but the lines-of-code reduction is significant. HelloWorld example * Before = 182 KB (7832 lines) * After = 96 KB (4788 lines) RandomGifHttp example * Before = 223 KB (9183 lines) * After = 137 KB (6817 lines) It would be good to run these through uglifyjs &amp; gzip to see final "production" numbers, though.
That's better than Time.every
Thanks for taking the time! &gt; Modules depending on each other shouldn't trigger any warnings. It's totally normal! :) &gt; [...] &gt; We could be here all day debating whether things count as "cohesive" or not, but as programmers we have more useful ways to spend our time. :) The more I think about it, the more I realise having the type safety guarantees of Elm, together with the helpfulness of the compiler, is a change of mindset even broader than I first realised. I come from languages where cohesiveness is a very important metric, in order to ensure a good life expectancy of the codebase, specially when the software is being developed by a team of people. In languages like Elm, I'm starting to realise this is not so determinant. Do you have any word of advice on what metrics is our time better spent? 
I would also wonder how much this actually increases in terms of performance. I could imagine the JIT is able to do many similar kind of optimizations?
You can use `Json.Decode.value` with `Json.Decode.andThen` and save the raw value in the `raw` field. Here is an [Ellie demo](https://ellie-app.com/39L455H5sqGa1/0). It might be better to keep the raw value as a `Value`([like this](https://ellie-app.com/39L455H5sqGa1/1)). 
There is a [`value`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#value) decoder which you can work with later using [`decodeValue`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#decodeValue). ([example](https://ellie-app.com/39LjQRTtGyfa1/0)) ------ If you really need a `String`, you can use something like `Json.Decode.map (Json.Encode.encode 0) Json.Decode.value` (a decoder that will take the whole value and encode it to `String`) but it might be inefficient with larger data structures. ([example](https://ellie-app.com/39LhPk3j52Da1/0)) ----- You could also add an argument to `decodePerson` in which you would pass the source string and populate the field using [`Json.Decode.succeed`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#succeed). ([example](https://ellie-app.com/39LfkXyxhKsa1/0)) Edit: Added examples based on /u/jediknight’s one.
Great info, thanks for clarifying what prepack is trying to do. Do you think that [Evan's benchmark repo](https://github.com/evancz/react-angular-ember-elm-performance-comparison) is "up to date" enough with the other frameworks for a fair comparison? I would imagine that React &amp; Angular 2+ &amp; Ember have made some improvements since August. Not that I want to spend the next 4 days updating them &amp; fixing issues...
Ah good points, thanks for the clarification. Yes that seems most likely how things will go.
Use a case statement: navLinkActive : String -&gt; Route -&gt; Bool navLinkActive navLinkName currentRoute = case ( navLinkName, currentRoute ) of ( "Login", Login ) -&gt; True ( "Register", Register ) -&gt; True ( "Users", Users ) -&gt; True ( "Users", User _ ) -&gt; True _ -&gt; False
Create a function **isUserRoute** that accepts a Route and returns a boolean. In the function, pattern match for User the return True. For all other patterns, return False. isUserRoute : Route -&gt; Bool isUserRoute route = case route of User _ -&gt; True _ -&gt; False
I would expect that since it's a function, you would write it once and wherever you have 'route == User', replace it with 'isUserRoute route'. 
Glad you like it. Check out [dreambuggy](http://github.com/kfish/dreambuggy) :)
Another update: I've added a nicer testing app: * [kfish/elm-gamepad-tester](http://github.com/kfish/elm-gamepad-tester) * [Live demo](https://kfish.github.io/elm-gamepad-tester/)
The best way depends on the requirements and already available code. A lot of people had very good experiences with introducing Elm slowly into their apps by giving it something to do. You can also implement the entire front end in Elm and use Django as a REST provider. [Take a look at RealWorld/Conduit](https://github.com/rtfeldman/elm-spa-example) to see a full implementation of a real world example. 
The trailing comma seems to be accepted in JS, so why not the leading one? I guess "weird" is a personal subjective matter. But I doubt any programmer would have any problem with it, once explained. I also would not call it inconsistency, it is very consistent and unambiguous. Which is again subjective, I suppose. I don't mean to argue, just state my own, also subjective opinion. However, that fact that it can be made consistent if desired, is objective. I would still like to hear objective arguments, it there are any, not dependent on personal preferences that may vary. 
&gt; In order to evaluate the elegance of the syntax you first need to use it for a considerable amount of time in order to get familiar with it. Indeed, hence the disclaimer. :) However, there is always something like language-agnostic elegance. The reason I find the other syntax is more elegant, is the emphasis of the equal role of lines that do have the equal role. I don't think that feature is language-specific. Or would be curious to learn if I am wrong. Again, sorry for my ignorance if any, but I was hoping the Elm community would have some more open-minded attitude and at the very least give some objective explanation.
You specified all the needed information so the compiler is happy. Take this definition `type alias ParticleList particle = List { particle | id : Int }`, `ParticleList ParticleExample` is not the same type as `List ParticleExample`. if you have `type alias Identifiable r = { r | id : Int }`, `ParticleList ParticleExample` is the same as `List (Identifiable ParticleExample)` With the definitions above you can have function that would work on any `Identifiable r` including `Identifiable ParticleExample`. Maybe the [Records docs](http://elm-lang.org/docs/records#record-types) can shed more light on this. 
&gt;Well... what languages allows that kind of syntax? In what language [,1,2] means an array of two elements? Perhaps JS in the future? It took few years to agree for trailing comma, then why not after some more years for the leading? In other words, in Elm it is not allowed? And not possible to configure? I was hoping in a language that has more control over its syntax this were possible. You don't have to use if you don't want, but other people may like it. &gt; we are a friendly and open-minded community but it is not clear to me what are you trying to learn here. Are you interested in the process of design that produced the current approach? Are you interested into the advantages of the current approach? I like to learn more elegant ways of writing and structuring code. Elm has much influence outside of it. A lot of it is intra-language. It seems that Elm has its particular way to write code, dictated by some internal elegance, but this one aspect I found puzzling. 
That is how I write JS, but I've thought Elm likes to prefer comma first. Which makes the leading comma just as natural as the trailing one in JS. It is sad if people at Elm want to limit even that much of freedom, it is really no big deal in JS and would give some sweetness to some people.
I meant more like if I have another route /books/&lt;id&gt; for example, then I'd have to make another function `isUserRoute : Route -&gt; Bool` And the same for any other nav option that will be added. But then again, I won't have *that* many nav items.. And after looking at it again the other solution has it's flaws as well. It would require me to have matching (duplicate) strings in 2 different parts of my application. (One string in the case pattern in that "navLinkActive" function and the same string again when creating the nav item) So your solution will be less error prone. Think I might use this instead after all :)
Here's an example: https://ellie-app.com/3bt2MBsSgBPa1/0 1. OnClick, start the fade out animation 2. When the animation completes, use `Animation.Messenger.send` to remove the item. 
&gt; See the diff section. http://dontkry.com/posts/code/trailing-commas.html I don't see any reference to commits. And the argument they make for the trailing commas applies precisely the same way for the leading commas in Elm. Right now the lines are inconsistent. &gt; If you don't use the leading comma for single line, you are creating more rules and special exceptions. There was a sentence about it in my previous message... &gt; There was a reasonable technical reason behind the way things are right now. This is what people say when they run out of objective arguments :) &gt; Or for trailing commas in js. Limiting diffs in version control. I don't see any relation with version control. &gt; Your proposal is about style, and it is a less simple, less succinct, less consistent, and unconventional style. Personal opinion. Not objective. &gt; It is precisely why style needs to be part of a language spec. But it is not. Not in Elm right now. See my previous message. &gt; To be clear, I'm not trying to be mean or argumentative. I mearly trying to demonstrate what happens when code style and freedom do wild. And I miss to see any problem. 
Allowing extra commas can easily lead to mistakes when refactoring. When you extract one of the elements into a variable you could forget to put the new variable back into the array. Not worth it at all.
Not sure I understand what you mean. Can you give an example?
Hi! I've just published a toast notifications package for Elm apps that deals with transitioning elements in and out: http://package.elm-lang.org/packages/pablen/toasty/latest Here's a demo: http://pablen-toasty-demo.surge.sh/ If you browse the source code you will see that I use Process.sleep in the update function to delay messages which in turn let you update your model &amp; view, so by adding classes or inline styles you can play with basic transitions or CSS animations in a similar fashion to React's CSSTransitionGroup. Hope this helps you!
Are expressions evaluated in the init (before |) part of a record update? Every time I have tried to do a simple nested record update I have needed an extra let..in statement to get the functionality of: { model | child = { model.child | ... The above code won't work. Wondering if I'm doing something wrong or if it just can't be done
&gt; I think the point that most people here are trying to make is that most languages are designed to make code readable to many, not allow everyone to adopt their own syntax conventions. The freedom to choose between writing lists as single line and multi-lines is still there. And people tend to write long lines with many arguments, making it hard to read. Standardising this would remove some of the problems people raised here. &gt; The greater programming community is pretty much in agreement that the kind of "freedom" you discuss can actually be a detriment to teamwork. How many people's opinion would count as "greater community"? ;) &gt; I totally get the point you are making about each array element being of equal relevance, but the comma is seen as an "element separator", whereas u are suggesting it to be used as more of a "line marker". It would still be a separator, no meaning changed, not that I see. &gt; As for the js trailing comma, that was a feature added for a very specific reason, after many developers and teams asked for it(as others have said) it was not meant for the purpose of allowing syntactic freedom. Do you have any reference to support this claim? 
In my personal experience it is easier and more efficient for the engine to do as much animation with css and only make the classes dynamic. Its not pure, but its hella pragmatic because you get gpu accel from modern css, less state updates (easier to debug) and less overhead from having to manipulate the DOM at each animation step. Interested to hear other people's takes on this as well!
Thanks for your answer!
Thank you. This actually looks a lot more manageable than I feared.
That only works for enter animations. If you want to do leave animations with CSS you have to setup event listeners for the animaiton complete event and wait for that listener to trigger before actually removing the element.
You'll want to use type parameters for this. type Tree a = Empty | Node a Tree Tree In fact, you'll probably want to use `comparable` instead of `a` for a binary search tree. But why do you have to construct your own tree anyway?
&gt;Well... what languages allows that kind of syntax? In what language `[,1,2]` means an array of two elements? Clojure, but only because it considers commas to be whitespace. The idiomatic way to write it is still `[1 2]`. I think that separating elements only by whitespace is quite elegant.
&gt;and because browsers can only handle so many AJAX requests at once, Can you upgrade to HTTP2? That solves that particular issue. Or you can have a new endpoint that takes all of that at once. Or do your scheduling in JavaScript.
In the update function, what's the most concise/idiomatic way to check if a string parses to an int between x and y and return { model | param = newInt } if it does, where newInt is the int obtained from parsing the string, otherwise return { model }? Are case expressions or if expressions preferred? Which parts should be split out into separate function(s)? I can see several ways to do it, but I'm not sure what's considered best practice.
What have you tried so far? I think this example is reasonably small enough that you could try it one way and try it another way in about 15 minutes, and once we have those example we can talk about trade-offs if the answer to your question isn't evident after trying it out.
This should accomplish the same thing: let newParam = Result.withDefault model.param (String.toInt newParamString) updatedParam = if c_PARAM_MIN &lt;= newParam &amp;&amp; newParam &lt;= c_PARAM_MAX then newParam else model.param in {model | param = updatedParam} ! [] It might make sense to pull everything in the let statement into its own function.
That doesn't look right to me - where is newParam given a value?
I'm adding login with Spotify to my Spotify Mapper app. After this, I will add the feature to save the playlist to your Spotify account. It's almost ready! https://github.com/FidelisClayton/elm-spotify-mapper
I just published new versions of my [2D/3D geometry](http://package.elm-lang.org/packages/opensolid/geometry/latest) and corresponding [SVG](http://package.elm-lang.org/packages/opensolid/svg/latest) packages over the weekend, so now I'll probably get back to a [WebGL-based scene graph package](https://github.com/opensolid/scenegraph) I'm working on. I also want to start looking at support for generating and parsing [IFC](https://en.wikipedia.org/wiki/Industry_Foundation_Classes) and [STEP](https://en.wikipedia.org/wiki/ISO_10303-21) files in Elm...
Improving Toasty, my toast notification package for Elm apps: https://github.com/pablen/toasty Here's a demo: http://pablen-toasty-demo.surge.sh/ First package on Elm's community, so feedback is much appreciated! :)
What you have there is actually just fine. Yes it is a little verbose but it's succinct enough that it is readable. If you wanted less boilerplate you could leverage some helper functions in the [Result](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result) module. For example, you want to default to some value on error so that tells me we could use `withDefault : a -&gt; Result x a -&gt; a`. Since you want a conditional you're also looking to `map` a value. String.toInt newParamString |&gt; Result.map (\newParam -&gt; if c_PARAM_MIN &lt;= newParam &amp;&amp; newParam &lt;= c_PARAM_MAX then {model | param = newParam} ! [] else model ! [] ) |&gt; Result.withDefault (model ! []) Another way to write it is like this: paramMapper : Model -&gt; Int -&gt; Model paramMapper model newParam = if c_PARAM_MIN &lt;= newParam &amp;&amp; newParam &lt;= c_PARAM_MAX then {model | param = newParam} else model toTuple : Cmd -&gt; Model -&gt; (Model, Cmd) toTuple cmd model = model ! cmd update msg model = ... String.toInt newParamString |&gt; Result.map (paramMapper model) |&gt; Result.withDefault model |&gt; toTuple [] Overall this is more code than what you have but `paramMapper` is now broken out and more testable and `toTuple` (or equivalent from various helper packages) pulls out duplicated code and can be reused elsewhere.
I'd try batching the command(s) with the "top priority" HTTP work alongside a `Process.sleep 0` command which results in a `SendLowerPriorityHttpRequests` message (I'm sure there's a better name) which fires the lower-priority ones in a second batch, one tick later. That ought to do the trick!
I understand what you're saying, but it doesn't really answer my question. But I guess that if you specify `List { particle | id : Int }` in the type defintion, particle won't have to stay the same type (in the case that it doesn't have an id field)
For this exercise is fine, but what if you have 6 or 7 inputs in a form? IMO this is not scalable.
I see, that makes sense. Thanks!
The follow up explains this more clearly: " In my thinking it comes down to the more freedom we have with creating type level functions the farther away the typechecker sees the error and the less the error message helps. That's why I add top level type sigs. to client code especially when it's using a lot of overloaded type class methods." https://mastodon.social/@deech/6118407
Thank you! It seems working! I changed this this line : Ready -&gt; -- ( {model | state = not model.state}, Http.send GetList &lt;| Http.post "/api" (Http.jsonBody (Encode.string "Hey You") ) (Decode.list Decode.string) ) to Ready -&gt; -- ( {model | state = not model.state}, Http.send GetList &lt;| Http.post "http://localhost:8080/api" (Http.jsonBody (Encode.string "Hey You") ) (Decode.list Decode.string) ) then flask now getting "OPTIONS /api HTTP/1.1" 200 instead of "POST /api HTTP/1.1" 200 - do you know why this happened? I'm noob here. sorry if my question is so obvious lol. 
I have not looked into your code, but the OPTIONS request is a preflight request. This is used if your request comes from a different origin than the server. It checks the servers headers for things like accepted request methods, content-types and so on. Google for preflight request and same origin policy to get a better understanding :) (i am on my phone and switching between my browser and my reddit client to google is a bit of a pain, hence no direct link from me ;))
/u/On3iRo explained the probable cause of the issue well - here's a library that might help you fix it: http://flask-cors.readthedocs.io/en/latest/api.html
This is only one of possible approaches so I separated it from original post. ------ Let's say there exists `fromList : List a -&gt; Foo a` and `toList : Foo a -&gt; List a` (aka isomorphism between Foo and List), then it is pretty straightforward to write `map, fold, any, all, sort, ...` for Foo : map fun = toList &gt;&gt; List.map fun &gt;&gt; fromList any fun = toList &gt;&gt; List.any fun The idea is to replace `List a` with `universal_structure` (probably some form of heterogeneous list), make sure the transformation will be done at compile time and give it a fancy name like **deriving**... 
I know this is super late but I was trying out techniques for splitting up msgs with lots of constructors and I didn't feel like splitting my update function so I did something like: ``` case msg of UserMsg (SetUsername username) -&gt; -- Same as when it was just SetUsername UserMsg (SetPassword password) -&gt; -- Same as when it was just SetPassword ``` worked pretty good!
I've made input fields with custom attributes attached named "index" with values that are stringified ints. I want to write an event listener similar to onInput that sends the input text and the "index" attribute value, but I don't understand from the docs where I would find the index value in the event object, or if it would even be present for me to decode. Is there a way to just dump the contents of the event object somewhere where I could read it?
Sorry to hear it's still not working. I suspect the previous change got it working in Ellie 'by chance'. I've had another go, at https://ellie-app.com/3d8nr3FkN7ha1/0. I would have more hope that this would work in your project, but of course I don't have the rest of your code so I can't be absolutely sure. The changes I made this time were to declare decodeConditionStatement and decodeConditionStatementOr as functions that discard their first argument, as I did with decodeAction2, and call them using Decode.lazy. I chose to make these two into functions because these two, along with decodeBlocklyActions and decodeAction2, are where the mutual recursion is. 
Love the idea
Question regarding Time subs...how does one "restart" the sub? I have an app where I want to save changes to an external service after the user does anything, but obviously want a bit of a wait so the server doesn't get spammed. I implemented this now by having a time sub that depends on a "needSave" Bool in the model, which seems to work. The issue is the check for "should I save?" is basically comparing the timestamp of the last change, vs the current time when the sub goes off (every 5 seconds). It works, but what I can't figure out is how to do the JS equivalent of cancelling and restarting the timer when a change is made, since I KNOW the check will fail at that point. So if a new change happens before the next Time.every Msg, I want to basically restart that sub. Does this make sense or am I thinking about it the wrong way? I know I can just do something like check every second and will get really close to 5s after the last change, but that seems inaccurate.
Wow, awesome. This is going to keep me busy for a good while. Thanks!
Oh... I am using Flow also (hope it gets better as I use it...) And will probably incorporate ImmutableJS (altho not looking forward to that : /)
Depending on who you talk to, a big advantage of React is that you can create components with local state (you don't have to put all of your state in the global state object). If you have some small piece of isolated state, like a boolean indicating whether or not a drop down is open, you can keep it inside the component. This allows you to create reusable components that can literally be dropped into a project without any setup. Elm, in contrast, requires a decent amount of boilerplate for each component, since all state must be stored in the global Model. If you have a 100 autocomplete components in your Elm app, you'll need 100 records inside your Model to track each one. I agree that Redux is underwhelming, though. Writing action creators is tedious.
Funnily enough, many people rail against local state. I've tried numerous times to explain to people why it's actually often a good thing, but the only response I've gotten was "hurr durr Redux". People really don't like thinking
If you are going to use ImmutableJS + redux + react, just use Elm. It's the end-game you are driving towards anyways.
&gt; If you have a 100 autocomplete components in your Elm app, you'll need 100 records inside your Model to track each one. Of course you wouldn't use 100 records, that's just silly. When you have multiple 'components' of the same type, you would use an Array or a Dictionary to store them. Also, the amount of boilerplate does not increase with the number of these 'components'. Also, using local state might seems like a good idea, however, it has huge drawbacks. You suddenly are no longer able to: * trivially implement a history of changes * trivially store and restore the whole application state * use a time traveling debugger * easily keep two 'components' in sync
&gt; Of course you wouldn't use 100 records, that's just silly. When you have multiple 'components' of the same type, you would use an Array or a Dictionary to store them. Sure, but that's not the point. You can't drop a component into your project **without any setup**. You must write boilerplate. You can come up with ways to abstract away some of the boilerplate, but at the end of the day you have to track each component's state inside the global state object. &gt; Also, using local state might seems like a good idea, however, it has huge drawbacks. You suddenly are no longer able to: trivially implement a history of changes, trivially store and restore the whole application state, use a time traveling debugger, easily keep two 'components' in sync All good points, but just to give you a different perspective, there are times when I frankly don't care about tracking every state change. If you've ever used [elm-style-animation](https://github.com/mdgriffith/elm-style-animation) in conjunction with Elm's debugger, you'll know that your app has to go through hundreds or thousands of state changes in order to animate style transitions. To me, these state changes are pure noise. They clog up my debugger's log and aren't useful to me (personally). That's why the creator of Redux has said it's ok to use local state; in any given app, there's going to be state that you don't care about that much. Although I appreciate the purity of Elm, there are pros and cons of both approaches.
I'm a BIG fan of web components for this exact reason.
Well apparently elm-mdl does exactly what I described, e.g. [use a Dict per 'component'](https://github.com/debois/elm-mdl/blob/8.1.0/src/Material.elm#L201). That is indeed the approach I'd take if I actually needed a large number of the same 'components', but most of the time I don't actually need this. Transient state is only transient as long as no other part of your application needs to know about it. If you want to react on whether the dropdown is open or not you need to know it's state. If a user managed to trigger a bug that only happens while the dropdown is open, the debugger wouldn't be able to record that. I just don't see any advantage of storing anything locally. And I have used both react and elm for bigger projects. The code always turned out nicer with elm, and I think this is a direct consequence of having no local state.
&gt; (..) You must write boilerplate (..) Yes, that's true, but I don't see it as a problem. In fact, I see it as an advantage. It gives you much more control over that 'component's state. E.g. I can easily reset a 'component' to it's initial state without the author having written this functionality. I'll gladly trade convenience over the power it gives me. &gt; these state changes are pure noise. They clog up my debugger's log Yes this is a (known) problem with elms debugger. However, this is a UI problem, not a problem with the architecture or with tracking these changes globally. This could be solved e.g. by grouping repeated messages or having a filter.
A shed called - it wants its bike back
[Here's an awesome talk](https://www.youtube.com/watch?v=ar3TakwE8o0), by /u/rtfeldman
It's easier to do automated tests using actions and 'global' state compared to using local state. It's also easier to log and simulate user sessions. Therefore it's also easier to reproduce errors. Having an application with many different actions can be tedious, but often it can be done with some generic actions that are reused. For instance redux-forms automatically works without creating many custom actions. The same can be solved in a generic way to load data. That way the application is still easier to test and reproduce state, but you don't have a ton of actions to maintain.
I get your point, but the example you picked isn't very good. The browser does not store some state per text element, it stores a global selection state. If this functionality had to be implemented in elm, it could be hidden within `Html.program`. Then there could be a more advanced version where you could control the current selection yourself. I'm sure there are better examples of elements with local state that the browser manages where I'd agree that this would be annoying to manage myself, but all I can think of right now are elements I wish wouldn't be statefull. E.g. the video or audio element. I'd rather own that state within my application.
You could use sites like https://runelm.io , so everyone could instantly run and modify your code and suggest a fixed version by providing a link to cloned/fixed version.
React + Redux has a number of niceties from both a business and developer experience standpoint. Sure, it has plenty of kludgy bits compared to elm, but it also has: * A huge ecosystem, a fair bit of which is made up of well-made, well-documented libraries and components that save you lots of dev &amp; maintenance time. * Integrations and support for end-to-end and integration tests that (AFAIK) elm is still very early int. * Hooks for element mount/unmount in the dom with guaranteed lifecycle timing. This can be critical when you *have* to mess with DOM APIs. * The ability to share code with react native apps or serverside node applications. * Advanced performance optimizations like serverside rendering, lazy loading parts of the application, etc. * An incredibly huge number of people hammering out crazy browser-specific edge cases so you don't have to worry about them. I can say from heavy experience with that stack and moderate experience with Elm that react + redux has plenty of good points too. I enjoy my elm work more most of the time and I think Elm has a ton of advantages over the react+redux combo, but they both certainly have their merits.
Interesting... I never thought of it as a UI problem, but that makes a lot of sense. Being able to filter out certain `Msg`s would address a major pain point for me, which is having to step through thousands of irrelevant state changes when debugging an issue.
Awesome idea, thanks. Here is an Ellie with the code that's having issues. https://ellie-app.com/3dXNrfBMyhta1/0
I'm specifically interested in a dead code finder/remover. If anyone knows of a good tool, I'd like to hear about it. EDIT: I just want to specify I'm talking specifically about elm static analysis: I meant that the dead code finder in elm-analyse doesn't quite do two things I want: find unused functions if the module exports all, and then remove those functions via a simple command. Since this wasn't a super easy package to come across, I was just wondering what other tools might exist in the elm ecosystem that I'm not aware of.
I like this text about implicit vs explicit https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html
[clippy](https://github.com/Manishearth/rust-clippy) is an impressive static analysis tool for rust. It doesn't do dead code analysis—the compiler does that.
I've looked into some static analysis tools in general, and their power seems to depend very much on the language. For dynamic languages there isn't much to analyze. Also the tools are very language-specific, I think it's quite hard to reuse code in this kind of stuff. The tools also grow in complexity very fast when you go deeper than just linting, which is basically row-level analysis. Therefore you also need to have quite concrete needs for the tool to be viable, like memory management issues in C++. I mainly looked into the tools with bug-hunting in mind, so I don't know much about metrics-oriented stuff for example. Anyways, it kinda makes sense that most bugs that can be seen compile-time are actually picked up by compilers, and therefore there's not a big demand for these tools. You also can't just flag up stuff that's a bug like 10% of the time, people will just ignore it. In [this](https://cacm.acm.org/magazines/2010/2/69354-a-few-billion-lines-of-code-later/fulltext) article there is some interesting stuff about how too smart findings will just be regarded as false warnings by the users. 
This works well on Ruby and Elixir: https://unused.codes/
You may have seen it already, but Evan's note in the [Focus library documentation](http://package.elm-lang.org/packages/evancz/focus/latest/) really summarizes why lenses are discouraged. It has also been discussed many times on the [elm-discuss list](https://groups.google.com/forum/#!searchin/elm-discuss/lenses%7Csort:relevance). &gt;It is possible that the concept of a Focus is harmful to code quality in that it can help you to be lax with abstraction boundaries. By making it easy to look deep inside of data structures, it encourages you to stop thinking about how to make these substructures modular, perhaps leading to an architecture that is not as nice and has extra conceptual complexity. &gt; The deeper problem may be that lenses are best when they are bidirectional, whereas a Focus is only in one direction. The issue is then that making proper lenses is not necessarily possible without changing the language itself. &gt; Point is, I have yet to see any code that follows The Elm Architecture that gets better by adding this library. 
Awesome, thanks for the link. This is great advice, especially for me, as someone new to functional languages in general. I definitely feel like I try to prematurely split stuff out, as it's more familiar to me. But I think that it adds more complexity than necessary, especially if done too early. 
&gt; It doesn't do dead code analysis—the compiler does that. So will the next release of Elm.
&gt; Is it possible to nest multiple Elm applications inside each other? This is a [XYproblem](http://xyproblem.info/). Yes, there are ways to nest Elm programs inside Elm programs but for what you want to accomplish you don't need that. &gt; What's the best way to split this out? Any large enough Elm app will have multiple pages. You will first need to split the pages in such a way as to be able to reason about them independently. Then you will also have the code split around concerns (Routing, Requests to the backend, Data types and their serialization, complex shared views). There are two ways to approach developing an Elm program: 1. you start in one file and your grow as you need 2. you start with a coherent structure and just populate the structure as appropriate. If it is a small, single page project (e.g. some kind of landing page), the first approach might be more appropriate. If it is a larger, multi-page project, you will move faster by using a well thought structure like the one from [Richard's Conduit implementation](https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa). 
http://credo-ci.org
There are other things in Haskell's `lens` library. Prisms, traversals, and the nice notation for state monad operation are incredibly useful to me. All the `Plated` stuff, while not being as common, can be invaluable in reducing boilerplate (and shooting yourself in the foot). They could probably not be encoded in Elm though.
The [JetBrains](www.jetbrains.com) tools do this. Using them for C#, Java, Python here. They underline problems/suggestions right in the editor and a simple [alt-enter] will fix it in-place (or globally). They detect 100s of code smells. Edit: I am very happy that this sort of tooling comes to Elm. I hope it will get integrated into the editors/IDEs. The lack of it is what keeps me using the *traditional* languages, although I would very much prefer functional languages like Elm...
Evans mentionned it.
I thought it's what you meant.
The difference is subtle. Dead code analysis will cause the compiler to warn, "Hey, you defined this function but you never use it." Tree-shaking is an optimization where code that is never used in your module or any of the modules you depend on don't end up in the compiled output, which can reduce the size of the output by quite a bit. AFAIK, Evan's only exploring tree-shaking for the next release.
&gt; Haskell is, above all, a playground for academics to try things out. This has meant that many features have been included in the language because they were interesting, not because they made for great production code or they had a good learning story. Elm has become, in part, a test bed for discovering which of these features are core to writing better production code and how to make those accessible to people from the imperative world. This is not a very accurate or charitable distinction. I could describe Haskell in exactly the same way that you described Elm - an experimental testbed of multiple, complex interacting features (called "extensions" in Haskell land). Indeed, some extensions are now deprecated as the community has had time to discover the anti-patterns associated with them. Also, your reasoning behind why Elm "doesn't have lenses" is over-simplified. In Haskell, one particularly efficient encoding of a lens involves a fascinating interaction between higher-kinded types, type classes, and rank-2 polymorphism. This same interaction also gives rise to many different "optics" with their own unique features (including the number of "targets" of an optic, whether or not it's read-only, if it has an index, if it's partial, if it can be reversed and used as a constructor, and on and on...). Your point overall may be perfectly valid - that lenses are not "worth their weight" in Elm - but to make this argument, you'd have to argue against each of the type system features individually (again: higher-kinded types, type classes, and rank-2 polymorphism), each on their own merit. It's also not at all the case that these type system features only exist to encode lenses, and are otherwise not useful. And finally, using the Law of Demeter as an argument against implementing lenses into a language is a ridiculous straw-man (I'm referring to Evan here, not you). But even _if_ lenses were merely a tool for performing deep record updates with convenient syntax, it's like saying you should omit booleans from a language because of boolean-blindness.
Wouldn't `toIterable` and `fromIterable` be an even better solution, working for both present &amp; future values? (Mind that I'm a noob and have no idea what's Elm's attitude towards things like generators &amp; observables.) 
Learning Elm by coding up a cardiovascular simulation. Lots of state, in the current implementation! Should be fun, but I suspect I'll be around the "easy question" thread.
The list I am talking about exists only at compile time so there is no reason to introduce iterable. 
My Elm implementation of my son's Spokes board game is now playable, on a single computer. Next: history and undo. Then: server for multi-player over the net. https://gibgoygames.com/spokes
Here's the Gist https://gist.github.com/MichaelCombs28/d650598bc233fe96ce8ef6eb31d735f7 Now I want you guys to note that the child update function sort of acts like the set function of a lens. If you need to retrieve something that could potentially be used by other components, this is a better pattern imo EDIT: Here's the github for when I do add Haskell Snap to just show this thing in action: https://github.com/MichaelCombs28/Elm-Auth
Even the creator of redux advice people to find a healthy mix between global and local state. The choice is between encapsulation+ease-of-use (mixed) versus easy-to-reason-about+boilerplate (fully global). I like local state personally, but that's because I like to define a UI kit made of very rich components at the beginning of projects, and then just reuse them with minimal boilerplate.
I'm building a file uploader to our rails API and sending it to s3. Lots of ports, JS and ruby included. The amount of Elm in this is pretty minimal actually. Just get the user to select a file in the Elm app, port that to JS land, pull it apart and send the content back to Elm for display. Do that for multiple files then on the submit button event port back in to JS, loop over the file list saved in JS land, use a &lt;canvas&gt; element to convert images to base64, build a FormData object and process/upload to s3 on the backend.
&gt; This method is not all that hacky. The only non-standard feature required was the Native API and it is widely used by the community, so it’s unlikely that it will stop being supported. The Native mechanism is in flux and one of the reasons it is not documented is because it changes, sometimes quite dramatically, between versions. 
Well done Marcelo, I was about writing the SAME post on my blog :-) working exactly on the same hack but with a naive implementation https://github.com/pietro909/share-elm-code-with-js Yours looks better :-) thanks for sharing!
I agree but this is anyway a useful documentation of the innards of Elm (or for that matter; how the inside is put together). Looking forward for 0.19 and all the things that it might break :)
I would sugest you to put a `cursor: pointer` at the circles, as they are clickable objects.
&gt; This method is not all that hacky. The only non-standard feature required was the Native API and it is widely used by the community, so it’s unlikely that it will stop being supported. None of this is true! **This is very hacky and you definitely should not rely on this.** It has never been "supported", and there is no "API" here to be stable or not. The particular details change as the compiler becomes more sophisticated, these details have changed dramatically a couple times, they will continue to change, and there is no plan where this is an "API" that is "supported" in any meaningful sense. I have tried tons of times to tell people this. References include: - [this podcast about ports](https://elmtown.github.io/2017/05/09/history-in-elm-town-ports-episode-13.html) - [this mailing list post about "native" vs "kernel"](https://groups.google.com/d/msg/elm-dev/bAHD_8PbgKE/X-z67wTdCAAJ) - [this other mailing list post from 2015](https://groups.google.com/d/msg/elm-dev/1JW6wknkDIo/H9ZnS71BCAAJ) This "feature" is "poorly documented" because it is not a feature. It does not feel responsible to recommend this approach, so I think it'd be good to edit the post so that innocent readers do not end up investing in a "short cut" that will ultimately be very costly.
I have the same issue, couldn't find a solution :(
Local state is extremely important in React/Redux for performance reasons. It *is* entirely possible to write React with only "Pure" components, using the Redux store to manage *all* states, but doing so has a major performance drawback as the actions must be passed through *every* reducer at *every* change. Specifically, the classic React example is a field that updates the model on change. That's literally with every keypress. If you were to dispatch an action every time a key was pressed, that action would have to run through *all your reducers in the state* and check against *every possible if/then statement* and eventually return a massive application state object for your entire app, which will force all your components to check to see if there were any changes. On the other hand, keeping the onChange event local to the form, and only dispatching an action when the result is final to store the *final* answer is much more performant. I'm just learning Elm, and I'm coming from the React/Redux stack. Here's my general rule: * If the event or change will only affect the current component, put it in the component state. * If the event or change will affect the entire application - that is, other components will need to see the result of this event or change - then put it into the application state / redux store. 
Thanks for letting me know about this. It should be better now.
I'm no expert, but TEA speaks directly to one global data structure handling all of your app's state. Also, a lot of the conventional wisdom seems to center around breaking your Elm app around the topic of concerns (related functionality) rather than having a 1:1 component type relationship. Time travel and a bunch of other fundamental aspects of TEA all stem from having a global and singular model, and bifurcating state would have negative consequences in that regard. This said, you can certainly produce the same results as local state provides without straying from the singular model concept. See this demo for an example: [Multiple Counter Demo](https://github.com/debois/elm-mdl/blob/v8/examples/Counter-many.elm)
The latter is what I mean. 
There's a lot that's been discussed on this topic. Unfortunately I cannot track down links to these conversations. I think first off, it might be important to consider the word "component" as it's somewhat contested in the Elm community because it does not accurately reflect how abstractions are accomplished in Elm. In React, it's indeed components all the way down, but Elm doesn't have this concept of stateful component classes. Instead, you'll separate logic into modules which only hold relevant types and functions. Overall, state management tends to be much flatter than a hierarchy of stateful React components. That said, it is possible to isolate a chunk of state in one Elm module, for example. It does involve some work `map`ping the isolated state back back into the global state, however. The prevailing wisdom is to avoid the urge to "componentize" in Elm as it will likely lead down the wrong path. Instead relying on pure, stateless functions as your main source of data manipulation is the way to go. With regard to performance issues on large state objects, I cannot comment as I've not heard that to be a problem in Elm. My inclination is to say that Elm's immutability and performant record updates make this a non-issue, but I'm just speculating.
This is a situation where you have to be open to thinking a bit differently given the different paradigm. Something to the same effect can be achieved, although I'd argue that it's modeled more nicely in Elm. If you look at Richard Feldman's [SPA demo](https://github.com/rtfeldman/elm-spa-example), you can get a good idea how this is done. The first thing that trips people up is this idea that we're storing one massive model containing all the app's state. While true, take into consideration how algebraic data types makes this approach more reasonable than it initially seems. From the SPA example, the application model just looks like this: type alias Model = { session : Session , page : Page } Not quite so bad, huh? So what is `Page`? type Page = Blank | NotFound | Errored PageLoadError | Home Home.Model | Settings Settings.Model | Login Login.Model | Register Register.Model | Profile Username Profile.Model | Article Article.Model | Editor (Maybe Slug) Editor.Model So, our global application state is really, once decomposed, the page type we're currently on, and the associated model for that page. If we look at the model for, say, the Login page, we get this: initialModel : Model initialModel = { errors = [] , email = "" , password = "" } This is, effectively, what you're asking for. *quick note*: The actual application model in the SPA example has a `PageState` instead of `Page`, which is really just a wrapper for `Page` and the details of why that is isn't really relevant to the question, so I presented it this way for simplicity sake.
I mean, one way is to take all the code in a branch and make it a function. Any time you have Elm code, it is safe to break it all out into a function! That said, **I think it is better to try to focus on the data structures in your model.** Maybe you have a `User` kind of thing? Maybe there are five or six things you do with a `User`? Maybe you check that they've been online recently? Maybe you care about account age? Make helper functions for those scenarios, and that will retroactively simplify your `update` logic. Finding these data structures is kind of tough to get used to, but if you can find the right representation for your problem, you end up with code that kind of breaks in to nice parts on its own. That's my experience at least. That's all pretty vague advice though, so if you say more about the specifics of your application, `Model`, etc. you can get more specific advice!
These two links may be helpful: - [Directory structure question](https://www.reddit.com/r/elm/comments/69hwta/can_i_split_my_code_into_viewmodelupdate_folders/) - [Growing code question](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbuu0m4/) I tried to write about them, as described [here](https://groups.google.com/d/msg/elm-dev/PiuWW6tBVRA/nfjOctSmAQAJ), but I think it'll be a while more before I can figure out how to present it really well.
&gt; Is it possible to have a local state for components in Elm? The answer from [the guide](https://guide.elm-lang.org/reuse/) is: &gt; **We do not think in terms of reusable components**. Instead, we focus on reusable functions. --- &gt; On larger applications, it doesn't make sense to run through the entire state and create entirely new state objects (or records) everytime someone types a single character into a field, and with React/Redux, there are performance issues with trying to put everything into the global store instead of localstate. This is an implementation issue and the implementation of Elm is quite fast. I don't mean to downplay your concern because it is easy to understand how this can be thought of as potentially spiraling out of control BUT, keep in mind that NoRedInk has over 100k LoC of Elm in production. If this would have been an issue, they would have hit it long ago. And they are not alone in this kind of scale, there are multiple projects with over 50k LoC. 
Working on my pet project to learn Elm - a game (Peggle clone using SVG) https://github.com/mandrolic/peggelm
it is not entirely clear to my what you mean by "tag"
I can confirm, it works like a charm. My app has exactly this structure of a model. The main/top level update function is basically the router to the update functions of all possible pages. It structures the app nicely (by the feature in many case). UPDATE: by the way, look how expressive the model is. You can look at it for the first time ever and in few seconds you know so much about the application. Imagine a change, where you would like the login form to be independent on the actual page, so it could just pop up, login and disappear without removing or altering what user was doing before it came out. Such a change would be reflected in a model so clear, you would see the change through before you reached the end of a pull request. Everything is so obvious.
Here's a couple of my updates/messages: My first Elm project, it's still at 0.17. If I was writing it now, I'd go with less nesting in my model, not do data massaging like in the `makeCategoryData`/`makeProductData` functions, keep API response messages at the top level(or nest them all in a single message type), and pass parent messages to my views instead of using `Html.map`: https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes/blob/master/elm/src/Update.elm https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes/blob/master/elm/src/Categories/Update.elm https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes/blob/master/elm/src/Products/Update.elm # &amp;nbsp; A simpler app, I kept everything in a single update, but broke the more complex branches into separate functions: https://github.com/prikhi/RSSonate/blob/master/client/src/Update.elm *Edit:* Actually, forgot I split the update for the login form: https://github.com/prikhi/RSSonate/blob/master/client/src/Auth.elm#L81-L112 # &amp;nbsp; Here I use a lot of nesting, but it matches the nesting of my UI. A single Routine form has an arbitrary number of Section sub-forms, which have arbitrary amounts of SectionExercises: https://github.com/prikhi/bodyweight-client/blob/master/src/Messages.elm https://github.com/prikhi/bodyweight-client/blob/master/src/Update.elm https://github.com/prikhi/bodyweight-client/blob/master/src/RoutineForm.elm The `Int` in messages like `SectionFormMsg Int SectionFormMessage` is the index of the Section form. # &amp;nbsp; And the latest, not too many branches in this one &amp; a lot of repition, I've been thinking of refactoring the options into a `Dict OptionName Bool` which would turn `updateOptions` into a single branch: https://github.com/prikhi/KittensAutomate/blob/master/src/Main.elm#L80-L185 
While this talk is a bit basic and more in line with selling people on Elm, I enjoyed Kevin's first talk regarding Elm's strengths and pain points. I also really enjoyed his appearance on the Elm Town podcast. He makes a lot of good points in both his youtube talks and podcast appearance. If you're in to Elm, definitely take the time to check out these resources.
This confused me for a while in Haskell. The key to understanding it is that Tree is a type and Node is your constructor function for creating that type. Now consider that pattern matching works for constructors not types and you'll see that you need to 'import modulename(Node)' to get pattern matching working, which is why (..) works, too!
Writing a bunch of update functions, and then: andThen : (m -&gt; ( m, Cmd msg )) -&gt; ( m, Cmd msg ) -&gt; ( m, Cmd msg ) andThen step ( model, cmds ) = let ( nextModel, nextCmds ) = step model in nextModel ! [ cmds, nextCmds ] So in the end, you have something like... doSomethingWithThisMsg msg model |&gt; andThen doSomthingMore param1 param2 |&gt; andThen sendAwesomeCmds param |&gt; andThen doMoreThings ... 
The podcast appearance (elm town); in what episode was that?
what does this function do'?
Does anyone know the name of cursive looking font in this presentation? Looks like it might even be a fixed width font. 
Looks like [Operator](https://www.typography.com/blog/introducing-operator). 
https://elmtown.github.io/2017/01/12/2017-1-12-Production-in-Elm-Town-Episode-10.html
Have you tried using SVG? 
Is there an idiomatic yet generic way of handling tabular data, for instance from a csv? Thanks in advance :)
The way I cope in this regard is trying even harder making good representative names for my modules. 
This is necessary, but I don't think it's sufficient. For example, I have a `Point3d` module (namespaced as `OpenSolid.Point3d`). I think `Point3d` is a good representative name (there are only so many things you can really call a module that manipulates 3D points), but reasonable people can have different ideas about how 3D points should be represented or manipulated. As a result, without some kind of namespacing you could easily end up with a situation where one package that parses 3D model files uses one `Point3d` module/type, and another package that renders 3D graphics uses a different `Point3d` module/type. The poor soul who wants to parse a 3D model file using the first package and then render it using the second has no way to do so - they can't write a function that would convert from one `Point3d` type to the other, since that would presumably require importing functionality from each of the `Point3d` modules.
Can you be more specific about what you want to do? Is it more about parsing CSV, or transforming it, or displaying it? Something else/all of the above?
I sincerely understand your feelings as I felt exactly the same way 6 months ago when I started learning Elm. What felt most confusing for me was the lack of parenthesis (or any other mark) to separate function names from function arguments both when declaring functions and when calling them. But, believe me, you'll get used to it after a few weeks of writing and reading in Elm. Even more, the amount of language constructs and features is so (purposely) small that it becomes relatively easy to read about it all in a few hours, so I'm pretty confident that after the feeling of alienation is overcome you will realize the syntax is pretty clear and consistent and you will love it!
I played around with it, got it to work. I imagine this isn't optimal though, suggestions are welcome. I just had to modify the `view` and `radio` functions view : Model -&gt; Html Msg view model = div [] [ fieldset [] [ radio "Small" Small (if model.fontSize == Small then True else False) , radio "Medium" Medium (if model.fontSize == Medium then True else False) , radio "Large" Large (if model.fontSize == Large then True else False) ] , Markdown.toHtml [ sizeToStyle model.fontSize ] model.content ] radio : String -&gt; FontSize -&gt; Bool -&gt; Html Msg radio value msg isChecked = label [ style [("padding", "20px")] ] [ input [ type_ "radio", name "font-size", onClick (SwitchTo msg), Html.Attributes.checked isChecked] [] , text value ]
Elm becomes fun after the initial pain period. You then start having nightmares about having to go back to work with JavaScript &amp; the ES6 BS, SCRIPT OR NOT? WHY IS THIS A FUCKING THING? MJS WHY ANOTHER FUCKING EXTENSION...asdfkjaskfdjwafas.fjda.fj.af.ajf....... Elm syntax makes programming less tedious IMO, union types are a beautiful way to structure your data. Write an app with it, then come back to us and let us know your impression :) 
It is pointless to use an if and return True or False, just use the condition directly (e.g. `(model.fontSize == Large)`). Here is how I would refactor the code on the first pass: view : Model -&gt; Html Msg view model = div [] [ fieldset [] [ radio "Small" Small model.fontSize , radio "Medium" Medium model.fontSize , radio "Large" Large model.fontSize ] , Markdown.toHtml [ sizeToStyle model.fontSize ] model.content ] radio : String -&gt; FontSize -&gt; FontSize -&gt; Html Msg radio value target selected = label [ style [ ( "padding", "20px" ) ] ] [ input [ type_ "radio" , name "font-size" , onClick (SwitchTo target) , Html.Attributes.checked (target == selected) ] [] , text value ] On the second pass I would probably go for something like this: view : Model -&gt; Html Msg view model = div [] [ radioSet [ Small, Medium, Large ] model.fontSize SwitchTo , Markdown.toHtml [ sizeToStyle model.fontSize ] model.content ] radioSet : List a -&gt; a -&gt; (a -&gt; msg) -&gt; Html Msg radioSet items selected onSwitch = let radio target = label [ style [ ( "padding", "20px" ) ] ] [ input [ type_ "radio" , name "font-size" , onClick (onSwitch target) , Html.Attributes.checked (target == selected) ] [] , text (toString target) ] in fieldset [] (List.map radio items) 
I ran into the same problem - I had elm-test defining a Test, and also my app (which is an e-learning thing) defining a very different kind of Test! Now I just namespace all my stuff one level deep by the company or app name.
but how do you uninstall it?
Yes, that makes sense. Re. plotting, it kind of depends on the library you're using. If you're using [elm-plot](https://github.com/terezka/elm-plot), it looks like you generally map your data into a [Series of DataPoints](http://package.elm-lang.org/packages/terezka/elm-plot/latest/Plot), types that the library defines, which allow you to do things like define the size of the points as a function of a column. If you're using [elm-visualization](http://package.elm-lang.org/packages/gampleman/elm-visualization/latest), your data is often just passed in as something simple like `List (Float, Float)`, but you also construct other parts of the visualization (scaling, axes, markers, colors, etc.) with other transformations of your data, in a way similar to d3.js (which it's based on). Re. data manipulation, I don't know of a standard approach in Elm. I mean there are some linear algebra libraries, but if you're doing basic mapping, sorting, grouping, reducing, etc. it's not too hard with the tools that you can find in List, Dict, Set, and List.Extra, Dict.Extra, etc. (But note you probably don't want to use Elm to manipulate as large a dataset as you could using pandas/R dataframes, Elm's data structures are not optimized for that.) That said, I have been working on a library to simplify some common data needs I have, such as producing a crosstab (aka pivot table). It's not ready yet but I could share with you what it looks like so far, to see if it looks useful to you. Re. CSV parsing, you probably have seen [elm-csv](http://package.elm-lang.org/packages/periodic/elm-csv/latest/Csv). That will get you as far as a list of fields and a list of records -- all as `String`. Not super useful for throwing into a plot. I wrote a thing that lets you declaratively parse this into your own types, i.e. `Csv -&gt; Result errors (List model)`, which is based on `url-parser`. (It's currently [sitting in a PR](https://github.com/periodic/elm-csv/pull/2), but I may spin it off into its own library.) 
Try using firacode font, it has a ≠ ligature for /=
There are sane reasons for the syntactical differences, which apparently are so opaque to most people here that no one has brought them up so far. I'll give explaining them a shot. An auto-currying functional language, like elm or haskell, is focused on composition way more than imperative languages are. Imperative languages rely on sequencing operations through state accumulation, like gathering up and side-effecting objects, to complete an operation. The types in elm map directly to what you're typing. `(+) b c` maps directly to `(+) : Int -&gt; Int -&gt; Int`, which is trivial. The less trivial case is that`(+) b` also clearly maps! You obviously get an `Int -&gt; Int` back. You can't do this kind of reasoning in javascript because types and formal arguments are mere suggestions and objects cause you to throw most of your reasoning-about-code tools out the window. So why not make it `add(a, b)` and `add(a)` in elm, instead? Because those would be tuples. The representation of parameter lists in javascript is the representation of tuples in imperative (and functional) languages with terse tuple syntax. If you're passing a single tuple as the sole paramter to a function, you can't partially apply that function. It loses you a lot of compositional power by destroying currying. You build programs in elm by composing functions, so emphasizing the compositional nature of functions is way higher priority than making some operation precendence situations more clear. On the other hand, lambdas are less defensible but the reasoning is a lot simpler, I think. `x =&gt; x + 1` vs. `\x -&gt; x + 1` -- with the leading backslash, the elm lambda is more readable. When you're reading left-to-right, the number of symbols you have to read before knowing what's going on is lower in elm. You see a backslash and an identifier and you can guess with near certainty it's a lambda. The following minus sign leaves no doubt. In javascript, you have to get to the `&gt;` before you have any idea what's going on--this could easily be an assignment statement until you reach that less-than. It's not a great reason, but it's at least not a downgrade.
&gt; It is pointless to use an if and return True or False, just use the condition directly Of course! Can't believe I did that... Thanks for the examples :)
I've used elm-plot before which, while nice isn't as expressive for some things beyond scatter and bar charts as I'd like. I hadn't seen elm-visualisation before though which looks really nice and potentially exactly what I'm after. As you say, I don't want to be handling a particularly large amount of data in elm. I think the sticking point so far has been trying to access data either by row or by column. Although I am starting to think I'm trying too hard to approach the problems from my existing mindset, rather than embracing an elm-ish approach. Thanks very much for the help, especially going off some very vague questions :)
This library has made life a lot easier for me, thank you very much for putting the effort to bring some type safety to bootstrap construction!
Thanks a lot, the deep linking is especially useful to me! Keep up the good work.
If only there was a way to create an alias for `{x: T}` and then go `{rest | Alias}` or something. I mean, the more functions with anonymous record params you have in your code, the more you’re going have to refactor. Or am I missing something?
Is package.elm-lang.org down? Why when I use `elm-repl` does it need to hit the package.elm-lang.org website?
What you can do is this: type alias A rest = {rest | x : T} f : A rest g : A {}
The ideal version is that you have `( "key", Lazy.lazy viewWhatever whatever)` such that you match keys, and then only expand if the data changed. You could do this by breaking `rowView` into two functions: import Html.Lazy exposing (lazy2) viewKeyedRow : Int -&gt; Row -&gt; ( String, Html Msg ) viewKeyedRow index row = ( toString row.id, lazy2 viewRow index row ) viewRow : Int -&gt; Row -&gt; Html Msg viewRow index { id, label, selected } = tr [ ... ] [ ... ] That is what the elm-todomvc example does [here](https://github.com/evancz/elm-todomvc/blob/master/Todo.elm#L300-L337). In that case, [the line you mentioned](https://github.com/krausest/js-framework-benchmark/blob/master/elm-v0.18.0/src/Main.elm#L173) becomes: List.indexedMap viewKeyedRow model.rows Do you think they would be willing to make this change? Would be very cool to have this in there!
There are some very strange decisions here regarding data structures. The actions being performed on `model.rows` suggest that it should be stored as an `Array`. This seems understood because there are many times that the list is being converted to an array to perform an operation then changed back to a list, which is nuts.
I think they absolutely would, especially if the fact that Elm's `Html.Lazy` is similar to React's `shouldComponentUpdate` is mentioned.
I gave it a shot with [this PR](https://github.com/krausest/js-framework-benchmark/pull/192). We shall see! Thanks for enquiring further! :D
I made [a pull request](https://github.com/krausest/js-framework-benchmark/pull/192) to use `lazy` on the rows, but I did not notice the array conversions! You could keep it as an `Array` in your model and then use `Array.foldr` to build a list of `Html` if you really wanted. This would skip some amount of intermediate allocation. Worth testing to see how complex the change is and what the performance impact would be. In trying to optimize the `elm-todomvc` code to use a `Dict`, I found that these details can so dominated by rendering that it's not such a big deal in the end. Though perhaps with 10000 rows it is more important!
interesting. Performance is a side show. Reliability is the elephant in the room.
I remember hearing that Rust avoided Haskell syntax because it wanted unseat C++ and Idris adopted it because it wanted to attract researchers. It's a brave decision for Elm - but I am happy with it - and sometimes it's good to take risks.
Undefined is not a function :)
This week I am reading the elm guide and doing the exercises.
In my experience, trying to emulate Elm as close as possible in JS is only going to feel awkward. The language is simply very different.
How do you find such projects, like what search terms do you use or do you follow the said links closely
Subscribe to the Elm subreddit. You'll see them pass. I also highly suggest you read Richard's book: https://www.manning.com/books/elm-in-action
Could Elm theoretically figure what should be lazy on its own? When using reagent in Clojurescript it knows which function dereferenced which piece of state and uses that knowledge to know which functions it should run again. I'm not saying it should be a priority given that Elm is already fast and it's not hard to optimise it with a few `lazy`, I'm just wondering if it'd be possible.
I found some time to make a demo of a current pet project. &lt;https://klaftertief.github.io/slippery-slope/&gt;, a slippy map implementation in pure Elm. It's not really an alpha version yet, but maybe people find it interesting. The idea is to start planning some collaboration...
I'm working on a collaboration platform using elm / NodeJS, can't exactly show a prototype but webRTC has been really fun to work with along with Elm. The Ports system was a good idea imo. As a side project, I want to build a chess game using Elm and WebRTC data link along with an Emscripten build of stockfish 8. If anyone wants in just message me here and I'll let you know the roadmap.
Actually making that happen sounds pretty difficult to me. That means functions know to track specific references? So they are keeping track of some table of references and checking that the arguments share all of those? I don't know really, but it sounds like a pretty complex project with complex tradeoffs in practice.
In reagent, the state is kept in a special reference type called a ratom (Reagent Atom, as apposed to regular Clojure atoms). As soon as a function dereference the ratom to get the content, the link between the two is established and changing the data in the ratom will make every function that called it dirty. The big difference with Elm here is that you have several of those ratoms rather than one big state as in Elm. &gt; but it sounds like a pretty complex project with complex tradeoffs in practice. It does.
Nice write up
That sounds like a good case for [Task.andThen](http://package.elm-lang.org/packages/elm-lang/core/latest/Task#andThen). Convert your requests to tasks with `Http.toTask` and chain them together with `Task.andThen`.
I'm working on a microtonal music sequencer at https://microtonalsequencer.netlify.com/.
Also maintainability!
I poked at these benchmarks a little, and it's true that you can do a bit better on the `Array` stuff, but it seems the contribution of the update phase on the benchmarks (say ~1ms for "remove") is totally dwarfed by the virtual dom/diff + browser restyling phase (~40ms). Elm seems to incur a little more restyling time than other frameworks. Not exactly sure why yet, could be something tricky about the vdom and styles specific to this benchmark. Another thing I noticed is that Elm's ability to use `requestAnimationFrame` adds noise to these results. Some of the benchmarks only take 10-15ms altogether, so in the same range as waiting for rAF to schedule a render. So it seems to hurt results in these synthetic benchmarks in a way that would not be noticed in a real use case.
If you have a msg that accepts two integers, like NewFace Int Int, then in the update function you can use it: Random.generate (NewFace index) (Random.int 1 6)
honestly, a few of the newer languages are intentionally doing away with polymorphism. Code is meant to be read not written, this those extra key strokes make the code more readable.
It's much easier to read `head [1, 2]` than `List.head [1, 2]`. Even more so on longer expressions.
What if there's also `String.head` - returning the first symbol. Can you use two simultaneously and let the Elm figure out if it should use `List.head` on lists and `String.head` on strings? import List exposing (head) import String exposing (head) _ = head [ 1, 2 ] _ = head "ab"
Don't agree. There's no such issue in TypeScript, it also has inference &amp; polymorphism. No I don't need to keep in my head every compiler decision - because most of the time (TypeScript for example) those decision is quite reasonable and I would made the same decision. And in rare cases when the extra clarity is needed - you just specify types explicitly - problem solved.
No, that won't work. The compiler will tell you that the usage is ambiguous and you need to use `List.head` or `String.head`. By your replies to the other comments, it seems like this is something you really want and the examples that are being used aren't working to change your mind. If you came here to see other's views then it may be valuable but I don't think that's the case. If you're interested in some of the design decisions in Elm, I'd like to point you to the Elm Town podcast. Evan Czaplicki, the creator of Elm, is often on it and he discusses the designs in detail. I found it really interesting and it boosted my enjoyment of coding in Elm. At the end of the day, coding should be fun and if the language you're using doesn't do things the way you like, then you can just use the language that you do.
You can certainly disagree, but experience has shown that type classes are a big stumbling block for people trying to learn Haskell. TypeScript is an imperative language and while you can describe more complex types and write in a purely functional style this isn't common so you won't encounter the same issues. Having mutability and side-effects provides escape hatches that can greatly reduce the complexity of the types you need to describe. Don't underestimate the value of making things easier to learn for a target audience. Purely functional programming has a lot of advantages but has generally failed to be adopted by the majority of developers largely due to the steep learning curve when transitioning from imperative style programming. Not having type classes greatly reduces this curve allowing more developers to get started with and gain an understanding of the attributes of purely function programming. For users that decide they need the power of type classes moving from Elm to Haskell or Purescript is a much smaller step. 
&gt; It was possible to do so in old Java almost 20 years ago. So why Elm in 2017 doesn't have this crucial feature? There are no solutions, only trade-offs. Adding that kind of object oriented features to Elm will forever introduce a large layer of complexity to the language. Each of the available options has its own set of disadvantages and, to my understanding, Evan has not figured out what is the best approach for Elm. So, the default position is to hold on implementing these features and focus on other, more important aspects of the language. 
&gt; Code is meant to be read not written, this those extra key strokes make the code more readable. Maybe sometimes, other times it's just noise. Sometimes the types that are manipulated are extremely obvious because of type signatures or because of the context and all those `List`, `String`, etc. are just redundant. Sometimes you work with an abstraction and you want to program to the abstraction rather to the concrete type. Let's say you are switching between `List` and `Array`in evaluating the performance of a piece of code. Sure... modern editors allow you to change text in multiple places at once but this might not be scalable in certain cases. Some people would prefer getting rid of this hurdle and program directly to some kind of protocol/trait. &gt; honestly, a few of the newer languages are intentionally doing away with polymorphism. Can you name these few languages? I'm asking because I'm not aware of any other reasonably well known language that does this. 
It is not Object Oriented feature. It's a functional pattern matching. In Object Oriented languages its known as Polymorphism. In functional languages it's known as multiple-dispatch, multi-methods etc.
To my understanding, the best thing that OOP brought to the world is "fixed number of operations, unbounded number of implementations”. It allowed multiple data types to be treated like one datatype with a certain set of traits. 
C++ screws up everything, so the fact that it's a pain in C++ is really irrelevant :P
Java is a DSL for the enterprise :P It's sort of technically correct, but not terribly useful.
Go. You can get polymorphic type behaviour but you do it by declaring up front you requires a specific set of methods and then passing in an object which satisfies said set. Go calls them interfaces, however functions themselves cannot be overloaded. You mention list specifically as a case where it is "obvious" which function is being called. Well lists are templated, so they have a free type. That means you can specialize it. Say a list of Foo. Now what happens when I go along and make a special map function for lists of Foo. Any sane compiler would prefer the more specific type match to a more general one and use it. Now you reading the code see a function which takes a list and thinks, oh thats calling Lists map. Except when you pass in a list of Foo everything breaks, would you suspect the map function. Of course you wouldn't, there is no indication that anything is special about it. There is nothing at the call site to make you think that the function being called is anything other than List's map function. You can get the polymorphism you want by injecting the dependency rather than having your compiler magic the function to you. 
Depends on what type of abstraction you are trying to achieve. Functions are themselves abstractions. Sure you can have functions that work on abstract things, the fact that a list can work on a list of abstract things means that there is an abstraction there. There is something that can be said for haskell like type classes but you are going to have to be more specific about which abstraction you are trying to achieve.
&gt; It's sort of technically correct It not only technically correct, I think it is totally correct. Elm has not been designed as a general purpose language right now.
Thank you.
Thank you. Have done some corrections.
I'd like to add again, it makes me uncomfortable that "Elm" is used in the name of your project even though it seems to be connected only in that the syntax is similar. Elm looks similar to OCaml and Standard ML and Haskell, but that does not mean we take their names. It seems that including the term "Elm" serves to piggyback on Elm's reputation, which I don't think is the right thing to do for either project.
Are there any decent resources for reading about reasonml? Could only find things that sort of suggest that it is very very new.
Check here https://github.com/vramana/awesome-reasonml
What research have you done already? Have you looked at both simple and advanced examples from both languages?
The target is to solve side effects the exact way Elm does it. The only way to introduce side effect now is to use FFI which is current equivalent of Native Modules (which as far as I know can introduce side effects too). With the exception that Elmchemy's FFI is type safe, and Elm's Native Modules aren't. But I will repeat. The **target** is to make everything work the exact same way as in Elm, with an exception of the platform being BEAM. But I hope it goes without saying that writing software takes time, so the features that are yet to come, or are half-baked aren't changing the context of the project
I'd explain functional programming a bit more by stating it has "no side effects" or at least "managed side effects". I'd also expand on "saubere Versionierung" by mentioning that elm's package management enforces semantic versioning. I haven't heard that from any other package management system yet.
* A detailed explanation: https://guide.elm-lang.org/architecture/effects/ * A real example you can play with: http://elm-lang.org/examples/http My explanation, in case it helps: Imagine your Elm program as a man that sits at a desk. He takes messages from his left, does some work, and passes messages to his right. Your man can only look at messages he is given and create new messages. He can't "change" anything. He can, however, give out a message that says "this side effect needs to happen". So imagine a normal imperative program that looks like this (psuedocode): state = Elm.YourApp.initialState command = null while(true): state, command = Elm.YourApp.update(state, command) command = Elm.SideEffects.do(command) dom = Elm.YourApp.view(state) Obviously, it's a gross simplification, but the idea stands. Your elm app is just being run in a loop that deals with all the side effects - you see it all as immutable state and commands. In a more in-depth example, you return a command from your Elm application that you construct like so: `Http.send SetText (Http.getString "https://example.com/books/war-and-peace")` That's a command that says "get the string result of the given URL, and then use the `SetText` function to make a new command, and give me that in the future". As some point in a future run of your update function, it'll get that command with the data you requested in it.
I'm not sure if there're any big pros actually, unless you care deeply about language `purity`. Besides that, only one thing that comes to mind - the toolbox to deal with when you're just starting out is really small and manageable. Imho.
[removed]
I am curious too, examples please :D
Is it possible to disconnect Elm from the runtime, though? Or plug in a different runtime? What I'm getting at is that it seems like it would be a little disingenuous for Elm to make such claims if the language was inextricable from the runtime. I suspect it must be possible, but I can't really find any info. about it.
I agree that from the language alone if you don't care about purity there's only a big difference which is the module system. But when you consider tooling, clearly usable libraries for newcomers, documentation OCaml in general hits very low compared to Elm.
Thank you this is a lot clearer for me now! I'm a little unclear about the runtime itself - the runtime simply helps execute our code, right? So, what is Elm doing with these side effects that is different from how it is done in JavaScript, with JS code and the JS runtime?
I was wondering, are you waiting for 0.19 for the next chapter of your book or we can expect it sooner?
Thank you for the response! Like I said in my OP, I haven't done much work in Javascript, so I didn't know I was linting anything :D I used [create-react-app](https://www.npmjs.com/package/create-react-app) to bootstrap my project, and the `package.json` is [here](https://pastebin.com/0WmAyhM1). I don't have a `.eslintrc`. But if Elm-generated code is not linter-friendly, I assume I can configure the linter (ESLint from the looks of it?) to ignore it? UPDATE: It would seem that using `create-react-app` hides a lot from the user; in my case, I needed to deal with Webpack, which was actually calling the linter. For those who may have stumbled upon this thread from the future and are also using create-react-app, 1) hi from 2017! and 2) run `npm run eject` to get full control over your config, including webpack. I added a rule to Webpack's configuration to exclude my generated JS from concern, and now I'm getting a TypeError from React, dealing with the `react-elm-component` line that I'm using. I think I'll try the ReactJS subreddit from here; the Elm part as far as I can tell is working. Thank you again for your help!
Yes, but you never directly code in javascript. The runtime is a body of code which executes your functions as well as dispatches the side effects. This leaves your code completely side effect free. 
Also the reason syntax loses the beautiful ML one
Thanks for the response. Now I will wait patiently :P
I completely understand this concept, and I'm very much on-board with it. It's similar, if not identical to the side-effect model in redux-saga. What I'm saying is, if it's not possible to run your code outside of the side-effect executing runtime (which... maybe it is possible, but I just haven't seen how yet), saying that the language is pure and side-effect free is really a bit of a falsehood in a way, because the language and the effect-ful runtime are inextricably entwined. To illustrate using redux-saga, if I have a saga like: function* foo(){ let body = yield select((store)=&gt;store.foo); let response = yield call(http.post, 'http://example.com', body); yield put('FOO_SUCCESS', response.body); } This is pure and side-effect free, each `yield` merely returns a plain JS object which describes the effects that the saga runtime would execute (if this were wired up to the runtime). And I think most importantly here, I can test this very simply by just calling it outside the runtime. In other words, I have the choice to execute this as a pure function outside of the runtime without any effects being executed. It's not clear to me that the same can be said of Elm, but I would be very happy to be shown otherwise.
And remember that it's only one small part of the code that would change (and presumably mostly just go away) so there would not be that many changes to the whole app.
Looking into it further, I think I misunderstood about how `Cmd` interacts with the runtime. I was thinking they were wired in implicitly, somehow, but it looks like it's actually quite explicit, via a `Program`. So nevermind! That's the piece I was missing. Looks like you can write your components pure and testable, and only wire them into the runtime as and when is needed.
Thanks!!
Yes, by default if you create a `Cmd`, nothing happens. It's just data. You can do what you want with that, including testing or debugging. It's only if you put it into a `Program` and expose that in a top-level module the commands will get processed by the runtime. There is no magic happening - those commands don't get found through special backdoor systems. This is how the debugger works, and why I gave it as an example. It just stores all the messages produced from the commands that run, and then throws them back into your application. It does *not* just store all of the state changes. (To see this, if you change your code to change the behaviour, and run the debugger with the recorded input, it'll do whatever the code now says, not follow what happened before).
&gt; Is it possible to disconnect Elm from the runtime, though? Or plug in a different runtime? Every language has a runtime, even the compiled ones. Elm has not reached 1.0 yet and because it is evolving fast enough, it is not wise to implement another target for it. In the future there could be other targets for the compiler (other runtimes). 
&gt; This is pure and side-effect free, each yield merely returns a plain JS object which describes the effects that the saga runtime would execute (if this were wired up to the runtime). The function itself is not pure nor side-effect free!`call` may halt the execution when the `fn` returns a promise, which is also an immediate side-effect. The choice you describe is to guarantee that `fn`does not return a promise, nor has any side effect, and basically that `call` does not halt execution. Then it could be considered somewhat pure-ish, but what's the point of all this? In the real runtime it will be impure. In contrast in Elm, there is now possible way to ever write an impure function, period. Side effect can only be described, they cannot ever be executed. The cost is that a sequence of side effects is then not so neatly listed as in you redux-saga example, but that is a different issue. Edit: replied to the wrong comment, sorry. [This was the target](https://www.reddit.com/r/elm/comments/6flnox/understanding_side_effects_in_elm/dijmdyi/).
`foo` above is 100% pure. Given the same inputs, it will always, always, always produce the same outputs. It's a generator, which is inherently stateful, but in this case we're not doing anything we couldn't have achieved with some other method, such as higher-order functions, so I'll kind of hand-wave at that. &gt; `call` may halt the execution when the `fn` returns a promise, which is also an immediate side-effect. That's not at all how `call` works. All it does is take its input (`http.post` function, a url, a request body (maybe a string or object)), and return an plain JS object like this: {type: 'CALL', fn: http.post, args: ['http://example.com', body]} That's it. Pretty darn pure. It's just describing a side-effect, which I will stress is not executed by default. If this saga were wired into the runtime, then the runtime would take this pure description of a side-effect and execute this `fn` function, but that doesn't make `foo` any more impure than the Elm runtime doing exactly the same.
&gt; foo above is 100% pure. Given the same inputs, it will always, always, always produce the same outputs. It cannot possibly be pure, if it returns something that contains the result of I/O. In this case the response body. I think we do can agree on the idea that `call` and `put` mostly hide side-effects. If we had one function ``` function postIt() { return call(http.post, 'http://example.com', body); } ``` and another ``` function processResponse(response) { return put('FOO_SUCCESS', response.body); } ``` then both these functions are in fact pure! Given that `call` and `put` do what the docs say. So how can all Elm functions be 100% pure, if `yield I/O` can never be pure? The answer is that Elm hides `yield` from you, in it's runtime. All events and I/O results trigger some kind of reducer, which returns the new state + description of side effect. And it really can only ever be the description. The result of it will be passed back to your reducer in your program. I think redux-saga is great, because it's building blocks are pure much like elm. But it also gives you this extremely convenient way of wiring side-effects together with `yield`. 
Ah, I see the sticking point. Still though, I assure you it's 100% pure. The way generators work is, they're a function which returns an iterator. An iterator is an object that has a `next` method, which returns the next item (in the case of a generator, it's the next `yield`ed value. But, you can also pass in a value when you call the `next` method, and, e.g. assign that value within your generator. That's what's happening here. The runtime is passing the HTTP response back into the function. It might look like this: function* foo(){ let body = yield select((store)=&gt;store.foo); let response = yield call(http.post, 'http://example.com', body); yield put('FOO_SUCCESS', response.body); } const bar = foo(); bar.next(); // {type: 'SELECT', selector: &lt;function&gt;} bar.next(SELECTOR_RESULT_FROM_RUNTIME); // {type: 'CALL', fn: http.post, args: ['http://example.com', body]} bar.next(HTTP_RESPONSE_FROM_RUNTIME); // {type: 'PUT', message: 'FOO_SUCCESS', payload: response.body} Now, the fact that this is done with generators, where you're calling the `next` method and getting different results... let's consider that an implementation detail. Aside from the calling method, this is really isomorphic to an implementation with higher-order functions. So again, 100% pure. The saga describes the effect (e.g. IO), the effect is handled by the runtime, and the effect results are passed back to the saga. But you don't need to wire this into the runtime. You put this in your test suite, you can run this function a million times, and as long as you pass the same arguments, you'll get the same results. Exactly what you're describing happening in elm is what sagas is doing here. Edit: Just to reiterate one point. Technically, yes, this is impure, b/c of the generator stuff, but that's really just for the sake of convenience, and could be implemented 100% purely with higher-order functions, with no loss of generality, as they say, and only a minor modification in calling method. It would be much, much uglier, though, to write functions that way, so I hope you'll forgive some handwaving over that one minor point.
Oh, now I think I understand it. Thank you for the nice explanation. If I got it right, `foo()` returns a stateful object, that on each call dispatches the description of the next side effect (or maybe also just simple values). The only purity mystery would then be the internal state of the generator's iterator. But I agree that this would be a technicality and not really important. 
Good to know it works on Firefox :} 
I tried out the site on my phone (LG G6), and the animations were super slick! Very nice job! Can you share any details of how you structured the markup for animation, and which libraries/techniques you used?
[Evan's Keynote](https://youtu.be/j7tc-5a99OA?t=6030)
SECTION | CONTENT :--|:-- Title | Diffusion en direct de Elm Europe Length | 5:31:34 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
I would hope that whatever happens, syntax and behaviors/complexity remain minimal. I mean, its fine if I build complexity into my app to suit the domain I'm modeling, but I don't want it hoisted upon me with hidden/non-obvious behavior, heavy convention, and keyword overload. This is biggest appeal to me for elm as been the focus on simplicity.
This list omits the fifth step: simplicity and programmer happiness. Elm has already reached that step, and I don't think it should regress to one of the earlier ones. :)
If `User` is extending `UserBase.User` (which is mildly confusing) shouldn't it be `(User.UserBase.User UserBase.User)`? Side note, I would recommend improving your type alias names, like BaseUser and ExtendedUser or something, just so things are clearer when you're reading through your code.
Agreed! I think library makers enrich the community a lot and it's time to make that group of developers happy too because it's very hard to create true flexibility in libraries without more abstraction. Code reuse is a synonym with copy paste en many real life scenarios in Elm and this remains unaddressed unfortunately.
I have a project that uses both Elm and PureScript. It took me about a month and a half (side-project time, not work-day time) to learn PureScript and write a CMS in it. Documentation was often confusing and had me digging through type signatures and source code to grok, but once I figured out what I was doing, it was very nice to use. The interop with JS, in particular, was much nicer (but less safe!) as well as handling async effects without having to make multiple branches of an update function (you can basically write async things as if they were synchronous). The community is incredibly helpful as well. If I couldn't figure something out on my own, all I had to do was pop into the PureScript Slack channel and ask. Would I recommend PureScript to a team of people who are new to FP and want to get started quickly? No, absolutely not. Would I recommend it to someone who likes FP and wants something more powerful than Elm? Yes, absolutely.
I hear this kind of statement a lot, but rarely in the context of any specific case. It would greatly move the discussion forward to give one or two specific cases you have run into (perhaps greatly simplified) in frontend work, where not having typeclasses is a pain in the ass and/or having them would enable better code (for some metric of code quality). In other words make the case on a practical basis. For me, I occasionally miss having the ability to define my types as comparable. But it's easy to work around. And probably wouldn't need full blown typeclasses to implement anyway.
 -- | Type of each JSON entry in record syntax. data Person = Person { firstName :: !Text , lastName :: !Text , age :: Int , likesPizza :: Bool } deriving (Show,Generic) -- Instances to convert our type to/from JSON. instance FromJSON Person instance ToJSON Person [Source](https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json) I like JSON decoding in Haskell, where the redundant Parser is derived automatically.
Well Elm certainly leads to happiness :) However I think that the ability to make abstractions is a prerequisite to simplicity, and I also feel like Elm provides very limited ways to produce abstractions.
Where do you place dependent types on that scale?
Personally I'm here for the happiness, not abstraction for the sake of abstraction, but I can certainly respect the other perspective. Fair enough!
You do not need type classes to generate decoders and encoders. That's generally called code generation, and different languages support it in different ways. Haskell's `deriving` feature happens to be designed in terms of type classes, but that's in no way necessary. Also, where is the dependently typed stage? If higher stages are better, isn't that the best one? When is Haskell going to get to that better stage?
Is something similar possible in Elm right now? I don't think that this scale is intended to linearily rank all possible features from the universe of typed programming. I never tried dependent typing, but it seems to be on a different level than the type abstractions in the scale. I looked and Idris also uses typeclasses...
Plus strictness. &gt;It only lacks in that it didn't detach itself from heavy math jargon from Haskell and academic cleverness with short variable names Short variable names are a *good* thing in functional languages. 
That's an excellent point - perhaps the issue is that until now language designers have trivialised specific user problems. I suppose you are only one person, so you focus on making a dent on one set of problems (web UIs). What I termed a 'DSL' is really just attention to detail on a specific use-case... As a matter of interest have you ever thought about tackling something like the server-side framework set of problems? That's another area that I think has had a lot of work and thinking on, but suspect a little deeper thinking could go a long way... I am sure there are lots of areas like this - and probably alot of overlap... 
I don't think more people would really make things go a ton faster. Figuring out how to express things in a pleasant and pure way usually takes a year or more (e.g. HTML, HTTP, geolocation) and I do not think there are easy shortcuts around the learning and thinking that go into these things. About servers, I have thought about that quite a lot :) You can read some notes [here](https://github.com/elm-lang/projects/blob/master/roadmap.md#can-i-use-elm-on-servers), and I have done quite a lot of exploration past that. Figuring out "how to make great servers" and make it easy is a hard problem ;)
Yeh - smart, elegant solutions look only look v simple in retrospect : )
Thanks!
This is a thing of beauty. I've been playing with the TW tech radar too, and like you thought that it looked like it had been written by a Java dev that played with JS (and was a bit of an incomprehensible mess). I'd even thought of rewriting it myself in Elm but didn't really have the time. Nice work!
Very nice article! Keep in mind that parsing CSV is never as simple as splitting commas. I'd recommend using one of the available libraries like [elm-csv](http://package.elm-lang.org/packages/lovasoa/elm-csv/latest). Have a look at the source to understand why it gets tricky: [Helper.elm#splitLineWith](https://github.com/lovasoa/elm-csv/blob/1.1.4/src/Helper.elm) Also it'd be great to have the gsheet URL in the input instead of as placeholder so that you can use it to run the code. Thanks for sharing
Super nice read ! kinda random question: what is the meaning of this string ? from the blips gist! ``` path [ d "M412.201,311.406c0.021,0,0.042,0,0.063,0c0.067,0,0.135,0,0.201,0c4.052,0,6.106-0.051,8.168-0.102c2.053-0.051,4.115-0.102,8.176-0.102h0.103c6.976-0.183,10.227-5.306,6.306-11.53c-3.988-6.121-4.97-5.407-8.598-11.224c-1.631-3.008-3.872-4.577-6.179-4.577c-2.276,0-4.613,1.528-6.48,4.699c-3.578,6.077-3.26,6.014-7.306,11.723C402.598,306.067,405.426,311.406,412.201,311.406" ..... 
I am working on finishing the outline of a video course on Elm for Manning Books. I will probably record the first few videos on Friday.
Thanks for the csv tip. It does look like it can get tricky.
ah, yep! Makes perfect sense know. I was like:" WAT? how can an human type that thing :/ " Thanks for the answer! 
http://i2.kym-cdn.com/photos/images/newsfeed/000/313/189/7e4.jpg
What do you mean specifics? I've used type classes in Haskell and functions on types in Idris. They reduce code reuse. &gt;what the costs would be in terms of compiler complexity Doesn't matter to the end user. 
Evan has used typeclasses quite a lot, being one of the most active Haskellers on GitHub thanks to his work on the Elm compiler, which is written entirely in Haskell. Do you have a theory as to why, despite his expert-level understanding of typeclasses, he does not share your view that it is "ridiculous” that Elm doesn't have them?
&gt;Do you have a theory as to why, despite his expert-level understanding of typeclasses, he does not share your view that it is "ridiculous” that Elm doesn't have them? I didn't say that. I said it was ridiculous to *defend* a lack of type classes. I don't expect him to implement my every whim (he has time commitments of his own), but we can still talk about design patterns without dismissing things out of hand. 
I'm adding Elm to an existing Rails/React app via Webpack. This is turning out to be smooth as butter thanks to https://github.com/rails/webpacker/ 🙂 Also I'm finding it really helpful that Elm and the existing React code can work together, without having to rewrite the React code to accommodate Elm.
Hey, Glad you got so far. Since you've ejected the app, you can add an Elm loader to Webpack, which enables you to import the Elm source files directly. I have a working project with such a setup [here](https://github.com/kevgathuku/docue-frontend) I've also written a post on that which might be helpful. https://kevgathuku.me/2017/05/24/how-to-introduce-elm-to-a-react-codebase/ Let me know if any of those help
Thanx for the kind words skater dad (i wanna be that one day). Know that I would never use your device to validate the transitions performance :} Find the oldest, crappiest android that you had forgotten you had, and test on it. Web apps on these devices we will never be able to achieve animations butteriness similar to the native platform. To remedy this, try to use the lowest level animation api possible, css-transitions. All animations you see on Dscova are built using css transitions, sometimes composed of multiple sub-transitions. They don't require any special structure, and have the simplest api of all animation apis within the web platform. That means we didn't use any library. For example, in the side (sliding) menu, if you check it's styles you'll see that it has `transform: translate3d(-100%,0,0)`. That puts it out of scene. And then, when we want it open, we just add this `opened` class, that declares `transform: translate3d(0%,0,0)` moving it inside the viewport. After that, reach for the artist inside you and come up with duration and easing-function values that give soul to your transitions.
Rock on! It's almost strange how small is the outputted bundle size.
I just finished an implementation of the "net" puzzle game: code is [here](http://github.com/juzley/elm-net), you can play it [here](https://juzley.github.io/elm-net/). This is the first thing I've written in Elm, so it was definitely a learning experience - any feedback on the code is appreciated!
I am trying to see how a server side elm code would look like: http://github.com/amitu/calm. Aim is to create fully iso-morphic app. Same code, as far as possible, on client and server side. It works. It handles async tasks (e.g. get time, get ajax). Server side rendering is possible. Am working on cleaning up the API and then will implement redis and pgsql commands. 
Ellie is compiled with webpack, elm-webpack-loader, and elm-css-webpack-loader. I have no complaints so far 🙂
I've been using [create-elm-app](https://github.com/halfzebra/create-elm-app). It's great if you don't have any special requirements. Zero configuration, dev server and an optimized production build are included.
This is a well known issue, see https://github.com/elm-lang/elm-compiler/issues/1362 For some reason, there's no bugfix release for 0.18 addressing this issue. 
Hey guys, So this is something I cooked up a little while ago. I was able to create a nice foundation for dropdown/popover-components which is pure, works with keyboard navigation, and doesn't make use of a backdrop while still allowing itself to be closed by a click outside of the component. I hope this can be of use to some of you. Furthermore I also made a more specific component based on elm-dropdown, namely [elm-select.](https://github.com/jschonenberg/elm-select) Elm-select can be used as a replacement for the default &lt;select&gt;-input. 
This is *exactly* what I want to do. Any progress?
Sure, here's a something I quickly put together: https://ellie-app.com/3tm2WSV9JTza1/0 **Features** * Pure, state gets passed in from the parent. * Use any HTML-element as toggle or drawer. * Choose for toggle on on click, hover, or focus. * Supports keyboard navigation (tab, esc). * No backdrop-element, direct interaction with other elements is possible. * Unassuming about visual style, bring your own CSS. 
I want to blink a graphic in time with the pulse of a simulated patient so i subscribe to a time msg (among other subscriptions) and all is good. When the pulse rate changes, what's the best thing to do? Re subscribe to all subscriptions, with a new time value for this one, or can I get to that single subscription and replace it? I suspect that "editing" the subscription is a no no. 
Thank you for kind remarks and enjoy:)
I've almost finished reworking of my blog from Ember to elm using the awesome style-elements library. https://github.com/kuzzmi/elm-simple-blog
I am writing a talk to be given Sunday night at the Ashdod (Israel) tech meetup
Hello, this is quite nice. Im working on a new elm program /project. I was wondering how I could create something like a table with weekdays and hours and put different items in it. ANd it would be possible to drag them into each other etc.. What approach can i use with this feature..
Looks very nice, and I agree the documentation is very good! Is there a reason you left `Model` as an exposed type alias though? If the intent is that users can only create a `Model` using `init` as mentioned in the `Model` docs, then an opaque type Model = Model { direction : Direction , offset : Int ... } seems like it would be more appropriate...
Examples have been added as well as the `Model` wrapped in an opaque type
This may be close to what you're looking for: https://github.com/styled-components/elm-styled/blob/master/Readme.md 
Look at his use of them in the Elm compiler. They are clearly useful when it comes to reducing boilerplate (Rust's traits perform a similar role), and allowing one to be much more expresssive when it comes to working with types - simple examples are Eq and Ord, for which Elm has to resort to a hacky solution to resolve. I understand his hesitation in adding them in a living language - they do have their limitations and pain points, but don't interpret that as him not recognising that there is a problem when it comes to building nice, elegant abstractions in Elm. I would suggest you actually learn about what you are talking about before launching into crusades against them on Evan's behalf, and understand the design space available (modular implicits for example). Try out a little Haskell and help out on the compiler. Broaden your horizons is all I'm saying. :)
I've never used Sublime, but looking at that link you posted it appears that all the package gives you is syntax highlighting and snippets. Sublime is just a fancy text editor, and you can use it to write Elm even without the syntax highlighting. Are you needing instructions on how to compile your Elm and see it in the browser? Or were you struggling to get the syntax highlighting working for Elm?
Nice! Going to use this today as I was just about to build one :D.
Looks like the videos are not available anymore :(
Some were available in their split form this morning if someone searched in google for "Elm Europe 2017". They were tagged "Unlisted" but it seams that they went private. I don't know what's happening but it's a shame that they are not available. There were a few talks that I think would provide great value. I particularly enjoyed the ones by Evan, Richard, Matthew and Noah. 
Pros of OCaml/Reason (assuming you're talking of using bucklescript and tea): - A complete language, not a tiny subset of a proper language - Plugins to the compiler so you can even extend the language if you must - Super fast compiler - Can compile natively, not just to javascript Cons have been listed by others here already but I'll add some: - OCaml hasn't got a single standard library (?!) - The syntax is... awkward... reason doesn't fix all that I think - The ocaml community hasn't standardized on a build system - General lack of hype makes it hard to find people to talk to compared to elm
[Here is one way to do it.](https://ellie-app.com/3w7Q3jLPhFga1/0) You can also [rewrite it like this](https://ellie-app.com/3w7Q3jLPhFga1/1). [Here is an alternative way to write the `repr` function](https://ellie-app.com/3w7Q3jLPhFga1/2). Of course, [you can also generate an actual table.](https://ellie-app.com/3w7Q3jLPhFga1/3)
Here is yet another way to write the `repr` function, using [krisajenkins/formatting](http://package.elm-lang.org/packages/krisajenkins/formatting/latest) https://ellie-app.com/3w8hvbV7JSya1/0
You can do a simlilar thing with [elm-css](http://package.elm-lang.org/packages/rtfeldman/elm-css/latest) by sharing the classes using a union type. The actual CSS class names are autogenerated.
Got started on a version of Simplenote in Elm, destined to run on the web and in Electron. It's pretty basic at the moment though because I don't understand the original interactions that well and I'm taking a new approach. Since Simplenote communicates with Simperium for its data store over a WebSocket (could be HTTP instead) there are a few ways Elm has been making it much easier to reason about. 1. Algebraic data types: after some time figuring out and documenting the server protocol in nothing more than a data structure it's simple and clear to use. The original work was done in PureScript but the data types are simple enough to port into Elm. 2. Managed effects and the update method: since all interaction streams through the single update function it's easy to track. I have the backend connection as its own sub update function and it can pass messages up to the main app where all local information is stored. The Simperium part will live entirely in this sub-app.
Elm is the one case where I switch out of sublime and into Atom instead. As far as I know, there's no way to get a Great Elm experience in Sublime the way you have it in Atom or Visual Studio Code
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/sonnymi [On Maintainability: Gold Plating the Game of Life in Elm](http://np.reddit.com/r/programming/comments/6i6vwg/on_maintainability_gold_plating_the_game_of_life/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hi, is it possible to get values from a record based on a string defining the key? If I have: type alias Point = { x : Float , y : Float } p = Point 1 2 can I do somethink like this? key = "x" value = getValue p key And value should be 1
with my hotloading starter https://github.com/simonh1000/elm-hot-loading-starter
With webpack
Is there a way to not pass anything to an Elm HTML function? For example if I want to use a &lt;br/&gt;, can I avoid the square brackets? Instead of `br [] []` just `br`?
&gt; I could use a case, but I don't think it's elegant This is exactly how I would implement it. I would maybe use a different name and order of parameters like `fieldAsString: String -&gt; Model -&gt; String` (it is good practice to put the data structure last) but still, it's the most straight forward option you have. 
Thanks so much for the detailed response! Just wanted to respond quickly to your direct question about what I'm not getting from the Effects section of the guide. Part of what's not clear to me is how much or little I should be trying to do in each update pattern. For example, I'm using Phoenix's channels so I have patterns that are looking for data coming in from those channels. It feels like I should have one generic OnData Json.Encode.Value update pattern that knows that data has come in from a channel and needs to be decoded and then passed to a view. But I haven't been able to figure out how I would implement that -- it seems like I should be able to take in that data, which I believe will be topicString -&gt; channelString -&gt; jsonString, in a generic update pattern that which then adds a Msg that tells some other function which json decoder it should use for that piece of data. It's not clear to me if I'm supposed to be using Cmd Msg to accomplish that, or calling functions directly. Or maybe I'm missing something even more fundamental and so my whole mental model is off. 
What you describe is very much like a `Sub`. (see the [websockets example](https://guide.elm-lang.org/architecture/effects/web_sockets.html) ) In that case, you have two options. Either you decode the `Json.Encode.Value` to a `Msg` in the `subscriptions` part of the app OR you simply pass the `Value` to a `Msg` and decode it in that message handler. 
with `webpack-mix`. I'm using elm with laravel.
I just realized that [sheetify](https://github.com/stackcss/sheetify) does it too, but with the build tool. 
Adding tests for https://github.com/FidelisClayton/elm-spotify-mapper and I've created a repo to publish jobs related with Elm https://github.com/FidelisClayton/elm-jobs.
This is fantastic! Exactly what I needed to get a real look at Elm. 
[Added registration/login/logout pages](https://github.com/prikhi/bodyweight-client/commit/e0c1322af04447cbc7963aa3b1bb9750c0f827ba) to my [bodyweight workout logging app](https://github.com/prikhi/bodyweight-client). ([as well as to the backend](https://github.com/prikhi/bodyweight-server/commit/2cca629214c4bebd0575fb0146f32a22330fbde8)) Now I've got to start refactoring my API commands to actually send the Auth Token, and modify my backend to limit the CRUD operations to authorized users(owners of routines &amp; admins). Not sure if I'll finish that this week, but if I do, I'll probably move on to the actual logging page - a follow-along version that I can use while I workout, &amp; a version where I can just enter all the details of an already completed workout. Still a long way from the end, but inching closer to actually being usable :) 
Hey! This is what i did: div [class "advertisement"] [ node "script" [ attribute "async" "", src "//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" ] [] , ins [ class "adsbygoogle", attribute "data-ad-client" "ca-pub-XXXXXXXXXX", attribute "data-ad-slot" "XXXXXXXX", attribute "style" "display:inline-block;width:300px;height:250px" ] [] , node "script" [] [ text "(adsbygoogle = window.adsbygoogle || []).push({});" ] ] basically i just used [html to elm](https://mbylstra.github.io/html-to-elm/) on the async snippet that adsense gave me! it works just fine! But it is also not the "elm-way" of course!
How much use do you get out of TransitioningFrom? I haven't thought of adding something like that to my routing/pages. Also, I see you're using `=&gt;` to return tuples from update. That's cool if you prefer it. I like using the `!` operator in circumstances like that. Just thought I'd point it out in case you're not aware of it.
Rumor has it `!` will be removed in 0.19 so don't get too comfortable with it.
Really nice work. One thing to note with this approach (small outer container, large inner container) is that you can't truly have an unlimited number of items in your list, because browsers have limits on how tall and wide elements can be. [In chrome, it's about 33554400px](https://stackoverflow.com/questions/16637530/whats-the-maximum-pixel-value-of-css-width-and-height-properties). This might not apply for most people, but if you try to render 10,000,000 items with a line height of 20px, the list will get truncated. I've been experimenting with another approach that listens for mouse `wheel` events instead of `scroll` events. The upside of this approach is that you can truly render as many items as you want. The downside is that you don't get a real, native scroll bar, so you have to render your own. Edit: Also, it's **much** more efficient to `slice` an `Array` than to filter a `List` for items that have an index within a given range.
Thank you for your comment. I didn't know about the limit in size, but I couldn't find another approach. I thought about your approach but I didn't like having to render my own scroll bar. Is a slice in `Array` really much more efficient than a `List.drop` and `List.take`? I could change the package to accept `Array` instead of `List` but I'm not comfortable with forcing a user to convert his `List` to `Array` (I assume `List` are used in most cases)
What I am hoping is that data1.a and data2.a are still the same referentially (at least in the first example, where only b changes). I am sort of assuming this must be the case, or I would not see much point in Html.lazy, but I was wondering if there was a way to test this. What I actually have is a selector on one part of the screen controlling the contents of another part of the screen. If the user presses the down arrow, the context changes and the 'details' display is updated. Updating the details display is an expensive operation, and if the user holds the down arrow down, the context changes rapidly, during which time I don't want to update anything other than the context selector, and only update the details display on key up. I have to change my model to keep track of the context changes, but my hope was that if I did that in a portion of the model that was not passed to the details view, then the details view would be able to be lazy (until keyUp), speeding up the selector rendering during keyDown. I was just hoping to be lazy myself and somehow test whether this was going to work or not before doing the refactoring.
ah, Elm will use 'structural sharing' when updating values, so values you don't modify will still be the same allocated objects and Html.lazy will consider them equal. But this is an implementation detail and it's impossible to see this detail from inside Elm. The best way to test if Html.lazy is recomputing your elements is to add a `Debug.log` to your function. The side effect of outputting to the log will tell you if the function was called or not. 
You might want to throw a link to that tachyons library in your readme, for people who have no idea what it is :)
Tachyons is a great way to approach js in the modern "component" style of writing js.
Definitely benchmark this kind of stuff. Being clever with data structures often does not do as much as you'd like. For example, I tried to improve some code that was trying to be clever with arrays [as described here](https://twitter.com/czaplic/status/870097413494550529). The result is that DOM performance matters and the data structures were not very important.
Lol, this is totally my library! I'm glad to see it's getting discovered despite my lack of telling people about it. Please make issues of things you would like changed. 
I think he means implicit state transitions, like Angular's two way binding. Also the non-obvious state transitions where just by having a reference to an object they can mutate it. This leads to confusing code. Like mutating state in the view in React. Elm enforces immutability and pure functions which fixes these problems by limiting what code can ask for state to change. 
It would be helpful if you could create an minimal [Ellie sample](https://ellie-app.com/new) with your problem. Frequently the act of trying to extract the problem solves the problem. If the space you are referring to is the space between the `h1` and the `button` my guess is that it's a CSS issue (maybe some margin or padding went wrong). In [a minimal example](https://ellie-app.com/3zf9WxhcG3Ca1/0) there is a 0.67em (about 21px) space. Regarding the import issue, if you use `import Module exposing (..)` on two modules that expose the same function you need to disambiguate. You can disambiguate either using namespaces (the way you did it) or by [explicitly stating what function you want](https://ellie-app.com/3zf9WxhcG3Ca1/1). Alternatively, you can avoid `exposing (..)` and import only what you need avoiding these kind of problems. 
Tried compiling my code on Ellie but it couldn't find the `Svg` module
You need to add it to your dependencies. Click "ADD PACKAGE" on the right and search for `elm-lang/svg` 
Yep fair point! I think others have briefly said what tachyons is but to git it a more practical bent: it allows front end luddites like me to produce something that others might look at without averting there eyes saying "arrrrgghhh my eyes"! Or put even more simply I can now do front end stuff in public without being evicted for swearing too much. It really is that good.
Could you share your whole .elm file that you are trying to render? You can use https://ellie-app.com Edit: Reading into this again I see the problem is only for testing purposes. Your best option might be to test the elm stuff with [elm-test](https://github.com/elm-community/elm-test) and using enzyme shallow rendering to test any react component that might include your elm one.
&gt; There were a lot of packages where the last commit is more than 6 months ago (e.g. react-elm-components) That "package" is 16 lines of code showing how to embed Elm in a React Component. It is in no way indicative of the health of the entire Elm ecosystem. The Elm ecosystem is healthier than ever. People are creating awesome packages and are making the existing ones even more awesome. I publish the `elm-docset`for Dash and in generating the docset I get to see what happens to the package ecosystem. I haven't kept track of the numbers but from memory, it grows and grows. &gt; Maybe because with Redux/FlowTypes/Immutable.js some of the main advantages of elm can be used in modern JS now? Redux/FlowTypes/Immutable.js will never be able to give you the peace of mind that Elm gives you. They will never give you the refactoring experience and reliability that Elm gives you. They help and if one is stuck in JS land they are a good bet architecture wise but at the end of the day you are still programming in JS and it takes a large amount of discipline not to abuse it's nature and go for the quick hacks. &gt; I still want to give it a try May the Force be with you! 
&gt; There was a big push in Japan, where Meetups had 30 or more people. Now there are 5. This is sad. Do you have any insight one what happened? 
Slightly off topic but do you know of a good Dash alternative for Windows?
My experience Elm. I have been playing around with Elm for six months or so and recently started rewriting a content-management for technical documents (math, physics, ...) with an Elm front end and and Elixir backend. It will be version 3, where version 1 was Rails, and version 2 had a Ruby backend (Hanami, great framework) with an Angular 1 frontend. I couldn't be happier with the new configuration. The new frontend is MUCH faster, and I have MUCH MORE confidence in the code. I attended an Elm conference a few weeks ago in Paris and was impressed with recent developments, including a new package (style-elements) that I am using in place of good ole CSS. Particularly striking was the use of Elm in several large mission-critical production products, e.g., one that manages video submissions to broadcasters. 
It could be useful to extract a [SSCCE](http://sscce.org/) in some gist or repository that shows this. Maybe someone can take a look at the actual setup and output and provide more information about what interacting parts are causing your issue. 
If you stay in synchronous actions, you can assume that they are the same architecturally (`Html.beginnerProgram`). I don't know enough about async actions in Redux to comment on how that compares to the full Elm architecture. 
&gt; There were a lot of packages where the last commit is more than 6 months ago I understand your feeling, but this is not Javascript: once a package works, it continues working even after 6 months :-)
I'm currently at work so I can submit my test webpack config that's in my personal computer, but I extracted the config from my project into a new one, this is the PR that tries to add Elm: https://github.com/cloverinteractive/boilerplate/pull/1 My intention is to get some end to end coverage of Elm rendered in react. Will update the PR later in the day to include the webpack test config.
&gt; The slack is incredibly active with a large number of extremely helpful individuals. (if you're reading this, go there, it's where the community is!) This is very true, and very sad. It makes the community nearly invisible to outsiders, and nearly inaccessible to those of us who are members of the Elm Slack, but don't have time to hang out there continuously. There used to be lots of interesting discussions in /r/elm and in the Elm mailing group. Now, they are mostly dead. I'm sure there are equally interesting discussions going on in the Elm Slack, but when you only visit a couple of times per week, it is nearly impossible to find them, when there are no subject headings, often several simultaneous discussions on the same channel, and a random mix of technical discussion, beginner questions, and random chat everywhere. Slack is also not at all search friendly. When I visit, I usually despair just looking at the number of unread messages, click "mark as read", and move on. Slack is extremely nice when you have the chance to be there all the time, or if you just have a quick question. For anything else, it's terrible.
Awesome answer. Now I'm convinced ;)
1) Totally agree. This is too painful and I've brought up partial solutions (such as having automatic de/serialization for reifiable/"port-safe" types), but these are considered too low priority. 2) Yes, and I think almost no smaller alt-JS community can really ever do this. Many very hard things like charting will inevitably need to be done by wrapping existing solutions in a controlled, type-safe way. [Purescript-Echarts](https://github.com/slamdata/purescript-echarts) is my favorite example of this, providing a type-safe, row-typed DSL that makes sure only the correct properties are written to in each layer. If you want straight FFI though, you might consider Bucklescript/ReasonML instead. 3) I think this is inevitable with the smaller languages that are under active development, but I'd invite you to try out Purescript, Bucklescript/ReasonML, or F#. I personally switched to Purescript with the removal of signals, and I've been really happy since. By the way, there is a Tokyo meetup happening next month: https://twitter.com/tipo159/status/876998480161460224.
Those are some really good points - having a Slack channel actually hurts the public presence of the Elm community. It also loses knowledge over time or makes it hard to find. Maybe questions should be asked via stack overflow and the slack channel is simply used to point at each question.
Thanks, here it is https://ellie-app.com/3zf9WxhcG3Ca1/0
&gt; Redux/FlowTypes/Immutable.js will never be able to give you the peace of mind that Elm gives you. Regarding static types and immutable data specifically, in JS these are opt-in. If you pull in a new library it's unlikely that it will use these technologies. It might even use TypeScript instead of Flow, or SeamlessImmutable instead of Immutable.js, etc. In Elm, there is one type system that every package in the catalog adheres to. All data is immutable at the language level. Things are nice *by default*. So the average Elm package is typically pretty good, and most are excellent. Finally, [libraries cannot provide new inabilities](http://tagide.com/blog/research/constraints/).
I was thinking in doing the same thing, thanks!
Here's my latest [commit](https://github.com/cloverinteractive/boilerplate/pull/1/commits/ace897054b47fc15f29429ed1c863e8297a960f7) where I added a webpack config to build the tests, I'm running the test manually like this: ``` yarn mocha-webpack -- --webpack-config config/test.js --require babel-register --require spec/browser.js spec/client/canary-spec.jsx ``` I'm getting a pretty lengthy [output](https://pastebin.com/raw/fsV9Ljwx). This is my first time trying to run specs that have Elm embedded into React so both my webpack config and the test itself may be wrong, the development and production configs work though I can build and run in the browser but I can't get the specs to work.
[What you sent me has no problem.](http://i.imgur.com/TiMubai.png) 
Released a package for parsing CSV data to types ("Json.Decode for CSV") http://package.elm-lang.org/packages/ericgj/elm-csv-decode/latest. It's based on the structures used in Evan's `url-parser`, more or less. Comments welcome.
I didn't know about the faq site. Looks like a great resource. Thanks for sharing and for trying to improve it. 
&gt; I got the gut feeling that the ecosystem stopped to grow My gut feeling is that you are wrong, more does need to be done to talk about the size of the community http://simonh1000.github.io/2017/06/elm_europe/ And in the compile to js world, Elm clearly leads https://trends.google.com/trends/explore?date=2014-01-01%202017-06-27&amp;q=%2Fm%2F0ncc1sv,clojurescript,purescript
Have you seen [elm-spa-example](https://github.com/rtfeldman/elm-spa-example)? The approach there is quite OK. :) 
Oh, my bad. Thanks for the clarification. Thought it was another name for [Vanilla.js](http://vanilla-js.com).
Thanks. That explains it. Anyway to disable that feature? Or make the button not active?
Ok, now I see what happened. Because the display for the `button` is `inline-block`, the `svg` is put on the same line. It is the `svg`that dictates the height of the line and this is why you see the space between the `h1` and `button`. if you make the output area small enough, the `svg`will go on the next line and the `button` will jump up. :) This issue is masked by the fact that it looks like you have the wrong code in svg (looks like a bad copy&amp;paste from the time example). [Here is a fixed version.](https://ellie-app.com/3BnKLt9qqtpa1/2)
u/kwaleko I'm going to give an answer based on how I have personally used the two architectures and that will focus on the *results* instead of the *implementations*. Also, my usage of Redux is primarily mixed with a large React app - WordPress.com - you may have heard of it. The biggest change I make when working in Redux vs. Elm is the way I think about passing state. In React, most of our components that need more than simple data (strings, numbers, boolean, lists of simple data) are going to be `connect()`ed to the global Redux store. The global state can be thought of as the datastore of resources (and settings) and individual components can work and function in isolation from all others if they are given the proper resource ids because they load their data directly from Redux. This is with a combination of a plain-data component and a wrapped default. export const Profile = ( { name } ) =&gt; &lt;p&gt;{ name }&lt;/p&gt; export default connect( state =&gt; state.author )( Profile ) In Elm we're not dealing with the same kind of components. The app as a whole is one functional unit and we pass down the data through the chain of views. There is no intermediate form and no `connect()`. view model = profile model.author profile author = p [] [ text author.name ] In JavaScript I actively avoid passing objects (records) through React as props because they become opaque and there's no easy way to answer the question, "what is this object *supposed to be* and *where did it come from*," if we pass data *through* components. &lt;SomeNeatThing onClick={ this.props.onClick } /&gt; // huh? In Elm this isn't a concern because of the static typing and compiler. We immediately know the expected shape of the data because it lives in the type signatures; further, if we make a breaking change three levels up in the view hierarchy the compiler will immediately alert us of *why* it's broken and *where*. --- In Elm pretty much *everything* is taken care of. In JavaScript/Redux many questions are still open. We've iterated through various attempts at using immutable data libraries and they don't fit right. We've had multiple iterations of data-fetching systems and they are awkward. In almost every basic need Elm has just Gotten It Right. It takes about twenty `npm` dependencies and several config files to get started with React+Redux whereas it takes only one in Elm. Asynchronous data fetching is a big question in Redux. I have settled on a system directly inspired by Elm which I am very happy with and which makes the distinctions moot, but Redux itself provides no mechanism for this (beyond providing the basis for its middleware, which is very nice). --- In general Redux feels easier than TEA for many different tasks. It's global and dynamic. It doesn't require thought. If I add a UI component way down deep in the visual hierarchy I can do that without making any further changes to my code. In Elm I also have to make sure that I now pass down the necessary data for that view function through however many levels of view functions and models I have. That being said, where Elm is harder it is also safer. You will likely spend at least as much time debugging in a typical large Redux application as you would in just designing your app right the first time in Elm; much more time spend refactoring than in Elm. The tradeoffs in Elm over Redux are speed and simplicity and soundness - worthwhile in my opinion. --- This was pretty off-the-cuff so please feel free to AMA. I'd be happy to address specific questions.
I tried sinking the `keypress` event but it does not work as expected. [Here is the code.](https://ellie-app.com/3Bp8CHJQbvna1/0) The Enter keypress is sunk but Space still works. If I try to switch to `keyup` event, Space stops triggering the click but Enter starts triggering it again. :) 
u/dmsnell thank you... &gt; have you identified strong reasons why the backend and frontend should be written in the same language. as I am going to develop the application alone, I find it hard to do the same things (declaring types, doing validations) multiple times, one for the front end and one for backend, in addition code reuse, lets say I built a parser in a language used in backend and I want to use share it with the front end, I cannot do that if I am using different language, I would embrace the separating if I have two different team but this is not the case. &gt; what kind of application are you building I am planning to start with SPA and might upgrade to isomorphic application later on. &gt; what are your data needs? I am afraid I did not get what you meant &gt; what kind of interactivity are you expecting? I am not expecting that hight interactive and performance app, I just don t want it to crush. &gt;have you written any actual code yet? this is what makes me confused, I haven t really done a complete app yet, instead I did several small things ( database queries in Haskell - small app in ELM - tiny app in angularjs) all those was for learning purpose and I haven't really done that much. my main concern is to get things done and gain experience that lead be to build large scale and reliable application and doing it solo I want to do less possible effort which makes me look for one language for both, I might be wrong.
u/kwaleko I would recommend just starting in whatever is most familiar to you. If that's JavaScript but you don't like dynamic typing then it's still probably the best idea; check out Facebook's "flow" for type-checking JavaScript. Elm is an absolute delight for building web applications; it's not encouraged to be using it on the server. From what you are writing I think that the most valuable thing you can do is just get coding on your application. Could you miss out on some cool feature if you choose "the wrong" language? Yes. Might you have to write some duplicate code if you pick a different front-end and back-end language? Yes. Are these going to be the things that stand in the way of you accomplishing your goals? Doubtful. As you build more you will feel where the rough points come in and then you can respond as needed. If you stay diligent in designing your code responsibly then you can save headaches in your future no matter which languages you are working in today. Please feel free to hone in with more specific questions about Redux vs. TEA. According to what you wrote I don't think the differences would cause a very significant impact on your code right now.
My hero 
Can you recommend front-end example Elm code for accepting a search term from a form, sending it to a REST API, and displaying the list of returned JSON results? This would be in the spirit of "find all existing Todos whose title contains the substring 'foo'". The backend is responsible for finding all the matches and returning the matching objects.
A second opinion... While I agree that there are some nice benefits to be had from working with the same language on the front/back end, those are nothing compared to the benefits you will enjoy from building your app with Elm. Just for the refactoring alone... by the time you've implemented several features in your app you will most likely want to make some changes and doing that in React is a whole lot scarier than doing it in Elm. I would argue that this is even more beneficial if you're working alone, since there will be no one else to double check your code. If you have the option of building it with Elm, and you don't have any particular requirements such as substantial use of several outside libraries, you should choose Elm!
This is how I would do it. 
Congrats on your thesis. The graphics look great! Would it be difficult to turn it into a gitbook? It would be amazing to have it like that too. 
Thanks! It's written in Latex - do you know any easy way how to turn it into gitbook? I did a brief search and haven't find anything.
It took me approximately 3 months 2-3 days a week. As I'm not native speaker, I often struggled with expressing myself in proper and suitable way. Most of the figures are bitmaps cited from other sources. You can find their authors in bibliography and ask them. The Latex template was provided by my school.
~~Try tripple-backticks.~~ ~~Or~~ four space before each line. code (Edit; triple-backticks doesn't work, should have tried multiple lines in my test.)
You can try this: https://codedocean.wordpress.com/2014/02/05/converting-latex-to-markdown/
Guess I will answer my own question: It's in the FAQ. http://faq.elm-community.org/#what-does--mean
It's called the "rocket operator" :) You can also get it with the [rocket-update](http://package.elm-lang.org/packages/NoRedInk/rocket-update/1.0.0/Rocket#=&gt;) package. 
What is a good clean way to show users that an error has occurred? Let's say I'm fetching something from an API and an error occurs, how do I show an error message to the user? The only thing I could think of is putting a flag in the model like `wasError : Boolean` and then an if statement in the view which adds shows the message. But I don't really like that because if there are a lot of possible errors each with their own unique message then I will have a lot of variables in the model which doesn't seem very clean. Also somewhat related to this, how would I retry an HTTP request if it failed?
Yes, you are quite right... it's more like a single-backtick. It enters "Code" mode but doesn't handle linebreaks or indents, really sucks.
Thanks :) this makes a lot more sense now
[André Staltz](https://twitter.com/andrestaltz) did an excellent [talk](https://www.youtube.com/watch?v=1c6XiQsnh_U) and [blog post](https://staltz.com/unidirectional-user-interface-architectures.html) where he compares several Unidirectional User Interface Architectures including Redux' and Elm's.
Thanks
There are rumors that say that the rocket operator might find its way into the core with the next release. This might mean that we'll get to see it used more often. In theory it should be a performance penalty with the current compiler BUT, if this is identified in practice and backed by a benchmark, I think it will get optimized away. 
That would be terrific, both optimization and standardization. I know the fact that everyone can define her own in fix operators is exactly what allows the most useful ones to emerge, but obviously this flux can be frustrating and potentially time-consuming. So personally, I prefer to go easy on non-standard operators, even though they're hot as hell. 
awesome thanks, also I have been looking recently at [cyclejs](https://cycle.js.org), do you think it is somewhat close to `reflex` in Haskell
Awesome. Just subscribed! I am thinking of starting to live stream some of my code sessions. I am a much more novice programmer, but thought it would be enjoyable. I used twitch briefly about two years ago, and found the community pretty great for the most part. 
The compiled Javascript had a bug relating to the lambda created in fold. Observe that _v2 references f, which is altered during the loop: var _user$project$Main$fold = F3( function (n, f, _p0) { fold: while (true) { var _p1 = _p0; if (_elm_lang$core$Native_Utils.cmp(n, 0) &gt; 0) { var _v1 = n - 1, _v2 = function (x) { return f( _elm_lang$lazy$Lazy$force(x)); }, _v3 = _elm_lang$lazy$Lazy$force(_p1._1); n = _v1; f = _v2; _p0 = _v3; continue fold; } else { return f(_p1._0); } } }); You can pull that lambda out, with the original f explicitly passed to eliminate the error. I would make an issue on elm compiler github, as this is definitely a bug.
yeah it's been really great. already met a couple folks who were just browsing the programming streams and decided to watch, and then got to tell them about elm. if you do decide to try out streaming let folks know and we'll share your link!
Not quite as grandiose as a language spec but may be just as useful to you :) http://klaftertief.github.io/elm-search EDIT PS. there are a bunch of monad `sequence`s, but sometimes they go by other names. For instance in Maybe.Extra, `List (Maybe a) -&gt; Maybe (List a)` is called `combine`. But `traverse` is `traverse` there. Hence the beauty of elm-search....
I was just looking at the issue tracker, ind this bug seems to just be issue [#1287](https://github.com/elm-lang/elm-compiler/issues/1287). 
Presumably /u/raould means [this sequence](https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:sequence)... in which case the answer is, no, Elm doesn't have a mechanism for abstracting over monads, so you can't make a similar (generic) function.
Great job! [Here is how I would do it.](https://ellie-app.com/3CrNH9NBBXGa1/0)
Thanks. It's an acceptable solution even if it's one I don't like. In Rust, even when just doing a simple if else, I find myself wanting to use match because it's one line shorter. (I always use braces around if blocks in c-like languages whether or not they're necessary)
First of all: don't hit enter after every period. Secondly: there are lots of places where elm can't help you and you end up with having to crash hard. Write your own serializer and you'll quickly find out.
Aha, if you have time to write a quick simplified example, I'd appreciate it : ) Enlightening.
This is a perfect example! I'm comfortable saying the correct answer here is to have that case return `Json.Decode.fail` - so when it ultimately gets decoded, the `Result` will be an `Err`. This accurately models the reality that not all strings have valid mappings to our particular enumeration, and it does so in a way that involves no crashing. :)
Well, I think you are stretching the definition of crashing here. The coder didn't get a compiler error even though all information was present to make that possible and as a result the app enters a broken state. Close enough to be a big problem. 
I think it's pretty well accepted that crashing means the program terminated. That's what [Wikipedia says](https://en.m.wikipedia.org/wiki/Crash_\(computing\)): &gt; In computing, a crash (or system crash) occurs when a computer program, such as a software application or an operating system, stops functioning properly and exits. So maybe we're just operating on different understandings of what a crash is?
Sure, that's a nicer end user experience but it's still entering an invalid state. Do you crash at the point of the error when developing at least so you don't need to trace back to where the problem was?
Why would you be doing this? If you are processing external input, then you should use `Result`, as the input may be invalid. If you can "trust" the input, then you should probably wonder why do you have a string in the first place.
Using a result just stops some problems. It doesn't stop you at compile time from making the mistake that causes the problem of invalid parsing. Note that a toString from a union type can be trivially made that gives you a compile time error if you forget a case. But the parser can't be made. Why? The compiler has the list of the cases because otherwise it would not be able to give the compiler error in the toString case. It's just not available. That's why you need code generators for Elm. I think it's a pity but it's not a deal breaker when other solutions are worse than elm+code generator. 
Again, please be civil. A less hostile way to make the same point would be "The browser doesn't crash, so the Wikipedia definition appears to contradict your point." Adding "Always funny when people quote things that contradict their own position in an attempt to strengthen their position :P" is unkind and unnecessary. I think Wikipedia supports my point. It says "a computer program, such as a software application or an operating system" - and Elm programs are programs which happen to run inside browsers (also programs) which run inside operating systems (also programs). Operating systems can crash, browsers themselves can crash, and programs running in browsers can crash.
(Sorry, I wrote that when frustrated by my kids. I'll try to not let that influence me more.) But very rarely does even the whole elm program crash. Mostly it's just that event handling that blows up. So the user clicks something, the elm program tries to do something and crashes (I agree that this is a crash!) and that action doesn't work. The next time the user clicks something else the elm program does respond, so the entire program isn't gone. Only way you can agree with the definition is by saying that every event handler pathway is its own program. This is why I think we should include a lot of other states as "crash". If the program enters an invalid state when presented with valid data where all the information to prevent that state existed at compile time, but wasn't presented to the programmer... I think that violates the Elm motto of "no runtime exceptions" and it's certainly a waste in my opinion. A little bit of code generation can fix this, it's just a pity that Elm itself isn't powerful enough to handle it.
Again: sure, but as I've stated in this thread already: your point of invalid/malformed data is a straw man. It's not related to what I'm talking about. I'm talking about valid data that the programmer missed to handle, and that COULD be found at compile time. 
&gt; But the point I'm trying to make is that the compiler could have told me that I forgot to have some outputs. And I showed you a function that ensures the whole union type has a matching input string. No default case needed.
When you get a "crash" in elm, it doesn't take out the entire app does it? Just that event handler stack or whatever?
Hmm.. I've clearly misunderstood! I tried to use your suggestion, and I see how I'll get compilation errors if I miss a case of the union type, but how do I use this function? From what I can see you have to call it like type Foo = A | B [define fromString...] fromString A "A" but then I still need some function that chains all the different cases for Foo, which I can't do anyway, so you've just moved the problem to the call site and it's back to my original problem anyway... right?
It's either case **HAVE** or case**'VE**, but never case **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
In Haskell (idk about PureScript, but I'm pretty sure not Elm) you'd use that fancy guard syntax. example: {- imagine all those pipes are lined up under x, I didn't realize the post would lose the whitespace -} f x | x &gt; 1 = x + f (x - 1) | x &lt; 0 = f (ABS x) | otherwise = x It took me a really long time to warm up to this syntax, so I understand why it's not in Elm, but there's apparently a library for it :D http://package.elm-lang.org/packages/Fresheyeball/elm-guards/latest
Ok, I understand what you're asking now, but why would the compiler assume that you want to return all possible Enums from a given function, and fail if you don't? In the example you gave, you expect the compiler to fail with a message that says "Hey, you forgot to return B from one of your cases!". What if I don't ever want to return B from this given function?
&gt; but how do I use this function? As I said: "Now, you can use this function with a list of the `Type`s you want to check." &gt; it's back to my original problem anyway... right? Not really. Now all you need to maintain is a list of the values, which can be placed right where the definition of the type is. But now you WILL get compilation errors if you add a new value to the type, so you are more likely to remember to update the list. I know, it doesn't really solve your "problem". I never said it could be solved. I'm just trying to make it more bearable to you.
I don't speak English as my first language either. In my experience native speakers often have lousy English. 
Great short talk. [The list around minute 10](https://youtu.be/OKQUmjW5wI4?t=573) is amazing. I think that it would be great for beginners to have it somewhere accompanied by Ellie examples. :) 
SECTION | CONTENT :--|:-- Title | What's Our Pattern For X? Length | 0:13:37 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
Oh. That's.... weird. Then it seems weird that debug.crash exists at all!
It shouldn't. But I should be able to tell the compiler that's what I want or be able to make this happen myself in some other way. A case block is just one way you could do this. There are many others. One would be to just expose the simple union type length. That with a compile time assert would also allow the programmer to make sure everything is in order. 
Yea, as I said: you need code generators with Elm to make it ok. Just being able to do a compile time assert that the length of your proposed list and the length of the union type is the same would actually solve all the problems. 
It's not very unique to Elm, and in my opinion it's not as nice as Reagent under ClojureScript. 
That all the cases of a union type are represented in the output. Just like the case statement gives you a compiler error if you don't cover all the cases of the union type in the input to the function, it'd be nice to be able to check that the mirror function gives a compiler error if you don't have enough cases. There are many ways to solve this. A simple thing would be to set up a dict from the union type value to the string and compile time assert that the dict has the same amount of keys as the union type is long. Would solve all problems, produce much nicer decoder/encoder code (because they can be generic functions over a dict), AND the only thing you need from the compiler is - compile time assert - access to the size of a union type at compile time - access to the size of the statically defined dict at compile time The compiler already has all this data.
Most developers we are "selling" to are using JavaScript, not ClojureScript. From their perspective it is new! Reagent seems to have the trappings of react components, specifically local state and the ability to call a JS functions like `setTimeout`. Let's just say that's not very Elm-like! Is there something specific that Reagent does well that Elm could learn from?
The DOM representation for one. You don't need to specify empty lists for no attributes for example. It's a little thing but it really adds up!
I think you're right. Coming from Django templates, to React and then to Elm, it has been been an improvement at each step. Though the jump from templates to JSX is pretty huge. It has taken me a while to get used to using `text ""` as a placeholder for 'nothing' but I'm getting there.
To be totally fair, you dont haveto use jsx, you can write your view as normal functions too. Hyperscript is the term iirc (or is it?). JSX is just a little bonus. I like elm, but i dont think this is any way a selling point (atleast for me). Im sure it would be doable to have jsx-like syntax in elm too, since its all functions in the end. Its functions all the way down.
Nice writeup. Looks like you had some copy-paste problems in guidelines 8 and 9 though (code examples with multiple definitions/uses instead of one for each type). Also ctrl + F "Elm all" at the end should be "Elm app".
Very small indeed. Anything else?
Love it. Good talk.
I assume that works because clojure functions can take a variable number of arguments. We can't do that in Elm due to implicit currying (and static types), and on balance I think it's a good trade.
You can always define `nothing = Html.text ""` and go from there!
Agreed that this is undersold, I love writing my views in pure Elm. I would be careful when comparing it with existing methods though. JSX, for example, is not a new language but syntactic sugar for JS. As such it gives you the same benefits: using plain ole JS such as if expressions, mapping over lists, variables, etc. I think the awesomeness of Elm can be expressed without dragging other frameworks into it.
&gt; Am I the only one who is this impressed? Nope. I'm in the process of learning Elixir &amp; Phoenix and looking at the templating engine of Phoenix all I could think of is "this is silly". `elm-html` spoiled me. :) 
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](https://s-media-cache-ak0.pinimg.com/originals/ea/38/34/ea38349e9487f76fc8bb6b14f819bb24.jpg)
Plain React is like `React.createElement('div', null, 'Hello');` Hyperscript is like `h('div', {}, 'hello')` And there are hyperscript helpers, like `div('hello')` 
You could have overloading with one or two arguments. It's not a big deal. In fact that's what reagent does, not taking variable arguments. 
The attributes look very different from the body of the tag visually: [a ^{:href "/"} "link text"}] And you don't need to write "text" all over the place. 
Ok. Fair enough. Any things you find annoying about HTMLs or XMLs syntax?
Like you: everything :P
That makes the elm syntax a better deal then, right? In comparison I mean. 
Sure. 
So how can we talk about something in elm being annoying when the situation that it provides and alternative for is more annoying :) ?
Yes! Spot on! 
Because we aren't ignorant?
I really like templating languages like pug, it makes me feel like my code is written more modular and it's easier to see the whole design. I understand why elm needs to have the HTML embedded within it's code, but I feel that is also a con as much ad it is a benefit.
Nicely done. Wondering about the use of Down-Arrow though, but maybe I'm not good enough to get to that part. (Record score; 5100)
&gt; without dragging other frameworks into it Sure, that's always a good suggestion. I was just trying to say that, when I used JSX a few years ago, an if-expression and loops had to be their own components with a lot of ceremony.
Personally, I like the claim to fame of knowing most of the ways to crash Elm's runtime. But it's not because I want to be known as that person, but rather the fact that there is _so few ways that you could name them one by one_ is amazing. A lot of people come to Elm and don't fully understand what "no runtime exceptions" means. It's a very unique approach to software design -- one that even languages like Haskell don't follow. And for what Elm tries to do, it works! It really does. Now there is only two domains of errors that the user has to care about: compiler errors and logical errors. I consider this streamlining of cognitive load to be really really important to the Elm experience. My advice to anyone skeptical about this, come talk to us on the Elm Slack. I can guarantee that any problem you run into modelling problems will be resolvable. In fact, I gave a talk on [exactly](https://www.youtube.com/watch?v=OgH3pPXXSkY) this at Elm Europe! P.S, depending on how you count, there's definitely more than 6, but there is only 6 that I see people "commonly" run into, where "commonly" is once a month. And that's wonderful!
SECTION | CONTENT :--|:-- Title | Elm Europe 2017 - Noah Hall - How to unblock yourself with elm Length | 0:16:39 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
Having tried both Elm and Miso (an older version), I think Haskellers will prefer Miso since you get all the benefits of Haskell's more powerful type system and sharing code between back- and front-end. The pre-rendering part is also quite nice if your need to care about SEO. Miso does implement many of the performance-sensitive pieces directly in JS. However, Elm will almost certainly generate superior JS in every case. 
&gt; A lot of people come to Elm and don't fully understand what "no runtime exceptions" means. It's a very unique approach to software design -- one that even languages like Haskell don't follow. Yeh, basically "no runtime exceptions" somehow undersells things, because Elm is mostly compared to JS. _Everyone_ is condescending to JS, even JSers themselves. But... This is of course an equally valid comparison to pretty much every language. The goal is no crashes! Ever! This is genuinely new. Genuinely exciting. And therefore often, genuinely difficult to get into people's skulls : )
Cool to see it. While I am quite happy with Elm I am very excited that lots of people are trying out different ways to do functional programming on the frontend. I think there is still a lot to learn on how to best do this. 
From https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa &gt; Fair warning: This is not a gentle introduction to Elm. I built this to be something I'd like to maintain, and did not hold back. This is how I'd build this application with the full power of Elm at my fingertips. &gt; &gt; If you're looking for a less drink-from-the-firehose introduction to Elm, I can recommend a book, a video tutorial, and of course the Official Guide. The links to those are in the article. ``` type Username = Username String ``` This is about encapsulating the String type. This protects any random String value to be used as Username or vice versa. As a general advice on your question. The functional programming style makes for very declarative code. So I'd say read the code function by function. When you see another function being called, just assume for a second it just does what is says it does. Once you've figured out the exact purpose of the current function you can move on to the next.
Nice work!! Great work putting all together both the commented and uncommented code files. Really easy to follow and understand. :D
&gt; type Username = Username String This is about encapsulating the String type. This protects any random String value to be used as Username or vice versa. To expand a tiny bit on that, you might see this called a `newtype` in other places. Compare these two possibilities: authenticate : String -&gt; String -&gt; Bool And type Username = Username String type Password = Password String authenticate : Username -&gt; Password -&gt; Bool In the second case, you can't accidentally call the `authenticate` function with username and password swapped.
How long have you been working with elm? That example is generally not the place to start(though it is a fantastic resource once you grow beyond a certain size). I can give you more resources if you can say what level you're at. Also, you don't need to struggle alone! Hop into the #beginners or #help channel on the elm slack. It's full of positive, helpful people that are happy to answer questions. 
JSX-like syntax in Elm is elmx: https://github.com/pzavolinsky/elmx
Working on a budgeting app I've wanted to build for myself. I've tried building it multiple times earlier in different technology but always got confused when working with the complicated data structures. Now when using Elm I've never really felt stuck, and I'm not afraid to refactor anything complicated. 🙌
I posted this in another thread, but... If you want to get away from "String Typing", I see people doing things like: type Username = Username String What's this do/mean? How does it work?
OK I had this the other day. Npm is moronic and tries to install to global directories as your local user even if you sudo. Follow the instructions to get npm's global install directory pointed at a folder in your home.
this solved my current problem thanks a lot !! 
thanks for your advice! I will follow it.
Totally forgot I posted that link - glad it helped you out :)
I'm working on my 2D Tron lightbike-esque game `bike-wars`. The twist here is that the bikes explode upon impact and can punch holes in the trails. Also later, there's going to be guns to do the same. And to that effect, just yesterday I finally managed to get the trail breaking work as I want it! This means I am now officially ready to get working on the weaponry, which is great. Zoomed-in GIF highlighting the trail breaking: https://goo.gl/photos/RPFsepidbBBHm8xm7 The repository: https://github.com/ohanhi/bike-wars
Thanks for the example ! I could easily understand.
It does two things: * `type Username` tells the compiler that you can now use a type called `Username` in type annotations * `= Username String` says that the only possible *value of that type* is also called `Username` and it needs to hold a string within it. You would then use it like so: sayHello : Username -&gt; String sayHello (Username name) = -- here we deconstruct the type "Hello, " ++ name -- now we can use the String value within The reason why you might want to do this are again two-fold: * Better communication: The type annotation `Username -&gt; PhotoUrl -&gt; Html msg` communicates much more than `String -&gt; String -&gt; Html msg`. This we could also get by simply using a type alias. * More type safety: You can't pass in any old String anymore, it has to be constructed a `Username`. This becomes important when you have several string or integer parameters, for example. This benefit we would *not* get with a type alias, because it literally is just an alias: any `String` also passes for a `Password`, if we do `type alias Password = String` 
&gt; # I've been working with elm for a month. I made one web app with elm.. without login part ... for the back-end server, Flask was used because I needed to use TensorFlow. About my level... I can say I'm a beginner of web and elm... I definitely join #beginners and #help channel on the elm slack! Thank you. 
Are there any resources around where we can see what sort of stuff is planned for 0.19?
 type Username = Username String type Password = Password String authenticate : Username -&gt; Password -&gt; Bool FTFY :) 
Thanks for hint. Trying it out now. What a mess with npm -- # source: https://gist.github.com/isaacs/579814 echo 'export PATH=$HOME/local/bin:$PATH' &gt;&gt; ~/.bashrc . ~/.bashrc mkdir ~/local mkdir ~/node-latest-install cd ~/node-latest-install curl http://nodejs.org/dist/node-latest.tar.gz | tar xz --strip-components=1 ./configure --prefix=~/local make install # ok, fine, this step probably takes more than 30 seconds... curl https://www.npmjs.org/install.sh | sh 
you should be able to do [this](https://docs.npmjs.com/getting-started/fixing-npm-permissions) using option 2
Interesting. Do you have a public repository for it?
Thanks; this helps. 
ooops!
I just fixed the example, thanks /u/jediknight !
Just as a note: After installing node/npm, with the above option, I could install elm without sudo on a normal user account. The folders are a bit strange - but, oh well. I guess I have to add some directories to the path somehow. Is there any better installation method in sight? Normally, these things are a reason not to choose with the software --
Thanks. Options 1 worked fine, though.
Option 1 has the potential to break your entire system and should never be run. Whoever is managing npm's needs to smarten the fuck up.
&gt; FTFY thanks ! 
Being side-effect-free is an intentional feature of Elm rather than a lack of one. The remainder of the web platform will be brought in over time but until then you'll need to use ports to access APIs that are currently only available in JavaScript. See also: https://github.com/elm-lang/projects/blob/master/roadmap.md#where-is-the-localstorage-package
So is there a minimal example of updating various panes of a Bootstrap.Tab control - that would require finding out the active tab after a click on the tab and then updating the items.item.pane content. Just not sure how that's done - there seem to be a couple of opaque types : State and Item and Pane! How do I "get at" these? thanks again. I can display the activeTab `State { activeTab = Just "Inspection", visibility = Showing }` but I can't get the value of activeTab. And similarly, Pane is opaque , so how do I update it in a view? thanks very much - the help is appreciated. 
You still have double colon (`::`) in the type signature of `authenticate`. ;) It betrays your Haskell background. :) 
Elm has effects but they are controlled. There is a whole section on Effects in [The Guide](https://guide.elm-lang.org/architecture/effects/). Once the browser platform implementation has a solid and complete implementation, Elm will move to other platforms like the server. It is then when native support for the few missing pieces will be added (File IO). Long story short, you can use Elm **now** to implement complex frontends and you will be able to use it to implement backends and console apps in a few years. 
Starting to prepare an Elm workshop for jscraftcamp.org in Munich. Any suggestions on what kind of content makes sense for one or two hours?
Should be acceptable now, thanks again!
Yes it is. One is glad to be of service. 
Nope, don't feel like opening it up until I have a proper Readme and stuff and mostly want to code for the time being 😄
Understandable. Happy hacking! ;)
My limited understanding of Purescript is that it's still very unstable (breaking changes etc.), there are lots of alternatives such as F#/Fable, Bucklescript and Reason that may be a better alternative if you want stability. Don't know if that solves your problem though. Why not GHCJS? That way you only have two languages to keep track of. 
Remember that time when C compilers would compile anything without complaining regardless if it was syntactically correct or not? :)
Note that there's nothing stopping you from using Elm on the server, you will just have to slash your way through the lack of server-side modules (as has been said, File IO etc.), using ports (or native modules -- discouraged).
The whole point of elm is to have managed side effects. 
I know this. I've been toying last week with the idea of implementing a REST Server in Elm starting from Noah's experiment. I have implemented toy websocket server in Elm using ports few months ago. There is a huge potential to create an amazing. smooth experience through a combo of blessed structure and conventions. 
&gt; I'm just feeling the pain a little bit in the JS world after deserializing the JSON coming through the Ports; it's very easy to mess things up and there's a lot of trial-and-error-at-runtime to contend with. Avoid processing stuff on the JS side. Keep it to a bare minimum. For example, in the case of localstorage, the JS code should only store/load the data. If you need extra processing, do it in Elm and serialize the processed entities. Think of ports as some sort of LowLevel library and put some kind of adapter in front of that low level library that does all the needed processing, offering a better API. 
Thanks! Actually this is what I have done and it's still pretty painful doing JS even for this minimal bit, so I'm looking to alleviate that.
So GHCJS results in a rather large lump of JS, I think due to the impedance between lazy and strict evaluation. Which is part of the reason I went for Elm in the first place.
I have been using Typescript's user-defined type guards to ensure the correct format of all IO (localStorage, some API calls, etc). 
Cool! How about using svg for crispy details?
https://sanctuary.js.org/
There is a `index.js` file that has the port logic to store the user in the `localStorage.session`it has 11 lines of code and I haven touch it since the inception of the project. While I agree that in principle even this insignificant amount could go, I find it very manageable. Maybe some day we will get some kind of official `localstorage` support or some official header manipulation. I can wait. If you can't wait, you can venture into the land of unsupported libraries and install one of the unofficial `localstorage` packages using `elm-github-install`. 
Do you have more info regarding the browser platform implementation as well as the general future direction of the language? I'm new around here. 
The function `koch` is overly complicated. See [my version](https://gist.github.com/anonymous/0984648f1ff18c9c18204e6cde07df5b). Could use some cleanup, like operators instead of add, mul, sub functions, but you can probably see my main points. When doing geometry, always use vectors. I don't remember when I last had to use trigonometric functions. You can use them on paper just fine, but make a cosine a dot product in code. That gives you cleaner, more numerically stable and faster code.
If you are worried about JSON.stringify and parse in js, you could do what the elm-spa-example does to avoid them. Pass back and forth the json string and do all encoding/decoding in elm, js is just responsible for localstorage set/get.
That looks so much better, thanks!
Good idea, i'll give it a try
Take a look at [the projects page](https://github.com/elm-lang/projects) and especially watch the [Code is the easy part video](https://www.youtube.com/watch?v=DSjbTC-hvqQ). One other interesting bit about the future years is in [this comment](https://github.com/WebAssembly/gc/pull/1#discussion_r111501121). ;) 
Wonderful, thank you for the response!
I maintain [a list of projects](https://github.com/elm-lang/projects/blob/master/README.md) that I think are nicely scoped ways to participate in the Elm community more. They are structured to allow folks to make a great deal of progress independently, no need to block on other community members until quite far along! Anyway, I just added an entry for this data structure website idea and wanted to share!
Thank you both! I needed exactly this!
I recently came across this https://visualgo.net/en which goings some of the way, but doesn't offer comparisons
Ooh the demo looks effective. Can't wait to try this out. 
my latest project idea... a book for kids and parents - about writing small video games. kids learn to write up declaritive type definitions, parents write the logic : )
I was quite confused by the name, but the gif explained it perfectly! I guess it's quite an abstract thing to name really :) Very cool, I'll look for an opportunity to use it soon!
I just started kicking myself as this is really obvious! However I then realised that the reason I'm having to do at least some of the work in JS is that I need to pick out related (parent/child) bits of a graph whose data might be too large for me to keep in memory. I'll have another look to see if I can bend it into a shape where the JS really does no work at all though as I've learnt a lot since embarking on that route. Thank you very much for your insight; it may well save me from over-complicating my build process! Edit: the eagle-eyed might highlight that LocalStorage is all in-memory, making my concerns moot: I just picked the easiest API, I'll be moving to SQL soon :)
This looks really good, nice work!
Looks great.
elm-tag-input should be a better name for it. Nice job though!!!! :)
Enjoying the process of refactoring my calendar widget. I remain astonished at how comfortable and easy it is to refactor in Elm. Also enjoying the exploits of https://medium.com/@billperegoy, who shows a delightful example of refactoring.
a link to github or ellie would do a fair bit of good here. I would keep the tasks in a list or Dict for updating and maintaining and only sort them out when in the view function. Just a couple of filters and sorts when and only when you render them.
The Elm compiler is written in Haskell, which, as far as I know, doesn't have any way of running in the browser. You would need to rewrite the compiler to Elm/JavaScript to have it run in the browser.
[Luke managed to get the compiler to work in the browser](https://www.youtube.com/watch?v=GwmVELtQnOI).
If you need the data that those tasks produce, you first need to execute them. The result you get back from the execution can be saved into the model and then, turned into a html table in the view. 
You could run the REPL on the dev server (elm-reactor) and pass strings back and forth. No need to run the compiler in the browser.
&gt; I want it to work offline so it would load everything it needs in the very beginning and it wouldn't rely on the server for evaluating Elm expression
As you can tell, I didn't read a single word from the post :)
It is not using, it is defining :) type Msg = SwitchTo FontSize Defines a new type called Msg with a single type constructor called SwitchTo which has 1 param. It also creates (automatically) a new function for each type constructor SwitchTo : FontSize -&gt; Msg https://guide.elm-lang.org/types/union_types.html
SwitchTo is a data constructor for the Msg type: type Msg = SwitchTo FontSize It basically works like a function which, given some arguments, returns an instance of a type. In this case, the SwitchTo constructor expects a type of FontSize, which has three data constructors: Large, Small and Medium. Hence, `SwitchTo Medium`.
Got it. Thanks.
Perfect. Thanks.
&gt; k channel actually hurts the public presence of the Elm community Absolutely agree.
Just to clarify:`Task` is your data type, not an elm [Task](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Task) ? I agree looking at some (even incomplete or broken) code would help.
Webpack brings its own set of issues. It can be a great help, especially if you integrate the project with other technologies like SASS and/or UglifyJS but it can also give you headaches. I don't know what "spa demo" you are referring to. The [elm-spa-example](https://github.com/rtfeldman/elm-spa-example) is not using webpack (and that was intentional). &gt; everything compiles and runs yet the screen is blank Usually you can see the issue in the browser's developer console as an error. Attempting to reproduce the error in a small example repository usually solves it by revealing to you what you might have done wrong. &gt; Is webpack the preferred way for deployments and resource management as opposed to just sticking with elm reactor ? Not really. Some people prefer makefiles, some prefer gulp. I'm using brunch in a project I'm working on right now. 
Thanks, I had two problems. One was related to using the wrong version of web pack and the other was a case mismatch. I will take a look at gulp and brunch as well.
I've been using this starter version that includes webpack and hotloading. So far I had no problems https://github.com/simonh1000/elm-webpack-starter
Cool! I did some experimenting with the Dragon Curve fractal with Elm and had a lot of fun (using SVG). [https://github.com/tmountain/dragon-curve](https://github.com/tmountain/dragon-curve)
Great talk. There is a puzzling statement about the [overhead of the elm runtime when embedding multiple apps](https://youtu.be/28aJOb1A34o?t=1423). To my knowledge, if you compile multiple modules into the same js file, you only get one runtime. 
Video linked by /u/jediknight: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [GOTO 2017 • Introducing Elm to a JavaScript App • Richard Feldman](https://youtu.be/28aJOb1A34o?t=1423)|GOTO Conferences|2017-07-07|0:32:58|25+ (100%)|900 &gt; This presentation was recorded at GOTO Chicago 2017... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/jediknight ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=djxtmvp\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
/u/BraveNewCurrency I'd be more than willing to assist in this effort, my friend. I love this language and this community so projects like this that could adoption even the tiniest bit easier would be awesome. hmu and let's start a fork of guide.elm
Not an "elm expert" in any sense of the phrase... but what he meant I think was.. it launches "n" elm runtimes with "n" elm apps in the page.
Sure. I'd be happy to take a stab at writing the missing section, but I wouldn't have time to maintain anything.
This is very interesting! So is the idea to learn and evaluate data structures that exist in the Elm ecosystem? Or is it more general than that?
From my experience among those you named PureScript seems the most mature right now. Breaking changes do come once every 6 months or something but they're usually quite minor.
There's a [`Cmd.batch`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Platform-Cmd#batch) would that work? I use the `(!)` function myself.
Relevant discussion on the mailing list awhile back: https://groups.google.com/forum/#!searchin/elm-dev/cmd$20task$20random%7Csort:relevance/elm-dev/MEBzD3f7Bq8/ojpRsjObDQAJ
As I understand it, `Cmd.batch` takes all of the commands that you have defined and runs them concurrently. There's no notion of the result of one command being fed forward into the next, and so doesn't quite fit this usecase.
Ahh, misunderstood the question. Sorry.
It would be specifically for Elm, and it would grow as the ecosystem grows. So if there are fancier `MinHeap` implementations or something, they would get included. But the overall goal is limited to "How can an Elm programmer find the right data structure for their problem?" which may involve learning more about data structures. The goal is not to teach data structures in a generic way (e.g. no particular problem needs solving, no data structures with mutation, no support for other languages, etc.)
http://eeue56.github.io/json-to-elm/
No worries :)
It doesn't make alot of sense to chain commands. Tasks yes, but commands not so much. 
It is not possible to create an andThen function for Cmd that always works the way you'd expect, because a Cmd doesn't provide any guarantees about how many Msg events a single Cmd will trigger. It could be zero or it could be a thousand every minute until the program is shut down. Task.andThen exists because a single Task is guaranteed to only ever produce one Msg event, so it makes sense to talk about one Task depending on "the result" of another.
I don't know much about Elm on both, but you can always 'stupidly' compile the code to JS, and push it online (the only requirement is to support HTML file). If someone knows a smart way, I'm interested too!
Elm compiles to JavaScript (maybe wasm in the future). The same way you would deploy any other javascript app. If your app is client side, then any file server or cdn will work to serve the static files to the browser. If your app also runs server-side, you'll probably want a node.js instance or alike.
What exactly is a Msg event? Could you point me to somewhere I can learn about what these are? My understanding was that there wasn't much difference between what can be done with a task or a command (conceptually). Given that though, why couldn't it behave, say, like the list `andThen` and just apply itself to every Msg event?
By "Msg event" I mean the events that trigger a call to your `update` function with a new value of your application-specific message type (conventionally named `Msg`): https://guide.elm-lang.org/architecture/ This is how both tasks and commands ultimately communicate back into your app. Tasks and commands are similar in this way, with the crucial difference that tasks are guaranteed to have exactly one result. Maybe it would theoretically be possible for Elm to implement `andThen` in the way you describe for `Cmd`, I don't know. I doubt it will ever happen, though, as it would then be very easy to create complex chains of command-producing functions whose logic occurs outside the confines of the update function. I expect this would make applications much more difficult to understand and debug. With Tasks, the `andThen` logic also occurs outside of the update function but understanding the system is much simpler because of the one-Task-one-result guarantee.
Huh that's really interesting thanks. Out of curiousity are there any examples of when commands might return more than once, I'm thinking something like a progress bar?
Hi friend! You're probably talking about what happens when Elm compiles your code. First you'll need the Elm language tools. [This page on guide.elm-lang.org](https://guide.elm-lang.org/install.html) explains more. After you write some Elm code (the guide will show you how) you will compile it with something like: elm-make MyElmFile.elm By default, it will create `index.html`, which you can open in your browser. If you need to name it, use the `--output` flag: elm-make --output someOtherThing.html MyElmFile.elm If you're just getting started it might also be helpful for you to check out the #beginners channel in Slack (see the link in the sidebar to get an invitation.)
Hmm...all the examples of this that I thought were done with commands are actually done with subscriptions instead. In theory a command may produce many results, but in practice it looks like subscriptions are typically used for those situations. An example of a command that produces zero values is sending a message to a websocket: http://package.elm-lang.org/packages/elm-lang/websocket/1.0.2/WebSocket#send (Note that listening to messages on a websocket is handled with a subscription.) 
I have watched it twice in a row while drinking beer and refactoring an app - brilliant : )
Another ask, in Richard's talk he composes types (linked nearby) which I have never seen before. E.g. onInput (FeedMsg &lt;&lt; Password) That end up as: FeedMsg Password String But again, I'd love a more verbose explanation. 
When you define a type in Elm you do so by defining constructors for that type. These constructors can be matched against in `case..of` blocks but they are also functions for *constructing* values of that type. `type Msg = UserName String | Password String` defines two constructors `UserName` and `Password` these constructors are functions that take a `String` as a parameter and produce a `Msg`.
This isn't the composition of types. `FeedMsg` and `Password` aren't types, they're 'data constructors' for their types. They are functions that are the only ways to produce values of that type. `(FeedMsg &lt;&lt; Password)` is the composition of functions, which makes more sense if you look at what types there functions are. Let's assume that `Password` is a constructor for a type called `LoginMsg`eg. `type LoginMsg = Password String` `Password` is a function that has the type `(String -&gt; LoginMsg)` And assume that `FeedMsg` is a constructor for a type called `Msg` eg. `type Msg = FeedMsg LoginMsg` `FeedMsg` is a function that has the type `(LoginMsg-&gt; Msg)` composing them together `(FeedMsg &lt;&lt; Password)` (you could also write it as `(\str -&gt; FeedMsg (Password str))`) you get a function that is of type `(String -&gt; Msg)` the intention of which is to contain a `LoginMsg` inside a `Msg`. 
 Http.send NewShortenedUrl (Http.get requestUrl decodeJson) Function `send` is expecting the 2nd argument to be: Http.Request String But it is: Http.Request JsonResponse The compiler is saying that it's inferring that the Http.get should be returning a `Http.Request String` instead of the `Http.Request JsonResponse` that it's returning. When you see an error like this you should ask yourself, 'what is the compiler using to infer these types?" You know that `(Http.get requestUrl decodeJson)` returns a `Http.Request JsonResponse` so why does the compiler want it to be a ``Http.Request String`? Let's look at the type of `Http.send : (Result Error a -&gt; msg) -&gt; Request a -&gt; Cmd msg` So `Http.send` expects that the `a` in `(Result Error a -&gt; msg)` will match the `a` in `Request a`, and the compiler has inferred that the `a` should be a `String`. Which means that `NewShortenedUrl` must have the type ` (Result Error String -&gt; Msg)` and if we look at it's definition we see that it does: `type Msg = NewShortenedUrl (Result Http.Error String)` The fix is simple. `type Msg = NewShortenedUrl (Result Http.Error JsonResponse)` 
That is an excellent explanation! Of course it's that simple. Really appreciate it
Thanks for taking the time in this. Your first explanation nailed it :)
Just as a note there's no reason why the pattern matches couldn't be different to the constructors, apart from how confusing that could make things!
But how do you go about nicely reloading all of the code in the big app that is being introduced to Elm one module at a time? Now I have a gulp watch that watches elm files and runs the `elm make` similar to what you have above, but I also have a `webpack watch` that watches all the rest. When `gulp watch` compiles Elm into a single JS bundle, only then the `webpack watch` is triggered (because the Elm output bundle is required somewhere in watched JS files). Not only it's noticeably slow (compared to using `webpack elm loader` - but this introduces code duplication in case of multiple Elm programs), but I have to run 2 independent watches (I wasn't able to combine them into one with nice output at least)...
If you are using both `webpack` and `gulp` you are doing something very wrong. Research the various elm-webpack-starter or elm-gulp-starter and figure out how to do everything with only one of them. 
I did. And it seems like a lot of people are having the similar problem to mine - there are multiple reports at the `elm-webpack-loader` GitHub page. The only advice I see repeating everywhere is to use `elm make A.elm B.elm --output bundle.js` Which is clearly not going the webpack way anyway. And `gulp` can be dropped, it's not the issue here - gulp and webpack are not mutually exclusive anyways as they can work together nicely.
This is an interesting read on combining (or not) various build tools: https://www.toptal.com/front-end/webpack-browserify-gulp-which-is-better. My problem remains though - without running `elm-make A.elm B.elm`, I can't seem to get rid of code duplication in case of multiple Elm programs. But webpack loaders are not working out as they bundle stuff as it's being requested. So, if I require A and B independently, the loaders will bundle up all the core stuff in both of the modules.
Formatted for readability: type alias Aufgabe = { aName : String , aBeschreibung : String , aDauer : Int , aTyp : String , aTag : Date.Day , aDeadl : Date.Date , aPrio : String , aStunden : Int , aMinuten : Int , aTermin: Date.Date , aMonth: Date.Month } You might have some data modeling problems here, but I don't want to go too much into them until I'm sure we're both on the same page. Could you say what problem you're trying to solve? We don't want to get an [XY Problem](http://www.perlmonks.org/?node=XY+Problem)! Also, we don't usually use hungarian notation in field names. Your code will probably read better if you remove that, unless you're really used to it. :)
It's not Hungarian notation if string and int have the same prefix. 
Can you turn one task into a row in the table?
You should probably use Haskell, OCaml or F# server side. 
I had this problem as well, I followed the advice in [this stack answer](https://stackoverflow.com/a/21171188) which worked for me. So basically from the terminal: $ sudo apt-get install nodejs-legacy 
Hey jessta, Thank you very much. I understood it now. The fix was indeed simple :D
That's exactly what the current in-browser REPL does. http://elmrepl.cuberoot.in 
Def a good way! I have a project setup right now that uses elm-webpack-loader, compiles everything into a nice statically deployable folder (index.html, js, css files) and just throws in onto S3. Works great! Like someone else mentioned it's just the same as any other JS project, with the exception of elm-webpack-loader to trigger the compilation.
I learned not to use generic types for data modelling: hiding state is not the same as reducing state.
I made this http://gitrank.mrkaspa.com/ to measure the progress of the programming languages in github
I have the same logic in my application, but the `Token` for me is not a (binary?) union type like yours. It carries just one tagged value. I check the auth status and if the authentication object is present I run the request, so your `listSources` shouldn't have the `case` statement in my opinion. If is not present just return `Cmd.none`. 
Thanks for your help! I wondered about this. So in the update function have the case statement that only calls the command if the token is valid? Is it possible (and desirable) to set the source list to a fail state in the other cases? I know that the API call would fail if I tried to make it, how can I manually set that?
1. [Convert your `Http.Request` to a `Task`](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http) 2. [Use `Task.andThen`](http://package.elm-lang.org/packages/elm-lang/core/latest/Task#andThen) Edit: Here's a convoluted example: https://ellie-app.com/3JYyt4R4NLna1/0 In an actual application, you would use the `Random` module to generate random numbers, but this will at least show you how to use `Task.andThen`
I'm sorry, I don't understand :(
Here's an example: https://ellie-app.com/3JYyt4R4NLna1/0
OK, I think I get it. If the getRandomInt request failed, that error would be passed into HandleGetRandomPostResponse? My HTTP requests are wrapped by the RemoteData package. How does that change the task stuff? I don't know a lot about tasks because: https://guide.elm-lang.org/error_handling/task.html
&gt; If the getRandomInt request failed, that error would be passed into HandleGetRandomPostResponse? Yes, exactly. It won't run `getPost` unless `getRandomInt` succeeds. &gt; My HTTP requests are wrapped by the RemoteData package. How does that change the task stuff? I haven't used RemoteData, but it looks like you'll want to use [`RemoteData.fromTask`](http://package.elm-lang.org/packages/krisajenkins/remotedata/4.3.0/RemoteData#fromTask) &gt; I don't know a lot about tasks because: https://guide.elm-lang.org/error_handling/task.html Are you familiar with Javascript Promises? It's the same concept. A task is basically an operation (usually asynchronous) that interacts with the outside world and might fail. Edit: Check out the Task documentation: http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Task
Wonderful! Thanks so much for your help!
&gt; Are you familiar with Javascript Promises? It's the same concept. A task is basically an operation (usually asynchronous) that interacts with the outside world and might fail. This is not true, but this is what I though at the beginning. The `Promise` and `Task` are different beasts: `Promise` encapsulates execution process, while `Tasks` are kind of command descriptions. Creating a task won't actually execute anything until you hand it to Elm's runtime. It makes a difference, example: a task describing random number request is always equal to other task describing random number request. You can create one or two of these, but that won't give you a random number. You can reuse same tasks and they will produce different results. On the other hand, a promise with remote response body cannot be reused to fetch another response.
The [elm-spa-example](https://github.com/rtfeldman/elm-spa-example) has a solid folder structure and could provide inspiration. 
I have been working through that one and the thing I'm not real fond of is that it has many files in the example were in the root. And then it only had one sub folder for "Players" I wasn't thinking of putting all commands or all updates etc in one updates.elm or one commands elm. To make sure we are referring to the same project, I'm referring to this one. https://github.com/sporto/elm-tutorial-app I was reading this article and he was separating to each to multiple folders. But I wasn't sure if this is the way to go either. https://becoming-functional.com/nine-guidelines-for-modular-elm-development-fe18d2f7885e 
1 - what I have is just a mapping function over the authentication data which is a Maybe and a `withDefault Cmd.none`. So the request might or not be executed and I don't need to explicitly check each time. 2 - I didn't understand " set the source list to a fail state", can you elaborate, please?
Sorry, I forgot that I hadn't provided the SourceList code. SourceList is a RemoteData object, so it's either `NotAsked`, `Loading`, `Success data`, or `Failure error`. If the user tries to list their sources, then I know that the request would fail when the token (also RemoteData) isn't `Success token`. In that case, it feels neater to be able to just immeditely set `SourceList` to `Failure "You are not logged in"` (or similar). I'm not sure about how to do this. I think I'm getting my head around how to achieve some of these things. I seem to very often reach for "how can I just return a Cmd Msg", which I know to be a bad idea. Finding the good solution is tricky at the moment :) Thanks for your help!
I would guess he was referring to https://github.com/rtfeldman/elm-spa-example
Another option to consider: http://blog.jenkster.com/2016/04/how-i-structure-elm-apps.html
Yes.
You can, but you shouldn't. JSON is for passing data, not to program in.
It would only be passing data. It would pass an image source, x, y positions. Not much more. I am hoping Elm would just be able to take that data and produce a webpage
&gt; Creating a task won't actually execute anything until you hand it to Elm's runtime Yes, Promises do execute upon definition (which is really silly IMO), but you can very easily make Promises act like tasks by wrapping their definition in a function. For example: const getPostsTask = () =&gt; fetch("/api/v1/posts.json") Other than that, Promises and Tasks are the same concept. They both execute asynchronous functions that interact with the outside world and potentially cause side effects. They both allow you to map failures and successes. They both allow you to chain operations. ## Mapping **ES6** getPostsTask() .then(posts =&gt; posts.length) .catch(err =&gt; err.message) **Elm** getPostsTask |&gt; Task.map (\posts -&gt; List.length posts) |&gt; Task.mapError (\err -&gt; err.message) ## Chaining **ES6** getPostsTask() .then(getOtherThing) .then(getOtherThing2) **Elm** getPostsTask |&gt; Task.andThen getOtherThing |&gt; Task.andThen getOtherThing2 
&gt; If I click the link to a new page, it would instead just pass more json with different information to create a different page You're describing a single page application with routing, and yes, you can do this in Elm.
It can, but why the (x,y) positions. Generally you leave the renderer to decide where to put things because you don't know what device it is being viewed on. 
Thanks I will look into this one. After looking at the rtfeldman example as well, it seems there are a few ways to "skin the cat" when it comes to project structure.
Yes. Both Richard and Kris are well known in the community, so neither is a crackpot off the wall untested solution. One may fit your mental model better than the other.
At the beginning you said the `Task` is like a function providing a `Promise`, with an example, but when you moved on to chaining, your one-to-one equivalents became again broken, because the way you chain promises actually executes them, while chained tasks stay "pure" and references are "transparent" . p = getPostsTask() .then(getOtherThing) .then(getOtherThing2) If this is supposed to be an kind-of equivalent of Tasks, it should be more like: p = () =&gt; fetch("/api/v1/posts.json") .then(getOtherThing) .then(getOtherThing2) Most of the time it's all a subtle difference, but once in a while it does make a difference :)
I was under the assumption that `getOtherThing` would be a function that takes the previous promise's result and returns another promise, just like `getPostsTask`: const getOtherThing = (foo) =&gt; getOtherThingPromise(foo) But anyways, you are definitely right: Tasks and Promises are not the same thing. Tasks are superior, IMO. I was just trying to give the OP an example of a similar concept.
Do you use regular URL's or hash-urls? (eg. domain.com/#/my-page instead of domain.com/my-page). If you don't have a hash in the url then make sure your server is set up to pipe all requests to your index.html file, otherwise the server will throw a 404 before Elm has a chance to do anything about it. 
@ElectricOrangeJuice is correct. Additionally, I commented a bit on the issue to help explain the issue and its source: https://github.com/evancz/url-parser/issues/35
Someone seems to be about to reinvent [free monads](http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html).
Last time I looked, they seemed like a rather painful workaround, but I guess they are better than binding to Idris via JS. EDIT: `type Fix = Fix (f (Fix f))` is not valid, as type constructors aren't really functions in Elm. More importantly, free monads do not solve my problem. My problem is that I want to be able to have different kinds of satellite data, or no satellite data at all. I would like to avoid writing boilerplate like functions that construct type variants. Currently the best option seems to be the snippet in my original post, or type Expression satellite = Lambda String Expression satellite | Call Expression Expression satellite ... 
&gt; I was under the assumption that getOtherThing would be a function that takes the previous promise's result and returns another promise That's correct. I was referring to the chaining itself, that once you start chaining, you have to actually create a promise and that, by itself, would launch execution process. But it is true what you said: knowing how promises work helps understanding tasks.
Do those concerns also apply to [`CSSStyleSheet.insertRule()`](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule) as /u/dustinfarris mentioned at the bottom of the original post and discussed with /u/gdotdesign in the [comments](https://www.reddit.com/r/elm/comments/5v9wg9/why_not_css/de0e8i0/?context=10000)? Or is it just an issue with e.g. glamor's [non-speedy mode](https://github.com/threepointone/glamor#speedy-mode)? &gt; speedy mode &gt; --- &gt; &gt; there are two methods by which the library adds styles to the document - &gt; &gt; * by appending css 'rules' to a browser backed stylesheet. This is really fast, but has the disadvantage of making the styles uneditable in the devtools sidebar. &gt; * by appending text nodes to a style tag. This is fairly slow, but doesn't have the editing drawback. &gt; &gt; as a compromise, we enable the former 'speedy' mode `NODE_ENV=production`, and disable it otherwise. You can manually toggle this with the `speedy()` function. &gt; &gt; characteristics &gt; --- &gt; &gt; while glamor shares most common attributes of other inline style / css-in-js systems, &gt; here are some key differences - &gt; &gt; * uses 'real' stylesheets, so you can use all css features. &gt; * rules can be used as data-attributes or classNames. &gt; * simulate pseudo-classes with the `simulate` helper. very useful, especially when combined when hot-loading and/or editing directly in devtools. &gt; * really fast, by way of deduping rules, and using [insertRule](https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule) in production.
[Nice explanation](https://github.com/evancz/url-parser/issues/35#issuecomment-315244485) from [john-kelly](https://github.com/john-kelly). I can confirm that evancz/url-parser works great on reload, it passes the parsed route to your program's `init` where you can deal with as expected. Both with webpack-dev-server and static hosting. Maybe it is worth to open an issue on [elm-reactor](https://github.com/elm-lang/elm-reactor). Otherwise, just use webpack with elm-loaded. It allows to build and bundle other js (if you use js libraries with ports), css (if you are not using an Elm css solution) and other static assets. 
Where did you get the API from? Its a nice work there buddy!
Hi Josh, co-author of elm-test here. It's a great feeling when someone else describes your library as "wonderful", thank you! Are you able to give more examples of how testing at different levels of abstraction was difficult? I wonder if you're not splitting up your code as well as you could, but that's just a hunch! I'd love to mull over some APIs or general suggestions that would make your testing experience even better.
Thanks for the response. I got in touch with folks on Elm Slack and they had the same response. I will try to use webpack for development and will serve Elm from behind Nginx anyway! Thanks. I was confused because the example from Navigation package has # and it works. On evancz/url-parser - the hash is gone, but that explains why it happens.
Thanks. That's awesome. I read it and it actually makes so much sense I feel dumb for not thinking about it in the first place.
I developed this small Elm app, using behance API. Got to admit refactoring is a pure joy in Elm! https://github.com/girishso/elm-behance Demo: http://elm-behance.surge.sh
That would be great! Both Richard and Evan had the same ask over on Twitter :) I have a more testing specific post in the works. I'd like to finish gathering my thoughts and get some more specific examples then I'd love to pair or get some feedback.
Following up on "Html msg", what does the "msg" represent in "Html msg"? The definition http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#Html shows: hello : Html msg hello = div [] [ text "Hello!" ] Is it "[] [ text "Hello!" ]"? Is it the argument passed to the Html constructor? 
I use it for client-side only projects, or ones that will use JSON to communicate with the server. Turn-based games have worked well for me, as well as line-of-business apps. I wouldn't recommend anything too heavy (Elm will groan under multi-megabyte datasets), nor anything too real-time -- but I think 95%+ of things made for the internet split those uprights. 
Absolutely brilliant, it really helps me to deal with my monolithic 25 cases update function.
&gt;Being a bit more specific, where does it fit into the current webdev ecosystem? Elm is great for (small) client-side code, or alternately pretty much any dynamic webpage that doesn't have to do too much communication with the server. On the other hand, if you'll need to be parsing webpages, signing responses for OAuth, or the like, Elm will probably not have the level of abstraction necessary.
When you think you could use Angular or React for a project, you can replace angular or react with Elm. 
I'm not even sure when it's better to use Angular over React or vice versa...
We are using it on the back end and in Electron. So everywhere. 
Can you elaborate a bit more about "Elm will groan under multi-megabyte datasets" ? I'm using it as the business logic container of a hybrid app, with heavy and frequent client-server interaction (via REST and WebSocket) and I need to know where/when to expect a bottleneck.
Do you have any resources on the back-end side of things? Do you have something like an express server and send the request/get the response out of ports? (assuming node). How was your experience so far? How does it compare to simple haskell web framworks like say spock?
I just watched Matthew's talk as well. I found the ideas he introduces extremely compelling, and the fact that they are a usable library is pretty amazing. Let me try to give a take on the two. **elm-css** This allows you to define your CSS in Elm. This gives you the benefit of protecting you from creating invalid styles, since everything has to type-check by the compiler. Since the classes themselves become Elm values, you also lose the ability to assign a class that does not exist if you your elm-css code is shared with your view code. **style-elements** This library offers a completely different way to think about the concept of "layout" of the entire page, which is neither just element positioning nor is it just styling. This library is not a replacement for elm-css, but it is a replacement for elm-css (or any CSS in general) and core/html. The main idea that Matthew presents is that you are defining your layout and your styles together, so that the code forms an explicit contract about how the element should exist on the page (something that either HTML or CSS alone cannot do). He gives the gist of the shortcomings of the "normal way" of doing it at [3:21](https://youtu.be/NYb2GDWMIm0?t=203). Also, using functions like `row` and `el`, you are both getting the benefits of organization and abstraction (when compared with a bunch of nested `div`s). That being said, Matthew alludes to considering making changes to the library API in his talk, so I would not necessarily use style-elements in important production code yet. TL;DR - elm-css allows you to write type-safe CSS, and reference it in your view code. style-elements introduces a brand new (to Elm at least) concept of a singular "layout" that explicitly defines everything on the page in a single coherent manner. With the latter, not only are you getting type-safe styling, but you are ensuring that everything about your view code is always consistent.
Video linked by /u/AIDS_Pizza: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Elm Europe 2017 - Matthew Griffith - Understanding style](https://youtu.be/NYb2GDWMIm0?t=203)|Elm Europe|2017-07-04|0:21:21|19+ (95%)|500 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/AIDS_Pizza ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dkack6e\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Elm seems to be good especially for larger client-side code and the more complex the more benefit. For small code base anything will do.
What do you mean by "splitting up" code? And why would it be more important in Elm compared to other languages as it applies to Elm? Is it just that elm testing tooling is immature?
I've had responsiveness issues with apps that e.g. load an entire English dictionary. It's just JavaScript executing, so when you want to do something that will break 60fps people might notice, and long tasks that last tens of seconds need to be broken up or you'll get the window being labelled unresponsive. I wouldn't anticipate any bottlenecks on the client for any websocket stuff, unless you're using websockets to keep a high-level 3d model of a digital world synced between all your users. 
&gt;For small code base anything will do. Maybe, but I sure as hell don't want to write JavaScript if I have to (see e.g. [this](https://www.destroyallsoftware.com/talks/wat)).
Thank you.
&gt; On the other hand, if you'll need to be parsing webpages, signing responses for OAuth, or the like, Elm will probably not have the level of abstraction necessary Could you elaborate for which scenario you are parsing webpages on the client side? Like scaling? 
Thanks, very interesting !
I developed WebSocket client and server components. Also a Postgres Effects Manager. Check out github. Look for panosoft/elm-*. 
I've done a few web apps in Elm including a WebRTC platform using WS and a few other things. I think you can develop faster in elm than JS, the ports system is pretty great, out of the box it's an MCV framework. My only issue is the lack of code injection which should be a feature in 0.19. There are also a few other areas such as a lack of support for iframes, and Contenteditable editors are a pain in the ass to work with.
For parsing big chunks of data, like loading a dictionary, you can: - break the work into chunks - parse line-by-line - use tasks to `Process.sleep` every 400 lines or something As browsers make it easier to support concurrency efficiently, we can do a better job on this, but there are ways around for now!
I really like this. I was always really interested how well a 'Scrap all your typeclasses'-approach would work out :) I don't know the elm ecosystem so well, but is there a Dict library in elm that works with this approach?
An exporter from Sketch into Elm. Basically allows you to make a design in Sketch, and preview the Elm code that it might make. Not perfect and definitely a work in progress, but it's pretty neat! Check it out [here](https://www.npmjs.com/package/elm-sketch-importer)
https://github.com/ktonon/elm-serverless/blob/master/index.js Found this today. It looks specific to REST APIs. The mechanism I created I can also use in socket.io or arbitrary JavaScript, but Elm-Serverless requires less setup.
This looks really cool, and I just so happen to anticipate using lambda as the backend for an Elm app I'm writing. Doesn't look like the repo has seen much activity as of late--Anyone know if this is still being actively developed?
* [UTF encoding tools](https://github.com/zwilias/elm-utf-tools/), since a lot of packages do their own UTF-16 -&gt; UTF-8 conversion and get it wrong * I wanted a quick, offline way to look at the docs of a package without using the online preview, so working on eventually turning [this](https://github.com/zwilias/docs-preview) into a static docs generation thingymajob * After some pretty interesting discussion on Slack concerning the tight coupling between views and the state-tree, I explored the idea of using explicit accessors to .. access the state from within view functions, which resulted in [this experiment](https://github.com/zwilias/elm-disco/) I've been busy :D
I just slapped a pull request onto it to get the demo up and running more easily.
Thanks :) I don't know for certain, but I don't really think so since I originally made this because I thought it hadn't already been done, and that was only over the weekend.
`msg` is a parametric type, but it will always get instantiated with your `Msg` type in practice. It's a bit funny, but the idea is that HTML objects (like divs and buttons) might have event handlers. The event handlers might send messages. And to send a message, you need to know what a message *is*. So we keep track of `Html msg` and attach to those objects `Attribute msg` attributes.... all in the name of functions like `onClick` and `onMouseOver` being able to construct a message for the runtime to dispatch back to your update function. EDIT: Also, reading the last line of your question. The `msg` in `Html msg` is a type parameter, not a parameter of the function. It will be inferred by your program. You honestly don't have to think about it, but it needs to be there for technical reasons. As far as you're concerned, you could just imagine the type is `Html` and you will live a happy life. 
Going through "Elm Beyond the Basics" . http://knowthen.com/
I scrapped github showcases for this
well, if the fields are maybe there, make all fields maybes? or if behavior changes drastically depending on what combinations of keys exist, make a union of the possible combinations?
Records are for situations when the structure of the data is known and fixed. If the data is not always present, you either have to use `Maybe` types to capture the idea that the data is either `Nothing` (null) or `Just x` (has a value of x). Or else, you might want to use a `Dict`.
Can you say more about your problem? What would you like to represent *specifically*? We can give better advice based on that. * * * I'll assume it is an extra large chess board. But like /u/tactics says, a record is best for data with known shapes. I would bet that a `Dict Int Piece` could be nice for your case. You can use [`Dict.get`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Dict#get) to see if there is a piece at a location. If you want further clarification, the folks on [the Elm slack](http://elmlang.herokuapp.com/) can help out with less delay! :)
I'm getting ready for Ludum Dare. Firstly by polishing off and publishing 2.0 of [Slime](https://github.com/Seurimas/slime). Secondly by working on WebAudio bindings, since there doesn't seem to be an easy way to play sound effects/background music in Elm.
the shape is known, it is a grid of input fields which are named c1_1, c2_1, c3_1 c1_2, c2_2, c3_2 for a 2 lines by three column grid it is like a sparse matrix, shape known but few slots occupied when the data is fetched from the server, they come in json with all the fields not necessarily used : if the json field holding the data is prefix, I may get only the record { prefix : { c1_1 : 1, c2_2 : 5}, other_fields : ... } so the problem is not keys unknown in advance but "tedious to list all the keys in all the situations" ideally I would need type alias grid = { Maybe keys} Maybe I should refactor to Array of Array of Int but that does not translate well to distribute the data in the grid of input fields for model update. I would need to translate this Array of Arrays to an object with keys back and forth (an object with keys is what the HTML form gives when the form is serialized to update the model)
 a field holding maybe some data is ok but how do you make a record key a Maybe ?
&gt; Dict.get I can say type Grid = Dict (Int, Int) Int to declare a Dict where the keys are a tuple coordinate (x and y) and an Int value but I would still need a conversion back and forth from json (record like) to save back to the server or read from it data are in json+api format Ideally this big record to send to json+api back end would need to be typed also or can I rely on an elm library on this 
If modules were records by default you could do this instead : `.map List ((+) 2) [1,2,3,4]` 
I don't think you can make the existence of the key optional, you can only make its corresponding data a 'Maybe' type. For a structure with optional keys you would use a dictionary, I think.
Haha, that would be really cool solution actually!
Trying to figure out which projects I can meaningfully contribute to. Anyone know any projects that need entry-level bugfixes, feature requests, or that have documentation needs?
Every project has documentation needs, always. :P A good place to start is figure out which packages you really enjoy using, then go and look at their issues or contact the maintainer for ideas. It's easiest if you start with an API you already know and love (or, even better, get caremad about.)
It's not. Elm, React, Angular, it doesn't really matter (except for developer preference). You would use one of these technologies if you want to make changes on a webpage without reloading said page. 
Online card game using socket.io. [EDIT] and Elm of course.
The approach from the [old Mario](https://ellie-app.com/3N7jtXJJYTha1/0) demo was quite interesting. Basically, you control the velocity with the keyboard and you move the object based on velocity and delta. 
Very nice examples! Looks very good, I will for sure take inspiration from that style for my update functions. The Maybe example I would probably write more like this to avoid writing a lot of maps: map (dothis &gt;&gt; dothat &gt;&gt; finishit) (Just "hello") I am not sure yet which is prettier, any alternative suggestions?
Good point. I think either way is just as pretty!
Frames will happen irregularly (unevenly), but when they do you should get a time delta for how long the frame actually lasted. Here's the trick: instead of moving a constant distance per frame, move a constant distance per unit of time. Multiply the time of each frame by a speed to get the distance added that frame. It will be more for longer frames, and less for shorter frames.
Elm lang has a list of projects to be done. [Elm Projects ](https://github.com/elm-lang/projects/blob/master/README.md)
Yeh that's what I was mulling over. I was wondering whether there was a standard rule of thumb - but I suppose I will just go with whatever feels better, or looks more elegant in code : ) Thanks!
You probably won't be able to print the `input [...] [...]` structure, because it's a function call. The result of it is of type `Html Msg` which you can't inspect (it's contents are hidden). Now for the printing of the HTML element instead of what you get now: that would, I think, have to be done by tricking the `view` function to be called again and having a `Debug.log` call next to the `input ...`, not inside `onModify`... You could maybe trick the `view` function by changing the Model somehow. I don't really know, it's an unusual request :) ---- **Can you explain why you're trying to do this?** Based on that, we might find different ways to achieve that goal. (eg. if you're inspecting five different inputs and don't know which one is which in the console, just change the first argument of `Debug.log`)
You want the [value](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode#value) decoder to capture the raw event object. Then you will have to send it out of a port to print it on the JavaScript-side. You cant trick Debug.log into printing it for you unfortunately. Check this [example](https://ellie-app.com/3Nw3QzHxLFWa1/0).
thank you that was helpful
I have a grid of input fields I would like them to send a unique message with parameters the value and the name of the input tag so that I can update a a record field based on the name and the value model = { response : { c1_1 : 0, c_2_1 : 0}} input [name "c1_1", ...] input[ name="c2_1", onInput Umess ] Update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of Umess name value -&gt; some update function for the response record 
You should probably not put stuff into the DOM if you don't absolutly have to for CSS or 3rd party reasons. Just partially apply the name to the "Umess" message and just use onInput. input [ onInput ( Umess "c2_1" ) ] [] 
You need to pass in the source array so I think it should be gridUpdate : Int -&gt; Int -&gt; String -&gt; Array (Array String) -&gt; Array (Array String) Incidentally you may want to check out [elm-flat-matrix](https://github.com/eeue56/elm-flat-matrix) which makes use of a single flat Array for improved speed/memory use.
The second creates a type called `Umess` with a constructor called (confusingly) `Int`.
`type A = B c d ...` says "make a type `A`. It should have the constructor `B : c -&gt; d -&gt; ... -&gt; A` and no others." So your second one says "make a type `Umess`. It should have the constructor `Int : Int -&gt; String -&gt; Umess` and no others". Constructors do not have to have the same name as their associated type, and there is no `Int` value already (there is a *type* `Int`, but types and values can share names), so Elm doesn't complain and happily makes your constructor.
In the first case you're defining a type called `Msg` with a constructor function called `Umess`; this constructor takes 3 arguments of types `Int`, `Int`, and `String`. It is then valid to run `Umess 12`, which gives a function which still needs two arguments, an `Int` and a `String`, before you can get a `Msg` value. In the second case you're defining a type called `Umess`, with a constructor function called `Int`, which takes 2 arguments of type `Int` and `String`. In this case to create a value of type `Umess` you'd need to run something like `Int 5 "foo"`.
thanks seems like an interesting package
thanks where do you get the source for this valuable information ? the doc at elm-lang site does not talk about that, or did I miss it
I learned Haskell well before Elm, and the two are similar enough that I've only since looked at the differences. However, I do think the guide (which is the main learning resource iirc) is reasonably clear. They step through a few examples in the style of the first to emphasize what constructors are. Now, if your second example were to auto-infer the constructor `Umess`, that would need very explicit documentation as that would be very unintuitive since you could very well want to call your constructor `Int`. Of course, you shouldn't, but you still might use constructors of `Var`, `Lam`, and `App` for a lambda calculus model, while enjoying the use of `App` as a type (and maybe also `Var`). Hence, the lack of documentation would suggest that there is no weird special case if the first item were the name of a type.
If you are capturing a grid it might make sense to use a Dict (Int,Int) value
The [section on types](https://guide.elm-lang.org/types/) in the guide attempts to explain this, building up to the particular questions you are asking. After reading that whole section (especially about type aliases and union types) does it help with the confusion here? Where were you looking before that you didn't find anything? Would like to make good resources easier to find!
I started my first project in Elm: a Magic the Gathering life counter. [Here's my progress so far](http://tylermassey.github.io/magic-life/)
the guide does help, but in my opinion there lacks detail you have nowhere in the guide explicitly the example type Msg = Constructor x y you do have Msg = Constructor x y | Int | Constructor_b etc... but i's not the same because it's there to emphasize type unions, and the explanation about type constructor is almost incidental and it's explained in a long example in Type Unions, not in the Syntax section. I also read the elm in action still in progress book, which is good, but again not a systematic language survey, the style of books I prefer
I thought about it also but since anyway I have to lay down the complete grid, and may do some computation on the grid of values a full matrix structure is good but for saving into a json backend, I need to translate the matrix into a json of the form { prefix : { c1_1 : 2, c3_2: 4}} where only the non empty cells are represented in the form c{column_number}_{row_number} if I translate the matrix in a record, I have to declare all the keys in a type which seems unfeasable if I translate it in a Dict it's ok but how does the Dict translate into json ? 
yes the guide is ok but the syntax section is short one small line on type constructor in the syntax section and not a lot of explanation on for instance, where does a function definition ends, carriage return not significant in some places, there can be only one expression in a definition body, and things like that, or else you use let expressions if you need more room to lay down computations etc... maybe it's because you need to read several times to get it anyway reddit comments and answers are absolutely helpful
Thanks hugely for this suggestion. I've just been working on something similar and had ended up with extra stuff in the DOM and a custom decoder to get it back out again. Partial application is so much easier - seems so obvious now - you're a star!
Looks good! But what is the answer to the third puzzle (2/50)? Looks like it might be impossible to answer it...
And maybe a possible enhancement is adding a "next" button along with the "replay" button when you win a game to move onto the next puzzle.
It was a bug for special chars ("Can't keep a good dog down") Fixed thanks to you :)
You got it
Directly, your decoder/encoder is actually simpler
More of a data structures question. I'm attempting to model a tab button panel that shows a list of tab buttons and only one tab can be "active" at a time. My initial thought was to use a library like [List-Zipper](http://package.elm-lang.org/packages/wernerdegroot/listzipper/latest/List-Zipper) because `current` could be the active tab. However, it's starting to look like a zipper list is meant to be traversed sequentially, without skipping. I think this will be problematic for me if the first tab is active and the user selects the fourth tab. I don't want to have to [next](http://package.elm-lang.org/packages/wernerdegroot/listzipper/latest/List-Zipper#next) over the zipper list until I find the correct item. Is there a better data structure for representing a list of tab panel buttons where only one button can be active?
Super good! :) Looks like some of these are literally impossible to lose, because the saying uses almost all the letters, and even if you picked all the letters not in it you wouldn't die. 
Algebraic data types are a combination of sum (union) types and product types. So they are not really the same. For example take a the List type: ``` List a = a * (List a) + 1 ``` This type is composed of a union type and a sum type. 
**Disclaimer**: This is my understanding, not a definitive answer. They are related, but distinct. A *union* is a type that can be *one of* many different types. For example, in Typescript, you can define a type as such: foo: SomeTypeA | SomeTypeB What this is saying is that `foo` can either be a `SomeTypeA` or `SomeTypeB`, and typescript can determine statically using type guards when it is one or the other, for example: if(foo instanceOf SomeTypeA) { // The compiler will know here that foo is SomeTypeA // You can access members of SomeTypeA here without compile issues. // If you treat foo as SomeTypeB in here, the compiler will throw an error } Another term for ADT is a *tagged* or *discriminated* union. That is, there is an additional piece of information provided when declaring the type that aids the compiler in identifying the actual underlying values. In languages that have ADT's, instead of declaring a type like a traditional union (`type Foo = String | Int`) we "tag" each value, for example: type Foo = AsAString String | AsAnInt Int Unlike the TypeScript example, we don't type guard by checking that the value is of a particular instance (a string or an int), we pattern match on the *tag*, and the compiler infers the actual values from that: case foo of AsAString stringVal -&gt; -- we have a string! AsAnInt intVal -&gt; -- we have an int! Here's another example that makes ADT's more powerful and illustrates a difference between the two. Consider this type: type Time = Relative Int | Absolute Int Here, the tag provides additional context about the type. Even though each ultimately holds an int value, they mean different things. This wouldn't be possible with a typical union, because, well, `type Foo = Int | Int` really just means `type Foo = Int`. So, to answer your question, ADT's are a kind of union.
http://package.elm-lang.org/packages/NoRedInk/list-selection/1.0.0/List-Selection Disclaimer: we wrote this and I just open sourced it. I'd love your feedback. 😄
But a union type doesn't have the tag, a tagged union is a sum type; union and sum types are different. A union type is like the union keyword in C while a tagged union is more similar to ADT although not the same
Thanks for the suggestion. I had a similar idea where the equivalent to your `select` function would take an index of an item in the list. This had the advantage of specifying the selected thing unambiguously (for example, how do you handle selecting the second Burrito in ["Burrito", "Taco", "Burrito"] when calling `select "Burrito" mySelection`?). The disadvantage is the index could be out of bounds and thus requires similar `Maybe` handling. I'm thinking there's probably no way around that. Anyway, since you asked, how do you select the second Burrito when Burrito is duplicated in a list? Also I like the way the invariants are plainly listed up front in the docs. +1
[here](https://ellie-app.com/3P3fpxxBRF7a1/0) 
well, you have tagged and untagged union types indeed. They are both union types though
True I guess. I assumed that the untagged union was called union type. Thanks for the clarification :) But then, how are Elm union types different from ADTs (i. e. a la Haskell)? Is there a difference? (I couldn't observe any difference reading the Elm docs)
I think "union type" is the clearer and more general term. From the wiki on [union types](https://en.wikipedia.org/wiki/Union_type): &gt; a union is a value that may have any of several representations or formats within the same position in memory Great, that is exactly what it is. It goes on to clarify: &gt; Depending on the language and type, a union value may be used in some operations, such as assignment and comparison for equality, without knowing its specific type. Other operations may require that knowledge, either by some external information, or by the use of a tagged union. To make pattern matching with `case` work in Elm, we use [tagged unions](https://en.wikipedia.org/wiki/Tagged_union) all the time. So we *could* say "Elm has tagged union types" but it doesn't have any other kind, so it feels sort of silly to be extra specific *within* Elm. Okay, so at this point we have a term that is used in C and in JS, and it describes what it does relatively clearly: it makes it so you can treat *different* types as if they are *one* type, like the union of these things. So the term provides *cultural* and *definitional* hints before you learn anything about it. * * * But to the original question, the overall design of tagged unions is pretty standard in typed functional languages, and folks have historically called them "algebraic data types" in OCaml and Haskell and others. (To be clear, we have the same design in Elm.) But we had trouble teaching folks Elm with this name! So we had discussions [like this](https://groups.google.com/forum/#!searchin/elm-discuss/algebraic$20data$20type$20union$20type$20alias%7Csort:relevance/elm-discuss/rI_IAf4TiAA/KTvQv1LQ6uAJ), and asked questions like "What does the "algebraic" in algebraic data type actually refer to? Does anyone know?" I did not after 5+ years with ML languages! So like I say in my [Let's be Mainstream](http://www.elmbark.com/2016/03/16/mainstream-elm-user-focused-design) talk, I am making this language for folks coming from JS, Python, Ruby, Java, etc. That includes tens of millions of people who have never seen or heard of Haskell or OCaml or SML. Furthermore, "the real terms" are not very helpfully designed. We used to use them, and they did not work well. I think it'd be silly to make all the same design and naming decisions as Haskell or OCaml or SML and expect a different outcome in terms of accessibility. So it would be great if we all used the same terms, and I hope that *union type* is the one we go with as millions of people learned typed functional languages for the first time!
Let me flip that on ya: how do you know the second burrito *isn't* selected? Since they're duplicate, and "Burrito" is selected, no problem! You get to decide if it makes more sense for you to indicate to the user that the item called "Burrito" is selected or just use the first one in the list.
Thanks man! You're right, I'll change the sentences bank
If I understand correctly, Elm has ADTs: type MyADT = Product Because Arguments To Constructors | Sum Because More Constructors Maybe the docs just name things wrong. There was a Twitter thread lately calling this out...
I know I recently notice this and post it on Twitter, but almost no one (or no one) replied, so I posted this on [reddit functionalprogramming](https://www.reddit.com/r/functionalprogramming/comments/6o2bz9/are_union_types_the_same_as_algebraic_data_types/). In that post, we got to the conclusion that they are the same but with different names.
I don't know much about Angular 2, but I can give an even-handed pitch for Elm. Elm is a programming paradigm that is very different from what a lot of JavaScript developers are accustomed to. Your team has to be open-minded and willing to suffer through not understanding things for a little while and realizing that the tricks you have learned elsewhere often don't apply very well or have limited utility (I'm looking at *you* 'components'). This will lead you into Elm's greatest strength, the ability to refactor with confidence. Your first draft of any new software is likely going to suck and this is particularly true when using a new tool. When you refactor in Elm, the compiler guides you through all sorts of problems so you can solve them while your changes are still fresh in your mind and without having to turn to manual testing or often-fragile unit-testing. It's hard to take someone's word for it, but refactoring in Elm is a *completely different experience* than in a language like JavaScript. I look forward to refactors because that is where my code gets all clean and shiny where in JS that is when things break. Elm's guarantees of safety come at a bit of a cost of having to be explicit about things which you hardly think about in JS. When you are consuming a JSON API in Elm, you have to describe in great detail *exactly* how to convert the JSON into an Elm data type. This has benefits of ensuring that your app won't crash when you didn't realize that an API field is optional ('undefined is not a function') and in giving you some time to think about how you want this data to be represented inside your app, but it lacks the tremendous ease that people are accustomed to. It also uses a technique which is *very* alien to most programmers and can be difficult to learn. Similarly, there is a wall of separation between Elm and JS which is different from what most people expect. You *can't* just call arbitrary JS code from inside of Elm. You have to pass things through an asynchronous 'port' and wait for things to come in (and convert it to an Elm data type). For most things, this isn't a problem, but sometimes you have to think to make something work well. The Elm community is small and extremely helpful. There are often not packages for everything that you might want because they just haven't been written yet. If your team likes the idea of contributing, Elm has a lot of room for contributors. While your team is figuring things out, they can lean on the community to get them up and running. Go join the Slack channel and ask away. People there bend over backward to help people learn. Elm is still beta software and Evan has continued to make deep changes to how things work. If you write something in Elm, expect to have to fix things (with plenty of help from the compiler). You shouldn't choose Elm if you are easily frustrated when things aren't clicking yet, if you don't have time to learn something which is likely very different from what you already know, if you want to do something complicated and want to just rely on others' code to get it done, or you just can't tolerate inconveniences regardless of the reliability benefits they enable. You *should* choose Elm if the idea of learning to do things in a creative, new way, you want to feel confident that your code is going to work even through massive refactors, you want to participate in a nice community while it is still small enough to make a splash.
Thanks for your reply and the links to the Google groups. I didn't know that this topic was considered and thought in that much depth. I see now where Elm stands (although I would not say that I agree) and its point of view. Thanks for the reply :)
There was a video (maybe by Haskell's Chris Allen?) I remember watching making a defense for using the actual names of things. Obviously, in Elm, the decisions have been made (and for the better in many cases, like the elimination of the `Monad` typeclass). But at the same time, it would be good to have footnotes in the necessary parts of the documentation laying out the actual names of things so that new users can easily reference the literature if that's their style.
I see. In that case I'm not sure that package will work for me. For example, relate it to the tabs in your web browser. You could conceivably have two identical tabs open with the same page and same window title. Knowing which one is selected is important so that the correct tab shows as selected in the tab bar.
That was great fun, finished all of it. Thanks!
*standing ovations*
Just to follow up with my other reply, I found the video I was referring to. It was by Chris Allen (bytemyapp), who curates the \#haskell-beginners channel on Freenode IRC. Here's the relevant part of the video. I think it's an important point, which deserves full consideration by any functional language: https://www.youtube.com/watch?v=Bg9ccYzMbxc&amp;t=15m29s
Is [this](http://package.elm-lang.org/packages/basti1302/elm-non-empty-array/latest) package what you need?
That sounds like a really good idea. On another note, why was a good idea the elimination of the `Monad` typeclass? I think I am missing a bit of background here (I do know what are monads, I just don't see why that is a good thing, thanks)
Generally speaking, I feel category theory is heavily oversold by the Haskell community. Category theory is incredibly important if you're an algebraic geometer or algebraic topologist or a logician. But developers are none of those things. From a more practical matter, the combinators for the `Monad` typeclass are just not very universal, outside of `(&gt;&gt;-)` and `return`. For instance, `forM` or `sequence` both "make sense" when the monad you're using has semantics reminiscent of `State`. But if you use them for a backtracking monad, like `List` or `Parser`, their names are nonsense, and what they do is pretty gnarly. To give a concrete example, tell me what `filterM (const [False, True]) [1, 2, 3]` or what `forM [1, 2, 3] (\x -&gt; [x, x+1])` do without running them :) The advantage `Monad` gives is purely syntactic, since Haskell supports `do` notation. But it adds so much conceptual overhead I doubt its value as a general programming construct. Elm shows that you don't necessarily *need* monads to have a useful system. And any experienced Haskeller knows that monads suffer their own problems related to composability. The worst part, though, is that it mystifies simple ideas. Knowing that `State s` is a monad or that `Reader r` is a monad isn't as useful as knowing what either `State s` or `Reader r` are individually! Those things aren't hard to learn. But the interface is minimalist, abstract, and devoid of any insight. You don't want the technical details any more than you want to see optimized compiled machine code. Hell, most of the time, you don't *actually* want the high level Elm code. You want the idea drawn out on a whiteboard in a way which makes sense. But I'm ranting :) Monads are still important, culturally. And they are everywhere you look. But as I said, Haskell goes way too far with them. They mostly serve to give you `do` notation, and beyond that, you really don't need them. They are a tool for theoreticians doing logic or algebra, not a tool for programmers.
All programs with `Navigation`have a message that is generated after the path changes. That message's branch of the `update` cand return a Port call `Cmd`. [Here is some code that shows this.](https://ellie-app.com/3Pdwx7XTD3ha1/0) (it just prints the received hash to the Console but you can send it the ID of some elements or some kind of other page related information)
&gt; My suggestion would be to make anything new in Elm if possible. This would be against the recommended way of introducing Elm to a team. Maybe is better to discuss exploring Elm as a team in this new project. Implement it in Angular 2 since you already have the know how and give Elm one of the jobs in the app. This way, if the rest of the team likes Elm, they can move more and more code into Elm. If they have a hard time with Elm (which I doubt), no big issue for the project, you just scrap the component you gave to Elm and reimplement it Angular. The situation is slightly different when you are the sole frontend developer. Then yes, you can bet the house on Elm because you already have enough Elm knowledge. As for making a case for Elm, what I love best is the declarative nature of the language. You declare what you want and if your declarations make sense to the compiler, you get what you want. The contracts you make when you declare a function are enforced by the compiler. This means that you can refactor without fear. There are no shortcuts that can tempt developers on a tight schedule. No easy ways in which things blow in your face at runtime. 
You can't. `Html msg` isn't a type that you can modify. If you want to have an extra `th` you'll need that value to be available then you create the `table`. Commonly you would do this by making the above code a function and passing in the additional `th`s as a parameter to that function. makeTable: List (Html msg) -&gt; Html msg makeTable additionalHeaders = table [][ tr [] [ th [][text "h1"] ,th [] [ text "h2"] ] ++ additionalHeaders ]
great thank you
Please always use elm-format when posting snippets. With elm-format, I'm pretty sure you'd have spotted the missing `(` `)` makeTable : List (Html msg) -&gt; Html msg makeTable additionalHeaders = table [] [ tr [] ([ th [] [ text "h1" ] , th [] [ text "h2" ] ] ++ additionalHeaders ) ] 
Great suggestion. Thanks!
[For those that didn't see the original](https://github.com/xori/gamblers-dice) [Project is live on Github.io](https://solkaz.github.io/elm-gamblers-dice/)
Elm reduces the amount of testing you need to do by a lot. I used to hate anything resembling strong, strict, or static typing. Every argument for it did not make sense to me. It was something I had to experience for myself to believe it. That is not to say I did not have prior experience with statically typed languages, I did, just not with intelligently designed ones. Now I understand the power of an intelligent type system as a replacement for much of the test code you would otherwise need to write. Use Angular if you don't want to think. Use Elm if you don't want to have to choose between delivering unreliable software and drowning in tests.
You don't call modules, all you have to work with are functions. The pattern described in the Elm Architecture shows you how to initialize your Model. Basically you have an init function that takes your parameters. init : Int -&gt; Int -&gt; Model init width height = { ... } In the Main module you can call this init function (e. g. in the Main.init function to initialize the Main.Model). I can really recommend you to read the official [Elm book](https://guide.elm-lang.org), it tremendously helped me to take the first steps. 
Based on the API it looks like yes. Interesting. I'm interested to look under the hood on this one.
You could use the [elm-http](http://package.elm-lang.org/packages/evancz/elm-http/3.0.1) library. If you're running a server, you can simply do a GET-request. If not (maybe you use `elm-reactor`), you could start a VERY minimal server using a built-in Python script: `python-m SimpleHTTPServer`. Run this in the directory with the ROM file, and you should be able to do a GET request to `localhost:8000/ROM.data` or something like that.
thanks for the answer I did that but in the main app how can I union the messages of the module with the ones of the main app if any The module itself when packaged alone in an small app is ok, now I wanted to use it as a component in a larger app so in the main app I imported import Mymodule exposing (init, view, model, Msg) In the main I tried to complete the messages type Msg = Utric String | Utrico String | Mymodule.Msg and in the main view added the Mymodule.view inside some div of the main view but got the message, (as if union types, as I wrote it, is not recognized) The 5th entry has this type: Html Msg But the 6th is: Html Mymodule.Msg Is there somewhere an example of a main app using a module with self contained model and messages and view ?
To my understanding, the center of rotation is the center of the `Form`. For example, if you insert `|&gt; move ( 100, 100 )` before your rotation (Boid.elm#L35), this becomes obvious. 
You need to use a wrapping tag thanks for the answer I did that but in the main app how can I union the messages of the module with the ones of the main app if any The module itself when packaged alone in an small app is ok, now I wanted to use it as a component in a larger app so in the main app I imported import Mymodule exposing (init, view, model, Msg) In the main I tried to complete the messages type Msg = Utric String | Utrico String | MyModuleMSg Mymodule.Msg and then, in `update` use `Cmd.map MyModuleMSg cmdFromMyModule` to map the cmd you receive from `MyModule.update` and use `Html.map MyModuleMSg (MyModule.view model.myModuleModel)` to convert the html you generate with `MyModule.view` to the msg of the parent. This approach is notorious for creating issues, especially if you use it to generate hierarchies of such "components" and you want them to communicate. Another approach is demonstrated in the code of [elm-sortable-table](https://github.com/evancz/elm-sortable-table). 
This won't work. The centre of rotation is the middle of the canvas whether the Form is moved or not. 
Here is a [simple Ellie demo](https://ellie-app.com/3PK9hwncjQ7a1/0). As you can see, the triangle is rotated around its center. If it would have been rotated around the center of the canvas, it would have ended up on the y axis. Here is [the same demo with a red triangle](https://ellie-app.com/3PK9hwncjQ7a1/1) that is placed in a collage the size of the canvas. this collage is then rotated to simulate what would look like if the center of rotation would have been the center of the canvas. 
I see, on my example though the initial position of the "ship" is not at the centre of the canvas but say at (50, 50). I think this is the main problem. Perhaps, what I need to do is render the ship at (0,0) and each tick use the move function to move it to the next location to simulate the effect of movement? Currently what I am doing for movement is drawing the ship at a new starting position each tick. **update:** I now render the ship at (0,0) and then I use the move function to move it (even the initial position is done with the move). That seems to solve my issue with the rotation :) Thanks
&gt; I see, on my example though the initial position of the "ship" is not at the centre of the canvas but say at (50, 50). In your case, by manually setting the position of the ship, the shape you are drawing is not the ship but the ship and all the empty space. If you manually manage the shape's position, you must also manually manage the rotation. It can be done but it can be simpler to think in terms of rotating the ship around its center and then moving it to the proper position on the screen. This is actually what the Form API is allowing you to do. You could ignore all those functions and just draw the forms in their final shape (after being moved and rotated). 
Yeap, agreed. This is what I have done now and it works flawlessly. Thanks
Well then. That's one way to put it!
Hey, CHIP-8 in Elm! That's cool - I'm also in the process of rewriting my CoffeeScript CHIP-8 emulator to Elm :) Here's to ... ever finishing it :D
does elm-sortable-table approach mean that the whole model must be held in the main app ? 
That package has now been replaced by [elm-lang/http](http://package.elm-lang.org/packages/elm-lang/http/latest) and it currently provides no support for binary data - just text and JSON. So I don't see how you could use it for this use case without also writing a simple server that served ROM files up as a JSON list of integers or something...
Currently there's no real way to load or parse binary data in Elm - there's a long [thread](https://groups.google.com/forum/#!searchin/elm-discuss/binary$20data%7Csort:relevance/elm-discuss/spr621OlUeo/ymWtQddqCAAJ) on the elm-discuss mailing list collecting use cases for binary data, so it may be useful to add your use case there. In the meantime you'll likely need to preprocess as you're doing, write a simple server that handles the conversion from binary to a JSON list or something, or use ports to have JavaScript send a request for binary data, parse it client-side into JSON and then send that back into Elm.
This is awesome! Loving the clean and simple icons. Keep us updated on the progress.
Yes. Elm has a single source of truth. All state ends up connected to the main Model. 
One big base64 encoded string seems much more sensible. 
 import Messages exposing (Msg(..))
Does elm have any restrictions on strings? Will it accept a string even if it's not valid ASCII or UTF8? If so, what's stopping me from loading binary data into a string? :P Quick test on the online editor; Char.fromCode will give the byte value for characters less than 256. From the looks of it, it definitely supports unicode, but unclear whether UTF-8 or something else.
In general Elm strings are (currently) just represented as JavaScript strings under the hood...I don't know the exact details of how string responses from a server are handled but I'd be pretty nervous about strings with embedded zeroes or anything like that.
Yeah you can do that, I've done it before. [Here's a link](https://online.pragmaticstudio.com/tour/courses/elm/steps/6) that shows how, but it might be a bit outdated. They probably have an explanation for how that works in their official docs as well tho.
Awesome, that works perfectly!
thank you it works, where is it explained anywhere in the docs ?
Wow, I didn't know it was getting so simple. But how does it (or you) know how much fuzzing to do? When is the test "done"? Presumably, the fuzzer can supply an infinite number of combinations..
I assume you are talking about the `core`. To my understanding Elm `core` stays purposefully small. This encourages innovation in the space of libraries. Some of the libraries represent style choices, some truly bring new and innovative way to do certain things. As people use the libraries maybe some of them that become develop a very stable API and are of general value could end up in the `core` but I can think of none that would qualify right now. The discussion about Date has been started and we will probably see an official library to better handle time in a future release . I would argue that the space of SPA should be handled by a kit rather than by the core as this would make more sense when considering the future of the language. Such a kit could make decisions about how to handle routing or CSS generation. We don't have a clear winner here. Take CSS for example, `elm-css` is a great library offering extra safety while writing CSS but it's still very much tied to CSS. `style-elements` is a much more promising library in this domain because it enforces a clear separation between layout and style. 
[Module section of the Syntax docs](http://elm-lang.org/docs/syntax#modules) mentions this by example but maybe it should be mentioned in the Guide too. 
I just checked and it appears in the docs here http://elm-lang.org/docs/syntax#modules but it is explained poorly. I remember being stuck with this same issue, I don't remember if I figured it out from the docs or by looking at someone else's code.
 a = { f1 =12, f2 = 23} field = .f1 value = field a -- value == 12 If you want to use text to describe the accessor, you can [create an accessors dictionary.](https://ellie-app.com/3Q8YmGfwWdha1/0). This assumes that all your fields (at least the ones you want to access like this) have the same type. 
Website for a charity that helps people start careers in aviation. You'd be amazed how expensive it is to get a pilot's license. The charity also promotes the history of a little-known pioneer of aviation. 
great, and for the update of the field f1 ?
I believe Voronchuk/hexagons is the most complete. I have been using it successfully in a hobby project.
There is no equivalent for update. You can get the same functionality but you have to implement the updater yourself. a = { f1 =12, f2 = 23} uf1 = \val record-&gt; {record | f1 = val} updater = uf1 updatedRecord = updater 21 a -- updatedRecord == { f1 =21, f2 = 23} 
elm-test fuzzing API settled on 100 tries by default, but allowing you to override this number (ie. let's run this fuzz test 10000 times for extra safety!) btw, &gt; Testing shows the presence, not the absence of bugs. &gt; &gt; ~ E. W. Dijkstra
That's a really cool idea
If that's what you're trying to do, a zipper is actually the most appropriate data structure for you. You probably want the `find` function from `List.Zipper`: http://package.elm-lang.org/packages/wernerdegroot/listzipper/latest/List-Zipper#find
Going through https://frontendmasters.com/courses/elm/ .
[create-elm-app](https://github.com/halfzebra/create-elm-app) uses Webpack, but you don't have to configure anything
I recommend asking for more specific guidance on [the Elm slack](http://elmlang.herokuapp.com/). I think that'll be a good format for this kind of question! If you want help here, please clarify *which* commands you are running. Based on the information here, it's not clear what you are having trouble with.
Hey! It sounds like maybe you're not "importing". Often times you need to import things before you can use them (especially if it's coming from a library like GraphicsSVG). Like @wheatBread suggested, this type of question is better suited for the Elm Slack: http://elmlang.herokuapp.com. You'll get quicker responses in there. With that being said, I took a moment to fix up your example to show you what your code should probably look like: https://ellie-app.com/3Qs8VS5sJf5a1/0 Hope that helps.
Mine (elm-hex-grid) is unmaintained and unpublished, but it's minimal, has pathfinding, and supports everything you can see in its demo. I recommend it if you are rolling your own solution and want to look at a simple reference. You can see how the API works: https://www.danneu.com/elm-hex-grid/ But the demo is super slow because I reuse the same HexGrid model for all of the examples, so moving your mouse refreshes everything on the page. Originally the demo was just one screen-full, but it grew and grew. :D
Since starting full-time lisp coding a couple of months back, my Elm work time has decreased markedly. But I'm getting paid, which is good. It has enabled me to replace my 2010 27" iMac with a brand new 2017 27" iMac. Ordered Friday. Ships next week. Backing up to my new Thunderbolt 3 drive as I type. I'm still working on the board game that my son invented, Spokes. Client and server in pure Elm (well, two ports for the WebSocket server). Yesterday, I added voting on stone removal during the last end of game resolution, when there's an infinite loop. I also made placement automatic on clicking a node, instead of needing to click and then press the "Place" button. Tonight, I added size adjustment buttons for the chat pane. * GitHub: https://github.com/billstclair/spokes * Play: https://gibgoygames.com/spokes/
Giving an introductory presentation to ELM in Spanish. 
https://github.com/tomekwi/elm-live is basically elm-make with live reloading. By default it generates an HTML file with embedded js from your elm, but you can also have your custom index HTML file link to the generated js and also include CSS. Works with live reloading still.
**Warning**: Rant coming. The flavor of "live reloading" offered by elm-live and create-elm-app is in my opinion worse than useless. I don't know how they work under the surface, but they seem to perform more or less the same operation as pressing the browser reload button, hence _destroying the entire app state_. Translated to mobile or desktop app terms, elm-live essentially causes the app to crash and restart on every source code change. When I'm using elm-live, after every source code change, I have to switch to the app and repeat whatever steps I used to get back to the UI state where I wanted to add, change or fix something (assuming that I even remember how to get there, and that there is no randomness involved), and pray that it works as intended. If it doesn't, I'll have to repeat the whole process all over. The _entire point_ of live reload is to avoid this cycle, and elm-live doesn't achieve that. I think it's actually worse than manual compile and reload: With manual reload, I can at least inspect the running app (albeit a slightly outdated version of it) and its state while I change the source code, instead of having the whole thing just crash and restart on any change. The lack of a working live reload solution is to me the single most painful thing about Elm programming right now. I love the language, the community, the compiler, and tools like elm-format, but without a working live reload, I just can't stand using it for anything beyond relatively simple apps. I understand that Elm is a young language and that I can't expect the tooling to be very mature yet, but what I really can't wrap my mind about is the fact that all Elm developers I have talked to seem not to miss live reload at all, or at least to consider it no big deal. 
Shouldn't it work if you do: Nothing -&gt; 0 Just i -&gt; (i + 100)
No precisely it does not Function `update` is expecting the 2nd argument to be: Maybe a -&gt; Maybe a 
Simple. This allows you to delete values. If you return `Nothing` the value is removed from the dict.
ok so update can be used to update an existing key, to remove an existing key (with Nothing) and also to add a non existing key (if the key to update does not exist it is created) so insert and remove are implemented in terms of update maybe ? 
Code generator for Elm: https://github.com/boxed/elm-cog and an accompanying blog post about it. 
So I went through the Elm docs and did a quick tutorial on Elm and wanted to solidified what I learned. I've been working on creating a Hacker News client with Elm since I figured that would be decent practice. It has been going well until I encountered this situation. When you make a GET request to get the top stories from [Hacker News' API](https://github.com/HackerNews/API) it returns a list of IDs of each story. I've been having issues taking that list of IDs and performing a GET request to each separate story and updating my model. [Here is what I have so far.](https://gist.github.com/dillonchanis/ba7942e65eca2496616ac3c9e101eb33) Specifically, lines 135-142. I take the list of IDs returned by the first GET request and I am mapping over each ID, sending the request, and decoding the story. I am getting no errors but I'm getting nothing. I figure its just a misunderstanding of what my code is actually doing. Wondering if anyone can point me in the right direction, or if there is a better way to accomplish this. Thanks!
Yes
Is there any way to have something like a 'Letter' type which can be any Char a-z? This is for a function 'guessLetter' in Hangman which would take a letter and return some updated model. I suppose I could just take a Char and check that it is a letter but I thought that the whole point of a type system was to avoid things like this by guaranteeing types.
You can debug this by looking at the Err you're getting. You're conveniently logging them to a console, so... - What you can see is that it expected a list but got a object. The URL for `apiGetItem` returns an object for one story. So, let's change the line 136 to `storyDecoder`. - Then, probably only a semantic change - the `Msg` TopStories should be TopStory or Story because really, you're getting one Story in the Msg. - Then, if you try to compile and look in the console, you find that some of the stories work just fine (those with `url` field), but some don't. HackerNews has two types of stories - let's call them links and texts. - So, that calls for `Decode.oneOf`. One decoder will be for story with `url` and the other one for a story without one.
What you want are dependent types or predicate types, allowing you to restrict the values the type "has". Elm doesn't have those - but look at Idris :) In Elm, maybe just creating `type Letter = A | B | ... | Z` could get you somewhere? (ie. enumerating all possible constructors for the type) I'm not sure how pleasant working with the code would be then, though...
Awesome, thank you so much. Excited to try this out when I get home today. Update: Got it working thank you so much! Also I realized I wasn't on my Elm file in elm-reactor but on the index.html so I wasn't getting some of the console messages...that's one way to learn I guess. Thanks again!
As the other comment said, this would require dependent types (try a language like Idris) That let you do a lot of very cool things but at the cost of a *LOT* of complexity. There is no easy way to do that with elm.
I disagree that the whole point of reloading is preserving state. For me it's about not having to hit the refresh button. I guess there is something in the works automatically exporting and importing debugger state. For now you can simply change your init function in dev. That works exactly as expected.
&gt; so insert and remove are implemented in terms of update maybe ? Yes: https://github.com/elm-lang/core/blob/5.1.1/src/Dict.elm#L178-L187
As an aside, if you _don't_ care about adding or removing values and just want to update ones that are in fact present, you can use `Maybe.map` to lift a regular function `(v -&gt; v)`: &gt; increment n = n + 1 &lt;function&gt; : number -&gt; number &gt; d = Dict.singleton "foo" 99 Dict.fromList [("foo",99)] : Dict.Dict String number &gt; d |&gt; Dict.update "foo" (Maybe.map increment) Dict.fromList [("foo",100)] : Dict.Dict String number &gt; d |&gt; Dict.update "bar" (Maybe.map increment) Dict.fromList [("foo",99)] : Dict.Dict String number 
Maybe.map ((+) 100) |&gt; Maybe.withDefault 0 |&gt; Just
Working on an image management program in rust and elm. I have been working on it for about a year and right now im working on improving the visual design of the album page https://github.com/thezoq2/flash
Instead of looking towards far horizons (dependent types..), you can also just simply create a 'boxed' type yourself. e.g. create a new module called `Letter.elm` with code like this: module Letter exposing (Letter, fromChar, toChar) import Char type Letter = Letter Char fromChar : Char -&gt; Maybe Letter fromChar char = if Char.isLower char then Just (Letter char) else Nothing toChar : Letter -&gt; Char toChar (Letter letter) = letter -- other functions that work with your letter type Within that module, you know that the boxed `Char` is always in range `a-z`, as this is the only way to create a value of type `Letter` 
I'm using yours since it had the most stars and it was updated the most recently. You all should get together and consolidate though!
Here are the sets of values each type correspond to, along with their cardinality: - Empty type: `Never = {}`, `|Never| = 0` - Unit type: `() = {()}`, `|()| = 1` - Product type: `(Bool, ()) = {(False, ()), (True, ())}`, `|(Bool, ())| = |Bool| * |()| = 2 * 1 = 2` - Sum type: `Either Bool Bool = {Left False, Left True, Right False, Right True}`, `|Either Bool Bool| = |Bool| + |Bool| = 2 + 2 = 4` - Union type: `Bool U Bool = {False, True}`, `|Bool U Bool| = 2` What Elm calls union types are actually sum types.
Trying to write a parser for Elm type definitions using https://github.com/elm-tools/parser. WIP at https://github.com/mbylstra/elm-types-parser/
Don't quite understand it all, but is this what you're looking for? https://brianmckenna.org/blog/type_annotation_cofree
This is where unit tests make you happy, reload and retest 
&gt; So, to answer your question, ADT's are a kind of union Don't you mean the other way around, all union types are ADT's but not all ADT's are union types?
Wow, excellent demos. I suddenly feel compelled to write a game.
Thanks, now I have a name for it! Didn't think that adding information to an AST would be a common problem. My current solution is that I have "Spy" nodes that are just passthrough, but contain a type variable that will be assigned the type of the subtree starting at the Spy node. It will be interesting to see how other approaches compare.
Unit tests indeed make me happy, especially when triggered automatically on save. They have nothing to do with live reload, however.
Opinions differ on that
My understanding is that sum types are not the same as algebraic data types (ADT). An ADT is, in practice, made of sum types that contain inside product types. Sum types per se do not account for the fact that each "branch" of the sum type can have a different number of arguments that made its product type. I believe this definition can be found in "Types and programming language" by Benjamin Pierce while the definition of ADT can be found in "Advanced Topics in Types and Programming Languages" by the same author. I believe it's important to agree in the name and definition. Otherwise, the next thing is to call the lambda calculus something else because beginners do not know why it has the lambda word in there (my personal point of view)
Derp. [Star *this* repository.](https://github.com/rtfeldman/elm-spa-example)
While I agree that the RealWorld/Conduit Elm implementation is a wonderful and valuable repo, definitely star worthy, I don't like this kind of "let's star so we can be no. 1". 
if you try buildFriend : Person a -&gt; String -&gt; Friend buildFriend person email = { person | email = email } the compiler will throw an error because `a` is not the same `{a | email : String}` and `Person {a| email : String }` is not the same type as `Friend`. I see no way to implement what you want without explicitly building the return value. &gt; If not, where is the proper place to request this as a feature? [How to make a Feature Request](https://github.com/elm-lang/elm-compiler/blob/master/How%20to%20Request%20Features.md). 
A major argument against Elm adoption is its small community. Increasing its visibility in any way is probably good for users of Elm.
So Elm allows you to make Html out of a model, view, and update. Is there a way to combine multiple models, views, and updates, each with different types of model objects and msg, into the main app so that it can be more modular?
This sounds very useful. I bet it would be especially easy to implement in Elm since the state of the whole app can be easily serialized, we're probably just waiting on someone to step up and do it.
[create-elm-app](https://github.com/halfzebra/create-elm-app) apparently supports Hot Module Reloading (HMR). I haven't used it, but that's one of the features listed in the readme. I also used to use this repo as a starter kit, but it might be outdated: https://github.com/fluxxu/elm-hot-loader-starter
So grow the community by making consistent useful contributions. Not marketing bs
A mixture of both would be nice.
Thanks for the response! While elm is a whole language, it is seen as alternative to js frameworks. I think people should not have to choose a framework inside a language that is already somewhat of a barrier. Wouldn't creating a kit be the equivalent of creating frameworks in js? I think SPA's show elm's strengths best because you have everything typechecked compared to small snippets on various pages. I would argue that SPA's are such an important use case that the standard tools for building them should somewhat be promoted, but I am interested in different opinions. I agree with you on CSS, different approaches there and not much experience yet. Do you see very different approaches in how routing is handled? Actually very curious about that one.
Hi! thanks for the amazing work getting all these links together! Do you have any further updates on this matter? I'm experimenting a bit trying to embed an Ace editor inside an Elm app and going trough the ports route. It works, but feels quite dirty.
&gt; Wouldn't creating a kit be the equivalent of creating frameworks in js? Yes, it would be similar but this fate cannot be avoided. This being said, we don't need to go as crazy as JS. There are alternatives. For example, Phoenix is the default framework in Elixir. I'm hoping to see something similar in Elm. 
Thanks for the info.
Probably the best route now if you need custom autocomplete like this https://github.com/DenisKolodin/elm-ace/issues/5#issuecomment-302318469 is with ace-widget and you add it somewhere here https://github.com/LostInBrittany/ace-widget/blob/master/ace-widget.html#L195
Thanks for this, it's very elegant!
Had a look at Idris and it seems very cool but like every other functional language I've seen I can't understand it all. I've wanted to try to learn Haskell for a while now but Elm is the only functional language I've understood so far.
Yes. Imagine modules `Main`, `Foo` and `Bar`, each with their `init`, `update`, `view`, `Model`, `Msg` -- and in the case of `Html.program`, `subscriptions`. * Here's how the pattern would look for [**beginnerProgram**](https://gist.github.com/Janiczek/55761beea60bcfe1545bec02d5db7aff#file-beginnerprogram-elm) * and for [**program**](https://gist.github.com/Janiczek/55761beea60bcfe1545bec02d5db7aff#file-program-elm) (with `subscriptions`, `Cmd`s etc.) The key is: if you try to use the child's functions, the types won't match, because they emit different Msgs than the parent! You have to wrap the child `Msg`s in the parent `Msg` (with a new case of parent `Msg` and the `Cmd.map`, `Html.map`, `Sub.map` functions), and then in `update` if you see **that** `Msg`, unwrap it and use the child's update on that (because the parent otherwise doesn't know anything about them!)
I am just after a minimal example of loading the contents of locally stored text file into a String with Elm 0.18. Surprisingly, nothing obvious appears after searching. At this stage I don't need to do any JSON decoding. My attempt is below, but the result is always matched with `Err`, not `Ok`. The error message itself contains the body of the text file I want and yet reports a rather unhelpful error status `BadStatus { status = { code = 0, message = "" }`. All tested locally via `elm make`. *Edit:* When run via `elm reactor`, behaves as expected. Can I do anything within elm to ensure this works without running a local web server? module FileReader exposing (..) import Html exposing (Html, div, text) import Http main : Program Never Model Msg main = Html.program { init = init, view = view, update = update, subscriptions = subs } type alias Model = { content : String } init : ( Model, Cmd Msg ) init = ( Model "", loadFile "test.txt" ) loadFile : String -&gt; Cmd Msg loadFile filename = Http.send FileRead &lt;| Http.getString filename type Msg = FileRead (Result Http.Error String) update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of FileRead (Ok content) -&gt; ( { model | content = content }, Cmd.none ) FileRead (Err err) -&gt; ( { model | content = "Error: " ++ toString err }, Cmd.none ) view : Model -&gt; Html Msg view model = div [] [ text model.content ] subs : Model -&gt; Sub Msg subs model = Sub.none
Check out episodes 39 and 40 of Elm seeds, I recently went through them and then added hot module replacement with webpack to some of my Elm apps. It's been working great, this should address your pain point if you don't mind setting up webpack: https://elmseeds.thaterikperson.com/elm-webpack-extras
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of filename, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
When you try to get the contents of `filename`, you need to provide a full URL. Without a full URL, the browser will try to complete it by using the current host and the string you provided as a pathname. When you run this via `elm-reactor` or by opening the `index.html` with something like `live-server`, it works just fine but if you open the `index.html` file directly, it will not work as there will be no server to serve the requested file. 
Looks very nice! I think I like the separation between querying and decoding, although I'd have to actually play around with it to see how it feels.
Ahhh I see, thank you! Very cool!
I was just looking at this today, very cool.
Thanks! I agree, the library I saw was about writing .graphql files, or built decoders with the query. When I switched to GraphQL, all my decoders were already written. I don't see why rewrote custom types for GraphQL… I'm already using it, and I want to improve it, so if you think about something, don't hesitate to pm me! :)
I would like to add that it is not recommended to start writing your program with many models, updates, etc... Start as simple as possible with one `model`, one `update` and one `view`. You don't need to worry beforehand about the code base getting too big in the future. You don't need to start writing your code modular. You can modularize it later. Refactoring is easy in Elm. 
Really interesting to see how the Elm community's growing; thanks for running the survey and writing up the results /u/brnhx :)
I've seen some really encouraging benchmarks for `insertRule` approaches lately. Like I said, the idea definitely appeals to me, and the more success stories that roll out about people using it in large production systems without performance problems, the less concerned I get! I didn't know Glamor had the "speedy vs development" modes, but it makes great sense to me.
Well, your styles have to be handled separately unless you use something like elm-css, so that's already as "normal" as it gets. As far as HTML goes, yes, Elm, React and even the more template-y (syntax-wise) Vue.js are designed to be compiled into JavaScript. Are you sure they would need more than CSS to customize their looks? I mean... look at subreddit's styles as an example. Those are all done with just CSS. If they really do, then they'll need a programmer anyway. From where I see it, it shouldn't be hard for someone who already has HTML and CSS knowledge to learn how the view function works. It's the same thing with a different syntax. But of course, they'll need access to the source code and a compilation toolchain to work with it. Not sure what else to suggest you given the information you've provided.
Kinda amazing. Needs shadows!
Thanks! I've been working over the lighting a bit recently, and made a new library for composing shaders: [glsl-pasta](http://package.elm-lang.org/packages/kfish/glsl-pasta/latest). That makes it easy to apply the same lighting "pipeline" to different kinds of shaders. Here the terrain and sky use procedural shaders and the buggy uses textures, but everything gets the same lighting and colorshift/fog. Shadows would be fun, there has to be a cheap way to do shadow mapping ...
I have a function that is one of several updates I apply to my model (I'm writing a simulation): generateAndApplyActions : Model -&gt; Model generateAndApplyActions model = Which is a better implementation of this function?: let actions = generateActions model in applyActions actions model Or applyActions (generateActions model) model This declaration lets me write the appropriate case of the model update function as: Tick newTime -&gt; ( model |&gt; incNumTicks |&gt; generateAndApplyActions , Cmd.none ) But maybe I should write it differently. (Note that I think it is likely that I'll want to add 1 or 2 more functions to the tick update chain.)
This tripped me up as well when I started with Elm. I found the solution by looking through example projects, but I can't recall which one specifically showed this pattern. This would also be a good addition to the compiler error already generated in this situation. Something like `DoThing is not defined, but is exposed by Msg. You can import DoThing by exposing Msg(DoThing)`
Well done! I also play around with Elm's WebGL now and then, and I really love it. For shadows (and things like water) it would be very nice if Elm's WebGL implemented rendering to textures/framebuffers. I know there have been discussions about it on GitHub, but I'm not updated on the progress.
The shadows would be more than fun. They would provide a clear indicator of when the buggy is airborne.
Totally. You've got me thinking about how to implement shadows efficiently. The usual techniques involve offscreen rendering, like what's described at http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/
Haha, still using my awful elm logo texture ;) Apart from that, you did a pretty amazing job! Unfortunately it is a bit laggy, what do you think is the biggest bottleneck?
Hey :) I like your logo texture, it makes everything subtly elm-ish. The lag goes down a bit with simpler models and worlds -- that buggy has about 20,000 polygons, and the terrain also has thousands. Chrome GC kicks in every 10s or so and there's a small stall. I should go back and check the mesh caching again though.
Thank you!! I've been trying to figure this out for a long time. Really wish it was more clear in the documentation :(
Thank you!
Glad to have helped! (btw I've edited the gist - forgot `Cmd.map` in the `init` function.)
Thanks to ilias and norpan on Slack I found out that it is not possible to set CSS variables in Elm. Relevant discussion: [virtual-dom: Changing way styles are applied to allow for custom properties #44 ](https://github.com/elm-lang/virtual-dom/pull/44)
Hey, nice reads. Currently I am also evaluating Elm, so that I can introduce it to my team. If you don't mind, a few questions: 1. Why Elm, and not purescript or rather GHCjs? 2. I have found Elm to have a Java-esque boilerplate problem, it takes a lot of code to even write a simple page (This makes it a hard-sell to coworkers). Are there any solutions to that? (Like Spring for Java)
Great article. I am considering to learn Elm, and try out a few side projects. I might take it to production based on my experience. In addition to the points raised in the article (which were mostly positive throughout which is nice) I'd like to know your views on some more aspects. Foreword: I'm sure you have a quite positive feeling about using Elm and I feel so too. I'd like to point out that the following questions might be just a bit critical, and I am strictly them asking for improving my own knowledge and opinion. * How confident would you feel about untested elm code? How often did you have to think about testing and how much time did you have to spend on it? * Apart from the debugger, how easy is testing in general? Any tools which you found really helpful? * How diverse can solving a problem get? Is code written in other approaches easy to understand? (This is one problem I see in using scala.js) * How easily do your engineer get ramped up for production ready code? * How easy is to find developers who would like to work in Elm? * Do any of your engineers who have a strong background in React/other frameworks feel that it's better to rewrite the site in their framework? Why (not)? * Do you feel the lack of npm packages a pain / an inconvenience / or are you indifferent? 
1. Purescript is essentially Haskell for the browser. I never managed to get past the monad is just a monoid in the category of endofunctors part of Haskell. Elm is written for those with no prior experience with functional programming, and it shows. It's much easier to learn, and teach to others. 2. Any examples? I don't really find Elm to have a lot of boiler plate compared to other languages/frameworks.
1. Much better than untested javascript or java, thanks to the type system. 2. elm-test is, in my experience, the best library for unit testing that i've used. 3. Elm has little syntax. Code formatting is mostly dictated by elm-format, and there's very little way around the elm architecture. As a result, most Elm code tend to look the same, which makes it easier to read other peoples code. Elm is better at this than many others. 4. - 5. - 6. When I use React, I naturally try to write my application as if I were writing Elm. The benefits of Elm in reliability are hard to exceed. 7. Mostly indifferent. Whenever I need a JS package i have to write the wrapper myself, or download code from github. This is a pain, but the benefits (i can generally trust whatever's in elm-package) is worth it.
Having done elm at work for about a year now I think I can chime in on the boilerplate question. There's generally 3 kinds of extraneous code I encounter, and I want to mention them because the bolierplate you refer to might be an instance of any one: 1. **Code written while solving a problem the first time, which you later realize is totally redundant.** It's surprising how much this happens when you're starting out! I would often golf things down a bit and be flabbergasted how my formerly 50 line function was actually just 4 or 5 lines 2. **Boilerplate needed to compose multiple (init, view, update) triplets.** There is boilerplate here, but it's a fair price to pay for totally sound composition of stateful components. The thing to realize is that very few UI components in your app will map 1-1 to such a triplet. [Richard's talk here](https://youtu.be/DoA4Txr4GUs) explains the intuition behind choosing the right modularity technique for the job 3. **Boilerplate JSON decoders/encoders and fuzzers.** Probably the most annoying thing to have to write every time you want to get data over the network. Until the compiler is somehow able to generate defaults for you, external code generation tools [like json-2-elm](http://noredink.github.io/json-to-elm/) are the best you can do. 
I'd argue the category theory jargon is unnecessary for understanding monads (or functor, or applicative) - it makes sense as you use them more and more. They're a surprisingly simple concept actually, just at a different level of abstraction than you may be used to. Don't get turned off by the apparent pretention, just build things until it clicks. If you can wrap your head around what a functor is and why it's useful, you can definitely get monads too.
&gt; This means that many Component.js files are being generated and included in a single page. This is inefficient. Compile all the components into a single file. elm-make ComponentOne.elm ComponentTwo.elm ... ComponentN.elm --output= app.js and then in your Javascript mount the components like this: Elm.ComponentOne.embed(nodeForComponentOne); Elm.ComponentTwo.embed(nodeForComponentTwo); This way you get everything with one server call and is also size optimized. 
Well... not with that attitude! :) Joking aside, while it might not be possible to recreate the inline variant with current version of the VirtualDom, you can use [a temporary class and a `style` node. ](https://ellie-app.com/3TqZ5S3pGyQa1/0)
Agreed, but the fact is that every book and/or tutorial tries to teach you what a monad is. Elm just says, "Here is a function called andThen. It works like this: ..." Which is much easier to learn.
Thank you! I totally agree with your last warning, and it's so important it's worth repeating: beware of a crucial dependency on a 3rd party library that might not be maintained. In the last upgrade cycle between 0.17 and 0.18 I waited 3 months before upgrading my Elm apps so that the 3rd part libraries I depended on (like elm-mdl) were bumped to 0.18 - and there were a few nail-biting weeks where it looked like it might not even happen. I Also totally agree with your points on the difficulty of JSON decoding and obtaining real time element metrics - I wish it were easier.
Regarding item 2, OP's article does say that sometimes Elm makes easy things hard, for instance JSON decoding.
That doesn't necessarily mean more boilerplate though. In my experience, I often need custom decoders/encoders for JSON, as the models I use in my application, rarely matches what things look like on the backend.
&gt;How confident would you feel about untested elm code? How often did you have to think about testing and how much time did you have to spend on it? More confident than any other language I have written code in. Features that come about as a result of the type system: exhaustiveness checks, JSON and port type safety, etc. result in a lot more confidence when writing code. I would say that writing Elm is a substantial departure from writing something like a jQuery-based application, where you frequently feel the need to reload the page and run the application. With Elm you have an extra layer of assurance that if your program compiles, it probably works close to the way you intend it to. It's not uncommon to write for 30+ minutes without refreshing the page. &gt;Apart from the debugger, how easy is testing in general? Any tools which you found really helpful? The debugger, using `Debug.log`, and the [elm-test](http://package.elm-lang.org/packages/elm-community/elm-test/latest) library come together to give you an entire suite of useful testing tools. I personally do not at all see the need for 100% code coverage in a language like Elm, and at most companies, I do not think blowing up the amount of time a project takes in pursuit of that makes any sense. It's there if you need it, and I recommend using it strategically. &gt;How diverse can solving a problem get? Is code written in other approaches easy to understand? (This is one problem I see in using scala.js) As others have said, Elm has a limited syntax. Usually there is only one way to do or write something. This makes reading and understanding what a piece of Elm code is doing really easy. This is quite different from a language like Haskell, where typeclasses and a larger core syntax make you have to study the code before understanding what it does. &gt;How easily do your engineer get ramped up for production ready code? Like I said, it was not too difficult. Pair programming for a few days and doing a lot of explaining in the process will help them get productive sooner than one might think. I cover this in the "Teaching Elm" section of my post. &gt;How easy is to find developers who would like to work in Elm? We have not hired any engineers since starting Elm, so I cannot say for sure. But my guess is that it is quite difficult to find Elm developers. I think it is easy to find people interested in learning Elm, and easy to train developers that already have front end experience to become proficient with Elm. I will say that ultimately my company and my team is relatively small. If you have a 2,000 person company with 400 engineers, this approach may not work for you. &gt;Do any of your engineers who have a strong background in React/other frameworks feel that it's better to rewrite the site in their framework? Why (not)? Nobody had substantial experience with other frameworks. As mentioned, I think you would be hard pressed to get the same level of reliability in any other framework. &gt;Do you feel the lack of npm packages a pain / an inconvenience / or are you indifferent? We have found Elm packages for the basic utilities that we needed. Our strategy had never been to flood our projects with external packages, so I am fairly indifferent. Ultimately if you need NPM packages, you can use ports to do JavaScript interop.
Thank you very much. I think you are exactly right (and my experience building whitelabel w/ react at my previous job reinforces your answer) about styling the alternate versions of a component. **If I, as the library author, write well structured DOM for a component with appropriate classNaming conventions (BEM modified) a third party should be able to style the component any way they want while retaining functionality without any changes to the DOM.** I've ran into issues styling other people's components but they didn't have a good DOM and classNames structure. I don't want to *ignore* my team's pushback about a third party being able to provide their own DOM for a component, but I have been able to push back on this as "gold plating" that we should figure out a solution for when we have a customer requesting the need. By then hopefully we've moved away from MeteorJS (Isobuild) too and we can implement a webpack strategy to load specialized versions of components for particular clients (the way we did it at my last company). None of these strategies provide a solution where a third party can provide us html/templating to copy/paste to form a new component. I hope to figure out a way of doing this type of strategy w/ compiled JS frameworks (react/elm) because there are obvious adoption cost advantages which are sold much easier to mid-market companies than high-tech langs.
Thank you for the work-around! I will consider it. :)
Anyone who says you need to understand category theory to use monads is silly. Monads are just a generic way of mapping items inside containers.
&gt; I never managed to get past the monad is just a monoid in the category of endofunctors part of Haskell. Are you saying there is actually a resource you were trying to learn from that presented this statement as relevant to learning Haskell? It isn't at all. Monad as a programming concept doesn't entail learning *any* of these category theory concepts or terminology. It just requires understanding how to read type signatures, which is not so different to what Elm requires. I suppose this statement is maybe meant as a joke. Its common one about Haskell, but its also a pretty harmful one.
It's a joke. It's from LYAH, where it's also meant as a joke, but incidently it's not long after that statement which marks the place where I stop reading it. What I actually meant was that every time I got to a point in a Haskell book where an abstract concept like Monads was being explained, things just got confusing or boring, so I closed the book and meant to get back to it, but instead ended up learning a new Clojure-library or some such as I found it more fun. Never had this problem with Elm. Just kept reading about it til I could write actual applications with it, and that took the lesser part of a weekend. That could be because I'm a frontend developer, though, and that's what Elm targets.
I'm up against a problem which feels like it should have a _very simple_ solution, but I'm struggling to find it: I have a video element which autoplays and I'd like to present the user with a replay button once the video has ended. In order to have the replay button _displayed_, I've had to add a new datatype (`VideoState`), `Action` data constructor, update function, include my Model in my view module in order to pass the appropriate `VideoState` through to `update`, etc. and it feels like things are getting messy ... and this is only half of the solution! In order to allow for the desired behavior, the consensus seems to be that I need to create a subscription and pass another out to JS-land, which will have a subscriber which traverses the DOM, finds the video and triggers the replay. Can that really be? Is anyone aware of a simpler solution to either half of this problem? Thanks in advance!
&gt;Why Elm, and not purescript or rather GHCjs? Elm has many aspects that make it a more appealing candidate over the Haskell/PureScript for a front end option: * The learning curve is far more gentle; better for developers that have little-to-no FP experience. * UI libraries are more developed. I read that GHCjs is lacking in this area. * The community is focused on using Elm for front end development, so one is more likely to find other people/posts/resources that have faced or address the exact same problem(s). * Performance of Elm is very good. I read that performance of PureScript is not great. &gt; I have found Elm to have a Java-esque boilerplate problem, it takes a lot of code to even write a simple page (This makes it a hard-sell to coworkers). I think that starting an application may feel that way due to the need to set up the initial Model-Update-View boilerplate. But once you get past that point, I think the amount of code you have to write is quite reasonable. The Haskell-like syntax makes individual lines rather short. Things like pattern matching with `_` and using pipeline syntax... startingValue |&gt; func1 |&gt; func2 |&gt; func3 ...are both examples of syntax that lead to to relatively concise code. I certainly prefer it over writing nested callbacks in JavaScript. Ultimately I think it is a matter of opinion, but I certainly do not thing that Elm has anywhere near the amount of boilerplate that Java does.
&gt; Why Elm, and not purescript or rather GHCjs? You will have to deal with the time it takes to get a new developer up and running with the language and with the implementation of a complex app in the language. I have not developed in Haskell variants to a reasonable degree but from what I saw, people without formal FP education find Elm much more approachable. You could say that it is more beginner friendly without losing all the power in the process. It implements the 20% that produces the 80% of the benefits quite well. &gt; I have found Elm to have a Java-esque boilerplate problem, it takes a lot of code to even write a simple page (This makes it a hard-sell to coworkers). Are there any solutions to that? (Like Spring for Java) I have no idea what kind of boilerplate you have encountered but I found that structuring the code of the project in a sane manner (something like the [elm-spa-example](https://github.com/rtfeldman/elm-spa-example) ) can alleviate some of the pain. There is no framework yet but who knows... maybe some company will create one (kinda like what 37signals did with Ruby on Rails). 
If the replay button is not displayed conditionally (ie. is there all the time and can be pressed anytime), you don't have to add anything to the `Model`, `VideoState`, etc. Just have a `Msg` (or, as you say, `Action`) and in `update` call your port's `Cmd`. In JS-land, in the subscribed callback that will run, do const video = document.getElementById("video"); video.currentTime = 0; video.play(); (This assumes the video has id `"#video`.) If you need to show the button only at some cases, you'll have to have the `VideoState` in `Model`, so that `view` can decide whether or not to display it, disable it, etc.
1) What's the problem? ;-)
You should probably just say they are space suits filled with nuclear radiation... That's not what a monad is any more than if I where to say a refrigerator is a tool for keeping cheese cold. That may be an important and notable example of what my fridge does, but it is so narrow in view as to be misleading. And that's also not to say monads are mysterious arcane things any more so than my fridge.
Sounds to me like you're confirming I'm on the _golden path_. Thanks for the reply. :)
An integration for Elm with Angular 1.x: https://github.com/basti1302/elm-angularjs-integration It allows you to embed AngularJS 1.x directives into your Elm application (which, in turn might be embedded in a larger AngularJS app). It also keeps the values in your Elm model in synch with the values in AngularJS' scope for the embedded directives, giving you kind of a two way data binding between Elm and AngularJS. Motivation: My customer has a huge AngularJS 1.x app and I've introduced Elm into the code base for a rather big new feature. It has worked out pretty neatly, but we want to reduce some of the more fancy input widgets that are implemented as AngularJS directives, instead of reimplementing them from scratch. Right now I'm in the process of extracting the solution I have come up with in this customer project into an open source project. Obviously it uses native code to do its thing so I will not be able to publish it to the package registry. It's still in an early stage, but feedback is most welcome.
Not this week, but I just did Ludum Dare and got a nice [game](https://keui.itch.io/mystic-power) out of it. [Source](https://github.com/Seurimas/ludumdare39)
I didn't write the article, but for my money: *Why Elm, and not purescript or rather GHCjs?* 1. Simplicity. Among these three, Elm most embodies the design philosophy of "perfection is when there is nothing left to take away." That really resonates with me. 2. Sandboxed JS interop. There is "JS land" and "Elm land" and the two are kept totally separate. I can trust that the invariants in Elm land actually hold, because JS is not allowed to sneak in. This gives me much less to keep in my head when debugging. 3. Preventing runtime exceptions. All three languages share a common approach to type inference and side effects, but Elm's core library design is the most aggressive about ruling out runtime exceptions. 4. Onboarding. There is much less to learn to get someone productive in Elm compared to the other two. We've hired several people straight out of coding bootcamps who were writing production Elm in their first week. *I have found Elm to have a Java-esque boilerplate problem, it takes a lot of code to even write a simple page (This makes it a hard-sell to coworkers). Are there any solutions to that? (Like Spring for Java)* My advice would be to think back on all the programming systems you've used. Which ones scaled the best? Which ones did you like using the most? Which ones had the deepest debugging rabbit-holes? Which ones felt like they had the most boilerplate? Things like that. When I did this exercise, I spotted a common trend: "reduced time spent writing boilerplate" in almost all cases implied "increased time spent debugging." 9 times out of 10 the magic saves me 5 minutes, and then the 10th time the magic eats my entire weekend by obscuring the root cause of an edge case bug. I write that weekend off as an outlier and move on like it hadn't happened. At some point I made a decision not to live like that anymore. I now embrace explicitness over magic, and treat anything that claims to "reduce boilerplate" with extreme skepticism. Anecdotally, I've noticed I spend a bit more time copying and pasting than I used to, and *much* less time debugging. Your mileage may vary. :)
I am working on a new product that would be a weekly Elm exercise. It would be a mailing list and problem sent out on Tuesday, solution on Friday. 
Not sure if 0 to 100, but I've got these links I've saved in the past. They might help: + Elm for Beginners (http://courses.knowthen.com/courses/elm-for-beginners) + Elm Beyond the Basics (http://courses.knowthen.com/courses/elm-beyond-the-basics) + A Sufficiently Complex Elm Application (https://hackernoon.com/a-sufficiently-complex-elm-application-c457d4373291) + Making Pong - An Intro to Games in Elm (http://elm-lang.org/blog/making-pong) + Tour of an open source Elm app (https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa) + 25 Elm examples (from a simple view to an interactive app) (https://github.com/bryanjenningz/25-elm-examples) + Elm codebase containing real world examples (CRUD, auth, advanced patterns, etc) that adheres to the RealWorld spec and API. (https://github.com/rtfeldman/elm-spa-example)
Curious why https://guide.elm-lang.org/ did not make your list. What did you think about it?
This example is perplexing to me. Why not write: div [ style [ ("margin", "10rem") ] ] [ text "I have margin 10rem." ] Elm gives you the ability to create variables already. Why exit the world of "all variable names are verified by the compiler" to do things you can already do?
Fair observation! I am specifically porting a CSS/JS library to Elm. I rewrite the JS but keep the CSS (and use class names in Elm). That CSS library uses CSS variables for theming (colors) and layouting (gutter width), they are also used in some animations. So Elm supporting it would be a huge time saver for me because I can continue not to rewrite CSS.
Thank you for such a comprehensive list! I'm excited to learn elm, but I must say, this language (at least in my use case?) has a shit ton of boilerplate in encoders, decoders, and types, and it's harshing my mellow a little bit. Maybe I'm just spoiled and used to Clojure making ```{:key1 "val1" :key2 "val2"}``` the extent of my effort in terms of data structures, but wow that bit of elm seems unappealing.
A videogame based off the open source game from [https://github.com/Viir/Baustelle/](https://github.com/Viir/Baustelle/) [Screenshot](http://i.imgur.com/dEnLgzt.png) Today, I mainly worked on improving the games UI, adapting it to findings from a recent playtest.
You gotta give it time to sink in my friend! Can't speak to the clojure experience, but in elm, once you can comfortably let the type defs guide your thinking about the code, it opens up a whole new world of programming. Decoders/encoders become a minor price to pay for entry
On the workflow side, here's my setup * atom + linter-elm-make + gets you on-the-fly type checking and inline type errors * elm-format (with its atom plugin) formats your code on save: you can barf out a whole stanza on a single line and it will just comfortably click into place. * elm-live will reload your app on save, much more lightweight than webpack at the cost of hot reloading (still not sure if the elm hot reloading solutions even work well tho) * elmjutsu is an atom plugin with a grab bag of features: autocomplete based on imports, import automation, and a bunch of language-specific niceties 
I installed that mix of atom plugins and it ended up *horrifically* broken, I think the formatter was freaking out because lines kept endlessly duplicating. Currently stumbling through VSCode, I might try and see how Emacs looks.
Started switching one of my Wordpress sites to Elm. It's got like 50 plugins so this is a pretty nice speed boost, 4-10x for the initial loads &amp; up to 20x for intra-Elm page loads :) https://github.com/Fellowship-Of-Intentional-Community/Wordpress-Theme/tree/master/src/Directory Old: http://theme.staging.ic.org/directory/listings/ New: http://staging.ic.org/directory/listings/
Hey, while I agree with most of what you have said, what I really meant with the boilerplate problem is this: Haskell has next to no boilerplate, Java has too much, and Haskell is actually more safer than Java and performs just as well if not better. What I am trying to say is what safety and boilerplate need not always be together, you can have one without the other.
/u/voodah already linked to my sufficiently complex Elm app but if you're interested in another example I [rewrote the thoughtworks tech radar in elm](https://hackernoon.com/rewriting-the-thoughtworks-tech-radar-in-elm-41a4e8244a13). It only comes to mind because I mention going from "0-60" a couple of times so perhaps it's the kind of resource you're interested in. Let me know if you have any questions.
I've been watching Daily Drip and listening to the Elm Town podcast. I think you can still use the code "ELMTOWN" to get the Daily Drip videos for free. 
It was great. It's not there just because I didn't have it bookmarked, probably because it's the first thing you look at when starting Elm. But yes, for sure, the guide and the Elm Architecture section are textbook must-read and should definitely be there.
&gt; &gt; &gt; Making Pong - An Intro to Games in Elm (http://elm-lang.org/blog/making-pong) This appears to be written for an old version of Elm, that uses the Signal model that was [removed in Elm 0.17](http://elm-lang.org/blog/farewell-to-frp) in 2016. (And indeed, it was written in 2012). Now I wonder, is there a way to use old libraries, based on Signal, with current Elm?
I did not use the term boilerplate in my post for a reason. Decoding JSON is hard. There's definitely quite a bit of a learning curve or you would not see so many posts/articles/books teaching how to work with JSON. All that being said, I think that much of the code is fairly necessary for the reason you describe.
Making some tools for debugging things: - [elm-debug-decoders](https://www.npmjs.com/package/elm-debug-decoders), a tool that will generate a testing file based on all the decoders you expose in your project. You can then put in JSON into a web UI, and it will show you which JSON decoders pass! Here's a [gif](https://twitter.com/eeue56/status/892548631160606720) - A package for producing user-readable errors for HTTP failures: [elm-http-error-view](http://package.elm-lang.org/packages/eeue56/elm-http-error-view/latest) - A view for debugging JSON loaded from a URL against a decoder: [elm-debug-json-view](http://package.elm-lang.org/packages/eeue56/elm-debug-json-view/1.0.0)
I want to answer you from the perspective of someone who is trying to do the same thing. I have a couple of points. Starting with **workflow**. I think one or two things are crucial, but don't obsess over tooling. In order of importance: 1. elm-reactor. Just have it running and you can refresh the page of your app to recompile. It's amazing 2. elm-format should be hooked into your editor, so that your code is formatted every time you save. It's hard to overstate how much bikeshedding this avoids. It's so great. 3. Use (almost) whichever editor you are comfortable with. Seriously, 1. and 2. already make more complicated plugins obsolete. I can recommend Visual Studio Code (on any platform) with the elm plugin. Vim is great too, and I assume so is Emacs. 4. Maybe elm-repl in a terminal is nice sometimes, but honestly, I don't need to have it integrated in my text editor because a) the compiler helps you so much and b) you can always load a module in a standalone repl instance. In short, yes, good elm tooling exists, adn you can keep it simple at the same time. For **learning resources** I have a couple of observations: - The state of tutorials is definitely not yet up to par with languages that have been around longer. Example: You still find stuff using FRP, which Elm has ditched in 0.17. So I have not yet had this feeling I have with other languages where "how to do X in Elm" consistently leads you to a good StackOverflow answer. I'm sure it will get there, but for now you have to take a different approach. Medium posts so far are pretty rubbish too on average. - Elm is very readable **and** by its very nature, written in a very modular style. This has a huge implication: whenever you find a project that is approximately in your domain, chances are that it contains a lot of good code that closely applies to what you want to do. Plus the different domains Elm is used for are not that numerous anyway, so triple-win. - You can quickly gauge what libraries are useful, but you can get away with not using that many actually. This part I'm still learning myself. Sorry for the wall of text, I will refrain for infodumping more stuff, unless you maybe want to specify which kind of site you want to build. But it sounds like you're on the right track. Maybe just read the code that is currently running elm-lang.org? It's on github: https://github.com/elm-lang/elm-lang.org/
Can you provide more information about your use-case? For example, what are you using this for? 
If it's a binary choice of "has thing" and "doesn't have thing", I'd go with Maybe. Keeps code vertically shorter when reading the union types and case-of branch handling; specially when you account in the latter for elm-format's added blank lines and for those case-ofs when you only care that the value changed, but not the value itself (dumb example: firing a small pop-up that says "action successful!").
&gt; Now I wonder, is there a way to use old libraries, based on Signal, with current Elm? [You can easily update the Pong example and make it work without Signals](https://ellie-app.com/3VzPwKLZTHDa1/0)
There should probably be a disclaimer in the article saying it's outdated, perhaps linking to your code :) The intended audience of that article probably wouldn't be able to convert the code.
I also think that if it represents a value that can either be there or not the `Maybe` is the best choice (shorter and easier to handle). If you have several interactions depending on that value though, I'd consider the separate message to keep it more readable. It really depends on what the `Maybe` state triggers.
In my opinion the latter option (`ItemDeselected` and `ItemSelected Item`) is more readable. (I don't really care for vertical bloatness :) )
Components/views are pure functions, you'll need to pass the width as a parameter from a parent component or an elm 'port' to get the external/impure data/global state etc
So this line in question? https://github.com/palantir/blueprint/blob/master/packages/core/src/components/slider/coreSlider.tsx#L202 const tickSize = this.trackElement.clientWidth / (this.props.max - this.props.min); Is using a ref. https://github.com/palantir/blueprint/blob/master/packages/core/src/components/slider/coreSlider.tsx#L108 &lt;div className={`${Classes.SLIDER}-track`} ref={this.refHandlers.track} /&gt; Refs are impure, because they come from the DOM, and the element has not been passed in via the arguments to the pure function. The DOM could be in any unknown state. As an alternative, to determine the tick size / width, you would pass it as an argument. Or the values to calculate it. Those values could be dynamic and not fixed, they would be calculated from some state. Like the container component width, or viewport width from an elm port. The dynamic values could be updated by a subscription, and the component would then be re-rendered with the new values.
Technically you are right but one does not need to leak this kind of an implementation detail onto the user of the library. If `Html.Events` would expose some kind of `onSize`event handler, the component could manage its own width without the user of the component being involved beyond the minimal boilerplate required to mount the widget into the Elm Architecture. 
Regarding whether there is a way to do this in Elm depends. I am aware of the following ways to approach problems like this: - As you did, you are making the `clientWidth` a parameter to `view`. I feel like this is transferring the problem to the user of the component tho. - Another possibility is to [use ports](https://guide.elm-lang.org/interop/javascript.html): the component could issue a Cmd to query the DOM. This solves the problem within the component, but it requires the user to set up boilerplate for ports. - Yet another possibility is to use Decoders to query the DOM ([excellent! blog post](https://medium.com/@debois/elm-the-dom-8c9883190d20), [accompanying package](http://package.elm-lang.org/packages/debois/elm-dom/latest)). This solves the problem within the component; and still requires boilerplate to be set up. But as it does not require ports, you can encapsulate this in a library better.
Thank you for pointing me towards the elm-dom library. From the look of it I could determine the `clientWidth` on each of my drag events and use this in place of the static width.
I try to keep Actions/Msgs at the "User Intentions and Communication with External Systems" level of abstraction as much as possible. I feel that it helps re-grok code you've written a month ago when the semantics of the data constructors match what you expect the user/server/port wants you to do. This leads me to prefer option two
[quicktype](https://elm.quicktype.io) infers types from JSON sample data, then outputs types, decoders, and encoders for Elm (and Go, and C#). This is a new project, and we would love to read your feedback. Is this useful to you? What can we improve?
Sure, but it's a relatively simple use case and is probably similar to what you've already got in mind, given the code listed above. In my application, a video can be _selected_ from a menu, at which point it populates the `selectedVideo` slot with `Just Video`. After a video has been selected, an overlay appears and the video begins playing. When the video is _deselected_ (via a close overlay button, esc key, etc.), the overlay disappears.
Disclaimer, I'm the author of [json-to-elm](http://json2elm.com), an Elm version of this tooling that has existed for a while now. Features that json-to-elm has that this does not: - Specify what type of decoders you want to generate - Upgrade decoders from normal to pipeline - Upgrade decoders from different versions of Elm - Take type aliases and union types and generate things from that. - Generate an English explanation. Some things that quicktype do better: - Looks really good (visually) - Generates nullables nicely Some things that quicktype do worse: - use of underscores in names make for non-standard code - Importing things as a format I've never seen anywhere else in Elm before (Jenc, Jpipe) - Naming things in a very strange way (enc__thing should be encodeThing) Still, cool that you made this, it's really great to see Elm get more support on different platforms like this. One piece of advice I would give is to focus more on making idiomatic code. Generators like json-to-elm and quicktype should only get you "half way" and reduce the amount of boilerplate you need, rather than being "perfect".
Thank you for your feedback. We do plan to make the output nicer and more idiomatic. The reason for these weird names right now is to avoid naming conflicts (which json-to-elm doesn't do, btw). Our main goal is to generate complete definitions and decoders, and the code we produce ultimately isn't meant to be human-maintained (just like the output of a parser generator, for example). That means we also need to handle a lot more cases where json-to-elm just defers to the human by outputting `ComplexType`. We know that right now we haven't quite achieved that goal yet, and we'll have to give the user ways to override cases where we don't infer the types yet, or our naming is off. All of that is coming, but we think quicktype is still quite useful in its current state.
&gt; We do plan to make the output nicer and more idiomatic. The reason for these weird names right now is to avoid naming conflicts (which json-to-elm doesn't do, btw). Actually, json-to-elm does avoid naming conflicts. Can you produce an example that doesn't? &gt; Our main goal is to generate complete definitions and decoders, and the code we produce ultimately isn't meant to be human-maintained (just like the output of a parser generator, for example). That means we also need to handle a lot more cases where json-to-elm just defers to the human by outputting ComplexType. If you wish to provide a way of generating code that isn't going to be maintained by a human, then you need to provide a CLI version. json-to-elm _intentionally_ generates only 90% of the way -- it is not meant to be consumed in the same way as yours :)
&gt; Actually, json-to-elm does avoid naming conflicts. Can you produce an example that doesn't? {"import": 123} &gt; If you wish to provide a way of generating code that isn't going to be maintained by a human, then you need to provide a CLI version. We [do have a CLI](http://blog.quicktype.io/2017/go).
&gt; {"import": 123} In those cases, it is up to the developer how to rename :) Hence why it should only be 90% of the way -- rather than 1-to-1. &gt; We do have a CLI. Neat! I would make it more obvious on the site, that would help a bunch.
I would go with Maybe. Your union type is almost identical to Maybe's but with a different name. If you keep it as a Maybe, then you have access to all the Maybe helper functions. 
The helper functions could be in a module?
What if the compiler generate automatic ADT list when there is no args (and others) the same way it generates automatically type constructor functions? type Laugh = Haha | Rsrs | Kkkk &gt; Laugh.list [ Haha, Rsrs, Kkkk ]
Maybe they should be.
That might be useful, but would not be sufficient at all.
It would be really useful if the [Elm package](https://hackage.haskell.org/package/Elm) exposed its AST and pretty printer in the first place.
That would be useful and help quite a few situations. 
Not sufficient for what? It would help in the places where I'd use elm-cog enum. 
Yea that would be better. 
Just saying "enum" is only one use case. "ord" comes first to my mind, but they are a lot of them (just see what typeclasses are used for in Haskell).
Gotcha. My point is largely that we shouldn't let perfect be the enemy of good. 
Found the 🇧🇷😉
I love it, it's insanely useful :-)
Thank you, we really appreciate it. We have quite a few improvements landing later today. Please let us know what your pain points are, and what kinds of features you'd like to see.
The best means of getting up to speed with elm (from "0" to...) is [Building Web Apps with Elm](https://pragmaticstudio.com/courses/elm), by Pragmatic Studio. I'm not affiliated, just a fan of the recent work that the Clarks have been publishing. Absolutely worth every penny. For example, the workflow and toolchain that Mike uses in the very first few lessons is a very productive one (also echoed by others in this thread). It provides the fundamentals, but also commentary on _why_ Elm is structured the way it is, or _why_ some things work the way they do. It also provides numerous exercises, for you to apply what you're learning and really internalize a lot of Elm. I found this resource to be critical in learning Elm. (BTW, the Elixir course is pretty damn good too. I believe they may have a bundle discount.) 
We just deployed a couple of improvements based on the feedback we got. Please [check it out](https://elm.quicktype.io/)!
❤️
The best is yet to come. :) Enjoy your learning experience! 
If you love the pipe operator and looking for a new backend language , try elixir: [elixir pipe](http://imgur.com/a/mz5ak) Sorry for hi-jacking, but one of the reasons I stumbled upon Elm was because I loved the pipe operator so much in Elixir and wanted to use that in the front end.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/EPelpo5.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dl8zzg8) 
And F#. And OCaml. Heck, I used it yesterday in Idris.
In case anyone is learning haskell and wishing there was a similar concept check out the &amp; operator in Data.Function (https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Function.html#v:-38-) Love both Elm and Haskell! My favorite langs.
If you're looking for the same idea in good ol' javascript, http://ramdajs.com/docs/#pipe https://lodash.com/docs/4.17.4#flowRight https://sanctuary.js.org/#pipe and of course you can get pretty far with the built in array prototype methods. return myString .split(" ") .sort(sortFn) .join("-")
Hi, I'm working on my first SPA in Elm (getting inspired by Richard Feldman's SPA example). And I'm struggling to make my Main model synchronised with the model from a page. To give more context, my app is basically a todo-list, including the *Tasks* page and the *Archives* page. *Tasks* only includes ongoing tasks (not done), and *Archives* only includes tasks marked as done. So my idea was having *Main.Model* containing all tasks, *Tasks.Model* being populated only with ongoing tasks, and *Archives.Model* only with done tasks. In other words when *currentPage* is *Tasks*, we would initialize its model with *List.filter (\t -&gt; not t.done) mainModel.tasks* (and naturally, *List.filter (\t -&gt; t.done) mainModel.tasks* for the *Archives* page). The problem comes when updating a task inside the *Tasks* page: it updates *Tasks.Model.tasks*, but I can't think of a proper way to update *Main.Model.tasks* as well. I've come up with several ideas, but I'm not sure about any: * Pass all *tasks* to each page, and filter *done/not-done* inside the page. Then copy *tasksModel.tasks* into *mainModel.tasks* during *Main.update* when msg is *TasksMsg* (probably the easiest way, but it leaks too much data &amp; logic into pages). * Use ExternalCmd to propagate the updates towards *Main*, and handle them in *Main* too (but it feels like duplicating the logic). * Use server-side as single-source of truth and reload the data every time (but it kinda defeats the purpose of Elm, and generates a lot of requests). * Do not even store *tasks* in *Main.Model* and use ExternalCmd to communicate updates from *Tasks* to *Main*, which then spreads the message to *Archives*. That sounds like an Observer/Observable pattern, with Main playing as the dispatcher. It's my favorite option so far, but I'd like to hear feedback about it. Thanks!
One difference is that Elm pipes the result of the previous operation to the end of the argument list, whereas Elixir pipes the result of the prev operation to the front of the list. I thought the Elixir version was a little odd, until I realized that if you squint a little, it becomes a bit like the dot operator for method invocation, like the way Python and Lua makes "self" the first argument for method invocation.
Also see [Flow](http://taylor.fausak.me/flow/)
never underestimate the power of pipes... esp for ppl who first see them in use : )
Behind the scenes `toString` does a `typeof *yourVariable*` to determine what it is and how to convert it to a string. For instance, `toString 33` is basically doing something along the lines of switch (typeof *yourVariable*) { case 'number': // Convert number to string return yourVariable + ''; ... other cases for different data types like arrays, objects, booleans etc. } Going **String -&gt; whatever** is much more complicated and error prone than going **whatever -&gt; String**. On top of that, you pretty much always have some kind of expectation of what the string *should* be converted into. That's why we have special functions for all of these cases. I.e. `String.toInt`, `String.toFloat`, `String.toList` and then JSON decoders for the more complicated structures. It sounds like a JSON decoder is what you need in your case.
For me it was the opposite, Elm pipe was weird. I think it's because Elixir's pipe allows a more "builder pattern" coding whereas Elm is by leveraging parcial functions, and coming from OO, Elixir's pipe is more readable.
You seem to have discovered that lists in functional languages are implemented as [linked lists](https://en.wikipedia.org/wiki/Linked_list). Performance-wise, you likely shouldn't be worrying about performance. For moderately sized lists (certainly those with less than 1000 elements, maybe upwards of 100,000) and working with typical problems, performance and memory usage won't be issues. You should only concern yourself when you have a proven case where your problem bumps up against the limits of what a linked list can provide. The use case for lists in Elm (or any functional language) is to iterate over all elements. Whatever action you perform to each element should typically dwarf the overhead of walking over the list. If you need to do something where performance is so difficult to achieve, you likely either want to drop down into Javascript (hah!... not really...) or do it server-side in a language like Java or C++. Elm (or any pure functional language) will no be able to match the speed of a language with in-place destructive updates.
&gt;Going String -&gt; whatever is much more complicated and error prone than going whatever -&gt; String. Could you explain why? Perhaps with example? It seems to me it can be implemented with simple switch (type) { case 'number': // Convert string to number return decoded; ... other cases for different data types like arrays, objects, booleans etc. } where `type` is simply the parameter `a` in `fromString: String -&gt; Maybe a`
If Elm's data structures (or the performance-critical parts) are written in JS and not Elm, you maybe could match the speed of in-place destructive updates? :) (Both elm-lang/core `List` and Skinney/elm-array-exploration `Array.Hamt` do this to some degree. It's interesting to me that eg. `List.reverse` is not JavaScript-y `fromArray(list.toArray().reverse())` but instead Elm-y `List.foldl :: [] list`, but hey, it must have been benchmarked and found acceptable :) )
Anybody ever got something like pipe-syntax to work with JavaScript? Like this https://github.com/michaelmitchell/babel-plugin-pipe-composition
&gt; The only bottlenecks are if you just want the nth item, if you want to insert or change deep in the list, or getting a count of elements What about mapping over a list i.e. something like: List.map (\n -&gt; n + 1) [0,1,2,3] Would an array be faster in that case or are they equally "slow"? 
Sorry, I think I wasn't clear enough in my question. What I meant to ask was if **Elm** arrays would be faster when mapping over items than Elm lists. Not Elm lists vs. plain old mutate JS arrays. 
Hi, the author of the new Elm Array implementation here. Array.map is WAY faster than List.map. The problems with Lists is that many operations require a foldr, which is slow on a linked list as foldr has to somehow reverse the result. (try writing your own List.map using foldl and you'll see what I mean). Arrays don't have this limitation, as access to both ends of the datastructure is fast. Arrays are, however, much slower to create. Although generally faster than Lists when adding elements to the end of the structure. Filter, for instance, is much slower on Arrays than on Lists (in fact, Array.filter first filters down to a List, then converts that to an Array). In any case. You'll most likely want to stick with a List unless you need random access or seriously need the performance gain of a specific op. For a language like Elm, which mostly centers around making SPAs, I doubt you'll ever notice the difference performance-wise.
Converting a list to an array, reversing that array and the converting back to a list (3 passes) is a much slower operation than just reversing the list (single pass). In Elm 0.19, foldr has been rewritten to use pure Elm and loop-unrolling, which is 25-40% than the previous method of converting to an array.
Continue working on a D&amp;D campaign roadmap app. First project in Elm. Currently refactoring an early foundation to this architecture https://github.com/rtfeldman/elm-spa-example. Throwing myself into the deep end but I enjoy how much I learn going this route. 
Could anyone point me towards a solution, documentation, tutorials, demos, etc. which would help me understand how best to achieve the following? I'm most of the way there, but need help with the last bullet point. - mousemove over element - add class to element - remove class from element after N seconds (any pending "removes" are cancelled by future mousemoves which occur before N seconds have passed) I'm currently using a mashup of the suggestions laid out in [this](https://stackoverflow.com/questions/40599512/how-to-achieve-behavior-of-settimeout-in-elm) SO post, but am not convinced I'm on the correct path, as I feel like I should be using Process::kill, but I don't really understand its API just yet (e.g. How do I get hold of a process id?).
I have two issues. The first one is that most examples and tutorials on Elm teaches how to build an app in the same file. I would like to understand better how to import modules and data from different files. The other one is navigation, I am very confused with that. I have been reading the elm-spa example by Richard Feldman. It imports modules from different files and uses navigation. The problem is that navigation requires many stuff to work. In some cases it looks like the same code is required, for example in Route.elm and Main.elm. Could anyone point me out some articles/tutorials on how to deal with these issues I have, please?
Adapted from [last week](https://www.reddit.com/r/elm/comments/6qoqt7/easy_questions_beginners_thread_week_of_20170731/dl9c7wt/): Hi, I'm working on my first SPA in Elm (getting inspired by Richard Feldman's SPA example). And I'm struggling to split Model between Main and individual pages. To give more context, my app is basically a todo-list, including the Tasks page and the Archives page. Tasks only includes ongoing tasks (not done), and Archives only includes tasks marked as done. So my idea was having Main.Model containing all tasks, Tasks.Model being populated only with ongoing tasks, and Archives.Model only with done tasks. In other words when currentPage is Tasks, we would initialize Tasks' model with *List.filter (\t -&gt; not t.done) mainModel.tasks* (and naturally, *List.filter (\t -&gt; t.done) mainModel.tasks* for the Archives page). The problem comes when updating a task inside the Tasks page: it updates *Tasks.Model.tasks*, but I can't think of a proper way to update *Main.Model.tasks* as well. I've come up with several ideas, but I'm not sure about any: * Pass all tasks to each page, and filter done/not-done inside the page. Then copy tasksModel.tasks into mainModel.tasks during Main.update when msg is TasksMsg (probably the easiest way, but it leaks too much data &amp; logic into pages). * Use ExternalCmd to propagate the updates towards Main, and handle them in Main (but it feels like leaving too much logic in Main). * Use server-side as single-source of truth and reload the data every time (but it kinda defeats the purpose of SPA, and generates a lot of requests). * Do not even store tasks in Main.Model and use ExternalCmd to communicate updates from Tasks to Main, which then spreads the message to Archives. But that would mean to maintain memory of the model for the *Tasks* page (resp. *Archive* page) even when the page is not loaded. I'd be really keen to have you guys' feedback about it. Thanks!
It's a good question. Is there a reason you need all the tasks loaded into Main.Model (presumably in Main.init)? It seems more straightforward to load just the tasks you need when you're on the page they're being edited. In other words, Page.Tasks has its own `List task`, and Page.Archives has its own `List task`. Data gets refreshed from the server on each page transition. What do you think?
Working on a graph dashboard. The frontend is in elm obviously and the backend in python with asyncio/aiohttp. First project in Elm. The idea is that when going to a dashboard, nothing is editable from the browser. Configuration is done instead with (hot reloadable) config files. I expect this dashboard to be used by non technical users that don't want to take the time to configure their own dashboard views or widgets. The first graph I'll support is a build view to see jenkins jobs that will update in realtime and allows for zooming and panning. It's really in progress, like in not yet pre-alpha. https://github.com/ibizaman/elmboard
Working on a patient/nutrition planning app for docs. Front is all elm. 
Yes, you're right. I started as a single module app with no back-end, and as I turned it to a SPA, I guess I just got stubborn at trying to keep all data in Main.Model ;). Anyway, the more I think about it, the more I realize I was trying to load and maintain the whole web-app's data at once, which doesn't make sense! Thanks for the answer :).
I don't think lists lend themselves well to native code speedups. For instance, if I have a list, I could cons something to the front, and you might think, "Oh, you can just push that onto the end of the list". But now I take that same tail and use it to cons up another list. So let's say you have `veryLongList` and you do `let xs = 1 :: veryLongList` and `let ys = 2 :: veryLongList`. In the linked list implementation, you now have a tree. But what happens in Javascript? Do you copy the very long list? At best, you will have to have some kind of hybrid linked list of arrays implementation. 
I understand your point, and to be honest, I didn't mean my comment in the sense that **all** its operations should be written in native code. On my mind was the `List.foldr` /u/skinney is talking about in another comment.
ElmLisp - an experimental LISP language compiling to Elm. Why? Because of **macros**. Essentially, the promise is "Macros will rid you of boilerplate!" ... I have yet to see if that is the truth :) (I want to announce it properly later, after I get it to MVP state and evaluate its usefulness. It's a lot of fun implementing it though! :) )
From the end of the tutorial exercise, "Add a "Submit" button. Only show errors after it has been pressed." from here: https://guide.elm-lang.org/architecture/user_input/forms.html &amp;nbsp; &amp;nbsp; I came up with a solution but wasn't sure if I was doing it the best way. Basically I ended up adding a field to my Model, showValidation. And then in my view I had a function that took my Model and returned an Html msg. &amp;nbsp; type alias Model = { showValidation : Bool } viewValidation : Model -&gt; Html msg Returning div with validation when Model.showValidation is set, otherwise an empty div. &amp;nbsp; The thing that I guess made me think it wasn't quite right was within the Update function, I not only had to set showValidation = True in the model when the Validate button was pressed. But I also had to update showValidation = False for all the multiple other inputs that trigger the update function. &amp;nbsp; Password password -&gt; { model | password = password, showValidation = False } Age age -&gt; { model | age = age, showValidation = False } Validate -&gt; { model | showValidation = True } &amp;nbsp; When I took a step back and thought about it, I basically wanted to only set showValidation to true when the Validate button was pressed and the the view rendered. But after that point I wanted it to be reset to False. So I wanted to basically from the view set showValidation to False when it started as True, which obviously realized I cannot modify the model from the view. Does my solution seem valid or is there a better maybe more 'Elm' way? Maybe I'm just thinking about it wrong? Thanks! 
I struggled with this kind of question for awhile too, and I had the same instincts you did. The elm-spa-example I found very instructive how it manages page state in a union type. Nothing but the current page's state (and user session) at any given time, basically. Also, for state that gets updated by multiple users, you want to get a fresh copy from the server every time you transition to a page, otherwise you may be displaying/editing stale state. It's very tricky to maintain a 'cache', unless your elm app is getting updates via websocket subscriptions or the like. 
In case anyone was curious or stumbles upon this question in the future, here's what I came up with: module Main exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (..) import Html exposing (..) import Json.Decode as Decode import Task import Time type alias Model = { hideAt : Maybe Time.Time , shown : Bool } type Msg = AttemptToHide Time.Time | ScheduleHide Time.Time | Show show model = ( { model | shown = True } , Task.perform ScheduleHide Time.now) scheduleHide model time = let hideAtTime = time + (2 * Time.second) in ( { model | hideAt = (Just hideAtTime) } , Cmd.none ) attemptToHide model time = case (model.hideAt) of Just hideAt -&gt; case (time &gt; hideAt) of True -&gt; ( { model | hideAt = Nothing , shown = False } , Cmd.none ) False -&gt; model ! [] Nothing -&gt; model ! [] update action model = case action of AttemptToHide time -&gt; attemptToHide model time ScheduleHide time -&gt; scheduleHide model time Show -&gt; show model subscriptions model = (Time.every Time.second ChromeAttemptToHide) view model = div [ on "mousemove" (Decode.succeed (ChromeShown)) , classList [ ( "active", model.shown ) ] ] [ [div [class "default"] text "Default" ] , [div [class "active"] text "Active" ] ] init = ({hideAt = Nothing, shown = False}, Cmd.none) main = program { init = init , subscriptions = subscriptions , update = update , view = view } [Ellie demo](https://ellie-app.com/3XKKySvspDka1/0) It all feels a bit heavy handed for something that could be done in a few lines of vanilla JavaScript, but I'm happy with it. Any feedback would be greatly appreciated.
It does sound that Elm isn't quite your cup of tea, and if that's the case, you should just move and and rather check out Elm at a later time. Life's too short to be miserable, i hear purescript is great! I also completely disagree that Elm is a toy or somehow not grown up. Elm is great! I've yet to use a language as readable as Elm is, and part of that is the low number of features.
I think purity is overrated so am not keen on an implementation that names itself after it. And Elm still seems like the superior option as far as web tooling goes. I'd just like some assurance that it has aspirations beyond its current sandbox. A half decent FFI to JS, for example, would be nice. Ports make it feel about as open as a Macintosh. Or a bank vault. Also, the one feature I mentioned was typeclasses, and they definitely *improve* readability. I cringe each time I have to qualify a map function in Elm.
I can see how coming from Haskell you could feel much is missing from Elm. But coming from JavaScript, as most of us are, Elm is giving us so much. I love that Evan is taking things slowly. He is thoughtful about what NEEDS to be in the language. I'd hate to see Elm a decade down the road full of crap like JavaScript. Granted I'd love typeclasses which is just interfaces. But most people are doing front end work in Elm and you don't need typeclasses because you really don't do complex things often. I mainly write Elm for the backend so I'd love more power. But I can wait since what I do get from Elm makes up for it. 
A 'better' FFI to JS would also require making it easier for errors in JS to spread through out your Elm application. Currently Ports protect your Elm code from sideeffects, mutable values and errors in JS code from causing errors/data corruption in your Elm code. Experience with people learning Haskell shows that typeclasses are actually a huge barrier to beginners in type inferred languages like Haskell and Elm. It would be sad for Elm to add typeclasses and end up with the same small market potential as Haskell does. The learning cost of adding typeclasses might be so high as to completely kill Elm as a language since people willing to pay the cost would just be learning Haskell. If the barrier to getting started with Elm is too high people will just keep using JS and the work of developing Elm will be largely wasted. All indications are that typeclass like functionality is a long way off, but lucky for you there are alternatives to Elm if the lack of typeclasses is a deal breaker. Purescript and Haskell(ghcjs) support typeclasses. If you don't care about pure functions or managed effect then ReasonML or OCaml might also be for you.
Growing up is about choosing to do the right thing rather than the expedient thing. It's about considering the long term effects of design decisions. In these respects, Elm is quite mature. &gt; Give me a roadmap for typeclasses within the short to mid term and I'll impatiently wait. This is not going to happen. For all practical purposes you can consider typeclass-like features to be at least 2 years away. There are practical considerations related to deployment of large apps that take and will continue to take the design and development time of Evan in the short to mid term. Now, just to get a better understanding of the level of discomfort that you are having, how big is the largest Elm codebase you have? 
Silently began replacing angularjs code with Elm on a weekly basis from an admin panel that's used by an important customer.
&gt; If it could return an `a`, then that `a` would be unbound and could be used as any possible type, which is a bad idea and breaks the language. Couldn't the compiler try to solve the type and throw an error if it can't? There is automatic serialization and deserialization happening with the ports. I don't see why this would be any different than that. 
Look up transducers. There are also some FRP libraries with a similar API style. Chained methods is probably the closest you will get when it comes to plain JS though.
&gt; Currently Ports protect your Elm code from sideeffects, mutable values and errors in JS code from causing errors/data corruption in your Elm code. They don't corrupt the data just stop your application altogether https://ellie-app.com/3XNVvQMLtZja1/0