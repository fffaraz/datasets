 &gt; It will not be possible to write native modules starting with Elm version 0.19. Do you have a source for this? I wholeheartedly agree with the decision and also think that this feature should have never been part of Elm. The only runtime error I've ever encountered in Elm has been due to a native package I once used for a prototype. I've never had the need for a native package since.
&gt; breaking change This is not really a breaking change. Evan's stance has been clear on this for a long time--you shouldn't write native modules.
yes
it's mentioned in this elm-dev post. my experience is similar to yours, and i'm actually having a good bit of fun refactoring things that used native in my codebases! https://groups.google.com/forum/m/#!topic/elm-dev/bAHD_8PbgKE
this is correct. "breaking" is a qualifier that is applied to changes to an api, and the native code format has never been an api
This seems to be about what can be uploaded to the package repository.
You are right. I guess it's like using the `context` API of React: you could, but you probably shouldn't. 
https://github.com/evancz/react-elm-components/issues/18
This is a great example. Thanks. 
https://github.com/gabrielperales/elm-native-module/commit/227ad3b226d8096bda901216ee4a5a47f2773ac3
I wrote a wrapper around my app‚Äôs update that logs the model before/after update &amp; the msg that was passed. I don‚Äôt have the code in front of me atm but I‚Äôll update later when I ‚Äòm back on my computer. 
Sounds exactly like Elm 0.19 - before you ask there is no timeline for that yet. A full Elm bundle is still quite reasonable in size compared to what other JS frameworks require, do you really have the sizing problem or is it premature optimization? If bundle size is reaaaally important you might have to stay away from Elm until 0.19 and re-evaluate. It's a trade-off using one complete bundle per page, but hey you're using a prerelease language and everybody knows that this isn't going to change for some time. P.S.: I think even the dead code elimination of closure compiler isn't able to remove much of the standard library in Elm 0.18 due to the code structure. I don't want to be mean, just paint a realistic picture of the situation :-)
Je crois que redalastor r√©sume bien ma vision de la chose. La vraie crainte de la direction n'est pas d'avoir de la difficult√© √† trouver de nouveaux d√©veloppeurs Elm. Leur crainte est de se ramasser avec un projet mort impossible √† maintenir entre les mains. √áa, c'est "language-agnostic". C'est possible, peut importe le langage, m√™me avec un langage mainstream. Il faut d√©faire cette vision qu'ils ont, le fait qu'ils croient que certains d√©veloppeurs NAISSENT en tant que d√©veloppeurs Elm. Nous ne naissons pas d√©veloppeurs Elm, nous le devenons. Nous le devenons assez facilement, en plus de √ßa, si nous sommes moindrement comp√©tents et int√©ress√©s. Il faut les convaincre que la rel√®ve existe, mais qu'elle n'est pas n√©cessairement D√âJ√Ä orient√©e vers Elm. Elle fait probablement du ReactJs, ou du EmberJs, ou du AngularJs, en ce moment. Il faut vanter les m√©rites de Elm pour montrer que ces gens l√† pourront l'apprendre avec une relative aise, et surtout que le code qu'ils r√©cup√©reront lorsqu'ils arrivent dans l'entreprise sera construit de mani√®re √† √™tre repris et termin√© avec plus de facilit√©, et surtout de robustesse/s√©curit√©, qu'un code base en JS ou en Typescript. Ceci √©tant dit, jessypl, beaucoup de gens nous ont manifest√© de l'int√©r√™t, mais peu ont appliqu√©s, pour l'instant. L'effet surprise, le fait qu'ils sont d√©j√† en poste, le fait que nos plateformes de partages sont quand m√™me limit√©es, et le fait que les gens qui font du Elm dans leur temps libre sans en faire de jour, professionnellement, ne regardent peut-√™tre tout simplement pas les offres d'emplois passer. Je garde ta demande en t√™te. 
&gt; Is there a way to get it set up like that or does Elm always need "basic runtime + actual app code" in one file? The current way the elm compiler generates output does not allow for what you want but I would not worry about it too much. The weight of the Elm runtime (gzipped) is 20k. Is this an unreasonable size? 
927
I have 45k LoC project that is served around 200kb on production. I was sweating about it, but unless we are talking thousands of dollars loss because of that slower page load (can happen on high traffic on highly monetary website) then you should not worry too much. It is really just a worm in your head (and I had it). And if you are that kind of website, just push your elm code in cdn edges, set agressive caching and you be blazing! :)
I agree, it's in one's head - considering what Elm gives you and an equivalent setup with a React/Redux/Regenerator/Babel/JSX/... stack or even worse an Angular stack :-)
How can I delay a command? I found solution for messages: https://stackoverflow.com/questions/40599512/how-to-achieve-behavior-of-settimeout-in-elm I want to delay a command in my update method. When I use above solution, I got type error - all update branches produces (Model, Cmd Msg) but one branch one branch produces (Model, Cmd (Cdm Msg)). My intention is to make a request, parse response and update state, wait 30s and do the request again. 
I really like [create-elm-app](https://github.com/halfzebra/create-elm-app), which is sort of a starter (as you use it to generate a well-configured initial Elm app) but is a bit better as you also add it as a dependency. This has the advantage over just copying some starter app to start building a new app as many issues you could have with the config `create-elm-app` provides you with have the potential to be fixed in the original project and then also fixed in any projects using it as a dependency by just updating the dependency.
I'd recommend not using a starter kit but with a small gist and going from there. I never understood why these are so popular, especially in the JS world, how would you know what it does under the hood, what if you wanted to change something in it as a beginner? ` npm install elm -g` ```elm -- src/Main.elm module Main exposing (main) import Html main = Html.text "Hello World!" ``` ```html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Elm Hello World&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script src="dist/app.js"&gt;&lt;/script&gt; &lt;script&gt; var app = Elm.Main.fullscreen(): // app.ports. ... &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ``` * `elm-reactor` takes care of the dependencies. * `elm-make src/Main.elm --output=dist/app.js` builds your app
The problem is unrelated to the ports. It's just that there's something wrong with loading Elm at all. Does "app.js" get loaded successfully? Did you build "app.js"? Isn't it called "main.js" maybe? It's `Elm.Main` because your using the `module Main`.
I use webpack to build the app.js. The app.js works fine with this: &lt;div id="main"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="app.js"&gt;&lt;/script&gt; 
Cool site and cool tool, thanks for sharing :)
You could inspect the page it is supposed to be included in an look at the network tab. I guess the script is not being found. I think you will be able to be helped faster in the elm slack. People in the #help channel are super friendly and normally faster to respond such specific questions.
https://github.com/rtfeldman/elm-spa-example the most elaborate one I've seen
I checked the network tab. the app.js is loaded correctly.
https://stackoverflow.com/questions/19059580/client-on-node-uncaught-referenceerror-require-is-not-defined
I am not sure I can understand it. I did use webpack but how to resolve the problem?
Webpack needs to be configured to target "node" for require to be used. https://webpack.js.org/configuration/target/
I added target: 'node' to webpack.config.js file. Now it does not show anything in the browser (blank page). The error is still there. var path = require("path"); module.exports = { entry: { app: [ './src/index.js' ] }, target: 'node' output: { path: path.resolve(__dirname + '/dist'), filename: '[name].js', }, module: { rules: [ { test: /\.(css|scss)$/, use: [ 'style-loader', 'css-loader', ] }, { test: /\.html$/, exclude: /node_modules/, loader: 'file-loader?name=[name].[ext]', }, { test: /\.elm$/, exclude: [/elm-stuff/, /node_modules/], loader: 'elm-webpack-loader?verbose=true&amp;warn=true', }, { test: /\.woff(2)?(\?v=[0-9]\.[0-9]\.[0-9])?$/, loader: 'url-loader?limit=10000&amp;mimetype=application/font-woff', }, { test: /\.(ttf|eot|svg)(\?v=[0-9]\.[0-9]\.[0-9])?$/, loader: 'file-loader', }, ], noParse: /\.elm$/, }, devServer: { inline: true, stats: { colors: true }, }, }; 
You can convert the Request to a Task and use Process.sleep with Task.andThen like this: sendWithDelay : Time -&gt; Request String -&gt; (Result Http.Error String -&gt; msg) -&gt; Cmd msg sendWithDelay delay request toMsg = Process.sleep delay |&gt; Task.andThen (\_ -&gt; Http.toTask request) |&gt; Task.attempt toMsg 
No, it's by no means an unreasonable size. After reading all the answers I think I will be okay with making one file with all the Elm parts for a long time.
I came to the conclusion that Elm 0.19 will still be arriving before our codebase gets so large that splitting it up will be necessary. So we are totally good to go with one Elm app file for now. And I don't really think of Elm as being a prerelease language. I've done some small projects with Elm and never felt it to be unstable or broken at any point. P.S.: But I do consider it funny that Elm enforces SemVer for all its packages but does not use it itself.
nice one. i‚Äôm new with elm too. how can you call chrome api from elm? btw you can you gulp or grunt to build popup file.
I have a background JavaScript file for calling the chrome API. You have to use [Ports and Flags](https://guide.elm-lang.org/interop/javascript.html) to communicate with Elm. I used JSON to convert complex JavaScript objects (the list of windows and tabs) to a string that Elm could decode.
thanks
My problem is with the currentTime tho. The date I receive always is the one that I return when the `Maybe Date` returns `Nothing`, which is `Date.fromTime 0`
Nice, is there a reason you don't use `elm-format`? Just curious
It does use semver, [https://semver.org/#spec-item-4](0.x prereleases can break at any time) :-). That's what I'm getting at - there were extreme breaking changes from 0.16 -&gt; 0.17 and right now the language seems to have stabilized in some way but I would guess there will be some insight when SSR is becoming a thing in RL that will influence the future language design. So 0.20 might have another huge breaking change that isn't easily fixable by `elm-format` like the removal of `Signal`s in the past
Great! If you want to hear a little feedback regarding syntactic sugar (partial application): List.filter (\tab -&gt; match tab) can be List.filter match List.map (\tab -&gt; tab.id) can be List.map .id
I couldn't make it work.
Thanks
Try adding some Debug.log calls around where you get the date out. What is the part of your code that is returning Nothing? 
It is an elm 2-D skeleton animation application. I uploaded it to Google Cloud Platform and you can see it here: [www.elmation.com](https://www.elmation.com) (you can click the "Load KF" button to load "Wave" keyframes and then click "Play" to see the demo; or use mouse the rotate each part of the body and use "New" button to add key frames). You can see the "Uncaught ReferenceError ..." logs showed in the browser console. 
This is most likely a webpack configuration issue and I wonder the kind of development starter kit you're using because that would narrow the possibilities of problems. So, did you take an existing boilerplate plate or did you roll your own? If you did do an existing boilerplate, which one? What have you changed it made special in the default configuration? Has this ever worked, or are you trying to get it for the first compile?
You can find my webpack configuration file setting in my previous message. I wrote Elm application using the standard and elm-community Elm libraries. I notice that in index.js file, which is used by webpack can get Elm but the Javascript embedded in index.html cannot: index.js file: 'use strict'; require('ace-css/css/ace.css'); require('font-awesome/css/font-awesome.css'); // Require index.html so it gets copied to dist require('./index.html'); var Elm = require('./Main.elm'); var mountNode = document.getElementById('main'); // .embed() can take an optional second argument. This would be an object describing the data we need to start a program, i.e. a userID or some token var app = Elm.Main.embed(mountNode); The elm-package.json file: { "version": "1.0.0", "summary": "helpful summary of your project, less than 80 characters", "repository": "https://github.com/user/project.git", "license": "BSD3", "source-directories": [ "src" ], "exposed-modules": [], "dependencies": { "Elm-Canvas/element-relative-mouse-events": "1.0.0 &lt;= v &lt; 2.0.0", "elm-community/linear-algebra": "3.1.1 &lt;= v &lt; 4.0.0", "elm-community/list-extra": "6.1.0 &lt;= v &lt; 7.0.0", "elm-community/maybe-extra": "4.0.0 &lt;= v &lt; 5.0.0", "elm-community/webgl": "2.0.4 &lt;= v &lt; 3.0.0", "elm-lang/animation-frame": "1.0.1 &lt;= v &lt; 2.0.0", "elm-lang/core": "5.1.1 &lt;= v &lt; 6.0.0", "elm-lang/html": "2.0.0 &lt;= v &lt; 3.0.0", "elm-lang/http": "1.0.0 &lt;= v &lt; 2.0.0", "elm-lang/keyboard": "1.0.1 &lt;= v &lt; 2.0.0", "elm-lang/mouse": "1.0.1 &lt;= v &lt; 2.0.0", "elm-lang/window": "1.0.1 &lt;= v &lt; 2.0.0" }, "elm-version": "0.18.0 &lt;= v &lt; 0.19.0" } The package.json file: { "dependencies": { "ace-css": "^1.1.0", "css-loader": "^0.28.8", "elm-webpack-loader": "^4.4.0", "file-loader": "^1.1.6", "font-awesome": "^4.7.0", "style-loader": "^0.19.1", "url-loader": "^0.6.2", "webpack": "^3.10.0", "webpack-dev-server": "^2.10.1" }, "scripts": { "api": "node api.js", "build": "webpack", "watch": "webpack --watch", "client": "webpack-dev-server --port 3000" }, "name": "elm-2d-skeletal-animation", "version": "1.0.0", "main": "app.js", "devDependencies": {}, "author": "", "license": "ISC", "description": "" } The compiling result: C:\work\JavaScript\Elm\elm-2d-skeletal-animation&gt;yarn build yarn run v1.3.2 $ webpack Running elm-make C:\work\JavaScript\Elm\elm-2d-skeletal-animation\src\Main.elm --yes --warn --output C:\Users\jzhang\AppData\Local\Temp\118112-29284-1ew6bqo.mi5x.js Success! Compiled 1 module. Successfully generated C:\Users\jzhang\AppData\Local\Temp\118112-29284-1ew6bqo.mi5x.js Hash: dd005ba3fef5078d7f7b Version: webpack 3.10.0 Time: 5034ms Asset Size Chunks Chunk Names 674f50d287a8c48dc19ba404d20fe713.eot 166 kB [emitted] af7ae505a9eed503f8b8e6982036873e.woff2 77.2 kB [emitted] fee66e712a8a08eef5805a46892932ad.woff 98 kB [emitted] b06871f281fee6b241d60582ae9369b9.ttf 166 kB [emitted] 912ec66d7572ff821749319396470bde.svg 444 kB [emitted] [big] index.html 538 bytes [emitted] app.js 737 kB 0 [emitted] [big] app [2] multi ./src/index.js 28 bytes {0} [built] [3] ./src/index.js 449 bytes {0} [built] [16] ./src/index.html 56 bytes {0} [built] [17] ./src/Main.elm 637 kB {0} [built] + 14 hidden modules Done in 6.45s. Thank you for your help. Let me know what detail information you need in order to debug the problem. 
I have an API that I want to call. There‚Äôs a base URL common to all calls, but the base URL changes depending on the environment (devel, staging, prod, test, etc.). What‚Äôs the best way to deal with this kind of global state? Currently the first argument to my functions is the base url. I store the base in the model, and set it using some web pack config. This seems ugly. Previously I had the base saved as a variable in the API module, but that made changing it based on the environment tricky. Plus I was nervous about forgetting to change it to the prod value when committing. Some kind of dependency injection would be nice? Or a way to pull things from a global state (although I get that that‚Äôs not the point of functional programming). Thanks!
put some code on https://ellie-app.com/
AFAIK there's no way to inject data into the update function other than through the model. I use a global piece of data called GlobalConfig that all functions (various update functions, view, etc.) get passed as the first argument. It contains the baseUrl, in addition to flags like globalConfig.debug. It is through flags (the values passed in via JS/Webpack).
I set up an environment with the things you've posted. It seems that it's not finding the Elm environment variable because your webpack isn't bundling it. There's something in your compile configuration that's preventing or just never running the compilation of your *.elm file.
Thank you, it works! The problem is that the ports should be defined in index.js instead of in index.html.
This recently came up on the Discourse as well: https://discourse.elm-lang.org/t/dependency-injection-how-to-switch-api-server/570 The suggestion there was to use an Elm file per environment which only contains constant. It seemed like a good one to me.
I like that option. I definitely like that I don't have to call the API functions with the root URL as a parameter, that's much cleaner. I'll have to look at how I can swap out the env files at the right times. Is there a way that webpack can do that for me?
I forked and upgraded the webpack starter pack from the community. Should be good enough for most production apps. https://github.com/FranzSkuffka/elm-webpack-starter-1
`static` is a reserved weird in JavaScript. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar
The big question is: why would you want to know that :-). I hope it's curiosity and not some "fiddling with compiler output" stuff ^.^
I know, although I've never seen this being enforced for object's keys. I guess elm is stricter than any other JS console?
ahaha :D let's say that a bug I've mentioned in the above answer gave me a good reason to start "fiddling with compiler output".
Some browsers (e.g. IE8) can't properly handle reserved words as object keys ([see here](https://eslint.org/docs/rules/no-reserved-keys)). That said, from what I can tell elm isn't trying to support ES3, so this may be a bug. E.g. maybe it's intended to prevent variables using keywords as names, but it's being misapplied to object keys. Especially where it sounds like this is something you're trying to use for interop, this does sort of seem like it might be considered a bug. Might be worth opening an issue.
ah, I see - that's indeed unfortunate, especially since [ES5 actually allows keywords as property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)
This seams to be a bug in the compiler and has been reported before: [#1510](https://github.com/elm-lang/elm-compiler/issues/1510) &amp; [#1548](https://github.com/elm-lang/elm-compiler/issues/1548). 
I've eventually opened an issue since there should be at least a compiler warning when using ports. https://github.com/elm-lang/elm-compiler/issues/1672 
thanks
Thanks for your Blogpost! I think it does a great job of introducing reasons to choose elm. My 2 cents on the downsides: Ecosystem: - it might not be one or the other, depending on your usecase. I would also argue that a lot of packages are not even needed because they solve a problem you don't have in elm (promises, generators, callbacks) or are included in the standard in (a lot of lowdash etc) or have better integrated solutions in elm already (style elements vs *CSS). What remains a huge pain is interaction with largely DOM based js libraries. Weird templates: I get that it's strange at first. But when I understood that this means I never again need to install weird helpers or learn yet another strange way to write inline functions, I accepted the tradeoff No big company: Evan said he has financing secured for several years even if No Red Inc stops paying him. Also, a big company does not guarantee success or long term maintenance.
What elm cannot leverage though is existing "controls" like date pickers and such like. If you use react or knockout or whatever you can include JQueryUI components or Bootstrap components or whatever. In Elm you'd have to convert the thing you need to Elm. Elm ports are great for non-UI stuff. Something like localforage can be taken advantage of. But once you are in the UI domain then the thing needs to be ported. The upside is once ported it is written in Elm, it is probably more reliable due to strong typing etc.
Maybe I'm super behind on Elm news, but wasn't server rendering another thing Elm also lacked?
To take a step back, are the points you mentioned really "break it's"?
provided you don't have to support ie &lt;= 10, custom elements are a really easy way to bring existing javascript ui widgets into your elm app. we're planning to do this in production at noredink, and i've implemented several parts of ellie this way in the upcoming release.
Thanks Luke, that is brilliant. That has just made me feel a lot better about learning Elm in my spare time, and taking on a bigger Elm project.
what an amazing thing to read! i'm so glad! always feel free to find me on the elm slack @luke if you want to talk more about using custom elements in elm. i've found it to be a nice, hack-free form of interop on the view side, but it's definitely a seldom-discussed topic among elm users and as such lacks documentation and recording of lessons learned.
i've done a couple of updates since your reply to add more detail. i think i'll write a blog post about this so that this can be more widely discussed.
in my attempts i found that ie10 is missing too many javascript features to make polyfilling the custom elements api practical. i could be wrong though, and would love to be shown wrong for sure
How to write generic funtions in elm? For instance: type Binary = Zero | One toBinary : a -&gt; Maybe Binary toBinary is a generic funtion that accepet Char, String, Boolean and return Zero or One for '0','1',"0","1",0,1 and Nothing for anything else.
[https://www.webcomponents.org/](https://www.webcomponents.org/) lists IE11+ as supported for the polyfills, IE10 is not even officially supported by Microsoft anymore, nor does Google/FB/... in my experience the bigger problem than IE10 is companies that are still stuck with IE8 - no webcomponents for this one, and why would you want to? :-) I'd say just go for the webcomponents interop, no normal user outside of company admin rules will ever use &lt;IE11
Luke, post about custom elements will be very helpful. Looking forward to read this soon.
Elm is great because it's _not_ backed by a major company. Following a major company's technology stack is a bad idea. Google doesn't eat their own dogfood with AngularJS evidenced by the Angular 1 debacle, they pay tons of bright people to work on abstract problems and if shit blows up, oh well. Angularjs success or failure doesn't remotely affect Google's bottom line. Facebook and React have a different problem and it took me a while to realize this: Facebook has one of the largest apps on the planet in terms of features, they have something in the neighborhood of 30,000 React components, they have scaling and performance needs that are as big and as unparalleled as it gets , and they have the management issues that come from having to manage hundreds (thousands?) of engineers all working concurrently together. It took me awhile to realize that with React they are solving their own problems which probably are a lot bigger than your problems. I think a lot of the complexity burnout you see people pushing back against in the JS world is coming from the idea that what's good for Facebook must be good for me because they are big and an important and that's what I would like to be. However, I noticed with React that they are so opinionated and broadly focused that it take a long time to get productive with it and I feel 10 times more productive with Elm. Part of my reason for choosing Elm is that I feel like the people behind the framework aren't too far away from solving the same kind of problems that I have.
&gt;HTML Templating is Little Strange This is because it's not HTML templating, it's just Elm code. And there is really no reason why your view code should be treated differently from other and therefore be written with usage of some special syntax. I remember trying out [Fortitude](https://github.com/ageweke/fortitude) which allows you to write your views using plain Ruby instead of HTML templates, and it was so much easier and more powerful, and eliminated many problems like limitations of a templating language, need to keep in your head special rules for organising view partials or declaring helper functions... I always wondered why it's not a popular solution and templating languages continue to be a standard for writing views, so when I discovered Elm, advantages of its approach were already known to me. One thing I disliked about Elm at first is its "leading commas" syntax convention. It seemed unreadable to me, especially in the case of writing HTML. But I became so accustomed to it now that I feel weird when I need to write JS or another language where you write commas at the end of the line and I think it much more readable.
You can currently implement something like this by using `toString` ( see [example](https://ellie-app.com/tyVHWkt4a1/0) ) but you will no longer be able to use this implementation in `0.19` because `toString` will be available only in debug mode. 
Regarding the html templating, I agree that it might seem unfamiliar but I personally think it's an improvement over html. No more worrying about closing tags. If closing tags are so great, why do most people prefer JSON to xml? Have you seen [slim](http://slim-lang.com/) for Ruby? It's somewhat similar to Elm templating in that it attempts to improve the templating experience by writing concise code. In fact, it's called Slim because it's significantly lighter than the equivalent html with embedded ruby. I get that if you've been working with HTML tags for years, the unfamiliarity of Elm templating could be considered a drawback. But seriously, this is a non-issue. I regularly attend my local Elm meet up and help beginners with their first Elm project. I've yet to meet a beginner struggle with templating. 
He's got a point that it's a little awkward to write, but so is HTML for goodness sake. I use Slim if I can.
For type safety, there actually is a TypeScript to fable converter: https://github.com/fable-compiler/ts2fable So that might be not a big issue anymore. I actually wonder why Microsoft itself doesn't use tools like that. TS inherits all problems of JS and just looks uggly and super artificial. Plus, it doesn't even guarantee type safety and type inference is quite bad. Plus, at some point they will be forced to brake backwards compatibility or use even more compiler flags, which were a bad idea from the get go. It's just not thought out. Anders Hejlsberg did such an amazing job on .NET but I think this he / they screwed up. They should've ported .NET to the browser (not only WebAssembly). 
Well said! 
This has been asked several times [[1]](https://www.reddit.com/r/elm/comments/71bp2o/elm019/)[[2]](https://www.reddit.com/r/elm/comments/7cetji/is_there_gonna_be_any_elm_019/). It seems the advice given is it will be ready when it is ready. I like `elm`, but a writing production software on something that doesn't have a regular release cadence in bug fixes or features is worrysome. 
Me too, my team waited too much for 0.19 release, we could not wait more so we started with js, and probably it will not be an option to rewrite it :/
what benefit would it be to your team to have an exact release date for the next version?
this wasn‚Äôt my question. why would it matter if there was a bug fix release once every three months or if sometimes you just got a bug fix release?
Having used Elm for over 3 years now, I genuinely find the thought of writing production software in anything else worrysome. I don't think this turns out to be as strong a signal of outcomes as it sounds on paper. üòÑ
What were you waiting for specifically? I mean, what stopped you from using 0.18? 
I like this question. I do not like Elm closed dev't situation, and I hope this will be over once Elm reaches 1.0, for Elm to adopt then an open dev't model like most open source software. All this while I totally understand Evan (main contributor) in making this decision. At some point we need this project to be run by a team, not by a unicorn. Yes that will require more communication, more discussion, more overhead. But a project of Elm's magnitude and ambition cannot survive the adoption curve with one dev only.
Bus factor maybe? There is no such a thing as the culture and information on developing it collectively in the community right now. If Evan suddenly stops, Elm is dead.
Being devil's advocate, you guys *do* have Evan on your payroll.
For SEO, right?
&gt; &gt; Bus factor maybe? &gt; that is not the case. there are quite a few people who work closely with evan on various projects even though they aren‚Äôt making commits to the compiler. This is still a major risk. There's not a clear policy in place, thus a possible negative impact for the Elm community exists the the case Evan is gone. There is only one true "open" solution to this and that is an open access dev't model. Look at a project like Rails: https://github.com/rails/rails/graphs/contributors And compare it to Laravel: https://github.com/laravel/laravel/graphs/contributors I find the latter's lack of major contributors a major obstacle for adoption. Here is a language to compare with, Kotlin: https://github.com/JetBrains/kotlin/graphs/contributors 
&gt; I've yet to see another language with such helpful compiler, great package manager, formidable code formater, thoughtful syntax, etc. Seen ReasonML? I know tastes differ (esp when it comes to syntax), but on those point your just mentioned it is pretty compelling.
Rust has that. Have you seen rust?
Agreed. For instance the bugged array implementation could have been replaced in 18.0.1.
Well yeah! I'm not sure how we could more directly endorse how great Elm has been for us than by hiring its creator and paying him exclusively to keep doing what he was doing at Prezi before. üòÑ [The original announcement](http://blog.noredink.com/post/136615783598/welcome-evan), for reference.
This is how Python was run when it was Elm's age. Are you concerned that Elm will only be as successful as Python? Because I'd say Python has been very successful, and I think it's great that Elm is growing so nicely!
&gt; So USA'ish Please keep it civil, /u/cies010
&gt; I genuinely find the thought of writing production software in just about anything else worrysome. How would you rate purescript + a virtual dom library Also what about typescript + a UI library? Ok it's not as safe a ML based language. It has nulls, but at least there is some type safety there.
I think Pux is much closer to TEA in PureScript - Halogen gives quite a bit on top (AFAIK Elm/TEA advises against components - Halogen seems to embrace them a lot more)
local storage, file reader and a lot of the rest of the web APIs can be used through a ports driver like [this one](https://github.com/pdamoc/elm-ports-driver). This uses only 2 ports.
Ok I'll add a smiley. :) 
Open access dev't does not mean "no governance what so ever". But it's a valid concern I guess. With a proper process of proposing new features that should be fairly easy to avoid. 
So, if someone wrote a PureScript sanitizer, that would be better? The only thing that‚Äôs been keeping me from PureScript is not being confident about how it bridges.
If you want you can try to gut Http lib and replace native calls with Fetch in Http.js Good luck :)
Can you share maybe just the lines with which you invoke the get time task, also just a part of update that handles new date?
I think most of us are not looking towards a completely open model. Just more transparency in the development.
IMHO being able to commit to a release date build trust in the community. Being open about what's going on, being a problem or a brilliant solution, also build trust.
Agree. I've only hit 2 big pain points in 2 years (variable shadowing and reserved JS words aliasing): this is the best experience I've ever had with a relatively new frontend language. I wrote 2 native modules, too, just to realize later that I could have gone with pure elm. I was just rushing things up, which is a good way NOT to finish a project :-)
I have been rushing many times, and made some compromises that shipped the product. Later when I came back, and dismantled everything that was bothering me, compiler lead me to fix the whole thing, like it was nothing ( I remember, at one point there were like 78 compiler errors, in two hours my app was being pushed to staging) ^^ There is no FLAMEwork, or platform du jour that gives you this level of certainty that your thing will work like Elm. 
[State of Elm](https://www.brianthicks.com/post/2017/07/27/state-of-elm-2017-results/) mostly. (Which reminds me - [State of Elm 2018](http://www.brianthicks.com/post/2018/02/01/state-of-elm-2018/) is still running!)
Well I‚Äôd definitely recommend trying PureScript if it seems appealing to you. Don‚Äôt let my preference for Elm dissuade you from trying alternatives! What worries me about other language ecosystems is not lack of sanitation, it‚Äôs about lack of guarantees. In every compile-to-JS language except Elm, I can write a pile of JavaScript which throws exceptions, runs side effects in the middle of functions, and depends on global mutable variables, claim its type is `String -&gt; Int`, and publish it. Now every other package in the ecosystem can call that supposed `String -&gt; Int` function, and build their packages on that, and then other packages build on those packages... That‚Äôs the stuff that worries me. If I‚Äôm debugging something weird, is the root cause that someone, somewhere, in some package or some dependency of some package ‚Äúbroke the rules?‚Äù I can‚Äôt rule it out. In contrast, `elm-package` won‚Äôt accept any packages that even *use* the `port` keyword. If I got it from `elm-package`, I can be confident that I‚Äôm getting actual Elm code, not a bunch of JavaScript with a thin veneer of Elm on top. That gives me a totally different level of confidence in the Elm ecosystem for production applications, compared to any of the alternatives.
&gt; I'm seriously concerned Elm will miss the boat because of governance structure. People have been saying this since 2015, when there were about 4 companies in the world using Elm in production. Now there are hundreds, according to early State of Elm 2018 results. &gt; That was early 90s. This is a different time. You have to compare to "new" languages nowadays, and what works for them. Kotlin, Go, Rust, PureScript, ReasonML, Clojure, etc. I disagree with the premise, but even if I agreed with it - [Rust was literally one person‚Äôs private project for the first 4 years](https://youtu.be/79PSagCD_AY), [people still complain](https://news.ycombinator.com/item?id=11883579) that Clojure is not a ‚Äútypical open source project‚Äù but rather ‚ÄúRich Hickey‚Äôs personal project,‚Äù and ReasonML and PureScript have not seen enough traction yet to be held up as success stories. (I don‚Äôt know Go or Kotlin; maybe they‚Äôre different.) &gt; No bruv. I'm concerned, if you read my comments Can we have a difference of opinion and discuss it calmly without snarking at each other? I‚Äôd really prefer that.
With elm you can do anything you could do in plain JavaScript. Sometimes directly, sometimes you will have have to use ports and sometimes you will have to wrap your logic in a custom html element or webcomponent. If you plan to build a standalone app you can use electron for it. With electron you can access local files and do many things regular apps do. You can always have a web API and communicate with JSON. You don't need ports for that. For conversations data, you can either use JSON objects, or you create your custom DSL (Domain Specific Language) and its parser. I would go for the DSL. Accessibility has nothing to with your choice of Javascript, Elm or whatever. That is a fight between you and your HTML (in case you build a web site). Any SPA technology will reflect what you ask it to.
To me, Elm sounds like a good enough tool for what you want to do. You can use whatever you like for saving the game. LocalStorage would be the easiest way but you can also upload files using something like `elm-ports-driver`. Having some data loaded dynamically from a server on page load is also not a problem. You can solve this by hosting the files somewhere and just instructing Elm to read them on init. You don't really need a backend for this. You can do this with a simple GitHub Pages setup. You would need a backend if you want to save the data in a safe location (on a server) and/or if you want user authentication. For that you can even reuse your Java knowledge using one of the Java web server frameworks. 
&gt; Can we have a difference of opinion and discuss it calmly without snarking at each other? I‚Äôd really prefer that. Me too! As I said "So we differ of opinion. :) No problem in itself." and taking my concern as "it will not be as successful as Python" comes across as mocking. But I do not take offense from this. I understand I'm mixing myself in language debates. &gt; Rust was literally one person‚Äôs private project for the first 4 years Contributors graphs in Github tell a different story. But maybe you mean the 4 years before 2010 (I did not see the whole video you linked). &gt; Clojure is not a ‚Äútypical open source project‚Äù but rather ‚ÄúRich Hickey‚Äôs personal project,‚Äù I stand corrected on Clojure. I did not properly review their governance model. &gt; ReasonML and PureScript have not seen enough traction yet to be held up as success stories. (I don‚Äôt know Go or Kotlin; maybe they‚Äôre different.) I was never comparing based on success. I was comparing on the ability to get traction to the point that it "crosses the barrier of immortality". As you can read in my first comment I mostly hope that the governance model of Elm can change at 1.0; that's all. If not that's okay too, I mean, to each his own, right? It's just my hope based on 2 experience were I did not manage to use Elm because mgr found out it was a one-man-show. Have a great day! 
You can use offsetTop, offsetLeft, offsetHeight and offsetWidth. In pure elm you can use this library: http://package.elm-lang.org/packages/debois/elm-dom/1.2.3/DOM
&gt; If you plan to build a standalone app you can use electron for it. With electron you can access local files and do many things regular apps do. Electron looks like something that could definitely work for me, thanks! How does the info get from elm to electron and back into the app for the purposes of saving and loading files? Does the file writing code get written in Javascript or in Electron or what? &gt; Accessibility has nothing to with your choice of Javascript, Elm or whatever. That is a fight between you and your HTML (in case you build a web site). Any SPA technology will reflect what you ask it to. Sure, but if it is not HTML, then it definitely reacts differently w.r.t. screenreaders. Java GUI frameworks, Python GUI frameworks, Console output etc. all have their weird quirks and the like with which it can be difficult to get a nice experience when using a screenreader.
&gt;you can also upload files using something like elm-ports-driver. Hmm, elm-ports-driver seems quite interesting, thank you for that! I'll take a look at it! 
&gt; Hmm, elm-ports-driver seems quite interesting, thank you for that! I'll take a look at it! `elm-ports-driver` library is still in experimental phase but that should not prevent you from using it as inspiration. 
Fair enough! And yeah - on Rust I meant the 4 years before 2010. Steve talks about Rust's beginnings around the 3 minute mark. Really interesting stuff!
Thank you. However, I looked at the elm-dom document. It seems I need to set the target upon an event update. What event I should response in order to get canvas target? Can you should me the code? Thanks. 
I saved the talk for later. But did it have public releases before 2010? I was not aware it had (Wikipedia mentioned 2010 iiirc)
I am not bothered by the time span between releases (actually, after the Angular 2-4 multiple releases and RC's, I am deeply relieved to know that what I write will not be "outdated" next week). I believe that most of the stress that the users put in the developers can be avoided by regular, official communication. The community is very active (anyone visiting the Elm Discourse or Slack can attest this), but all this work is not visible by people that don't access these channels. I believe that having a new post every two weeks - even monthly - at http://elm-lang.org/blog will change the perception of the "regular users" that fell (wrongly) that development in the lang is abandoned/slow.
I've just alpha launched my side project: https://www.billabl.co (I'm very nervous about posting this). It's a tool for reporting on how you spend your time (i.e. for billing clients for X hours of work). You record your time in regular calendars, billabl just pulls the calendar info in to make the report. Anyway, I used it as an excuse to learn Elm and how to build an SPA. I've loved it. I'm still pretty bad at Elm but I'm liking it so much I'm going to keep learning :)
[removed]
[removed]
This might be an angle: https://www.reddit.com/r/elm/comments/7xu3hf/elm_makeits_breakits/dubrpre/ So create a component like that, but that writes out the JS that imgur wants you to embed.
Thanks - I might take you up on that. I'm not there yet on the side project, but at some point I might add date pickers and the like as a bit of polish once the main skeleton is there.
It's always glad to hear that others also love Elm ;) I'm not personally in need of this (still student) but I hope it will work out for you!
Since there are no type classes in Elm, the idiomatic way is to have a function for each type, e.g. Binary.fromChar, Binary.fromString, etc. Since you know the type going in anyway, it's not a big deal. 
It exists an event for node addition, DOMNodeInserted, but it is deprecated. The successor is MutationObserver, but does not use events. If you can't think of any event that might work for you, like forcing the user to click on the canvas, I think you should use ports to trigger a custom event on the canvas. Anyway, all HTML that is rendered is created by you. Why can't you be deterministic about the canvas size? It seems that it is what you are doing already.
Cheers!
Cheers!
Cool! I made something like this once in MS Excel to help me study in college. I actually remember some of the symbols. :)
I made a small cycling results administration system for my local club. The frontend is hosted on Github and the backend on Firebase. A demo (connected to a test db) can be found here: http://uitslagen.wtos.nl/?test and the source code here: https://github.com/michie1/wrs_elm/tree/master/src I would love to hear your feedback. 
Currently, I subscribed Window.resize event to get the window size whenever the window changes. Is there a canvas size changed event I can subscribe for getting the canvas location and size? As I said, I am new to front end develop, I may not aware some thing exist there for me to use (I may not fully understand what I did on my HTML layout). I also tried to use CSS to set the canvas with and height and it even get worse (the WebGL texture became pixelated low resolution rendering). I hope some experts can advice me.
I would like to integrate my app with Firebase. I discovered elm-fire and noticed they have an in-development branch of a 0.18 version, so I cloned it and tried it out. As cloned the example works nicely. However when I try to reference the module from my main project using this method https://stackoverflow.com/a/44469731/417377, I get the error: "_elm_lang$elm_architecture_tutorial$Native_ElmFire is not defined" Is this something to do with the Native calls not being allowed in modules? Is this a bad direction to go in anyway? Maybe I should create a port-friendly version of elm-fire and use that?
&gt; Less stupid example, if I want single character specifiers to be displayed, is there a way I can make sure that the string can only have a length of one? Have you tried using the Char type?
A couple of options 1. type LevelUnion = Level1 | Level2 | Level3 -- ... etc 2. -- Put this in a seperate module, only expose LevelType and makeLevelType, but not Lvl type LevelType = Lvl { index : Int } makeLevelType : Int -&gt; Maybe LevelType makeLevelType i = if i &gt;= 1 &amp;&amp; i &lt;= 10 then Just &lt;| Lvl { index = i } else Nothing
Impressive that you have built everything in elm including the promotional pages. Just to make you aware, I did have trouble signing up - got an error on chrome. Tried in firefox and nothing happened. I recommend you get higher resolution screenshots (or at least click to show hi-res) and at the start of your video, as you speak, show the system being used in a way that matches what you say, rather than just having nothing to see. Nicely done though and overall the site looks very professional. Good luck.
Thanks! I completely agree about the video, i think it might be one of the most boring promotional videos ever :) I was very aware that if I didn't push myself to launch that I'd just spend too much time 'perfecting' everything. So I gave myself a time limit for the video and stuck to it. When the launch is underway I'll go back and spice it up a bit. Speaking of signing up. I'm gutted that it didn't work for you. Looking into it I think my CSP messed up the stripe payment side of things. I've just pushed an update that Stripe's docs say should work. If you're interested, give it another whirl, it should work this time (or at least you'll see a different error). Thanks for the feedback!
P.S. If you do want to sign up, please use the IMTHEALPHA coupon code to get ¬£2 off each month. (It is an alpha after all)
[Posted this in last week's thread by mistake - apologies] This seems such a basic question, but I'm afraid searching has eluded me thus far. What does Elm provide for laying out UI components? This article suggests there are built in layout features, though I can't find in the docs. I also found Elm Bootstrap. That made we wonder if there isn't a layout (sub)language - or perhaps the bootstrap integration is specifically targeted at responsive behaviour? To be clear, I'm hoping to avoid having to use CSS layout (in all its grid/flex glory). Thanks. 
Yes it now works. Thanks for the code, I am not a customer for this as I work for a company that already has a subscription to something similar for the desktop, but if I was indie I would definitely consider it. 
No worries! Thanks for testing it for me üòÄ if your company ever feels like changing their time tracking app... üòÄ
Yeah, I was just thinking about it theoretically for putting arbitrary limits on types, and less for the specific examples, but you're right, Char would work really well for that one.
I see, cool. Thanks for the help!
Allow me to disagree: I think you are comparing very different tasks with different goals. " "The web platform" is a standardization of the most promising approaches to solve problems in the browser. Different vendors implement different approaches and then sometimes come to an agreement to make slight changes and call it a standard. Other standards get deprecated and will eventually stop working on an ever increasing number of devices. Elm on the other hand is the fundamental building block for a lot of developers. What happens if you deprecate something on a language level you can see by looking at python 2 vs 3. The alternative is to maintain it forever, which means an exponential increase in complexity because you have to ensure everything still works together. In consequence, you as a language designer have to really make sure the feature you are putting into the language can be supported forever. Let's make it concrete: If anything specific to js would make it into elm, backwards compatibility would have to be broken in order to compile to wasm. Therefore I think it is totally OK to write a little js to bridge the gap to missing features. There is an excellent talk about the topic: https://youtu.be/4Dr8FXs9aJM Main takeaway: Languages should be stable and not break things. Evan wants to figure out one API to do IO that works in the immediate future for localstorage and for file storage in the long term.
I am also considering parse api (http://docs.parseplatform.org/rest/guide/) which has the advantage of having many vendors implement it and being open source (ultimately even if all the vendors pack up you can [self host](https://www.digitalocean.com/community/tutorials/how-to-run-parse-server-on-ubuntu-14-04) )
Ah yes, Parse. I haven't had a chance to read much about it but from what I've seen it appears to be a good (open source) alternative to Firebase.
Thank you for the advice and the code example. Can you show me how to get the "width" and "height"? The "width" and "height" should be the canvas size, which changes when user resize the browser. 
Sorry, that I can't really help you with! I generally just set those myself (often as a function of overall window size, as discussed above).
excellent, thanks for the pointers. `style-elements` appears to be just the kind of thing I was looking for.
I just had a play and modernized this source code (https://github.com/randomer/elm-parse-sdk) for 0.18 and it works a treat. Found a free parse plan (https://parse.buddy.com) and got some CRUD operations going. Very happy with it. No JS ports required as it is all simple REST stuff. Once my project is finished and this is battle tested I will publish a package to work with Parse. Like your Firebase lib, it would take some time to cover all the operations.
Hi! Thanks. :) I haven't tried elm-fire (yet). During development I was prototyping how firebase worked in Javascript and then sending the values back with ports to Elm. Later changed the structure to only use one port after seeing the talk "The Importance of Ports" by Murphy. Probably at this stage it's not necessary to use this package, but I'll keep it in mind. Thanks! What is your issue with elm-fire?
The issue I had with the [ThomasWeiser elmfire](http://package.elm-lang.org/packages/ThomasWeiser/elmfire/latest) is that it is pre-0.18. There is however a branch of work in progress to make it 0.18, however it uses natives, which is the reason I think I can't get it to work as a package. Even though it probably works if you copy all the source code into your project. Since the original post, I have change my mind to use a different Baas called Parse. Parse is an open source API for storing back end data. (It's an ex-startup than open sourced when they shut down I think). You can go to many different providers, and your same source code will work, so you are not locked into Google. It has a well documented REST API, so it is possible to write a pure Elm library or module to talk to it. I think you can also do this with Firebase too, but I'd rather put the effort into matching up to something that is open source, not subject to Google's whims.
"The Elm Architecture" ("TEA") is branding and literally nothing else. It's a pitiful wrapper around a few callbacks doing the simplest possible thing that a pure functional language could. The compiler's take on the importance of error messages is more notable. But even this is probably just a reflection of the piss-poor status quo we have in most other languages. But designing for an good user experience for using the language overall is something Elm does pretty well. I wonder if this approach can scale reasonably as the language grows, but for a small DSL-feeling language (like Elm kind of is right now), it's wonderful. 
Consider that maybe the branding is equally aggressive, but that we've been raised to treat it as innocuous. Something like "no more exceptions" slogan is fine, because Elm avoids the null pointer issue yada yada. But the term Elm Architecture makes me kinda queasy whenever I read it.
But it is HTML... Electron is basically just a Chrome Tab. The elm code renders the UI by generating HTML just like it would in a browser
I'm working on a way to write Elm code using your voice only, with a custom editor built in Elm. Using the [elm-ast](http://package.elm-lang.org/packages/Bogdanp/elm-ast/8.0.12/) package to tokenise the code and move around, write and refactor with commands. Not got the actual voice recognition in yet, but a port to the [Web Speech API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API) should work for that.
Alright, cool, thanks!
It seems ironic to me that people here are arguing that the development model for Elm needs to change when the development model for Elm undeniably preceded its current existence that people are excited about. I mean, if you want a different development model, go use Angular or something. If you want just the development model to change for Elm, fork it and have a blast. Personally, I like the curated nature of Elm. I like the language as it exists today. I like the stability of fewer source-breaking releases. When the new version arrives, I'll enjoy digging into it - trusting that every bit of it was carefully considered and fully baked before being unleashed.
Is there are a way to extract a value from union type? For example: type alias TestInfo a = { a | name: String } type alias Model = TestInfo { } type TestModel = EqualityModel Equality.Model | OtherModel Other.Model I need to get this Equality.Model or Other.Model from TestModel value. Something like case v of _ f -&gt; f does not compile
How do you handle large complicated forms, with lots of `onInput`? The method on the Elm website for the simple examples is to have a different message for each, but for a large number of inputs that seems like it could be very unwieldy and very verbose. I have a form with about a dozen inputs, some of which are only required if others are, etc. The way I have it structured right now is: ``` type InputType = Input1 Type1 | Input2 Type2 | etc. type Msg = Reset | Input InputType | Submit ``` and then I have multiple helper functions: ``` makeIntMsg : (Int -&gt; InputType) -&gt; (Int -&gt; Msg) makeIntMsg it = (\i -&gt; (Input (it i))) makeBoolMsg : (Bool -&gt; InputType) -&gt; (Bool -&gt; Msg) makeBoolMsg it = (\b -&gt; (Input (it b))) ``` which I use in the HTML like `onInput (makeBoolMsg MyBoolInput)`. Is there a better, more elegant way I'm not seeing?
I don't frequently write elm, but I have really enjoyed listening to Evan speak on the elm-town podcast, (I'll probably be vaguely, poorly referencing some of these notes from memory ahead). He's said some very compelling and interesting things, I'd recommend checking it out. He, on several occasions, has discussed the importance of planning, research, and "putting in the time" so-to-speak towards the development of Elm. I think he may have addressed some of the things you have brought up. &gt;The reality is, for a language to have a future, it need to have adoption. It needs to have momentum (especially if it's a nascent) or else, it becomes yet another obscure but interesting language. In my opinion, we need to think about what it _means_ for a language to "have a future". I may be misremembering it, but on one elm-town episode, Evan really digs into some of the "why's" and motivations behind building Elm. What I found particularly inspiring, is that he's not doing this for getting market adoption -- while some developers put a lot of effort into getting "market share" on libraries (or even getting those sweet sweet github stars...). In other Episodes I believe I recall Evan also pointing out that developers need to make a point of deciding what tools are right for _themselves_ -- Elm isn't trying to be a silver bullet. On a somewhat related but different note -- your post states several times, something like "Evan NEEDS to do X". Evan doesn't have to do anything -- he doesn't owe the community anything (in my opinion). This is open source software, and you don't have to use it if it doesn't fit your problem -- and if it does, you need to weigh the possibilities that someday a language might not be developed at the rate you'd like it to be. That one's on you. I'm biased from having written open source software -- so take this with a grain of salt: these kinds of posts can be tiresome for those who are working on the project in question - the constant evaluation, pressure, and demand for change and "progress" can easily deter and lessen motivation ( to say the least). With that said, I think you were very polite and made points that are certainly worth discussing! I think when you are really passionate about a project, it's easy to want everyone to use it (and why not!) -- but I think it's important to stop and ask why that's important to you, and perhaps even more so -- see if there's a way you can help. Perhaps you don't want to see Elm become abandonware or whatever it's called. Again, I think a solution is to try and step in and help out in any little way. In a sense, I think your post does that -- but I think something more along the lines of blogging and sharing what you love about Elm to have a positive and powerful impact. To (poorly, sort of) quote again from an Elm-town episode, Evan actually makes a call to action for help with things like, providing docs / blog posts about how to use ports in the real world. Anyway, some of that has been on my mind lately -- hope it doesn't come across to critical - I certainly didn't address many of the points you made - many of which are valid points to talk about. Hopefully some other folks might have some valuable things to toss in. 
I think the Elm language is pretty much fine at the moment. What would make Elm very attractive is to have more available in the ecosystem. More packages. Better examples on existing packages. More 0.17 packages upgraded etc. As for the blog posts / youtube, well anyone can do that, so it just needs someone to volunteer. It doesn't need Evan to coordinate it like some kind of "Elm CEO". Impressions are important, but I don't think Elm can be aimed at people/organisations who judge something by how recent the blog posts or Github commits are, how many conferences are on it etc. I see Elm being used in companies with developers who like functional programming, see the benefits, and the managers trust their developers to make good choices. It will also be popular with indie developers who like it and can just use it without convincing anyone. It will be less popular in places that use tech based on trends, salary costs for an 'X' developer etc. 
I guess your thought process was: More frequent releases -&gt; More people seeing elm -&gt; more people developing packages -&gt; an overall better experience for all members of the community I want to say that I understand the thought process, but I want to share an alternative: Developers adopt elm over time, not because of constant bombardment with new features, but simply because the language is stable and the slower pace allows the language as well as important packages to adopt the best, not the first solutions. More adoption occurs because of stability and reliability. Fast and massive adoption guarantees neither good ecosystem quality nor long term maintenance (look at angular). You could even argue for the opposite, when the package with the best PR wins. Some elm packages recently decided to even remove their logos, because they want to shine with their APIs and features. Please consider a less aggressive title next time. It might be catchy but it can easily be considered a personal attack.
Thanks for engaging in this discussion with a great comment. &gt;What I found particularly inspiring, is that he's not doing this for getting market adoption Yes, I do admire that too. But bringing others to help does not necessarily detract from that mission. &gt;This is open source software, and you don't have to use it if it doesn't fit your problem I think we are saying the same thing, here. If we don't see growth or momentum, or don't like something, we might need to think about switching. My main thesis here is that Elm can lose momentum. Which seems like that is what you are saying. But that you're okay with it. &gt;I think it's important to stop and ask why that's important to you, and perhaps even more so -- see if there's a way you can help That's a great question. As I said, Elm was the language that helped me to better grasp functional programming and more importantly, helped me better digest Haskell. I'm still learning and have a long way to go, but I'm very appreciative of the potential of Elm. The second motivation is time. Once you dedicate your time learning something, you want it to be around and perhaps help you beyond being just a stepping-stone. It would be nice to think becoming a proficient Elm developer, can be something that you can fall back on and be able to do side projects for high pay. &gt;I suggest something more along the lines of blogging and sharing what you love about Elm as a way to have a positive and powerful impact That's a fair point. Reddit post inside an Elm subreddit, is an easy way to comment about what you feel to an audience that has a vested interest. I guess, it's an easy way to say something that's been on your mind. But to your point, I like and inspire to write something constructive that is education to others. 
It might hurt motivation to upgrade packages to 0.18 when it is known a major set of changes is coming that could break them again. I know this hurts my wanting to start a project with it.
Elm is very usable as is. Its always going to be a more niche platform for more experienced programmers, that said the userbase is most likely never be as big as some of the counterparts in js/ts land. This is a good thing. This allows a more focused growth. I have too many tines seen projects grow out of control because literally every PR is merged so you end up with a complex all incuded thing.
I'm more worried now that I see how many in the community, comments in this and the other post, don't see an issue with a project that everyone knows has a major release with breaking changes coming but no one knows at all when it might be... How anyone doesn't see that this might make potential adopters uncomfortable I have no idea.
Beside the marketing effect I have no idea how to measure, I loved to hear some news in the podcast interview Evan did a few months ago. I agree that there where some insight there that could have been very interesting posts on the blog too, last but not least the possibility opened by the no-js rule in the packages to move to WebAssembly with minimal coordination.
&gt; Rule 4: Compare yourself to who you were yesterday, not to who someone else is today. There will always be someone more successful by some metric. The idea is to look at Elm or yesterday not at some other piece of tech. The number of packages available increased, the number of people in Slack increased, the number of companies using Elm in production increased. 
&gt;More frequent releases -&gt; More people seeing elm -&gt; more people developing packages -&gt; an overall better experience for all members of the community That's one aspect of it. If you think about any type of user acquisition process and community building these are the steps that are typically taken: 1 - awareness 2 - acquisition 3 - activation 4 - retention 5 - referral I think Elm has been a bit of a black box recently. So not only awareness frequency is fading. I'm wondering if retention and referral is growing or shrinking. Was just looking at ReactJS vs. Elm subredit growth rate as a proxy for momentum and Elm has slowed down: http://redditmetrics.com/r/elm#compare=reactjs &gt;Please consider a less aggressive title next time That's a fair point, I guess subconsciously I've been frustrated with lack visibility and communication and additionally I wanted to make a strong and polarizing point to get more people talking about this issue. &gt;Proposal: let‚Äôs increase activity on elm‚Äôs website by suggesting recent articles from different authors Both of your suggestions are far more constructive than my post. I don't disagree with your positive tone. I just think it's time for action and taking a polarizing tone, might get more people discussing it. Either way we do need more frequency, visibility, clarity and articulation of vision and planning. I feel it makes for a stronger community engagement and a stronger community probably. 
If anything is killing Elm‚Äôs momentum - and I‚Äôm not sure such a thing is actually happening - I don‚Äôt believe it‚Äôs Evan. It‚Äôs Slack. Slack is very convenient for insiders, but makes the community activity invisible to outsiders, and impossible to follow for those who are interested and curious, but don‚Äôt have time to visit the Elm slack daily. In order to keep the community growing, I think it‚Äôs important to bring the discussions back to Reddit and the mailing list. 
There is clearly a conflict of priorities here, you're not talking about the same thing so it won't go anywhere. I don't know how long you have been in web tech but I recall the same kind of discussions when it was jquery vs. react. And jQuery clearly won, didn't it?
I feel you: and that's why it might not be appropriate to early-adopt pre-release software in some cases. By choosing Elm 0.x you consciously or unconsciously agreed to handle possibly big breaking changes. The language is extraordinary but it ain't done yet...
In short, no. Elm is a great language because Evan takes his time and finds good solution. The alternative would be to make more mistakes, which would more often break things, or potentially just not be such a nice language. None of these things are great for momentum. Slow and deliberate, that's how you win the race. (I've also seen you compare Elm's growth rate to React, which is an apples-to-oranges comparison. JS is the most used language used on the planet, of course a popular JS framework (which doesn't have to include a language or package manager) is going to make the growth rate of anything else look silly).
Thanks for the GitHub Pages suggestion. The (first, very rough, non-working, template) GUI is now hosted on Github pages [**here**](mark-chimes.github.io/trading-post).
Early stages of setting up and planning out a game which involves playing a trading-post owner in a fantasy setting. Github repo [**here**](https://github.com/mark-chimes/trading-post). The (first, very rough, non-working, template) GUI hosted [**here**](https://mark-chimes.github.io/trading-post).
I write Elm for a living. I deploy it on production that is earning my bread. And I can tell you, I don't need faster growth rate, or faster adoption rate. Elm is great, because everything is toughtout. Elm is great because packages are great and don't fuckup. I don't see a point in wishing bigger adoption for others, except for the desire to be cool and recognized. Something that with JS was sign of times: every big js library, has a website, logo, donation page, as if they are attractive cool product. Code should work differently with less of marketing, more of category theory. :) So no, Evan is the one person that is KEEPING Elm AWESOME! &lt;3
I think after initial pain of setting whole thing up you will be happy with result and maintainability of your code :) As per loading and saving state. I would recommend having a type which you can easily push trough ports, and that store in whatever for you'd see fit on JS side. Same thing with configuration. If your write a parser that will load big string and output your game data (customers etc), i think you will have no problems loading different files fast and easy.
If I skim through Slack and see something that interests me, I tend to open a discussion for it on the discourse site. Some topics are suitable for Slack, like "hey, how do I parse a Date?". Others are better suited to a slower and more considered format.
Yes, this. I am using elm for a project at work, in an academic environment where I'm the only programmer and programming makes up only a small part of my job description. I enjoy learning about elm and would like to be a part of the ecosystem. But the constant refrain of "discuss it on slack" just kills my motivation. I get the sense that the elm community is geared towards a small group of insiders who have the time to maintain intellectual and social connections via chat software. That's not something I can do or aspire to. This contrasts with other development communities I've participated in (emacs/org-mode), where the primary means of communication is mailing list. There I could and did make tangible contributions without being constantly reachable (or even spending much time on communicating, as opposed to coding). That experience was rewarding for me, and I like to think for the community as well. (I stepped back a few years ago due to health issues). On the other hand, with Elm I feel like an outsider looking in. Evan has mentioned wanting to see Elm grow to support usecases like mine (data visualization, UI programming for not-full-time programmers). But I think it will be difficult to grow in that direction unless the community structure changes. (PS I really don't like posts like the OP which say things like "Elm is dying, Evan must do X, Y, Z." I think they are provocative towards Evan and the other Elm core team, and counterproductive in building the community. So I want to be clear that I'm not saying "Elm must ditch slack," but rather just laying out what I think the effects of the choice of communications medium has on the ecosystem.) (PPS The new Elm discourse site &lt;https://discourse.elm-lang.org/&gt; is a great step towards having a better communications platform than either slack or google groups.)
one is glad to be of service. :) 
I think the issue of language and community stagnation is a real enough issue to worry about; because even if Evan doesn't care about market share, Elm still needs a critical mass in terms of adoption to make sure the tooling, libraries, knowledge base, and so forth is maintained. So has Elm reached critical mass in adoption? In my mind, yes. Now, you're worrying about growth being too slow, but I think at this point in time, Elm doesn't need a lot of growth; it just needs to not shrink. I think about it like this: Elm is still very young with a lot of ground left to cover in terms of design; so at this point in time, Elm just needs enough users to sustain the community through these changes. And since the community is not shrinking, I think Elm is in a good place! So Elm doesn't really need more momentum right now; Evan is doing what Elm needs in order to become a language for conquering the world (give or take), and the community is broadly okay with that and sustaining itself despite the changes yet to come.
The Clojure community came to the exact same conclusion.
In some ways, I can sympathize for your frustrations; it doesn't seem like releases happen very quickly. On the other hand, I don't feel the struggle when I'm actually developing in Elm. If the language stayed the same as it is today, I'd still continue to use it for quite a while. Where I feel there's room for growth is around tooling and libraries. The tools that are out there aren't bad, but (like everything) they can improve and expand. We as a community can start working on this and let Evan continue to deliver the quality he has been at the pace that's been working. I think the trouble is that Elm competes with JS technologies. Love it or hate it, JS is probably the fastest moving community ever. Its hard to ignore JS market share, but I don't personally feel its because of the outstanding merits of the language, its because everyone who is involved with frontend web development HAS to touch it at some point or another so there's a lot of effort around improving their experience. I chose to use Elm because its brings sanity to the browser and the predictability of the language. I think a comparable situation on the backend is Go. Both Elm and Go are engineered languages (versus languages that evolve as needs change). Even now, the book recommended to most beginner is [The Go Programming Language](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440/ref=sr_1_1?ie=UTF8&amp;qid=1519390702&amp;sr=8-1&amp;keywords=Golang), which was published in October of 2015. Find a JS book published two and a half years ago that's still the #1 recommend book for people to learn the language. I'm sure this relates a lot to my personality type, but I use both Elm and Go because of the consistency. Elm programming at one job is VERY similar to Elm programming at another job. JS programming at one job may be a completely difference experience than you'll find at another job (or even another team within the same company). I view the price of consistency and good design is slower release cycles. All that said, I don't blame you semorg, you seem genuinely interested in helping, not just complaining. Your post has me thinking of things I can do to help the community out with adoption. I'll let that idea simmer a bit and try to think of what I can do too.
Yes, the Clojure community definitely suffers from the same problem. I get the feeling on reddit that most people believe Clojure is slowly on its way out. I actually don't believe this is true at the moment; I think it's just an illusion caused by much of the community activity moving to Slack. But this very illusion could easily cause the language to decline in the long term. It's not easy to attract new users to a language that appears to be dying.
I think that what Elm needs is not so much more releases but guess bloggers for the official site and more visibility for the Discourse board.
I would not react to personal attacks because don‚Äôt feed the trolls. To me the issue seems more fundamental: You are talking about elm like a startup that needs a hockey-stick growth to attract investment and survive. That is not how elm works, much less so because it is open source and I like it that way.
Yes, that was my second point. That the very least, Evan can have others take over Elm-lang site and write guests posts and have regular updates on the blog post. 
Right. And of course Evan owes us nothing, we can choose to use or not use pre-release software. But the attitude from others on here and the other thread are an issue. I deal with this attitude of thinking it is almost a virtue to not be adoptable in the Erlang community :). 
"if you don't try and fit in, your don't have to compete" One of the ways Elm stands out is not changing all the time.
I don't think Evan's lack of communication is too much of an issue, it's the lack of quality getting started guides, tutorials and documentation that I found frustrating when starting out. If anything the fact that many guides hadn't been updated for the latest version caused most issues. ReasonML was in an even worse position until a few months ago but the community driven by Facebook have really pushed things forward. Feels like the momentum is with them now and I fully expect it to power past Elm in popularity this year. For me Elm is the better concept but I'll be enjoying the ride with ReasonML for now, might check back on Elm in a few years time as it's sure to be a quality product. 
To each his own, but mailing lists, tend to become a nuisance, IMHO. At least with Slack ( or other chatting software), I can easily skim/ignore unrelated discussions, and also initiate a private or a small group chat about specific topic. With mailing list - it's one big pot of everything, and I tend to tune them out after a while. I ended up unsubscribing from all of my Google group emails for that reason. Forum software, like the discourse site you mentioned, is a great middle ground IMHO. 
If offline, one can use `elm-install --skip-update` and install directly from cache. This, of course, requires the packages to be cached.
&gt; Its always going to be a more niche platform for more experienced programmers I‚Äôm interested in this opinion. As a newbie to Elm, to FP and with limited JS experience, I‚Äôm finding Elm an absolute joy to learn and use. Granted, what I‚Äôm doing is about as basic as it gets, but I don‚Äôt feel excluded as an inexperienced programmer. A lot of users also seem to pick up Elm as a gateway to Haskell. It (Elm) has a reputation - as far as I can tell - as being easy to learn. What is it that makes you think Elm is for experienced programmers? I can feel my Imposter‚Äôs Syndrome coming on again. üòâ
I'm finishing up a proof of concept for using Elm and Google Charts together via ports https://github.com/mikeonslow/elm-google-charts-example. We're refreshing our analytics dashboard at work and I wanted to get an idea of what it would take to use Elm for most of the project rather than for a small portion. It's definitely a rough draft but I found the experience of building it very enjoyable (as I normally do when working with Elm!) and wanted to share my example with the community.
I propose a new unit of measurement: TtFM Time to First Monad :-)
Yes, but he has VERY LONG view of Elm. He sees this as a language that could last for the next 20+ years. When you see it from that perspective I think his choices and actions make a lot of sense. However, I would also welcome more openness and more communication. 
I strongly agree, Slack and Discourse suck, and I no longer follow along as they're really inconvenient to use.
I've only written a couple things in Elm, would like to do more, but it's hard getting the rest of my dev team behind it since it's still in alpha and might be abandoned in a year if for some reason Evan stops working on it. No one wants to have to learn a dead language just to add a feature to a project in an older repo. I already hear groans when devs encounter Coffeescript, and that's a very intuitive language if you're half-way competent with Javascript and Ruby/Python. Growing the community is the only way to ensure that Elm will continue to exist.
San Jose this sunday: https://www.eventbrite.com/e/learn-elm-tickets-43463409227
&gt; Growing the community is the only way to ensure that Elm will continue to exist. Precisely, my sentiments. 
&gt; For me Elm is the better concept but I'll be enjoying the ride with ReasonML for now, might check back on Elm in a few years time as it's sure to be a quality product. I like Elm more. I even wanted to make part of our key product in Elm. But I just don't trust it will be there in 2 years or so. For that reason, I'm also looking into ReasonML. It seems like, it's already getting more adoption in live projects than Elm. 
&gt;has VERY LONG view of Elm I know he does. I've spoken to him in person. I admire that. But a language that no one uses has no future. It becomes academic. The world is littered by great academic languages that no one uses outside of the academic environment it came out of. If that's his goal, I think he should be upfront about it and say, my goals is to make a perfect language that is more academic than a development tool. 
&gt; Elm just needs enough users to sustain the community through these changes. And since the community is not shrinking, I think Elm is in a good place... I'm just not sure that will continue for too long. Maybe the community stays at where it is today. But then it misses on many other future libraries from other developers that can expand the libraries. The problem is, it's hard to measure shrinkage of community, until it's too late. I think ReasonML and other solutions that are better promoted, will probably capture the best and brightest of the community members. Ultimately providing superior libraries in those platform over Elm. As a serial entrepreneur, this is something I've seen and I have a strong appreciation for. I think Evan is not seeing that, and he is being a bit naive in that sense. 
When you get really good, you get negative TtFM.
&gt; The alternative would be to make more mistakes which in turn would also more often break things I'm not suggesting he should not be deliberate. The very least he can hand off the official blog to someone else. With monthly updates, articles and some official communication. Sneaking into Evan's github commits to see what might come out of Elm is ridiculous. 
&gt; I'm more worried now that I see how many in the community, comments in this and the other post, don't see an issue with a project that everyone knows has a major release with breaking changes coming That's a valid point. It dovetails to my frustrations with lack of communication. Again, Evan can hand off the official blog to others. Let them post about what is coming, when it might come (with a caveat of delays) and how people should be thinking about it. Whether or not there will be an automated conversion tool, etc. 
**hard getting the rest of my dev team behind it** I have heard this couple of times. But that is not problem with Elm, but peoples reluctance to dive in into ML style functional languages as a full time job. I understand, when I actually switched my project to Elm it was scary month until I got thing totally under my fingers. My biggest reason to object against this "Mr. Cz. is slowing down Elm" is that you are always welcome to fork Elm compiler and build different language based of what Mr. Cz. already built and envisioned. Your vision may be better. If you are objecting that Evan should involve more people in the release process, then you are objecting the sole reason why Elm is so devilishly attractive: fact that was carefully designed thing from ground up. You see what I am saying? Yes Evan takes its time, and modern humans are conditioned for constant gratification and exhilaration, hence his work may seem boring, and down putting to your colleagues. I am betting on Elm in long term, and let me tell you even 0.18 has everything that you need. So I can tell that your colleagues are just afraid of doing it for real, so you can actually feel the joy of ergonomic language :) Ok this is a rant, and I apologize :)
/u/rtfeldman Richard - I was hoping to see your thoughts and comments on this thread. However, with something more insightful (I guess the comment is deleted now). I actually think you can take on becoming the public face of Elm on a more steady bases. Perhaps taking over the blog posts. I'm guessing your hands are already full with "Elm in Action" and running your day job. But it would be nice if you or someone else at NoRedInk took on managing the Elm blog and published something on regular bases. 
&gt; I look at other small projects like Aurelia, and they try to maintain a regular cadence of blog posts I looked at their blog and they've done a simple but a great job maintaining a cadence of blog posts. This is a great example that I would like to see Elm do on its blog: http://aurelia.io/blog/2018/01/03/aurelia-2018-roadmap
&gt; Some topics are suitable for Slack, like "hey, how do I parse a Date?". I wish this kind of Q&amp;A was done on StackOverflow. I'm new to Elm and I constantly find myself searching the web for Q&amp;A and code examples. I'd rather find a solution among the top 5 search results than asking a question on Slack. In this regard Slack is like a black hole sucking up valuable information and wasting large amounts of man hours, because things have to get asked and answered over and over.
955
I catch your drift, but I think the timing is quite crucial. For example, right now Rust is attracting a lot of smart people to do important work, but a large part of that is because Rust has hit version 1.0 and is considered stable. The situation was quite different before hitting 1.0, and I see Elm in the same way: the real growth is going to hit once the stability mark is reached, and right now it just needs to sustain itself up to that point. I realize the situations are quite different though in a number of ways (e.g. the web community seems less concerned with using something unstable than the systems community, and Elm has a number of users already in production, despite the instability). But I think the analogy is accurate enough to be useful at least :)
I dont have a good answer here, but like haskell or other ML style languages, Elm has features and qualities you understand and/or respect only after you have programmed for a while and used other tech. 
The tiresome part is that many people on this thread and others like it put a decent amount of time patiently responding in some detail how they are not blocked by the pace of Elm's development, and then get to do it all over again the next time it comes up, usually in provocative posts like this, as if the issues had never been raised before. To cut to the chase, first of all I think we should withhold judgement on the health of the community until State of Elm 2018 data comes out shortly. Second of all if engineering managers are making decisions about technology based on blog posts and other marketing, it's true they may not consider Elm. (Is this a problem with Elm or with tech culture?) But there have been many pieces written by Elm users about how to sell Elm to your organization. And looking at the increase in organizations actually using Elm in production will tell an objective story of how successful this has been. More could be done no doubt. But if you are asking for a re-prioritization of Evan's and other core members of the Elm community's time you have to look at the tradeoffs. Elm competing with the money and reputation behind ReasonML is not a winning strategy. And ReasonML would not exist if it weren't for Elm. Redux would not exist if it weren't for Elm. Elm set a new standard for friendly compiler messages that other languages have adopted. So a lot is at stake beyond Elm when we talk about Elm's survival. I also think you seriously underestimate the effort involved in writing regular blog posts. There's not just the time involved in researching, writing, editing, formatting, etc. but also the time and mental space considering people's responses, which are often misinformed and hostile, and in some cases actually responding to them, which goes on for months and years. I don't think the community is well served by putting this job on Evan.
That seems fine to me... as long as the inputs can all be boiled down to a set of types. Often times you need different validation on different fields, or to parse the input slightly differently. In those cases you might start with one Msg per input and later when you refactor see how common bits could be extracted. &gt; I have a form with about a dozen inputs, some of which are only required if others are Curious, how do you model this to avoid impossible states?
You have to handle all the cases. You can't use `_ f` to pattern-match on "all cases that have one piece of state". case v of EqualityModel f -&gt; f OtherModel f -&gt; f 
The original post was constructive criticism.. It's no way related to the nitwit from the Clojure thread who basically said: "I want a free datomic, and if you don't give it to me, then fuck clojure!" And I think Rich over-reacted to that dipshit. You mean a man like Rich with a dozen years of building clojure is going to have a despair-inducing meltdown over some troll? Really? Obviously, the dipshit was a Sanders "i want free shit" moron, and Rich is a Trumptarian conservative economic hard-liner. And you know what, I just made up that stupid political stuff because sometimes you got to hang loose and know when things are ridiculous, and have a laugh at things. Now I know that SF is ground-central for hyper-sensitivity, but to say the OP induces "major emotional violence" is dramatic for SF standards. All this fellow was saying is: I love elm, please promote it more, just with short blog posts once a month, or regular guest posts from guys who would love to do it. That's all. Evan has major skills as a language designer. He doesn't have major skills as a marketing dweeb. But some people love to be marketing dweebs :-) So loosen the reins a bit and let them have a go. You might fuck up a few times, but so what? People will always give Evan the benefit of the doubt because of the time he puts in. That's what I like about hanging with Eastern Europeans and Russians. They'll call you a stupid piece of shit, then take a shot of vodka. Then you'll say they've got an ugly wife, and take another shot. Then you'll jump into a frozen lake, and run home to said wives for a warm night. Rinse and repeat tomorrow. 
Folks, When making a post like this, you should really consider the reader. For example, framing things as "person X is killing Y" is neither friendly nor a suitable way to ask a question. If you showed up to work and someone said "Hey, why are you killing &lt;product&gt;", you'd feel pretty bad. It's always better to phrase things like: "Would Elm have more momentum with more maintainers?". You might be passionate about Elm -- a lot of us are. But consider others in the community. Clickbait-titles that accuse or target people aren't really acceptable on this subreddit. 
Elm is not just competing with React it is also competing with ReasonML and Purescript. And ReasonML has powerful sponsorship from Facebook. Also there are plenty of examples where slightly inferior technologies beat superior ones.
Sorry about that. The nightly versions of Firefox work but the current release has that issue
Sorry, but same here in Chrome. Seems to be auth0: Uncaught (in promise) Error: auth0 is not defined Evaluating https://wonktonk.com/app Loading app
&gt; That's what I like about hanging with Eastern Europeans and Russians. I, too enjoy working with Russian/Eastern-European engineers for a similar reason. They tell you if the idea is stupid or not, but it's not malicious. Once you understand that. You really appreciate working with them. 
&gt;I've had difficulty sleeping since you posted this. I'm sorry if it hit you this hard. My motivation was to drive a strong point and galvanize urgency around the topics I raised. Seriously, It's NOT cool to not have a blog post update in 1 year! &gt;to inflict major emotional violence on my friend My initial feeling was, that you were overreacting here. However, after thinking about it. I think your reaction might be caused by something deeper. Ask yourself, Richard. Are you having this reaction because you might be agreeing with my sentiments (and others who have been raising the same issue in the past) and feel that it's you who has let down your friend, Evan. Maybe you feel like you could have done more. Or perhaps you realized the blog needed more frequent updates but you couldn't bring yourself to push Evan to do it. Now, the guilt of not doing that is adding to the agony you're experiencing from this post and the ones similar to it. All of us who are taking time to post here, do care about Elm. Because it's a great language and we have devoted the only precious commodity we have, time, to it. We have been advocating for it and we are excited to see where it goes. It's a journey we're all taking along with Evan. But we need some roadmap. Even you, your book had an estimated delivery of Dec, 2017. A large portion of it, is not finished yet. Is it because, you too, are also waiting to see what new tooling Elm will add so you would not have to release a book that is already outdated, when it comes out? We're all professionals, here. I think rather than loosing asleep, it's better to see what is causing these posts (which has a lot of upvote count despite 30% downvotes) and come up with a solution and deal with it. Anyways, I sincerely hope you sleep well tonight. 
I guess the least bad thing here is to respond to you despite saying I wouldn't. The alternative is to let people think your accusations might be correct. &gt; Even you, your book had an estimated delivery of Dec, 2017. A large portion of it, is not finished yet. Is it because, you too, are also waiting to see what new tooling Elm will add so you would not have to release a book that is already outdated, when it comes out? No. When the book comes out, Manning prints a bunch of copies based on how many get ordered. If the language updates, I update the book. (I've already done this once, for 0.18.) If it's a small change, the next print run is in the new version. If it's a big enough change, it becomes a second edition. This is a normal part of the modern publishing process. The only way Evan's schedule impacts mine is if I know a change is coming down the pipe. I'd rather write for what's coming than for the way things are right now. (e.g. not doing a section that relies on custom operators being a thing.) That's to save myself time rewriting it; I'm hardly one to shy away from more work, but I'm a glacial enough writer as it is. It's impacted the order in which I write things, but I'm not resting on my laurels avoiding writing because of language changes. &gt; Ask yourself, Richard. Are you having this reaction because you might be agreeing with my sentiments (and others who have been raising the same issue in the past) and feel that it's you who has let down your friend, Evan. No. Not only had that thought not crossed my mind, it also hadn't crossed my mind that you might respond to my opening up about the personal impact this post had on me by asking me if I'd considered whether your actions were maybe my fault. This response was truly breathtaking. I'm actually feeling much better knowing what type of person I'm dealing with, so thank you for that. &gt; it's better to see what is causing these posts (which has a lot of upvote count despite 30% downvotes) and come up with a solution and deal with it. Well, two can play at that game: have you considered that maybe the problem is *you?* If not, let's say hypothetically that the root problem here was an out-of-control sense of entitlement on the part of certain open-source software users. That maybe this is the reason open-source maintainers burn out and walk away from their projects. That maybe, despite the best of intentions, one could write an inflammatory post that actually drives a project closer to the grave than to the poster's stated goal. Or let's say that this is not at all a hypothetical, and is in fact well-documented: * https://github.com/Homebrew/brew/blob/master/docs/Maintainers-Avoiding-Burnout.md * https://www.techrepublic.com/article/why-open-source-developers-are-burning-out-no-respect/ * https://thenewstack.io/darker-side-open-source/ * https://nolanlawson.com/2017/03/05/what-it-feels-like-to-be-an-open-source-maintainer/ * https://storify.com/trodrigues/why-i-don-t-like-open-source-a-play-in-3-acts So let me hold up a mirror to the title of your post: If you love Elm so much, why are you putting so much energy into killing it?
&gt; The only way Evan's schedule impacts mine is if I know a change is coming down the pipe. I'd rather write for what's coming than for the way things are right now. That right there is the problem. You know because you are his friend and work with him closely, but we don't know. We can only see a 1 year old blog post and and a 1 year old [roadmap](https://github.com/elm-lang/projects/blob/master/roadmap.md), and when people actually ask about updates they get shut down. This is why I no longer interested in Elm.
&gt; The alternative is to let people think your accusations might be correct. I think, "accusations" is rather a strong word, here. &gt;The only way Evan's schedule impacts mine is if I know a change is coming down the pipe. I'd rather write for what's coming than for the way things are right now....That's to save myself time rewriting it You're basically agreeing with me. That's basically what I was suggesting. You're waiting to avoid having to rewrite the book and your book publishing estimate is already 3 months past due. &gt;hypothetically that the root problem here was an out-of-control sense of entitlement on the part of certain open-source software users I'm really sad to hear that. This seem to be the fundamental issue here, perhaps. Some of us, have become accustomed to what I consider certain industry-standard norms. Especially around libraries and tools that are used in production projects. These norms, include some basic and minimal level of communications to the the users and adopters. Take something like Redis. The communication, the level of response out of a one-man project is great. But Elm, has been backed now by two companies. Prezi and now NoRedInk. It was actually the validation and your comments about how much more reliable your software releases are because of Elm that I started learning it and seriously considered our team using it in our next major release. For people to trust a product in midst of many competing ones, they need validation, they need to trust the solution. They need to feel comfortable once they commit their team to it, this solution is going to be around for foreseeable future and they're not betting the future of their company on one developer who might be at risk of burnout from a reddit a post. No, it's not an exaggerated sense of "entitlement". It's certain basic industry-standard practices to share the vision, planning, roadmap with the community and the decision-makers. Perhaps it was the initial tone of my post, that has put you in a defensive posture. But, what I'm hearing from you is rather discouraging. Instead of understanding the community and reacting to their comments, you're saying we are "entitled" and should not be expecting any communications. Where as, all you had to say was: *We know this has been frustrating. It's something we are discussing with Evan and it's something we'll work on improving.* There is another way of looking at this. Richard, like it or not. You've become the second face of Elm. Like it or not, Elm has become successful to some extend. Along with that, you're getting certain amount of celebrity and notoriety and you're building a brand as a result of Elm. Evan started a great language and he is getting paid to work on his dream project. With this, certain amount of scrutiny is inevitable. It's only going to get more as Elm grows. So this is a good time to have a strategy to best adapt to it. &gt;If you love Elm so much, why are you putting so much energy into killing it? Contrary! I think comments like mine (an others who have been relentlessly asking for updates) will/could help save Elm. It all depends how you react to them. If you turn this into a grudge-match and dig your heels and not budge to the community, yes, then it might kill Elm. But if you can better manage these criticism and respond to them positively, it will help increase the success of Elm, IMHO! edit: fixed formatting 
Isn't questions like "hey, how do I parse a Date" perfect for places like stackoverflow so people wondering the same thing can go there and find the answer so they don't have to post the question over and over again? 
The knowledge gap there is a smaller than I think people assume. In the past, Evan would routinely speculate in public - e.g. "I was considering these options, X, Y, and Z, but I need to investigate further." - but over time, it got to the point where speculation was routuinely met with pressure to ship sooner. "Hi Evan, just pick X, that's what React does. We'd rather have it right now than wait for you to look into Y and Z." So he dialed public speculation way back. Does he still speculate around people he personally trusts? Sure. But it's still just speculation, and it'd be risky for me to make assumptions (about the book or otherwise) based on that. If something's been resolved one way or another - e.g. "0.19 won't support custom infix operators outside elm-lang packages" - I don't think I get that information notably sooner than the Internet at large. I do understand the frustration that the roadmap document doesn't lay out a timetable of feature delivery dates, but to be fair, the document does explain why that wouldn't honestly reflect reality.
&gt;However, I think it's **really important** that the blog post topic not distract from the much, much more important point of this thread, which is this: &gt;Elm community members must not attack people to get what they want. I agree one hundred percent with that point. However that one guy should not prevent some needed introspection. Elm aims at being mainstream. And the current communication strategy hinders that because it makes people afraid. And scared people lash out. Sure you can say that people have no reason to be afraid and I agree about that. But it takes significant research about Elm to find that out. And fear is not rational. If you want to be mainstream you have to acknowledge that [reducing fear is the killer feature](http://headrush.typepad.com/creating_passionate_users/2006/10/reducing_fear_i.html).
If only there was a programming language that guarded against exceptions at compile time
Wow, what a thoughtful post! Thank you. ‚ô•Ô∏è One of the challenges with balancing this is that communicating things that are still uncertain and then changing them can also create fear. "Is this real? I don't know if I can trust it. Last time you said this was the plan, it totally changed a few months later." For example, I bet the final changelog for Elm 0.19 alpha is going to bear very little resemblance to what I expected it would be when 0.18 came out. Elm is still pre-1.0 in large part because of the reality that there is little certainty in the plan right now. Honest question: do you think it would help people with fear to say "this is the plan right now" and then to change it every few months? That would certainly take more time and work than the status quo, but do you think it would be better for people using the language?
I asked in the slack and wasn't shut down. Vaguely remember that the only real big thing you have to watch out for is that you won't be able to define infix operators (like for example the rocket operator (=&gt;)) and also (!) is being removed. 
Considering that - you post a "polarizing and provocative" question, by your own admission, to goad people into responding, and to draw support for your point of view; - you use an inflammatory and clickbait title; - you further goad Richard Feldman into responding by insulting his work; - you don't respond to his and others' legitimate points that having more regular status reports from Evan has hindered development by leading to more lobbying and speculation; i.e. _the strategy you are suggesting has been tried and rejected_; - you say nothing about what you are doing to evangelize or mentor people in or even just use Elm; I think the mods of this subreddit are exercising extreme restraint with you. It has nothing to do with your point of view, which has been debated and will be debated many times to come. It has to do with how you raised it. If you have the time and are serious about supporting Elm, there's plenty you can do. Take a turn on the Beginner's Questions thread of this subreddit. Spend an hour a day answering questions on the slack channel. Write a blog post evaluating Elm for your situation, aimed at managers who have considered but rejected Elm for reasons A B and C. Participate in local meet ups. Do an occasional podcast interviewing people in the community. This kind of post on the other hand is in bad faith and is not constructive in the least. 
My weekend combination ‚Äúlearn Elm‚Äù / ‚Äúscratch my own itch‚Äù project, for browsing Dropbox directory sizes, is finally ready for some (gentled) tire-kicking and feedback. It's built on top of [elm-dropbox](http://package.elm-lang.org/packages/avh4/elm-dropbox), Semantic UI, Highcharts, and [Poi](https://poi.js.org/). Source: https://github.com/osteele/banyan Deployment: https://banyan.osteele.com/
&gt; Honest question: do you think it would help people with fear to say "this is the plan right now" and then to change it every few months? I would prefer this to the status quo. I think a shifting plan with a short description of the insight that triggered the change would be preferable to leaving people in the dark. "The night is dark and full of terrors" When people are left without information it is very tempting and easy to imagine disaster scenarios. I, for example, having experience with depression, wondered about the possibility of Evan having some kind of burnout/depressive episode. I remember reading some old topics (maybe from 2015) some time ago and asking myself what happened to that Evan that was present in the mailing lists. &gt; That would certainly take more time and work than the status quo, but do you think it would be better for people using the language? Sometimes, if you slow down, the trip is nicer for everyone involved. Sometimes, it is not about the absolute speed at all but about the perceived speed. Sometimes.... it's not about the code. 
Compile time is the new runtime.
Let me start by distancing myself from the OP and his approach. Bad form. That said, one thought for the powers to be ... it is a bit silly to argue that a blog with no posts for over a year is anything but a negative. I don't see how it serves anyone well, regardless of intentions. If I may, there is a ton of work being done by Evan and 'team' for conference presentations. In fact, Evan's Elm Conf talk discussed some of these issues head on. I would suggest that the blog is updated with links to those talks with just a brief topics summary. It would go along way to show those who stop by the momentum, the work being done, and the philosophical approach under which Elm is being developed. 
[Apply directly to the forehead!](https://www.youtube.com/watch?v=f_SwD7RveNE)
Posts like this make me never want to even consider managing an open-source project of any kind. When you say you're being "polarizing", what you're doing is being accusatory and mean. Richard's links about open-source burnout are dead on. You're not the only person who does this, and it ruins communities. Having concerns is fine. Deciding to draw attention to them by being mean is not. People leave open source, and other people decide never to even get into it in the first place, because of how often people decide to behave the way you decided to behave here in this post. Several people have told you how your post came across, and have explained why it's not okay. And instead of apologizing for the way you brought this up, you've justified it and blamed others for how they reacted. Listen to what people are telling you, and apologize, and do better next time.
Does the wrapper thing affect performance? If I create a function in elm that takes 3 arguments, then calling it with 3 arguments gets turned into calling 3 functions. In most UI-building cases this won't matter, but if you're doing something like making line graphs and you run a lot of code in elm to generate your data, could performance take a hit vs plain JS?
Well that's something I didn't know because I'm on slack very rarely and I don't have time to read all the messages I missed.
Looks like for layout they have done the hard yards in the update/view (https://github.com/debois/elm-mdl/blob/v8/src/Material/Layout.elm) and so I assume this is not being offered as a seperate 'component'. Therefore unless you want to do the pull request and add chevrons to the tabs control, you might need to think of a different way to do it. For example the drawer property of the layout could give you a second level of 'menu' under the main one.
I would agree re overly private discussions, but I think the premise is kind of ridiculous. I don‚Äôt see Elm losing momentum, and I‚Äôm not convinced it‚Äôd be so bad anyway. I‚Äôve been in languages which became the flavor of the month. it comes with a price, and it‚Äôs debatable whether what you get for that price has any value for a language beyond a brief but enjoyable spike in consulting fees anyway. Elm is great and I appreciate Evan‚Äôs work on it.
I just got through the first half of this book on a flight. Thanks for the timely recommendation! It's absolutely fascinating so far.
There were a couple of Slack discussions about it awhile back. (Not saying that's the easiest medium to check or anything, just that it's been openly discussed in public channels.)
It always has.
I really don't think OP said anything that mean in his post, but then each to his own.
your update is a `fold` (or reduce or however you want to call it) in general you cannot parallelize this (as you can monoidal operations for example) but that's not really a problem for a GUI as your probably don't want to have concurrent updates to your UI in the first place so in TEA there are no "out-of-sync" events - all pass through update-view or are ignored
Before we can have a constructive discussion, OP should apologise for personal attacks and rewrite this post. Preferably without this doomsday, "let's get out our pitchforks" theme. Yeah, this is not going to work, amigo.
&gt; so in TEA there are no "out-of-sync" events - all pass through update-view or are ignored And if an event fires before the 60Hz view update has been rendered which would have removed that event?
Nice post. Elm is really great to make me rethink about how things should be done, and what they really are. And yes, last Elm Meetup in Paris was great for explaining this stuff. I'm new to functional programming but I like it for its safety and its way of thinking about problem. A problem is nothing that smaller and easier problems :)
&gt; irst: sorry about the "or are ignored" part from me - this was highly misleading or even wrong - I'll remove it Okay thanks for the clarification. I don‚Äôt know what Elm is doing because I haven‚Äôt use it. I‚Äôm basing my inquiry only on reading some of the documentation, blogs, etc.. &gt; what do you mean by "removed that event"? If the update changes the state such that the view will end up removing an event, what happens if the event fires again before the view can remove it? That would be an inconsistency because the state of the model assumes the event can‚Äôt fire again at that point. We were [discussing this pattern](https://github.com/keean/zenscript/issues/17#issuecomment-364913864) several days ago before I encountered Elm. &gt; also where did you get that `60Hz` idea from? https://github.com/evancz/react-angular-ember-elm-performance-comparison#no-requestanimationframe-in-elm
&gt; I'm sorry if it hit you this hard. My motivation was to drive a strong point and galvanize urgency around the topics I raised. You can do this without using a title designed to provoke emotional reactions from the reader. There is a huge difference between what you say and how you say it. Framing things as "X are killing Y" is how you get upvotes, but it is not a reasonable way to communicate in a community. Again, the problem is the _way_ you tried to get your message across. &gt; Ask yourself, Richard. Are you having this reaction because you might be agreeing with my sentiments (and others who have been raising the same issue in the past) and feel that it's you who has let down your friend, Evan. This kind of manipulative question has no place on this subreddit. &gt; All of us who are taking time to post here, do care about Elm. Interacting in this manner _is not welcome in this community_ and any threads with similarly click-bait titles targeting other members in the community will be deleted. Thread locked.
&gt; the view will not remove events - the view is a pure function from a state to say HTML Indeed, but the HTML produces contains events: https://guide.elm-lang.org/architecture/user_input/buttons.html Now what happens when an update changes the state in such a way that the event is not in the HTML upon updating the view. And what happens if that event has fired interim, that is an inconsistency.
you include something the elm-runtime/renderer will translate into an event-handler that will raise an event that in turn will end up in your update function in some form so if your model (*the* state of your application) indicates that right now it is not interested in said event you just ignore it (meaning you don't change the model) so yes it can happen that you get events that are not valid for your current model any more - and yes the order your events are processed will determine the model state and yes that could depend on the rendered view state (say you model just could button presses but stops to render the click-event once it hits 10 - if you are fast enough you could produce say 11 events and if you update does just increase the number you could end up with a number higher than 10 - but that's because you did put logic out into your view - the "stop counting at 10" logic - instead of having it in your update - if you had it in your update you would be fine here)
Indeed, the fact that the concurrency is ordered into a single stream of events is the main strength of the ELM architectures in terms of concurrency, it might make the it less "general" but is makes the concurrency significantly easier to reason about. With that said the ELM architecture is not immune to concurrency bugs, one bug that i have seen in reality is when you bind an event to onInput and then send the text in the input field to the server to do autocomplete, if you don't handle the fact that the responses can arrive out of order then you can end up in a state where the input shows "ABC" but you are showing results for "AB" because the responses arrived out of order. One solution in this case would be to ignore outdated responses in the update function. 
Yes you're always going to have to do some handling of out of order responses when you have two asynchronous feeds which are related, but that's really easy to do using Elm-like tools.
You might want to parallelize tasks, even if you don't parallelize updates. You don't need a monoid necessarily. I have an actual use case for this in my side project. With the Parse REST API you need to do a separate query per object type (think separate query per database table, if you like). Then why not do all those in parallel, and as they come back update the model with those results as they come back? Here "parallel" really means "many asyncs" because the parallelism is happening somewhere else, not on my cpu. Anyway to implement this with I think you'd just use Cmd.batch which I think would run all those in parallel.
But the introduction says it can be utilized for general effects: https://guide.elm-lang.org/architecture/effects/ So I want to understand the limitations of that.
The Elm Detroit meetup is happening this Thursday at 7pm: https://www.meetup.com/elm-detroit/events/245681039/ At these events we have a mix of open space coding/discussion as well as an intro workshop for folks starting out.
On a fundamental level, it‚Äôs really about shared mutable state isn‚Äôt it? Your reads from I/O don‚Äôt depend on shared mutable state until they want to update the local state. But that presumes there‚Äôs nothing else going on that could create dependencies between writing reading something, updating, and reading something else, i.e. if updating is feeding back into that external I/O you‚Äôre reading from (even transitively). Afaics, in the general case, this is [an intractable problem to model at compile-time](https://github.com/keean/zenscript/issues/17#issuecomment-366867722). 
&gt; it might make the it less "general" but is makes the concurrency significantly easier to reason about When the concurrency you want to model fits into that idealized model.
the effects mentioned there are basically commands and subscriptions - it's a mean to get sideeffects out from and in to this model in a pure-functional fashion (by pushing the dirty part out to the runtime) the only time "general" is mentioned there is for the debugger ;)
yes things are not perfect - as always when you have concurrency (where basically order of things happening will factor into your behavior) I have no clue if there *is* a solution to this but no elm don't has either - it just makes dealing with this stuff much less painful (no need for locks or other synchronization for example) you "single-shot" idea is not bad (sounds a bit like linear types) - you could try and propose something like that - although I guess it could lead to lost input
Hey, nice, thanks! Might make use of this.
Philadelphia has them every couple months or so. There aren't any Elm Meetups posted right now, but there was one this past Thursday.
I think something like todo-mvc would be a good candidate https://github.com/evancz/elm-todomvc/blob/master/Todo.elm
Have you seen [Richard's talk on teaching Elm](https://www.youtube.com/watch?v=G-GhUxeYc1U), which is roughly 30 minutes long :-).
I think something like the [challenge 4](https://github.com/pdamoc/elmChallenges) would be a good experiment. You could implement an "app" that interrogates an already established backend and displays the data. This would allow you to go through the Elm Architecture, explain records, explain type aliases, side-effects. If time allows (altho I seriously doubt it), you could also implement the debouncing of the input. 
Simple login form is great thing for a starter also, because it emphasizes all the small stuff around building a form, controlling it's behavior, validation nice looking inputs and buttons and submitting it to server. Please let us know what have you picked! :)
I'm studying elm, I checkout your project but I do not understand how to run it locally. I tried elm-make, but it compiles one file per time. I tried elm-reactor, but again it is more one file per time without style sheet.
If this will be a recorded thing, I would appreciate it a lot. : )
Any Seattle Tacoma area meetups for elm?
Just stumbled on this motherload: https://www.elmlog.com/meetup_groups
I'm trying to start studying elm, but my first impediment is that what ever project I checkout, I do not find the way to run it in development mode and debug it. I know about elm-reactor but it is running a file per time, instead I would find more useful to run the full "webapp" 
To answer myself, I found this package https://github.com/architectcodes/elm-live it is used also in https://github.com/rtfeldman/elm-spa-example
Very cool, thanks for sharing.
Usually I am incorporating Elm into an existing web app. For simpler stuff I just install the compiler and include the output in a script tag in an HTML file.
I think I am fundamentally misunderstanding something because I can get elm working with elm-reactor or elm-live, but I do not understand what to do with the output of webpack. Opening the files directly with the browser doesn't work, neither does serving them up with a webserver (all the URLs are absolute, so it all breaks). How is this supposed to work?
IMHO, I wouldn't be impressed by seeing a creation of regular todo app. But if you include into it some selling points for elm like time traveling debugger, the type system that helps doing painful refactoring (and show it in action) + some small example of making impossible states impossible, that could be interesting. I'm actually planning to do the same and re-writing a part of our app in elm as a demo.
This article looks promising. You should expand upon your experience more. What led you to choose Elm other than frustration to other things? How has your experience been this far using Elm? 
great ideas. I will add that
We underwent a similar dilemma. I personally wrote 30,000 lines of Elm code almost all backend stuff. I wrote `elm-grove` which was hated by Evan so much that he pretty much decided he needed to shut down any such "unsanctioned" usage of "his" language. I'm still a bit pissed about what went down (never in my nearly 4 decades in software development have I ever encountered a language designer who wanted to dictate how anyone used the language), but I must say while it was a short term hit, in the long term we dodged a bullet. Okay, maybe not dodged. But it only grazed us. We're still using Elm on the front end for our project because we are now 6 months behind schedule but we will look seriously at other solutions for our next project. For the backend stuff, this event forced me to finally take the full leap into Haskell. I'm a week away from being back to where I was with my Elm server. This took me 3 months to learn (work time and personal) and recode. Most people would have taken 6 to 9 months to get to my level of understanding. I'm lucky that I learn quickly. And I had my back against the wall. Some other things I've heard about 0.19 is that users will not be able create their own infixed operators. I had created dozens that I used regularly. Now that I'm working in Haskell, I cannot imagine not having such a feature. These 2 major changes from 0.18. to 0.19 are the canary in the coal mine if you ask me. Elm is a great language for teaching and it's still the easiest way to get front end developers into functional programming. But I don't agree with the highly opinionated approach to the language. But worst yet is the ideals that they subscribe to can only be achieved by removing ALL the power from the language. It's like trying to protect your children by locking them up in the closet. They'll be safe from the big bad world, but they will sacrifice living to achieve such safety. All and all, learning Elm was a great intro to Haskell or Purescript. But FOR ME, it's not a language I will be programming in any more. 
Thats the problem when one guys controlls everything. I dont wanna hate on evan - he created an amazing language but he does away with stuff he thinks people dont need was too quickly imho
We're in a similar state. 10,000 lines of Elm over 6 months. Rewriting it is not an option at this stage. We don't even want to use arbitrary native code! We just want to fix some bugs in elm-lang/websocket that have a pull request open for 2 years!
&gt; he pretty much decided he needed to shut down any such "unsanctioned" usage of "his" language. How did he "shut down" the use? I see that the posts about elm-grove still exist here although the feedback was mostly extremely negative.
After 0.19, grove won‚Äôt be usable because it uses Native code. 
Where did you read this today?
Sorry should have included the link: https://www.reddit.com/r/elm/comments/7vnikt/i_have_a_proble_porting_a_js_library_to_elm/dtwlzax/?context=2
What about Bucklescript/ReasonML? There even is a very close port of TEA https://github.com/OvermindDL1/bucklescript-tea
&gt; we might just maintain a private fork of it with the native module restrictions removed. What about actually doing it? We could just fork Elm compiler publishing and maintain a more open version. Then, the time will just tell us who took the right decision. It has been done for dozens of projects (just think about Linux, OpenOffice, ...) why shouldn't we give it a try?
&gt; We love Elm and don't want to rewrite all our code but if we won't &gt; be able to use Elm 0.19 and any future versions then we seriously &gt; have to start thinking about a rewrite. I don't see how your inability to immediately upgrade to 0.19 implies the need to rewrite. As far as I understand, Evan will go through the upgrade-path for packages once the 0.19-stuff is ready for that. If I were you, I'd keep enjoying 0.18 and once 0.19 has been out for a while, figure out if the websocket-library changes have been reviewed or maybe try to get in touch about it again; I think there's a lot of pressure on Evan to be active &amp; responsive in every aspect of the project at the same time, which I'd say is impossible. Have you contacted Evan about the changes (outside of the PRs) to figure out if the changes you want to the websocket library can coincide with the 0.19 upgrade?
Based on the [response to elm-grove](https://www.reddit.com/r/elm/comments/72wsf6/announcing_grove_the_advanced_package_manager_for/) I don't think a public fork would be a good idea if we want to be a part of this community.
And what is with this raising arms against Evan? And also what was the question of OP? That others should leave Elm, because something he has an issue with? I have worked on many crappy technologies, and I never had an urge to pull other people with me when I was leaving those crappy tech. 
&gt; But I don't agree with the highly opinionated approach to the language. I actually think, the opinionated aspect of Elm is a good thing. Those of us that had to read through old Perl codes (in the olden days) can tell you that giving people ten different ways to do the same thing is a nightmare. As much as I have griped about Evan not being communicative enough on the future of Elm and not updating the site in over a year, I think his single vision approach to Elm is a great differentiating value. I just think he needs to bring more people and learn to delegate further. However, the key frustrating point is lack of repeated warnings. What Evan has failed to communicate in a consistent manner is that this is really an alpha project. And as much Elm likes to celebrate the customer-facing projects implemented on Elm lang, as part of showing the growing adoption and success, they forget to add a caveat about the alpha-ness state of Elm. In other words, if you write a lot of codes in Elm. Do it at your own risk. However, this caveat ads a bit of a dilemma: Firstly, because we don't know the delta between .18 and 1.0 (not sure even if Evan is sure about that). It's very difficult to assess the risk taken when you invest a lot of time into an Elm codebase. The caveats are there to alert people of the risks, but it's unclear the degree of the risks. If you stand by the side of a cliff and there is a sign that warns you of not getting too close to the ledge, as an adult you can reasonably assess the risk depending on the height of the cliff. With Elm you don't know how big the 1.0 cliff is. Secondly, I think with excessive caveats, there is a strong chance of decreasing adoption on meatier and larger projects. I believe Elm needs to be implanted across several larger projects, so the learning can be applied to further improve the language. But how would you get that learning without burning bunch of developer who have put a lot of time and sweat into their codes. I suppose this is like trying to capture the enemy strongholds. Bunch of soldiers need to run into the pillboxes and give up a lot for the rest of the regiment to capture the territory. Thanks for the sacrifice! 
Link of the rationale/announcement for reference: https://groups.google.com/forum/m/#!topic/elm-dev/bAHD_8PbgKE Personally I seem to be in the minority in this thread, because I agree with the points made in there. I am really excited that Elm is giving a high priority to future portability. Please tell me if you disagree, but the long-term advantages of that are huge, and the short-term benefits of native JS code are not. As a side note: I would also like to see a discussion about how we complain about those things with clickbait threads. I can see that the advantage is that major frustrations can be made very visible through upvotes (which is a good thing), the disadvantage is that it can lead to the typical flame wars that our community tries to avoid through reasonable discussion.
You fear is misplaced, imo. In Haskell we have an absolute armoury at our disposal to blow our foot into atoms if we so choose to. Yet 30k lines of code and 300 dependencies later (I just ran the numbers on our work codebase), I am yet to see an error where something seg faulted at runtime because someone decided to leave the safe confines of Haskell. &gt; That‚Äôs the stuff that worries me. If I‚Äôm debugging something weird, is the root cause that someone, somewhere, in some package or some dependency of some package ‚Äúbroke the rules?‚Äù I can‚Äôt rule it out. Sure, you can't, but amusingly you're in a *better* situation than I am in Haskell - you actually have a decent debugger behind you! Though as I'm saying (anecdotally, but that's all we're both saying) - you probably won't even get into this place. Going against the grain is painful, so you don't do it without good reason. In Haskell just writing the `unsafe` in `unsafePerformIO` makes me sweat, I know that there be dragons. And indeed, if I do use it and release it, you can bet someone will pick up on it and similar alarm bells will go off there. I don't have a huge problem with what Elm has chosen to do, but I think it's worth being aware there were alternatives - and I'm not convinced this particular change was actually solving a problem. I do appreciate that pulling this support at least forces things to change at the language level though, which in a sense is noble (though crippling for those who hit their head against the ceiling in production with a deadline that's already passed).
Do you think my thread is clickbait? Sorry I did not mean to do that. We really are worried about the future of Elm (for us) considering that bug fixes to core modules have open pull requests for _years_ and starting 0.19 we won't be able to use those forks without forking the Elm compiler.
&gt; but the long-term advantages of that are huge, and the short-term benefits of native JS code are not. That may be true but if that's the general opinion here then we made a mistake going with Elm in 2017.
&gt; What Evan has failed to communicate in a consistent manner is that this is really an alpha project. Yes, this. If we had known that bug fix pull requests would hang for years without response and one day we won't even be able to use a fork, we might have went with something else (which unfortunately would have been JavaScript and TypeScript since PureScript was way too new back then).
Yes, that might not be a bad idea for elm-lang/websocket. We're worried about the trend too though‚Äîwhat if a bug in another package which cannot be written as a port stays open for years like the bugs in websocket? I saw that talk. It was very nicely presented. It would have been nice if there was a minor release every 3 or 6 months but simple feature requests not getting a firm yes/no for years is frustrating for users. I also know Evan can't do this alone. No one can build a language, a community, and then maintain dozens of packages alone. Other communities solve this by delegating work to volunteers. I'm sure there are tens of capable individuals willing to do this in the Elm community.
I might be wrong but I believe that local 'native' code will continue to work fine. The whitelist &amp; policies that are being talked about are regarding published code, ie. published packages to the elm package repository that include javascript code.
&gt; My question to you elmphoenix, is why are you concerned, when the thing that you have right now is working nice for you? (and please I really don't want to be down putting on you, I just want to understand a concern that you have that made you write this post) Yes it has been working fine for 99% of our use case. It would be nice to have a fix for https://github.com/elm-lang/virtual-dom/issues/107 which is going to be addressed with 0.19. The real concern is that we have no idea how many releases Elm will have until we can upgrade? Will bug fixes in elm-lang/core, elm-lang/http be back ported for Elm 0.18 once 0.19 is out? when 0.20 is out?
I'd agree, I just started reading, and hit the comments section :) Also I think conclusion why and how this list of features that Elm has have helped you to get your job done and feeling happy in meantime. :)
You already can't publish native modules to the elm package repository. I believe OP in the link is talking about local native code.
You can't fully rule it out in Elm at the moment either, I can still write an `undefined : forall a. a` term.
I think the only thing that is changing is the policies around who can publish native modules. I might be missing something though, I often do. Could you quote the particular part that has you concerned?
I know, and I also wouldn't use a _custom_ package manager at work (so far, I feel at home with what I have in 0.18). But I think also that writing a Native module on your own is a great way to learn more about Elm and eventually understand why using them it is not a good idea. If this possibility just disappears, we will miss a great way to let the more skilled developers learn _the hard way_ it, as they like :-) Not everyone one love someone dictating some good rules: most of us just want to learn by breaking things and say "you were right".
but don't you have the same problem with a private fork (not enough manpower to really fix things quickly enough?) I would be interested in a "open" fork and while it might be not as stable it would really be nice if people could contribute wrapper-packages IMO (it's just unlikely that we really will reinvent all those great wheels out there within this smallish community)
I agree with this. I fear people are getting the wrong idea from this post &amp; comment section.
Another example - comparing functions with (==) crashes at runtime (at the moment at least).
If that's the case I'm relieved. I wrote what I wrote because the conversation went like: &gt; It will not be possible to write native modules starting with Elm version 0.19. If you write your program this way you won‚Äôt be able to upgrade your compiler version beyond 0.18. Then &gt; That's a strong assertion, and afaik you should be among the core developers. Can you provide us with an "official" statement? and finally rtfeldman said: &gt; The official statement is here: https://groups.google.com/forum/m/#!topic/elm-dev/bAHD_8PbgKE Maybe he meant "No, the official statement is here .." and not "Yes, the official statement is here ..". I'm sorry for starting this thread if what you said is true. I trust you know exactly what is happening (love your work on data structures in Elm btw!). I'll edit the original post and add this comment.
Maybe I read it slightly wrong, I felt that 'we' referred to us as a community, but I now realize you meant your project/company.
Perhaps what /u/rtfeldman would like is an Elm analog of `{-# LANGUAGE Safe #-}`?
Yep, we was my team :)
Unrelated question: Do you know if your array exploration and/or dict exploration code be merged in Elm 0.19?
OMG!! So many nerves in the skin, misunderstandings and missed read. I think the only fail by the author of the Elm language is the lack of information, mainly because that misunderstandings that happens sometimes, like this post and this comment above. 
Array exploration was merged into elm-core last year, so yes, that's definitely coming in 0.19. Evan is going to review my dict exploration work before the 0.19 release, so maybe =)
I'm going to moderate myself a little, because I haven't asked Evan straight out if that's what's happening, but if it did it would surprise me a lot. It would also mean that I've seriously misread things (and I've read everything that's come out). Most of my exploration work is done in private. If all native code would be banned, even in private repos, I would never be able to conduct explorative work for Elm again. Anyway. Nothing I've read has given me the impression that the Elm compiler will not accept native/kernel code in private/local repositories. So I wouldn't worry about. I think 0.19 will be even more usable for you than 0.18. There are so many nice things. Bugfixes, stability improvements, faster compiler etc. Look forward to it =)
&gt; TypeScript Isn't one. Just like Kotlin with Arrow (compiles to JS) isn't one, arguably more so than TypeScript though.
I think you might run into trouble when the canvas node is rendered with Elm, `Html.Keyed` might help with keeping Elm's virtual dom from tearing down the node, I've never tried that before. Your integration would have to be based on ports to communicate with the fabricjs part. Maybe you can make the Elm app live beside the canvas so that the Elm virtual dom doesn't interact with the JS managed canvas, that would be your safest bet, I'd wager. Although what you're getting out of this setup depends on how much logic actually lives outside of fabricjs and the glue code surrounding it. If there's not much more then I doubt it'd be worth porting to Elm - that's up to you to decide :-) I've seen google maps being included via WebComponents and `Html.node "google-map" ...` but these are pretty self contained, which might not be the case with your canvas thingy. [Here is a relevent talk by Richard](https://www.youtube.com/watch?v=ar3TakwE8o0)
Thanks mate
I'm the author of that PR. To me it's now a canary of if/when I should look again at Elm. I was trying to introduce it in my work projects but the websockets shortcomings, and the fact that I could not contribute back changes that I needed, held me back and I've since lost interest.
I'm sorry I realized way too late that "we" could be interpreted as "the Elm community". By "we" I meant my team. I'm not asking anyone else to leave Elm.
Yes, but only Evan and his team will be able to compile Kernel code.
It [looks like](https://github.com/elm-lang/elm-compiler/blob/d07679322ef5d71de1bd2b987ddc660a85599b87/compiler/src/Elm/Package.hs#L72) we'll need to fake the name of our project as if it belongs to elm-lang or elm-explorations /u/skinney?
I have spoken with Evan and during our conversation he said that in 0.19 Kernel code would only compile from elm-lang which means it won't compile your personal JS code. He wants Elm to only be used in the browser and what is was meant for and feels that he needs to put restrictions so people don't "pollute" the community with libraries that could have runtime errors.
I considered forking the compiler and patching it, but I really saw that as a losing battle. We've moved on to Haskell and will only use Elm on the front end (and ultimately I'd like to leave it for something more powerful like Haskell (GHCJS) or Purescript). The real question you have to ask is whether you want to throw good code after bad. We had 3 times the code you do and I didn't want to write another line of Elm server code or Native code.
From Evan's PR in gabrielperales/elm-native-module (https://github.com/gabrielperales/elm-native-module/pull/7/commits/6e1cbff8b354b1cea8e84e39546c4acd896b9c93) it seems clear to me that even private code will not be able to compile with "Kernel" code. It means that will prevent any kind of personal exploration, which is personally sad, but far more serious for companies like elmphoenix's.
And the decision to rename it Kernel predates grove by a long while!
I understand that the OP was misinformed on 0.19 changes, but still. I've evangelized the hell out of Elm over the past few years over twitter, youtube, and reddit. I authored a handful of the websocket PRs referenced by OP. I've contributed in whatever way I could to other Elm projects. I've politely advocated for *some* way to allow the community to build and distribute native modules, and am tired of seeing resistance to it, with the reason being that developers simply can't be trusted to do the right thing. "Use ports! Use ports! Use ports!" No. Elm is a fine language. Evan is a fine language designer. Evan has done a great job selling the language. The latter part is the only real problem I see here. If you're going to sell your language, among the great things about it, you should take care to temper expectations that users will (naturally) have. I never see slides in an Elm talk that highlight the following: - Long standing bugs in the core library will never be fixed! Hell, you won't even get a response to them! - You see all this ergonomic code? Well, the second you need some native functionality that's not officially supported, you'll have drop down into ports! - Want a timeline for any particular feature? NOPE. And don't you dare try to implement it yourself, unless you work at or are an NRI almuni. So yeah, I've been done with Elm for a while, and didn't really plan on writing anything on it, but this seemed like an appropriate time and place. I won't be actively bashing it, as I still want to see it succeed, but I certainly won't be recommending it. 
Just made another edit. Looks like I was _not_ misinformed. Only elm-lang and elm-explorations GitHub organizations can write native code now (or we can fake them or fork the compiler but is it worth it?).
I'm worried an open fork would mean we'll not be welcome in the community anymore judging from that thread.
Yes. We're not doing any "explorations". We just want to modify a package to fix bugs and use that without forking the Elm compiler. Looks like that won't be possible anymore.
Yeah my approach has been to [literally copy patched native code into my repo](https://github.com/bgourlie/rs-nes-debugger-frontend/tree/master/src). No, it's not worth it. I prefer a language that isn't rooted in an inherent distrust of its users.
Oh... you're that guy! I loved your Elm + Rust NES Emulator demo!
Ok so update returns a (model, Cmd msg). Can Cmd form the basis of streaming a Msg back into my update function? You can make a Cmd sequence with Cmd.batch so it would be cool to say request the current time and then have some other Msg after that. I kind of almost got this to work, but it seems like I'm swimming against the tide here. In my submodule I made a Cmd Msg with (Cmd.map (\_ -&gt; MyMsg) Cmd.none), but that seems hacky. But on the other hand, I'm starting to think build something a bit like Cmd sequencing anyway, but it seems like this stuff is already built in so maybe I'm supposed to use it? So here's a case clause from my Main.update that deals with msgs from a submodule: TagsEditing: TagsMsg tm -&gt; let blah = Debug.log "tm" tm in case tm of TagsEditing.Save -&gt; Debug.log "TagsEditing.Save" update Save model TagsEditing.RequestUuid msg -&gt; Debug.log "TagsEditing.RequestUuid" (let ( nm, uuid ) = nextUuid model ( tagState, tcmdmsg ) = TagsEditing.update (TagsEditing.NewUuid uuid msg) nm.tagState in ( { nm | tagState = tagState } , Task.perform identity &lt;| Task.succeed &lt;| Cmd.map TagsMsg tcmdmsg **-- this ends up being Cmd (Cmd Msg) and not Cmd Msg** ) ) _ -&gt; let ( nts, temsg ) = TagsEditing.update tm model.tagState in ( { model | tagState = nts }, (Cmd.map TagsMsg temsg) ) 
I think Elm was/is *marketed/propagated* very well, which is fine since Elm is great! But this *marketing* let to a fairly large community, lots of people who invested and lots of different interests. I think the crowd will not calm as long as the structure of leadership and communication remains diffuse. If you bring all these people in, you cannot leave them in the dark. The core team has to come up with a clear and up-to-date channel of communication at some pont, otherwise threads like this one will pop up weekly.
Can you think of something that can't be written as a port ?
Thanks for all your work on elm-bootstrap - it's an excellent package!
Which Haskell web framework are you using?
They've never really been interested. Anytime someone deviates from the party line, suggests solving problems in a different ways, requests that a feature be added to language, or asks for clarification on what the future of the language will be, someone from NoRedInk chimes in to say "you're doing it wrong". The official recommendation is to not use Native/Kernel code, period. [People have decided to risk using Native modules anyway](http://elm-directory.herokuapp.com/native-packages), even though the API is undocumented and bound to change in future releases, because ports frankly suck for a lot of use cases. Rather than the leadership embracing this community driven effort, they chose to clamp down even harder and make it nearly impossible to use custom Native modules. If you've been around for a while, you've probably realized that they've always been this way. Elm is basically an internal DSL driven by the needs of one company. They don't care about the community at all. I honestly regret convincing my team at my last job to use Elm in production. I feel like an asshole for saddling them with a dying framework/language.
Yesod. 
Completely agree with everything you've said here. I've also decided to move away from Elm. Elm's leadership (aka NoRedInk) has been downright hostile to the community. Their response to any and all criticism has been "you're doing or wrong". It just gets tiring after a while and it's not worth it. Elm brought some solid ideas into the front-end programming world but it's just not going anywhere. With all of the Elm-inspired alternatives out there these days it doesn't make sense to choose Elm.
I have similar guilt for wasting a few man-years on Elm. It's not my fault. I could have never seen it coming. But I still feel badly. However, that guilt (misplaced or otherwise) drove me to learn Haskell and rebuild our server. It's been hell, but I'm sure glad I did it.
Are you sure those bugs aren't being fixed for 0.19 in which case you won't need the native fixes? Are the bugs being tracked in a "meta" issue?
When I here freelance (as opposed to contracting) I think of a customer who doesn't care what technology you use. In which case just find someone who needs some web functionality developer (or even desktop as you can use electron to host elm). Then you are no long an 'elm developer' but a solution provider and can probably ask for more money.
I'd suggest you check Bucklescript-TEA out: https://github.com/OvermindDL1/bucklescript-tea It's in early stages, but maintainer accepts contributions without much problems + you're using far more powerful and extensible language. 
To be clear, there‚Äôs a huge difference between ‚ÄúDesign the exact language I want to see!‚Äù and ‚Äúyou sold me on this language, sold me on the idea that it‚Äôs production ready, and now I‚Äôm left explaining to my team why we‚Äôve invested in a language that is seemingly unsupported/purposefully breaking code that we depend on.‚Äù
&gt; You may need to rethink the structure of your application involving math libraries, remember that ports were meant to function as means of communication between actors. Typical Elm-speak for ‚Äúthis is fine‚Äù while the entire room is on fire. &gt; A good way to deal with this is to process all things involving the math model outside of elm and simply use elm to render the html for this specific case. Might as well use a Native module then. At least you can reuse the library wrapper or import one that somebody else already wrote.
I still don't get why ports are so bad. You could most definitely write an npm library that works with ports. I've been working with Elm everyday for the last year and I've yet to feel an urge to switch back to JavaScript or PureScript. Instead of forcing your ideas of what should work a certain way it may help you to actually learn how these concepts were meant to work together. You could always write a JS side port library on NPM, I hear they let you publish anything there.
Everything _can_ be written as a port, but that doesn't mean the API is usable. Writing a port for say a math function of type `Float -&gt; Float` is much worse than the "callback hell" in Node.js.
Well, no array-exploration or dict-exploration from /u/skinney anymore I guess unless Evan lets him have a repository on github.com/elm-explorations.
&gt; Instead of forcing your ideas of what should work a certain way it may help you to actually learn how these concepts were meant to work together. Ah, the classic Elm condescending attitude of "if you don't like, it means you don't understand it". I've been working with Elm for 2 years now. I've published libraries. I've (regrettably) convinced team members to use it production. I understand what ports are and how they work. They suck.
&gt; Elm is basically an internal DSL driven by the needs of one company Like React :-) ? Just, that one is just a Javascript framework and anyone can screw up things as they want...
Out of curiosity, can you give a realistic use case for this? I'm curious about the practical use cases for synchronous JS calls not theoretical ones. Do you have some benchmarks to contrast the call with some pure elm implementation? 
I've never claimed to be among the "group of the enlightened ones", nor am I. I spend an hour or two each week working on datastructures in Elm, as a hobby. I'm not really a software developer. I read whatever is posted on the elm-dev mailinglist and make my assumptions based on that. Every once in a while I do talk to Evan, but those conversations are centered around my exploratory work, not really on Elm itself.
I'm certain that particular process won't change that much. array-exploration wasn't whitelisted (meaning it could use native code) until I had been working on it for six months (in my spare time). dict-exploration doesn't actually require native code at all. My next few projects doesn't require native code either. So you're certain to see a bunch of new projects from me going forward, either way.
But we're not talking about whitelisting anymore. If the project doesn't live on elm-lang or elm-explorations, it can't use native modules at all. Not even locally, not even for experiments. There's no `"native-modules": true` in `elm.json` anymore AFAICS. We can't use a fork of websockets library without patching and recompiling the Elm compiler.
We have a ~100 line JS function that does some calculations (complex trigonometry stuff used to draw SVG paths in our view). Its type in Elm syntax would be `Float -&gt; List Float -&gt; Float`. The function is pure‚Äîit does not depend on any global state and always returns the same output for the same input. It's not practical to call this in a port. Performance is not the concern. The concern is that ports are async. We call this function multiple times in the view. We're not going to send messages to JS and then get them back asynchronously every time a value changes. This reminds me of Node.js' callback hell but worse. We ended up writing a tiny native module for this and it's been working well. We know the downsides of native modules but doing this with ports is just not practical.
It's okay to have personal regret. But it's not condensation to ask you to explain _why_ you think ports suck. What problems did you have that you couldn't solve with them, that thousands of other people could?
But why not reimplement it in pure Elm?
I wrote that because in another comment you said: &gt; Most of my exploration work is done in private. If all native code would be banned, even in private repos, I would never be able to conduct explorative work for Elm again. All native code _will_ be been banned in 0.19.
I'm a fan of Elm and have been using it for several home projects. But I've seen a number of threads like this over the past several weeks where users are expressing frustration and confusion about where Elm is going. It's unfortunate, as I think Elm is a great direction for front-end development and I want to see it succeed. It seems like we need a community virtual meetup or something, from the maintainers, to get an update on the state of Elm. Threads like this, while good for expressing the community's state, aren't great for those looking to adopt Elm as it reveals a lot of confusion and frustration. We need to clear the air. Just a suggestion. Thanks! 
Yep - I remember reading that. But it doesn't have to be Evan who communicates to the community...maybe someone else from the inner circle. Honestly, it doesn't have to be polished - it would be beneficial for the community to hear an update on how things are going. For example, I liked Richard's RealWorld example (https://github.com/rtfeldman/elm-spa-example), and a comment in his Main.elm file about expecting "most of this file being unnecessary". I'd really like to see what this may look like, especially since a lot of the initialization plumbing *may* go away. I don't mind building it in 0.18, but if I'm going to talk to my local dev community about building an Elm app, I'd like to be able to say "it looks like this today, but it'll probably look like *this* in 0.19".
I don't think you can pass internal data structures through ports. A hacky solution might be to expose the gl context by modifying the JS [here](https://github.com/elm-community/webgl/blob/master/src/Native/WebGL.js), e.g. just put it on the window object. A cleaner solution would be to think about how an API for saving frames might look like in elm, make sure it typechecks and then implement it. In any case, you should probably contact Andrey (@unsoundescapes on slack) to collaborate on this. Recording a WebGL scene seems like something that would be very useful to have for all users of elm-community/webgl.
&gt; it would be beneficial for the community to hear an update on how things are going Yes, but it's disheartening to read some of the responses by old timers on [this](https://discourse.elm-lang.org/t/will-elm-release-time-getting-longer-for-every-release/620) thread. &gt; I don't mind building it in 0.18, but if I'm going to talk to my local dev community about building an Elm app, I'd like to be able to say "it looks like this today, but it'll probably look like this in 0.19". That's exactly what Evan doesn't want. He wants the releases to have have a '"Holy moly!" factor'.
Cool, I totally see your pain. In my company we decide to stick with elm and go the port way, or simply move all the things to elm where possible. We found more bugs than we introduced TBH. 
Hi, Evan explained the policy here: https://www.reddit.com/r/elm/comments/73ubxo/an_explanation_of_elms_policy_on_native_code/?st=jebhn848&amp;sh=6cf11933
Last time I checked the react community was flourishing and Facebook wasn‚Äôt trying to dictate how people use it. 
He explained clearly and concisely earlier in this very thread why he dislikes ports, and as someone who's also been developing Elm for 2+ years, I agree 100%. &gt;Port modules can't be bundled up and shared on the standard package manager. Asking people to write their own port implementation every time they want to use LocalStorage is insane. 
thank you for clarifying it, and sorry for the misunderstanding.
Well, I think they try to do it: take the _context_ API for instance. It exists, any developer can access it, yet the docs clearly state that it will be changed and shouldn't be used. They just can't enforce it (yet) because of the language limits. If tomorrow they'll remove it, one-third of the packages I'm using in production won't work with the new version. Do you think their community is going to raise half of the issues raised by the Elm community about Native packages?
Don't forget GHCJS (using Reflex and the like), which allows you to use the same language between backend and frontend, providing benefits like being able to share types between the two.
&gt; For the backend stuff, this event forced me to finally take the full leap into Haskell. Have you also considered GHCJS? This would allow you to share code between frontend and backend. Reflex is already being used in production, including mobile apps.
Ocsigen / oCaml lets you do the same - I haven't built any non-toy projects in it but a lot of it looks quite nice. (And my minor bugfix PRs were accepted reasonably, even!)
&gt; PureScript's performance is not even close to Elm right now I don't think this is really true. PureScript is just a language, and generates very clear, compact code. There's no additional runtime or exceptional overhead. If you mean for UI development, and are referring to a specific benchmark, I would take that with a grain of salt, since none of the implementations were optimized (diffing the entire tree on every change is quite slow). I wrote [purescript-spork](https://github.com/natefaubion/purescript-spork), which is a TEA clone and uses purescript-halogen-vdom (the same vdom library that purescript-halogen uses) under the hood. My implementation scored around 1.8x that of JS, which is pretty good since halogen-vdom is implemented _in_ PureScript. This sort of library is not expressible in Elm (elm/html is a 100% JS library), so it's not an apples-to-apples comparison.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/bprogramming] [Do we need to move away from Elm?](https://www.reddit.com/r/bprogramming/comments/81s64q/do_we_need_to_move_away_from_elm/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Have you looked at [purescript-concur](https://github.com/ajnsit/purescript-concur) which is meant to be a really simple UI framework? It's very new, and I wouldn't recommend it for production right now, but I'm happy to receive feedback and provide support.
I agree with you on this point.
The existing context API has known limitations and is considered "broken" in several ways. The React team has said since the beginning that they intended to replace it eventually. Well, "eventually" is now. The React team has merged in a new context API that will solve the same use case as the existing API, but without the limitations of the existing one. The existing context API will stay as part of the public React API through at _least_ the rest of the 16.x cycle. The React team also considers backwards compatibility and upgrade paths to be a key concern, especially since _they_ are responsible for any changes that are required to Facebook's 50,000+ React components. This usually takes the form of "codemods", which automatically transform old/deprecated code patterns into the newer ones.
Here is your code in the Ellie App. https://ellie-app.com/4tGxsNdZja1/0 On line 5 you describe a new union type that takes two parameters that each could be any type. There is only one form that could take, which is described on line 6, and that form only care about a value, and not about a tag. As you point out, you can create an alias for the Tagged value constructor, but this is not necessary. So your code can simplify to what we see here. https://ellie-app.com/4tGxsNdZja1/1 You can add more forms of Tagged tag value, and each time you construct one you can provide whatever types you want for tag and value. Like so. https://ellie-app.com/4tGxsNdZja1/2 However, you have the option of being deterministic about what types tag and value can be, especially if you're expect a result from a function. https://ellie-app.com/4tGxsNdZja1/3 Try messing with that getTagged function and see that it won't compile if you mismatch the types of foo and bar with the different forms of Tagged. For instance if you turn the bar on line 37 to a foo, it won't compile. I hope that helps!
I did but it felt a bit risky and I wasn‚Äôt sure how well it was supported. I may reconsider it on the next project. But since I lost so much time on Elm on the backend, I had to limit how much new tech I was going to take on in such a short period. Haskell was enough of a hurdle for one project. Especially one that was back to square zero with no change in the deadline. 
Hey, so I'm not going to say that your problems aren't problems, nor that you should or shouldn't move away when 0.19 comes out: I don't know your exact problems! What I will say, however, is this: 1) 0.19 is getting closer to an alpha. As part of Evan's methodology, bug patches get merged right around the time of an official release. See [this](https://github.com/process-bot/contribution-checklist/blob/master/expectations.md#batching) for a description on how work is batched! The work-arounds you need for the websocket library might be merged into master. 2) Going forward, I personally feel there is a need for more frequent bug releases. 0.19 was a tricky one for that to happen, since a lot of internal pieces had to change internally. I'm not saying that means the lack of bug fix releases doesn't matter: but that's one reason why that happened. 3) I'd love to help you out with any migration problems you might face when 0.19 comes out. In fact, I'd love to help anyone out: there's now an #upgrading channel on Slack for that exact purpose! 4) The community team discuss these issues often, they're on our mind: and we're actually going to talk in person about it in a couple of weeks. 
Flow + FantasyLand/Sanctuary.js + Ramda + React for me atm. Considering working with Elm.
I already tried this approach before but it seemed not work. On JavaScript site I get the Canvas element by the id and then use canvas.getContext('webgl') to get the canvas context. But the canvas context (gl) get by this way seems created different from the gl used in Elm. I pass this gl to [hughsk/gl-gif](https://github.com/hughsk/gl-gif) result a blank. The is code snippet: ===== index.js ====== app.ports.gifStart.subscribe(function(canvas_id){ var gl = getWebglContext(getCanvas(canvas_id)); if(!gl){ return; } gif = GIF(gl, { fps: 24 , width: 175 , height: 175 , quality: 20 , dither: true }) }); app.ports.gifTick.subscribe(function(canvas_id){ if(gif == undefined) { git.tick(); } }); app.ports.gifDone.subscribe(function(canvas_id){ var dataURI = gif.done(); document.body.innerHTML = '&lt;img src='+JSON.stringify(dataURI)+'&gt;' // app.ports.gifURI.send(dataURI); }); function getCanvas(canvas_id){ var canvas canvas = document.getElementById(canvas_id); if( !canvas || canvas.nodeName !== "CANVAS"){ console.log('Fatal error: Canvas "' + canvas_id + '" could not be found'); } return canvas; } function getWebglContext(canvas){ var context; context = canvas.getContext('webgl'); if(!context){ console.log("No WebGL context could be found."); } return context; } ===== Main.elm ======= port gifStart : String -&gt; Cmd msg port gifTick : String -&gt; Cmd msg port gifDone : String -&gt; Cmd msg port gifURI : (String -&gt; msg) -&gt; Sub msg PlayKeyframe -&gt; ({ model | playStatus = Start , ... }, gifStart "canvas_id") update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of CurrentTick time -&gt; case model.playStatus of PlayingFrames -&gt; let nextKeyInfo = (characterCalDuration model.animKey model.animEndKey time model.animStartTime character) in case nextKeyInfo of Just (key, nextStartTime, playTime) -&gt; ( {model | currentTick = time , ... } , gifTick "canvas_id") Nothing -&gt; ( {model | currentTick = time , ... } , gifDone "canvas_id" ) view : Model -&gt; Html Msg view model = div [ ] [ menuPanel model , parameterPanel model , webGlView model ] webGlView : Model -&gt; Html Msg webGlView model = WebGL.toHtml [ class "canvas", id "canvas_id" , width model.scene.size.width , height model.scene.size.height , style [ ( "display", "block" ) , ("background-color", "white") , ("height","100%") , ("width","100%") ] , Emouse.onMouseDown WebGLMouseDowns , Emouse.onMouseUp WebGLMouseUps ] (charactersWebGLEntity model.characters) 
&gt; Other languages do things differently, and that's okay: if you want to use JS that might break, ReasonML, Purescript, Typescript are all valid choices! Elm is different. Elm intentionally makes it so that all code you write must work and not introduce bugs that should be caught by the typesystem. Please don't state that "all (Elm) code you write must work" and PureScript code doesn't, when that's demonstrably false.
&gt; I did but it felt a bit risky and I wasn‚Äôt sure how well it was supported. Well, having used Elm I had little difficulty migrating my project over to Miso (which is based on the Elm architecture, but uses GHCJS) https://haskell-miso.org/
Thank you. I am contacting Andrey. I am learning Elm (in few months) and also new to front-end development. I hope some of the experienced Elm developers can help me.
&gt; It's like trying to protect your children by locking them up in the closet. They'll be safe from the big bad world, but they will sacrifice living to achieve such safety. Reminds me of [A Perfect Circle's Pet](https://www.youtube.com/watch?v=m5i3WtvjOHs).
Interesting! I'm not super interested in working for Amazon, but it's interesting to see a big company use a less mainstream language.
I'm just tired of features that ought to be there to be useful for some rare cases being removed because "very few people are actually using them". Same thing happened to record property additions, which is something I really could have used. But "very few people actually used them", so they were gone.
The thing is, removing these features are a good thing: Elm code is familiar, with less unknown features. Rarely will you come across some Elm code that you aren't sure what it does. This is because Elm is a curated, refined language at present. It can't be everything for everyone. If the majority of people aren't using a feature, and it simplifies the language to remove it, it may make sense to remove it. There are other languages out there that do the opposite, however: so if that's what you're after, there's something out there for you!
Great answer, glad to see you're still involved
Wtf, Amazon is going to make their UI better?
Would love to hear some experiences working for an ecommerce giant 
As far as I can see, the whole industry is going in that direction: learning Redux, Flow, immutable-js, React, ramda, ... thus whatever framework or library you learn will just be good for your career. On the other hand, I might suggest you learn also the styling part (its principles, the preprocessors, how to structure it) because it is a very important side of the frontend to know and it is required usually. Another downside of learning Elm only is that you completely miss the prototypical inheritance and the OOP (but you have a degree, I'd expect you to know it), plus some gotchas which are almost unique to the JS environment (== vs ===, references vs values, arrays as objects, the `this` scope, ...). Finally, I wouldn't hire a juniot frontend dev who doesn't have an understanding of the SEO basics and doesn't know how HTML is written. I don't know how much of this you already know, I'm making assumptions based on the fact that you only know Elm. Good luck! And well done for having started with such a beautiful language :-)
Like I said, we're discussing this going forward. For 0.19, there was too long time between bug releases. _it is known_
&gt; Sorry but we can't upgrade to the official 0.19 There isn't even an alpha yet -- you can't say this without knowing what is in 0.19. Like I offered and suggested: wait for the release, then come talk on #upgrading on Slack about it. 
&gt; Infix operators are just one great way to code "into" a language. Infix operators are a way to code clever code. When used right, they are amazing BUT, they have a major trade-off: they allow you to write very clever code which means that sometimes you write code that is too clever to be understood by other people including yourself few months into the future. I welcome the removal of the infix operators and think that this would make the code better. 
&gt; I welcome the removal of the infix operators What's your opinion gonna be if evancz/url-parser and elm-lang/parser still keep using infix operators?
No, the check for allowing native code and infix operators is this: https://github.com/elm-lang/elm-compiler/blob/master/compiler/src/Elm/Package.hs#L72 and it still has `user == "elm-lang" || user == "elm-explorations"`.
As far as I understand, `elm-lang` repositories will continue to have access to defining infix operators. The `evancz/url-parser` will move to `elm-lang/url`. I'm fine with that. I don't think they are a bad feature that should be avoided at all cost but I do think that they are a dangerous feature that is best kept constrained. I've seen what I initially considered a good idea (`!`) trip a lot of people, I've also seen myself getting confused by code I've written with infix operators. 
Yes, we'll wait and hope Evan reconsiders allowing private use of native code and infix operators.
Joyent had to give in when the fork got traction and they're better off now with the new management. Maybe a fork is how we'll know how many users are frustrated with how Elm is managed. This thread seems to have invited more of the frustrated folks than the happy ones. We don't know how many Elm users outside Reddit share this view.
This is a highly specialized domain. People who want to explore Kernel details are still free to do it. The project is open source, if you want to hack a certain part of it, you are always free to do it. For example, if you want to patch some library, you can easily create a post-processor to add in your build that will go and replace, the official implementation of, let's say websockets with a custom implementation that you deem better. You could do that in `0.18` and you will continue to be able to do that in `0.19`. I implemented a web components mechanism that allowed me to implement web components in Elm because I was curious how would that look/feel. Of course, that needed Native but it was worst than that, the implementation needed certain functions to be exposed in core Native. In my case it was easier to do it in a pre-processor that first patched the files in order to have the needed functions available to my Native module. If you have a particular need that absolutely mandates that Elm behave differently than official Elm behaves, just use a custom version of Elm that solves your problem. This is not a universal solution but a trade-off. You will have the advantage of the custom Elm doing what you want it to do with the added disadvantage of having to maintain the fork. If you consider the trade-off worth while, use that solution. 
Right, but from the perspective of the old management (ie: Evan), they got ousted one way or another.
No. I'm not sure if I undestand how to properly use it. For example, how would I do some client rehydratation with it?
For those people, what I'd say is: why not go use ReasonML, PureScript, Typescript etc? Why use Elm if you're not interested in the language?
We are interested in the language. It's wonderful. We don't like some of the changes coming in 0.19 and the fact that bug fix PRs are open for years without a response. It's not that easy to switch to another language for those already invested in 0.18.
&gt; the fact that bug fix PRs are open for years without a response Like I said -- this is being discussed. It is a known problem! Threatening forks to get your way is not the way a community should work. Having panicked angry discussions on reddit is not the way a community should work. 
Yes, it is a known problem, and like I said, it has been for years (I can find 1 year old comments here complaining about the same thing) and there hasn't been any progress. One motivation of creating this thread was to start a(nother) discussion among the Elm core team. I hope something good comes out of it! I am not threatening any fork. I'm explicitly _against_ creating a fork. The most I'll do is remove the kernel package restrictions from the compiler's source code and use that privately. Anyways, I don't think we should continue an angry discussion until the Elm core team makes an official response. Thank you for all your kind responses on this thread even if I made a couple of angry comments. :)
This is the very first time I've seen a major company looking for Elm developers. 
Does anyone have a practical (and simple!) working example that illustrates this?
üéâ
&gt; Will using something more oriented towards FP wreck my chances at getting a front end job etc? On the contrary, I am now seeing job offers that request "knowledge in functional JS" or similar. 
Amazon is known for giving their teams a lot of autonomy, so somebody was able to convince their team to give Elm a shot.
Oh, so it's not for the whole console? That sucks, I hate using the dynamo and sqs UIs.
[This Ellie](https://ellie-app.com/rTn2kR2Wga1/1) contains the gist of how I do the communication of Elm with the outside world using Flux-Standard-Actions, which is pretty much ready to use with a run-of-the-mill React/Redux Real Life setup. It's not exactly "simple" for a traditional hello world, but it also won't get more difficult, the approach stays the same. I've tried to include the dataflow in the comments. Hope this helps to illustrate how you could do it.
Ok, but wouldn‚Äôt hiring indicate that they are more then giving it a shot?
They did? Do you know what?
There is also a library that makes typical interaction with JS easier https://github.com/pdamoc/elm-ports-driver which you might be interested in
It‚Äôs called Lightsail
I'm using Uuid in two different data structures, and I'd like to distinguish them so I don't use an ID from one where it doesn't belong. So its like this: type alias TagId = Uuid.Uuid type alias Tag = { id : TagId , name : String , description : String , tags : EverySet Uuid.Uuid } type alias ActivityId = Uuid.Uuid type alias Activity = { id : ActivityId , name : String , description : String , tags : EverySet Uuid.Uuid } getTagById : List Tag -&gt; TagId -&gt; Maybe Tag getTagById tags id = List.head &lt;| List.filter (\t -&gt; t.id == id) tags So getTagById looks up a Tag by its TagId. But Elm doesn't prevent me from passing an ActivityId in instead. Is there any point in using type aliasing aside here from maybe documenting? 
What Pivotal already uses Elm for Pivotal Tracker and ConcourseCI
&gt; Back in the '70s, Fred Brooks said "Show me your [code] and conceal your [data structures], and I shall continue to be mystified. Show me your [data structures], and I won't usually need your [code]; it'll be obvious." Data driven development is in my perspective a great thing and I whole heartedly encourage everyone to start from first designing the data structures that will solve the problem. These being said, components have their role. Their main advantage is encapsulating functionality and not loading the user of the component with details. Every `Html` element is a `node`, which is to say, a component with its own behavior. They have accidental state and their behavior is handled transparently to the Elm user by the browser's renderer. Imagine being forced to explicitly add a piece of state to your model every time you use a `text` element and you will understand why automatic handling of accidental state is useful. The only reason why we can pretend that we don't do components in Elm is because we are delegating functionality to components implemented by the browser. 
Summary: How do I read the type for a `view` function? `view : Model -&gt; Html Msg` If you were reading this out in English, how would you do it? Specifically, the `Html Msg` part. My guess: "view is a function that takes a `Model` value as input, and returns an `Html` *function?* that produces a `Msg` value" Is that right? Should I think of `Html Msg` essentially as some sort of future? Thanks 
You could use opaque types instead of aliases. type TagId = TagId Uuid.Uuid getTagId : List Tag -&gt; TagId -&gt; Maybe Tag getTagId tags (TagId id) = ... (Also, usually those arguments would be reversed so the data structure -- List Tag -- is the last argument. )
Exactly. And even though I generally like Elm, there's no good way to implement something like Select2 without a convoluted mess of mapping, wrapping Select2.Msg in the main application Msg, etc.. It's actually easier to copy and paste the code into your program than to import a module that needs to manage state. 
This looks comprehensive at a glance. I‚Äôm looking forward to digging in deeper.
Check out elm-ui.info
It's not that simple. When you have a complex piece of UI that needs to be reused several times, components are actually unavoidable. Take a look at https://github.com/elm-community/elm-datepicker for example. It's essentially a component. It manages some internal state and the following (from its readme) is inter-component communication: ``` ( newDatePicker, datePickerCmd, dateEvent ) = DatePicker.update someSettings msg model.startDatePicker date = case dateEvent of NoChange -&gt; model.date Changed newDate -&gt; newDate |&gt; processDate ``` The difference between this and components in React is only that in Elm it's done in a completely explicit and transparent way. It doesn't mean that it's automatically bad because for some applications it might be enough -- if they don't need components much, it may be better to write a bit of boilerplate sometimes than depend on some complex abstraction (but for other it might be unacceptable). You points about state synchronization are valid, but these problems are not related to components really. If some state belongs to a component only, it's ok to store it at the level of that component, and if you need it in multiple places -- move it up to a common ancestor and pass down instead. Even React's guide says that. &gt;are some internal components hiding in elm? Absolutely not. As jediknight said, every HTML node is a component. Text nodes might not be the most obvious example, but think about an input field and how much things it needs to do behind the scenes to manage at least its blinking cursor. 
It's not really like a future though, it's more a "piece of data for the runtime to interpret" than "function to be executed at a later time". Also, there is no `Html.andThen`. It's more like a `Cmd` and/or `Sub`. This explanation from the guide may help: https://guide.elm-lang.org/architecture/effects/
&gt; But, don't you think that storing the date into the model resolves the state synchronization problem? Yes, and that is what you do when you use the `elm-community/elm-datepicker` package. You store it in your model and pass back to the datepicker: div [] [ DatePicker.view model.date someSettings model.startDatePicker |&gt; Html.map SetDatePicker ] So the datepicker doesn't store the date in its state (it only stores what it needs), but you still need a way to receive the new date when it's selected because the datepicker handles how the selection itself happens. You receive it from it's `update` function, and this is where the "communication" happens (but there is no state synchronization, because the date is stored in one place, so no problems). &gt;my point is that you don't care about the blinking cursor most of the time, just like you don't care about managing your memory when you're coding. You consider it as acquired, and go on. In elm, you're not dealing about the component, you're using it to obtain the result. Depends on what kind of thing you are building. What if you want to reimplement that text field with a `div`? Or a more realistic example: a reusable button that needs to show an animation on click which you can't implement with CSS. If just sticking to reusable view functions works for your project, then everything is ok. My main point is that this approach has a theoretical limit, and when you hit it, the solution is to go the same way as `elm-community/elm-datepicker` or `evancz/elm-sortable-table` which, in my opinion, are essentially components. So it's not really correct to say that components don't exist in Elm. 
&gt; That's true, I totally agree with that. But in the end, most of the time you're not writing components. It depends on what you understand by components. For example, the recommended way to write React Components is the way Elm handles things: stateless components. A combination of html and css could be considered a component. (think stateless Bootstrap Components). Some require accidental state. &gt; What are you thinking when you talk about accidental state? It is state that is part of the accidental complexity of using something. For example if you use a dropdown, the state of the dropdown (open or closed) is accidental complexity. You seldom care about that state as long as the component behaves properly. What you care about is selection events. Most of the time you want it to behave as the `select` html element (which is a component where the accidental state is managed by the html engine). To better understand the contrast between essential and accidental complexity, read [Out of the tar pit](https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf). It is one of the best papers I've read. 
Consider posting the job opening in Slack #jobs channel too.
[removed]
Salary?
I use bootstrap all the time - the big benefit is that the framework dealt with all the differences between browsers/devices etc. so that you don't have to I don't use a library for that though - it's easy enough to just translate the parts you need
You get to use Elm :-)
Hmm, I wonder if I can pay my mortgage with this.
Only the spiritual one.
&gt; I am trying to figure out what an optimal way to handle layout in Elm would be. A theoretical optimal way to handle layout would be with layout primitives. [style-elements](http://package.elm-lang.org/packages/mdgriffith/style-elements/latest) is an exploration in that domain. If layout is what you are after, look into that library. &gt; I am less clear what elm-bootstrap or elm-bulma would offer over the native versions though? Both elm-bulma and and elm-bootstrap offer components. These are small views that allow one to express something like a `dropdown` in a better way. In the ones that have small state needed to manage their internal state, the management of the internal state is done for you and all you have to do is just provide some message handlers. My preferred method so far has been to use Bootstrap and SCSS but using `elm-bulma` or `elm-bootstrap` might be faster when one is just starting up. 
I haven't used Bootstrap for Elm, but I've used extensively in the past. I did try Material Design for Elm (`elm-mdl`) when I started learning Elm. I've since moved over to Bulma as a pure css framework because of the way that events are handled in Elm. &gt;It looks like they will wrap the CSS frameworks into elm functions for us, which is nice I suppose. This means that you're not writing your own functions. The only way to learn to code is by writing it yourself. If you let someone else do it for you then you're giving up a learning opportunity. If you use a framework like Bootstrap, there will be a lot of prepackaged events and animations that you can take advantage of. This may be beneficial when you're getting started but I found that my application got extremely bloated and actually became more difficult to reason about. If you're starting out, I would suggest trying to handle events on your own and letting something like Bulma handle the styling, otherwise you're learning the framework (Bootstrap) and not the language (Elm). I never used `elm-bulma`, I preferred to include the compiled css in my page. I prefer to keep styling separate because its what works for me. There are many options, like `elm-css`, that will let you write Elm to generate css documents. You should try different things and figure out what you like. But if you're learning Elm then prioritise that and you can always try different css frameworks when you understand Elm well enough.
This was helpful, I appreciate the way you framed this and clarified some of these options and trade-offs! Thank you for the thoughtful feedback!
I'm glad that I could help. You're welcome to PM me if you have other questions. Alternatively, the [Elm-slack](https://elmlang.herokuapp.com/) beginner channel is super helpful and welcoming.
`style-elements` is an alternative to CSS. It has functions for both layout (Elements) and surface (Style). If you are going to explore that, I suggest joining the style-elements channel in Slack. It is very active. 
use `npm install -g elm-format@0.7.0-exp` to switch to the experimental branch. 
The file under `/usr/local/bin/` is just a symlink. You can check actually where `npm` installs global modules by `npm list -g`, on UNIX systems this is mostly `/usr/local/lib/node` or `/usr/local/lib/node_modules`. I just prefer `yarn` over `npm`, npm has given me a lot of headaches.
One important aspect to remember is that by embedding style into code especially by using something like `elm-bulma` or anything you seriously commit yourself to `elm` itself, it is kind of vendor locked. If in the future you want to migrate your website to another framework or language with 100% same look and (UI) behavior it will become difficult if not impossible. Just something to keep in mind when using this for production or something serious.
I'm currently using Elm with native Bulma. For now I don't see the added value of including an extra lib. Works like a charm.
Tell the bank you will pay it lazily.
Very nice. Will do! :)
Hmmm... I can't seem to go elm-app install gdotdesign/elm-ui Any idea why? 
Sorry but I haven't used it myself.
I just use bulma alone, including it as scss. (no wrapper lib, as it's easy enough to add what's necessary when it becomes too repetitive). The no-javascript part made it the perfect candidate for elm.
tailwind css
I've done the same (reverse-engineering) approach with MDL components. It does take a little more time but at least you don't have to buy in to the whole framework, just the pieces you need.
In which location are you looking?
Mostly in Texas but I've applied outside when relocation has been offered. 
Looks very very good, I look forward to trying it in my next project!
Hey excuse u remember your pronouns or I'll be triggered!!!!!!!!!
I'm struggling with the submit button on the tutorial: https://guide.elm-lang.org/architecture/user_input/forms.html It seems as though I should stick the viewValidation inside a button: button [ onClick (viewValidation model) ] [ text "Submit" ] but this fails with an type error which doesn't yet make much sense to me: The 3rd and 4th entries in this list are different types of values. 51| [ input [ type_ "text", placeholder "Name", onInput Name ] [] 52| , input [ type_ "password", placeholder "Password", onInput Password ] [] 53| , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] 54|&gt; , button [ onClick (viewValidation model) ] [ text "Submit" ] 55| --, viewValidation model 56| ] The 3rd entry has this type: Html Msg But the 4th is: Html (Html msg) Thanks!
I am not too experienced, but in my side project I found that the various material design / bootstrap elm libraries seem to litter my code and require a lot of tight coupling, plus a lot of time figuring out how the thing works from the example as documentation isn't too complete. I did these spikes on different branches, and then rolled it all back, and just used css classes, the "Skeleton" css framework, plus another CSS for tweaks. I found this most pleasing to my style of programming, and I got 80% of what I wanted for 20% of the effort. I also like it because I have a different way I want to respond to mobile form factors which I will do later. When the width goes below "X" I will stop rendering a table and render divs. I want the benefits of a table on large screens, and the benefits of css layout on smaller ones. That's something you can do in Elm but not generally with CSS frameworks. Elm opens up a new way to tackle problems. 
Yeah, maybe is a data structure that can hold a value. Html is a data structure that tells the runtime what html to build. In the brower, the elm runtime will present said html, and intercept the events that emerge thereof. Those events will be transformed into Msgs by the elm runtime and passed to your update function.
Take a look at [elm-static-html-lib](https://github.com/eeue56/elm-static-html-lib). 
Cool. So this loads the elm app, replacing the virtual dom implementation with https://github.com/eeue56/elm-html-in-elm, run a cycle of the elm app and outputs the HTML (I think). Awesome. I guess my question is whether the elm app will then break in odd and surprising ways afterwards? Does elm-html-in-elm do anything special to avoid any such problems? 
viewValidation is a function that, given a model, produces an Html Msg data structure. That's different from a Msg data structure. The error message means you're passing the wrong thing in to onClick - the compiler wants you to pass in something of type Msg, like is done in the calls to onInput. If you want something to happen when you click Submit, have onClick take a Msg and then handle that Msg in your update function. 
I have not used this library in any production code but Noah (eeue56) is one of the senior Elm programmers. If you have concerns about stability, maybe it is better to wait for `0.19` which, as far as I know, will have an official static renderer. 
Thanks jediknight. I have no doubt elm-html-in-elm is stable and reliable. I just remember reading something about how React prerendering requires (or required this was from a couple of years ago) special code when starting up to work with the prerendered HTML. I was surprised the approach I used in the original post 'just works.' I was hoping someone would say, "Yeah that just works," or, "it works unless you do XYZ, but you can work around it by doing ABC" and then I would know. But if 0.19 is to include an official static renderer, it sounds like that is the way to go.
The approach you've chosen should work alright. One thing that React gets you, which this doesn't, is that once react is loaded on the frontend it will actually diff against the dom. Your solution will just remove the dom and render everything all over again. That's only a problem if the user tries to do something before your client code has loaded though.
technology does not override life obstacles. Your landlord will probably care the least which technology you use to make a living.
Hey, I wrote this. We're using it in production for a number of products, being served to quite a few people. Any differences from normal Elm rendering is considered a bug! So it tries to mirror the main rendering system as closely as possible. 
Thanks for the reply. I think I'm struggling with all the overloading which is going on in the examples. For example: update : Msg -&gt; Model -&gt; Model update msg model = case msg of Name name -&gt; {model | name = name} The operator "-&gt;" seems to be used for two different things, and the word "name" seems to refer to three different things in the space of a single statement!
you'll get used to it after a while! you can try renaming some things and seeing if they still compile, like case msg of Name myname -&gt; { model | name = myname } or case msg of Name name -&gt; { model | MYname = name } 
`-&gt;` is not an operator but a piece of syntax. In the first instance is part of the type signature describing functions. In the second case it is how you define case expressions. `Name name -&gt; {model | name = name}` here, `name` refers to the name of the variable in the case branch and the name of the field in the record. Is `Name newName -&gt; {model | name = newName}` clearer? As you probably know, naming things is one of the two most difficult problems in computer science together with cache invalidation and off by one errors. 
Were those SPA's open to the general public or just some sort of "internal applications"? How did you sort out the SEO problems
Thanks for the advice! I have finally solved this problem. I have one last question: is this pretty much *the* way to solve this problem? Or, at least, the sensible way. Here is the code that I have used (and I hope I get it to format the code properly): import Html exposing (..) import Html.Attributes exposing (..) import Html.Events exposing (onInput, onClick) main = Html.beginnerProgram { model = model, view = view, update = update } -- MODEL type alias Model = { name : String , password : String , passwordAgain : String , color : String , message : String } model : Model model = Model "" "" "" "" "" -- UPDATE type Msg = Name String | Password String | PasswordAgain String | Submit update : Msg -&gt; Model -&gt; Model update msg model = case msg of Name x -&gt; { model | name = x } Password x -&gt; { model | password = x } PasswordAgain x -&gt; { model | passwordAgain = x } Submit -&gt; if model.password == model.passwordAgain then { model | color = "green", message = "OK" } else { model | color = "red", message = "Paswords do not match." } -- VIEW view : Model -&gt; Html Msg view model = div [] [ input [ type_ "text", placeholder "Name", onInput Name ] [] , input [ type_ "password", placeholder "Password", onInput Password ] [] , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , button [ onClick Submit ] [ text "Validate" ] , div [ style [("color", model.color)] ] [ text model.message ] ] 
Even if SEO weren‚Äôt a concern (I still believe it is) there are other very compelling reasons to consider SSR a hard requirement for serious production use for consumer facing apps: load times on mobile devices. 
One of them is a general public app with a reasonable amount of visitors each day. The other two are for vertical markets (few users, custom functionality) 
[this video](https://www.youtube.com/watch?v=DoA4Txr4GUs) talks about splitting projects, which is exactly what you need
There isn't a dichotomy between: * Use a good programming language * Get a good compensation There are companies out there where you get both.
He said he watched it already.
As Evan said in "Life of a File", split your app by identifying data structures and functions that work with those data structures and splitting those off in to modules (this would be your Card and Board) Another thing you can do is to identify patterns that you might be able to extract out in to types of their own. [Maybe](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Maybe), [Result](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Result) and [RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/4.3.3/RemoteData) are good examples of this. These kinds of things aren't always obvious as a type and you'll find them often as patterns in various functions. (Evan does this in 'life of a file' by extracting the concept of a bounded set) Often you can identify that multiple functions are actually the same function that you can parametize either with types or value parameters. In terms of your 'Elm Sage Solitaire' example, It's only 1000 lines, if you split off the functions for Card and Board then it's only a few hundred lines. You'll have a much better idea about how to split it when it gets to a point where it's size actually makes it difficult to maintain and you need to split it, right now it's not really big enough. 
It is certainly nicer, but you can speed up mobile loading speed for example with server push. Requirements are different for every project and a lot of ‚Äúserious production apps‚Äù have to be neither indexable nor load (fast) on mobile.
There are but they are rare, so supply and demand mechanics mean either the comp takes a hit, or the bar to entry become very high. 
&gt;‚Äúserious production apps‚Äù You seem to have omitted some important words from my quote.
Thanks, /u/jessta; I‚Äôll leave it as-is for now then. It‚Äôs on the cusp of being too big for *me*, but I guess when I try to add other features they may well lend themselves to modules of their own anyway. It‚Äôs also good to know I was thinking along the right lines with the Card and Board extractions.
That choice of thumbnail appeals to me as a programmer.
The intuition/anxiety you have from JavaScript about how much code should be in a file doesn't apply to Elm. Not having a file be the scope of mutable variables greatly changes the risk in file size. A 10,000 line class is a nightmare, a 10,000 line module is just big. Push through that feeling because you've learned it in a environment that is different to what you'll get in a purely functional language.
Heh, we're still using elm-paginate. I learned a lot watching it develop.
&gt; "Bad programmers worry about the code. Good programmers worry about data structures and their relationships." - Linus Torvalds Your intuition is correct. Split along the lines of data structures (Card, Board). I find it very useful to think in terms of [The Five planes of UX](https://medium.com/omarelgabrys-blog/ux-a-quick-glance-about-the-5-elements-of-user-experience-part-2-a0da8798cd52). You have the Scope plane where the business objects live. The UI has not come into place but this is where you describe how the key data structures look like (fields, relations) and what can be done with them. If you have this plane designed right, the rest of the app will flow easily from that. Another useful heuristic is to think about your app's specifics and extract out the things that are not specific to your app. There are all kinds of helpers that you would have want to find in some library. Extract those away in some module. Look in the `-extra` libraries, sometime you will find there the functions you need. Rethink your code in terms of more generic operations. 
You can get server side rendering right now with elm-static-html-lib.
&gt;I am trying to figure out what an optimal way to handle layout in Elm would be. CSS Grid, a new framework independent web standard. But no idea if it's supported in Elm yet. This will definitely become big in the coming years, it's already supported by most browsers.
In indexes them, though that doesn't mean that they get nice scores... At last i do not think that google's pagespeed insights woudl provide decent scores for non-ssr pages. Is that tool not adequate to measure SEO scoring? What do you propose instead?
Note that that quote is not mine; I believe indexability and load speed are important. However, SSR is not always the quickest way to achieve that, and if your client-side Javascript executes quickly, you can still get a fine SEO ranking. It's all a game of balancing pros and cons.
&gt; At last i do not think that google's pagespeed insights woudl provide decent scores for non-ssr pages. Is that tool not adequate to measure SEO scoring? What do you propose instead? Google's own websites do not score high on that tool. Sure, use it for information and try to apply as many of the recommendations that you find there or in other tools BUT, I don't think that it should be taken as gospel. 
I'm curious! Are there any good use cases of this in production?
Interesting. Can we refer on the blogpost?
Nice article! An additional argument is that you don‚Äôt need three different concepts of responsiveness (col-md-x, media query and window.size) I think style elements is the first real killer elm library and also goes ‚Äúback to the roots‚Äù as Evan‚Äôs initial motivation for elm was an easier way to center something on the screen.
ouch!
I have very limited JS history and none with OOP. I could never get my head round the latter; FP seems much more intuitive to me, perhaps because I have a mathematical background. My anxiety is much more general. üò≥ But I will push through, thank you. I‚Äôm loving my Elm experience so far.
Thanks for your reply; not the first time you‚Äôve helped me out. I really enjoy the way Elm encourages me to think ‚Äúdata first‚Äù, so hopefully I‚Äôm heading toward becoming a good programmer. I appreciate the validation of my intuition and the link, which I‚Äôll read soon. I am already using some of the `-extra` libraries, so I‚Äôll see if I can leverage them some more.
Why is it that that the function Random library does not return a simple type, instead of a Cmd msg? Is it to promote a certain way of doing things? For example, I have been working with this example: https://guide.elm-lang.org/architecture/effects/random.html The model and update section of code is: type alias Model = { dieFace : Int } type Msg = Roll | NewFace Int update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of Roll -&gt; (model, Random.generate NewFace (Random.int 1 6)) NewFace newFace -&gt; (Model newFace, Cmd.none) I wondered if I could rewrite it more simply as: type alias Model = { dieFace : Int } type Msg = Roll update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of Roll -&gt; ({model | dieFace = (Random.int 1 6)}, Cmd.none) I cannot do this because (Random.int 1 6) does not return an int. As far as I can see, nothing in Random returns an int! I appreciate that the correct example is more flexible because you can respond to changes to the dieFace value independently of whether the Roll button is clicked, but it strikes me that whether to add this possibility is more of a design decision than a best practice. Presumably I'm wrong, and I'd be glad to hear people's opinions on this. Also, I have a second question, concerning the correct example. If you click "Roll", update says that it always returns the model as it is before the click. Sure, NewFace would return a different model if it was triggered directly, but Roll clearly states that it returns the model as it is when it is clicked. That seems strange to me...
any example of a data grid with ajax data out there?
This was one of the best articles I've read on this subreddit yet.
Yes, one of the best I've seen on the topic of data modelling in Elm, period!
Yea, that one is hard wrap your had around. This article explains it very well: https://medium.com/@ckoster22/randomness-in-elm-8e977457bf1b TLDR: Because all functions you can write in elm have to be pure (same input results in the same output), a random function like in js would always produce the same output. That‚Äôs why you instead produce a message to tell the elm runtime to give you a random number, which it does in a new message. In case of random this might seem like an overkill, but because everything in elm user code is forced to work this way, debugging and testing are so much easier. Let‚Äôs say there would be an exception for random number generation: functions that use it could pass all your tests, but break the next time you run the test, without you having changed anything! If the function on the other hand takes numbers as input that will be randomized by the runtime, you can just write tests for numbers that you think might be a problem ( typically 0, -1, and numbers bigger than expected). Even better, the fuzzer module can do that for you!
thanks I figured it. Only last question I have as I said in my *update* in the original post.
Great writeup! 
What do you mean exactly? Could you go into more detail? Do you want to show data in a grid?
If you want to do something like this: https://evancz.github.io/elm-sortable-table/presidents.html You can use this package: http://package.elm-lang.org/packages/evancz/elm-sortable-table/latest
I've heard it's not that great
CORS errors are due to an interaction between the browser and the server where you make the request. In order to fix it you either have to configure the server to accept CORS requests OR you have to use an environment that ignores this restriction. This is a security feature and it can be turned off, for example, in Chrome you can disable it by running chrome with `chrome --disable-web-security`. There are also plugins that allow you to disable this security feature by adding headers to the response. If you control the server, it is advisable to enable CORS for the domains you will be calling from. 
I did check what a CORS error is. I do not have access to the server but that doesn't explain why doing it from javascript works and does not produce the error " No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access. The response had HTTP status code 405."
&gt; I do not have access to the server but that doesn't explain why doing it from javascript works and does not produce the error As I said, the error is at the intersection between server and client. It is mainly a server thing but it is not 100% related to the server. The client can chose to ignore the security issue. Elm is defaulting to the correct way of treating this issue. If the request works in another environment, it works because that environment ignores a security setting. If you want to ignore the security (for development purposes) you can voluntarily do so by disabling it in the browser. 
It is intended for a user to use it. Does this mean the javascript way may throw the error with some platforms? Maybe I can use a CORS proxy then. Thank you! 
&gt; It is intended for a user to use it. Does this mean the javascript way may throw the error with some platforms? If it is intended for the general public than the default, secure behavior that Elm has is the correct way to approach this. Using some kind of proxy to bypass the security settings could be a viable option as this proxy could be easily removed from the chain as soon as you can change (if possible) the server settings. The idea is to solve this outside of the Elm project as this is more a server-side concern than a client side concern. 
Problem is Github pages is hosting the website and I am doing a request to Google sheets. From what I've seen github pages adds the right headers but I tested it and didn't work from there.
Thanks for the detailed reply - I think it makes sense to me now!
I love this! elm explicitly excluded typeclasess to not introduce additional complexity or something, annoying me on multiple occasions. But this just hacks them back in, amazing!
&gt; grid Thanks! I was able to find that but I'm still not quite connecting how you would wire up pulling the data from the ajax endpoints when moving from one page to the other.
I'm working on a [floor plan/seating chart mapper application](https://github.com/shoemakerdr/sat-django/) with Python/Django backend and Elm front end for the floor plan viewer/editor. Still have a ways to go. Need to finish implementing the rest of the editing features, rewrite the API, and then hook it into Elm and add some nice error handling. Also gonna need a big refactor on the Elm code, so any recommendations or suggestions on that would be appreciated!
I guess there is nothing as ‚Äûout-of-the-box‚Äú as you seem to be looking for, but you can easily combine this with http.get or https://github.com/jschomay/elm-paginate if it makes sense for your usecase. 
I guess this text was already there... https://blog.realkinetic.com/elm-changed-my-mind-about-unpopular-languages-190a23f4a834
@ggerico, it looks like you can SET the selectionStart/End with "selectionStart : Int -&gt; Attribute msg", but how do you GET the selection values? I want to have a text field that you can type into, but if you click on a button, then it will insert text into the text field at the current cursor/caret position.
Despite all the hate Evan received over his decision to close "kernel code", I feel this is the right direction and choice. Especially considering that Elm most probably in future will compile to WebAssembly.
I assert that ElmLang is what the cure to JS fatigue looks like: curated libraries, one way to do things, slow and steady evolution, a refusal to bow to every whim of the community, "no, we won't bless your one-off hack". It's like there's an actual adult in the room.
I've been reading about ports for Elm-JS interop but still cannot for the life of me figure out quite how I would use the [Chart.js](http://www.chartjs.org/) library. Has anyone used this library with Elm that could give me a few pointers?
It's generally a good idea to avoid calling the `update` function recursively, it's a big function that can do anything so calling it recursively makes it much harder to debug. The code you've posted ignores the `model` value returned from the calls to `update`. Doing this will inevitably result in missing future changes to the model that relate to those Cmds. I recommend you instead split the cases for Foo and Bar out in to functions and call those functions directly. ``` foo = Random.generate ExampleMessageA (Random.int 1 10) bar = Random.generate ExampleMessageB (Random.int 1 10) update msg model = case msg of Foo -&gt; (model, foo) Bar -&gt; (model, bar) Baz -&gt; (model, Cmd.batch [ foo, bar ]) ``` 
This has been a long time coming. I'd still like to see a nicer story for packaging ports over libraries, but it will be nice to see the debate finally settled. Now, with BuckleScript, ClojureScript, Purescript, Rust/Wasm, Ghcjs, etc. there are enough alternatives that we can say "this is Elm's niche, it is going to be very good at it, and if that doesn't suit your needs you might have to try a different tool.
[removed]
"if that doesn't suit your needs you might have to try a different tool." Or more bluntly: FIFO
Firstly, I'm glad Evan wrote this post. It's a great way of communicating a potentially sticky point with the next release. It's also great that he delineated the path to his thought and the vision. Secondly, I fully agree with this decision. I think it's aligned with the vision and the mission of Elm (at least as I see it). There is a downside of course, it will limit flexibility and ability to use some needed native codes and possibly make it very hard to develop some applications that need some of these native codes. But I'm guessing these will mostly be corner cases and in the long run (assuming Elm will still be around) will actually greatly benefit Elm ecosystem. That said, Elm will probably need a faster process for selecting and curating libraries and approving them (while maintaining the Elm vision) for this decision to become fully beneficial. 
I didn't want to say it explicitly. But sooner than later objective will be to completely replace Javascript, not live with it side by side. And as much as people will deny it this is exactly the objective of WebAssembly, even if they claim contrary to that on their home page. And everyone knows the reason, Dart. Dart tried to outright kill JS, and it didn't go well so this is the more ninja approach.
Better in which way? Can you give a concrete example of what you are missing that is high quality and needs to be called via native code?
First In First Out? 
I didn‚Äôt want to pretend they are perfect, I want to understand in which way people feel limited by them, as I personally have not experienced this, which probably is because I used them to a small extend. I cannot speak to why Task Ports do not exist, also because I don‚Äôt know their downsides. Which downsides do you see? If ports would work like the http package, would that make your usecase easier?
You are asserting things that you really have no business asserting. &gt;But sooner than later objective will be to completely replace Javascript, not live with it side by side. No sane browser vendor would break millions of existing websites. &gt;And as much as people will deny it this is exactly the objective of WebAssembly, even if they claim contrary to that on their home page. So even though the goal of WebAssembly is explicitly *not* to replace javascript, you're privy to the secret, conspiratorial inner workings of the WebAssembly working group. Got it. &gt;And everyone knows the reason, Dart. Dart tried to outright kill JS, and it didn't go well The original goal of dart was to have a separate VM altogether for running dart, not replace the Javascript VM. It failed in large part because non-Google browser vendor was going to ship a new language-specific VM. Please stop spreading blatant misinformation.
Too much hostility and aggressiveness in a post that warranted none. 
&gt; **Is WebAssembly trying to replace JavaScript?** &gt; &gt; No! WebAssembly is designed to be a complement to, not replacement of, JavaScript. While WebAssembly will, over time, allow many languages to be compiled to the Web, JavaScript has an incredible amount of momentum and will remain the single, privileged (as described above) dynamic language of the Web. http://webassembly.org/docs/faq/#is-webassembly-trying-to-replace-javascript
Addressing some of Evan's points specifically: &gt;How can I... not have people write jQuery bindings for Elm? I *personally* have not witnessed anyone wanting to write native modules for integrating with javascript libraries. In all cases where I desired the ability to write native code, it was either to fix bugs in core libraries or integrate directly with native browser APIs. It seems to be the motivation for others as well. &gt;I was very surprised when people began reverse engineering it to write packages, and we did not really know how to handle that. I'm a bit surprised by this. This is the nature of open source software! Trying to lock down your software to prevent people from picking it apart and trying to understand it is weirdly draconian for an open source project. &gt;I always wondered ‚ÄúHow do I document that a-thing-that-does-not-exist does not exist?‚Äù Except it does exist. You want people to *pretend* it doesn't exist. &gt;I felt that I had communicated the intent poorly and tried to address that here You communicated the intent clearly. People just disagreed with it. &gt;Packages often are fine. Wait, do you have the IE9 polyfill? I think that is a huge loss. Wait, are you saying that the motivation for not having native bindings for modern browser APIs is to maintain backwards compatibility with a browser that has 0.12% of the market share? &gt;Elm will likely compile to WebAssembly some day. And WebAssembly can call into Javascript, and backwards compatibility could be maintained. &gt;I do not know of big exploits like this, but it seems like a strange door to open casually. "I'm paranoid that browser vendors don't understand security and as the author of a transpiled language it's my job to prevent it." &gt; ‚ÄúI want jQuery (and d3 and react and moment.js) in Elm‚Äù for Ruby, Python, or Haskell This keeps being presented as the motivation for people to want to write native code, but it's overwhelmingly not. People want to interface with modern browser APIs without resorting to ports. &gt;And point out that ‚Äúwhy doesn‚Äôt JS allow C calls?‚Äù is basically the same question. "Why doesn't JS allow calls from a sandboxed environment into an unsafe language with manual memory management?" is not remotely close to the same question.
Can you suggest a more palatable way to assert that the person I'm responding to is spreading blatant misinformation?
I just said they claim exactly opposite on their front page. Don't you read? Not everything is supposed to be taken at face value. 
not sure if this one is for **total** noobs, but I liked it: [Elm For Beginners](https://courses.knowthen.com/p/elm-for-beginners)
&gt;Some people like you just like to live in their make believe world even when the writing is on the wall. Ok. From [the web assembly website](http://webassembly.org/docs/faq/) **Is WebAssembly trying to replace JavaScript?** *No! WebAssembly is designed to be a complement to, not replacement of, JavaScript.* What specifically have I said that is misleading?
Who should I trust for information about WebAssembly? 1. Official communications from the WebAssembly team. 2. Some random guy on the internet. I'll go with choice number 1.
Folks, there's too much aggression in this thread to keep it open. We don't need that here. Specifically, please review the [forum rules](https://github.com/elm-lang/forum-rules). If you have specific things that need to be solved that you're currently using native code for, please open separate topics.
I just found https://github.com/danielnarey/elm-modular-ui * Site: http://danielnarey.com/elm-modular-ui/ Looks pretty nice. From the site: &gt;Modular UI is a framework for building a modern user interface in Elm that abstracts out a lot of the details of the underlying HTML and CSS. It's partially inspired by and designed to be used with the Bulma CSS framework.
Your bad-faith Socratic questioning is obvious and insulting.
This is the most important comment here, but of course no one has addressed it.
I found this paid course pretty nice (~$20): https://www.udemy.com/beginners-guide-to-elm-programming-build-web-apps He goes through a lot of smaller examples compared to "Elm For Beginners". I do recommend doing both though, starting with the Udemy course I recommended above. There is also an Elm slack (elmlang.slack.com) with a ton of friendly and helpful people so hop on there and join the beginners channel. Best of luck with learning Elm! It's a super fun and nice language to work with.
the Pragmatic Studio videos are pretty good. https://pragmaticstudio.com/elm
[removed]
976
The official [Introduction](https://guide.elm-lang.org/) is a pretty gentle introduction to Elm. I also liked the [Elm tutorial](https://www.elm-tutorial.org/en/) as a way to get started.
Yes, Beginning Elm is really awesome. üöÄ
Working on a "classic" image database frontend at work linked to our software ecosystem. Incidentally it needs i18n so, I'm also writing a Gettext implementation (the core is just a PO parser). That part may be open-sourced.
Thanks! I'm having a hard time figuring out how to mesh pagination and ajax requests but I'll keep working on that.
I think the library is the way to go. The last episode of elm-town had it as the topic: https://www.elmtown.audio/28-elm-paginate
I like watching videos to get to know something, [this talk by Richard](https://www.youtube.com/watch?v=G-GhUxeYc1U) is pretty easy to understand, I think
Spare time project is a budgeting app. Demo: http://martincapodici.com/elm/elm-budget/index.html The data you see is shared, using a parse back end. 
You also need to provide an initial value: List.foldl (\n total -&gt; n + total) 0 [1, 2, 3] 
It is not an antipattern, often that is even reasonable. Just have in mind that it ships the ‚Äúruntime‚Äù with every compiled file, but after gzip it‚Äôs pretty small. Additionally you can uglify the code, which earns you another 20% in my experience. That being said, the next release is going to focus on that with code splitting and dead code elimination, which should make everything snappier. As we learned in a post on discuss, that version is further away than one month, so you can go with your approach for now. I expected it to be not too hard to change down the road.
ok so it is same as `reduce` and `reduceRight` from JS. Only the name is different in Elm. Got it.
[removed]
[removed]
Wow, you could build your App to train sales people. Funky stuff. Thanks for showing the world. 
&gt; that new version is further away than one month If a pre-release version was not yet announce, I always assume that it's further than one month.
Is there a typeclass definition or something that specifies the interface for `Cmd`? I'm having trouble understanding why a `Generator` for example can be used as a `Cmd` when using random values. 
It‚Äôs basically what elm needs to be able to do the immutability, ports, event loop and so on. That said, it‚Äôs much smaller than the equivalent in js libraries. A fairly complex multiple page app with around 10 imports resulted in 300 kB after zipping. I think that‚Äôs pretty acceptable, but of course your usecase might vary. If you go down the road, use HTTP2 server push if you can. It‚Äôs trivial to setup with the caddy webserver.
Folds turn lists into pipelines. Folds always takes an initial value and applies a series of transformations to it. It applies one transformation for every element in the list. For instance, if I want to sum a list, my initial value will be 0. Then for every number in the list, I will add that value. If I want to find the length of a list, I start with 0 and for each element in the list, I increment that by 1. If I want to find the max value of a list of positive numbers, I start with 0 and then for each number in the list, I replace the initial value with the current value if the current value is bigger. The function you pass in for fold is the hardest part to understand. It's type is `a -&gt; b -&gt; b`. I like to think of this as `a -&gt; (b -&gt; b)`, giving each element in the list (the `a`) a way to transform the initial value (which will be a function `b -&gt; b`).
Looks like i've been p0wnd ... thanks for the testing :-). Yes if someone puts invalid Json into the store it will crash on retrieval. Something I have had on my mind to fix.
In case you didn't see it, Dillon summarized quite well the GraphQL status in elm in this post: https://discourse.elm-lang.org/t/introducing-graphqelm-a-tool-for-type-safe-graphql-queries/472
Interesting project, thanks for sharing! I was excited for an addition to plotting libraries for elm, but they are rendering it on the backend. The elm code is very readable and I will try to understand it all to see if I can learn something.
`reduce` is just a special case of `fold`. In fold, the initial value is a required parameter. A reduce is just a fold where the initial value is the first element of the list. 
And `(\n total -&gt; n + total)` is just a long way of saying `+` so you can simplify further to: `List.foldl (+) 0 [1, 2, 3]` 
Elm doesn't have typeclasses. The to turn `Generator` into a `Cmd` you need to use `generate`. You can think about `Generator a` as about a function that takes a seed and returns `(a, Seed)`. The runtime implementation of `generate` takes care of generating a seed, running the function from the generator and returning into the update loop the value generated. You can run the same generator/function without the help of the runtime by using a seed and the function `step`. 
You can actually compile each module combined into one JS blob which embeds the runtime once, for better efficiency.
Haha, not yet. But hopefully, eventually. Thanks! 
Yes, I've seen it and read through couple of time before I started. I took different approach, I believe, a more stable one.
Thanks! 
&gt; As we learned in a post from Evan on discuss, that new version is further away than one month Do you have a link for this?
No problem. I've grown sour on the "everything needs to be a SPA" after watching another team at my organization spend an obscene amount of money and an insane amount of time building a React/Redux/Flux+Node render server system that just wasn't that complicated to begin with conceptually. Granted that's not the fault or React but I feel like FE devs that use React want everything to be a SPA even when the story for doing that is less then compelling. Also I haven't looked at elm-navigation - I've read that it's pretty nice but again for what I'm working on next a SPA IMO isn't the answer.
Also, because of this reduce is limited type-wise. You can reduce a list of bools to a bool (eg "and" them together) but you can't reduce them to an int (eg count the number of trues), which is possible with fold.
Is it possible to avoid Ruby as a dep?
yeah, i only use ruby for rake. you can run any of those commands in the terminal yourself or use make or any other script to run your commands. ruby isn't required.
Cool, do you have any docs on this?
thanks! 
Pure Elm, no JS. Impressive!
[removed]
Richard Feldman put together an example project that illustrates best practices for exactly what you‚Äôre trying to do: https://github.com/rtfeldman/elm-spa-example Also, don‚Äôt be discouraged by the fact that you‚Äôre not sure how to approach the problem. Having also spent years writing traditional MVC apps, it takes a while for your brain to make the fundamental shift toward a more functional way of thinking about these problems. 
Thank you so much - I think that this is exactly what I am looking for!
As somebody who feels like they finally do things the elm way the first thing I suggest is you need to move from MVC way of thinking to TEA (The Elm Architecture) way of thinking. In Elm you'll see something called the model and something called the view, so you might be inclined to think "Okay, this is somewhat like MVC...", my own thinking has shifted that when I think of Model and View in elm I think of them in a much different way now. I agree with the suggestion to use the elm-spa-example as a way to bridge your learning. Also I'll mention something that came up in my own learning: At some point you'll come across this code: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L435 In my opinion what is going on there is very Elm-esque and it would help to check out this link regarding composing parent-child: https://www.elm-tutorial.org/en-v01/02-elm-arch/06-composing.html
&gt; move from MVC way of thinking to TEA I find it interesting that you see it that way. From my POV, TEA is actually a very clean/direct implementation of MVC.
We'd have to go into a deep conversation about what you mean by MVC, and what I mean by MVC and the original concept as described by Trygve Reenskaug and figure out how we differ in ideas. I concede it's entirely possible my concept of MVC is totally wrong despite assurances I was doing it. For me I found value in just learning TEA without trying to map it to MVC.
the two or three places where he basically threatens the reader are a bit odd, but beyond that, this is the best Elm critique I‚Äôve ever seen.
Hmm, my poor attempt at humour, thanks for letting me know it comes over badly. I'll try to tweak it to make it more obvious. Glad you liked the post in general.
It is used in core library code for: 1. Implementing many key libraries that are performance sensitive 2. Implementing everything that simply cannot be done in Elm - at some point you need access to things like XMLHttpRequest, which is not pure. For example, here are the implementations (in Javascript) of some key functions that you use in Elm, such as `ceiling` and `not`: https://github.com/elm-lang/core/blob/master/src/Elm/Kernel/Basics.js And here is the Javascript code behind the [http](http://package.elm-lang.org/packages/elm-lang/http/latest) library: https://github.com/elm-lang/http/blob/master/src/Elm/Kernel/Http.js This code is 'unsafe', in that any exception raised in it will crash your Elm code immediately. The primary usage of Native/Kernel Modules is in implementing Elm itself. However, up to and including 0.18 there is nothing to stop you writing your own, if for example there is something missing you cannot easily write in Elm. I gave an example of `toHex`, which you can implement easily in Elm, but it turns out to be massively slower than the Javascript code `x.toString(16)`. That `toString` method is not available to you in Elm, but you could easily make a tiny native module that would do it. You could then call this code as a pure function in Elm. Normally, you would not do this with Javascript functions, if they have side effects or at all untrusted. Normally you would use ports to call Javascript functions. If you overuse or abuse native modules, for example running code with bugs, or impure (side-effectful) code, you will make life hard for yourself and break your app.
The elm implementation doesn't necessarily have to be slow, but yes, you're essentially correct.
I was actually interested in doing a project with Web Audio in elm. Does this recent prohibition explain why I can't find https://github.com/trotha01/elm-webaudio on http://package.elm-lang.org ? 
No. You can't share native code on package.elm-lang.org. That's a restriction in place already, and one that many people like. It means that any third party dependency you get from the package manager cannot break your code (well, there are some runtime exceptions, but not a whole lot). This recent restriction makes it more difficult to use call javascript functions synchronously from Elm, even in unpublished packages. Ports will work as they always have, however.
tldr about Native/Kernel stuff: OP wants to call arbitrary JS code from Elm synchronously which goes against the very foundation of Elm ‚Äì purity and no runtime exceptions and he won't be able to do that from 0.19.
Native modules have never been allowed in the official package repository. About Web Audio: The official stance from what I've read is to wait until Evan implements all these APIs which will be of highest priority once 0.19 is out. If you want to use those sooner, it's better to use a different language e.g. PureScript.
Well ok then... Do you think Web Audio could be a candidate for a blessed native module? How would one petition for that?
As someone who has been using Elm in production at work and in personal projects for almost 3 years now, I wholeheartedly agree with all the points made in this article and am actively looking for an alternative to Elm. Rust + [Yew](https://github.com/DenisKolodin/yew) is one possible alternative I am currently investigating. I can understand why Evan wants to close the Native/Kernel module escape hatch, and I appreciate his long-term perspective on language design. It's certainly possible that this decision will eventually lead to higher-quality pure Elm packages. Maybe the day will come where non-trivial apps can be built entirely in Elm and compile down to WebAssembly, no JS needed. Back to reality though, JS interop/FFI is almost always necessary for Elm apps in 2018 and will be for the foreseeable future. This can be true even for very simple use cases. For example, lets say you want to display a UTC `Date` in the users local timezone. This is something that's very simple in JS, but currently [impossible in Elm](https://github.com/elm-lang/core/issues/755) without JS interop. Of course ports could be used to fetch the users' local timezone offset, or the offset could be passed through with program flags, but both of those solutions have drawbacks and introduce unnecessary complexity for what should be a simple task. Another example is an issue I ran into recently with the `WebSocket` package while trying to connect to an Apollo GraphQL server. In JS-land the [WebSocket constructor](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) accepts an optional second argument that specifies the protocol(s) to use, e.g. `new WebSocket("wss://localhost:8888", "graphql-ws");`. However, the Elm `WebSocket` package [does not support specifying protocols](https://github.com/elm-lang/websocket/issues/20), and the GraphQL server will not work without the protocol specified. So the possible solutions to this problem are: 1. Modify the server code to work without a protocol specified. 2. Rewrite with ports. 3. Copy the standard `WebSocket` package to your project and make changes where necessary (requires Native modules). Note that by rewriting this in ports you're essentially throwing out all the nice things that the Elm package does for you like connection handling. Option #3 would be my preferred solution. In the past these issues have been annoying but tolerable thanks to Native modules. However with 0.19, these issues could quickly become deal breakers. I'm aware that there will supposedly be a quicker turn-around with these kinds of issues once 0.19 is out, but I'll believe it when I see it. And to those who would say "just use 0.18 then", will 0.18 receive any performance/stability updates? I'd rather not develop new projects on a depreciated platform, and honestly there are things about 0.18 that I really don't like (things that the OP has already pointed out). Regardless of the Native module situation, the most alarming thing for me is the general patronizing and sometimes hostile attitude from Elm core developers. Most of the time the impression I get from NRI/Evan is that they think they know better than their users, and things should always be done a certain way -- if you're not doing it the "Elm way" then you're probably just not smart enough to think of a good solution. In a way I can kind of understand this attitude, because for a lot of people Elm is probably their first experience with functional programming. Moving from JS to Elm requires a change in perspective, and some developers may try to cling on to the old way of doing things. I'm sure NRI/Evan have seen this a lot, which is probably why they tend to answer most questions with questions. To solve problems the "Elm way" usually requires some deeper thought that might not be immediately obvious, especially to a newcomer. The problem though is when the Elm core team treats all their users like newcomers. Like their users don't know what they're doing and that they need to be taught how to do things the "right" way. Elm is 6 years old now, so it's entirely possible that the users *do* know what they're doing and have a good reason for doing it that way. But I've learned long ago that, unless you're doing things the "Elm way" don't bother asking questions because you will only be meet with more questions and frustration. Basically you'll be told to do things their way, or go rewrite your entire project in another language like Purescript/ReasonML/GHCJS. For someone who has devoted years learning, contributing, and advocating for Elm, this response is especially infuriating. Sorry for the wall of text. This post is longer than I originally intended but I think it's important for people just starting out with Elm to understand what they're getting into. I may come back to Elm in a couple years when it has matured, but for now I can no longer recommend Elm for anyone doing any serious work.
Should we be writing kernel code (native code) or not? This question contains a false dichotomy. As OP points out, Elm's core libraries, both the general-purpose parts and those dealing with the Web Platform, are written in JavaScript. So whether you know it or not, you're already using "unsafe" kernel code. As more parts of the Web Platform get added to Elm, those will inevitably be implemented using kernel code as well. So the salient distinction is between kernel code written by the Elm core team and kernel code written by others. In the absence of formal verification, it all boils down to a question of trust. As part of their jobs, developers are frequently asked to judge the quality of code. The compiler change for elm 0.19 hard-codes this decision for you. Elm's compiler will only accept kernel code written by a specific group of people. Some people may consider only the quality of kernel code authored by the Elm team sufficient for their project. But depending on your requirements, you may apply different standards of quality. Perhaps a pure function from a well-respected NPM library meets your standard. In fact, some libraries can be considered more trustworthy than Elm's core library based on objective standards of evaluation like industry use, test coverage etc. More strikingly, the compiler change, if released, will prevent you from using your own JavaScript code, barring drastic mesaures like compiler patches. Does this imply that you, the developer, personally cannot be trusted to make the right call with regard to the suitability of your own code? With the change, the compiler changes from not making things easy to actively getting into your way. This attitude strikes a lot of people as excessively paternalistic. We commonly assume that whether or not to trust a function to work correctly is a decision that should be ultimately left to the individual developer. Are we ready to jettison this assumption in the name of type safety?
&gt; Does this imply that you, the developer, personally cannot be trusted to make the right call with regard to the suitability of your own code? Yes. Evan compares writing Native/Kernel code to be equivalent to asking browsers to execute C++ code for APIs that JavaScript cannot access. &gt; the compiler changes from not making things easy to actively getting into your way. It's actively preventing you from breaking Elm's guarantees. &gt; Are we ready to jettison this assumption in the name of type safety? Not just type safety, that's the whole philosophy of Elm. We want a language free from runtime errors and decoupled from the semantics of JavaScript. This cannot be achieved if the compiler allows injecting any piece of JavaScript code.
&gt; Yes. Evan compares writing Native/Kernel code to be equivalent to asking browsers to execute C++ code for APIs that JavaScript cannot access. That's a good point, JavaScript has no way to break out of its sandbox. But I don't think it's really relevant to Elm, because JavaScript in a web browser needs to be sandboxed for security. The browser facilitates all communication with the operating system and hardware. When JavaScript is outside of a browser, for example run with Node.js, it has much more freedom. In fact, [Node provides a system for implementing features in C++](https://nodejs.org/api/addons.html). That doesn't mean I think Native/Kernel code should be allowed in the elm package repository. Elm can't guarantee that code will work, so it must be tested outside of Elm. I think it makes sense for any Native/Kernel code to have a rigorous approval process before being allowed in the package library.
You seem out of touch. Elm's development does have issues. But forking a project isn't a magic solution. Unless someone is willing to lead (and fund) the fork, it will just die shortly down the line. A fork would also severely hurt the community in the short term, diving an already small community in two. Is Elm worth forking? Maybe. People are unhappy about the situation. But are they fork-levels of unhappy? I'm not sure. 
&gt; OP wants to call arbitrary JS code from Elm synchronously which goes against the very foundation of Elm ‚Äì purity and no runtime exceptions His arguments around Native do present a use case where it makes sense. One might be able to achieve the same functionality using different techniques (like the one Richard mentioned in the discourse thread) but the use case is valid and does not go against the purity of the language. 
Very good points. These are also the reason Im giving up on elm for now. Maybe once we can compile it to WA it might be worth picking up again..
maybe this one ? http://package.elm-lang.org/packages/elm-community/graph/5.0.1
Best to clarify if you mean graph as in X Y chart or graph as in nodes with arrows.
ah, I too agree with you I wrote the same thing lol. 
Purescript already exists for those who want a less opinionated (and more powerful/complex) ML.
Nodes with Arrow. Specifically I need to represent DAGs (Directed Acyclic Graphs). 
This is useful for only charts it seems. I am more interested in representing DAGs. 
This library seems to be for manipulating and operating on Graphs not for rendering them. Still useful though. 
You might also consider [elm-vega](http://package.elm-lang.org/packages/gicentre/elm-vega/latest). This is a higher-level approach to chart specification that maps onto the [Vega-Lite](https://vega.github.io/vega-lite/) grammar.
There are a couple of issues here. The `&lt;&lt;` operator allows you to create new functions by combining existing ones. It is helpful to remember that `&lt;&lt;` and `&gt;&gt;` are about defining functions, not evaluating them. So, for example, the following would be valid: notEven = not &lt;&lt; isEven notEven 2 If you prefer you can create the composed function directly without naming it: (not &lt;&lt; isEven) 2 But notice the use of brackets here to ensure that `not` and `isEven` are combined before the `2` argument is applied. The second issue is that the `%` operator requires its arguments to be integers, but `sort(4)` is a float, so you need to convert it to an integer before passing it to your function: (not &lt;&lt; isEven) (round (sqrt 4)) or if you prefer it without brackets, you can use the pipeline idiom: sqrt 4 |&gt; round |&gt; not &lt;&lt; isEven Noticing that `|&gt;` pipe is what you use when you wish to pass the evaluated result of one function as an argument to the next function whereas the `&lt;&lt;` pipe is when you want to join two functions together to form a new one. One way of remembering the distinction between the two types of operator is that `&lt;&lt;` and `&gt;&gt;` are about connecting segments of a pipe together, while `|&gt;` and '&lt;|` are about passing values through a pipe. 
Thank you very much for explaining it. You nailed it. I am noob both in FP, ELM and Typed language. My background is JS and Ruby :)
I agree the op should try to learn as much as possible online. Then wherever they hit a wall that's something to bring to the session. For some people even getting started is a wall. I remember when I started programming. It was a mystery how to get the tooling set up.
I really appreciate the advice, I am just looking for a tutor for personal reasons, but I have been following along tutorials online.
If Elm were a stock, I'd short it. The leadership of this language will never change. Elm is doomed.
The "error" and "value" here represent types. In the "Msg" example, the Password part was hard-coded to always be a string. But for the Result type, the Ok value and the Err value can be of any type, and so those types have to be specified on the Result type as well. For example, you might have a function that will return an integer on success, or a string on failure. So the type of this function would be `Result Int String`. Hope this makes sense :)
Those are type variables. You could rewrite it as: type Result a b = Ok a | Err b Which is probably less misleading since `a` and `b` don't carry a semantic meaning. 
There is no hydration, the library is just to turn your Elm view with a model into HTML
thanks for encouraging me :).
Doh! Good catch :)
As others have pointed out, your problem is a type mismatch: you can't treat Int and Float as the same thing without explicit conversion, full stop. But to understand `(&lt;&lt;)` better, you can also read [this StackOverflow answer](https://stackoverflow.com/a/32078225/596361).
Implicitly passing data, without named arguments, is known as "point-free programming". In your example, it doesn't change how the code works. It's really just a matter of preference, ie code style. Here's a few more examples with elm: https://www.elm-tutorial.org/en/tips-tricks/point-free-style.html Generally more explicit code has less errors (case in point -- type signatures!) so I believe Elm encourages top level functions to always name their arguments. In fact, I vaguely recall hearing that leaving out named arguments will be treated as an error in the future, although I can't remember where I read that.
Yes, plus: 4. Continue using 0.18 (no problem doing this for a while). 5. When 0.19 comes out, patch the compiler to make it easier to run native code. I've had a quick look at the code, my guess is it would be pretty easy to patch. But it's just a bit annoying to have to build the compiler yourself. 
Hahaha I had always wanted something like this, and it turned out exactly as crazy as I thought it would. Despite that, I might still use it. I have several complex re-usable pieces in my app that have to be a triplet to be re-used, there is just no way around it. I definitely made the early mistake of doing that way too much, but even after untangling all my apps, I still have several 2-3 things that I want to re-use that *have* to be a triplet.
Question around union type destructuring and returning the original value from a function. Let's say I have a union.. type TabbedPanel = TabbedPanel Config (List Tab) Int Note that because this is an opaque type the single value of this union holds quite a bit of data. In many situations it's very convenient to destructure single value unions in the function declaration but then it makes it inconvenient to return the original value. select : Int -&gt; TabbedPanel -&gt; TabbedPanel select index (TabbedPanel config tabs sIndex) = if index &gt; List.length tabs - 1 || index &lt; 0 then TabbedPanel config tabs sIndex -- the original argument to the function else TabbedPanel config tabs index I realize I could do this.. select : Int -&gt; TabbedPanel -&gt; TabbedPanel select index tabbedPanel = let (TabbedPanel config tabs sIndex) = tabbedPanel in if index &gt; List.length tabs - 1 || index &lt; 0 then tabbedPanel else TabbedPanel config tabs index but I generally like avoiding let..in blocks if possible. Has anyone come across a different way to handle this same situation?
&gt; In fact, I vaguely recall hearing that leaving out named arguments will be treated as an error in the future, although I can't remember where I read that. I seriously doubt that. Functions are first class citizens in Elm. It is perfectly fine to receive a function and it is perfectly fine to return a function. The entirety of `Html` library is implemented in point-free style so I seriously doubt that will go away. 
http://faq.elm-community.org/#how-can-i-pattern-match-a-record-and-its-values-at-the-same-time
Perfect. Thanks!
What is the benefit of a type union with a single type over a type alias with a single type. Such as: type alias UserName = String versus type UserName = UserName String The only reason I can think to do either is to have more semantic/readable type names, but I don't see the advantage of using a union type like this.
Don't use it if you only have 2-3 triplets! It's better to write a bit of boilerplate than depend on a package like this. It is for projects where you have so much components/triplets that it becomes really hard to work with them. Go as much as you can without using it, and if you have any problems with scaling your app, definitely ask the community for the help first!
That's interesting. How often do you do this? It seems like you could apply this example to any function that takes multiple arguments of the same type. Do you define new type unions for every function? For example: numerator = 0 denominator = 10 division num den = num / den result = division denominator numerator -- divide by zero error?
I'm not sure if there's a universal answer to this. Defining new types is useful but it adds boilerplate code when handling values, so it isn't practical to do it everywhere (I think). 
I'm joking, I get it! I've been there and messed up plenty. Life is way better without triplets now. But I have so many goddamn datepickers...
I don't write Elm often, but I write a lot of functional code. While I do like the terseness of being able to drop arguments, I think the value of being explicit outweighs the value of being terse and clever. That's more of a guideline than a rule, and sometimes the point-free style more illuminates the intent of a function by removing visual noise, but if you're not sure, I would err on the side of explicitness.
&gt; Is Result is a function here which takes 2 arguments error and value? `Result` is *type constructor*, it constructs the type. `Ok` and `Err` are *value constructors*. Type constructors can have arguments - type variables. Those variables should appear somewhere in value constructor definitions.
Depends on culture that you impose on your self and the others. I work alone, and I make my own rules that are half of the times broken, cuz I forgot the rule at that moment ^^ My personal experience is that I am happy to drop last argument, and you don't even need to write (LinkedList a -&gt; LinkedList a) in parenthesis, be cause it reduces typing, but I have came back to certain functions with dropped argument and it took me couple of frames of internal rendering until I figured out that I actually omitted the last argument, and that a thing returns a function that does a returns a thing. Having said that, I still like writing something likes: a : Int -&gt; String -&gt; Bomb a i s = daBomb (toString i) s -- and then I'd drop argument bbb : String -&gt; Bomb bbb = a 420 beast : String -&gt; Bomb beast = a 616 Hence, it's really question of style, and those come with experience of burning your self on your own mistakes :) 
I think this answer is very close to what I asked. But other answers are also helpful because those taught me something new which I didn't think before I saw them. So we always call value constructors, but not type constructors. Like we do `Ok (sqrt x)`, or `Err "negative"`. So why do we need to mention type variables with type constructor? Looks like there is some connection which I am not able catch yet. :)
The date problem noted above is now being [tracked here](https://github.com/elm-lang/core/issues/816).
I had some thoughts about it. There is nice alternative to forking. Create a transpiler. Elm syntax is not that big so recreating it (while making sparser) and then extending doesn't seem as much work as diving deep into current compiler's architecture. However, the question is - what people really need. I know there is much boilerplate around SPA navigation. Some people would like to see custom generic types in Elm. Some would like to make hacks around calling embedding JS. And if there is support for inline shaders then why not for GraphQL or anything custom? Some compiler plugins, maybe? But there is more than that. Tooling would need to be forked too, probably. Support for editors, package system and more (?) It would be nice to share some syntax proposals. I'd love to review some of them.
&gt; So we always call value constructors, but not type constructors. We call type constructors - on the type level! For example let's look at function f : Int -&gt; Maybe String f x = Just (toString x) Here `Maybe String` is a call of type constructor `Maybe` with argument `String`. &gt; So why do we need to mention type variables with type constructor? When we create value with type `List String` we can't tell to the compiler that this value just have type `List`! Otherwise a compiler won't distinct types of the lists with different content and allow us to do smth like this a : List a = [1, 2, 3] b : List b = ["foo", "bar"] c : List c = List.append a b -- oops! 
I don't see anything in that post about when the release will be - can you point me to the relevant paragraph?
&gt; All that said, Elm 0.19 is not out today. The alpha period will last one or more months, and that has not started yet. We have a lot of time to figure out each case, and I think we can do it in a good way
Hi, as a humble user of Elm on side projects, I don't think bashing on Evan is the best use of anyone's time. I think the guy has done a marvellous job, and appears to remain very committed to the evolution of the language. Maybe what the Elm Foundation needs is more communication around the project status, more documentation, but throwing more devs on the project does not necessarily help things move faster. Companies like NoRedInk have already built successful applications around the Elm language, although with various hacks on build tools, progressive integration of elm components, etc., so the language is mature enough to do serious work. Maybe you just don't fit the profile of an early adopter, and should go back to Elm once it has reached your maturity comfort zone, or maybe you should use some time to develop side libraries which are as useful as working on the core (see the great elm plotting libraries in the making). And maybe people have felt alienated due to the slow progress of the language, but they cannot have been by Evan himself: in our era of twitter trolls, rarely have I seen someone replying with such calm and intelligence to abrupt, sometimes even hurtful, comments.
(I'm replying to your comment because this is not perhaps too valuable of an input to OP's question) Wouldn't treating point-free style as an error be just an ad-hoc measure to prevent using a language feature that's baked in it? Let's say I'm creating a function that adds an item to the end of a list: append : a -&gt; List a -&gt; List a append x xs = xs ++ [ x ] Now I want to get clever and do this in point-free style: append : a -&gt; List a -&gt; List a append x = flip (++) [ x ] Now imagine that it actually was an error to leave out an argument. I could then write the type signature as `a -&gt; (List a -&gt; List a)`. No problem, right? The function takes one argument and returns a function. Surely this would be still allowed? Only difference is that I would be forced to explicitly show the currying in the type signature. 
This was worth it just for the mention of the [Importance of Ports talk](https://www.youtube.com/watch?v=P3pL85n9_5s) which I hadn't come across before.
Hi, IMO you can do quite a lot in Elm without knowing JS - a good place to start for you (knowing elixir) is probably here: https://guide.elm-lang.org/ of course in the long run it probably won't hurt to know a bit of js (but you can come really far there by just copy&amp;pasting from StackOverflow :D)
You can't do everything in Elm, sometimes you will need to ask JS for something, so you need to learn JS, at least a bit
Thank you a lot for your comment. I will check it out
Nice blog post!
+1 for this. Additionally, Javascript is relatively friendly to the functional paradigm for a mainstream language.
JS
[removed]
[removed]
This one is great: http://javascriptbook.com
Or [bucklescript-tea](https://github.com/OvermindDL1/bucklescript-tea) if you are into [ReasonML](https://reasonml.github.io/).
IMHO, you should learn JS first, build some small apps and start to run into pain points of Javascript. Then come to Elm to see how it drastically improves the Developer Experience.
See how far you can get with just elm in a live-reloading setup, like elm-reactor! But if you're new to webdev, then just HTML and CSS will be challenging enough. 
&gt; because elm compiles to js should i learn js first No, that's like saying "because JS is eventually translated into machine language instructions, you should learn assembly first." There are plenty of JS languages (like CoffeeScript) that are [leaky abstractions](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/) and require knowing JS before learning them. But Elm is not one of them, and shares almost nothing with JS. (Just like Elixir is written in Erlang, but doesn't require you to know Erlang. Or so I imagine.) I say learn Elm first. There is a *lot* less to learn in Elm, since it gets you really far out of the box. Nobody programs in plain "JavaScript", they program in giant abstractions on top of React, Angular, Babel, WebPack, etc. In fact, when you start learning JavaScript, I'd advise that you learn JQuery. It's old, but it's really simple compared to trying to grasp React without a firm grasp of JS + other modern web standards. (I'm sure some people will call me crazy.)
I think I implemented something similar with ports in my Functional babelfish babelFishApp.ports.scrollIdIntoView.subscribe(function(domId) { document.getElementById(domId).scrollIntoView(); }); Full source here: https://github.com/hakonrossebo/functional-programming-babelfish/blob/master/src/index.js
I would say elm first. Elm compiler helps you do do things in a nice way. If you begin with elm you'll end with better code and better understanding of how things work, because, you model things yourself. If you need then to code some js, it'll be easier for you to write the js you miss if really needed. I would definitely go elm first
How are you running the project? I find the easiest is to use something like [elm-live](https://github.com/architectcodes/elm-live) and just drop the sheet into the index.html! There's not a super easy way afaik to do it with elm-reactor
I second elm-live.
When you "take over" the DOM node with the live version of the app, you will see the screen blink briefly as the entire DOM is deleted and then replaced. This is because there is no diffing against the actual DOM, which would be needed for a slicker rehydration experience. I am not 100% sure, but I think this is coming in 0.19.
I know this is a silly answer, but if you want Elm to have control over everything inside the `&lt;html&gt;` tag, then you can just link your stylesheet in there. https://ellie-app.com/gLmXtQd3ja1/0
I know this is a silly answer, but you can just make a `&lt;style&gt;` tag in Elm, and import whatever you want there. Here's an example: https://ellie-app.com/gLmXtQd3ja1/1
Ummm... it's too minimal to be criticized yet!
Aye, that's the idea. You have your stylesheet linked in your index.html, and then just use the classes in your html functions. For example, for some (rather shitty) sticky header I was working on, the view function looks like this: ```elm view : Model -&gt; Html Msg view model = let brand = div ( if model.is_fixed then [ class "navbar-brand" , class "banner-background" , class "fixed-padding" ] else [ class "navbar-brand" , class "banner-background" ] ) [ text model.title ] navbar = viewNavElements model.nav_elements model.is_fixed in div [ id "banner" ] [ nav [ id "site-navigation" , class "navbar" , attribute "role" "navigation" ] [ brand , navbar ] ] ``` where the classes are from my own css stylesheet I have linked in the index.html.
Informative article. I may reference it in my upcoming "Language Buffet" lunch and learn for the web devs at my company. I didn't know about the Go not having null thing. I have a snippet of Go here where I do a comparison against `nil`. Isn't that effectively null? err := json.Unmarshal([]byte(jsonStrings.GoodJson), &amp;m) if err != nil { ... }
Okay thanks! :)
At [CurrySoftware](https://www.curry-software.com/en/) we use rust and elm in combination for one project. It's basically a SPA-CRUD App with a bit of very hairy logic. It feels really natural, especially because nearly every idea can be formulated as a type in both languages. This makes backend to frontend communication trivial. Alas, in elm one has to write json decoders and encoders manually. Another drawback is, that their syntax is so different. `snake_case` vs. `pascalCase`, `case a of` vs. `match a`, `use` vs `import`. When switching between frontend and backend work I often try to use the syntax of the other language.
I've shared this here before, but seems relevant enough to share again: A demo of my rust + elm project: https://www.youtube.com/watch?v=YC2FvozglPc
Sometimes the timer takes one second to go from 25 to 24:59, sometimes it jumps quicker.
Not OP but I use Yesod/Haskell and Elm and love it ... some differences in the languages yes, but not much overhead to switch between them.
&gt; manually http://eeue56.github.io/json-to-elm/
We haven't looked at Yesod in paticular. The choice of rust was maily because we already had experience using it.
That works well if you use Ints and Strings. But if you want to use custom types (i.e. Markdown is embedded in its own type, types for UserIds SessionIds, etc.) this approach doesn't work very well.
[removed]
I think it's because of the implementation of Time.every second subscription. It runs and runs and when you click the button it's different when it runs next depending how long the former run is over. But maybe I'm wrong. Suggestions how to make this better?
Thanks, I know this video. You mean because I split my code into smaller files? I personally like it really more to have meaningful modules which concern is clear and they only take care of this concern.
Thanks. Using ports may be the easiest approach. 
I don't understand what you mean by "swallows the Nil problem".
Oh that's actually interesting. Didn't know I could do this. I'll play around with it more then! Thanks!
Or servant with the elm type gen, woot 
Curious; why did you go with elm as opposed to the various compile-to-js haskell alternatives out there? Wouldn't that have given you a more fluid developer experience?
We were looking for a front end language and Elm was getting good reviews ... tried it and loved it. Later we were looking into backend languages for a new service and I was able to trick the others into doing Haskell (because it‚Äôs ‚Äúsimilar to Elm‚Äù) and I couldn‚Äôt be happier ;)
And the number of packages is growing too https://www.reddit.com/r/elm/comments/79qucw/789_packages_for_018_listed_in_packageelmlangorg/drao2lp/
Thanks. Yeah, it would also be interesting to look at the rate of growth for the various metrics (although I don't think there is historical data for the packages). I didn't have time to look up more numbers - might do it some other time. 
I think some people confuse "lack of hype-train activity" with "stale".
[removed]
It's very language-specific I think. The idea of library having properly stabilized is kind of alien to the JavaScript ecosystem, but in other context you sometimes hear "X gets its first update in ten years!" and it's big news because people are wondering "what did they need to change, that thing was already perfect?"
I wonder if that has anything to do with Java being old enough to have age-related differences in mindset, with the older devs being more conservative (and also having seen pointless hype before), and the younger devs worrying that Java is becoming stale and stuck in outdated paradigms.
Yes, the important thing here is that Rust is a systems level language, so it's a replacement (the only viable replacement?) for C/C++. 
Use a list of arrays under the hood for the best of both?
Thank you! I've actually thought about it today. Will implement that soonish!
Fascinating! I always thought the efficiency of recursing over a list by pattern matching on its elements one at a time was a big part of the reason `List` made an efficient default, but it sounds like the plan would keep recursion like that efficient? `michael_jackson_eating_popcorn.gif`
Lol. I'm using the latest Java, but I have barely touched anything that was added since version 5...
Probably. And the fact that releases HAVE come out a lot quicker than in the past, so there's some "thought momentum" being disrupted. Too, "enterprisey" places that tend to move WAY slower, chafe at having to update to be assured of new security updates that Sec Orgs are enforcing, vs. the new hotness of other JVM languages that do move a lot quicker like Kotlin, Scala, etc.
&gt; Efficient immutable arrays is a pretty recent invention, first being seen in Clojure back in 2007. Wasn't this based on Phil Bagwell's work from well before? And having been used in Scala before Clojure?
Based on Phil Bagwell's HAMT yes, but made immutable and optimized for use as a vector. Everything I could find online said Clojure pioneered the work, could find no mention of it being used in Scala first.
Don't think that would work.
Is it different than: https://infoscience.epfl.ch/record/52465/files/IC_TECH_REPORT_200244.pdf ?
`List` is an economy of thought, not an efficiency of execution. The reason `List` is the most familiar data structure in functional programming is because it is so damn simple as an algebraic data type. It's the least fixedpoint of the polynomial functor 1 + x, which while probably meaningless to a lot of people who might read this, 1 + x is much less scary than something like 1 + 2x + x^2 or something :) Functional programming is more about the denotation of your programs, not the operation of your programs. It's about *what* your programs compute, not *how* they compute it. A [sufficiently smart compiler](http://wiki.c2.com/?SufficientlySmartCompiler) would be able to take your inefficient linked-list representation, in theory, and convert it into an efficient `List (Array a)` implementation automatically without risking changing the results of your program. But these kinds of optimizations are non-trivial to implement, and unless your the GHC Haskell compiler, you probably go for lower-hanging fruit in your compiler.
Yes, the VList is something else entirely
[removed]
&gt; Functional programming is more about the denotation of your programs, not the operation of your programs. Which is why it's a bad idea to expose the internals of such a ubiquitous data structure to functions and algorithms written in the functional language. All those functions in the standard library that take lists should take opaque instances of an ordered collection typeclass instead, and only interact with them through those functions. But we keep teaching people to pattern-match on head and tail before telling them about map and filter.
This doesn't follow. The cost of having a concrete implementation in your signature is debatable. At worst, you would have to explicitly cast your iterable to a list first. 
Why? Most of the time, when a standard library function has "List a" as an argument, all it really wants is a collection of "a"s that it can iterate through, access a particular element of, or otherwise transform in some way. There is no reason for that to be a concrete type. It does not need to pattern match on "h :: rest". So, following the principle that you should accept the loosest type you can afford to, we should not tie the fundamental functions to a specific implementation of an ordered set. &gt; At worst, you would have to explicitly cast your iterable to a list first. This is a costly operation. Say you need a large collection of things and random access is where you spend most of your time. Using a list over an array simply does not make sense, and it is silly to have to convert that array to a list to pass to a function that will anyway only iterate over all its elements.
Thank you, nice suggestion!
Ok, so we are talking about the same thing: as long as List and its operations are only defined in an implementation-agnostic way, the appropriate implementation can be swapped in (either by the programmer or the compiler). I agree that pattern matching to deconstruct a List can be treated by the compiler as an iteration, and an array can be swapped there. But I don't think that's true for list constructions, I don't see how translating a prepending constructions to an array allocation could be a decidable problem for a compiler to solve.
My point is that _despite_ the different approach to development taken in Elm, there is quite a lot of activity, so there's no way this can be assessed as a stale ecosystem. Regarding velocity and trends, I agree. Even the second derivative might be interesting, ie is the rate of growth accelerating or decelerating? On the other hand, what if the rate of package creation is going up? Does it mean that the scope of available functionality is increasing, or does it mean that more redundancy is being introduced? We won't be able to tell from velocity alone, so it's still not _that_ insightful. I'm also a bit wary of going _too_ far with metrics precisely because of deliberately different decisions about community and software development in the Elm realm that you alluded to. For example, Elm Directory, which displays a list of recently updated packages, is useful for certain kinds of research, but I don't want it to become the primary way of finding packages, because development activity isn't correlated with quality. 
It's certainly not decidable in general. But just because you can't decide the general case doesn't mean it's not an admissible optimization. Most compiler optimizations suffer from this, and a stepping outside the boundaries of the compiler's limits will cause sudden (and frustrating) degradations in performance and memory usage. This is just as true for general inlining as recognizing iteration.
Something I've thought of that wouldn't apply to Elm, but could be useful in other functional languages is a short of static linked list. The idea is that instead of storing a pointer to the tail, you'd store the tail itself. Naturally, this would require different types for the full list and its tail, but it would be able to be pattern matched like a linked list and, ideally, have the same in memory representation as an array. Instead of `data List t = [] | t :: List t`, you'd have `t =&gt; struct []` and `t l =&gt; struct t :: l`.
This will be interesting to follow. Based on responses I'd like to share my thoughts on replacing lists with a more universal version of "Array", and the implications for recursive computation: I'm strongly in favour of keeping implementation separate from interface. An opaque Array is great, and even more great would be an opaque "Sequence" type (or typeclass-like thing) that could potentially have its implementation swapped depending on usage by either the programmer or the compiler. A single sequence type would be great from a pedagogical perspective. Opaque types prevent the pattern matching and manual recursion that we have for lists, but I consider this a feature, not a bug. Pattern matching exposes implementation, which is reasonable for flat sum types but is highly questionable for recursive data types. Pattern matching on recursive types often implies you're doing manual recursion, which is like playing with pointers and GOTO in imperative languages: it's far too low level and often you're really wanting to do something that can be achieved with a map or a fold. Teaching manual recursion to beginners has the potential to encourage bad approaches and it's also another instance of a pedagogical nightmare. Manual recursion is hard. In fact, manual recursion is the only means to introduce non-termination in a well-designed functional language, and we should stamp out the possibility of using it wherever possible, including for custom recursive types. We need to make progress on language primitives in order to make this truly achievable: working with user-defined recursive data structures without using manual recursion requires things like catamorphisms, anamorphisms, and hylomorphisms etc. which are collectively known as *recursion schemes*. There's a lot of research on these primitives but (to my knowledge) we're yet to find a simple interface to them. A good interface would likely require language support. In summary, opaque collection types like Array or a hypothetical universal Sequence type are great, but to truly make them shine we need to look into better interfaces to recursive computation, such as some derivative of *recursion schemes*.
In the context that everything is immutable (like in elm), the generic Array type you want to present to your users cannot be a "simple contiguous chunk of memory". Otherwise changing 1 element in a thousands imply to copy 999 others. I suggest one of the following presentations for an overview: * [Robin H Hansen: Persistent collections: how they work and when to use them](https://youtu.be/mmiNobpx7eI) * [Juan Pedro Bolivar Puente: Postmodern immutable data structures](https://youtu.be/sPhpelUfu8Q) * [Anjana Vakil: Immutable data structures for functional JS](https://youtu.be/Wo0qiGPSV-s)
Another thought: The List data type should really be renamed Stack, since it's really only good for stack-like use cases (including linear recursion). Changing the name to Stack would make it clear to users what they can expect.
You can try to subscribe to every second only when Running. Because when you change your model in update subscriptions are updating as view as well. And while in pause it will no war cpu ticks
I didn't know this is possible! Will try it out, thanks!
Could you elaborate about how a type can be seen as fixed point?
It's actually working really easy: https://github.com/mstruebing/elmodoro/commit/cb3b9b2950cd0d3898d1f8d38061d9a8399ee848
Gonna try it on a 80k line SPA at work on Monday, looking forward to it. I'll let you how it goes!
It's a standard construction in type theory. You can ignore the point I made, but if you're curious, here's a rough sketch at the risk of being unapologetically technical. A list must be one of the following types: 1 - an empty list T - a singleton containing T T x T - a pair of T's (a product is a pair) T x T x T - a triple of T's ... etc So the type List T might be thought of as 1 + T + TxT + TxTxT + ... as a kind of formal power series. The + means "disjoint union", like the branches of a `type` declaration in Elm. This way of expressing list requires ellipses, which isn't especially precise, but it can be made precise using fixedpoints. Let F(X) be the polynomial 1 + TX. Then imagine you started stuffing F into itself: F(F(X)) = 1 + T F(X) = 1 + T(1 + X) = 1 + T + TX. And then F(F(F(X))) = 1 + T(1 + T(1 + X)) = 1 + T + T^2 + T^2 X. I could have made a mistake in the algebra, but the point is you just pretend you're in math class. The more layers of nested F's you have, the closer the resulting expression looks like List T. Lastly, you wave a little bit of something called Domain Theory at the problem, and you realize there are two solutions to the equation F(X) = X. One is the least fixedpoint of F, aka List T, and the other is a slightly different beast which we might call Stream T (which is a lazy, possibly infinite iterator of Ts). It's all good stuff. But nevermind my ranting if anything didn't make sense!
Wow, this was a genius idea. Great work.
Well, I'm one of the old guys, so perhaps that is why I don't use the new stuff.
Great explanation, thanks.
First time I used the elm debugger, I was disappointed that it wasn't more like this.
Are you saying pattern matching on recursive types is always bad, or just for lists? The reason I ask, is that I have non-list recursive types that I am using to express the unfolding of a complex computation. Obviously I need to pattern match on those or I can't write the functions I need.
Thanks for the great explanation! Definitely made me interested in reading up on type theory a little.
My proposition was that pattern matching on recursive types should be avoided where possible, yes, because it exposes implementation and mandates manual recursion. I'm not saying it's practical: as you say recursion schemes can be hard to use well. Pattern matching is often an easy solution. That's why we need to do more research into these kinds of alternate approaches.
Those who are disappointed left (like me)
Like a VList? Performance for get/set would be reduced.
If List was no longer the default type I'd agree with you completely.
I'm getting the gist that when we speak of recursion schemes you're thinking of basic transformations like map and fold? There are all kinds of wacky recursion schemes like paramorphisms and hylomorphims which give you greater flexibility in what you can compute. I'd be surprised if none of these would work for the case you're thinking of. Turing completeness is a straw man though. I've never seen a convincing argument as to how a language which does not permit general recursion would deny people from doing 99.99% of the things that they need to do. For the other 0.01% people simply need an escape hatch, like the "unsafe" keyword in Rust.
We're not discussing issues of implementation. We're talking about renaming List.
Why would you rename List to Stack when a Stack could just as easily be an array? It would be more vague. 
&gt; Is there any chance -- whether or not the next one is it -- that Elm could target Wasm directly in the future? Yes, it's been publicly announced that this is the plan in the long run. Evan even volunteered Elm as a testbed to develop wasm which may very well happen. However, wasm doesn't yet have the features Elm needs, a garbage collector and access to the DOM. So that feature isn't being worked on yet.
List could be implemented by an array. The Array data type could be implemented by an array. I encourage you to look up their implementations though: they're both primarily linked structures, because pure FP languages don't work well with flat arrays. The name of a data type should not reflect its implementation; it should reflect what it's good for. If we named according to implementation, we would have had to rename Array already, because its underlying data structure has changed from an "RRBT" to a "HAMT". Neither of these names would be better though, they'd just confuse people. In fact, Array should probably be named something like Sequence instead, because it's not implemented by an array. The name Array is really just useful as a crutch for people coming from languages that have flat arrays since it's the most suitable replacement.
Ok I thought it was called List because it actually worked like a linked list. 
Short answer, it won't happen any time soon (probably not before at least 2 years in my opinion). A bit more details: * Changing of compilation target is a huuuge work, when it happens, it will probably take more than a year. * Wasm is not ready for languages that need efficient garbage collection. Features tracking issues are available [here](http://webassembly.org/docs/future-features/). Specifically for garbage collection [here](https://github.com/WebAssembly/design/issues/1079). * Elm development is [public](https://github.com/elm-lang) and it is not focused wasm for now. Elm 0.19 is focused on [asset management](https://github.com/elm-lang/projects/blob/master/roadmap.md#how-do-i-make-a-single-page-app). Wasm is still an interest and exploration by documentation [is encouraged](https://github.com/elm-lang/projects#explore-webassembly).
Another interesting case arises when you put a single-constructor union type into its own module. This allows you to expose the type itself but not its constructor, which is really useful if you want to put constraints on how that type is constructed. For example, you might want to disallow the empty string as a username. With a type alias, the empty string would be completely valid: type alias UserName = String userName : UserName userName = "" But we can disallow that by putting the union type into its own module, and expose something like a `fromString` function to construct a username from a string if it is not empty: module UserName exposing (UserName, fromString) import String type UserName = UserName String fromString : String -&gt; Maybe UserName fromString str = if String.isEmpty str then Nothing else Just (UserName str) This allows people to use `UserName` in type signatures in other files like: createUser : UserName -&gt; Password -&gt; User But only construct usernames by using the `UserName.fromString` function (forcing them to deal with the case of `Nothing`)
&gt; Or do I misunderstand something fundamental? Elm has `wasm` as a potential target but work on that cannot truly start yet without someone willing to waste a lot of time on something that will be thrown away. Evan has enough on his plate and has other priorities for the time being. The fundamental thing that you are missing is that Elm is am managed language. This means that in order for Elm to compile to wasm, there are two options: 1. Implement a garbage collector. This is potentially a lot of work and will bring with it a considerable extra piece of code that would have to be included in every program compiled to wasm, probably removing any size reduction advantages of wasm. Implementing a performant GC is also not a trivial thing and since memory management is such a performance sensitive topic, the performance of Elm + naive GC on wasm could be less than the current performance. There is also the penalty of calling DOM from wasm. 2. wasm provides a high performance GC with no penalty for calling the DOM. All the above issues disappears as since the GC is provided by the wasm machine, it would not have to be shipped with the compiled code and since it would be highly optimized, it will be at least as fast as current JS. The second road is what I think will be the road for Elm. This means that we have to wait for the browsers to implement a wasm version with GC. I think Elm is among the languages that are being considered for optimization on this official wasm GC. There was a call for functional language examples, Evan proposed Elm and it received a lot of support. So, now we wait for the first GC proposal. 
I am structuring my app off the [elm-spa-example](https://github.com/rtfeldman/elm-spa-example). I have a page, with an init function: init : String -&gt; Task PageLoadError Model It calls out to an API to retrieve the model. I then want to render a chart via a port function: port plot : ( Show, ChartOptions ) -&gt; Cmd msg How do I go about doing this? Where do I call plot?
i really really doubt that js will fade to irrelevance pretty quickly.
Sounds great! Please do!
&gt; Another way I might try is to add a build step for a debug build that patches the Platform.js and my index.html so that I don't accidentally leave those changes in production. Feel free to open an issue if you succeed with this! If there's an easier to way to add this integration in development, I'd love to add the instructions to the README!
That was bloody fascinating.
Great demonstration of the library! I kept wondering if there was a cleaner way to implement the rules. This is my attempt: https://ellie-app.com/cZmxDGnPma1/0 I am not quite satisfied with how the farmer crossing alone is handled. I also had to lower type safety because Elm does not support comparable user-defined types.
Very cool!
I may have some good news for you :) http://package.elm-lang.org/packages/eeue56/elm-all-dict/2.0.1/EveryDict
Hi! &gt; What is a good drag and drop library? You can follow [this example for drag &amp; drop implemented in Elm](http://elm-lang.org/examples/drag). Alternatively, you could try to [leverage HTML5 drag &amp; drop](https://medium.com/elm-shorts/html5-drag-and-drop-in-elm-88d149d3558f). Personally, I haven't tried this yet and it does come with some caveats, but the implementation should be easier. &gt; How do you determine if a package is healthy on package.elm-lang.org? Best to look at its github page - commits, issues, PRs... &gt; Whats the best way to make a sidebar intended to fill a side of the screen at all time, should I style the elements within elm or should I make a separate style-sheet and import it in .html or .js? If you want something close to regular CSS, have a look at [elm-css](http://package.elm-lang.org/packages/rtfeldman/elm-css/latest). I prefer to use (style-elements)[http://package.elm-lang.org/packages/mdgriffith/style-elements/latest], which is a bit more powerful, but it's also going to change more frequently. For starting a new project, I would recommend [create-elm-app](https://github.com/halfzebra/create-elm-app), which gives you a nice starter template, which includes elm-css, webpack and more. Good luck :)
If you're not already used to html + css styling, I'd also vote for the style-elements library. Layout feels more natural with it.
In your Main `setRoute`, if you are following the elm-spa-example, you will be performing the Task such that it calls back Main.update with a `MyPageLoaded` msg. In the elm-spa-example, all such branches return a `Cmd.none` (see for example https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L344-L345). But there's no reason you couldn't port out at this point.
So after it's loaded, I should return a `MyPageMessage a` message like `RenderChart` or something similar? I think I tried that, but I couldn't figure it out.
Go ahead, but Evan isn't just doing nothing. There are hard problems to solve, both technical and pragmatic, that Evan is working on. You might be able to solve them better, but remember that code is the easy part. Elm is not the only Functional JS language out there. Its success is due to its philosophy, and that involves a degree of conservatism.
That's useful!
No, the 'wacky' ones give you stuff like folds, unfolds: https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29 I'm talking about when you have an abstract syntax tree, and you need to pattern match on its constructors, because you need to compute quite different results for each, and also to recurse into sub-expressions. There isn't a way to generalise this because the function does not follow a regular pattern that can be summed up by a simpler generalisation. Maybe I need to show some code to explain what I mean.
I absolutely second create-elm-app. It's a good setup, especially for someone not versed in Webpack and such.
I am working on a Sokoban game. Prototype: elm-sokoban.lieberkind.io (works best on desktop, but should be playable on mobile) Source: github.com/lieberkind/sokoban The code is a little messy, as I'm struggling with figuring out a good structure. Some things I am currently unhappy with: - The Main.elm file seems bloated when I compare it to other Elm apps - The way the player is animated is handled in JavaScript, I would like to move this to Elm (using a `Time.every` subscription?) to switch between its four states. It doesn't feel right to me to put it in the "top-level" state - The `move` function in `Data.Level` is long and complex, but it's probably the function I've spent the most time refactoring, and it has been in a much worse state than it is currently - The general file structure seems a bit messy still Would love feedback and critique!
Hey, I can't say I have any answers, but I think this question would garner lots of discussion in the discourse.elm-lang.org forums! 
Thanks, was planning to post there too. Good call!
Tried to get Elm at my company. The other web devs were turned off by the lack of HTML templates. So be prepared for that. Do your homework on Elm's usage stats. Somebody will argue React or NG2 or something because everyone's using those. Elm can beat those in terms of productivity post-learning-curve. Sell the features of Elm. I believe they are superior.
Fortunately the one SPA they are currently building is in React, so they are are already on board with HTML in JavaScript üëçüèº
I would wait 0.19 first. What do you mean with "supporting non-deferred Cmds"?
Well, the more "traditional" Elm Architecture signature for page init would be `init : String -&gt; (Model, Cmd Msg)`. This gives your pages more responsibility and 'modularity'. So you could do your API call and then the port plot call right there. But, it means you will need to `Cmd.map` the result in Main `update` and `init`: a bit more boilerplate. The elm-spa-example favors having Main be responsible for creating and handling Cmds, not individual page modules. So in that setup, it does make sense to call a port function in Main, not in the individual page init. 
Currently working on learning Elm and building CRUDish web app using it with GraphQL.
I loved this! Good work!
It's gonna be a hard sell. Most devs/engineers I've worked with don't like having to learn something new, and manager types don't like using tech they're going to have trouble hiring for. I think you'd have better luck getting on board with using React + Redux with functional components. 
It can be a tough sell, especially if you are the new guy. I think much of it will come down to your personality and how good you are at persuading people. I guess there might be a lot of value in getting them to at least try Elm on a mini-project, or a hackathon first, otherwise they feel that their happy status quo is threatened. Good luck. I am an enterprise architect, and it is within my power to tell the developers that they must use Elm. Even then, with my current project I am letting them use Angular because otherwise their will be an almighty wailing and gnashing of teeth. The devs using Angular are very good at it though, and can churn our projects fast so long as they are happy. I know Elm 0.18 is good enough for production, but I also find it hard to make a justification of that on paper, when all factors and other choices are taken into consideration.
I might have said that wrong. Asked on the Elm discourse, I‚Äôll update when I have an answer.
Apparently hiring for Elm developement is easy, at least in Paris. My guess is there are more devs knowing, learning or interested in Elm than job offers. It's all a question of demand and offer.
I work in an Elm team, and for me personally, the biggest hurdle was the steep learning curve: I've never used a purely functional language before, so adapting to this new approach took some time. I learned the ropes since then and I like the language, but I imagine this could be an obstacle. Another big thing is tooling: debugging elm can be trickier, since as far as I know, no tool allows you to place breakpoints, so you have to use a different approach. The "no runtime exceptions" tagline is a big selling point \(it adds a lot to code quality, especially when you compare it to a lot of the JS code you can find\), but accessing various APIs and libraries through ports might feel like a huge hassle to some people, especially if they're already used to some more traditional and flexible technology. 
I think with what's currently going on around JavaScript interop it is clear that Elm is not (intended to be) ready for real-world usage yet. In the real world, you need escape hatches to iterate quickly or to integrate with existing systems. The Elm team rejects these practical solutions for ideological reasons. My personal conclusion is that, at the current stage, other languages and frameworks are better suited to real-life projects, i.e. anything but personal experiments.
Hi. I've worked in three different companies now using Elm in production, and consulted on many more. In the majority of cases, the biggest selling factor of Elm is the developer experience coupled with the safety and reliability of Elm. In fact, a few Scandinavian websites in Norway and Sweden are both now using Elm-powered pages. You can read about it here: https://discourse.elm-lang.org/t/scandinavian-news-in-elm/256/ Elm definitely is ready to be used in production. However, I've been involved in Elm for a long time and know a lot of tricks to unblock myself. The community on Slack is both welcoming and helpful -- anything that you might run into, people will be able to offer advice or help you out with. Best of luck!
Thanks! I‚Äôve certainly noticed you have quite a bit of experience, I‚Äôve seen your name around a lot. Have you found anything in Elm that you simply can‚Äôt do but could in JS? I‚Äôve heard that certain events have properties that are only available within the same run loop tick (ie. The data property on drag events) and are impossible to extract without native code (although it occurs to me it might be possible with a web component).
There are some things that I choose to do in JS because it's simpler -- such as dealing with google maps, but I've never had a problem integrating such things with Elm. Watch these two: [How to unblock yourself with Elm](https://www.youtube.com/watch?v=OgH3pPXXSkY) and [Everything in Elm](https://www.youtube.com/watch?v=FUHlnxQJTMM) where I talk about these things a bit more.
Hi, Nice work! I see some problems with saving and loading stored items: * there seems to be some id-collisions when adding new items when there are already stored items (multiple items gets checked when only one should be toggled). Either you need to fix the seeding, or just use an incremental ID (that's what I would do). * if you use the "clear completed"-button, the change does not seem affect localstorage, so when you reload the cleared items pops up again A couple of thoughts, regarding code-style: `allCompleted` can be rewritten as `allCompleted = List.all .completed` I think you should take a look at `ToggleAll`. The entire else-clause can be simplified a bit. Basically, you are just toggling the .completed-field, so you should be able to do something like this: toggled = if allCompleted model.todos then List.map (\todo -&gt; { todo | completed = False }) model.todos else List.map (\todo -&gt; { todo | completed = not todo.completed }) model.todos Regarding the use of `flip`, I'd avoid using it like you did - to reorder the arguments for the sake of clarity. It's useful in some cases where you would need to pass the function to another function (like List.foldr and such), or when needed to use function composition properly. If the lambda function gets too big, I think it may be better to separate the lambda to a named function instead.
Fortunately, this team has never done UI at all, so no matter what we end up with they will have to learn something. That said, I understand that the learning curve is much higher with Elm than anything else. It's all tradeoffs.
I'm being hired as a "UI Architect", and it sounds like I might have similar "powers". However, I feel like dictating to a team is a recipe for disaster and unhappiness, hence the reason I'm doing this research beforehand.
I agree.
Having the only european Elm conference in Paris probably also helps :)
[removed]
I think escape hatches should be there for when you _really need_ them, not to meet deadlines. For instance OCaml/Reason has them for when you just need to make an algorithm more performant, sometimes it's easier to mutate state. However, it makes it kind of ugly and hard to use and out of the way so you're discouraged to use it. Just like how react's `dangerouslySetInnerHTML` requires an object that looks like this: {__html: '&lt;div&gt;htmlGoesHere'&lt;/div&gt;}`, rather than just a `string`. All that said I think Elm covers the 90% case really well. If you _really_ look at it, most of what people do is: HTTP requests and view transitions (changing pages, opening models, etc...) Elm does really well with these things. It's when you want to get crazy and deal with the less than ideal DOM APIs that it get's less nice. It's nice in React to use a nicely abstracted, yet side-effecting, thing like good drag and drop libraries, virtual lists, etc... Elm is an amazing fit if you really can't tolerate errors (or just don't want to). It's also got amazing tooling compared to JS.
&gt; I think with what's currently going on around JavaScript interop it is clear that Elm is not (intended to be) ready for real-world usage yet. There are too many [Elm in production success stories](https://www.google.com/search?q=elm+in+production) for this to be a defensible claim. We get it: you disagree with Elm's design decisions. Please don't condescend to those of us who have happily used Elm in the real world to tell us what we "need" according to your personal preferences.
Nit pick: RRBT/HAMT is implemented by an array. An array which can contain other arrays (aka a tree of arrays).
Fair. Elm is very pleasant to use. If the requirements of your project match Elm's capabilities, it may be a good fit for a real-world project. Nonetheless it's worth noting that the choice of Elm imposes significant constraints on your team. Many real-life tasks become difficult or impossible, including integration with an existing JavaScript code base, using existing widgets (e.g. a rich text editor), use of algorithmic libraries (e.g. crypotography), alternative platforms (PWA, native apps, Electron, Node), integration with 3rd party JavaScript libraries (e.g. analytics), use of the Browser's multimedia APIs, integrating with FileReader, upcoming Web Platform APIs, and parts of the existing Web Platform APIs not currently supported by Elm. My point is that currently Elm is a good fit only if you know your business needs don't include these requirements in the foreseeable future or you have the luxury of waiting until the author of Elm adds support.
&gt; Many real-life tasks become difficult or impossible I mean, are they harder than in JS where no interop is necessary? Sure. I've heard of people doing all the things you listed, though, and aside from alternative platforms (which Elm explicitly doesn't target yet - fair enough) I haven't heard of people finding it *impossible* to build what they needed via ports, custom elements, pplyfills, etc.
Damn. Where was this 2 weeks ago :D Well done, looks great
Thanks!
This reminds me of Python's list, which goes to great lengths to perform faster than Python code in all cases. I think it is a good idea because it would remove the burden of selecting between List and Array. Deconstructing wouldn't work anymore, but fold is better in Elm anyway because it is not limited by stack height. For implementing data structures, however, List is great. Array has too much overhead for that. List could also benefit from advanced compiler optimizations in the future, unlike a convoluted version of Array.
Nice!
Elm‚Äôs List is a Linked List, so it really isn‚Äôt that great for building other datastructures (other than a bankers queue). I also cannot think of any optimization which would benefit the list instead of the Array, but I‚Äôd be happy to be proven wrong :)
Really nice article. Well done op.
Thank you for this
Thank you for this
What would the rfeldman elm-spa-application look like if it was built using graphql? I'm not too familiar with graphql but it occurs to me lately that as I build an app based on the elm-spa-application architecture that as my user navigates through various "Pages" each page navigation causes a request. My app is different in that I'm not concerned about constantly fetching the latest data from the backend because only the current user could be updating it. It occurs to me that maybe instead of loading data as my user navigates through my app I would rather load the entire application state once at the beginning and maybe if the user elects to click sync. Is this what graphql is designed to facilitate? Could you load an entire application state with the mother of all graphql queries plus some ungodly elm decoder? What's ridiculous about this idea?
Yes. You can define it in two lines and most common functions can be defined in 3.
Nice! To me this is just fun to do :) Not entirely sure about the problem with the id:s, I didn't really look closely at what happened there, but I did notice some strange things happening and took a guess. Here's one way to do it with incremental id:s anyway: https://ellie-app.com/6LfpzzpwYa1/0 The interesting part happens in the init-function (and of course, loadItems and addItem) The id:s are not preserved here (didn't see the need to do that), but you can of course do that if you wish. You should be able to do that just by changing the addItem function in my example, but I'll leave that as an exercise ;)
[removed]
The JS parts of Array are still pure, so I don‚Äôt see why that would be problamatic.
[removed]
What foreign function? It‚Äôs all javascript to the javascript vm.
One could adapt `elm-spa-example` to using GraphQL without having too big of an impact on the source code. Using GraphQL would not mean that the app needs to look very different. &gt; Could you load an entire application state with the mother of all graphql queries plus some ungodly elm decoder? Yes. This would require using a slightly different pattern than the one in `elm-spa-example`. This would be an extension of `elm-taco` where you keep a cache of the DB data in the `taco`. All requests would then ensure that the cache is updated. Please be aware that this has advantages and disadvantages. Cache invalidation is one of the two hard problems of programming (together with naming things and off-by-one errors). 
Thanks! I'm going to try that strategy out üôÇ
Ah, we were talking about different things. I meant optimizations to the Elm AST. The VM has to add overhead when performing similar optimizations, because it can only speculate about the properties of the code, while Elm knows the types.
The Elm compiler could treat Array as a special black-box data type if it becomes the default list implementation. I would be surprised it it wouldn't (eventually). So optimizations would be written specifically for it.
I've been working on my first web app, I released it today. It's a visualization of the night sky at a given time and place, and a name gets written in the stars as constellations. [the source code is here](https://github.com/jiegillet/sky-writer) and [the app is here](https://jiegillet.github.io/sky-writer/). I originally wrote it for some colleagues for [White Day](https://en.wikipedia.org/wiki/White_Day) (with 2 weeks delay) although it's not especially related. I'd love to have some feedback :)
Yes, credentials/secrets should not be part of source control. But IMO it is very practical to have things like ApiUrls as part of source control. Especially if they differ from local development to production.
I second that!
Join the Elm community on slack... the #beginners channel is very active and helpful https://elmlang.herokuapp.com/
I think I see where the confusion is. By definition, an SPA has the routing logic on the front-end. That means that if you don't want an SPA, then you don't put the routing logic in Elm. Elm is for front-end only. You want to create a separate Elm app for each page, and do the routing in the back end.
Ah I see. Well, technically it could be an SPA if elm keeps track of the initial page. I set up `programFlags` for that. However, each page would still need a way to get the underlying JSON data from the backend.
Thanks. I‚Äôll check this out!
Use the HTTP module to make requests to your server to get the JSON you need for the page. You can hook this up to your URL changed message to grab the data when the page link is clicked. 
The cleanest way to sepate your front-end and your backend is to serve your backend from a different subdomain. Like `api.yourdomain.com`. It will also help you when you decide that your front and your back won't be served from the same machine at all. You could for instance decide to put your frontend directly in a CDN with for instance [Netlify](https://www.netlify.com/).
I think this qualifies: https://github.com/bgourlie/rs-nes-debugger-frontend
Thanks, this was really helpful! Regarding websockets, how would you recommend setting up sending a websocket msg depending on the page loaded? Like `home` might not send anything, but `/commands` would send a message with `"commands"` to the websocket.
Diwata a db interface https://github.com/ivanceras/diwata ~10k lines of code
I'd be interested in specifically seeing how the complex Elm projects deal with disparate components having to use TEA which requires a global model and update mechanism. Also it'd be interesting to see the result of `elm-format` on these projects. Just found [this](https://github.com/ivanceras/diwata/blob/master/webclient/src/Page/WindowArena.elm); is this a good representation of `elm-format`'s output?
https://github.com/prikhi/bodyweight-client https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes
I want to get the path of a file the user can pick via a dialog. Currently stuck on: - How to open a FilePicker on Button Click? - How to get the path of the selected file? Web Development, Elm and FP noob here, so sorry if this is something extremely simple. I was looking for a kinda "FilePicker"/"FileChooser" dialog, which I can spawn upon a button press and then get the path of the selected file, but I could not find it. 
for input of type file - you can use ports but you need to convert blob to base64 https://www.paramander.com/blog/using-ports-to-deal-with-files-in-elm-0-17 - or use native which won't be available in 0.19 https://github.com/simonh1000/file-reader If you need to handle bigger files, use native and don't upgrade to 0.19 when it comes until there will be support for this Web API.
Hello! Thanks for the reply. I tied the file-reader package and it seems _just_ as what I need....but I seems it only let me _read_ files? I do *not* need the content of the file, only it's absolute path! Unfortunately, it does not seems that the package exposes the path.
It's just JavaScript in the end, so putting the setup code into a separate file and not in an inline &lt;script&gt; should do the job, depends on your CSP settings, of course.
Only temporary path can be obtained https://stackoverflow.com/questions/15201071/how-to-get-full-path-of-selected-file-on-change-of-input-type-file-using-jav/24818245#24818245 Or in IE8 but with specific settings https://stackoverflow.com/questions/3489133/full-path-from-file-input-using-jquery/3489167#3489167 
IME `Debug.crash` is special in that it compiles even if you invoke them with the wrong arity. It just doesn't work. Similarly `Debug.log` does nothing in practice if you only pass in one parameter. This is probably a corner case that the compiler doesn't catch. These two functions are the only (?) side-effecting functions in Elm's standard library. As to why `crash` and `log` have different signatures, I don't know.
Remove the `err`. `Debug.crash : String -&gt; a`, I'm guessing it infers `a` as `Error -&gt; Model` (or there's a special case in which `Debug.crash` always typechecks as long as it gets a String parameter). Either way the `Err` parameter is simply ignored.
There's https://wonktonk.com. The source code isn't open source but I'd be happy to discuss
The type of `Debug.crash "sasa"` is `a`. This means it can be anything, e.g `Int`, `String` or even `String -&gt; Maybe Int`. This is why it works no matter how many arguments you pass. Consider this example: 1 + Debug.crash "" "" -&gt; compiler infers (Debug.crash "" "" :: Int) -&gt; this means (Debug.crash "" :: String -&gt; Int) -&gt; Debug.crash :: String -&gt; (String -&gt; Int) == String -&gt; String -&gt; Int == a Hope this helps.
&gt; If you configure the policy well enough to allow ELM to run and perform all/any external requests there should be nothing preventing you. Sure. You're weaselling yourself out the question. "If you do it well enough it'll work" is a trivial statement to make. It depends on Elm in that CSPs can forbid eval statements. So does the Elm runtime use eval? What is the tightest CSP you can make to run an Elm app successfully still?
I presume that means the second argument is ignored
I was able to get very strict one working with vanilla Elm and Elm packages, it was the JS libraries we rely on that made it more difficult. You should be able to be as restrictive as you want to be assuming you have full control of your JS dependencies. I didn't need nonces on any script tags, but it can be done by server rendering your HTML, I would try to stay all in Elm though. If you want to be restictive on inline styles as well you can do it, but external stylesheets are probably the easier route. We had medium sized codebase already so I didn't plan on disabling inline styling. We didn't use elm-css so I can't speak to integrating that.
Yep, that file i representative of `elm-format`. I would guess that most of the open source elm code out there uses it. If you want to play around with it live, ellie has a "Format" button. https://ellie-app.com/new
Yes. The second argument is evaluated, but the result is ignored. Then it crashes with the string passed as the first value.
Hey i made some but, :D it's not done and it's not perfect. Also a Doc is not so good. I made it for my CS studies as a project. https://github.com/jankowskirobert/Trollo-Front
Did some more coding on this http://martincapodici.com/elm/elm-budget/index.html. Feel free to play but don't put any important or confidential data there as security still needs to be tested, plus I might blank out the DB.
This is really fantastic, thanks for posting it. I hadn't thought of extensible records as inheritance but you're 100% right, it explains all the difficulty I've had with them. The `toEntity` pattern seems a much cleaner idea here. Looking through the source code I also really liked the way you separated out the `IntroState`, `PlacementState` and `GameState`. In these situations I've always used a single state record with maybes. Your approach really nails that whole "make impossible states impossible" thing.
Hello, I'm following the book/website/tutorial: http://elmprogramming.com/restructuring-code.html and I'm facing an error in my program: ``` I found multiple modules named 'List'. Module 'Types' is trying to import it. Modules with that name were found in the following locations: directory ./PostApp/Views/List.elm package elm-lang/core ``` How does the import system works? And how should I fix the error? Thanks
So this is something I've been working on for the last 2 months on and off. It details the last 10 months of working in Elm full time. The purpose is to share our technical roadblocks and show how we overcame some of these. It's really a blog post that got wayyyy too big in the making... hope you enjoy!
&gt; What was the motivation for writing it up? Purely what I said in the intro, I wish there was more long form discussions of technical challenges people were facing. As a consequence, summarising my learnings helped me gather my thoughts and I think I'm ready to tackle forms again. hehe &gt; Did you have to convince your company? I ran the draft by my manager a couple of weeks ago, he was ok with it. The screenshots and code samples are either contrived or non specific to the business. &gt; tone which came over as aggressive to me in some places If you can highlight them either in the book or here, I'd be happy to look over that area and tone it down a bit. There was a lot of frustrations in the refactoring section. Perhaps that came through? &gt; How do you currently handle forms? Badly. :D Approach 1 in the forms section is how we're doing it (https://mordrax.gitbooks.io/elm-at-phd/content/chapters/forms.html#approach-1-forms-manager-module). 
One workaround / fix I found was to remove the PostApp/Views from the source-directories. I don't think elm should search directly in this directory. If you have any more material/links to guide me, I'm taking them. Thank you
Cyclic graph - how to add edge? https://ellie-app.com/fgKhcxx4Qa1/0
Looking forward to reading this! Great idea. Amen to more long form discussions of real world technical challenges. 
I use Rust in production, and soon will use Elm in production as well. Love them individually, and together. For writing the Elm decoder/encoder boilerplate, I now use https://app.quicktype.io/#l=elm, which is very impressive.
Awesome read, thanks a lot for this! In "Compile" section, I did not understand this, can you explain please or show a snippet? "This is how it looked after I removed Quotes from the Person/Membership models and passed it into functions that required it."
So initially we have 15 views, and each of them needs to import the Membership model. Then the membership model imports the Quote. But only _one_ of those views actually need Quote. So instead of Membership importing Quote and holding it inside, the function in the single view that needs it is passed Membership _and_ Quote separately. This way, Quote is only depended on by one module and incurs less module recompiles where as previously, it was imported by Membership and thus by 15 views. Hope that cleared it up?
Yes to both actually! At the time, we really didn't have the resources to do this change. So we hacked around it ( elm-hack.sh ). But this is the essence of decoupling. In this way, Membership no longer depends on Quotes. They are two separate entities that just happen to be required by a third module. So you definitely want to do this regardless of the compile time implications because the longer term implication is your architecture will become more and more coupled until you end up with a state that models your UI and you start hitting dependency loops everywhere!
 genderDropdown : Lookup -&gt; Int -&gt; (Int -&gt; msg) -&gt; Html msg You lost me here. What is `Lookup`?
Ah, I thought I'd removed those... the glossary terms doesn't pick up on code indents. &gt; A record containing all static domain data such as enums, insurance products, users etc... which are downloaded at login. Lookup is useful for displaying friendly string representations of ids and such for dropdown selections and business data. https://mordrax.gitbooks.io/elm-at-phd/content/GLOSSARY.html#lookup
This was a great read, thanks a lot for taking the time to write it up!
There was a whole bunch of ppl that gave their time to help me, I'm just trying to give what I can back. Hope it gave you some ideas for your projects!
Nice. Thanks for writing this up. I think these topics are standard stuff for people familiar with functional programming but it's *great* to have it all documented in an easy to consume way like this. What I think would have helped me more is more fleshed-out code examples rather than just function annotations. Maybe more code featured in your module breakdown? Your app sounds very interesting.
As part of Strange Loop?
&gt; We are returning as a Strange Loop pre-conference event, and attendees are welcome at the Strange Loop party at City Museum during the evening of the 26th. ^Looks like it. This is a good thing, by the way... it's a great excuse to attend one of the best dev conferences around, IMO!
yep, on the preconference day :)
Still working on budget app http://martincapodici.com/elm/elm-budget/index.html. Feel free to sign up. No email confirmation is required. I've got use to Elm and set up most of my 'architecture' involving talking to Parse, pop-ups etc. so most of my time now is on non-Elm issues, like how to design an efficient mobile interface. What features I need to add next. I feel that now I have the swing of things Elm is a very efficient language to work in and I haven't been back to fix bugs on older features, which is a 'feature' of raw JS development that I am quite use to. I am still considering whether to open source this so bear with me on that. If this gets good enough that I'm happy for people to use it, I'd like to offer a very decent free plan for everyone anyway, and in that case I might as well open source it. 
There aren't that many cities named "St. Louis" on this planet
I'm an amateur actor, and with my friends, we need to learn a play. I'm setting up a very simple form to ask the next sentence you should say. But I'll need to write a new ELM library to give me the similarity between two strings. So I'm currently looking at the algorithm like the trigram, but slightly modified.
Nice :) I think you can avoid the CellWrapper type alias by directly encoding the pairs that come out of Dict.toList. Example here: [https://ellie-app.com/kV9MFJ6CYa1/1](https://ellie-app.com/kV9MFJ6CYa1/1)
Also, assuming you want the board to be a grid of size MxN with no missing cells, using a Dict with cell co-ordinates as the keys as the data structure for allows the representation of a board that should be impossible (eg. a Dict whose keys are [(0,0), (50, -1)] is ridiculous, but possible to represent!). A possibly better way of representing your data is to make a Board module that exposes a Board type but not its constructor (this is an opaque type, see [here](https://medium.com/@ckoster22/advanced-types-in-elm-opaque-types-ec5ec3b84ed2) for more info), and a 'create' function that returns a Board. This way, you can make sure that certain constraints (for example that a Board always has MxN elements) about the Board type are always enforced, just by making sure that none of the functions exposed from the Board module violate those constraints! Here is an example of such a module: [https://pastebin.com/BBPMSuqz](https://pastebin.com/BBPMSuqz)
There aren't many cities called "Sydney", but nonetheless https://www.smh.com.au/news/travel/tourist-ends-up-in-the-wrong-sydney/2008/09/25/1222217366682.html
I've looking at making a more involved SPA in Elm for a long time, and so I finally started something the past couple of days. For now it's simply a dynamic movie search using the TMDB api, but I was looking into using separate APIs to immediately find availability on various torrent site. But I'm concerned about the legality of putting such a code on github. The repository for this project is available here: https://github.com/flupe/movie-explorer
Hey, I'm currently working on a form library for Elm. My team has been using it for quite awhile in production and we are really happy with it. Open-sourcing it has been in my backlog for awhile, but your post has motivated me to work on it, publish a draft of the API with some examples and ask for feedback. I will hopefully have something to share later today.
I got myself into a week of pain early on. Had to abandon a few PRs hours into them because I got to a point where I could not continue (I didn't talk about the 100+ module dependency loop I hit, coupling makes the modules so highly dependant on each other that most changes to module imports will cause huge loops). That's what inspired me to think about strategies for refactoring large codebases and lead to the method in the article. That ordering puts decoupling Msg and Model on step 3, which is the first step outside of a single module refactor. ie it's the first step to unraveling inter-module dependencies and it's important to start at the leaf nodes. Personally, if that was in js, without tests and with a similar level of coding, it would have been much less effort to just rewrite it. Of course, I'd have lost the job in that situation or just walked away. Another thing I didn't mention in the article is that the Elm project only existed because they previously had a _team_ of consultants who spent months to make a angular version which was deemed so buggy it never saw the light of day. But I don't have a good answer to js refactoring other than have a cr*p load of tests and be in good standing with your deity.
Hi. Thx for review. I'll continue next week. 
I have read the book-in-progress https://www.manning.com/books/elm-in-action, and found it quite useful (especially tricky stuff around requestAnimationFrame and functional state of mind) The remaining chapters should be quite interesting, especially the SPA example which will probably help understand the very elaborate architecture designed here : https://github.com/rtfeldman/elm-spa-example Do pay attention to the estimated date of completion which is quite far, it might not fit with your timing (although I said the already published chapters are quite useful). But I have not read any of the other books on Elm.
I agree here. Try to find an alternative data model before diving into `Dict` like you would in other languages. Dictionaries in Elm are unwieldy (leading to blog posts like this) for a reason - there are often better ways to achieve what you are trying to achieve.
"Elm in Action" is great, although still in progress. I have it and I recommend it.
I'm commenting here because gitbooks was not letting me add comments with my GitHub account. What do you mean by "Opaque"? i.e. opaque Msg and Model... this is still not clear to me. 
I liked the incremental approach of the book. You do a thing and you refactor it into a better thing in the next chapter based on what you learned.
Interesting, maybe that's why not many ppl have been starting discussions. Crap! Opaque model/msg is when you expose only the type but not it's internal workings eg: type alias Login = { ... } type Msg = Success | Fail String | ... -- opaque module Login exposing (Login, Msg) -- transparent? module Login exposing (Login(..), Msg(..)) With opaque types, you cannot reference any fields or values in the module importing this one. If you google for "elm opaque types" you'll get a good idea of how they are used. 
Thanks for the PSA. Wonder if this is on the radar for future releases of Elm.
Is elm pure functional programming? Does it have a state?
I don't think this is possible in a nice way at the moment, unfortunately. The only way I could do smth like this when I wanted to archive extensibility was wrapping all of the public API's and library-declared types into another layer of types and functions that's application specific. So you'd have a type MyFormField = LibraryField FormField | CustomField1 ... | CustomField2... and myViewField : MyFormField -&gt; Html Msg myViewField myField = case myField of LibraryField formField -&gt; viewField formField CustomField1 cf -&gt; viewCustomfield1 cf ... Another way is to put field-specific handler like viewField *inside* your field's record, but when you put those in the global store\model - you're breaking the "don't put functions inside your model" rule :\
My pet project is a simple webapp to memorize the verb forms of Maltese language: https://github.com/pietro909/maltese-verb-forms I've just finished the roots and markers highlight, next step is to make the UI fancier :-)
Thanks /u/handbagstevens for the suggestions with working code.
No probs :)
I'm wondering, wouldn't you be able to solve this infinitely recursive data type by simply changing the way you model it? I'm thinking something along the lines of: type PlanNode = PlanNode { nodeType: String } | RecursivePlan { nodeType: String , plans: List PlanNode } This way you could also differentiate between nodes that have an empty list of sub plans as opposed to no sub plans. Since this seems to be the way the JSON is structured, it seems sensible to replicate this in the way you model it. Hope this helps! :-)
Glad you brought up this topic. I started the project with http://package.elm-lang.org/packages/eeue56/elm-flat-matrix/, but I needed to get cell co-ordinates from the "Cell" which seemed difficult, the only option I could think of was storing the co-ordinates in "Cell" itself. With Dict all I had to do was find it's key.
My specularion is that they may have less established institutions, and a younger industry open to new ideas. I've noticed forward thinkers there in other industries too.
Hello, I have this union type: type Color = Red | Blue | Green | Yellow | Orange | Pink The user can choose as many colors as he/she wants, but there can't be duplicated colors in the selection. How can I model that selection? I was thinking about using `Set` from the core package, but it only allows *comparable* values. Is there a better way of modeling this in Elm? Should I implement my own Set, or is there a popular library for this sort of thing? 
This answer isn't specific to your example here, but it might help anyway. The way you usually solve this is by passing in a `Config` record with functions in it. If you haven't seen this yet, definitely check out [Evans sortable table library](http://package.elm-lang.org/packages/evancz/elm-sortable-table/latest). The readme contains some more good tips on API design. You see this pattern pretty much everywhere in Elm when you need a lot of flexibility. Sometimes the configuration functions are hidden behind a custom type, but at the core those also work very similar (example for that approach can be seen in [the Generator type](http://package.elm-lang.org/packages/mgold/elm-random-pcg/latest), [Json decoders](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode) or [parser combinators](http://package.elm-lang.org/packages/elm-tools/parser/latest))
&gt; I'd have to duplicate them if I used a union type like this. This is where extensible records really shine! :D type alias NodeContent a = { a | nodeType : String, other : Int, isSomething : Bool } type PlanNode = PlanNode (NodeContent {}) | RecursivePlan (NodeContent { plans: List PlanNode})
Ah, but they don't work with JSON decoders because extensible records don't get constructors generated for them. 
1011
[AllDict](http://package.elm-lang.org/packages/eeue56/elm-all-dict/latest) ? 
persistent data structures are implemented as trees including Array and List and Dict in Elm.
thanks!
Elm-flat-matrix looks more or less like what you need actually! You can use the toIndexedArray function to get a list of tuples where the first element is the cell coordinates, and the second element is the cell data. One very minor complaint about that package is that the Matrix data type that's exported isn't opaque, so it's up to you to remember to not screw up its internals.
Thanks, I didn't know about this. I'll definitely check that out, it seems like a way to go.
https://www.linkedin.com/pulse/single-page-web-apps-elm-part-four-side-effects-kevin-greene
Have you compared notes with /u/mordraxx? This person recently posted a [detailed writeup](https://www.reddit.com/r/elm/comments/8anvrz/elm_at_pacific_health_dynamics/) on building a large app in Elm. According to the writeup, after trying three or four different approaches for forms, none of them worked out too well. A takeaway was that forms are still an open question, with no good solution, so I'd be curious how your approach compares.
Sure, that's why I think it's hard to do in a nice way :) `Config` approach can work, but it has it's limitations. Library author cannot foresee all of the possible use cases you might have as a user of the library. Some important *extension points* could be missing and hard to work around. Evan's sortable table library has a good point on this in docs in "crazy customization" section: &gt; **Crazy Customization** &gt; If you are new to this library, you can probably stop reading here. After this point are a &gt; bunch of ways to customize your table further. If it does not provide what you need, you &gt; may just want to write a custom table yourself. It is not that crazy. In my experience, any library has a flexibility limit. If you've designed it with one set of requirements in mind, any other person with another set of requirements might have really hard time trying to bend the library up to his\her needs. Trying to think on highly composable building blocks, not just some extension points could be beneficial.
Elm is pure functional programming. Elm programs are composed of function which are all pure, cannot have side effects, and return the same output for the same given input. The exception to this would be "Native" code but that is getting phased out in the next release. Elm does have state, and it is maintained outside of your program. In your program you supply a model type that represents your entire program's state. You write a function to convert that state into a view. Outside of your program the runtime will pass the current state into that function, and then process the view you produce and update the virtual DOM to match. This happens every time a message is received. For more details, see https://guide.elm-lang.org/architecture/ 
As a small note to add to the discussion, I've found this to be the case regardless of framework/language. I'm convinced front-end forms are one of the last unsolved problems of frontend...they are as annoying now despite all our great advances as they were years ago. Been toying with the idea of them as graphs/sub-graphs, or perhaps there's some secret branch of math I don't know about that would be a good fit? :P.
At work, using the core concepts of this library, forms are not a pain anymore. We can: * Add/update/remove fields without changing our `update` or `view` functions, * Add support for new types of fields with complex UX. * Reuse and embed forms in other forms. * Swap between different rendering strategies for the same form, without changing its core definition. Did you take a look at the repository? I would really appreciate your feedback!
I'm working on a web spa for a CCTV system; real time videos and recordings.
If you want to avoid external packages, you can do a simple fold on the list, only adding unique items to the accumulator: ``` unique : List a -&gt; List a unique = let addNew x xs = if List.member x xs then xs else xs ++ [ x ] in List.foldl addNew [] type Colour = Red | Blue | Green | Yellow | Orange | Pink selection : List Colour selection = [ Red, Red, Green, Pink, Orange, Red, Pink ] |&gt; unique ``` This particular implementation preserves the order of the selection (discarding only subsequent repeats) should you wish it. Under the hood it is not as efficient as a `set` of comparables, but that is likely to be undetectable at the scale of a user selection. If you want a more general approach to doing comparable operations with lists of union types I'd recommend [List.extra](http://package.elm-lang.org/packages/elm-community/list-extra/7.1.0/List-Extra) with functions like [uniqueBy](http://package.elm-lang.org/packages/elm-community/list-extra/7.1.0/List-Extra#uniqueBy)
&gt; I'm convinced front-end forms are one of the last unsolved problems of frontend...they are as annoying now despite all our great advances as they were years ago. Because there is no use case that covers a large enough percentage of them. It's always a balance between what is typical and your actual desired UX.
Just name it elm-form too. Your username is the differentiator. 
&gt; In my experience, any library has a flexibility limit. If you've designed it with one set of requirements in mind, any other person with another set of requirements might have really hard time trying to bend the library up to his\her needs. Trying to think on highly composable building blocks, not just some extension points could be beneficial. It's funny, I have the same experience, but draw a different conclusion. Having some specific and well documented extension points - not trying to cover every possible use - makes an api stronger and easier to use. And an approach like in that library allows you to define very tailored levels of customization under specific assumptions about common usage patterns. If it doesn't meet my needs, not just with this library but in most pieces of UI I'd rather reimplement than put my head around a more generic solution. And Elm's simple type system encourages that.
&gt; As a small note to add to the discussion, I've found this to be the case regardless of framework/language. I remember them not being annoying at all in Clojurescript due to the magic of macros that write all your boilerplate.
What's the best to way to model a Registered User visiting his own profile page or visiting other users' profile pages? Let's say it's like a social network where if the registered user visits his own page he will see the data in some way (private data for example), while if he visits another user's page he will only see the public part of the data. Right now, I'm thinking of separating this in the model by having a loggedIn user field which stores all the data for the current logged in user and another visiting field which stores the data for the current user page being visited.
Yes - they are separate pieces of state, loaded at separate times. The top-level model of the canonical [elm-spa-example](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L53-L56) reflects this division exactly. type alias Model = { session : Session , pageState : PageState } You can see how it [renders the profile page differently based on if it's "my" profile](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Page/Profile.elm#L65-L86) 
I'm trying the Http example from the intro, but elm-package won't install `elm-lang/http` for me. It keeps saying that there are no versions of it on my computer. Even after I try nuking the elm-stuff directory. 
[removed]
Informative article! One question I had about breaking up larger files into individual Model/View/Update/Subscribe files is how that applies to modules other than main? Would I use folders to contain all the files, or just name them Module_Model.elm etc?
Hi, I am working on a web spa and I would like to use materializecss. Do you think that it is better to use elm-css ? And if is so, how is it difficult to reach materialize responsiveness with elm-css?
I personally really recommend it! Good written text and detailed examples should help start easily
I figured out the answer to my question is that modifyUrl is useful in cases where you have a different "view" of the same resource where you want navigating back from the resource not to show that view. So for instance I have a list of items, where you can navigate to a detail view of an item and from that detail view go to a form for that item where you can edit it. I use newUrl to go from the list to the item and then modifyUrl to the form for the item, so that if you go from the detail view to the form and then go back you end up back at the list instead of the form again.
I can't think of a ton of good uses, but one situation where we used it was in an "editor" page. If you visit the page with no ID `/page`, the page automatically creates a new entry for you to edit and modifies the URL to reflect the ID, `/page?id=abcd`
Hmm I think we are talking cross purposes.
Pragmatic Studios https://pragmaticstudio.com/courses/elm or KnowThen‚Äôs Elm for Beginners https://courses.knowthen.com/p/Elm-for-beginners. Pragmatic‚Äôs is paid but very much worth it. KnowThen‚Äôs IIRC is free but with a more advanced paid follow-on course.
Thank you so much! Pragmatic Studios course looks great. How do you think it compares with [this one](https://www.udemy.com/beginners-guide-to-elm-programming-build-web-apps/) on udemy? Which one would you take?
I haven‚Äôt done the udemy one but I have completed and love the pragmatic studios one. Their production is really polished and they make the learning process fun and enjoyable. My favorite part is that they have a follow up section of notes, tips, and exercises after every chapter/video. I think you would be in a good position to start using Elm in your own projects after completing the course.
https://frontendmasters.com/workshops/elm/ I think is good ,and new version is coming
Difficult to be sure with only an outline for the Udemy course, but I‚Äôd say the Pragmatic one is more complete. If you can afford it, I‚Äôd go for that over the Udemy one. Or maybe do the free KnowThen course and see if that gives you a sense of where to go next.
Thank you very much! Purchased it, looks great so far!
Thank you! Bought the course, watching it =)
Awesome, thanks! Currently learning elm. When splitting up as `Module/View.elm` you would import from `Module.View` right? Each directory level is a dot?
Check out https://www.dailydrip.com They have a monthly sub fee, but intro videos are free (and the sub is totaly worth it) Great format, in small daily lessions.
The Elm language actually complies down to JavaScript, and is run entirely client side. So you can use any Static file host to serve the Elm code. The ability to serve/run an .elm file is really a developer-only mode, not intended for production. Just compile your file, and use that for 'production' (hosting.)
That's correct and the compiler will complain if you do anything different. This is an example of Elm being opinionated, and I like it because it makes other peoples code easy to navigate. 
Sorry for late answer, but I'll share one of possible approaches in an article this week. But to my mind, Modules and Folders names should be added from the point of application logic. And sometimes it's good idea to separate, eg. REST API wrapper to even separate package, not just folder to make it easier to maintain and update API itself.
Just in case you don't know this already, the next Elm Melbourne meetup will be on May 7 [https://www.meetup.com/Elm\-Melbourne/events/wvhsfpyxhbkb/](https://www.meetup.com/Elm-Melbourne/events/wvhsfpyxhbkb/)
"An Outsider's Guide to Statically Typed Functional Programming", https://leanpub.com/outsidefp
my advice: if you're new to Elm and comfortable with your current CSS practices, use them. No need to change all the things at once. But if you're comfortable with Elm already, elm-css is super great since it won't let you write invalid CSS. As for responsiveness, it's pretty easy to define breakpoints and then use them inline. Some examples: - defining breakpoints: https://github.com/elm-conf-us/2018.elm-conf.us/blob/master/src/Styles/Breakpoints.elm (I did this is a separate file but it's not really necessary) - using a breakpoint: https://github.com/elm-conf-us/2018.elm-conf.us/blob/master/src/View/Headers.elm#L110-L125 It can be a little weird to debug the output from elm-css right now. It hashes your styles to create a class name on the fly, so they change. Using inspect element works fine, though.
1028
If you want easy mode, set up a github repo for your code. Keep the index.html file with the compiled js in the root of the repo. In Azure, create an Azure App Service plan and select Windows as OS. That lets you select the free tier hardware. When you have that, create a Web App. Select the "HTML5 starter app" or something like that. You probably have to scroll down a little. The wizard will probably suggest to use the app service plan you just created. When you have the app up and running there's a menu item called Deployment Options when you are viewing the web app resource in Azure. This is already linked up to some github repo. Change or delete this and link it to your repo. It should be pretty straight forward. Now you automatically deploy on on each git push, and you should see your site on the url on the Overview page on the web app resource. See other comments on how to compile to js. 
Can you clarify? I thought RESTful is a paradigm more than a specific implementation. I would have thought you just use Http/JSON to for each specific RESTful API. That's what I've been doing with Parse.
REST describes how the backend API is setup. Elm as a frontend client has the Http package therefore Elm supports REST requests (and any other HTTP requests). So for example I'm writing an app where the frontend is Elm and the backend API is in RubyonRails, If I want it to be restful than I need to make this happen on the backend Rails app, not on the frontend Elm side.
The problem is that function don't serialize. For example, you'd be giving up hot-reloading
[Part 2: Screen Based Routing with Navigation](https://medium.com/3-elm-erlang-elixir/spa-in-elm-part-2-1908623429fe)
I am still working on elmbudget, which is now at https://elmbudget.com/. It is still prealpha so use with caution! Any feedback on the UI etc. is welcome.
This series of articles is written during creation a real project. As I move forward with it, I log my experience here. I already have API backend, but haven't yet done with auth. But I think I will and I'll write about it too. Thx for your feedback and your interest.
I've been working on a fun little side-project that finds paths between Wikipedia articles. For example, asking it to find a path from "Death Star" to "iPhone" results in: "Death Star ‚Üí CNET ‚Üí News ‚Üí Radio ‚Üí Wi-Fi ‚Üí iPhone" You can try it out here: https://fizwidget.github.io/wikipedia-game/index.html And the source code is here: https://github.com/fizwidget/wikipedia-game I'd love some feedback on the code! This is the first time I've written anything non-trivial in Elm (or any purely functional language for that matter). 
There is a **Featured Users** section at the bottom of the homepage with the logos of the companies using Elm. 
I'm working on a command line interface for documentation: http://cli.elbear.com/ At the moment it only supports a few Elm packages, but if I receive enough feedback that people are interested in using this, I'll develop it further.
Awesomeness, thanks for sharing this! I've done loads of Elm but only in side projects. Bookmarking this for the mythical future when I get to use it "for real"
Thanks for your feedback. I'll go change that right now.
what I'm looking for is a package similar to requests in Python. 
Absolutely what I needed! Excellent article and well worth the read.
Nice!
[removed]
It is a nice intro but not very deep.
I'm glad you guys updated the community section to include the discourse link as well as updating the copyright up to 2018. But the blog section is showing 2016 still and blog is showing 2017. 
&gt; Just out of curiosity, would it be possible to run non compiled .elm files on a custom server? Or is it mandatory for it to be .js? That is a very odd thing to ask for. (Note: even if you can run the elm reactor on the server, that will let people view your source files, etc. May not be what you want.) I think it's possible to run the elm compiler in a browser, so you could host your elm files + compiler as static files (nothing installed on the server). But I'm not sure how because I haven't looked into it. &gt; I have my .elm files on the server, but I can't actually install elm on here. That is fine. Most people have a workflow that goes like this: - edit the elm files locally - hit "save" in your editor - run "elm compile" - run "scp files to:server" (or any other file transfer method) You can write a shell script to combine the last two. And your editor probably lets you kick off a command on save, so the last 3 steps magically happen when you save. In other words, you don't need elm on the server.
[Reflex](http://docs.reflex-frp.org/en/latest/) is based on Conal Elliot's [Push\-pull functional reactive programming](http://conal.net/papers/push-pull-frp/).
And it's worth mentioning that Elm *used* to be based on functional reactive programming (FRP), but Evan ended up finding it too complex and ultimately unnecessary. Consequently, it may not be super useful to read FRP papers if you want to understand the state of the art on functional web development.
I still wonder if it *is* ultimately unnecessary. For example it could make dynamic experiences like complex interactive data visualizations and animations easier to work with. This is currently where I find Elm's simplified model lacking. For the most the most common cases you could use the Elm Architecture - it would just desugar to full FRP under the hood, and you'd be free to drop down to a more flexible form of FRP if your use case demanded it.
For [JSON API](http://jsonapi.org/), there is this package \- [https://github.com/noahzgordon/elm\-jsonapi](https://github.com/noahzgordon/elm-jsonapi)
I've done this. You can use Express on the node side and have that send stuff to your Elm logic core. The tricky part is knowing which response that comes out of Elm maps to which request. For that I had each outgoing port send the requestId along with its payload.
I don't think there are many more. Elm doesn't really present anything new in terms of theory. It's advantages are in its careful simplicity, API design, community management, etc. The record system in Elm is based on this, I believe: https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/ The type inference implementation is based on this, I believe: http://cristal.inria.fr/attapl/ 
Does anyone have an example of integrating audio or music into an Elm app, perhaps via SoundJS? 
From the repo: "But Electron did the same thing? Yeh, but sometimes, all you need is just a webview to display your web application on a desktop. You don't need file system access or automatic update, blah blah, it would be a huge waste to ship your app with &gt;100MB of Chromium and V8 in it. In fact, this application only uses 0-3% CPU and the bundle size is &gt;800KB on macOS."
Yeah, my intention is to find a solution to replace Electron.
I feel like it would be useful to have a more concrete example of one particular thing you consider easy with FRP but difficult in Elm. That would be a great starting point for discussion on how Elm could evolve in the future.
At the moment Elm's update loop is fixed at runtime, and every update you make has to go all around the update loop every time, even if it is an encapsulated bit of behaviour. Often this shows up in user interface animations and interactivity. There might be workarounds that folks are finding for that, but more powerful forms of FRP (as implemented in Reflex) can support this, at the expense of being easier to turn into an unmaintainable mess, and being more intricate and hard to understand for a beginner. I'd like to see folks be able to have their cake and eat it too - have TEA to help structure things the macro scale, with more powerful FRP when you need it. Alas it's been a while since I've done UI/front end programming, so I don't have any concrete examples on hand. But it's something I'd love to explore, if given a second life.
`Html.Keyed` exists for this reason! http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Keyed What's going on here is that if you have a big list, the diffing algorithm has to look at the difference of *the whole list*. If you assign each item a key, it only has to diff single items. The difference can be pretty dramatic.
For now I'm just using a 'show more' button at the bottom of the page. Simple and works ok for now. I gave the keyed thing a try but there are other considerations making rendering expensive, so I didn't see a benefit yet. 
Correct me if I‚Äôm wrong, but this posting never mentions Elm. 
In the ‚Äúskills and qualifications‚Äù section, they ask for experience with: &gt; One or more frameworks, such as Angular, Elm, React, Vue, etc. Although I wouldn‚Äôt say this is an ‚ÄúElm job posting‚Äù.
I agree. To say it‚Äôs an Elm position is disingenuous. 
You are right, probably I could have phrased it better. But we do have couple of Elm project going on already and hopefully more in the future. PM me for more details
Dude this is pretty dope. Could this be used for SSR?
Cool. \&gt; style\-elements library for Elm ... made sense in a way they never did with CSS I've never used style elements. Could you elaborate on why you liked this better?
I think `elm-static-html-lib` is what you need - this is what I used to convert Elm code to HTML/CSS. 
`style-elements` is to HTML/CSS what Elm is to JavaScript. Matthew started with the requirements (which is primarily producing application layouts and visual styling) and came up with a logical API for it, without all the complexity and legacy that CSS, in particular, suffers from. HTML/CSS is just an output format for `style-elements`, the way JS is for Elm. I find that `style-elements` is way more intuitive both for producing layouts and for visual styling. At this point it's probably more constrained than HTML/CSS but that's fine with me. 
We have to ask whether including "powerful" features is worth the complexity for a language like Elm, which is specifically designed to avoid the major complexities found in other languages. In the worst case, a "full FRP" architecture becomes no better than an OOP architecture in terms of maintainability, comprehensibility, and learnability. At that point, what have we accomplished? Perhaps merely a functional language with good error messages. We've learned from OOP that education and discipline on how to use programming features doesn't work very well. A lot of people know of "design patterns" and "composition over inheritance" but this hasn't stopped them from continuing to write spaghetti code. Having hard limitations on how programs can be written is usually a *good* thing (e.g. memory management, static typing, immutability). Perhaps The Elm Architecture doesn't support certain needs such as animation very well, but again it's better to talk about one specific problem and code example at a time. The solution to a particular architectural problem is not necessarily FRP, in the same way that the solution to a particular polymorphism problem is not necessarily typeclasses. Finally, I'd say that it's worthwhile being careful about proposing solutions without careful reasoning and justification. It risks introducing dogmatic thinking whereby people start believing that certain approaches are the right answer (because others have said so) and push for their implementation/usage without evidence. I've been very guilty of this in the past. There is certainly a dogma around typeclasses and category theory in the Haskell community, for example. (Also, I have a gripe with your use of the term "powerful"; it's not a helpful adjective. Such a term is typically used by proponents of a feature without qualification. It's important to be specific about what you mean.)
&gt; Perhaps The Elm Architecture doesn't support certain needs such as animation very well, but again it's better to talk about one specific problem and code example at a time. The solution to a particular architectural problem is not necessarily FRP, in the same way that the solution to a particular polymorphism problem is not necessarily typeclasses. Agreed. I'm not saying Reflex has all the answers, and I think there are some very good ideas in the Elm Architecture, and that it might be a very good 'default' solution. I just found it has limitations in practice, and want to urge people to keep trying to have their cake and eat it by questioning the status quo. It's good to look at ways others solve these problems outside of Elm, because there are lots of good ideas out there! I'm going to a workshop on Reflex this month as part of a conference, so hopefully I'll be able to give a better critique of its approach then. On the topic of type classes, I do think we can do better. I've personally been working on a language that will use a combination of records-as-modules (like in 1ML and scrap-your-typeclasses) and implicit argument passing (like in Agda and OCaml's modular implicits) as a solution to bounded polymorphism and ad-hoc overloading, learning from some of the mistakes made in Scala's implicits. May not work in practice, but it will be interesting to see! &gt; Finally, I'd say that it's worthwhile being careful about proposing solutions without careful reasoning and justification. Yep, that's a worthy concern, but there's also the risk of then never being open able to consider any new ideas. It's important to have [a marriage of skepticism and wonder](http://alexpetrov.com/memes/sci/skept_wonder.html) when learning new things.
&gt;"The human eye does not function to its best advantage in the dark or in looking at a fairly well illuminated object when the eye itself is surrounded by darkness," according to Mr. Henry. "There should prevail as high a degree of general illumination as may be consistent with securing clear and easy vision of the picture. &gt; &gt;"Too low illumination causes dilation of the pupil to an abnormal degree and provides a coreal area which does not permit of focal accuracy and which tends to distortion of outline. To partially overcome this, segmental action of the ciliary muscle governing the focusing of the eye is induced. Such muscular action can only be attained by great effort. &gt; &gt;"There is also strain of the iris muscles resulting from the prolonged dilation of the pupil and another objection is that the varying intensity of the light reflected from the screen requires constant iris action more difficult of accomplishment than under normal dilation. https://www.thecrimson.com/article/1927/2/17/poor-lighting-in-movie-theatres-causes/
&gt;"The human eye does not function to its best advantage in the dark or in looking at a fairly well illuminated object when the eye itself is surrounded by darkness," according to Mr. Henry. "There should prevail as high a degree of general illumination as may be consistent with securing clear and easy vision of the picture. &gt; &gt;"Too low illumination causes dilation of the pupil to an abnormal degree and provides a coreal area which does not permit of focal accuracy and which tends to distortion of outline. To partially overcome this, segmental action of the ciliary muscle governing the focusing of the eye is induced. Such muscular action can only be attained by great effort. &gt; &gt;"There is also strain of the iris muscles resulting from the prolonged dilation of the pupil and another objection is that the varying intensity of the light reflected from the screen requires constant iris action more difficult of accomplishment than under normal dilation. https://www.thecrimson.com/article/1927/2/17/poor-lighting-in-movie-theatres-causes/
I'll send people here whenever I get into pointless discussions about dark themes for IDEs. 
This article is speaking of looking at a very bright picture, while sitting in a very dark room, as being bad for the eye. So I don't understand why this is in *favor* of a white theme?
It's better for your eyes to sit in a bright room with screen having the same brightness.
I'm not sure if any of the devs hang out here but the example program http://elm-lang.org/examples/field linked from https://guide.elm-lang.org/architecture/user_input/text_fields.html does not match up with the tutorial text. Or maybe there's a better place to report this, educate me! 
The "getting Started" guide was very helpful but now it feels like im stuck. I would need the "advanced guide" that talks about specific problems and best practices. for example:is there a function for \name -&gt; value -&gt; a -&gt; {a| name = value}? so that i can write a |&gt; function "name" value this feels so odd to me... like i missed something.
Haven't used them myself yet because I avoid modals and dialogs as much as possible, but here's an example of somebody creating one: https://youtu.be/AQ2Am3saNXY?t=4m10s
This is the best video I have seen that can help you organize your Elm projects. [The Life of a File](https://youtu.be/XpDsk374LDE)
This is not possible because Elm does not have reflection. That is to say Elm doesn't have anyway of executing code at runtime that can see what properties are available on a type. The closest you might get to this is to represent your data as Json, although you might need to build up your own general-purpose Json types, effectively storing dictionaries. (The Json.Encode.Value types seem to be one-way i.e. you can create an object, but you can't do anything with it to manipulate it (other than encode it), at least from what I can see.) 
[removed]
Very nice, but it does not work well on mobile. The text is hidden behind keyboard, so you don't see what you are writing. The documentation lines also are not wrapped. 
Definitely a good one to watch - I think the main takeaways I remember were "start with just one big file" and (if I recall correctly) "make modules around nouns/things instead of verbs". So in your case probably start with just `drawMountain`, `drawCastle` etc. in `Main.elm`, then potentially split those out into `Mountain` and `Castle` modules with associated game logic. I think for a smallish self-contained project, it would be totally fine to import `Html` into each of the modules and then have Mountain.draw : Mountain -&gt; Html msg Castle.draw : Castle -&gt; Html msg etc. (You may also want to consider using SVG or perhaps WebGL.) If that makes you uncomfortable, you could have (for example) the `Mountain` module include the complex functions for things like determining a sprite image URL based on current state/animation time, then just use that image URL in draw functions elsewhere. That way most of the logic is in the `Mountain` module (organized by noun!) but is independent of how it is actually rendered (you could use that image URL in HTML, in SVG or as a texture image in WebGL...).
Elm is very similar to Haskell, in that sense that the type system is very similar and syntax is the same as far as I have noticed except for the part that Elm does not have guards. So if you are interested how functional languages like Haskell, you could start with http://learnyouahaskell.com/