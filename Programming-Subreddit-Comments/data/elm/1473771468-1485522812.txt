In more complex scenarios, you need to rest on the work of others. This means using carousels, accordions, various forms of dropdowns, calendars and other so called "JS Components". These are not available in Elm (there are some attempts but not something I would call production ready). Embedding an Elm component in a larger React app is a very different experience than embedding a React component in an Elm view. Maybe it's my ignorance but I've seldom seen JS components integrated in Elm views. I have tried to add a carousel to one of my apps and ended up giving up and reimplementing a more primitive, minimal version in Elm in the end. Also, I feel the need to clarify, you can implement extremely large apps in Elm. It's not a question of scale. If your needs are covered by elm-html with an externally generated CSS, you can grow to quite a large scale with just Elm. It depends on the project requirements. 
You're on /r/elm, everyone (me included) will say Elm, but there are still tradeoffs in each case.
You can, depending on what you want to do. Some things are easy to model with Elm, and some are more difficult. But when Elm hits its limitations, you can Can you tell us more about what your frontend app looks like? I think it's worth your while to read about Elm with the [Guide](https://guide.elm-lang.org/) and [The Elm Architecture](https://guide.elm-lang.org/architecture/). Try writing some small apps on http://elm-lang.org/try, and get a feel for the language. I think it will help you know what it can and can't do. Be prepared that it is likely radically different from other ways you've programmed.
I came to FP from Ruby, frustrated with inscrutible inheritance systems and the horrors of debugging complex hidden state.
As the comments are alluding to, this depends on your personal definition of 'production ready'. The Elm ecosystem is small, young, and unstable (meaning it is likely to change, not that the software crashes) compared to some other platforms. There are fewer polished off-the-shelf components than you might want, the next version might require serious changes to your code and the code of any dependencies you do happen to use, and you aren't going to find many out-of-the-box Elm experts when you go hiring. On the other hand, Elm produces fast, maintainable software in a way which is uncommon in the browser. It is interesting, so it is eaiser to hire talented people. There are plenty of things which people want ported to the language, so it is easier to give back to the community. If I didn't have anybody to answer to, I would start integrating Elm into my work straight away. If I answered to people who are risk-averse, I probably wouldn't mention Elm.
Elm is definitely much simpler in terms of tooling. You don't need the whole Gulp/Grunt/Webpack/Babel etc whole build process that's necessary in JS, you don't even need any framework like React or Angular. You can just handle everything in plain old Elm and compile it with the built-in tool easy peasy. Of course, you need to learn a totally separate language. But that language is definitely much simpler than JS + tools + buildsystems.
I think the bottom line is that all languages have their own best practices. If you don't follow them, you'll have a bad time. As it turns out, some languages have best practices that are very simple and intuitive (fp happens naturally in js because no one understands how objects really even work). Others are much more complex and nuanced (how to manage state or the lack of it in Haskell). 
Don't pretend like Haskell and Elm don't have their warts either. The grass is always greener. I just am happy with ruby as of now. I realized that with Haskell and Elm I was forcing myself to learn something that I knew was highly impractical given my skill set, just because of some ideology that I bought into and didn't fully understand.
I'll give it a look. I think I previously just couldn't find a good resource to learn it. The book jumped into spawning process children right away or something.
Sounds like it should be fine. If you need to, you can communicate with your other pieces with a port. You should probably run the generated files through the closure complier though, the output files can be quite large. It's better to just have a single app eventually and conditionally render parts of the page where you wouldn't need the widgets
I was running into the same problems as u/elm-idiot , so that helped me too :) One more thing... How would you suggest doing this part of the suggested exercises: &gt; Add a "Submit" button. Only show errors *after* it has been pressed. My solution at the moment would be to: * Add a field named "validate" to the model * Have viewValidation return something that amounts to empty html in elm if "validate" is True (and the current code would go in an else block) * Set "validate" to False in all the update messages * Add a "Submit" message * Add a button that sends "Submit" when triggering onClick * Set "validate" to True in the model if Submit is the message 
Do you want to use web components in elm or elm in your components?
It is highly encouraged to write components of a larger site in Elm and this will often involve multiple Elm applications. Incrementally moving to Elm creates projects which are small enough to be managed and offer the opportunity for frequent, small wins. There is a [post](http://elm-lang.org/blog/how-to-use-elm-at-work) on elm-lang about this sort of issue. Inter-component communication can use ports and keep an eye out for opportunities to merge applications to reduce overall complexity.
As /u/bartavelle notes, `Maybe.withDefault ('', "") &lt;&lt; String.uncons` is another way to write `myUncons`. However, you should reconsider the logic that you are employing here. In this section, you are saying that if there is no string to compare to, any keypresses are counted as incorrect. Is this intended? `String.uncons` returning a maybe gives you easy access to useful information should your application make it to this state and you should be using this. case msg of KeyMsg code -&gt; case String.uncons model.word of Just (first, rest) -&gt; if keysEqual code first then ( {model | score = model.score + 5, word = rest}, Cmd.none ) else ( {model | score = model.score - 5}, Cmd.none ) Nothing -&gt; -- handle no string. perhaps: update EndGame model 
You can use Task.perform and Task.succeed to send a command back through the update function OR you can just call update with the message and return what it returns. I'm on mobile so hard to give a good example but if you'd like I can later.
&gt; However, you should reconsider the logic that you are employing here. In this section, you are saying that if there is no string to compare to, any keypresses are counted as incorrect. Is this intended? No, myUncons was a dirty hack just to get something functioning. The rest of your post made things a lot clearer for me, thanks. For some reason I was avoiding nesting my case expressions.
Thanks, this did help. I wasn't quite sure how to do another update, which was a bit foolish because I could just call the update function when I needed to. I think I need to stop doing my recreational coding first thing in the morning before coffee.
I find that Elm asks me to indent a bit more than I would tolerate in most languages (partly because it has intentionally avoided things like function head pattern matching to simplify the language). This is about the limit that I tolerate and any more I would shunt off into a function.
Happy to help! It just occurred to me that the helper function could be simplified a bit by doubling down on using lists everywhere: initialModel : String -&gt; Model initialModel word = case String.toList word of first :: rest -&gt; Playing { first = first, rest = rest, score = 0 } [] -&gt; GameOver 0 (Untested, but I think it should work.)
Also, I did think it would be better to remove all the onChange events and submit the data only on button click but I am not sure how to submit the text field data by clicking the button.
Given the event must be delivered to Main, if you want a short cut, introduce a mechanism for GGGC to "register" interest in events with Main. The event can now be sent directly to the GGGC. Of course, this assumes that C, GC and GGC have no legitimate interest in knowing that the event took place until they see some resultant change in the model. This is just the Observer design pattern. There's no reason why you can't use these and other design patterns in Elm code, though you may end up tying your app in knots if you violate TEA too severely.
I agree with this. I don't really need to track the real-time changes of text fields in most forms, just sample them when something else happens. To get around this I always have a String field for every text box updated constantly via "onInput", and then a separate "onBlur" handler or something that will actually do something with the value, like parse it as a Float and do a calculation. It is automatic now, but I don't like it. Especially if the text box is for a number, you don't want to two-way bind it to the Int or Float parsed version of the number, so you need TWO model values for the field - one for the constantly changing String value, and one for the Float value that you update when the user seems to be done typing. On the other hand, I can probably just do this: input [ on "blur" (targetValue `Json.andThen` (\str -&gt; let floatVal = str |&gt; String.toFloat |&gt; Result.toMaybe in Json.succeed (FormFieldCommitMsg floatVal) )) ... ] [...]
Could you elaborate on that? How would you achieve it in elm code?
&gt;replacing asynchronicity with recursion is only a slight improvement. Huh? Fewer code paths means fewer places to accidentally mess things up. There are reasons to go either way here, but some sort of irrational fear of recursion doesn't seem valid.
Thank you, I might have overlooked the part where subscriptions can also be map just like update and views. I don't see any example codes that does that either. How about init, maybe init could be map too.
I've tried to clarify that statement. Objectively, I think introducing functions is a great idea. Functions are composable and reusable. Calling update recursively from one branch is probably fine, but the complexity increases when you do it a second time. I think separate functions add less complexity than calling update recursively. Of course, the result is the same so if you have a different taste, that's fine. 
Those are valid points, thanks! Judging by what I've seen on the elm-slack channel, people who use Task.perform with Task.succeed rarely want to call the other branch asynchronously. Because it can (theoretically) lead to weird bugs, I think the "default pattern" should be to call synchronously. The idea of knowingly using Task.perform to update asynchronously makes me wonder what it could be used for. Would it ever make sense? 
I think a dict would be the right way to go as we don't have dynamic records in elm. Could you build the gen_keys function below so that it does what it says? module Main exposing (..) import Html -- import Json.Decode exposing (Decoder, decodeString, keyValuePairs) json : String json = """[{a: 1, foo: "bar", bar: "baz"}, {a: 2, foo: "baz", bar: "foo"}, {a: 34, foo: "big", bar: "lebowski"}]""" gen_keys : String -&gt; String gen_keys json = -- Decode the first JSON record and return a comma separated -- list of keys json main : Html.Html string main = Html.text (gen_keys json) 
 maybe ("key" := decoder) `andThen` maybeNoKey maybeNoKey maybeKey = case maybeKey of Just v -&gt; succeed v Nothing -&gt; -- decoder when no key present 
 type CatchAll = Int Int | Float Float | String String decodeObjects = list &lt;| dict &lt;| oneOf [ map Int int , map Float float , map String string ] You can add more types as required. I think it will also mangle Floats which are equivalent to Ints (e.g. 2.0).
Perfect, thanks!
You probably don't have a module declaration right ? if you just add a module declaration it should work: `module &lt;SomeModuleName&gt; exposing (..)` Ref : https://guide.elm-lang.org/reuse/modules.html It's optional to have one, but I tend to always declare it, so I haven't catered for that case (yet another complicating exception case). In most Elm apps you typically end up defining modules. I'll add an issue for handling the no module declaration case, but in the mean time you'll have to define one. It's not that hard, and you might as well get used to it :-)
Uncontrolled recursion has the problem of making it more difficult to identify unintentional infinite recursion. One of the great advantages of map, fold, filter etc. is that while they're recursive the recursion is hidden from the caller and controlled. If message "X" calls update with message "Y", "X" has to assume that message "Y" will never produce message "X". If you keep the update function simple enough that's it's just a way of dispatching asynchronous messages to functions you don't get that kind of trouble.
Elm doesn't have side effects. "sending an instruction to Elm" would be a side effect, so you can't send commands to elm. Instead Elm "polls" for commands. You only provide a pure function that takes the current model (state of the program) and calculates a command, which is just a static value. Elm calls this function whenever it feels like it needs a command (whenever the model changes). Function application is left associative, so that Random.generate OnResult (Random.int 1 6) really is ((Random.generate OnResult) (Random.int 1 6)) i.e. (Random.int 1 6) doesn't get applied to OnResult, rather OnResult is the first argument to Random.generate with type (a -&gt; msg) and (Random.int 1 6) is the second with type Generator a. So OnResult is not a message. It is a message constructor and it needs an argument of type Int to become a message, hence the type Int -&gt; Msg. So the example is producing a static value of type Cmd msg, which has the semantics "Call the given generator to produce a value of type Int, then use the msg constructor "OnResult" on the generated Int to produce a message and finally pass that message to my update function to get the next state of the program and your next command." Hope that helps.
Thanks
Function application is just juxtaposition in Elm. Both `OnResult` and `(Random.int 1 6)` are arguments that are being passed to `Random.generate`. Remember that in &amp;nbsp; type Msg = OnResult Int &amp;nbsp; `OnResult` is a **function** of that takes a value of type `Int` to produce a value of type `Msg`. Its type signature is: &amp;nbsp; OnResult : Int -&gt; Msg &amp;nbsp; *This* is the first parameter to `Random.generate`, so you can see this type actually does line up with `Random.generate`'s polymorphic `(a -&gt; msg)`. The call to `Random.int` actually returns type `Generator Int`, so it fits as the second argument to `Random.generate`. The broader reason for all this is that Elm is purely functional. Making an arbitrary AJAX call, for instance, ruins your ability to reason about your code equationally. If it doesn't always return the same thing, any function using it would return different values for the same arguments. That's no good. So the hand-wavey explanation is that to do anything useful with IO, we have to instead let *Elm* reach out into the world and pull back useful information via Commands in a way that enforces certain guarantees.
&gt; So OnResult is not a message. It is a message constructor and it needs an argument of type Int to become a message, hence the type Int -&gt; Msg. Ahh, okay. I didn't realise that at all. I reasoned that `type Msg = OnResult Int` meant "`OnResult` is an example of a `Msg`, and it always comes paired with an integer." But you're saying that the real meaning is "When `OnResult` is fed an integer, the result is a `Msg`"? &gt; Function application is left associative I feel dumb for not realising that's what was going on. Just getting used to the ML-style "spaces separate arguments" thing, I suppose... although I do know Ruby which can do basically the same thing, so that's no excuse. &gt; calculates a command, which is just a static value. Elm calls this function whenever it feels like it needs a command (whenever the model changes). So that's whenever `update` gets called, right? I've only written using `Html.App.beginnerProgram` until now, which doesn't have commands or subscriptions, but it looks like in `Html.App.program`, `update` always returns a tuple of (model, command). Am I right in thinking that every time `update` gets called, the Elm runtime says "Okay, let's re-run `view` using that new model, and then do whatever the command was"? Thanks for your help, I really appreciate it and it's helping me out a lot!
Sort of related, but if I have a BAM (big ass model) with nested records and a lot of fields, when I update just a part of it, does the whole model tree get deep copied, or is the majority of the data structure re-used and just the part that's changed has its references updated -- sort of like the concept of a union file system
There is the [react-elm-components](https://www.npmjs.com/package/react-elm-components) module, as announced/discussed in [this blog post](http://elm-lang.org/blog/how-to-use-elm-at-work).
For an overview of how the Elm runtime works and how messages/models get passed around and updated, I like [this diagram](https://raw.githubusercontent.com/notyy/learn_elm/master/elm_arch.png).
Most of the structure gets reused, everything is references underneath, so when you make a new copy, any fields that are unchanged won't get copied, since all you had in the first place was a reference. 
Imagine Google's confusion
I've used (and made a small contribution) to a project that integrates elm into a redux app. It uses redux's middleware system to pass redux actions to Elm. If you have any questions feel free to send me a message. https://github.com/stoeffel/redux-elm-middleware
Shouldn't `SubTaskMsg Msg` be `SubTaskMsg Int Msg`, where the `Int` is the ID of the `SubTask`?
Ah, sorry, forgot the multiple arguments. Possibly yes, but possibly you might not need the ID in the Msg. I'd start without it and see if it leads to a dead end and I need to have it in the Msg.
&gt; then later I can iterate through the records and pull out the relevant data doing something like so: so how do you know how to pull out the data? at some point somewhere you have to know something right?
No JS knowledge is necessary! Most of what you do with Ports is interface with other libraries, websockets, etc. Stuff you can copy and paste to get working. But Elm avoids most JS idioms, so you should be fine without it. Knowing html basics will help, since Elm is mostly used for making html pages, and our libraries are pretty close to normal html structure. But the Graphics libraries can help you make pages without any HTML 
&gt; The reliance on existing JS/CSS components is actually the main reason I said this might not be the best route for beginners. Of course, if one does not need such complex widgets, Elm is fine. The main thing here from my experience is that if one starts without thinking that they need the JS components and then they discover that they do, these JS components are not trivial to embed in Elm generated UI. and &gt; I think it's fair to say that Elm is a great choice for projects where teams are already comfortable doing Web development, but I can see how it wouldn't be the best choice a beginner building one of their first production Web applications. I expect that will change over time, but we are not there yet. https://groups.google.com/forum/#!msg/elm-discuss/odfyxZPmIyI/--AIFJCIAgAJ
Thanks!
As ever, try them all and form your own opinions, but IMO: Elm &gt; React &gt; Vue &gt; Literally anything else up to and including writing assembly code while strapped to a medieval torture rack &gt; Angular I exaggerate, but still. I spent all of last year working on an Angular 1.x application at work, and it was no fun at all.
I really like watching presentations on Elm by Richard Feldman - anything from him?
I'm also an Elm noob, but this is the best read I've found on how to compose Elm modules: https://www.elm-tutorial.org/en/02-elm-arch/06-composing.html Very interested to hear of any other articles/examples that tackle the same subject
You can abstract those to a generalized set of CRUD routes: https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes/blob/master/servant/src/Routes.hs https://github.com/Southern-Exposure-Seed-Exchange/Order-Manager-Prototypes/blob/master/servant/src/Api.hs#L29-L48
This might be helpful: https://guide.elm-lang.org/reuse/
Thank you!
Thanks! It looks like it doesn't work if you copy/paste it into http://elm-lang.org/try though. It doesn't seem to like the Dom module. I get this error: I cannot find module 'Dom'. Module 'Temp1474577168177632' is trying to import it. Potential problems could be: * Misspelled the module name * Need to add a source directory or new dependency to elm-package.json
You need ``elm-lang/dom`` in your dependencies (e.g., in ``elm-package.json``). I would suggest trying locally.
Hi ! tnx for your feedback! Real valid and thoughtful points. * Haha your probably right but we so want so show our video, it pretty hype right ? * We have changed our signup quite a bit so that quote is no longer there. * We are going to implement "login as guest" pretty soon, and hope that it will resolve some of that "what am i signing up for" issue. Long term it of course would be nice to only need your user when you want to write a comment or save something. * Valid, we are looking into describing our platform more succinct. Would be super helpful to get some follow-up notes after you have used the site :) Have you visited it again ? if not why ? And generally more points about what works and what does not. Cheers! 
Thanks! That's where my project is at as well. I ended up deciding to modularize it and am working on that right now. - it's in a private repo right now, but I'll get back to you when I switch it to public and we can share and compare!
Sorry, thanks for pointing that out. I've updated the post now, and here's the link: http://cast.rocks/hosting/6039/feeds/8YSE5.xml
1. Whitespace affects Elm syntax, so if you copy and paste code snippets and mix them with tabs, you'll get terrible parse errors with useless messages. (If you've ever mixed them in python, you know how bad this is). 2. Literally every editor allows you to press the TAB key and get spaces put out. 3. You should use elm-format, so that your code ends up in the standard style at the end anyways. So this affects neither the developer's workflow, nor the final appearance of your code at the end, and has a concrete benefit for parsing. This is a non issue.
I'm not saying one is better than the other since it's really a matter of taste, but elm imposing spaces is a deal breaker for people using tabs. I was going to give elm a try but thanks no.
If this is a deal breaker, of all the facets of Web Dev, then your priorities are sorely mismatched. Let the flame war die. And like I said above, it changes literally nothing about how you do Dev. 
I prefer tabs over spaces. What I prefer even more is that everyone's code looks exactly the same. 
&gt; Let the flame war die. I'm definitely not participating in a flamewar, I don't mind other people using spaces at all. I just don't want to use them myself. It seems to me like the authors of the compiler are the ones participating in the flamewar... Oh well, time to use spaces I guess :-/ 
Thank you! Yes, sorry about that. It's already been submitted to iTunes. We're now just waiting for them to approve it. In the mean time your podcast client *should* allow you to paste in the feed URL and subscribe that way: http://cast.rocks/hosting/6039/feeds/8YSE5.xml
Being so inflexible as to refuse to use one and reject a language because it chooses one *for technical reasons* is continuing the flame war. This isn't "Silicon Valley". You don't need to have a side and stick with it. 
That was great! One tiny suggestion: perhaps note the time that each link corresponds to in the podcast.
Ah, but I'm not rejecting Elm, that was /u/pier25. I still like Elm very much. I'm just mildly upset about the spaces but as long as the reasons are technical like you say I suppose it's not a big deal... 
Great podcast, looking forward to the next one! :-)
So you can never use Python either?
This might help provide a starting point. http://noredink.github.io/json-to-elm/
I thought that, until I figured it out - the decoders in elm are more of an understanding problem, as soon as it clicks its super quick and smooth to build them out. The idea of missing a maybe or parsing the wrong type is more on you and your api - I find that it encourages more understanding of the api and what the data transforms are in general. If a property can come back with a value or a null, you should know that - or you wouldn't know to put proper error handling on a null value for it even in regular js. It's just a different way to look at it, that's all. 
&gt; json decoding can result in runtime errors, for example when you forget to use a Maybe to decode nullable json. Perhaps I'm dense, but I have never seen this cause a runtime error. It can cause the decoder to fail, but that just produces an `Err` `Result`. `Json.Decode` is only as complex as JSON requires it to be. Elm is just forcing you to actually handle all of the nasty corner cases which can emerge from this data format. What *should* your program do when it encounters an unexpected `null` field in a JSON structure? In JavaScript, all sorts of things might happen depending on how long it sits in memory before being discovered and then cause any number of problems when it is revealed. `Json.Decode` is just showing you how unreliable this data format is. Simplifying it requires making assumptions about data which might be unfounded. You might check out `elm-community/json-extra` for a few functions which make certain things easier (e.g. `maybeNull` to handle possible null values). More generally, if you find yourself implementing a particular pattern repeatedly, put it in a function.
noredink's json pipeline is nice when you have to deal with fields that may not be there. https://github.com/NoRedInk/elm-decode-pipeline
In practice, the way I build apps against APIs is to look at their sample data. Since most APIs don't provide a robust JSON schema, I can't guarantee a value will be required, null, or even non-existent. What happens instead is that I build my app, and it occasionally breaks (because of nulls etc) and I then fix those bugs for it, one-off. 
I've never seen json decoding fail with anything other than `Err` `Result` either. If it does cause a runtime error, that's a compiler bug.
&gt;Also (unless you are using VIM) moving through code indented with spaces is a royal pain. ...yeah, no. You should be using ctrl+left/right (or os x equivalent) to move if you're not using vim/emacs.
It's not a preference. Tabs have caused problems in Haskell, and Elm has avoided these issues. The nature of these language's syntax does not really allow variable width tab characters, so Haskell defines a tab as aligning to the next 8 character column. If your editor is configured differently, your code will look really weird to others, and their code will not even look syntactically valid in your editor. It's smart to just avoid the whole problem and forbid tabs. It's too late to do that in Haskell, but Elm could always allow tabs someday in the future, although it would be a silly thing to do. Are you bothered that constructors have to start with a capital letter which is arguably also a preference?
For reference: https://guide.elm-lang.org/reuse/
Link to a library which already does this: https://github.com/krisajenkins/elm-export
F# is a really nice language, but I never stuck with it because it felt too coupled to Visual Studio (great IDE, but too heavy for small projects IMO). Ionide might finally get me to give it another try. Great article :)
If the API you're using has a Swagger spec (and if it's your own api, start using Swagger. It's awesome) I would like to shamelessly plug a project I'm working on, https://github.com/ahultgren/swagger-elm, that can generate complex types and decoders based on a declarative spec.
The "announcement" was actually this posting on this elm-discuss thread a few weeks ago which precipitated a major re-thinking of best practises for many of us: https://groups.google.com/d/msg/elm-discuss/_cfOu88oCx4/madaA1rBAQAJ Which lead to: https://groups.google.com/forum/#!topic/elm-discuss/lC4FwHSPUA0 And: https://guide.elm-lang.org/reuse/
Might I suggest looking at the design issue the other way around, then? It seems like you are trying to match the API emitted by some third party, and since it is not well specified, you have trouble fitting it into Elm's type system. Instead, figure out the minimal core of the API you need to do whatever it is you are doing, and make that required in your types and decoders. For everything that you might be able to do something with, if it is present, make that optional. Ignore anything else since you don't have a way to make use of it.
I think he just started the channel! And don't forget to write back your experience with fsharp :)
Are you the author of these? I appreciate the posts, however this one completely failed to explain what it was doing imo. I'm more confused after reading that section on currying than I was going into it. 
I don't know man, implying tabs only belong in the 90s or non-serious languages seems quite the fuel-to-the-fire type of thing to me... 
I work in that constraint all the time, because I am part of or contribute to projects that indent with spaces. It's no problem at all. What I don't like is having the choice taken away from me for personal projects. This is about **liberty**, not personal flexibility or whatever. Similar thing is with makefiles - they enforce tabs, and I don't like that very much either. Oh, and I am enjoying Elm quite nicely, thank you very much. The hostility of some of the people much less so, but I can't do much about that... 
Thank you for reading and commenting :) So, I really would like to experiment with the other languages too. I don't know if next I will go deeper on F# by using Fable, or try one of the other "finalists" with Elm. Kris Jenkins is really smart. I've learned a lot from his blog posts. I'll give a look in the talk and the lib - thanks for the tip! 
The first line of defense is to structure your data so you can't generate error states. Richard Feldman had an [excellent talk](https://www.youtube.com/watch?v=IcgmSRJHu_8) at Elm-Conf regarding this. It's not always practical to achieve, but give it *serious* consideration because it is best practice when you can do it. Where you go from here depends quite a bit on how you want to handle the problem, but `Maybe` and `Result` are the basic structures one uses to handle these possibilities (they are very similar). Consider this (and forgive any typos since I am going to freehand it): update : Msg -&gt; Model -&gt; Model update msg model = case msg of DoNext -&gt; next model.foos |&gt; Result.andThen process |&gt; handleErrors model next : List Foo -&gt; Result String Foo next foos = Result.fromMaybe "No Foos to process." &lt;| List.head foos process : Foo -&gt; Result String Bar process foo = -- do process step which may produce a Bar or fail with an error string handleErrors : Model -&gt; Result String Bar -&gt; Model handleErrors model result = case result of Err message -&gt; { model | errorMessage = message } Ok bar -&gt; -- update the model with the process result Each step can fail independently and produces a different error message. More complex arrangements might use a more interesting error type in `Result` or you might roll your own type for handling the evolution of state through your pipeline of transformations.
The issue os that you are makimg many sub modules. This isnt an OO language its a functional language. Things work better when they are a little flatter and functions become the reuseable component.
Remember that modules aren't objects, they're just a collection of functions and types. They can't store state. You can't 'communicate between submodules' because there isn't any instances to communicate between. It doesn't make sense for a 'submodule' to subscribe to anything, what would happen when an event on the subscription occurred? If it resulted in called a function where would that function return to? 
I realize that there aren't "instances" of anything, and I think I have a good grasp of the Elm model. My specific issue -- I have a toggle switch sub-module because the behavior of toggle switches in this app is complicated. The Models for each individual toggle switch are children of the Model for the draggable control panel that they live in (the control panel is a sub-module). And the Model for that control panel is a child of the main Model. There are also other child control panel Models that have their own children. In the case of one control, when the user selects it, it's supposed to fire off a websocket message, cause its parent control panel to disappear, and then cause another switch in a different control panel to turn off. In the case of making the parent control panel disappear, that's easy. The update function of the toggle switch returns an OutMessage (http://folkertdev.nl/blog/elm-child-parent-communication-continued/) which triggers the parent's update function to close the control panel. But changing the model for the switch in the other control panel requires way more boilerplate. The control panel's update function needs to pass a OutMessage to its parent's update function, and then the message has to be pushed back down to the control in the other branch using Cmd.map. All of this follows other models I've seen of how to do this kind of communication. I'm using Sub.map and Sub.batch to combine and handle all the subscriptions defined in the sub-modules. The problem is all the boilerplate, as you have all these chaining update functions. What would be great is if, when that toggle switch is activated, its update function returns a Cmd, and that Cmd fires an event that's listenable via a subscription. 
I spent some time looking into this in the discussion forum, and I think binaryblade and jessta are right on. I'm taking the wrong approach to this. I saw this quote on the forum, and I think it really applies: *What is a big deal, and a super common beginner mistake, is to split out separate state ownership when you don't need to yet.* I'm going to try to seriously rethink this as a flatter app. I think I'm conditioned into trying to turn everything into a component because of other frameworks I've used. The idea of one huge, flat state for everything still feels a little weird to me, but I'm seeing the advantages. Probably just part of the growing pains of adjusting to the functional language way of thinking. Thanks to both of you for the advice!
/u/magnuscrocethethird Similar thread about flat structure: &gt; The term "component" seems to lead to lots of misunderstandings in the Elm world. If we stop using it, I expect better understanding will result. &gt; Here is a good example: The header is split in 3 components: logo, menu and help &gt; I'm going to go out on a limb and assume the logo does not need its own local state. &gt; As such, I presume the header can be implemented in Elm as three functions that each return the same Html Msg type. &gt; As a starting point, I would strongly recommend beginning with having things be as flat as possible—one Model, one Msg, one view, and one update—and then splitting up from there according to paint points. (Probably one monolithic view is going to get annoying right away, but fortunately splitting view into multiple functions is the among the easiest refactors you can do.) https://www.reddit.com/r/elm/comments/4zmr83/help_required_scaling_in_elm_or_how_to_solve_what/
I think you are missing a simple fact. A tab is just a single character `\t`. It's not a series of characters. What you are referring to as 8 characters width is an old reference to [the printing world](https://en.wikipedia.org/wiki/Tab_key#Tab_characters) when tabs were a series of spaces. An advantage of tabs over spaces is that you can configure those to be as wide as you wish **visually** on your editor and even change that later without changing a single character of your code. Why? Because tabs are not a series of spaces and the visual space that the tab character occupies is a simple visual setting, not a difference in code. You whole gripe about tabs being 8 characters long is pointless, as long as you don't convert tabs into spaces and just use "real tabs", so to speak. Considering that, my previous point still stands. Elm could perfectly support tabs just like Python does. If it doesn't it's because of a limitation with the parser/compiler. And that limitation is most probably because of a personal preference, not a technical one. Are we done here?
&gt; This is about liberty, not personal flexibility or whatever. Elm is the wrong language for you if that's what you seek. It very much makes a number of choices (syntactic, semantic and architectural) for the developer, with no "liberty" or "personal flexibility". You may want to look at e.g. Purescript instead. &gt; The hostility of some of the people much less so People are only hostile in response to your hostility, the title of your post is a troll, the content is little better.
&gt; What you are referring to as 8 characters width is an old reference to the printing world when tabs were a series of spaces. &gt; Elm could perfectly support tabs just like Python does. It's interesting to see how little you understand what you're talking about. Because What Python does is, during parsing, expand tabs to the next tabstop with a fixed, non-configurable tabwidth of 8. Haskell does the exact same thing. Hence the risks and issues with mixing tabs and spaces in their source code as the visual aspect of the tabs may have no relationship with how the parser handles them. Rejecting hard tabs altogether conveniently fixes the issue entirely, and provides the same visual experience no matter where elm code is viewed as &gt; An advantage of tabs over spaces is that you can configure those to be as wide as you wish visually on your editor in your editor yes, in most other contexts (terminals, web pages, …) no. Spaces provides consistent visual style across most display substrates. That's especially important given Elm's compiler has a strong tendency to echo your code back with decoration in error messages, mandating and enforcing spaces means a much easier time doing that.
&gt; Elm is the wrong language for you if that's what you seek. It very much makes a number of choices (syntactic, semantic and architectural) for the developer, with no "liberty" or "personal flexibility". You may want to look at e.g. Purescript instead. Oh, I'm not giving up on Elm that easily just because a couple of people are scared that a different code style might break things... 
You're missing my point. I'm saying that the values you claim to have are broadly antithetical to the Elm project's avowed goals. You're also apparently missing the point of code styles, and why Elm tries to enforce one across all projects.
&gt; I'm saying that the values you claim to have are broadly antithetical to the Elm project's avowed goals. You're getting way too broadly philosophical on me here, I was talking of whitespace and a little bit of syntax, nothing more, definitelly not of architecture or design. Besides, the elm style guide doesn't even mention tabs/spaces, it only says _"Do not be a maniac with indentation."_ on which can agree wholeheartedly. Or is there someplace else where I can read up on these "avowed goals" you claim Elm has? &gt; You're also apparently missing the point of code styles, and why Elm tries to enforce one across all projects. I am definitely not missing the point of code styles. But yes, I am missing the point of trying to force one code style across ~~the known universe~~ all projects, I've read way too many code style guides (many of which claim they're the best one) and I'm reading to much code written in different styles on a daily basis to believe in such a utopistic idea. 
&gt; That's especially important given Elm's compiler has a strong tendency to echo your code back with decoration in error messages, mandating and enforcing spaces means a much easier time doing that. I don't see how that's a problem, this has been previously solved in a number of languages. 
Front end to a derivatives pricing system written in Haskell. Interested in FP approaches to the frontend, including Elm. Should be able to work with Haskellers :)
If my comment came off as hostile, I genuinely apologize. It honestly was not meant that way, but rereading it now, I can see how it could be received that way. My point was that Elm is opinionated and imposes many constraints on the developer (not to mention FP itself). It tries to make it hard or impossible to do "bad" things. "Bad" is definitely a subjective term, but let's say for the sake of this conversation that it just means "something not in line with Elm's philosophy". In learning Elm one has to learn to work within these constraints and the hope is that one will come to realize the benefit of doing so. And frankly, using spaces instead of tabs is literally the easiest constraint to work within that I can think of that Elm imposes on the developer. In the case of tabs vs. spaces, the "bad" thing (at least this is my interpretation) is inconsistent code style. I don't think tabs vs. spaces is the issue so much as simply choosing one and enforcing it for the sake of consistency. Consistency has much more benefit in a programming language than just aesthetics. It makes reading the language (for both humans and machines) _much_ simpler and that in turn makes things like adoption, reading/understanding code, tooling, and syntax highlighting/editor plugins simpler, less expensive and easier to develop. I get that only allowing spaces might irk some people. What I don't really understand so much is it irking them so much that they refuse to see the benefit the consistency that comes from that constraint. Especially when they are still new to the language. Furthermore, I think to come into a community and suggest that such a decision is rude is petty and rude itself. Throwing an H into "IMO" at the end of your post doesn't make you or your opinion humble. 
&gt; So you're standing up for the freedom to do worthless customisations? Yeah, or rather customisations that seem worthless to someone else... &gt; It doesn't need to if that's handled by the compiler Ah, ok, _"The implementation is the standard"_, I see... &gt; Things like the Elm Architecture, mandatory semver, removal of faulting constructs or feature restrictions, etc… all point towards a restrictive "elm imperative". So far, Elm seems like one of the fewer JS frameworks that let me structure my project the way I want and seems to me less restrictive in this regard. This is also evidenced by some of the examples each of them having a different structure. IMHO. &gt; It's the exact same one as within a single project, with the bonus that projects don't need their own code style since they get one out of the box. Larger projects are going to need their own style and overall design considerations anyway. Also, if the syntax rules get too restrictive for my taste I can always use my own code style + `elm-format` or some other tool as part of the compilation process, it would make no difference whatsoever as the language needs compiling anyway. I already use JS minifiers in the pipeline. Project I'm (trying to) use Elm on right now is written in Python, JavaScript, and Elm with the possibility of other languages joining in as well. Now, which of these languages should dictate the overall style? Or should each part be in a different style as dictated by the specific programming language of each? Doesn't that kind of beat the whole purpose of the "harmonizing the code style" effort, observing that the result is not a harmonized code style? You see, no matter what, there's _always_ going to be either a mixture of styles or non-conformance with one of the offical styles in my project. Look, Elm is a young language with a narrow focus, so this restrictivness makes sense _now_, but as it matures and grows (provided that happens, and I believe the potential is there), there's going to be a shift from a specific use-case to a more general one, which is a phenomenon that almost always happens in programming. And so I believe a more colorful world will be embraced at some point. In the meantime, you can, of course, try to only allow a specific dress code at the party. 
Highly recommended. This is the video that got me interested in Elm. I paid for the Beyond the Basics one and am enjoying that one as well.
I've used an ML family language that does not have white space sensitivity (Ocaml) and there are a lot of awkward situations caused by it. Consider pattern matching with this contrived example: case list1 of x :: xs -&gt; case list2 of y :: ys -&gt; ys [] -&gt; xs [] -&gt; -- white space is used to know which case this belongs to [] Ocaml doesn't know how to parse this unless you bracket the outer cases with begin and end keywords. It would consider the last case to be redundant in the inner case expression. Ocaml also has statements which end with `;` and that causes similar problems. If Elm's compiler considered tabs equivalent to some number of spaces, these cases might look syntactically and/or logically invalid in your editor if the file mixed tabs and spaces which happened regularly in the early days of Haskell. I agree about the trailing comma in lists though. When languages don't allow a trailing comma I tend to use this style: list = [ thing , another thing , last thing ]
Agree. This is awesome!! I wasn't sure how good the course would be for someone who's not an Elm beginner, but the videos are excellent even for those with some Elm experience.
&gt; I paid for the Beyond the Basics one and am enjoying that one as well. I am planning on buying it as well. Just have to internalize the basics first. Very confusing coming from a OOP Javascript world. I believe Elm will stir things up quite a bit. I am so tired from the JS ecosystem...
I come from an OOP *NON* javascript background (although I do have a trifling of FP experience). Elm has brought back some of that wonderment at a new thing for me.
I would have a model : { ... | popup : Maybe Sometype } and a function addPopup content popup = case popup of Nothing -&gt; content Just (SomeConstructor data) -&gt; makeSomePopupDiv data :: content Just (SomeOtherConstructor data) -&gt; makeSomeOtherPopupDiv data :: content
This is called a "light box" or a "modal"
I'm not sure if I'm violating any advertising rules in /r/elm by posting this here, but I'm not affiliated with Richard or his book in any way. I've had my eye on "Elm in Action" for a while, and figured I'd share so others could take advantage.
Then how does javascript does it?
If you're referring to the library you posted, that's a node.js library, i.e. It's on the backend.
elm-ui has modal dialog too I believe. http://elm-ui.info/ Theres also: https://github.com/krisajenkins/elm-dialog
Also had my eye on it. Thanks!
Not sure if trolling or...
Your post is 7 hrs ago, but I'm not seeing the sale... did I miss it?
I know! And what's been fascinating is how quickly this has become "Best Practice". When new Elm users now ask about "parent-child communication" or "modularization" all the advice I now see is about how Flat and Wide is better than Nested and Deep - the conversation changed almost overnight. 
`TextField` renders a standard html `&lt;input&gt;` field (by default), so you can wrap it in a `form` and bind to the `onSubmit` event on the form. This works if there is only a single input element in the form or a submit button.
There is a bunch of discussion on how to do this better, so expect that things will change/improve rather quickly. &gt; sometimes you need to report something to a parent This is a warning sign that you are thinking too much with 'objects' and this is a pattern which leads to difficult-to-maintain code. A module is just a collection of functions for getting something done. It doesn't have to be and often shouldn't be an independent wigit. I would recommend Evan's [API design session](https://www.youtube.com/watch?v=KSuCYUqY058) for elm-autocomplete to get a feeling about how to design these modules. &gt; some changes cause HTTP requests, some don't Handling `Cmd`s can be a bit of a pain. Check out [elm-return](http://package.elm-lang.org/packages/Fresheyeball/elm-return/latest) for a standard way to handle `(Model, Cmd msg)` as a composable type.
There's an issue about this, but apparently this one-and-only xml parser isn't good enough according to the author, and I respect his wishes.
The Elm Architecture actually maps quite closely to how Rails implements MVC. * Elm msgs map very closely to Rails routes. * You match against them to see which code to dispatch too * The update function cases map closely to Rails controller actions * Should do minimal work to mould the input in to a format that you can then dispatch to the model code. * Some controller actions will result adding a background job to a queue (like making a HTTP request) and update the model when it's complete. * The view functions map closely to Rails erb views. * produces html output of what the user should currently see * includes links that call routes (ie. Elm msgs) to perform actions * can be broken up in to smaller partials (ie. functions) that either need to now about app specific routes (and are thus less reusable) or need routes passed. * Functions that modify the model, nested update functions etc. relate closely to Rails models methods. * most of your 'business logic' code is here. It doesn't need to know about the controllers, routes or views. * contains types and functions to modify those types in ways that make sense for your problem domain. 
Maybe you'll like elm: https://github.com/pzavolinsky/elmx
It has afaik. 
&gt; 1] Isn't the list syntax a bit verbose for modelling a view? No. There are some things to be said for allowing [a trailing comma](https://twitter.com/garybernhardt/status/635918662793166849). &gt; 2] My second question is why attributes are not written as records? A record has a concrete type. What you propose would require the code to look like this: div [] [ button {defaultButtonAttributes | onClick = Just (Something withParam) , text = Just "Nothing"}] Also, `defaultButtonAttributes` record would have to be quite large. This also limits some crazy attributes that for some reason you might want to add to your element. The current approach also allows you to specialize a `button` to have that interface (limit it to onClick and text, maybe a class) myButton : { onClick :msg, text : String } -&gt; Html msg myButton attr = button [onClick attr.onClick] [text attr.text] 
Oy. Where is this syntax documented? I find a lot of Elm somewhat non-discoverable and the docs aren't good enough yet :(
You'll need one of the test runner packages (they're mentioned a ways down on the [elm-test package page](http://package.elm-lang.org/packages/elm-community/elm-test/latest)). For example, I use the [HTML runner](http://package.elm-lang.org/packages/rtfeldman/html-test-runner/latest) like import Test.Runner.Html as HtmlRunner main = HtmlRunner.run mySuite
Wow, that worked (thank you!), but I don't understand that at all. I'll have to read more about type constructors I guess. I also don't understand how: type Items = Items (List Item) and type Items = List Item are different and why you'd want the latter, and if you wouldn't, why is the redundancy in the former necessary.
The big problem that I see right off is that the time zone data is inlined in a special format. Time zone data changes so frequently, what is a developer using the library supposed to do when the data listed here gets behind? Wait for a new version? Build a script to edit this package? It's much easier for the developer if the library either relies on time zone data as external to the package in some way, like an online API or flat text file. Integrating such a text file in Elm is currently problematic, so I sympathize with the problem, but these are the realities of representing local time.
Yeah, since the `Html` type is opaque you can't easily write view tests and you may need some sort of external tool. (I confess I am getting out of my depth here - I'm coming to Elm from C++/Scala as my first experience doing front-end programming, so I'm not very familiar with the tools available.)
Elm is intended to transpile to javascript. However, there exists a suite called electron which allows HTML/css/js applications to be run as native desktop apps. There are some bindings for elm.
Compiling to Javascript is fine. I'm having trouble understanding how to run that Javascript on the command line via node though.
I created an elm node.js example https://github.com/leobm/elm-node-example I modified and extend elm-node so that it runs with elm-017. But this is all very experimental, incomplete and not production ready. https://github.com/leobm/elm-node/tree/cfc1e6c64f424e01c97306b4bcf44a61ee106802
Large order, can't answer everything, but I'll at least chime in: Re: interop with Dojo. TL;DR: You can do it, but it will require a lot of work. AFAIK there is nothing comparable with the React Elm Components (https://github.com/evancz/react-elm-components). That means that you will probably need to create an integration bridge of your own via ports (meaning further that a lot of the type safety goes away in interop). Most people who interop with the existing JS world comes from a React background, I still haven't heard anyone using Dojo / Elm. But it all depends on how hands-on you are ready to be. compile-time failures, not runtime: will depend a lot on the answer above. linting: if successful, it shouldn't be needed as much. Don't try to lint Elm output, the Elm compiler takes care of the Elm part. For the Js part, you can, of course, plug in ESLint or other linter to guard only JS sources. test coverage tools: not much ideas, anyone else? FWIW found an SO question about this: http://stackoverflow.com/q/33205048/288672 packaging &amp; deployment: Maybe elm-webpack-loader can help you: https://github.com/rtfeldman/elm-webpack-loader Dojo AMDs: yes, that will probably be difficult, there's an issue https://github.com/elm-lang/elm-make/issues/50 in elm-make that talks about this. Maybe the latest version is your friend here.
Use the ports. It is possible to port the code but it is better to use the ports for that kind of functionality. There is a promised `persistent-cache` library that will take care of that kind of functionality. We don't know when it will be available but, in the mean time, use the ports. 
I'm using a similar setup to yours with my game and I get very smooth animation. I use AnimationFrame.diffs and I draw everything and calculate everything (physics, collisions, AI) every frame. I'm using mostly SVG polygons, points, and rectangles, but even with a couple hundred things moving on the screen, it's still pretty smooth. Are you using Chrome, by the way? I get choppy animation in Firefox and Edge, but I think it's because the size of my list of game objects is always in flux, so there's a lot of garbage collection, which shouldn't be happening in your game currently. Chrome, Safari, and their derivatives all handle it well, though.
Did you try looking at other libraries which implement native modules and also happen to work with 0.17.1? As far as I understand, packages like elm-lang/websocket have to use native modules. So if your question is "Is it even possible to make native modules work with 0.17?", then the answer is yes. However, just as you, I didn't stumble upon any guides yet.
I recently had the need to write some native code, too. I watched https://elmseeds.thaterikperson.com/native-modules and it helped me out. I also referenced https://github.com/evancz/elm-markdown/blob/master/src/Native/Markdown.js
Haven't seen any guides. I cargo-culted some native code by just finding the implementation of Debug.log, which is relatively simple. Seems like its a little cleaner now than in 0.16.
I didn't analyze your code so I can't tell you whats wrong. But I do get smooth frame rates for my game which also uses `AnimationFrame.diffs`, so something else must be wrong. Hope you figure it out! For most games a variable delta time (dt) is fine, so keep that if possible, as it is much simpler. Some games however do require a fixed dt for their logic, e.g. a physics based game with a replay functionality. If you want to know how to run your game logic with a fixed delta time while keeping the rendering at a variable frame rate, I could provide an example. Once you get to actually drawing cool stuff on the screen, you might be interested in trying out my library: https://github.com/Zinggi/elm-2d-game It's still pre 1.0, so the API **will** change before I publish it. Also a small tip: In elm we usually [use the data structure as the last argument](http://package.elm-lang.org/help/design-guidelines#the-data-structure-is-always-the-last-argument).
Thanks for this!! I think this is almost exactly what I need. I started down the path of using Semantic UI without the Elm bindings, but this looks much more compact for what I actually want to do. I think I'll have a go at using this library and animating it with elm-style-animation (https://github.com/mdgriffith/elm-style-animation). Thanks! 
Maybe have a look into PureScript as well.
Yeah, I second /u/Zinggi57's suggestion. I think you will have the best time with this route, and elm-style-animation is nice :)
A hashtable is an intrinsically-imperative data structure, because the only way to insert a new element in O(1) is to modify the underlying array in-place. Since Elm is a purely-functional language, there is no chance Elm will ever have a hashmap type into which you can insert values one at a time. I can easily imagine a O(n) `freeze` operation which would turn a Dict into a read-only Hashtable though.
It looks like you want to unpack the Maybe. You can do it like this: List.head ["hello", "world"] |&gt; Maybe.withDefault ""
Why do you want to pipe here? You could just do this: case List.head ["hello", "world"] of Just message -&gt; message Nothing -&gt; "" If you *really* want to use pipe (I wouldn't recommend it) you could do it with a lambda: List.head ["hello", "world"] |&gt; (\h -&gt; case h of Just message -&gt; message Nothing -&gt; "" ) And of course, as /u/jediknight already suggested, `Maybe.withDefault` is the best in this particular example. 
Honestly, I would start with basic html, css, and Javascript. Elm abstracts so much of it, it's really good to have a working knowledge of those 3 just to know what it is you want to put together. Otherwise you'll be starting at such a high level you'll have gaps. Not that it couldn't be done, but it would be like learning in reverse - you want to have some knowledge of html and css to even know how to make the elm templating do what you want in the first place, let alone the logic parts of it. You can use lodash as well, start getting used to some of the functional ideas, but while having the flexibility of regular Javascript as well. There are some things that are very difficult to implement in elm without the use of ports and and understanding of what Javascript can do in the first place
[Record extension syntax was removed in 0.16](http://elm-lang.org/blog/compilers-as-assistants). Scroll down to "Simplified Records" for reasons. 
The best approach is to kindly ask your professor to provide extra information. There is the curse of knowledge where one knows something for so long that they forget how it is to be a beginner. The professor should provide you with the appropriate materials and should clarify terms. The advantage of going this route is that if you are puzzled, others are most likely to be puzzled too. So, if you speak you will be their hero. :) Have you seen the Elm Guide? For example [Core Language](https://guide.elm-lang.org/core_language.html) chapter should clarify at least parts of your list. 
Wow, that's rough if you never had any programming before.
You're right, there is a lot of prerequisite knowledge which teachers take for granted if their target audience is programmers. And that's a good thing: if they didn't take it for granted, there is so much material that they would have to spend the entire class on that prerequisite material and they would never get to the subject they actually want to teach! Assuming your class targets students who already know how to program, my advice would be to start with a class which targets non-programmers, and to come back to the Elm class afterwards if possible. That being said, "case" and "cons" aren't part of the vocabulary which every programmer is expected to know, so if the class doesn't explain those terms, I'd ask for a clarification, you can't be the only person who doesn't understand what they mean. As for the terms which every programmer is expected to understand: A list is, well, a list, like a shopping list or a list of chores you'd like to accomplish today. Your program manipulates all kinds of things, including pieces of text, numbers, lists of things to buy, and lists of chores to complete. Learning how to use a programming language involves learning which kinds of things the language is able to manipulate, and learning how to tell the language to perform certain manipulations on those things. "case" and "cons" are concepts involved in some of those manipulations. Learning programming itself involves learning how to use the simple things which programming languages allow you to manipulate directly, like pieces of text (usually called "strings") and numbers and lists, and assembling many of those to represent and manipulate things you care about, like shopping lists and lists of chores. A type is a set of related things which can be manipulated in the same way. For example, 2 and 6 are both numbers, so you can do the same kinds of manipulations on both, for example dividing them by 2. So they should both have the same type. Some languages call this type "Number", but most of the time languages choose "Int", for "integer". Another example is "hello world": its type is String. "hello world" is not an Int, so you cannot divide "hello world" by 2, but you can perform other manipulations such as reversing it, obtaining "dlrow olleh". Good luck!
There are a few questions you can ask to see if this is actually a problem: - **How big are your graphs?** Say your graphs have less than 1000 nodes. Lookup with O(log2(n)) means a lookup will cost ~9 dereferences. It's not 1, but it's also not the end of the world. - **Are the graphs static?** If so, you could assign each node an integer (an index!) and put them in an `Array`. Now your lookups are O(log32(n)) so 1000 nodes means ~2 dereferences, so not bad at all. There are also data structures like [integer maps](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.5452) that may also be nice for your case. I don't know of an Elm implementation of this data structure yet, but I also see no reason it cannot be done!
Thank you for the pointer. The referenced discussion on Github was especially interesting for me, because my use case was "extensible models" like those [described by rgrempel](https://github.com/elm-lang/elm-compiler/issues/985#issuecomment-136056202). I guess I agree with rgrempels comments (withdrawn later) that without field addition records are "extensible in terms of the type system, but not extensible at run-time" which "seems like a strange gap". But I realise a decision has been made to prioritise simplicity and performance despite those concerns. I'm afraid, there does not seem to be a point in arguing for resurrecting field addition and deletion now after the discussion has already happened.
Whoa, a university is teaching Elm? Which one?
You are dumb.
Html and css yes, but js is not necessary for knowing Elm. You don't need to understand mutation and objects, and having types to guide you will help. 
Have you taken a look at [guide.elm-lang.org](https://guide.elm-lang.org)? The chapter on [The Elm Architecture](https://guide.elm-lang.org/architecture/) starts with `beginnerProgram`, and then tries to smoothly transition into `program`, introducing commands and subscriptions gradually. The transition starts [here](https://guide.elm-lang.org/architecture/effects/), and the examples in that chapter are all available in [this repo](https://github.com/evancz/elm-architecture-tutorial). I would recommend that path! If you *have* checked it out already, which was the example that you started getting stuck on?
For what it's worth, I found artwelf's explanation around subscriptions and commands much more informative than what's available at elm-lang.org. Your approach of sugar coating concepts might be better for some people, but it's definitely not for everyone's taste, so I definitely don't think it is harmful (I came out with a better understanding of said concepts).
It is not difficult to build intuition about monads. The problem of all monad tutorials is that they try to explain *monads* themselves, but the right way is to explain *why we need such abstraction at all*. And it is very easy to explain it starting with wrapper types. With *not wrapped* types you perform pure computations. But sometimes we need to encode not only the result of pure computations, but also *something else*. For example, you want to calculate the distance between 2 points. You write the function using a *Float*, but you want to encode as well that the distance should be in centimeters, not in inchs. You wrap your *Float* to the wrapper *Centimeter* and get the type *Centimeter Float*, encoding this additional information (*something else*) in the wrapper type. Now you cannot accidentely use the result of this function in other function which expects the value of type *Inch Float*. We use wrapper types also to encode not fully determined functions like divisions, which is not determined for 0 (with the wrapper type *Maybe*). Every time we want to encode not only the result of our pure computations, but also *something else*, we use wrapper types. But if our wrapped value holds not only the pure value itself, but also *something else*, how do we chain computations with wrapped values? It is the case where we need monads. Monads are just the composition of functions dealing with wrapped values, where you encode what you should do with unwrapped value and what you should do with *something else* encoded in the wrapper. Sometimes you have wrapped value which encodes **either** the value **or** something else. In that case we can represent monadic operator *&gt;&gt;=* (bind) in imperative pseudocode as the chain of if-expressions: composeMonadicFunctions(func1, func2, wrappedValue) = if (wrappedValue holds value) then apply func1 to the unwrapped value return computed value wrapped with the same wrapper to the func2 else (if wrappedValue holds somethig else instead of value) then return something else and ignore all functions Sometimes your wrapped value encodes the pure value **and** something else. In that case your monadic chain of functions executes the pure computation with the wrapped value **and** does something with *something else*. 
Anything taken to an extreme will of course be less helpful than it could be. Going 100% theory isn't any more effective than going 0% theory. And, people prefer different routes, of course. I like to have both, but I favor the fundamentals and theory. Colleagues of mine are more "jump in" types, where I am a "learn a bit before leaping" type.
I can't speak for OP, but I got stuck on the `Random` example. I've worked through it, but for some reason the Generator pattern was a level of understanding just a hair's breadth too far. The HTTP one I think I got a bit easier (maybe because Random softened it up for me?). You call a thing, you get back some data. All you really needed to know was the URL to call; very little setup needed. But just as anecdata, since you asked.
I'm not sure this explanation is that good. It's not bad but some monads are not a single value, like lists, and some monads don't really have the *something else* part, like futures or promises or tasks. And Identity is a monad as well. I think any attempt to describe what monads are for fails because the concept is so vague. I think monad intuition is built on top of intuition for map and join (or flatten, flatMap is such a better name), since bind is map and then join. And then showing how flatMap's type allows chaining closures together in a way that map does not.
&gt; @gelisam On reddit, the syntax to ping other users is "/u/gelisam". In this case you were replying to my comment so I was notified anyway. &gt; dictionary/map/hashtable-like data structures This is the crux of the issue: in most discussions, those three words are interchangeable because they are all used to associate values to keys and to later lookup the value from the key. In this conversation however, the distinction between Dict and Hashtable matters because the OP (the Original Poster, so /u/Keith) specifically asked why Dict is implemented as a tree and not as a hash table. Even though both implementations support the same operations, they have different performance characteristics which the OP cares about. &gt; Underneath it all I believe they are big Trie structures. Binary search trees, tries, and hash tables are all implementations of the dictionary interface, but they have different performance characteristics. Moreover, in a functional programming language the name "dictionary" denotes a slightly *different* interface, which I will call "immutable dictionary". The difference is that a mutable dictionary's update operation is free to destroy information by mutating pointers etc., whereas an immutable dictionary's update function must return a new dictionary. In an imperative language, if there are several variables which point to the same mutable dictionary and you update the dictionary via one of the variables, you want all of the variables to point to the updated dictionary. In a purely functional language, if there are several variables pointing to the same immutable dictionary and you update the dictionary via one of the variables, you want all the other variables to continue pointing to the old dictionary. The reason I am saying that a hash table is intrinsically imperative is that in order to get the average-case O(1) update which is characteristic of the hash table, you have to mutate the underlying array in-place. This would of course affect all the other variables which were pointing to the same dictionary and therefore to the same array, so that would not be a correct implementation of the immutable dictionary interface. At first glance it might seem like binary search trees and tries suffer from the same problem, because modifying the pointers in those data structures to reflect the newly-inserted element would also affect the other variables. But since those are tree-based representations, there is a standard trick which can be used to turn those imperative implementations into immutable implementations. The trick is based on the observation that the tree after the update will look a lot like the tree before the update, only a few of the nodes will have changed. So instead of mutating those nodes, we can create new nodes corresponding to the ones which changed (and also up to O(log n) ancestor nodes), and keep all the other nodes as is. This way, the old variables can continue to point to the old nodes and the update function can return a new dictionary which points to a mix of old and new nodes. This trick only works with trees, it doesn't work with arrays. &gt; the underlying implementation may always be immutable, but exposed at the right abstraction (Elm in this case) it becomes immutable in practice. Assuming you meant that the underlying implementation is *mutable* and that it can be exposed via an immutable interface: unfortunately this only works for functions, not data structures. An imperative implementation of a pure function can temporarily create imperative data structures, mutate them as needed in order to compute the right result, and construct an immutable data structure as its result. Since the imperative data structures are only visible inside the function, they do not interact with anything else in the program and thus they do not cause any other variables to suddenly point to a new value when we don't want them to. So that was functions. If you try to wrap an imperative data structure in an immutable API, on the other hand, operations like update will be problematic. Since the imperative data structure already exists before the call begins, you can't mutate it and then return an immutable version, that would incorrectly cause the other variables to see the change. Instead you have to make a fresh copy and to only mutate this new copy. But for small operations like update, copying the entire data structure is ridiculously inefficient. It only makes sense for longer functions, in which you perform several imperative operations in a row in order to offset the cost of copying the immutable input (if any) into a temporarily mutable data structure.
Nothing wrong with that section. It is pretty good, actually. I just think different people learn in different ways. I'd rather read 3 paragraphs with all the technical detail that I need than 3 pages jumping through hoops to avoid saying monad or monoid. But that's just me and I completely agree that most newcomers would much rather read those 3 pages. The point I'm trying to make is that I think it's healthy to approach technical subjects in different ways, with different authors. Sometimes it takes a few different perspectives for things to "click". So, while I do understand artwelf's approach would be suboptimal as a section in the official docs, I don't understand your objection for said approach on a public forum.
Just wanted to say that I really like the podcast. Keep it up! (oh and I cant wait for the ukulele intro :D )
Use the `on` function and capture either `keyup`, `keydown`, or `keypress`. http://package.elm-lang.org/packages/debois/elm-mdl/7.6.0/Material-Textfield#on
&gt; I fail to see how data structures can't be immutable. Clojure, for example, updates will return brand new structures. they are fairly cheap too for many operations because they don't have to clone everything to make an update. I don't understand why you consider Clojure's hash maps to be an example of a mutable implementation of an immutable data-structure. Googling for its implementation details yields a [post](http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html) which explains: &gt; PersistentHashMap (PHM) maintains a very-wide tree, each node having up to 32 children So despite its name, this is an immutable dictionary implemented with a tree with O(log32 n) updates, not a bona-fide hash map backed by a single contiguous array with O(1) updates. So this is exactly the kind of tree-based immutable implementation I was describing earlier.
I don't know if other people feel the same way, but I think the header image on this series is really smug. It seems like you are calling your intended audience dumb. "People who disagree with me or who have different technical goals are lesser beings. Not even human." IMO this kind of thing is why people think functional programmers are elitist and smug, and I don't think you build healthy and well-regarded communities by name-calling other ones. Furthermore, this chart is really silly from a technical perspective. If you are programming embedded systems or operating systems, your goals mean that memory management is not really viable. C or Assembly are better tools for your goals than Elm or JavaScript. If you are doing scientific computing, it's different again! Each technology has different strengths and we can have opinions about that, but no one is *better* because they hold particular opinions and have particular technical goals. That said, the actual words do not seem to be this way. So maybe I am seeing that image different than you intended. What is the actual goal of the image? Does this perspective give you any desire to swap it out?
You're not seeing things. I kind of felt the same way after reading the first two in the series.
&gt; This reveals your programming experience. Does it now :D Ok, what are the other languages that enforce either? I'm not counting Makefiles as a programming langueage. Neither am I counting Befunge-type of things. 
Nope. Tabs people have already lost by statistics. Just get over it and move on. 
Okay, great! Do you see that your intent is not coming through clearly then? I guess it's an attempt at self-deprecation, but it reads like normal deprecation. The image is not labeled to be about you in any way. My feeling is, if the image needs 7 paragraphs of words to clarify its intended meaning, it probably is not saying what you want in the first place. (I also suspect this image is why this post did poorly on /r/programming.)
I never saw it as deprecation. We all start off as babies and grow and improve. To admit that is to admit the truth. To feel ashamed of your past ignorance is unproductive and unwarranted. I'm constantly trying become a better version of myself. This imagine chronicles that progression with plenty of room for improvement. If others struggle with their failings, then appeasing their insecurities with explanations that limit the meaning of this image doesn't speak to the truth but dances around it in the hopes to not upset anyone. If I've learned anything from the Internet is that this is an impossible task to accomplish. Someone, somewhere will find something to object to. To allow that fact to dictate how we speak is to give up having an opinion on anything. Something I refuse to do. 
Elm to Go is nigh impossible because they have no generics. We could possibly target something more low level, or monomorphize everywhere, but that has its own set of problems. 
Would you mind sharing thoughts on Oden? It seems like it could offer a basis for rationalizing an approach.
I strongly prefer to keep dependencies minimal and on the development side rather than the operations side of an application. Using Go, and Elm (+ Elm-&gt;Go) would mean that I can write and deploy exceptionally powerful projects as a single binary, nearly anywhere, quickly, efficiently, and without any deployment dependencies. *https://www.youtube.com/watch?v=KINIAgRpkDA
I think there would be very little value in a functional language compiling to Go. Go and Go libraries have a strong focus on exposing memory layout, where as functional languages intentionally hide memory layout. The interop between a functional language and Go libraries would be minimal. 
Elm would likely have more success targeting LLVM than Golang.
As some sort of ducttape solution; one could use Otto, the Golang V8 Engine to power compiled Erlang and use some predefined environment functions to communicate. It'd be absolute ducttape, but Elm already runs (theoretically) in embedded golang solutions. (via Javascript)
&gt;Notice that we had to write the currying part by hand. (No) &gt;Functional Programming ideas that have been around for over 40 years will be rediscovered to solve our current software complexity problems. (see (lisp))
\#1 sounds fine. I like using [`Basics.extra.never`](http://package.elm-lang.org/packages/elm-community/basics-extra/1.2.0/Basics-Extra#never) instead of `identity` in #2 - it's also handy in other similar cases (as long as you can wrap your head around what's going on with the types). No particular opinion on #3, but another few things I noticed looking through your code: * Is there a reason you're using `andThen` on line 75 when you could more simply use `Maybe.map .duration`? Is it just for symmetry? * I notice you've commented out the 10-millisecond line, but as was [recently discussed](https://groups.google.com/d/msg/elm-discuss/ojj7LyXSCZk/EBQifv5xAgAJ) on the [elm-discuss](https://groups.google.com/forum/#!forum/elm-discuss) mailing list it's better to use the [animation-frame](http://package.elm-lang.org/packages/elm-lang/animation-frame/latest) package if you want very fast ticks. * I recommend using [elm-format](https://github.com/avh4/elm-format) for everything =) Can take a bit of getting used to, and the amount of whitespace can initially seem excessive, but I pretty quickly came to like its style - it's very clear and easily scannable. 
&gt; Assembler doesn't have generics either Assemblers also don't have types, so all code is generic. An assembler doesn't care about *void versus *T for some type T, so generics are easy. Dealing with too simple types is harder than dealing with no types. &gt; Well, Go certainly has generics, they're just working differently and called interfaces. So how would we translate a function with this type into Go? map : (a -&gt; b) -&gt; List a -&gt; List b I see a few options: 1. Monomorphize it, i.e. for every use, create a copy with the types filled in. 2. You use void pointers, or `interface{}`, or however you would do it in Go, to write a version of the function that works with anything, and then just use casts to get the right types out at the end. Maybe I'm missing something? I'm certainly not a Go expert. 
Are the LISP and JS versions interpreted, or compiled? I can certainly imagine writing an Elm interpreter in Go. But an actual translations? Like I said, if it's possible, how would you compile Elm's `map` into Go? I get how the interfaces work in Go, but that's ad-hoc polymorphism/overloading. There's no parametric polymorphism in Go, and while I'm sure it's possible to fake it, I'd like to see how to do so from the people who seem to think it's possible.
&gt; Like going through Haskell to JS sounded like it'd save work in the early days, and I'm glad I did not do that Could expand on that a bit more? What pitfalls or issues did you run into that made you feel that way?
For sure- each language optimises for different things. Erlang is very much about ease of maintenance and system durability and as a result building an Erlang release is not nearly as easy as cross compiling a Go binary.
&gt; The Task.perform identity identity solution a lot of people end up in is being fixed as we speak and 0.18 will have two functions, one for failing tasks and one for tasks that don't fail. Good to hear. Sounds like it'll be more intuitive in 0.18.
&gt; Is there a reason you're using andThen on line 75 when you could more simply use Maybe.map .duration? Is it just for symmetry? I was having trouble accessing a Maybe value inside another Maybe value in a way which didn't seem too convoluted. I think using `andThen` let me get away with using fewer parenthesis, which seemed attractive at the time. &gt; I notice you've commented out the 10-millisecond line, but as was recently discussed on the elm-discuss mailing list it's better to use the animation-frame package if you want very fast ticks. I didn't look into this since I wasn't doing fancy animations, but I guess a constantly changing number qualifies as an animation. &gt; I recommend using elm-format for everything Thanks. Looks like this will complement elm-mode.
Not sure what "similar" means to you, but maybe take a look at F# / OCaml?
Haskell is the obvious choice. A lot of people who like Elixir also like Elm. I'm one of them. So I say check out Elixir.
&gt; haskell is an obvious choice too, but a bit too complicated for me Hmm, I agree that Haskell is intimidating, but with Elm experience under your belt, it shouldn't be too hard, no? Nowadays, when people ask me for tips about learning Haskell, I tell them to learn Elm first. Since Elm is pure, has Haskell-like syntax, parametric polymorphism, algebraic datatypes, monadic composition (`andThen`), and the philosophy of eliminating bugs by making illegal states unrepresentable, it seemed like a great way to learn the basics without getting overwhelmed. Pretty much all that's left to learn in order to use Haskell are laziness and type classes, the rest is mostly more advanced types to make more subtle states unrepresentable and you don't have to use those if you don't want to. So I'd be curious to hear why Haskell still seems complicated to an Elm programmer? I hope I haven't sent people down the wrong path by telling them to learn Elm first.
Yeah, Horizon is going out the window....I would recommend firebase...I'm working on a port to gundb too
Personally, I can't even figure out what I'm supposed to download to get started in Haskell.
Yeah, there was a debate in the Haskell community recently about the fact that our [downloads page](https://www.haskell.org/downloads) lists too many alternatives, which might be overwhelming for beginners. There is a group who created an [alternative, more beginner friendly homepage](https://haskell-lang.org) for this reason. Their [getting started page](https://haskell-lang.org/get-started) is indeed much more streamlined, you should be able to get started quite easily.
RethinkDB and Horizon are under good licenses and the community might keep them alive. As for Firebase... Google killed a lot of products. I would not be entirely shocked to see it go. :) 
Yeah, I saw that on the slack channel, but my friend who is a really good programmer said once a project like this loses funding, the project slowly dies away
What's important to you? OCaml and F# are strict like Elm and have similar type systems. Haskell is pure like Elm (no side effects), but has a much more powerful, and complex, type system. Rust is radically different from Elm, but similar in philosophy and pragmatic approach. 
Yeah, I really liked it
Thank you for the image! Incredibly helpful. Edit: Found the css thorn! The element containing the content needed the css class word-break defined.
Do you want your players to cheat? Because that's how you ask your players to cheat.
Try Stack for the build system/compiler install, and I think Spock is a relatively simple webserver. 
I'm working with F# currently which has a lot of similarities with Elm. F# has everything you could possibly want for a server side language - it's part of the .NET framework so can use all the libraries available (which cover pretty much any use case you're likely to encounter). I would also add I'm using it on my Mac and deploying to Linux (in case you think Microsoft's association with F# means you have to use Windows).
actually I love this kind of libraries. I'm also a huge fan of Feathers.js, but after using Elm a little you feel like javascript is such a stupid language. but for small projects all of this libraries are the most sane solution. I don't need to have a full rails app just to put something in a database and have some validation logic.
At my company are using Elm on the backend via `lukewestby/worker`[0] to power workers that subscribe to RethinkDB changefeeds via ports then check for missing or expired cache entries and trigger appropriate API requests (via ports), the results of which are received (via ports) and parsed, processed and stored as new entries in Rethinkdb (via ports). We've found that Elm isn't quite as high leverage for this as it is for the front end work it was designed for, but it brings many of the same traits that make it awesome on the front end to bear on the backend as well. The most obvious example is that it's amazing to have Elm's wonderful error messages when working on the back end. Another is the ability to make it so that all of the messy state management is handled correctly by a framework that only has to get it right once and then developers are left writing only pure functions in their day to day work. Of course this could be accomplished with other languages as well. At a great Elm talk he gave at the BoulderScript meetup last night Kyle Kress made the point that if you want what Elm has to offer on the backend you have more choice, and specifically you access to more powerful languages like Haskell, OCaml, F#, etc. This is something we are exploring as well, but we don't think the argument is as clear cut. For example, Kyle also made a point that in order be productive in Haskell you have learn what a Monad is so you have to learn what an Applicative is so you have to learn what a Functor is so you have to learn what a Semigroup is... and after several months of study of category theory you can write your program that shuffles bits from once place to another. Now obviously this is a bit of an exaggeration but the effect itself is very real. The time for mere mortal (non category theorist) developers to get productive in Elm is much shorter than the time to get productive in Haskell. (At least in our anecdotal experience.) We may one day abandon Elm for want of Typeclasses or zygohistomorphic prepromorphisms but as Kyle also said, for now it's at least a great stepping stone. And personally I think it's worth at least considering it for any new backend projects to see if it might simplify your stack (assuming you're already using it on the front end, and you should be :)) and provide at least some of the same leverage it does on the front end.
fixed! thanks for catching that.
This should be titled "why I like ELM". There's no reason to jump from performance, package management and so on to the clickbaity "future of the web". Good summary of ELM's strengths nonetheless.
Agreed!
I prefer naming after what has happened as well. I think Evan may have specifically changed the name from actions to Msg for this reason. As for http commands, Resp or Response is nice for success cases and Error or HttpError is nice for failures. I'm currently building a real time ticket in system using Elm for work and as the project grows, I realize how important this detail is specifically for Elm because of the lack of abstraction (language lacks HK types or type classes/module system.) Not the best language for a big spa imo, at least not yet Edit: typo, it's late
where the source?
How do you play?
https://github.com/nwjlyons/retrorace
I put a description when submitting my entry but I don't know why it doesn't show up. Anyway, I'd like to know how I can improve the code, especially on theses topics : - State modeling : The profile and repositories are 2 separate variables but I would have preferred a single one where repositories is a single field of profile. - Http calls chaining : When the user is retrieved, another request is made to retrieve his repositories. I'm aware of the `andThen` function but I need to store in the model the results of both calls so I don't know if the function allow to do that. I'm open to other suggestions as well ! Thanks !
Tip: use Maybe.withDefault instead case expressions in function displayProfile and repositoryView I will look deeper later
Here are a few random thoughts: * Calling anything with `""` instantly makes me suspicious. As a rule of thumb, if you don't have a value yet, use a `Maybe` type. Don't create fake data as a placeholder. So I would make `githubName` and `Credentials` a `Maybe`. This'll tidy up your SearchUser handling a bit. * I'd merge the data-loading result and error together, since you can't have both at once. (For a detailed explanation of why, see http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html) This would eliminate a whole class of UI-inconsistency errors, and simplify your `profile` function. * For your list-group-items, consider doing this: `List.map listGroupItem [ ( "E-mail: ", email ), ( "Blog Link", blog ) ]` `listGroupItem ( title, value ) = li [ class "list-group-item" ] [ b [] [ text title ], text value ]` HTH
Well, that makes sense ! There are indeed some uses cases I can think of where using andThen will be better. Thanks for the detailed explanation ;)
That's really a great example of an Elm application. Thanks!
properties is just a random json structure. theres nothing special about geojson thats not in json.
There is currently no way of iterating over elm record members. Records are static, so they are definitely the fastest. But if it makes sense to make the number of elements dynamic, or just for the sake of convenience of iteration, you could consider tree based Dict container http://package.elm-lang.org/packages/elm-lang/core/latest/Dict
ShumpEvenwood provided a good answer with the Dict solution. As for the question from the title: &gt; Is there a way to iterate over items in a record? There's no way and I think there's very little chance for it to change! Think about it this way: in order to iterate over a collection in a statically typed language, all elements of the collection must be of the same type.^1 To iterate over fields of a record, all fields would have to be of the same type and the Elm compiler would need to figure it out. In this one special case, the compiler would have to allow to call something like `map` on the record. It seems like too much hassle for a very specific feature, especially when there are already data structures like Dict or List which seem to be better suited for your problem. ;) --- 1: Though there are some attempts to [create heterogenous collections in Haskell](https://wiki.haskell.org/Heterogenous_collections) (collections with values of more than one type).
That's also a possible solution, but since OP said that "I need to access each one individually to get or change values. (…) grab an individual record by name when necessary" and that "Performance is really important here", using list is going to have much worse performance than Dict. I assume `condition` here is something like `motor.name == "motor1"`.
I'm planning to work on a dialogue game using Elm some time in the future, but mostly as a prototype/demo kind of thing for the time being. I have no idea if it's an idea I'd want to carry on with, so I can afford to be a little experimental. If you need to be able to support this UI choice post-release, especially if the app is for sale and you have to keep players happy, you may want to opt for the React/Redux route since it's the more well-supported platform for the forseeable future and offers a good number of the benefits of Elm when done well. It really kind of depends how much risk you can accept from your choice, imo.
Looks nice, will your blog series include an explanation how to play the sounds from Elm?
Right, that sounds reasonable. We are not really that far to be close to the production. Current UI is more or less crude and highly incomplete. I am not so sure about React/Redux support. I am swimming in those waters for a bit now, but there isn't a single way how to do things that could be considered as some sort of standard. Everyone kinda does it how they like it the most. That's something that got me interested about Elm as well, that there is very little space for dev stack decisions.
Yeah, that's true enough. The entire modern JS ecosystem is wild-west-style right at the moment and probably for the near future. You just can't escape that, unless you're willing to settle for older tech stacks like your currently jQuery infrastructure, which is fine too of course, but comes with its own hurdles (that you're probably trying to get away from). Mostly I mean that at least the React/Redux APIs are stable and there are lots of people working with that tech, even if there's little agreement about the "right way". Elm has been going through major API changes to structure itself around new design patterns in the last little while (particularly the v0.17 update), and there's no reason to think that won't happen again before there's a v1.0. The most recent big update was enough of an upheaval that lots of people were left scratching their heads and going back to the drawing board until they managed to grok the new concepts underlying the ways that dataflow was represented between models. It was a very big shift -- for the better I think -- but hard for people who are beginning to rely on Elm for more than trivial stuff. So that's sort of the basis for my cautious approach here.
Wait, what? So if I was DC'd from the net I can not use the `elm-repl`?
It downloads the core module on first use, apparently.
The question is if that's a good idea. What would be the motivation to not download it while installation?
Libraries are downloaded per project, makes multiple versions easier 
Or else use online repl http://elmrepl.cuberoot.in
It does, but that does not help you if you don't have it in the cache
There is also a discount code for $4 off!
That's pretty much a perfect use-case for Elm, and what I would do if I were writing a JS game. I wouldn't want to write the whole game in Elm, but interop is easy once you get over the learning curve. (And there is a big one.) On the other hand, Elm doesn't have as easy shortcuts for defining UI animations, but it can make them VERY reliable.
I'm not an expert here, only been using elm for a very short period, but currently I don't think getting compiler messages is possible. I tend to just use the Terminal tool window. Maybe get in touch with the plugin author on github?
Is it possible to get documentation when I hit "F1" on methods though?
Haven't tried that, but it should be possible to do with [`onWithOptions`](http://package.elm-lang.org/packages/elm-lang/html/1.1.0/Html-Events#onWithOptions). You need to pass [`contextmenu`](https://developer.mozilla.org/en-US/docs/Web/Events/contextmenu) as the event name and set `preventDefault` to `true` since [it's needed to disable the right click menu](http://stackoverflow.com/questions/737022/how-do-i-disable-right-click-on-my-web-page). There's also [elm-mouse-events](http://package.elm-lang.org/packages/mbr/elm-mouse-events/1.0.2) which implements [onContextMenu](http://package.elm-lang.org/packages/mbr/elm-mouse-events/1.0.2/MouseEvents#onContextMenu) already, but I think it doesn't stop the event propagation. I was able to find this package thanks to [elm-search](http://klaftertief.github.io/elm-search/).
Edit: It works now, I just used "oncontextmenu" instead of "contextmenu". I [did try the onWithOptions already](https://gist.github.com/roSievers/78f0a533b047d295d549453ae3db49d5) but it didn't suppress the context menu. I thing this is because [using preventDefault sets the event.preventDefault value](https://github.com/elm-lang/virtual-dom/blob/1.1.1/src/Native/VirtualDom.js#L504 ) instead of returning false from the event as described in your linked stackoverflow. 
Should I know HTML or CSS before this course?
Tell me about it.
You're right. Fixed.
&gt; I'll need to run the numerics in JS directly Are you certain that this will be faster? Elm's compiled code ends up looking much like JavaScript, and if you're smart with tail-recursion, things will end up as while loops. You could also reduce the performance hit by reducing the number of times you go in and out of ports, maybe by batching data, sending a bunch over through a port, then receiving a bunch back, so that few dynamic checks occur. If it's too slow still, your case (performance heavy) is one of the *very few* cases where you might want to use a Native wrapper. There's no official documentation for this, because it's only meant for the core libraries, but if you look how [core](https://github.com/elm-lang/core) is implemented, you should be able to figure out how to call your code directly. You won't be able to publish any libraries containing Native code, but that doesn't sound like a problem for your use case.
elm has really good error messages in the compiler, so at least that's something. No other language is quite that mix of helpful and able to catch errors at compile time. 
It's true that you can't write the function you want. (You can write many functions with that type signature, though.) However, it sounds like in your application, the `List a -&gt; List a` function is actually a filter. If that is the case, you can write a function `(b -&gt; a) -&gt; (a -&gt; Bool) -&gt; (b -&gt; Bool)` (it is just backwards function compositions, i.e. `(&gt;&gt;)`) which will convert the filtering function.
&gt; Hey folks. I'm trying to get into Elm &gt; What am I doing wrong? Native modules are a rather advanced concept available as the very last resort when one needs a certain kind of API. It is recommended that you approach this subject after you have a solid understanding of Elm and after you have exhausted the official, recommended JS interop way which is [ports](https://guide.elm-lang.org/interop/javascript.html). 
I have seen this in Aaron VonderHaar's code: https://github.com/avh4/elm-testable
Thanks for the comment. Yeah, I realize native modules aren't really the way to go, but some guy's module already uses it so I figured it wouldn't be too hard to make it work. I've found a bit of a fix/workaround. The module was defined as `_jtojnar$file_reader$Native_FileReader` when it should have been `_user$project$Native_FileReader`. I'm not really sure of the intricacies of this, I'll check it out later... but at least it's working now.
Thanks for the help. Now I understand how to solve this problem. I ended up just storing all my data in the Graph directly instead of building it from a list.
Vou gravar e jogar no YouTube depois, tu acompanha assíncrono se quiser ; )
It's also worth mentioning that problems like this are *literally* the reason Native modules aren't allowed to be published.
Thank you for this, definitely a good answer to the "How do I implement components in Elm" question.
tools written in elm, for use in elm development, something like the node test runner.
The game is very cool, but I think it is better to customize the action keys, because I prefer WASD (accelerate, left, shoot, right) A multiplayer version of this game would be awesome!
I don't think so, sadly. You might have some luck by including all components in the same program, and activate a different one through flags. Anyway, if you run the compiled .js file through uglify or google closure (simple optimizations), one of the things that will happen is that it removes all functions you do not use. This should reduce the size to ~80kb. When gzipped, it should get down to ~20kb.
&gt; As a side note, the whole JS world seems to be going this way -- one massive JS file that has your entire application, polyfills, runtime, etc. bundled, rather than you being able to divide your app how you want in smaller pieces. This is because in HTTP/1.x, only one request can be active on a connection at a given time, so your assets end up coming in in sequence, with each request having overhead. Bundling into a single blob increases performance in this case. HTTP/2 is multiplexed, so you can send lots of requests at the same time and the server can respond in whatever order it sees fit. This should cause best practices to shift towards having a more fragmented application, which will decrease load times and allow for more aggressive asset caching.
I'm beginning planning for 0.19 and having a really nice way to bundle files is one of the bigger goals I am exploring right now. Point is, there's no explicit support for cutting up files like this right now, but I understand it's important and will be trying to address it in a lovely way relatively soon!
That's how I've been doing it. Here are my build and watch commands: // Build: elm-make elm/*.elm --yes --output public/assets/javascripts/elm.js &amp;&amp; uglifyjs public/assets/javascripts/elm.js --output public/assets/javascripts/elm.js --compress --mangle // Watch: chokidar 'elm/**/*.elm' -c 'elm-make elm/*.elm --output public/assets/javascripts/elm.js' --initial Where each of the elm initializers are at the top level of the elm/ directory. Also my guess is that running each through that uglify command in the build portion would result in much &lt; 200kb
Thanks for sharing. It's always good to see how people approach the same problem differently. 
Haha actually it is the stack I use. So that's totally true
is there a way to make server side rendering to work with Elm?
I started trying this and immediately hit a roadblock. My current update function executes some tasks, and as such it seems that I can't easily abstract it away from Cmds. The effort of adding the kind of indirection you suggest might be more than is justified.
That sounds like a bug to me. Ideally, elm should be handling that case for you either by making the port work to not have an issue or by simply disallowing that variable name.
It seems that `new` is a valid key name: a = {} a.new = 3 a.new &gt; 3
I'm not convinced it is the same bug. It says: &gt; Only permit recursion when there is at least one lambda between the definition and the usage. So `x = x` is not allowed, but `fact n = if n &lt;= 0 then 1 else n * fact (n - 1)` is allowed because the definition implicitly introduces a lambda. In the above code, the early reference to `compute` is leading to a cycle, but since that reference is guarded by a lambda, it would be allowed.
Its [in the works ](https://youtu.be/DSjbTC-hvqQ) 
I can confirm, this compiles successfully on 0.18 (version from the Windows installer), and gives the following JS console error: TypeError: _p2 is undefined TypeError: runElmProgram is not a function
Open a bug report with the SSCCE.
Not at all, I would be honoured - glad I could help!
lol this is the intro to programming class. This is the first programming course in university, in first semester.
Yes, honestly this is the most disorganized, unstructured course I've taken at the university level. A lot of people dropped out and I think have a permanent scar about what computer science entails. Turned a lot of people off to even giving it a chance.
Cool, it's published here: http://poyarzun.io/blog/benchception/ If you're interested.
Nice, worked liked a champ!
Well, if this is part of the public API of a module, then yes, it needs a test, not only to check for bugs (even if the compiler can catch some of them), but to ensure that it actually does what it says. If someone accidentally changes the declaration to first: (a, b) -&gt; b The compiler will not catch that, but it's a real error. The point of testing this is to actually catch human error.
That was the declaration in the example Yes I guess the test can ensure that no one has changed both the code and the type, but then again if they did that they probably also changed the test
But changing a test usually denotes intention, at least if you are going for tests first. Changing a test means "I now want this API endpoint to do this thing", and then you change your code. Of course, if someone changes the test and the code intentionally in a wrong way, there's a bug, but having a test makes it harder to do it accidentally.
That looks nice. But help me out, what does the "model ! [] " do again? I can't remember and don't know what to look for in the docs...
Would be nice if [elm-new](https://github.com/simonewebdesign/elm-new) could incorporate this. 
 model ! [] == (model, Cmd.batch []) model ! [doSomething] == (model, Cmd.batch [doSomething]) etc :) http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Platform-Cmd
Right, thanks!
You can use http://klaftertief.github.io/elm-search/ to lookup operators in the Elm docs eg. http://klaftertief.github.io/elm-search/?q=!
it returns the model and a null command.
I didn't put a licence on it but I will add a BSD3 clause
We had Highcharts integrated in our 0.16 project somewhat along the lines of https://github.com/sgillis/elm-highcharts, relying on vDom hooks. With 0.17 and the rewritten elm/virtual-dom, no hooks are available, so I had to go for a new approach. This is still hacky as it relies on virtual-dom internals not changing, and it does no cleanup on node removal, but demonstrates passing (almost) arbitrary data to virtual-dom and using it to drive an external component, e.g. Highcharts, which controls its own rendering and keeps its own state.
Finally! But, there are quite a few glitches in the epub version. I use iBooks to read. I'll send you screenshots if you are not aware of the issues. Thanx!
thanks, I don't use epub myself, so I really didn't know how to check it out. I will fix it over the next few days and see if I can't improve it.
## Notes for Commenters - With questions like this, I think it is better to start by pointing to high quality resources. - That *components* is a confusing term is not constructive knowledge. You can't just say that to beginners and expect that you have taught them anything. Building a full picture of what is meant with "components vs functions" takes a lot of examples, so it's better to start with concrete examples. - It makes sense to offer additional clarification outside of real resources *iff* there are specific questions not addressed by any resources. - Just be nice! Never blame a beginner for having questions; they didn't make the docs confusing! If you are not excited to help out newcomers and share knowledge, you do not have to talk to them!
So are higher kindred types, it's like saying voldemort. "Shhhhh we don't need them yet so they should be referred to as you know what"
F# may be a good choice for you! It has a lot of features that Elm has, but it's more suited for data science than Elm. Also, it has a very good integration with IDE (Visual Studio or Xamarin Studio, I don't remember). Here's [a talk by Evelina Gabasova](https://www.youtube.com/watch?v=SH7KwMXL4Mg) on how she replaced R and Python with F# in one of her projects.
http://elm-lang.org/ is generated client side using elm and indexes just fine as well. There was a lot of talk about this in the reactjs community, and the consensus seems to be that google handles it just fine.
I wouldn't expect JS to approach native speed either. That's probably why JS isn't used for data science. Basically, if JS can't be used for data science, then Elm can't be either. Perhaps when WebAssembly becomes a standard and Elm compiles to WebAssembly, the situation may change. My test was not headless. It contained an input box, a button, and the resulting time. 
Elm only runs in the browser, disregarding the hacks out there. Browser for big data? Uh....no
It's completely usable outside the browser on eg node, but I'm not aware of node or any other server side javascript environment being used much for big data.
It's just a mock of ELM architecture in JS :)
I won't run the data munching jobs in the browser. I would like to process it outside the browser with elm and deliver the results to the browser with elm.
Would be interested in people's onions on this. I've found that there are a few ways of doing things in Elm (like most languages) and I'm currently trying to find a balance between some approaches. The project should build and render a dummy page that show cases the idea.
My bad I could have swore it said it used the gpu, thanks for the clarification.
That would solve the problem only for decoding json. I have similar patterns with Tasks and Maybe. I think my main problem is that I this "monadic pattern" very often in many situations, because it's so flexible. Thank you for the suggestion, I guess I will have to use that in the future. 
Where is this information from?
Ah, I found the answer to my question. This is from the elm-dev list, and information is marked as not to be shared, so you've jumped the gun a little bit here. ;) But for anyone else wondering the specific narrow context of this, its the removal of backtick syntax to make a function infix. The arguments of `andThen` are now swapped too. So instead of m `andThen` f we're suggested to write: m |&gt; andThen f I'm not sure exactly what functions you have available, but I agree with the other commenter that what you wrote surely can't be the right way. 
You can also just define your own infix operator to do the same thing the old andThen did. Something like this might work for 0.18's Maybe: (&gt;&gt;=) : Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (&gt;&gt;=) = flip Maybe.andThen Then you could just use `&gt;&gt;=` how you used to use `andThen`. Does anyone know if he's really going to get rid of backticks entirely? They seem really useful for writing DSLs with informative names.
Ah, I just saw your other reply. Nah, its fine, especially since you got from the github. I just happened to find out about the change from the thread talking about the draft 0.18 announcement blog post thats not supposed to be shared. I think this has to do with making sure the announcement has a big impact, and this change is pretty minor in that context. So no worries!
I don't know about Elm 0.18, but I use the |: operator from Json.Decode.Extra for that (although what you did works). I have no idea how |: works though, some functional thing that makes my head spin.
Not quite done yet as you can see from the TODO's in the README. But I wanted to get some feedback on the initial approach / API before I spent too much more time on it.
Interesting problem, thanks for the thought Sparc! My first instinct would be to draw everything using svg. I think it makes all the measurements easier and with Elms reusability it shouldn't be too much of a hassle compared to Html building blocks. And right now I fail to see the advantage of Html... But I think doing two passes would also be possible. (Warning, spit balling ahead): you could probably implement some sort of flip flop behavior, with which every incoming message triggers a redraw, which flips a switch at the end and immediately triggers another redraw while flipping the switch back at the end. So you end up with a cycle like: | Msg -&gt; redraw -&gt; measure -&gt; redraw -&gt; start over Might be a stupid idea though... Not sure right now
&gt; Possibly one of those things that you might be able to get working but you then regret for the lifetime of the project. Well put. We actually use a lot of d3.js and svg at work (without elm sadly), and I don't think dealing with text there is as bad as you think. A colleague of mine actually did some svg work using elm at her did seen pleased. Give it a try.
Cheers for the reassurance. I will give it a go :) Svg is out my comfort zone but double draw gymnastics looks terrifying.
It seems like exactly what i needed, thanks! I will try it as soon as posible
Cool thanks
Cool thanks
I wrote this package! I'll admit it's kind of half baked, so I'm open to questions, suggestions, pull requests, etc. There are lots of places where we're working around the fact that there's no GADTs or DataKinds in Elm, but I think we get something decently usable. It's also worth mentioning that this was partially invented to be used with a multi dimensional array library I also wrote, equally half baked: http://package.elm-lang.org/packages/JoeyEremondi/array-multidim/latest 
I think one of the motives is that a function inside ticks has precedence over (|&gt;). Therefore, with Maybe.andThen as it is, piping with multiple functions where only some of which return a Maybe pretty annoying in Elm 0.17. For example, this works: ``` value |&gt; f1 |&gt; flip Maybe.andThen f2 |&gt; Maybe.map f3 |&gt; Maybe.map f4 |&gt; flip Maybe.andThen f5 ``` This doesn't: ``` value |&gt; f1 `Maybe.andThen` f2 |&gt; Maybe.map f3 |&gt; Maybe.map f4 `Maybe.andThen` f5 ``` Even if it would, it would be ugly. In Elm 0.18, I won't need those flips. 
Yeah, though this is a lot more lightweight. 
Just wanted to give an update. I noticed that the `elm-oracle` script is written in Elm. That is the program that IDEs use to provide semantic completion; it runs from the command line. What he's doing is better than what I did and I'm probably going to copy it. https://github.com/ElmCast/elm-oracle/blob/master/Main.elm
Thanks for your input. The symbol in question should be a "heavy circle" (http://unicode-table.com/de/2B58/). I will try to find something else instead.
My issue with the "reuse" section is it only talks about view code, which IMO is the easiest to understand how to break apart because HTML is strictly hierarchical. I'd like really like to see how someone handles a model with a lot of super complicated logic on nested records in a sane way. I almost end up with a "component" situation regardless of any way I approach it, and all the tedious boilerplate that entails.
Well you can use hierarchies to some success with regard to messages. But those need to be confined to the update. It's a big mistake to start mixing view with update they are very different things. You may think you have a series of small reasonable chunks but through abstraction you have built a system of many small interacting components each with their own state. Making it easy to make updates in a hierarchy, bravo but requireing or or allowing a sub view to be included is problematic. Most of these scheme would be helpful if the view os just left out of it. The whole point of the MVC abstraction is to seperate the model from the view but by packaging them into the components the become intertwined from the bottom up. You are correct that some functional languages introduce class like features but these are at the outer reaches of the language, typically things like the IO monad to break purity. They do not purveyed the typical use case. 
`elm-format` &amp; `elm-make --warn`is what I use. They catch &amp; fix far more problems than eslint ever did for me. :-)
I can help you out tomorrow if you'd like? Do a little peer programming?
Sure, i just found it wierd that you made a point of not understanding something that is fairly well documented, in an article explaining why you're ditching the language. What would you do in python? Create a dict and iterate over key/value pairs? No reason you cannot do that in Elm.
I'll make a code sample for you later
This signature? (String -&gt; msg) -&gt; Attribute msg. My point was that it was more than you get from Python. You claimed otherwise. You're creating a select with a set of options. Each option needs a value and a text, both of which must be strings because that's how HTML works. You wish to map over the possible values. You have two options. 1) create a list og your types and create a toString and fromString to convert values. 2) create a dictionary of value and texts, and create a fromString to convert to type in the event handler. Both deal with string conversion, which has the same pitfalls that you mention. Option 2 is less code and arguably and easier.
Thank you for taking the time to try Elm and write your perspective! One small question on enumeration. Imagine for example that your type would have been `type TimeRange = AllTime | OneWeek | OneDay | Days Int` . It's a valid type that allows for some smart defaults and flexibility. How should the enumeration have worked in this case? 
Native packages do, for sure, but that's not what the linked article claimed. Libraries which don’t have the blessing of Czaplicki himself allegedly aren’t allowed to be published. This is bull. Libraries containing safe code can be published without anyones approval.
You claimed "I can make more robust code for this type of scenario in Python." Which is weird when you can do the same thing in Elm, and Elm can make sure that the type actually is a string, and that it isn't null/None. 1) It's not an easy fix. Your solution is to place all the Union values in a list by the compiler, but this won't work in all cases. What if one or more of those union values takes arguments? How would you represent that in a list? 2) It doesn't make union types bad. They do require translation, sure, but so does most things in Elm when communicating with the outside world. Any non-trivial record, union, tuple etc. requires explicit conversion to/from JSON. This is not a problem with Elm, but it's a limitation of HTML. If you could place `onSelected` listeners on the option elements, we wouldn't be having this problem.
Ah. That's because I can have assertions that validate the data structures at import time in Python. Don't think there's anything as good in elm. Correct me if I'm wrong. 1) don't know. Maybe just skip that case. Just because a solution doesn't cover all scenarios doesn't mean it's not very valuable to cover some of the cases. 2) the translation is only checked one way though. From union types to outside. And since there is no way to enumerate you can't make sure with a unit test that you've handled all the cases the other way. 
Interesting idea :) Type holes did seem to feature quite a bit at CodeMesh this year. Perhaps you could use the stuff Jessica did with her code generator to automate the process?
I'm building in Elm for work, and have found that building the options with a List.map, and using onInput works to send to a function that reads the value. That's the simplest approach to inputs that I've found so far, and it works pretty well
Oh. Forgot to say that generating the DOM from a union type would still be crap if the events were nicer. Because i can't loop through the union type to generate the options. So a better designed browser even system would still have half the problem. It's not an good sign that elm doesn't allow to cleanly work around icky facts of the real world. You'd want a language to allow to isolate ickyness into one place so the next abstraction level is nice again. 
&gt; and claim to have spent a lot of googling to find an answer that is in the guide on the elm-lang homepage, suggests to me that you haven't really given Elm a fair chance. Where in the guide does it show how to handle select boxes? I think you're confusing some things I've written. My point is that I super quickly found that a tent post feature is seriously flawed and a super basic thing can't be handled properly for a supposed web focused language. When this happens it makes me think if I spend more time I'd hit more of the same. Do you really think that there is just this one wart in elm? Even though I've read on mailing lists that people routinely use code generators to get stuff done? That's another thing that makes me suspicious. I'm willing to give it a try again after my initial icky feeling have passed if you say it is worth it :P Of course I'll write a "fool me twice, shame on me" article if I find more stuff :P
Yeah, but again. In Python you'd solve this with a dictionary. You can do the same thing in Elm. So you can't make maximum use of the type system for this one thing, but you can be sure that when you change the dictionary, everything is updated. It's a tradeoff you have to make, every application is full of such tradeoffs. Another thing. Presumably you're sending the select values somewhere right? To some backend? If that is the case, you're going to have to convert the union to a string anyway, so why not just have it as a string all the way, and have a validate function just before the send off?
[more discussion on /r/programming a.k.a. proggit](https://www.reddit.com/r/programming/comments/5bs2mu/a_small_dive_into_and_rejection_of_elm/)
Yes! I do this literally all the time! It's so useful. But, what works the most often? I like `String` for most things, but Unit or `()` works well others. I'm curious: what do y'all use? --- Also I literally spit my water out at "And your ho would be well and truly tallied." so there's that.
https://github.com/xdissent/elm-localstorage/issues/1#issuecomment-122585560 I'm thankful to this article. *“Packages with native bindings [not being] publishable without getting Evan's personal approval”* is a huge turn-off. Not even Haskell is so purely big-brother. Edit: Nevermind and thank you to nickwebdev and wheatBread for excellent points below
To be fair, IIRC this process is being actively discussed and I think it's largely because the Native API wasn't intended to be public and isn't designed up to Evan's standard so can be fraught with peril.
Elm has been my introduction to a safe and strong type system, but I expect myself to transition to Haskell eventually. Pragmatically Elm has been awesome, but I have already hit the problem described at the end of the post: &gt; If I decide to change from a List a to an Array a for efficiency reasons, my whole codebase needs to know about it. It was only a toy project so I needed not much time, and I indeed was shown a even better way of doing what I wanted. But I imagine this is a concern Elm cannot avoid forever. Or maybe let [Atomist](https://medium.com/the-composition/software-that-writes-and-evolves-software-953578a6fc36#.4yu6469sn) handle it?
Thanks for working on this. This is definitely a big problem, and it is always great to see people other than Evan exploring possible solutions for good architecture. Not sure if this is the right abstraction though. It does a great job of getting rid of boilerplate, but I don't think it really solves the problem of the elm architecture. It sure is a lot of boilerplate to manage parent child communication in TEA, but it really isn't that bad to manage just a parent to children relationship. The problem comes in when you have multiple generations. That becomes hard to manage, and reason about. The compiler makes refactoring that mess easier, but it is still a pain. I think your solution is a good exploratory step, but I would like to see something that can be added to TEA that is less brittle. I think it was unfortunate that Elm has moved away from FRP, because I am pretty sure that there was a good solution in that. Also I agree with your points of view in the readme about local reasoning of components and how state should be managed.
The article itself gives an impression that it applies to all packages, and not just packages with native code, which is what I'm criticizing.
The problem isn't the lack of a specific onSelect function, but that you have to specify the change value as a string. If you could add a "on change" function per option, you could simply have the on change fn return the proper union value and be done with it, but as it is now you have to convert to/from string.
That's a lot better but still has the fundamental issue of having to reconcile by hand the list of values and the union type definition :(
It doesn't need to be a trade off if the language wasn't crippled though. Is my point. Sure. I started with a super trivial page. But I'd like to show that I can make that super simple page rigorous and nice. 
Maybe a `select` variant could be like `List Html.Attribute -&gt; List (String, msg) -&gt; Html msg`? Kinda defies the convention of putting onSelect stuff in the attribute list so it might be a problem.
&gt; O(2^(n−1)n^(2)) &gt; &gt; That function grows so quickly it’s no longer super-exponential. It’s officially reached super-duper-exponential. The point of Big-O notation is to simplify exact expressions like 2^(n−1)n^2 to the shorter O(2^(n)). So it's "merely" exponential.
2^(n-1)n^(2) is not O(2^(n)).
Weird! I changed it to a "better" link to the same thing.
Typeclasses would be really nice, but I can see why Evan doesn't want to add them, seeing as he wants to keep things beginner friendly. With typeclasses we'd start making a bunch of confusing (but really cool) advanced libraries that use monads and whatnot, and it would end up looking a lot like haskell/purescript with a more limited syntax and nice default architecture library. Maybe if he added typeclasses but didn't add a "do" syntax? It could be a good balance of power and constraint.
This is a nice trick until there's something more legit, though I'm not sure how well it will work with 0.18. My ambition is to do a lot more with this concept than just helping write types, and I'd expect all of that work to get batched together. Some early info about that [here](https://groups.google.com/d/msg/elm-dev/QPLPd8q1Od0/3-EjlV5zAwAJ).
The `Config` stuff in this snippet is basically a convoluted way to store and access a url string. There might be some greater context going on where this makes sense, but here it does very little but complicate things. The `Soundcloud.view` function isn't binding anything to the `msg` in its return value of `Html msg`. There is only a problem if `msg` is bound to two conflicting types at once. Since this doesn't actually generate any messages, it can't conflict with other messages and thus there is no problem.
So that's a lot of reasoning, but it's still a BDFL situation, with all the pitfalls that entails.
You are more saying, "this returns html which *can't* produce a message". Since it can't produce a message, you can use it with type safety along with html which produces any sort of message without creating a conflict. Compare with `Nothing` which creates a `Maybe a` that can't possibly produce a value of any type and thus can be used next to a `Just 2` or a `Just "foo"` with no problems.
I haven't noticed another place where this has been posted, but `Random` does have a way to generate pseudo-random numbers synchronously. Use [Random.step](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Random#step).
It's up! http://package.elm-lang.org/packages/kintail/input-widget/latest I might post it in a couple days after I (hopefully) get some feedback at this week's Sydney Elm meetup.
Awesome - thanks! 
I was just answering ~~your~~ the question. I don't really care that it doesn't have an inferred enumeration. As for Ints, you probably should use naturals instead with the appropriate enumeration which is much more sane, especially since the number of days can probably be limited to a year (i.e. bound the enumeration.) Floats aren't enumerable, so no problem there. However, while it's straightforward to enumerate an Int length, width, height, and radius shape type, I will agree that such an enumeration is unlikely to be useful. Maybe for testing? Though random generation is probably better.
FWIW I wasn't the person you were replying to, I was just trying to understand whether people would actually want that type of enumeration in cases with large numbers of values (in the context of select elements). Thanks for the insight.
The thing is, it seems you just have to write a bunch of native code to get any non-trivial work done.
you can do native code in your own code base, it is only if you want to publish it as a library that it becomes an issue. I wrote a 6500+ line elm project with probably less than 50 lines of raw javascript , mostly for working with external APIS all threw ports 
Why not? What is it actually?
The default value in this case should absolutely be a runtime exception. The alternative is silently corrupting data. I seriously hope you don't think that's preferable! Again: I don't care about reflection. I care about the language supplying building blocks that compose so you can build stuff. 
Had no problem removing implies they did use the feature which implies the feature was removed on bad grounds?
&gt; constructive &amp;nbsp; &gt; egregious tarpit of a language
(I'm the OP) The fact that union types can be checked by the compiler on the way out but not on the way in is not just a problem for select boxes. It largely negates the supposed type safety of union types AND either requires error prone copy paste or just ditching type safety and going with stringly typed stuff instead. I object to the statement that Elm removes runtime errors when it's glaringly obvious that it fails in this specific case. And what if you've built your app to use union types and you're a hundred hours in and now you realize they are crap so you have to change to stringly typed dicts? That's gotta suck. 
I didn't write that. That's the point. My article was a LOT nicer in tone but the article that wrote the quote you gave was said to be the more constructive. Or do you mean "tarpit of a language" is more constructive than my entire blog post? :P
It will be interesting to see any replies to this. The recommended way to introduce elm is to do so slowly into an existing code base, not as a rewrite or new project. This gives you a chance to try it out with little risk, so I wouldn't worry too much about who else is using it. The NoRedInk story is still pretty compelling even if they are connected with the creation of the language. They claim to still not have ever seen a single runtime exception in production.
Open your `elm-package.json` and change your `"elm-version"` to `"0.17.1 &lt;= v &lt; 0.18.0"`. Version 0.18 hasn't been released yet. "elm-version": "0.17.1 &lt;= v &lt; 0.18.0" Edit: Or you could just delete `elm-package.json` and run `elm-package install`. That'll create a new `elm-package.json` with the correct Elm version.
Having a default value in a select box (which can just as well be "") is much more preferred for the user than the application crashing. Remember that in the browser, most users don't know about the console where such exceptions are logged. Or, you can simply return a value that displays a message box, telling the user to contact support or something. Your application shouldn't just crash. That's bad UX.
Oh sorry, I misread - I thought the article /u/gelisam referred to (which I presume you wrote?) was considered to be more constructive. I don't recall your article too well, but the one linked to here in any case was far from constructive.
The goal of a feature is not to be used, but to help you solve problems. If no one has a problem with removing a feature, it means they don't care if it is removed. In that case, there is no reason to keep it around either.
could you update the readme to include a snippet or two on how to use it? it's really good work, will be using it for my sideproject *thumbs up*
It's not quite what you are asking, but here's a thread over at r/purescript about enterprise-level usage of purescript: https://www.reddit.com/r/purescript/comments/53r4v7/using_purescript_for_work_sept_16/ In particular, there are some mentions of purescript-pux which is an adaption of elm in purescript.
In order for 2^(n)n^(2) to be O(2^(n)), there would have to be constants C and N such that 2^(n)n^(2) &lt; C 2^(n) for all n &gt; N. But that would mean n^(2) &lt; C for all n &gt; N, which is clearly not possible.
I am using it in an enterprise app (~10k loc), but it is not large-scale, just for a small company. The benefits of "no runtime exceptions" are real; the client has never had a bug with the elm features of the app, and we have avoided so much of the grief that usually goes with JS dev. Every problem I ever had with it was decoding malformed data coming from the API, and learning how to manage complexity in a functional way instead of OOP, and the unfortunate lack of complicated "widgets" in Elm, such as a datepicker (there is one now that is pretty good, but it will never be as configurable as simply dropping in the jQuery one). The neat thing about Elm for enterprise is you don't *have* to build the entire app in it (and I would recommend that you do not), instead you can implement small portions of the app that can really benefit from the safety and runtime guarantees. If you don't like the view layer (and I wouldn't blame you atm; it is good enough for my purposes, but there are some rough edges), you can probably implement it in React and just use Elm to mutate the state. I am actually thinking of trying this for a part of the app I built in React already, just to see how it goes. Edit: Another rough edge was simply the learning curve. I was driven because I **HATE** JS development and needed a one-stop toolchain for SPA's, and found writing Elm to be very satisfying. However, I did find myself writing and re-writing similar boilerplate code over and over for each app and that the initial implementations of complicated features were like solving long, arduous math problems. Some of my older code for manipulating complicated models is incomprehensible. The results are absolutely killer, Elm delivers on reliability in a huge way, but it is difficult to move quickly and add features until you have written a LOT of imports, type definitions, and JSON decoders or encoders. There is a dire need for a way to generate these automatically.
I think you're exaggerating how hard this is. Maybe you could use buttons instead that produce the type safe messages you want though?
There hasn't been much enterprise adoption yet due to the cyclical loop of people asking if it's already being used for enterprise and then not using it for enterprise when they decide that the two existing open source projects aren't enough. It may be getting used in places for huge applications we'll never hear about, due to highly restrictive NDAs. 
Elm has never claimed to be a language with "no runtime errors". It has claimed to be a language with "no runtime exceptions". That last word being key. Forcing the developer to deal with potential errors is what makes Elm great. The problem with many other languages is that a developer has no idea what parts of a problem can fail, and therefore cannot be sure if all cases are handled. In a browser, this sort of knowledge is paramount, as a user will not be necessarily become aware that the code has crashed. Forcing developers to deal with errors, whether they display an error or just provide defaults, is good for everyone involved.
How would I know if I have created all the buttons though? I have to rely on lots of copy paste. Every change to the code will have to touch several totally distinct and probably far-from-eachother pieces of code. And only some of them will have compiler errors if I forget, while the others will silently fail or corrupt data (by going to the default case).
NoRedInk has around 55k LoC in production and I remember Richard (lead front-end at NRI) commenting that soon they might not be the largest Elm code base but I can't recall the name of the second business. For some reason, I don't think it's CircuitHub. Other than these two, there was little publicity for using Elm in production. Elm is still in development (before 1.0) and it takes courage to adopt it for enterprise work. If you want to play it safe, you might be better served by some other tech. Maybe go the NRI way (they were an early adopter of React and gradually moved to Elm) 
This should help with the JSON part: https://github.com/eeue56/json-to-elm
You can't write algorithms that are generic in the typeclass implementation. For example, you can't write a `sort` that works for a user-defined ordered type without explicitly passing in the ordering. (In this case, it is not too bad, since there is essentially only one method. You can still have issues with, say, `Dict`s, which would require the programmer to ensure the same instance is used in every case.) The `do` sugar doesn't have anything to do with it.
You should build something that works this way.
This is my solution for achieving what you are talking about while automatically doing the from string conversion /u/skinney is talking about: https://github.com/lgastako/elm-select/blob/master/src/Main.elm#L106
Whats wrong with a helper function ```a -&gt; b -&gt; Ord``` ?
I'm not entirely sure what you mean in that type, but the problem with `Dict` looks something like this: If you want to use a structure like a binary search tree, you need a way to compare the keys. One attempt would look something like type alias Dict k v = { bst : BST k v } -- BST is a type of binary search trees where keys are of type k, values of type v empty : Dict k v insert : (k -&gt; k -&gt; Bool) -&gt; k -&gt; v -&gt; Dict k v -&gt; Dict k v lookup : (k -&gt; k -&gt; Bool) -&gt; k -&gt; Dict k v -&gt; Maybe v delete : (k -&gt; k -&gt; Bool) -&gt; k -&gt; Dict k v -&gt; Dict k v union : (k -&gt; k -&gt; Bool) -&gt; Dict k v -&gt; Dict k v -&gt; Dict k v ... Note that all of those types have that `k -&gt; k -&gt; Bool` at the front, which is the comparison operation on the keys. You have to manually pass it everywhere it is needed. If you ever pass the wrong function (say using `(&gt;)` instead of `(&lt;)`), you get incorrect results; either you fail to look up or delete a key that is actually in the tree, or you leave the tree in a state that violates invariants which will cause trouble later. You could try to avoid that by keeping the comparison with the dict itself: type alias Dict k v = { compare : k -&gt; k -&gt; Bool , bst : BST k v } empty : (k -&gt; k -&gt; Bool) -&gt; Dict k v insert : k -&gt; v -&gt; Dict k v -&gt; Dict k v lookup : k -&gt; Dict k v -&gt; Maybe v delete : k -&gt; Dict k v -&gt; Dict k v union : Dict k v -&gt; Dict k v -&gt; Dict k v ... But now think about how `union` has to work. What happens if the two `Dict`s passed in to `union` have different `compare` functions? Then it has to pick one to go with, and insert the members of the other `Dict` one at a time. If they used the same `compare`, it could instead do a bst merge with potentially better performance. But since you can't guarantee that will be the case, you can't do that and preserve correctness.
Thank you for creating this! I very much appreciate that you took the root concern and made something constructive. It is hard to do, and I hope it is helpful to the person who wrote that original post!
I love the idea of elm as a intro web language. Evan showed a bunch of fourth graders who had made cool stuff before from a class in one of his talks. To go deep you'll eventually need JavaScript for the ports
I recently wrote a small feature for work in Elm. The rest of our project is a full stack MVC framework that includes framework-specific view templates. Although at first I was concerned about how integrating Elm with the framework's view templates would be a pain, it turns out that it is quite easy. I use the HTML embedding technique you linked, except instead of a plain old `&lt;script&gt;` tag to load my compiled elm app, I use jQuery's `$.getScript` function. The reason for this is because we are using an AJAX-based navigation plugin called `pjax`, and the way it does partial page loading can sometimes make `&lt;script&gt;` tags fail to load any data. In terms of project structure, I keep all of my Elm code in a directory separate from the MVC framework structure, and use a symlink between the directory that contains my compiled Elm apps and my framework's `webroot/js` directory. I wrote a one line `build.sh` script that just calls `elm-make` with the proper file names for src and output. We are moving away from what has been a pure jQuery approach since the beginning to one of a few possible alternatives. The impetus for this push is that the majority of features we are making now have front ends that are more like single page apps than small discrete pages the user has to navigate between. jQuery is a nightmare to deal with when your page has 5000+ lines of JS on it. I am interested in using Elm for more in the future, although we are also evaluating Vue.js as a possible option. I think there are pros and cons to using Elm. The bright side is that the pros are very good (type system, compiler errors, performance), and the cons are all manageable and many of them will disappear over time (initial learning curve, lack of libraries). Ultimately what we choose will come down to a matter of the overall opinion of my team.
I should build something that is hard to build and brittle? I've worked with a lot of such code. I am working to fix a lot of such shortcomings in the code at work. 
Your approach looks right, but it doesn't currently works as expected when pasting it to elm-try. It gives the same thing (AllTime) regardless of choice. And on mobile nothing changes at all.
there is a [polymer calendar example](https://github.com/fredcy/elm-polymer-calendar) and a [google maps example](https://github.com/rtfeldman/elm-google-maps). 
&gt; you took the root concern and made something constructive It is constructive, but I am not sure the root concern was addressed: &gt; There is no reasonable or agreed upon way to do select boxes. I think this might *help* define an agreed-upon way to do select boxes, but it is not reasonable in the rant author's mind!
OK, now I no longer know which article you're talking about :P In any case, what I meant was that your article was probably the more constructive one.
I'm curious what alternative solutions people are suggesting to having to manually create a list of options. Reflection seems like a *bad* solution because you suddenly couple the arbitrary order of constructors in a union type to the order they are presented in a view. It is also brittle because it falls apart the moment you want to exclude one or more options. Also, how do we handle a type which has constructors of different types? Are there alternate solutions out there which address these problems?
Original poster here. It isn't. Because it misses the point. And the same thing has been shown to me by multiple people already. In addition to people saying I was stupid and shouldn't have used union types at because they're not useful for this type of thing. And people saying "just use Haskell" because Haskell has "deriving Enum". Plus a whole lot of other advice that is all over the place. 
Thanks for saying this publicly. 
How is it now constructively worded? Seriously. I toned it down a lot from my initial draft because I wanted to be constructive and NOT ranty. Thanks for getting the point though! Most people read it like the devil reads the Bible. 
Well, this is how I felt when I read it ... sorry if this offends you, I should probably have used my words with more care!
All those things are trivially handled in a system with reflection so that's just weird. The different types thing I don't care about. Haskells deriving enum probably doesn't either. This is a solved problem in ML like languages so don't be so worried that it's a problem!
You've reacted to my article by missing the point. See my other responses in this thread and the post of my article in this subreddit and proggit. 
I think "toxic" is a bit much. Attacking a language -- even for totally valid reasons -- is always going to rub some in its community the wrong way. I'd suggest being as non-combative as possible to get the most positive response in return!
Ok thanks for the replies. So if Elm is not ready for prime time would learning a language like Dart be more beneficial in the real world?
 data Foo = Bar | Baz deriving (Enum, Bounded) From `Enum`, you can use the `..` syntactic sugar, and from `Bounded` ou get `minBound` and `maxBound`. You can then write: allValues :: (Bounded a, Enum a) =&gt; [a] allValues = [minBound .. maxBound]
Honestly I was leaning towards your side until this comment. Really both sides of this conversation need to chill out a bit. Does elm have things it needs to address or fix, YES! Doesn't take away from the fact that it's been awesome where I work and is much more understandable by non-FP programmers IMHO. Either way let's just be respectful to everyone.
&gt; This also seems to require that the constructors all be the same type I don't understand what you mean by that? &gt; it requires type classes Yes, this specific solution does. &gt; it only works when either everybody uses it or you are using it on types you are comfortable changing in your code. I do not understand that either. &gt; I never said that this isn't a problem that can be worked around, but this is far from a solved problem as described I have an acceptable solution for this problem in Haskell, and I find my Elm solution lacking. As I said, I understand why I can't do the same thing in Elm, but it is nevertheless annoying. As a result I have to use code-generation tricks, which is acceptable as I already generate code (namely types and related JSON encoders/decoders).
All of that is just showing how it is a limited solution which requires increased complication in the language. You don't seem to be talking about my main point which is that it couples the arbitrary order in the source code with the ordering in the view. The Haskell solution doesn't solve this and using that solution in this example would be hacky. You are asking for the language to be more complicated so that you can write a bad solution which reduces some code maintenance in a relatively small problem area.
Yea, sorry, I am getting frustrated at this point. So much crap thrown against me. Like this "reaction" that just misses the point.
&gt; The order of the items in the view shouldn't be coupled with some order that makes sense in the source file. How do you decouple these things without declaring the arbitrary order of elements like making a list? If the order is arbitrary, why not make good use of it? And anyway, the ordering can be fixed by declaring a list with the order you want IF you can validate that the ordering list has all elements. Which you can with reflection.
What's the problem with using the ordering in the source for something constructive?
Sure there are. For all n &gt; 1, n^(2) + n &lt; 2n^(2).
&gt; abitrary order in the source code I don't really see why it would be arbitrary, but tossing that aside, you obviously would never use this list directly. The constructor names can't have space or arbitrary capitalization, and are often unfit for end-user consumption. A more complete solution would look like that: data Foo = Bar | Baz deriving (Eq, Enum, Bounded) fooDescription :: Foo -&gt; Text fooDescription f = case f of Bar -&gt; "The important bar option" Baz -&gt; "The not so important baz option" fooPriority :: Foo -&gt; Int fooPriority f = case f of Bar -&gt; 10 Baz -&gt; 1 allOptions :: [Foo] allOptions = sortBy (comparing fooPriority) [minBound .. maxBound] It is a bit more code, but it is safe, and easy to understand and expand. The `Enum` typeclass gives me a mapping between `Foo` and `Int` that I can use to give an identifier to the options in the select box, and the `fooDescription` a human readable text. &gt; You are asking for the language to be more complicated so that you can write a bad solution which reduces some code maintenance in a relatively small problem area. I am not asking Elm to change. As I said, I (think I) understand what spot it occupies, and understand that `andThen` or `map` will be different for every type, that applicative operators will never be in core, and (more importantly), that I will never be able to write something `comparable`. The Haskell solution isn't bad. It is cleaner and safer than the "manually maintain a list" option. Finally, it is alright to have strong opinions on language design, but it would be better to also have an idea of what the solution space looks like before dismissing other approaches.
&gt; you obviously would never use this list directly People would. Maintaining a type-safe list of priorities is annoying and the list comes to you in a particular order, so why the hell not use that order? This is why I say it encourages people to write bad code. &gt; It is a bit more code, but it is safe So is an incomplete list of constructors. The broader problem space that this belongs to is the view getting out-of-sync with the business logic. This solves a problem when the type constructors changes and you have a list in the view which should always include all of these items. As soon as you want something different, you have returned to silent failure land. We now have to do some sort of cost-benefit analysis. Yes, it solves a problem with some debatable level of frequency and severity. No, it doesn't solve significant closely-related problems in the same problem space. It creates increased complexity for learning and maintaining the language. It creates new space for people to write bad code. It doesn't seem to improve the amount of boilerplate code in many situations. When I look at it, I just don't see enough of a win. Acceptance testing seems like a fine place to catch these problems with much less cost and greater consistency of workflow. &gt; I am not asking Elm to change. I didn't intend to suggest you were and there are plenty of things I would like to change in Elm. What you seem to be saying is that this change would be good for Elm and this is where I am skeptical. &gt; it would be better to also have an idea of what the solution space looks like before dismissing other approaches. This is unnecessarily derogatory. I started out asking for thoughts on ways of implementing things because I couldn't think of a good way to solve it without the problems I have been talking about.
&gt; serious games require ports. Can you elaborate on that? I've only ever needed ports for interacting with pre-existing javascript nonsense that I didn't want to rewrite. Is there a use case specific to games that I don't know about?
&gt; This is unnecessarily derogatory. I started out asking for thoughts on ways of implementing things because I couldn't think of a good way to solve it without the problems I have been talking about. You started by asking, but you quickly made uninformed, yet firm and derogatory judgement: &gt; You are asking for the language to be more complicated so that you can write a bad solution which reduces some code maintenance in a relatively small problem area. So, if, as you claim, you are humbly asking how others approach a problem, I would suggest not doing that. Especially when you are wrong on all counts: * I never asked for Elm to be more complicated, I only pointed out that its simplicity had drawbacks. I don't want it to become like Haskell, we already have PureScript. * The Haskell solution is simple and clean. If you disagree, please show me a superior solution. * The problem of writing a select box where all options map a sum type is exceedingly common, and the problem of running code on all the elements of a sum type is even more common. &gt; The broader problem space ... Please.
I feel like there should be more tutorials about Elm with an API backend (building it included).
I think one of your biggest challenges is going to be the age of Elm. With 0.18 is coming up there are a few breaking changes that will require you to update your source before it will run again. Imagine you had rolled Elm out to a bunch of internal teams who wrote modules against 0.17. Now someone needs to update your internal catalog of components and applications before Elm can be upgraded. In addition, what kind of people are you working with and what kind of people do you typically hire? You might face social challenges with adoption. That tends to be an issue with anything sufficiently different; especially functional languages. If it were me, and it will be me, I would not start a new project entirely in Elm yet. I think that would set me up for failure long term. If it was a solo project then I would do it in a heart beat, but at work (especially in enterprise) you'll have to sell people on new things. I would pick a less framework dependent, standards based core with the ability to integrate little modules in any framework/library/language, be it Elm, React/Redux, etc. Then, give up-front caveats and instructions, with time dedicated in sprints for source code upgrades for new major versions. If you set expectations correctly then you'll get less push back when those things inevitably happen. I also want to note that I would say a lot of the same stuff about other frameworks. You don't need to design something that depends solely on one library/language at its core; especially in today's Javascript landscape.
- http://gdotdesign.github.io/elm-ui/ - https://github.com/debois/elm-mdl/
Elm-mdl looks awesome! 
This is exactly the problem I'm having now -- I love everything else I've learnt so far about Elm but JSON decoding has just been an enormous headache. I've spent hours and hours going over it but everything I read only makes me understand it less, including this article. So this post says "A decoder is a function that can take a piece of JSON and decode it into an Elm value", but then in the next paragraph "what's important to remember is that all these decoder functions return new decoders", which seems contradictory. Does a decoder return an Elm value like a string, record, or integer, or does it return a new decoder? If decoders just return more and more decoders, when do I get my actual result? Later it explains that `object1` has the signature `(a -&gt; value) -&gt; Decoder a -&gt; Decoder value` -- a function and a decoder to get a decoder, where the decoder youprovide will be passed into the function you provide as its first argument. So isn't that `(Decoder a -&gt; value) -&gt; Decoder a -&gt; Decoder value`? The next paragraph seems to contradict that, saying that the `a` in the function is *not* a decoder but instead the already-decoded value. This function returns the Elm data you want to get out of your JSON -- but the decoded value *is* the data I want to get out of my JSON, isn't it? Is this just an optional step to wrap it up in some unique way? Why make this an obligatory part of decoding? The Json-Decode documentation lists object1, object2, object3, up to object8. But what if I want to decode JSON with more than eight fields? This all just seems so bafflingly bizarre and arcane to me. Why is it so much more complicated than TypeScript?
 &gt;This all just seems so bafflingly bizarre and arcane to me. Why is it so much more complicated than TypeScript? Because you haven't found the Json Decode Pipeline yet : http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/2.0.0/Json-Decode-Pipeline 
&gt; So this post says "A decoder is a function that can take a piece of JSON and decode it into an Elm value", but then in the next paragraph "what's important to remember is that all these decoder functions return new decoders", which seems contradictory. In some sense a JSON decoder *is* a function, so using the two terms interchangeable makes sense. Unfortunately the JSON decoder is mostly implemented in JavaScript, but if you'd implement it in pure Elm it would look something like: type Decoder a = Decoder (Value -&gt; Result String a)
Thank you. A little disappointing though :(
This is the one I use: https://github.com/fluxxu/elm-hot-loader-starter `elm-live` looks really nice, though. I might use that on my next project.
Here's an awesome explanation about algebraic data types (that's the name of the thing you're trying to understand): http://learnyouahaskell.com/making-our-own-types-and-typeclasses
This is the explenation from the docs. https://guide.elm-lang.org/types/union_types.html But the concept is called algebraic data types or union types. Plenty more to read if you know the name. Pretty common in functional programming.
Use a custom `Int` decoder import Html.Events exposing (on, targetValue ) import String import Json.Decode as JD onIntInput msg = targetValue |&gt; JD.andThen (\str -&gt; case (String.toInt str) of Ok val -&gt; JD.succeed val Err _ -&gt; JD.fail "err" ) |&gt; JD.map msg |&gt; on "input" 
If you want to get an `Int` from the input, you need to pull one out of the event somehow. The input event provides a `String` -- whatever was actually typed in -- and you need to convert this to an `Int`. Fortunately, the Elm library provides `String.toInt : String -&gt; Result String Int` which can do this. The `Result String Int` type allows it to produce an error in the case that parsing fails, and you will have to account for this somehow. One possibility is to have an additional message to communicate this. Then you can do something like input [ type' "number" , placeholder "release year" , onInput handleInput ] [ ] with handleInput : String -&gt; Msg handleInput str = case String.toInt str of Ok year -&gt; UpdatePendingYear year Err err -&gt; InputError err
If you want to separate content into distinct files, you need to pull out the types first.
I found that this is explained pretty good in Feldman's "Elm in action" MEAP book. I'll try to explain it in his words later this evening, if I find the time. But if you are serious about elm it is worth getting the book in my opinion (though it only has 3 chapters as of now)
I had some headaches with this too, because you can export/import types, but I needed someone to point me to the right solution in the docs. It is a bit hard to find. Edit: Well, not that hard... https://guide.elm-lang.org/reuse/modules.html
It just means that as all the functions will need access to the types, this is what needs to be factored out first. In Elm I usually keep the view/update/Action/Model stuff in the same file, regardless of its size, for "components". But types that are used across the application, such as those that are used in JSON API calls, all go together in a "Foo.Types" module (along with the json encoders/decoders).
&gt; I'll put the update function in its own file and import it. &gt; But the update function refers to a ton of functions and values from Main. Don't extract the update function but the update section. If that grows complex, extract case specific functionality into their own files. You also need to extract the Model (the types of the app) into its own file so that you can import it into Update without causing a cyclic dependency. 
Coming from Elixir, you can just think of these as 'special tagged tuples'. The 'special' part is that you can't use them as a 'normal' tuple in any sense from comparison to destructuring. You can only create them using the 'constructors' that were generated when you defined the type and you access them in pattern matching using the constructor name. Aside from this specialness, they are conceptually the same. The language magic here is that the type system can guarantee that the tagged tuples are always of the correct types, it gives you 'constructor' functions for generating these special tagged tuples, and the constructor name is reused in pattern matching (since you need some syntax to deconstruct it).
Is updating elm-webpack-loader as easy as bumping the package.json?
You shouldn't even need to do that - just install Elm 0.18 and you should be set. :)
The debugger and error messages are nice and all, but I am very pleased with the removal of special syntax. `andThen` finally gets to have its arguments in the proper order and no more extranious ' and ` floating around.
No. It could also take a page from Lein and offer templates. But *as is*, it's not very useful.
http://elm-lang.org/examples/drag
that only uses the position -- it doesn't allow you to drag and drop list items between eachother.
whoa, this guy is definitely doing it! https://github.com/IwalkAlone/elephant-guide/
"complex functionalities" like... what?
I am currently coding "a game like Minesweeper" in Elm. It is called Elm-sweeper and clones [Hexcells](http://store.steampowered.com/app/304410/)' mechanics. I hope to collect user made levels there. For the game UI (the hexagons) I am using Svg+Css and everything else is done in Html. When I started out I was doing Buttons &amp; Text in Svg as well, but refactoring those parts to use Html+Css gave me nicer code. If you want to have a look, the tutorial is quite playable already and can be found at https://rosievers.github.io/elm-sweeper/. You can [find all the code](https://github.com/roSievers/elm-sweeper) on my Github.&lt;/shameless self promotion&gt; One drawback of using Svg is browser compatibility. Currently it looks bad on Chrome because I didn't do any propper css in over half a decade. Using [elm-graphics](http://package.elm-lang.org/packages/evancz/elm-graphics/latest) would likely solve that issue, but then I have to handle the window size myself. This is why I am sticking with Svg at the moment. For anything "more demanding" I would either use WebGL directly or find a nice JS game/graphics engine to wrap. 
The work is still in progress but you can try my library https://github.com/ir4y/elm-dnd https://github.com/ir4y/elm-dnd/blob/master/example/src/Table.elm
also take a look at this https://youtu.be/IRa_eDNZISQ
I split my data models into modules &amp; my messages into a separate module: https://github.com/prikhi/bodyweight-client
If this course just got released and is only in early access how do you have 30ish reviews for this course already? Are you really posting fake reviews? And if the reviews were for the old version of elm and the old elm course, isn't it unethical to use the same reviews for a new course? 
Watched the first 7 odd videos. Very basic. No videos on communication with back end for example. 
Never understood the Java hate. Yes, Java is verbose, but it's much better than C++ in this regard, which is what it was meant to replace. Every language I prefer over Java is simpler than Java. As such the title of the post just doesn't make sense to me. As a Javascript and Elm developer (and previous C/C++ developer) I'm consistently happy with Elm's removal of unnecessary features in later releases. Elm is the easiest language to work with, and the easiest language in which to read other peoples code. The sole reason for this is Elm's "infantilizing". I'm also pretty happy that `where` was not added to the language. I never understood why `where` was in Haskell when you had `let`. I also didn't understand why Haskell has list comprehensions, when you can do the same with map/filter/reduce. I also find `let` more readable than `where`, but I guess that's subjective.
The course is worth every penny if you're new to Elm.
&gt; And if the reviews were for the old version of elm and the old elm course, isn't it unethical to use the same reviews for a new course? This is a good question. Maybe they can make it clear that the reviews are for a previous version. Personally, I don't view them as unethical because I associate them with the general product (Pragmatic Studio's Elm course) but I can totally understand how other people might have a different take on this. 
Thanks for your thoughts. I opted for svg also but, man, is not easy at all. It is my first take at it so maybe I will need to read some more to better address the issues.
It is subjective: I like 'where' much better because I get to understand the overall function without getting bogged down in the detail of it until later. For perspective, I program in Java and C# most days, so it's not a bias held only people used to Haskell. I see it like good essay writing: the introduction tells me what you're going to prove in your essay, before I get into the nitty gritty. I get to read the detail with the overall context.
Thanks I will check it out.
Cool Link. Thank you. This sounds reasonable. I will try to limit myself and not implement everything at once.
Decent article, terrible title 
I think the idea with text fields is that the model is meant to be updated with every keyless using "onInput", rather than just when the user presses a button - it's just best to forget that data can be stored within the DOM
Doesn't really explain what json is doing in there for example. 
Seems Elm really needs to look over some basic experiences for new users. 
But what new user experience is going to help someone in this situation? The author seems to have not even RTFM on [Html.Events.on](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events#on) as evidenced by surprise at the need for a decoder. If a person can't be bothered to read a dozen lines of documentation to understand a lower-level function like this, then what hope is there?
Out of curiosity, when you say "I tried Elm", what have you actually tried to implement with it and how far you got (functionality wise and/or LOC wise)? 
I like `let` for intermediate values &amp; `where` for helper functions.
I think the reason event handlers rely on Json is that essentially Json.Value is an opaque wrapper around any javascript object reference, and decoders are the way to turn those opaque references into Elm types that you can use. Since events are javascript objects with varying (nested) fields, you need a way to be able to extract the values you need from them ... and lo and behold, we already have what we need to do that in Json.Decode. Looking at how the events that are handled by default in Html.Events are defined might be illuminating, eg. `targetValue` or `keyCode` near the bottom of: https://github.com/elm-lang/html/blob/master/src/Html/Events.elm
&gt; Actually i'm trying to port my own component from redux app and stuck with this problem. This is valuable information. Maybe you can use the [webcomponents approach](https://github.com/fredcy/elm-polymer-calendar) and bypass having to do that component in Elm. If what you want is a pure Elm version, my advice is to go with the ports solution where you make requests for information on one port and listen for replies on the other. 
For anyone who comes across this thread wondering how to handle text field submissions, here's my unsolicited advice on how to do it. :) &gt; A typical scenario on the web: user types something into a text field and presses enter to submit his input. The semantic way to do this would be to wrap the &lt;input&gt; in a &lt;form&gt; and use onSubmit. The user's intent to submit is what's most important here, not keyCode 13, and different devices may have different ways to communicate that intent to the browser. Elm has a built-in onSubmit handler for this typical scenario, and it even does the preventDefault for you so the form submission won't trigger a page load. form [ onSubmit msg ] [ inputGoesHere ]
So instead of a JsonDecoder, you argue it should be called a JavascriptDecoder or ObjectDecoder?
My main issue with this is that the criticisms are barely enumerated, and it seems to be more of a vague frustration with the learning curve. I sympathize, but please RTFM at least a little bit and explain what point you are trying to make. :( I actually do sympathize in one respect: Some of my modules have way too ****ing many imports. Elm really needs an IDE to manage these. Event handling is not nice the first time, but it doesn't stay horrible once you understand it. JSON decoding is necessary to deal with any JSON object, such as the event object, and I agree it is a pretty difficult module to learn until it "clicks". After getting over the hump, it is honestly no less convenient than Vue. The problem is Html.Events is really missing a lot of helpers that it ought to have. Also, you can't preventDefault conditionally. :(
I'm not prescribing a solution, just stating the problem.
I know, but it would be good to know if you think this is mostly a problem about naming or something more fundamental. Is the problem that people are confused by seing JsonDecoder, when JsonDecoder in this case essentially validates a Javascript object, or is it something more profound?
Google for "ligatures" and your favorite text editor. E.g. there's Hasklig: https://github.com/i-tu/Hasklig
Re list comprehensions: [ g a | T as _ _ &lt;- ts, a &lt;- as, f a ] is just *so much clearer* than map g $ filter f $ concat $ map (\(T as _ _) -&gt; as) ts `where` for example makes code look much better when using do notation: do a &lt;- f x b &lt;- g x return a where f = ... g = ... instead of: do let f = ... g = ... a &lt;- f x b &lt;- g x return a 
I'd say it's an issue of naming. ObjectDecoder makes more sense. I think the vast majority of people will associate the term JsonDecoder with actual deserialization.
Boils down to the fact that the writer doesn't know HTML that well, which is funny considering he's doing web development. It's a shame that the `keyCode 13` way of handling enter key for inputs is pretty much everywhere when it in fact is not even needed...
He literally didn't give any examples on how to improve anything. All he did was to show that he didn't read the documentation, which is sort of a must.
He showed how much better it is in vue.js. Must it be worse in Elm?
Aaahh, good ol' collage. I might give it a try. 
It is better in Elm, see rtfeldmans comment.
There's nothing in that comment to even address the issue of writing "13" instead of "enter" just to start. 
In fact some mobile devices do not even send `13` when pressing "enter", "go" or whatever is on the on-screen keyboard.
I agree. So wouldn't it be better to have the choice (edit: i.e. Elm could've as easily gone in the other direction and killed `let` instead of `where`)?
I'd prefer just `where` in that case. To me, code is easier to read when there's mostly just one way of doing things.
+1 on elm-mdl to get the design issue out of the picture. otherwise, here the training routine I would follow, that's doable in 40-60 minutes batches: 0. find myself an REST/JSON API I like (twitter, github, reddit, meetup, whatever), make an API GET request using curl that returns a list (e.g "listFriends"), save the result into a file somewhere. 1. JSON API exercise : hardcode the aforementioned JSON into an elm string, parse it to an elm type and display it in the UI 2. HTTP API exercise : issue the GET request from within elm. 3. locastorage : make a form to submit "Notes" on the list items returned by the API, but save those comments to localstorage 4. subscriptions : Implement some kind of "autorefresh" feature by subscribing to timer events and issuing GET requests periodically. 5. Tasks: chain 2 or more HTTP requests together using Tasks and related functions. I think you can build up from there quite nicely and get an insightful overview of elm features and code style.
Then, designing to satisfy zillions of different styles must be how we got Perl ! Not saying Perl was "bad", but allowing many different ways of doing the same thing actually did enable this weird "write-only programming" effect : being able to write some sensible Perl doesn't mean one can read any kind of sensible Perl - not even remotely. I think it's fair to say that elm's terse syntax enables efficient collaboration, just as with Java. Hell, elm is actually a lot better at this than Java. After 6 months of writing and reviewing elm code on a daily basis, on a code base shared by 4 devs, I am really impressed that: - Without any style guide and no formatting rules except tab size, nothing seems overwhelmingly inconsistent from one source file to another - and i *am* very picky about style and formatting. - No one uses a small dark subset of the language to write his code: everybody needs to use the full language constructs set to achieve about anything serious. I had never developed anything in elm before except for the simplest tutorials but I could read the other devs code from the get go. I didn't even know them beforehand and we only met very shortly (and remotely) before we started coding together. I never felt lost. I'm not sure I could say that about any other programming language I practiced before that (ASM, C, C++, Perl, Php, Python, Java, Scala, JS, Haskell, Ruby) Elm syntax could change a 20 times before hitting stable, I couldn't care less - but please keep it simple and balanced between safety and simplicity. _Making compromises isn't necessarily a bad thing_.
lol, the point is not about how to submit a form, but about how elm tackles key press events.
Should have stated that in the article. Also, there's this note in the docs: &gt; Note: It looks like the spec is moving away from event.keyCode and towards event.key. Once this is supported in more browsers, we may add helpers here for onKeyUp, onKeyDown, onKeyPress, etc. on which you make no mention at all when it in fact is pretty important little note.
[Try opening an issue on it's github.](https://github.com/elm-lang/elm-lang.org/issues) EDIT: [There is actually issue for it.](https://github.com/elm-lang/elm-lang.org/issues/624)
I wouldn't really call this "Generating a function", it's more like a feature request for Case-splitting within the Editor. Haskell (and other languages, like Agda) have this, and when combined with typed holes it's really nice. So it's definitely possible for Elm, but would probably end up as an editor plugin.
`UpdatePending` has type `MovieAttribute -&gt; Msg`, so you should give it a value of type `MoveAttribute` but you gave it `Title`, a value of type `String -&gt; MovieAttribute`. You probably want `UpdatePending &lt;&lt; Title`. That is your type error, but that's not the error message you get. I'm guessing that Elm sees that you're giving `UpdatePending` an argument, and so before even looking at this argument, it concludes that the type of `UpdatePending Title` is `Msg`, and so it complains that you gave it a `Msg` when it wants a `String -&gt; Msg`. If you used `UpdatePending Title` in a place which does expect a `Msg`, I bet the type checker would continue its checks, it would finally take a look at the argument, and it would complain that `Title` has type `String -&gt; MovieAttribute` but `UpdatePending` expects a `MovieAttribute`.
I think the newbie would have gotten a much better reception of they'd asked for help, instead of posting a blog post entitled "Elm is a Nightmare". Elm is in general beginner friendly, and you will definitely see that on elm-discuss! But there's a limited tolerance for people who try the language and give up on it without asking for help, then complain about it publicly. There's also a recurring problem, which is that (especially after a new release), there is a flood of suggestions for how to change the language. Some of these get adopted, some don't. But it's frustrating that there are more people who are discussing how to change Elm, than people discussing how to build stuff in Elm. Other communities don't have this to the same degree. If someone gets stuck in Python, they don't email Guido Van Rossum and demand he change the language, they ask for help and figure out the Python way to do it. But people do this *all the time* with Elm, and it just gets tiring, particularly when they ask for change before finding out if there's a way to do what they want with existing Elm. 
Sorry if this sounds condescending, but I hope in a near future one won't have to justify itself for wanting to use secure connections. I believe http without ssl is good for local testing, but that's about it, whatever the content.
Yeaaaa.... you have no idea if he asked for help. That's number one. Number two: I asked for help before writing "a short dive into, and rejection of, Elm" and I got sooooo much shit. Who mailed whoever started Elm? Wtf are you talking about?
I see your name pop up often in the Elm subreddit and I have to ask - are you genuinely interested in learning more about Elm or are you just here to troll? The answer to your question is in the documentation for the `Html.Events.on` function: [`on : String -&gt; Decoder msg -&gt; Attribute msg`](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events#on) &gt; The second argument is a JSON decoder. Read more about these [here](http://package.elm-lang.org/packages/elm-lang/core/latest/Json-Decode). When an event occurs, the decoder tries to turn the event object into an Elm value. If successful, the value is routed to your update function. Perhaps the documentation could include more information, but I think this is a great start. Javascript event handlers emit an `event` object when triggered. In order to get the desired information out of the `event` object, such as `event.target.value` or `event.keyCode`, we need to use a "decoder" that can convert the native Javascript data into Elm data.
Or, you could use something like https://github.com/etaque/elm-form :)
Ah cool. Thank you that sounds really nice and reasonable. Will definitely chrck out mdl
You're not supposed to check the signature with a file you download next to the binary. The point of the cryptographic signature is that even if the server is compromised you can trust the binary.
Sure. At some point the translation needs to happen obviously. But look at how it works in the clojure world: in Om you have to (or used to last time I checked) convert back and forth yourself to native JavaScript and it's a pain, while in reagent you don't have to because they put the abstraction just a smidge higher. A minor quibble I have with the way it's done in Elm is using the word "json" which for most people means "some data structure with stuff in it" but in Elm includes primitives like numbers. I think that's confusing if technically correct. I am genuinely interested in seeing a really good front end development language emerge. I would be happy if that was Elm but it can't happen if the reaction is "are you a troll?" or "rtfm" or any similar things I've had thrown at me and other newbies. I don't really care about learning any specific technology, I want to get stuff done. 
JavaScript has a single-threaded programming model (ignoring web workers), so any significant computation you do will block the one-and-only thread. The best you can do (ignoring web workers) is to break it into pieces and schedule the individual pieces for a more convenient time. Web workers can genuinely process computation on another thread. So you might consider using them for your Mandlebrot computation. Handing off to a web worker is very much like creating a task that interacts with the outside world - treat it like talking to an external server. 
Doesn't matter if the signature is http less. As long as you have Evan's public key (for which he confirmed the fingerprint somewhere else like the mailing list) everything else can be verified even if the site has been compromised (and https sites can be compromised too).
I think you can hack something together. Task.succeed True |&gt; Task.map (\_ -&gt; ... ) 
Aaron tried this approach around this minute [in the video linked](https://www.youtube.com/watch?v=8gQBiMxIJEQ&amp;t=1501s). But it seems the `Task.succeed` is ran synchronously and he needed to walk around this with `Process.sleep 0`. Which is not a solution on my liking. My hope with this question is something that can be accomplished by javascript scheduling for the next tick achievable with `setTimeout(callback, 0)`. 
Just glancing at the code, it seems that `model.stateOutput` and `model.instrOutput` are holding output graphics. I would check out what is happening to them in the `update` function for a clue as to why all previous outputs are being displayed.
This could be huge for the Elm community. I'm very happy to see a few big companies getting on board with type safety, functional programming, and sane error messages. [Adobe is also looking for Elm devs](https://adobe.wd5.myworkdayjobs.com/en-US/external_experienced/job/Seattle/Functional-Programming-Generalist_46723-1)!
I made this game a couple months ago and today I decided I would tweak it a bit before sharing it. I am aware the current implementation is not very efficient. It works relatively well for me on Chrome but not so well on Firefox. I would love to get your feedback on a few points: - It is currently being rendered with the elm-graphics library (which uses canvas), would a webgl implementation be worth attempting to get better perfomance? Or is it not worth the hassle and won't make a huge difference for a simple 2D game? - The maze generation can interupt the gameplay (when creating big mazes). Currently I'm using Task.perform to generate it asynchronously but javascript still being single threaded can make the game stall. Should I try to generate mazes using a web worker or split the generation in several phases? - What do you think about the game itself? Is it easy to understand what's happening? Is it boring? The [source code](https://github.com/basile-henry/haze) is probably not very readable but this can be improved. If there's anything which doesn't makes sense I'll be happy to explain what I was thinking when writting it. If I'm doing something stupid I'd like to know! How else would I learn? :-)
Is elm production ready?
what does it mean depends on my requirements? It is not possible to do everything in elm like in javascript? What could be a problem, that can appear?
We've been using Elm for almost a year now for an internal tool at Grammarly. It makes sense, since integrating Elm into an existing product can be hard and risky. And internal tools usually start small. (and [we're hiring](https://www.grammarly.com/jobs)!)
You can use the elm-version-manager for that: https://github.com/mattludwigs/elm-version-manager It was released an hour ago 😳 I tried it and it seems to work as advertised.
Thanks so much.
Do you have any concrete example?
I'm using Elm to do everything I did with Flash 10 years ago. It's absolutely perfect for that. I use it do make educational games in my day job.
Yes, I've found it very easy by looking at the example code and elm-mdl's documentation. The best part is that you can use it as a drop-in replacement for custom HTML based UI elements without having to do any crazy re-architecting of you app. So, for example, if you want to replace a button that you made from scratch with one one elm-mdl's, buttn's you can pretty much drop it in at the same place in your code. I'm very happy with elm-mdl's API - its sensible and simple.
Maybe you can give a visual indication when picking up a red orb, like "+25". That might make it more clear.
I did have a look at your source code and was a bit confused by the stack used by Maze.Model. Is there a particular reason why you choose to use the linked list [in reverse](https://github.com/basile-henry/haze/blob/master/src/Maze.elm#L571)?
Thanks for the tip, I've updated it accordingly with a little "+25" animation :-)
That's fair point, it would be much more efficient if I didn't traverse the whole stack every time. I'll update this straight away! :-) Edit: Fixed! Thanks you.
Oh you're the person who made elm-sweeper. Had a lot of fun playing with it the other day. Great job making it!
Thanks :-) Your game being hex based actually made me interested in having a look a the source code. A few structures seem familiar.
I've totally forgotten that &gt;&gt; and &lt;&lt; exist in the language! But yeah , you're not wrong about the readability.
Ah, so that solves the conflict between &lt;| and |&gt;. In this particular instance I'd prefer something right-facing such as |&gt;&gt; or ||&gt;, but then again, keeping it left-facing better illustrates what's actually going on.
The code looks very clean and readable, but to answer the question, what you could do is create an infix operator specific to the bind of your type. Something like (&amp;.) or &gt;&gt;= infixl 1 and &gt;&gt;= = flip andThen
In this case it might make sense to do it backwards. ``` Maybe.andThen &lt;&lt; foo "bar" &lt;| Just "baz" ``` But yeah, it's definitely not recommended to mix either directions or flavors of the application operators. :P Edit: I also don't see what `foo "bar"` is in your code. I may be just missing it? Seems like the call would be missing the function to `andThen`.
None of this is factually accurate. I hope no one new to the language comes across it and mistakes it for knowledge. :(
My team has been doing this for a few months now. We had a jam with Elm last week and it was incredible how quickly we were able to get everyone up and running. Using Docker for development environments has some quirks, but is very promising.
What's DU?
Elm has parametric polymorphism, which is the equivalent of templates/generics. Typeclasses are more analogous to function overloading and/or interfaces, which are a whole different beast. Care to point out where Typeclasses show up in Java, C++ and C#? 
Discriminated union. Here are my `Model` and `Msg` types, both of which are DUs: type PlayMsg = CellClicked Cell | CellFlagged Cell | Restart | Tick Time | SwitchMode type Model = Playing GameData | GameWon GameData | GameLost GameData
Well as you said, typeclasses are somewhat analogous to interfaces, and Java, C++, and C# have interfaces. 
Correct me if I'm wrong, but recently I heard somewhere that elm-mdl uses no-longer-advised method of nested components and heavy use of App.Map. Is this still the case?
But the code shows that they all have the same data...
In this case I use the same data in order to be able to draw the board and additionally to display a message like "Victory!" or "Game lost". In a terminal state not much is happening. User just have the possibility to restart the game. Even tough `Restart` is the only valid message, I still need to pattern match for all the rest at least by wildcard... :( 
I am thinking about setting up an online class, but it won't be targeted at mobile
One day, I will read through an explanation of functional programming and not feel like a complete idiot. Today is not that day.
This is probably a little off topic, but this question reminds me that in a recent podcast, I heard Light Table is supposed to have the most "wiz bang" stuff for Elm... http://lighttable.com/
I'm curious to know about that as well, I saw an update to the latest HTML lib (2.0.0) which no longer has an Html.App package.
I, for one, thought it was very well written and clear. I agree that it assumes a certain degree of familiarity with these concepts, but still, does not throw it impolitely at your face. I think we need to start thinking about code in a more mathematical fashion, without the need of becoming mathematicians ourselves. There is great power to extract from it, even while focussing entirely on what most of us are interested and skilled at, software design. We are naive, most of the time, in thinking we can abstract ourselves from, or even dodge completely, all the foundations built before our recent arrival in the functional programming paradigm. Let's embrace these rules, structures and patterns and there is no way we will come out weakened or more ignorant.
Still haven't seen a good example of wtf a huge project looks like without this though. When you have a big object graph, shit gets ugly and you end up in a bad situation regardless.
It's an idea that's been floated more than once, and I'm not certain it won't happen. But it's an extra layer of complexity, that makes modules harder to understand. In particular, records don't have the ability to have types stored in them like modules, and doing so would end up allowing something like existential types. Not necessarily bad, but a path to tread carefully. 
I would argue that it would it actually make modules simpler to grasp but that is just my opinion. Could you explain how are types stored in modules? As far as I know you never expose type itself but only the type constructor, which is just an ordinary function. 
This idea has been around for a while, and I considered it a few years ago :) You can see versions of it in OCaml and in Agda. - In Agda, modules and records are unified, but this only works because Agda is dependently typed. They keep the syntax for modules though. - In OCaml, they have first class modules, so you can create new modules dynamically at runtime. The syntax around making this work in a language without dependent types is kind of crazy though. They do not unify records and modules, but all the problems of "creating modules dynamically" would exist if "modules are records and records can be created dynamically" so it is a useful reference point. In both cases, you lose decidable type inference, and it introduces quite a lot of complexity. I encourage you to explore the full details of these systems to get a better feeling for the tradeoffs. Perhaps interestingly, they all keep the syntax for modules. Part of the importance of `import` declarations is that we can figure out all the dependencies of a module without reading the whole file. Figuring out dependencies efficiently is important for compiling large code bases.
Could you show some code that would have a problem with inference?
repost because someone asked if anyone is working on educational Elm apps: https://www.reddit.com/r/elm/comments/5dnz24/is_anyone_working_on_education_elm_apps/
Basically Elm is a work in progress and somehow it feels like a hacker language. It's meant to give lots of power to a few devs. &gt;More generally, there are quite a few things which are difficult to do in Elm, such as DOM querying In what sense is that difficult?
Hi there ! i managed to run react storybook with ELM. I made small Elm Apps with Flags for each component and then wrapped them in React Components using https://github.com/evancz/react-elm-components. Here is a sample of my stories : storiesOf('Calendar Header', module) .add('october', () =&gt; ( &lt;div id="calendar"&gt; &lt;Elm src={Storybook.CalenderHeader} flags={'October'} ports={()=&gt;{}}/&gt; &lt;/div&gt; )) .add('december', () =&gt; ( &lt;div id="calendar"&gt; &lt;Elm src={Storybook.CalenderHeader} flags={'December'} ports={()=&gt;{}}/&gt; &lt;/div&gt; )) .add('january', () =&gt; ( &lt;div id="calendar"&gt; &lt;Elm src={Storybook.CalenderHeader} flags={'january'} ports={()=&gt;{}}/&gt; &lt;/div&gt; ))
You're looking for `Platform.program` now: http://package.elm-lang.org/packages/elm-lang/core/latest/Platform#program
thanks
No, because of two things: 1. react-elm-components is [buggy](https://github.com/evancz/react-elm-components/issues/3) to a degree that it is not usable. 2. The API is different. reactify-elm gives you an actual React Component API. You could literally just exchange a normal Component with an Elm app, without the need of any further changes. react-elm-components has a really awkward API and props. 
Wow, I wanted this so bad, thank you and great job! :)
I loved it! What about a signature search? :D
This is fantastic! Thanks for doing it :thumbsup:
I'm curious to hear /u/wheatBread s or /u/rtfeldman 's thoughts. This all seems reasonable
I don't think there is anything like that currently. There is an open issue regarding this: https://github.com/elm-lang/elm-repl/issues/126
Ah, just learned that there is already a ticket for this. 
I think your argument is wrong. By that logic Elm shouldn't be strongly typed, because users from javascript are used to dynamic typing. Also fewer high quality libraries are better than more low quality libraries. 
Pull requests are always welcome. Documentation can evolve, so asking questions about specific confusions will help motivate what needs to go in the docs. 
Now I understand what you tried to say and I definitely agree.
&gt; In other words, it should be forbidden (or at least discouraged) to publish package unless you provide documentation of at least the same quality core library has. There is a goldilocks place between too restrictive and too free but forbidding publishing ain't it. ;) I guess that we could come up with a series of criteria that would evaluate a package and just let people vote. I would definitely want to use a poorly documented package if the usefulness is high enough for me to justify spending the time needed to learn it by trial and error or by exploring the source-code. 
I think that IF you have an idea for useful package than you WON'T mind spending a little bit more time on documentation. But since I cannot be sure, I will rather decide to not enforce the rules. 
Very nice article. I also think that a little bit of ad hoc dependant types could simplify certain algorithms immensely. ( Similar to c where array type must contain info about its length even though it is not dependantly typed language... ) 
&gt; I think that IF you have an idea for useful package than you WON'T mind spending a little bit more time on documentation. It is a cost-benefit analysis. Sometimes the cost of adding documentation is little and the benefits are large. Sometimes, the cost is high and the benefits are doubtful. 
I posted this to https://www.jobsinnew.tech/langs/elm/
Not ISO8601 :(
Impressive! Is it open source?
It is, although I haven't made any effort to document getting started with it, and it's still under pretty heavy development. That being said, you can find the source for the front-end [here](https://github.com/bgourlie/rs-nes-debugger-frontend/tree/master) and the emulator itself [here](https://github.com/bgourlie/rs-nes).
Sometimes I feel that computer science is just stacks and trees.
What if—and hear me out here—we implemented the stacks as trees?
&gt; Did I figure it out for myself while writing this? You seem to have figured it out. Without the `&lt;&lt;` the *function* `Title` is being passed as an *argument* to `UpdatePendingBook` and that isn't what you want.
I suspect ratings would be an unhealthy thing for a package ecosystem. When people are capable of damaging something with a low rating, that inevitably becomes a cudgel used to influence the author. Think about how many Amazon reviews are like "Great book but this price is ridiculous; 1 star." Now imagine this tweet: "Hey @rtfeldman, accept my PR you said would overcomplicate the API and I'll remove my 1-star rating from elm-css." I'd like to think authors wouldn't be affected by such things, but we're human. The influence might not be overwhelming, but it wouldn't be zero. It seems to me that an inevitable consequence of having a rating system is that package authors would become incentivized to say yes to user requests, even when doing so would be bad for the long-term quality of the package. That seems like a bad thing for the ecosystem. If people can give feedback, I think something like "stars" would be better - your options are to give a package (or perhaps some aspect, such as docs) a +1 or nothing at all.
I came to Elm from Meteor and I think that no rating system is needed. Check the following link for the inspiration https://atmospherejs.com/ . IMHO it is the best system for "rating" packages I've ever come across.
Great article! There is a tiny nit to pick &gt; -- a ! b is equivalent to (a, b) as per [the docs](http://package.elm-lang.org/packages/elm-lang/core/5.0.0/Platform-Cmd#!), `(!) : model -&gt; List (Cmd msg) -&gt; (model, Cmd msg)` So, what you said isn't strictly true. `(!)` collapses its second argument into a single `Cmd msg` with `Cmd.batch` before returning it as the second element of the tuple. So it would be more accurate to say "a ! b is equivalent to (a, Cmd.batch b)" 
So powerful! 
Ports are the way to go. Native is unnecessary for this IMO. A couple things to keep in mind: 1. Wrap your port code on the javascript side in `requestAnimationFrame`. This ensures that elm is finished rendering before you go and do anything to the DOM manually. in practice this looks something like app.ports.myPort.subscribe(function(argFromElm) { requestAnimationFrame(function() { // do stuff here } )}); 2. If you find that you have to prevent parts of the DOM higher up the tree from changing so that your editor has a stable place to live, the `Html.Keyed` module will probably do the trick. 
Thanks. This was a good answer! Anyone know if a Html.Keyed node disappears and then re-appears later on, is it re-used? Howabout if it moves from one branch to another?
I kinda misspoke, `Html.Keyed` is specifically designed to avoid deleting and redrawing nodes from scratch every time `view` is called. It looks at the key, sees if a node with the key is in the DOM, and reuses it if so. It also works if the node has changed position in the list of children, not sure if it can reuse nodes on a separate branch. `Html.Lazy` might also come into play depending on your use case. Thats the one that checks if the arguments to view have changed, and only calls view if so
You could try the 'Task Runner Explorer' extension. It lets you use gulp/grunt/npm tasks in VS2015. I believe it lets you select which VS build events trigger the scripts. Here's a link to a blog post about it: https://blogs.msdn.microsoft.com/webdev/2016/01/06/task-runners-in-visual-studio-2015/
There are some packages like "elm-decode-pipeline" and "elm-json-extra" that can decode big records easier, but I made an simple example without using 3rd libs: import Json.Decode as JD import Html -- When you create a type alias, you can use it as a function: -- User "Gabriel" False == {name = "Gabriel", registered = False} -- In this case the type signature is String -&gt; Bool -&gt; User type alias User = { name : String , registered : Bool } decoder = JD.map2 User (JD.at ["response", "user", "name", "value"] JD.string) (JD.at ["response", "user", "registered", "value"] JD.bool) json = """ { "response": { "user": { "name": { "type": "string", "value": "Darunia" }, "registered": { "type": "boolean", "value": true } } } } """ main = Html.text &lt;| toString &lt;| JD.decodeString decoder json 
When was "stylesheets" tag introduced in elm-package.json? I didn't know it was possible and I really needed it, thanks for the info :D
Crap - I see the newlines are all screwed up. Can't hide the fact this is my first reddit post ever.
Use github gist
Good plan. Here's the gist: https://gist.github.com/anonymous/6e49ef77c07ab3751ffb75f2ce5ac147
First problem is that it's all weakly typed. Suits and ranks are strings, and a card is just an integral id. I'll try to put together some code today.
Be careful, it hasn't been added! :D runelm uses its own package.json to enhance the official elm-package.json (with stylesheets for example)
Well spotted! [Here is a version that works](http://lpaste.net/7992633477260378112).
&lt;shrug&gt; Not every action can be accomplished by the same tool; there's no need to have an existential crisis over it.
You could use web-components to provide some of the more complex libraries to elm in a controlled and constrained fashion. As for a Blueprint equivalent, you could use [Polymer integration](https://www.dailydrip.com/topics/elm/drips/web-components-introduction). 
Have you considered using native modules? https://github.com/NoRedInk/take-home/wiki/Writing-your-first-Elm-Native-module
Do you have an updated source by chance? I feel like the concept of native modules is hidden and frowned upon for some reason...which it would be nice to have even if you can't publish them. Maybe we (the community) can create a place to publish native modules? That way it's separate but still accessible.
Thanks for your opinion I enjoyed reading it. I still am going to use elm, but I wish you the best. I wish there was some way for you to do both then report on the difference and problems encountered with both ... that would be an awesome experiment. Glhf
Yeah, PureScript's complexity is a little intimidating... Also, in comparison to Elm, it doesn't have "it's own" DOM lib, http lib, etc., although obviously there are 3rd party libraries to choose from... 
Wow. Can't thank you enough for the rework. I had thought about using types like you suggest, but I was worried about when it came time to do the actual solitaire logic I would need numeric values associated with each type so I would know if you could play an 8 on a 7, a king on a queen, and such. What would be the elm type best practice to solve that problem?
&gt;My ¢2 is that the whole idea of ports is terrible. They get in the way so much. They interfere with application logic by integrating with it's message/cmd handling and they also interfere with modules (you need port modules). They turn sync calls into async ones even when it makes no sense to do so. They introduce boilerplate code as well. I'm dealing with ports right now and it's alright. I'm not sure how they would interfere with application logic though but maybe I haven't used them enough.
I found this talk helpful, about making invalid states impossible. That'd make it a lot simpler. https://www.youtube.com/watch?v=IcgmSRJHu_8
I did some googling and found https://elmseeds.thaterikperson.com/native-modules which give a very brief idea/intro to a (0.17?) Native module. They hinted that you should just look at elm-langs http module and reverse engineer what it does (https://github.com/elm-lang/http/blob/1.0.0/src/Native/Http.js) which might get you want you want/need? If anyone understands Native modules in more depth I hope they would post a link to an explanation.
My reason for tabling Elm is simply that I found myself unable to learn from most resources out there, especially the official ones. Way too often I found myself staring at the code in a tutorial trying to reason it out and having to go back to Learn Elm in Y minutes as a cheat sheet to understand. I still don't feel like I really understand how to write in the language I just bought the Elm in Action MEAP so I will be giving that a try and the Pragmatic Studio course. I don't plan on giving it up completely because I like the idea but I'm not super optimistic either.
I love Elm but having used it for about a year on many production apps, I definitely agree with your points. The thought of having to write a JSON decoder is something that fills me with dread. Also, in applications that require heavy use of ports to communicate with specialized JS libraries, I've found that I end up writing two seperate applications: One in JS that handles the JS library acrobatics, and the other in Elm to handle the main application code. Getting these two applications to communicate with each other, and still feeling that I have a maintainable or understandable codebase has been difficult. I'm now at the point where if I have a small (few hundred lines?) app that needs to do JSON encoding, or requires extensive use of JS libraries, I'm better off writing it in JS. But for most of my work that falls in the Goldilocks Zone (few ports, no JSON encoding, and relatively complex logic applications) Elm is the currently the perfect tool. But I think we're still in a world where we need to choose from a basket of different tools based on which best for the job at hand - and I think that's actually just fine :) 
I think it would be very helpful, if you could make post / blog about what confused you in the official tutorial. So we can fix those issues. Also it is very unlikely that you will understand everything just by reading documentation with no prior experience in functional language. 
If you liked Elm, Pux (https://github.com/alexmingoia/purescript-pux) is an Elm clone in PureScript (even has a time travelling debugger). I'm using it for my home project and like it a lot. It's pretty self-explanatory if you know the Elm architecture.
I think the point about ports resonates the most for me. Lack of namespacing is a problem and maintaining both an Elm app and the translation layer between the two is irritating. I think a more robust native module system handles both of those things and that something like OP's unsafe idea could be a great way to deal with it. I don't mind writing json decoders, so even using that as an Elm-level safety guarantee sounds good to me.
Ports prevent JS errors from metastasizing across an Elm code base. Failures have the same characteristics as HTTP: if some malformed data comes in, you can't decode it, and failure happens immediately in a way that gives you total visibility into debugging the problem: "I needed a value that looked like X, but I received Y instead." The selling point of `unsafe`- that it can be used by any function at any time - is what makes it damage reliability. Now if JS does something crazy, the symptom won't be that a port couldn't decode some data, it'll be that I got a runtime exception in the middle of my Elm function call. That's not something I worry about in the world of ports. If `unsafe` existed, I'd go from only having to think about JS problems at the border...to having to think about them in any function call in my entire Elm code base. Something behaves weirdly? Maybe the culprit is some misused `unsafe` call buried deep in a tertiary dependency. I couldn't rule it out. This would be a devastating downgrade in debugging experience compared to the one I have today, which is why I hope it never happens to Elm. :)
That is true, Elixir isn't really all that heavy on functional concepts. It (Erlang VM) uses what it needs to achieve the design goals it's trying to solve (fault tolerance, concurrency/distribution, scalability, high availability, etc.). This is in contrast to Haskell which is a functional language for more philosophical reasons, at least that's how I feel about it. Now I wouldn't say Elm is much like Haskell either, while it does follow it in some regard (and it certainly is much closer to it than remotely being close to Elixir), I don't think it's as elegant or pure as Haskell. But Elm (at least from the last two days I've spent with it as I've only just gotten into it) seems to be using these functional concepts to solve specific problems (much like Erlang/Elixir, however different concepts are needed). Since the other side of Elm seems to be it's trying to tell you how you should architect your applications (kind of like how Erlang/Elixir does the same with OTP, though obviously very different because of different problems/use cases), and making it easy to pick up for other frontend developers (they certainly could've gone down the Haskell route like Purescript, but it's going to scare off a lot of frontend only developers who've never had any exposure to functional concepts; this is also kind of like how Elixir tried cleaning up some issues with Erlang and used a more friendly syntax to encourage more developers who have no experience in that space like OOP backend devs). But yeh concept wise Elm is very different to Elixir. The biggest difference is obviously in the type system. Elixir being a dynamically typed language, while Elm is a statically typed language. Both are strongly typed though. Elixir gets by with dynamic typing because we rely on its pattern matching capabilities instead, and are able to allow and are encouraged to let stuff crash (which we then can fix later once discovered). But it misses out on catching type related runtime errors at compile time, to try and get the benefit of this we do have typespecs which the static analysis tool dialyzer uses to catch these problems (or at least attempt to). Elm on the other hand uses its type system to catch all these runtime bugs. I don't think the rest of Elm's concepts should be too foreign to Elixir though, as they both have pattern matching (albeit Elixir's is much more powerful), and use recursion for loop related control flow. The next difference I could see catching an Elixir dev out though might be the actual terms (data types) you have available. Elm (as far as I know, could definitely be wrong given I'm very new to it) doesn't have atoms. This is a term we make use of quite heavily in Elixir so it could seem weird trying to program functionally without them. You could use strings in Elm as a replacement, though that would be a very poor choice. The Elm way of doing this I believe would be leveraging it's type system. For every "atom" you would use in a given algorithm you instead would make a type with that name instead and use that. And if you need to handle a variety of types then use a union type. Think of how Elm handles boolean values, they're just types (like how bools in Elixir are just atoms). 
So there were couple of things. There was hooking up controls to audio/video player that was done through JavaScript. There was also that web worker layer that polled a REST API and stored and retrieved data for the front-end in IndexedDB. There was an analytics API that was hooked into. There was also a couple of things related to scrolling/scroll positions.
Oh nice, I've never seen that. Thanks for linking it for us!
Thanks, this is a great post that illustrates a lot about each language. If I had to take a stab at where my issues are it's not so much the language, so much as it's the architecture of it all? I guess I also neglected to say that I have very little front-end experience so maybe I'm making it more difficult for myself by starting with Elm. But I heard that it was being adopted by a lot of Phoenix devs so I wanted to give it a shot.
&gt; Well, you can use ports from anywhere in your entire Elm code base, can't you? That way you can run into runtime errors from pretty much anywhere in the app. I've seen that happen with my code. No, they can only create a Cmd or a Sub. That means if I write a function whose type is (for example) String -&gt; Int -&gt; Html msg, there is a 0% chance any port code is being run in the course of executing that function. Since functions that involve Cmd or Sub represent a tiny fraction of my code base, this is huge for my debugging ability - I have to worry about things going awry at the border of JS Land and Elm Land, and only at the border. In an `unsafe` world, even if they crash as eagerly as possible, I now have to worry about any function call in my codebase potentially resulting in a crash.
While we're on the subject of Elm JS FFI, here's something I've been wondering about: Can Elm receive &amp; pass opaque objects? Suppose I use a library1.js that creates an object that I want to pass to library2.js, but I don't care about that object's internals. Can I pass that through Elm? 
&gt; First off, just because you can't (without permission) publish a package with native modules doesn't mean you can't use them within your own project. I had no idea about native modules until now. According this [this document](https://github.com/NoRedInk/take-home/wiki/Writing-Native) _"Elm's Native API is undocumented on purpose and subject to change. If possible, avoid writing Native"_. &gt; Elm might not have the syntactic sugar of Haskell (Which is wrecking my wrists) But it sure as hell is better than React or anything javascript. Languages ugly as hell. I don't care. Yeah, Elm is fairly good, I agree, but even if it were the best thing since sliced bread, until you persuade everyone to only code in Elm, you're going to either isolate yourself in an Elm world where everything is candy or need to find a decent way to talk to other programming languages. 
A big difference between Rust and Elm is the way effects are handled. Rust doesn't require that functions are stateless and allows them to do arbitrary things as side-effects of calling the function. This make FFI a lot easier because a call to a foreign function can also have arbitrary side effects. The stateless and side-effect free model of an Elm program allows the programmer and the runtime to rely on certain guarantees about what happens when you call a function, these guarantees go out the windows when you have `unsafe` functions anywhere in your call stack. You have to trust that the programmer that wrote the `unsafe` function has made sure it's a stateless function that is side-effect free. The problem with this is that most of the time the reason people want to call out to JS is for some kind of effect. If they were calling out to a stateless function they'd likely just reimplement it in Elm. This leads to really hard to find bugs where your program appears to work, but when you start using `Html.Lazy`on some part of your view and weird things start happening. (I've experienced this kind of thing a lot with `shouldComponentUpdate` in React) `ports` need to be async because of the ability for foreign code to have arbitrary side effects. 
Eh, elm-html used the old Signal concept before 0.17 but it wasn't all that much different.
I agree with you totally. I really feel that Elm is great in theory, but not always in practice. You might want to take a look at my (WIP) framework https://github.com/jhdrn/myra. It targets the "middle ground" between Elm and React + Redux by using Typescript (only) and stricter state management than React. 
&gt; Way too often I found myself staring at the code in a tutorial trying to reason it out and having to go back to Learn Elm in Y minutes as a cheat sheet to understand. This is how I was before I took on the Elm Challenges. Goal directed learning was what did it for me. It took me like a week (maybe two) but after I finished writing that snake challenge, I could say that I knew Elm reasonably well. 
&gt; Quite useless I spent about 10 minutes trying to figure out what you meant by this, considering it tells you literally everything about what was wrong with the data...except which function sent it! Is that your objection? That the stack trace doesn't include the function that called it? That's a fair point, but it's an implementation detail of ports, not something exclusive to `unsafe` - e.g. here's a PR that adds it to ports https://github.com/elm-lang/core/pull/770 For what it's worth, I wouldn't recommend using ports in "explode mode" in production - better to receive the port data as a Json.Debug.Value and decode it yourself. That way you can handle errors the same way as you would with HTTP: recovering gracefully and showing the user a nice error message. I'd say the "auto-decode or explode" mode is a feature best used for prototyping. &gt; How is it huge for debugging ability? Runtime exceptions aren't the only way that things could go awry in an `unsafe` world. There's no try/catch for side effects. Several things in Elm rely on the guarantee that Elm functions cannot perform side effects...things like Html.Lazy and view batching on `requestAnimationFrame` could cause all sorts of crazy-to-debug "some `unsafe` function that I depended on needed to do some side effect to work properly, and now it's broken" bugs. Having to worry about things like that - just in general having check "is this pure Elm logic broken because I implemented my business logic wrong, or because something `unsafe` - possibly in a dependency - did something crazy?" - would be a big recurring debugging time expenditure I don't have to make today.
On the other hand, there should probably be some way to ensure that, say `List` and `Array` have same API, say `map`, `empty` and `length`. This way you know exactly how many things are going to break if you switch one for the other (e.g. with `import as`). Right now `List` and `Array` are similar just because they were written by the same author and because of **his good will**. But what happens if some newcomer tries to write `PriorityQueue`? It might end horribly ( he might switch arguments of map etc ). If you could somehow say `this is API of Collection : ...` and `... uses Collection API` then both library users and library authors would have much easier time. How shell it be done is different topic though.
&gt; I spent about 10 minutes trying to figure out what you meant by this, considering it tells you literally everything about what was wrong with the data...except which function sent it! No it doesn't. In this case the error was raised on the incomming port, not the outgoing one. The data was probably wrong in some other way, it was passed through some JS machinery at the end of which `null` appeared for some reason. What was the original argument to the outgoing port and where did it come from? We don't know. I'm not sure I understand the pull request, but it probably does something else. Thanks for the effort to help me with this though! &gt; Having to worry about things like that - just in general having check "is this pure Elm logic broken because I implemented my business logic wrong, or because something `unsafe` - possibly in a dependency - did something crazy?" - would be a big recurring debugging time expenditure I don't have to make today. There are definitely ways of addressing those problems. Like I said in the other comment I never wanted Rust's `unsafe` to be copied to Elm as is. You could have the unsafe marker propagate up the call stack (kind of like Java's checked exceptions). You could still forbid libraries from using it. You could forbid it from Html.Lazy. It could be totally different. I think there are definitely possibilities. **edit**: Anyhow, if a dependency implements its logic wrong, you're going to have a hard time debugging it in when used in Html.Lazy similarly. That's a problem with lazy and bugs in dependencies rather than `unsafe`. Besides you _already rely_ on native modules today, as I found out, and my above proposals are _safer_ than that. I generally sense a lot of irrational fear of JS FFI. 
Right, thanks.
I moved from Elm to PureScript (Pux) for various reasons, and in that process rewrote my Elm based game in PureScript. Elm tree =&gt; https://github.com/srid/Pallanguzhi/tree/elm PureScript Pux tree =&gt; https://github.com/srid/Pallanguzhi/ 
&gt; No it doesn't. In this case the error was raised on the incomming port, not the outgoing one [...] What was the original argument to the outgoing port and where did it come from? We don't know. Ahh, I understand! Sorry for the confusion. So this is specifically for the case where you want to call some JS code *and* get a value back (as opposed to subscribing to an event, or to fire-and-forget, like recording some analytics - two things we use Native for internally, trivially wrapping Rollbar.js and Analytics.js, although this reminds me I should really replace those with pure Elm implementations since all they do are HTTP requests under the hood 😅). Fair enough that ports don't give you caller info in that case. However, something like `unsafe` isn't the only way to change that; having a port responsible for both sending data and receiving the response could provide the same level of error-case feedback without changing the "only happens at the border" invariant. &gt; my above proposals are safer than that. Well it's not safe at all - which is presumably why you named it `unsafe` - so it sort of axiomatically can't be safer than anything else. ;) In all seriousness, though, neither is at all safe - and we shouldn't pretend otherwise! &gt; You could still forbid libraries from using it. You could forbid it from Html.Lazy. It could be totally different. I think there are definitely possibilities. It kind of sounds like you want to write Native code but with nicer error messages if something blows up. Is that fair?
Using Html.program in the init model you can use: { init = update NewUuid model ... } Tip: I'd use Random.generate instead of working with seeds
Perfect, thanks! I saw your earlier response using `Task`, which worked well, but this is much cleaner.
&gt; I'm currently switching from String to Text in the compiler, written in Haskell, and type classes are not doing anything for me. Changing a data structure is a complex thing if you use it directly. Have you looked at Backpack? It's a retro-active solution, but it looks like it will be nice for things like the text problem: https://www.youtube.com/watch?v=s_geh6SlGuM Super interested to hear where you are at with your thinking on having nicer polymorphism in Elm!
Hmm, couldn't Native be used to work around this problem somehow?
You can't use `Random.generate` if you want to have a random value in init though, right?
Probably. I guess you could implement some kind of effects manager with some Native code that could mediate something like this. It could use a JS object as a dict and add the opaque objects to it, together with some kind of opaque Elm object that would hold only the reference (key) to the saved object. 
Random.generate will generate a Cmd, that you can use in the init, then the elm architecture will call update with that message and the random value. http://pastebin.com/x9T4vN5f
It's totally fine not to value "no runtime exceptions," but it's worth noting that Evan values it a ton. He explicitly discourages Native use except when there is no alternative, has said he does not intend to document it—official Elm docs don't even mention its existence last I checked—and has said the API is expected to be indefinitely subject to breaking changes without notice. Of course none of this prevents you from using it if that's how you want to get down, but fair warning - I wouldn't hold out hope for its being embraced more as something intended for use in typical Elm programs. :) As far as how to use Native, I'm the wrong person to ask. I've written almost no Native code ever, and the couple of times I did, it was pretty much just asking Evan or Noah what to do, and then doing that. ;)
Very clickbait title. 
Maybe is not the problem here. type User = NoUser | .. This does not really make sense to me. I would rather have a User type used in combination with Maybe, (defined the same way as the author describes, without NoUser), than a User type that can be *null*. I find it much more explicit. Edit: phrasing
the problem I was trying to avoid is having a state where you can have a combination of values that does not make sense 
Might be a good idea to split the "filling state" and a "filled state", something like a UserForm or a UserBuilder (which uses either maybe or a sum type) and then a User type which genuinely requires all required data e.g. type UserBuilder = Empty | WithName UserName | Complete UserName Avatar type User = User { name: UserName, avatar: Avatar } buildUser : UserBuilder -&gt; Maybe User buildUser builder = case builder of Complete name avatar -&gt; Just (User { name = name, avatar = avatar }) _ -&gt; Nothing
Making illegal states impossible to represent is an objective that is fairly universal. But it seems you mixed this with "having more descriptive types". The problem is not `Maybe`, as you could have written: type User = User UserName (Maybe Avatar) type alias Model = Maybe User Depending on the use case, this might even be better than the sample you provided as you can now be certain you can get a `UserName` everywhere you have a `User`.
My reading was that a "proper" user had to have both name and avatar. But if the avatar is always optional then yes your formulation seems better than TFA's (though the names are odd).
If those functions only need to know about usernames, they should be taking usernames as input, not `User`s.
If I understand correctly, what /u/vinni is suggesting is something like: type alias User = { name : String , avatar : Maybe Avatar } type alias Model = { user : Maybe User } which will not let you have an avatar without a user.
I am intrigued at the thought of replacing webpack with a tup-based solution, because i spend several days thinking about that myself before deciding that webpack had to be doing a lot behind the scenes that I wasn't aware of, and I should concentrate on writing my own app instead. nice to see someone with more js experience than me had the same idea; at least I wasn't totally crazy to think it could be done!
Knowthen.com has a great free tutorial updated for 0.18
Seems great! (The $45 advanced curse too!)
I'm a student of both and give them 2 thumbs up.
[removed]
thanks, i'll check it out. i was also looking at caddy, which seems pretty similar, though there was a feature request for asset pipeline support that got closed due to inactivity.
IIRC this does actually work, elm doesn't change JS values so you can pass them through without decoding them, including stuff you couldn't actually decode (like functions)
You need to not take the 'components' idea too far, it quickly causes messy code. Is it really the best experience to pre-wrap the output of this port in some opaque 'message' type? Wrapping of this sort compartmentalizes your code, with all the benefits and drawbacks that brings. Incoming ports create subscriptions which have to be collected together in your main `subscriptions` callback in order to work. Here you use [Sub.map](http://package.elm-lang.org/packages/elm-lang/core/5.0.0/Platform-Sub#map) to cast the various types into your main `Msg` type. Then your main `update` function's case statement will grow to route the various messages to their appropriate functions along with bits of data from the program's `Model`.
&gt; Is it really the best experience to pre-wrap the output of this port in some opaque 'message' type? My app naturally consists of 2 big parts, so yes, I feel like I need at least these 2 big components. Honestly, I t seems I am not sure yet what problem exactly I am trying to solve here :-) The simplest example is that let's say I have websockets and some RPC stuff, it has 2 functions add numbers and subtract numbers, so I want to tell apart what result I am receiving on the port, is that for add() or subtract() and route them accordingly. Also because this is remote asynchronous calls results for 2 add() calls can come back out of order, this is another problem I'll have to sort out. So, it seems I'll have to send type information along with remote calls, if there is no better way, I just have found another [question](https://www.reddit.com/r/elm/comments/5gypej/is_this_a_sensible_way_to_handleabstract_external/) that is close to mine. 
First example is valid code. Aliases are great for reasoning about programs but they don't make any difference to the compiler. `Color` and `Name` are really just `String`.
I'd actually considered doing something like this but wanted to see if there was a way that involved less code (adding each new case to the decodeWork function). But the async issue is probably worth just being more verbose, that would be a much harder bug to track down.
You have the option to not dispatch in Elm. Just use different ports. Pair an incoming with an outgoing and just use the appropriate outgoing port. Alternatively, you can have a parametrized outgoing port and dispatch in JS based on the parameter, pushing the result on the appropriate incoming port. 
Maybe you should describe what your are actually trying to do because it starts to look more and more like an [XYProblem](http://xyproblem.info/) Ports and native code are tools to reach for after you are 100% sure that what you try to accomplish cannot be done otherwise. In most projects there are just a handful of ports or maybe a small Native file with a couple of utility functions. 
I want to use [Crossbar.io](http://crossbar.io/) JS library to connect to services I have that use RPC and PubSub over websockets. For now just support for RPC would be enough.
I don't know enough about that to provide a meaningful answer. Maybe it is best to ask in elm-discuss. Who knows, maybe someone has a need for WAMP and you could join forces. You intuition might be right, for this kind of a scenario you might be better served by an Effect Manager with some Native code. 
That's what actual types are for!
Or use phantom types to attach meaning to the data, while retaining the ability to write generic functions which work with all types of ids: type Image = Image type Owner = Owner type ImageId = ImageId type OwnerId = OwnerId type Id a = Id String -- works only with ownerIds fetchOwner : Id OwnerId -&gt; Result String Owner fetchOwner (Id id) = Debug.crash "fetching owner" id -- works only with imageIds fetchImage : Id ImageId -&gt; Result String Image fetchImage (Id id) = Debug.crash "fetching image" id ownerId : Id OwnerId ownerId = Id "user-123" -- foo = fetchImage ownerId -- foo will be rejected with -- The argument to function `fetchImage` is causing a mismatch. -- -- 23| fetchImage ownerId -- ^^^^^^^ -- Function `fetchImage` is expecting the argument to be: -- -- Id ImageId -- -- But it is: -- -- Id OwnerId -- the big win? -- writing functions which work for all types of ids -- without branching, i.e. even if we add another type -- of id, say ImageSetId, `idLength` with continue to -- work without any changes -- works for all id types idLength : Id a -&gt; Int idLength (Id id) = String.length id I am planning to give a talk on this at Elm Europe, fingers crossed.
&gt; Is it even possible that abstraction can make someone's life harder? Isn't simplification the very definition of abstraction? Is simple not equal to easy? Yes, it depends, and no. Abstraction correlates to simplicity in the sense that you are removing case-specific detail from a pattern. This is not the same as making something simple to understand or to use. An example might be an API of the sort: getItems : String -&gt; List Node How do I know that my user wants a list? Perhaps they want to append to an existing data structure? What if we want to check for early termination? getItems : (Node -&gt; a -&gt; a) -&gt; (Node -&gt; a -&gt; Bool) -&gt; a -&gt; String -&gt; a This form abstracts away the data structure at the cost of cognitive simplicity. That isn't to say that this is objectively bad, just that there are trade-offs which need to be managed.
&gt; Is simple not equal to easy? Here's a great keynote devoted to this very unintuitive idea: https://www.youtube.com/watch?v=rI8tNMsozo0 Even Evan has said, "Abstraction is a tool, not a design goal". (Paraphrased, I think.) Not that quotes should guide your development life, but consider what made people say them.
The end result is - I created a simple native module, took me like 30 minutes, thanks to Http.Native for the inspiration. It is much more sane approach and less verbose than ports.
But what if we could have an alternative implementation of Elm for the server that would compile to Erlang? I would find that very compelling. 
Oh I agree I would love to look at that
Have you ever seen enterprise Java? In the popular Spring Framework, there's a class called SimpleBeanFactoryAwareAspectInstanceFactory. Ah, and who can forget InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter.
Tell me if [these examples](https://github.com/Pilatch/elm-port-program-examples) help. I had trouble with ports too because nothing really _spoke_ to me as a beginner. Yes I read plenty of documancy.
I have done a bit of googling and found [this](https://news.ycombinator.com/item?id=11032296) very interesting thread. 
I'm very fascinated by Elm as a frontend language, but I too don't see the compelling case for using it on the backend. It seems to me that what really makes Elm tick is that it is a simple and safe way to do web clients; trying to make it compete in the server space will both take away from the simplicity, but also slow the progress that can be made on Elm in the frontend. The backend already has very capable languages and frameworks, whether it's in Haskell, Elixir, Scala, C#, Java, Rust, etc. and I don't think the promise of sharing code between client and server is worth the effort of trying to compete with those languages.
IIRC there is no browser API to manipulate the clipboard, for security reasons. At most you can intercept user-initiated clipboard events, but the utility, and browser support, will be very limited. I vaguely remember a flash bug that did circumvent this. But since flash is faded out now, and required allowing access or something like that, it probably won't work anymore. You're probably best off just selecting the text (or showing an input field) and telling the user to copy it himself. 
I would use a port for this!
Yes it is possible http://stackoverflow.com/a/30810322/3362184
I stand corrected, it is indeed possible :)
Nice job! Anything specific you want feedback on?
Why is jQuery used to execute the ajax requests instead of the native [elm-http](http://package.elm-lang.org/packages/evancz/elm-http/latest) library?
Not really "a thing" but it was what made me learn Elm. ;) 
There's a post ["How to Copy to the System Clipboard in Elm, and Why it Works"](http://claytonflesher.github.io/2016/11/01/copy-to-clipboard.html) in which the author uses Clipboard.js without native modules or ports, you may want to give it a try.
Keep in mind that you don't always have to do this! 🙃 There's this talk by Edward Kmett, [Encapsulation vs Code Reuse]( http://youtu.be/yFXzuCFeRGM?t=1h34m55s), which may give you some counterarguments – or arguments for exposing internal types through something like `YourLib.Internal` or `YourLib.Barebones`. Take a look at [Uuid.Barebones](http://package.elm-lang.org/packages/danyx23/elm-uuid/2.0.2/Uuid-Barebones) for examples.
Awesome. I really need more practice with union types. It never occurred to me that I could build a union type like this. Especially building a constructor having a parameter with the same name looks quite alien but it makes sense to wrap it this way. I feel that this is a crucial bit I was missing. Will refactor soon. More remarks later :D
In your main Update.elm function, you forgot to map LoginMsg to your login update. Needs to look like this: LoginMsg subMsg -&gt; let ( updateLogin, cmd ) = Components.Login.Update.update subMsg model.user in ( { model | user = updateLogin }, Cmd.map LoginMsg cmd ) instead of LoginMsg subMsg -&gt; let ( updateLogin, cmd ) = Components.Login.Update.update subMsg model.user in ( { model | user = updateLogin }, Cmd.none )
I have had this problem with both `Task` and `Random` not having a function to wrap a fixed value. One can hack together a solution (ask random-extra has), but it would be nice to be able to more correctly fix these sorts of oversights. The Elm package repository also punishes developers for exposing these sorts of details, forcing minor and major updates more often just to address bug fixes. Perhaps it would be valuable to have a way to label functionality as unstable, although this might be a distinction which would be abused and make version numbers less meaningful. 
I expected that you will show us some functional tricks like : ``` average = uncurry (/) . foldl ( (,) . sum &lt;*&gt; (+1) ) (0, 0) ``` but written in elm instead of haskell.
Well that explains it. Good catch. So this is where I get into what I was referring to as type mismatch madness before. After the above edit, I'm getting 2 errors: The definition of `main` does not match its type annotation. 301| main : Program Never ( Model, Cmd Msg ) Msg 302| main = 303|&gt; Html.beginnerProgram 304|&gt; { model = initModel 305|&gt; , view = view 306|&gt; , update = update 307|&gt; } The type annotation for `main` says it is a: Program Never ( Model, Cmd Msg ) Msg But the definition (shown above) is a: Program Never Model Msg and: The argument to function `beginnerProgram` is causing a mismatch. 303| Html.beginnerProgram 304|&gt; { model = initModel 305|&gt; , view = view 306|&gt; , update = update 307|&gt; } Function `beginnerProgram` is expecting the argument to be: { ..., update : Msg -&gt; Model -&gt; Model } But it is: { ..., update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) } To resolve the first error, I changed: main : Program Never ( Model, Cmd Msg ) Msg main = Html.beginnerProgram { model = initModel , view = view , update = update } to: .... { model = ( initModel, Cmd.none ) .... and all seems well. However, for the second error, when I try changing: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) to: update : Msg -&gt; ( Model, Cmd Msg ) -&gt; ( Model, Cmd Msg ) I get 2 other errors (besides also getting the feeling that the above change is incorrect for what I'm trying to do): The argument to function `beginnerProgram` is causing a mismatch. 303| Html.beginnerProgram 304|&gt; { model = ( initModel, Cmd.none ) 305|&gt; , view = view 306|&gt; , update = update 307|&gt; } Function `beginnerProgram` is expecting the argument to be: { ..., view : ( Model, Cmd Msg ) -&gt; Html Msg } But it is: { ..., view : Model -&gt; Html Msg } and: `model` is being used in an unexpected way. 112| ( { model | abilities = (abilityScore model.abilities name score) }, Cmd.none ) ^^^^^ Based on its definition, `model` has this type: ( Model, Cmd Msg ) But you are trying to use it as: { b | abilities : a } I have to admit, I'm not entirely sure why it's expecting: update : Msg -&gt; ( Model, Cmd Msg ) -&gt; ( Model, Cmd Msg ) so it's making it difficult to find another way out other than what the compiler is suggesting. I've read through the guide sections on Messages and Cmd but I'm still at a loss. I apologize for the long post.
`Html.beginnerProgram` does not allow using `Cmd`s. You need to use `Html.program` instead. The reason that it is expecting update : Msg -&gt; ( Model, Cmd Msg ) -&gt; ( Model, Cmd Msg ) is because `beginnerProgram` expects the result of `update` and `model` to be the type of the model. Since you are returning something of type `( Model, Cmd Msg )`, it thinks that is the type of your model, so it expects that to be the type of the model fed into `update` as well.
Ah that makes a lot more sense. Was able to make a few more changes and get everything to render. Thanks for all your help! Here's the working version if it helps anyone: [Gist](https://gist.github.com/psilotec/160e76e0906dc6ef6ed2292c326ce3f4)
Planet Elm is an aggregator for exactly that :) http://planet.elm-lang.org
This should help a bunch! Thanks!
Well, one thing that might help with the second function is that you can replace that big if/else chain with a [case statement](http://elm-lang.org/docs/syntax#conditionals). I would pull that case statement out into a named function that operates on one word at a time: meowthifyWord : String -&gt; String meowthifyWord word = case word of "JERK" -&gt; "JOIK" -- etc Then your `meowthify` function becomes easier to think through, you want to take the string you start with, split it into words, then map over the words, then join back, something like: meowthify : String -&gt; String meowthify s = s |&gt; String.split " " |&gt; List.map meowthifyWord |&gt; String.join " " HTH. PS. Don't forget to deal with lowercase...
If you can find a way to use [elm-format](https://github.com/avh4/elm-format). It's very much recommended to use `|&gt;` over `&lt;|`. This creates a 'pipeline' which reads from left to right. I would rename the `validString` function to be `invalidChars` and give it the type `Set Char -&gt; String -&gt; Maybe (Set Char)`. In order to apply the validation, you need something like this: validate : String -&gt; Result (Set Char) String validate string = case invalidChars string of Just invalids -&gt; Err invalids Nothing -&gt; Ok string EDIT: Thinking on it a bit, I think you could just use [Regex.replace](http://package.elm-lang.org/packages/elm-lang/core/5.0.0/Regex#replace) to do your lifting and simplify your code quite a bit. type alias Rule = { match : Regex.Regex , replace : Regex.Match -&gt; String } meowthify : String -&gt; Result (Set Char) String meowthify s = let rules : List Rule rules = [ rule "\\bJERK(?=S?\\b)" (always "JOIK") , rule "\\bYOU\\b" (always "YOUS") , rule "\\bYOUR(?:E?\\b)" (always "YER") , rule "ING\\b" (always "IN") , rule "\\bTH" (always "D") ] in List.foldl replace s rules |&gt; validate replace : Rule -&gt; String -&gt; String replace { match, replace } string = Regex.replace Regex.All match replace string rule : String -&gt; (Regex.Match -&gt; String) -&gt; Rule rule matchString replaceF = Rule (Regex.regex matchString) replaceF 
A case statement won't work well with the `String.endWith` test. I would recommend putting each modification into a separate function, then composing them all together. jerk2Joik w = if w == "JERK" then "JOIK" else w you2Yous w = if w == "YOU" then "YOUS" else w ing2In w = if String.endWith "ING" w then String.dropRight 1 w else w ... meowthifyWord = jerk2Joik &gt;&gt; you2Yous &gt;&gt; ing2In &gt;&gt; ... This does change the behavior slightly when a word can match more than one condition. You could also pull out the repeated pattern, though I don't know if it is worth it: modifyWhen : (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a modifyWhen p f a = if p a then f a else a jerk2Joik = modifyWhen ((==) "JERK") (always "JOIK") you2Yous = modifyWhen ((==) "YOU") (always "YOUS") ing2In = modifyWhen (String.endsWith "ING") (String.dropRight 1) ...
Oh you're right, I didn't really pay attention to the details of everything that was happening. I think I prefer your first example to the second, then I would look to factor out duplication in the implementation of those individual functions so that you might end up with something like replace w a b = if w == a then b else a jerk2Joik = replace("JERK", "JOIK") you2Yous w = replace("YOU", "YOUS") ing2In w = if String.endWith "ING" w then String.dropRight 1 w else w ... meowthifyWord = jerk2Joik &gt;&gt; you2Yous &gt;&gt; ing2In &gt;&gt; ... 
Does the elm community not like Discourse as a hosted solution for forums? Also, is it counterintuitive to have the subreddit and the forums and the elm-discuss Google group all split up?
Very cool, looks like it could be an awesome piece of software!
Save destructuring the `Result` for the view. You shouldn't ever have this particular error while simultaneously having a valid translation, so they should be saved in the same data structure to be mutually exclusive (search for 'making impossible states impossible').
There's also an open source forum engine in Haskell by thoughtbot. Forgot the name, but on phone now
What I did a few months ago is: https://gist.github.com/Janiczek/3767e69a1ded4a76164c5dc97f23bda0
I use webpack to bundle my compiled sources. Check this repo for reference: https://github.com/jairoandre/faturamento/tree/master/src/main/elm
I suspect [this](https://www.youtube.com/watch?v=ar3TakwE8o0) is a better route. He gets into how do Google Maps with Web Components, which works pretty nicely for this kind of scenario.
I know the risks of using Javascript inside Elm, but unfortunately the Google Maps API must be written in Javascript (as you pointed out in your talk linked above), so we have to escape Elm's safety features at some point. The risk has to go somewhere. It seems that there are three options for this: 1. **Ports.** I'm not aware of a way to create reusable components with ports. We'll be using maps in multiple places in our app so this is a deal breaker. 2. **Web components.** This would be my ideal choice if it weren't for the polyfills, Polymer, Bower, and questionable performance. That's a lot for something that would normally be a dozen lines of Javascript code. Furthermore, adding all that to a project that is otherwise written entirely in Elm seems like it'd expose you to a lot more risk than one native module. 3. **Native.** Unless I'm missing something, this is the only way to do what I'm asking for. Reusable code with a minimum amount of Javascript. I understand why the Elm team discourages writing native modules, but sometimes it really is necessary. It's unfortunate that there's zero documentation for this. If I can't figure this out, the final option I guess is to use a poor mans custom element, a `div` with a bunch of `data-` attributes, targeted with a specific CSS selector (`.google-map` for example). I reaaaally would rather not do that. 
Same on Android, pretty fun otherwise :-)
&gt; This would be my ideal choice if it weren't for the polyfills, Polymer, Bower, and questionable performance. This is a temporary context. v1 has been agreed upon and will most likely be available in the evergreen browsers next year. Going the webcomponents route might be paying a higher price now for a better future. 
Thanks for comments! The 3210 is a tribute to the game that it's based on, Gimme Friction Baby, which also had 3210 on the cannon. My guess is that it's communicating that that a circle bursts once you it has no points. &gt; Sometimes '3' balls explode along with current ball not changing it's direction on impact. Happens with '1' balls as well. Sounds like a bug. I haven't seen it myself but if you know how to reproduce it, please log an issue on github. &gt; Please change the pointer of text block to arrow when not visible. I didn't even realise that there was a text cursor when mousing over the text. Will try and add some CSS to fix that. It took a [little over two months](https://github.com/martimatix/sweet-sweet-friction/graphs/contributors) to make this. I made it on the train while commuting to work. Can't code much at home these days because we have a 3 month old baby at home. :) 
Why not post your questions to this group?
Some resources on internet are outdated to Elm 0.18, be carefull Avoid using conflicting names in your types, like Task Look at this example: import Html import Http import Dict exposing (Dict) import Task exposing (Task) import Json.Decode as JD exposing (Decoder) type alias MyTask = { name : String, something : Int } type alias Model = { token : String } decoderMyTask : Decoder MyTask decoderMyTask = JD.map2 MyTask (JD.field "name" JD.string) (JD.field "something" JD.int) fetchTasks : Model -&gt; Task Http.Error (Dict String MyTask) fetchTasks model = { method = "GET" , headers = [ Http.header "Content-Type" "application/json" , Http.header "Authorization" model.token ] , url = "http://kkjkjkjk.com/api/v1/list" , body = Http.emptyBody , expect = Http.expectJson (JD.dict decoderMyTask) , timeout = Nothing , withCredentials = False } |&gt; Http.request |&gt; Http.toTask Instead of Http.toTask in the end of the chain, I'd use Http.send to generate a Cmd directly
Can you give us more details about what you have in mind when you say "interoperate"? What would you like to accomplish and how? Interoperation might be possible but that does not mean that it would also be advisable. For example, you might be able to implement an elm-html equivalent that would render the Elm views in UI5 components but that would be a large undertaking. 
Take a look at elm-mdl as an example of integrating a mature ui framework into elm. OpenUI seems pretty heavy on the jquery to make it an easy transition. I am relatively new to Elm but I don't think trying to use ports to connect the behavior currently covered by JS would be a fun experience, so complex behaviors would have to be recreated in Elm. Interoperate may be the wrong term as elm uses that term to describe direct JS interop via ports. To do it right you are probably looking at almost a complete rebuild.
I see that the code is broken, because it is incomplete, but I can't really tell what you are trying to make it do. Can you explain the goal of the function? What output do you expect to see?
There is a balance to be struck here between reducing the number of imports which must be made to construct complex data structures and avoiding the complexities of layers of indirection caused by things such as re-exporting. Elm lands rather heavily on the side of reducing indirection and the result is rather large `import` blocks at the top of the page. One way of improving this is to just become more familiar with the language and the directions it pushes you to do things. If a type is being used all over the app or needs a large number of functions to support it, it usually ends up living in a specialty module that shares its name. If a type doesn't need many support functions and lives in some particular neighborhood in the app, it often finds itself living in some sort of generic-feeling module with some other interrelated stuff. I would also go so far as to say that `(..)` is code smell and should be avoided in anything that isn't quick-and-dirty. Unqualified imports and exports increase the opportunity for naming conflicts and make it difficult to figure out where something came from should a problem arise. This relates as once you are no longer just importing everything, the value of a re-export goes down quite a bit as it is another example of the balance between implicit convenience and explicit reliability.
Pretty nice, I was happy to read the article, although I can even tell you a more realistic example: - a dependent select belongs to multiple options from the main select, say you have a set of tags and a big list of games - the dependent list fetches its items via ajax, because there are just too much of them - it is not possible to load all the dependent items at once, thus the `select2` or `chosen` plugin is required 
My apologies for the lack of documentation. I don't work as a developer and the main reason I published my libraries is that elm-package doesn't support local dependencies. Frankly, I didn't expect a lot of people to find them, let alone use them. That being said, I've added a tutorial for please-focus (in case anybody is interested), and might do the same thing for euclidean-space.
So, the end of the year is always busy but I finally managed to refactor a lot and incorporate your ideas. What did I do? &gt; Your update function is a monster which needs to be tamed. Yes :D I split up pretty much everything which was a pretty rough trip for me but a good learning experience. I stayed with a unified model for now, i.e. I did not split up the model and the initial state for different parts of the app. Everything is at one place. I tried it but it was much easier for me that way. Maybe I am going to change this. Lesson learned: Next time I will start with this structure. It was a lot of work getting everything split up, getting the imports right, not building circular dependencies etc. But I think it is much nicer now. &gt; [Nice Validation Ideas] I took your ideas played with them (learned something about generic union types) and changed them a bit for my needs. I think the API is *much* nicer now than it was before your input: https://github.com/rommsen/elm-bookkeeping/blob/master/src/elm/Form/Validation.elm I also changed my forms to only have a List of Errors, no more mix up of validation and form results. Thanks again. Your remarks helped me a lot. edit: [spelling, missing words]
http://blog.jenkster.com/2016/11/type-bombs-in-elm.html
I already use this technique sometimes, great article btw. But doesn't solve this case.
Well, not exactly... but while this won't prevent you from compiling it, you could replace `Debug.hole` with `Debug.crash "hole"` and then check for `Debug.crash`'s with a linter or similar. That would get you pretty close.
I didn't think about Debug.crash, really works. Thanks :D But in bigger projects I would need to pay attention using project search "Debug.crash" or using a linter
Just listened. Kris is always fun to read, and Remote Data is very cool. What was with the audio? Chirps, whirrs, really weird things going on today!
I'm guessing it was on Kris' end. Probably a low quality microphone in a loud environment. Coffee shop maybe? I could hear voices in the background. Great episode though, love the Haskell parallels. I've tried to use elm-bridge before and I'm looking forward to using it properly as soon as I can. :-)
Yup, my fault on the sound quality, sorry! I had a quiet meeting room booked where I could set up a decent (but more sensitive mic), and then the room got double-booked and I got bumped into the open-plan. :-( If they ever have me back, I'll just work from home and guarantee a proper setup. :-} Glad you liked it though, despite the audio! :-D
There is a lot of talk in the Elm community about 'not making components'. This really means that you should always have in your mind that your Elm application has only one entry point, one data model, one `msg` type. Modules don't define 'components', they define functions which transform data handed to them through their arguments. &gt; If have multiple models how would i connect them all together to the main? A 'model' is just a data structure and data structures nest. type alias Model = { ... , currentPage : Page , pageOneData : PageOne.Model , pageTwoData : PageTwo.Model , ... } You need to store data about which mode you are in. type Page = PageOne | PageTwo To segment out your messages, you need to nest those as well. type Msg = ... | PageOneUpdate PageOne.Msg | PageTwoUpdate PageTwo.Msg | ... This is the messiest bit, but we need to update the page data given that page's msg data. This could be cleaned up a lot using [elm-return](http://package.elm-lang.org/packages/Fresheyeball/elm-return/latest). update msg model = case msg of ... PageOneUpdate pageOneMsg -&gt; let (newData, newCmd) = PageOne.update pageOneMsg model.pageOneData in ({model | pageOneData = newData}, Cmd.map PageOneUpdate newCmd) ... We need to delegate views as well. view model = case model.page of PageOne -&gt; PageOne.view model.pageOneData |&gt; Html.map PageOneUpdate PageTwo -&gt; PageTwo.view model.pageTwoData |&gt; Html.map PageTwoUpdate Just to be complete, subscriptions can be switched and their messages need to be mapped. subscriptions model = case model.page of PageOne -&gt; Sub.map PageOneUpdate (PageOne.subscriptions model.pageOneData) PageTwo -&gt; Sub.map PageTwoUpdate (PageTwo.subscriptions model.pageTwoData) To get back to the point about 'components', these are **not** components. If they were components they could 'communicate' to each other, but in Elm they cannot. Here, you just have one big ball of data and you call functions to transform that data. You are breaking up complexity by nesting trees. If there needs to be shared state between multiple pages, you store it once, in your main model, and pass it as extra arguments to the update functions in the various page modules.
Look at this simplified example from elm-route-url https://github.com/rofrol/elm-route-url/blob/simplify/examples/elm-architecture-tutorial/MainWithFullUrl.elm More about elm-route-url: - http://www.gizra.com/content/faithful-elm-amazing-router/ - https://medium.com/@whatcomesafter/navigation-in-elm-0-17-with-elm-route-url-a921f393f052
We'd love to have you back for a second shot at the audio, Kris!
So much positive, creative energy in this community. I love it
Awesome tips! Many thanks ; ) Gonna implement then soon (but anyone is welcome to send a PR if I'm not quick enough!)
`n - (n - 5)` will always return 5. So you aren't keeping the randomness. Something like `(rem n 5) + 1` would do what you say.
Nice work! Looks really complete and simple to use..
Elm return is quite good imo
My index.html &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link href="node_modules/normalize.css/normalize.css" rel="stylesheet" type="text/css" media="all"&gt; &lt;link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.css"&gt; &lt;link href="style.css" rel="stylesheet" type="text/css" media="all"&gt; &lt;base href="/"&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt;&lt;/div&gt; &lt;script src="elm.js"&gt;&lt;/script&gt; &lt;script&gt;Elm.Main.embed(document.getElementById('main'));&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Then I use elm-live elm-live src/Main.elm --output=elm.js You may also enable debug elm-live src/Main.elm --output=elm.js -- --debug
I use WebRTC with Elm - the bulk of WebRTC stuff is just in JS and it communicates with Elm via ports.
I was about to suggest Debug.crash, since I wrote about [prototyping with runtime errors](http://mirrors.link/posts/prototyping-with-runtime-errors-in-elm) a few weeks ago. 😉 There was a thread on elm-discuss about [elm-make throwing a warning on `Debug.crash`](https://groups.google.com/d/topic/elm-discuss/6QtWFlIsYI4/discussion). Right now, a linter would be a better idea. [Noah posted a screenshot](https://twitter.com/eeue56/status/802915901628502016) of the one that's in the works right now, but idk what's its status exactly.
&gt; Hi Richard, thanks for your reply! Could you please give a more substantive critique of components and why they are counterproductive? I've found them to be extremely useful and am worried the Elm community is being steered away from a potentially viable tool/technique. Sure! You mentioned earlier that your definition of "component" in Elm is something that has its own Model, Msg, and update. If I think "here is a part of my UI that is logically separate from other parts, so I'll give it its own Model, Msg, and update" then I am either (worst case) making my code more complex than it needs to be, or (best case) making it exactly as complex as I would have if I'd never been thinking in terms of "components." There's no scenario where I come out ahead. Maybe I needed a separate Msg type...and maybe I didn't. My code would have been simpler if I didn't impose that communication overhead on myself, and maybe I didn't need to. Maybe I needed a separate update function and maybe I didn't. Maybe I didn't even need a separate model; maybe a view function would have sufficed in this case. Adopting the mindset that it's fine to introduce the maximum amount of complexity possible, whenever I want to logically separate parts of my UI, is counterproductive. It's better to do the opposite: to introduce the *minimum* amount of complexity necessary when I want to logically separate parts of my UI. :)
Fable has Rollup support for bundling ( http://rollupjs.org/ ). It has some nice features too, and you can use it by calling `fable --rollup`. There are also some examples with Webpack, and it seems it's not very complicated to set it up.
[removed]
I just started playing around with Elm and this whole "component" stuff is by far the most difficult thing to wrap my head around. Your right it introduces a lot of complexity. If you say that sometimes its a bad idea to introduce a new "component" with it's own Msg, Model, Update etc. is it then a common theme in elm applications to have really large update functions that transform a large state? Or how can I split up my update logic in a way so that it's somehow logically decoupled? Should I really mostly care about separating parts of my UI by introducing different view functions and helpers and have one (more or less) global model and update? I would greatly appreciate it if you (or someone else) could help me understand this a little better :). Currently I'm still in the mindset of breaking everything up into small components (with msg, model update..) and I'm kinda got stuck with that :|
elm-mdl is awesome. It worries me a little that google is stopping support for mdl and the library uses the mdl assets directly. 
Ahyep. Elixir too.
[removed]
Adobe in Seattle is hiring elm too
Very, very interesting! I was just working on something where I thought it would be nice to chain JavaScript calls (dealing with loading from and saving to HTML5 LocalStorage). Are there any downsides to your approach other than it using Native code?
That did the trick :D
If you wanna see more, the #jobs channel in the Slack is pretty regularly active. :)
This is really fantastic, thanks so much for doing this! It's exactly the kind of concrete contribution to the discussion that we've needed to take the debate further. JSON decoding and JavaScript interop are by far the two most difficult things about working with Elm, so it's extremely encouraging to see such an innovative and helpful take on the problem.
My job is making educational games for children and we used drag and drop all the time. Unfortunately, although we use Elm for a lot of things, drag and drop in has in Elm been too unwieldy, so we've fallen back on Dragula.js and... I struggle to say this.... jQueryUi. If there were a good, simple, easy, reliable and nice high-level drag and drop library for Elm, I would be the first to use it.
Oh no, the idea that a frontend and a backend are out of sync and frontend can survive a bit modified backend is insane. Yeah, everything can be cached, but it is not that hard to put a version in the api, or to put a deploy date to the generated web page and then ensure that a frontend and a backend match the date. I agree that there can be other reasons to add optional fields though, but this one seems to be really strange.
[removed]
Read this one a little while ago and definitely found the idea useful. I tried to apply it at work but to no avail - we had spent enough time on our elm code that everything I looked at was already well factored!
In what way was it refactored? I'm curious about how alternatives compare to this approach. Also, are you using **Html.Lazy**? I wrote a [follow up post](https://medium.com/@ckoster22/upgrade-your-elm-views-part-2-864ba38499ce#.job0iwh6r) on how to use lazy with selectors and came across a gotya that I describe in that post. I'm also curious how you're using lazy with the approach you took, if you are indeed using lazy.
Saw "Making Impossible States Impossible" online and really like the ethos - that's one thing I really like about the functional approach. Will be sure to watch the other mentioned talk - thanks!
Mostly, our state is all split up already. The application state hold other, smaller state structures, like SearchState. The SearchState view takes only that model, so we had already done something much like selectors. We're not currently using Html.Lazy but I'll have to give that article a closer read!
While this is fine and all, application models tend to be records because there tends to be some state which should persist regardless of what the main state of the application is and to include this data in every constructor for a union type produces a lot of duplication. If your case doesn't have that, then fine, but the more average case of this refactor is to leave the model as a record and then collapse non-persistent fields into a union type which itself is stored in a field of the main model record.
That seems like a reasonable compromise between a Model that is entirely a Record and a Model that is entirely a Union Type. It does have one trade-off that is highlighted in Kris Jenkins' talk. What does it mean to have a record with empty data when we haven't retrieved that data yet? Or we're in the process of retrieving it?
Yes, I just responded to someone else about ports actually :) https://www.reddit.com/r/elm/comments/5jwwrc/webrtc_or_any_alternative/dbo349g/ Basically, you could make your `renderWithOptions` and `renderToStringWithOptions` functions become outgoing port functions, so (I thinkkk??) they would look more like this: type alias RenderData = { options : Options, data : String } -- Outgoing ports port renderWithOptions : RenderData -&gt; Cmd msg port renderToStringWithOptions : RenderData -&gt; Cmd msg -- Incoming ports port receiveRenderedHtml : (Html msg1 -&gt; msg2) -&gt; Sub msg2 port receiveRenderedString : (String -&gt; msg) -&gt; Sub msg I'm not exactly sure how KaTeX works, but basically just match up the data types in Elm to whatever the `render` function in KaTeX returns (which you should send back to the subscription). Ports are preferred over Native code because they are much safer—the reason being that any runtime errors that occur will occur within JavaScript and not propagate to your Elm code. It also cleanly separates your "unsafe" (JavaScript) code from your "safe" (Elm) code with a nice API. Finally, Native code is actually completely undocumented and could change at any time, so using it is really a work-around/hack that is not encouraged unless there is absolutely no other solution. Let me know if you have any more questions! Sorry about the vagueness with the types of the incoming subscription port—I'm just not quite sure exactly how KaTeX handles all its stuff. Good luck! *P.S.* Definitely check out the [official ports tutorial by Evan](https://guide.elm-lang.org/interop/javascript.html#ports). I find it to be a nice, concise explanation.
Looking at your refactored example side-by-side with the example at the end of the blog post I still prefer mine for the same three reasons that I listed, at least for complex views. Trivial views (and this one is border-line trivial) probably don't need selectors and are fine with plain refactoring, but the more the view is doing other than presenting data the harder it is for me to personally maintain. Imagine a view where the data transformation was even more complex than this example. In that case even the small view functions get unnecessarily bloated with data transformation logic which has a negative impact on readability. A pattern that separates data transformation from presentation *does* need to exist for certain views. I can only back that up anecdotally, but for those who find themselves in a situation where their views are doing too much, this is a viable way to split the data transformation from presentation.
Thanks a lot for your detailed explanation! ports definitely seem like a safer and more elegant way to go about this, I'll take a deeper look.
Here's my general advice. First, start with one `Model`, one `Msg` type, one `update` function, and one `view` function, and then start building things. ## When Things Get Too Big When things start getting big and unwieldy, the key is to **treat one symptom at a time**. If something has gotten too big, split up just that one thing, without splitting up any of the other parts. ## When `view` Gets Too Big Almost always the `view` function is the first one to get this treatment. It starts getting big, so you split out a function called something like `viewSidebar : User -&gt; Html Msg` to handle just the sidebar rendering logic. These split-out view functions can take `Model`, but they don't have to; maybe the sidebar only uses the `User` that's held inside `Model`, so you only pass it that. Ideally you pass it only what it needs, but to be fair, that's more work than passing it more than it needs...and it's pretty easy to refactor later if you pass it the whole `Model` at first even though it doesn't need all that. ## When `Model` Gets Too Big The same strategy applies to splitting up a big `Model`. If `Model` is a record that feels like it's too big, you can split that record into smaller records. Again, you do this without splitting `view`, `update`, or `Msg`. You'll still have to change `view` and `update` to reflect the new `Model` structure - e.g. changing `model.accountUsername` and `model.accountUrl` to `model.account.username` and `model.account.url` - but that's it. ## When `Msg` Gets Too Big The same strategy applies to `Msg`. If `Msg` feels like it has too many constructors, find some that can be logically grouped together and then split them out into another `Msg`. It doesn't even need to be in a separate file! You can take `type Msg = SetUsername String | SetPassword String | Foo | Bar | Baz` and split it into `type Msg = UserMsg UserMsg | Foo | Bar | Baz` and then define `type UserMsg = SetUsername String | SetPassword String` right below. Once again, you'll have to update how you're calling these. `onInput SetPassword` will become `onInput (UserMsg &lt;&lt; SetPassword)` and you'll move the parts of `update` that now live under `UserMsg` into a function like `updateUser : UserMsg -&gt; Model -&gt; ( Model, Cmd Msg )` which `update` will call in the `UserMsg` branch like so: `UserMsg subMsg -&gt; updateUser subMsg model` Note how the type of `updateUser` is identical to the type of `update` except for its first argument, which is a `UserMsg` instead of `Msg` - the only symptom we're treating here is that we had more constructors than we wanted in `Msg`. So there is no need to make `updateUser` do anything more than handle the `UserMsg` cases that we split off from `Msg`. We could have made it return `( Model, Cmd UserMsg )` but that has the downside of forcing `update` to call `Cmd.map UserMsg` on the result, and there's no corresponding upside. We'd just be making life harder for ourselves. ## When `update` Gets Too Big Now if you feel like `update` itself is too long, but not because `Msg` has too many constructors, you can split whatever branches of its case-expression feel too big into smaller helper functions. ## Summary These are the techniques I recommend using for dealing with problems of "____ is too big and I want to split it up." The key again is to **treat one symptom at a time**. If what you're dealing with is not a desire to split up something big, but rather to make something reusable, then you want a different set of techniques - specifically these: http://guide.elm-lang.org/reuse/ Hope that helps!
Thank you, this is very helpful, especially the custom attributes and the "firefox hack".
It's the same data structure. But the approaches are a little different. Clojure can call native code (java or javascript) directly, this is not an option in Elm. Clojure also relies on certain interfaces/protocols for some functionality. Since Elm doesn't have such constructs, more of the code is specialized.
Thanks for the long reply. It helped a lot. I definitely gonna approach my next Elm app that way ;). 
This might be a lengthy comment so excuse me for that, and keep in mind that this is my opinion on the subject. A little background on me: I'm the author of (Elm-UI)[http://elm-ui.info], I've been doing web development for a long time and I'm professionally a frontend developer at an agency for 5 years now. ### On Web Components Web Components in general (as a spec) **are not ready yet** and probably will not be useful for a long time. I'm referring to http://caniuse.com/#search=web%20component which shows that only Blink based browsers (Chrome, Opera, Chrome on Android) have good support for them, this means that to **use them professionally heavy polyfills are needed which probably slow to download and execute** which makes them bad. Web Components in prespective of Elm just does not makes sense. If every component the app uses is a Web Component written in plain HTML, JavaScript and CSS then why use Elm at all? why not just write the whole application in them? For me using them in an Elm app is contraindicated. ### To comment on your two points &gt; * encapsulation of state in small components that are unavoidably stateful. This is a valid point, and it can already be done with Elm, the whole Elm Architecture is desinged for that, and I think many people misunderstand the direction Evan and Richard is trying to take the community in this regard. An example that is frequently brought up is the https://github.com/evancz/elm-sortable-table , it hides state in type (`Msg`) instead of record in order to prevent people **storing data** in the components state, at this particular example store data that is rendered in the table. But as the readme states: &gt; It may not be obvious at first glance, but this library follows The Elm Architecture: So there is a **hidden state**, there is `init`, `update` and `view`. Personally I don't like this approach that much, I see the point but there is one key part it fails: **textareas and inputs**. These elements cannot be driven by VirtualDom beacuse of user input. There are tickets for this issue https://github.com/elm-lang/html/issues/105 https://github.com/elm-lang/html/issues/42 The bottom line that state can be encapsulated and can remain visible (if records are used). &gt; * encapsulation of styling (CSS) in a way that is performance aware. This is an other subject that a solution is really long overdue for. The sad part is that there were proposals for it like `scoped` attribute which were never implemented or were implemented but was removed later: https://css-tricks.com/saving-the-day-with-scoped-css/ http://caniuse.com/#feat=style-scoped I'm not really sold on what other JS frameworks are doing, adding the same style over and over under generated classes, dinamically. This is just abusing system that wasn't design for that. What I do in Elm-UI is to **use custom HTML nodes** and style them. By default they don't have any browser styling and probably won't conflict with any user created CSS. ### Communication All the discussions that come up is because there is no standard and official way for _components_ to communicate. The funny thing is that the system for commands and subscriptions make this possible. There is a pure Elm way of using this system to send messages type safe between components using an effect manager: https://github.com/rupertlssmith/elmq. Personally I used this pattern in few of my projects (large and small) and one project at my agency as well without any major issues. The problem is that if not used properly it can lead to bad code, which I feel Evan tries too hard to prevent. ### End Thoughs I feel that this issues is really over hyped and discussed. There are ways to make it work but for that one needs to go beyond the official tooling and resources. This is why I created Elm-UI in the first place because I believe that this can be done. 
Props to elm-ui. I'm currently trying to get my team to give it a try with me. 
&gt; The hidden statefulness of DOM widgets already causes big headaches for Elm developers, usually requiring porting out to JS to handle. Some developers are trying to bypass the architecture in order to achieve some inter-components communication. I believe this approach to be very fragile and a stubborn attempt to shoot oneself in the foot. It is actually a very good reason to provide something better to cover this need. I don't see why hidden state in a properly implemented custom component would cause problems. The end result would be like a mesh of Elm components communicating through messages. Do you have some code using the web components approach that demonstrates the said issues? &gt; https://github.com/evancz/elm-sortable-table is a great example of such a widget. elm-sortable-table does not solve the "small components that are unavoidably stateful". It is fine when you have one big ass component like a table BUT, it is not fine when you have a bunch of small components that need state. 
That's maybe so, but my point stands :)
&gt; The polyfill for Custom Elements is only 6k. My main concern with this is that the polyfill is not full https://github.com/webcomponents/webcomponentsjs#known-issues, for example CSS leaks into the polyfilled shadow-dom and things like that probably introduces bugs that are environment specific, which the developer ideally shouldn't have to deal with. Top that with potential slowness and more size and it becomes less and less desirable. &gt; elm-sortable-table is too clever and, IMHO, does not solve the "small components that are unavoidably stateful" need. Yes I agree there, the current architecture is not favoring this kind of use For things that you brought up in the original text to work I feel a language level support is needed. I'm not saying that it's impossible but I would say it's improbable because the argument can be made (and it's frequently used) that things can be done with the current feature set with some more work with just the amount that can be justified. I also feel that the development of the language is erratic, to focus on implementing something like this size is not likely. 
Yes, that's essentially it. You'll need to make sure all the links in your HTML work under whatever path, but it shouldn't require *much* more work.
Hello, I've been following this discussion on components for the past few months, but there are a few fundamental issues I don't understand. Can anyone help me clarify these? 1. Is there something wrong with this approach? https://groups.google.com/d/msg/elm-discuss/y1CVQpQpRcc/lzdEbAQPCwAJ 2. What advantage is there to components having a "hidden" internal state, rather than having that state exposed as a property in the main application model? Is it for easy reusability (for example, so that you can drop a component module into your project, and it will just work, without the main application model needing to know its state?) 3. If you need a hidden state, what's wrong with using `update`? I used this very successfully to create reusable buttons with internal state before the general recommendation was to avoid using it. 4. The latest version of elm-mdl (v8) is a reusable component library which conforms to current best practise recommendations. Can anyone comment on whether the approach used in the library is a good one? Thanks! -Rex 
Thank so much for that, Mr. jekiknight sir! I have a few more comments and questions :) - By "small components that are unavoidably stateful" do you mean something like a date picker that knows what current date has been chosen? Couldn't the state just be stored in the main application model? Or, is this a situation where you're suggesting that the amount of boilerplate would be overwhelming? - Oops! I just meant calling a submodule's `update` function and mapping its effects (I edited my post above). This kind of thing: ``` let (newInfoBox, fx) = InfoBox.update infoBoxMsg model.infoBox in ( { model | infoBox = newInfoBox } , Cmd.map UpdateInfoBox fx ) ``` When I first stated learning Elm, I build all my early apps this way, and it worked just fine for making reusable modules (like InfoBox) with their own internal state. The only downside (for me) was the large amount of boilerplate code. Again, I really appreciate the time you've put into this thread and these replies, it's extremely helpful.
I have. I needed an autocomplete component a while back so I took a good look, in the end I found it far easier to just implement my own. I spoke to the author at the time and he expressed that he also wasn't happy with it and intended to do some more work to improve the usability for common scenarios. Given the design constraints that are currently being encouraged though I think that it will be difficult to match the usability of the ember.js example above. Hopefully I'm wrong but certainly the version I created internally ended up requiring the client to do more work than I'd like.
This is my experience as well. I implemented my own autocomplete using an outmessage style. Easier, but still lots of work pushed out to the client. There is just a lot of tricky state you don't realize until you look at it. I have a hunch this is what started people looking at web components. But following people's struggles with them the past several months I am not eager to try them :( give me dependable boilerplate over hours in a debugger.... at least until something better is discovered.
Thank you vKompff, you found the solution! I just added: `&lt;script&gt;setTimeout(function() {hljs.initHighlighting();}, 50);&lt;/script&gt;` And it works really nicely.
&gt; elm-sortable-table is too clever Can you elaborate on this? I haven't heard anyone describe it that way before. &gt; there isn't even an official way to do CSS in Elm. Official as in: "this is the official, battle-tested, production-ready way to do CSS in Elm". For what it's worth, we've used elm-css in production at NoRedInk for months and it's worked great. That said, I'm not sure what it would mean to say "this is the official way to do CSS in Elm." There are different tradeoffs to implementing styles via `style=` attributes, via `&lt;style&gt;` tags, via stylesheet files, and via Shadow DOM (where supported). I'd be wary of declaring "this is the one size that fits all" when it comes to CSS in general. Or is what you're looking for an official way to *represent* CSS styles? Maybe a more direct question would be to ask: if elm-css were considered "official" would that allay the concern, or is its scope too broad for what you have in mind?
Oh no… doing this without the [`UrlParser`](http://package.elm-lang.org/packages/evancz/url-parser/latest/UrlParser) library isn't going to scale …like at all. I know it says "_simple_" in the title, and mentions the library, but I don't think it's a good idea to let new people think that this is going to cut it. I know it's a complicated thing to grasp at first, but save yourself the long-term headache and use the library. It lets you build "pretty" routes too--not just ones based on hashes.
I remember trying to find a cleaner solution for this and spent hours digging, but this is the best for now. :-(
I know a lot of effort went into this -- and thanks for the shout-out to my non-empty list library in part one -- but I wonder if this is the right way to go about things. It seems to be falling into the classic "monad tutorial trap" of laboriously explaining abstract algebra terms. Now if you actually want to learn those things, Maybe is a great stepping stone, but it seems like overkill to learn how to use something so commonly used in the language. &gt; Surprisingly many people think map is just for collections. Really, map is for transforming values inside contexts. Yes, and that's a really powerful idea for Random.map or Json.Decode.map. But Maybe is not a (true) computational context. The most important thing to realize about Maybe is that **Maybe is just a data structure**, one that happens to be able to hold at most one item. So of course you can map over it. It's worth noting that there is no magic to Maybe other than that it is imported exposed by default into every program. The source code is 100% elm and isn't very complicated. You could have written it; it's part of the standard library only so that everyone agrees on it. Beyond that, I think a familiarity with |&gt; pipes, Maybe.map, and Maybe.withDefault are far more important than any fancy academic language. That said, I'm looking forward to seeing what you do with monoids/appendable in the next post. Unlike lists, there's not one obvious implementation and I've felt it's a symptom of trying to cram too many things into one abstraction in a way that glossed over important details.
Note that the library has been completely rewritten recently with the help of Evan
Can `Array(32)` not be used to replace that huge `[ null, null, ... ]` block? There's special code for checking `length === 32`. What's up with that?
&gt; Have you looked at the "elm-component-updater" library I made yet? Isn't your library going against official recommendations to not put functions in messages? type alias Updater pModel pMsg = pModel -&gt; ( pModel, Cmd pMsg )
It works better on Safari (significantly). I've explained this better on the elm-dev mailing list.
&gt; Can you elaborate on this? I haven't heard anyone describe it that way before. Intead of having `type Msg = TableMsg Table.Msg` and a TEA child update, the table update is moved into the view via Config and computing the new state for each event. This is solving a part of the boilerplate (the one around mapping messages and commands) but it end up being a little bit harder to understand. Have you seen this pattern imitated to the degree that the old nesting architecture was imitated? &gt; Or is what you're looking for an official way to represent CSS styles? Maybe a more direct question would be to ask: if elm-css were considered "official" would that allay the concern, or is its scope too broad for what you have in mind? Making `elm-css`the official way would be a step forward. As you said, every approach has its tradeoffs but these tradeoffs would be made explicit and clear. I might be wrong but I think that we look at this issue form 2 different vantage points. You might see it from the perspective of a senior front-end developer with a lot of tools on his belt, a lot of domain knowledge. I look at it from the perspective of the beginner. The enthusiast that wants to get into Elm without solid web-dev domain knowledge. I don't want to research and decide what is the best way to handle CSS. I want to delegate this decision to the people with 15 years of experience in the field. Also, this is not a representational issue but more of an integration issue. It is the kind of issue that would be solved if the `Html.program` signature would have a `css` field OR if `elm-package.json` would have `stylesheet` field. The end result would be people being able to do more with Elm tools. Another way to look at what I would like is to imagine an official `elm-app` tool that takes care of project boilerplate (`init`) and provides support for `devel` and `deploy`. `elm-package` already does most of the work and with an official way to do CSS integrated with it, people would have to move out of the Elm ecosystem later. An alternative path would be for Elm to adopt one of the JS build tool and just provide official integration via the external tool. This would be suboptimal for what I wish BUT it would still be better than what we have now. Now, getting back a little bit to the topic. Implementing an Elm UI toolkit would isolate beginners even more from the madness of CSS because, if done right, the toolkit would take care of the layout issues and provide almost all of the surface details (colors, typography). Such a toolkit would make `elm-css` into a low level technology that people would use only when the want very custom stuff OR when implementing their own low level components (I view this a job for a very small percentage of the developers). 
I did my review at the start of December which already included that work.
Ah true that, I'll update it thanks!
Your approach is fine. You could refine it and give the `Product.view` only the relevant information from `User` (e.g. `user.isGoldMember`). A different approach would be to expose two functions `Product.viewRegular` and `Product.viewGold` and select which one to show in the parent based on `user` details. 
&gt; that describes a hierarchy of potentially stateful components that communicate But that's not the intention, it's something unfortunate that the platform forces on us. Ideally all the html elements would only have the state that was passed to them on the last call to `view`. (eg. it would be awesome if we could set cursor position and focus in input elements) There is infact no communicating 'components' in an Elm view, there is a single view that produces events that is made up of composing elements together. The elements don't communicate at all. &gt; Sometimes you want to tell an element its dimensions, sometime you want to interrogate the element about its dimensions. You always want to tell a widget it's dimensions if you can because it shouldn't have state that you haven't passed to it. Of course this would require a change to the browser platform for it to expose the algorithms used to calculate layout and that's not going to happen anytime soon. The point is that this isn't the ideal situation, it's Elm doing the best in can in a hostile environment. Creating nice stateless view functions is what we want to encourage because stateless functions make maintenance and comprehension much easier (at least that's the hypothesis that Elm puts forward) 
&gt; But that's not the intention, it's something unfortunate that the platform forces on us. Ideally all the html elements would only have the state that was passed to them on the last call to view. (eg. it would be awesome if we could set cursor position and focus in input elements) Take a look at the [Hello, World](http://elm-lang.org/examples/hello-html) example. How do you represent mentally the fact that you can interact with the output? You can select a piece of the text. Where is the state needed for this selection to happen? I think that whatever rationalizations you can come up with will be just as valid for another component that might be implemented in Elm. In a web-components world, nothing changes from the perspective of the view. It will be just as stateless as it is right now. The web-components would be an extension of the runtime NOT a stateful function used in the view. 
&gt; How do you represent mentally the fact that you can interact with the output? It's more hidden state, it would be nice to be able to render the text already selected and to have that selection be an event that the `view` produces allowing the Elm program to store the fact that the text is selected. The browser is an OOP environment, following OOP principles, it has objects with encapsulated state and methods to communicate with those objects. This has been a common paradigm for UIs for the past 30 years and it's quite different to the "immediate mode" paradigm that Elm and React encourage. Where given a `model` value and a `view` function you can reproduce the UI exactly without additional state. Of course, because the browser doesn't let us do that we sometimes have to compromise. It's important to remember that the compromise is a compromise and not what we actually aspire to be able to do. Encouraging Elm developers to write 'web components' with internal hidden state as the standard practice goes directly again the goals of Elm. 
I wanted to show how it is possible to use Navigation without UrlParser. In the next article I will show you how to use UrlParser in depth.
You should not think of your `Product` module as a 'component' in the sense you seem to be thinking about it in. It is just a collection of functions. &gt; I don't really like it because the subcomponent view shows differently for the same model `Product.view` isn't a method for your `Product` model, it is a function which describes how to create the HTML for a given set of product data and that HTML depends on some other data (here about the user's gold status). This is entirely expected and you should do this sort of thing more. If you have a couple of hours to spare, there is a [very informative design session](https://www.youtube.com/watch?v=KSuCYUqY058) video with Evan which shows a thought process in developing a 'component' in this style. Additionally, I would probably make a couple of changes to the view function. I wouldn't pass the entire user data structure, instead I would have some enumerated type representing the various account levels and some way of extracting it from the user. In Elm, the subject argument of a function is usually the last argument. Product.view user.accountLevel model.product With this ordering, it is cleaner to do things like this: List.map ( Product.view user.accountLevel ) products
Pity it can't do union types for which this type of thing seems to be the most needed. 
When I have some more time I'm going to look into making a "generics" library for Elm, like this one for Purescript: https://github.com/purescript/purescript-generics which would let you do low-level stuff with union types, or any other type.
I agree with the server part, but in my situation it's a front-end rewrite, so we have limited flexibility about the date format that we get from the server.
Elm doesn't currently support node very much. Elm is new and is focusing on being good at doing the front-end. Later I'm sure it'll have a back end story but currently it is not the case. Interesting alternitives are Purescript, doing things in Elixir (with phoenix), Perhaps even Haskell or OCaml, etc...
Oh I guess if your feeling adventurous there is this package: https://github.com/ElmCast/elm-node
Are you just wanting direct function calls into Elm? And you don't want to use "worker" with "ports" because there's too much separation between call and response? I just recently made a library that lets you do direct JS calls from within Elm (https://github.com/mpdairy/elm-frontier). Using a similar technique I think you could do it the other way, maybe one for exporting functions that return right away and one for functions that might take a while, where you provide a callback for the response. If you don't get around to figuring it out, I can probably look into it next week sometime and add it to elm-frontier. It'd be pretty slick.
but I do think PureScript would be your best route unless you've already got lots of Elm code you want to use. It's got a really direct FFI and can compile down to readable javascript.
Yes! See the edit in the OP. It prevents the event traveling to the target's parents, but it does not prevent it being triggered by it's children.
Great as always, thanks! Just stumbled across: * Header text on the page of episode 8 is the wrong one (still that of episode 7) * [Contact form](https://elmtown.github.io/contact/) seems to be not working (at least for me) 
&lt;3
Yeah, you need to a) set up a click event on the children too b) make this click event "stopPropagation = True" so that it does not bubble up to the parent. The effect is that a click on a child will NOT fire the onClick event of the parent. Here is a working fiddle that demonstrates this behavior: https://runelm.io/c/i77
`pointer-events: none` CSS can help too in certain cases.
Ok… let's go: - Format: PDF ✔️ ePub ✔️ mobi ✔️ all of them available - Length: the PDF version (kind of A5 size) has 50 pages - I'm not sharing samples unless the author authorizes me ; ) - Elm 0.18 ✔️ Source: just bought the book ; ) Thanks /u/brnhx
Good points, thanks! I've added that information to the page.
Yes purescript looks like a better bet for compiling to stand alone javascript - I'd like to option to target node or even embedded systems. That said I was hoping to ease myself into FP bit by bit, purescript's inspiration being Haskell makes it a tad intimidating out of the gate!
Yeah, purescript is much harder to pick up because you have to learn category theory abstractions like monads and applicatives, as well as the do syntax. But the ideas are really powerful, show up everywhere, and help you code really complex stuff with brevity. And you don't have to use those abstractions if you're just writing your own stuff and want to keep it simple. On a side note, we do run Elm on Node for backend stuff here at work, using Worker.
Haha, I was already being adventurous! Playing with alpha modules in a language I don't yet know may be a step too far today thanks :)
Nothing != null - this is one thing I find people who are coming from a non FP (especially JavaScript) background struggle with, whenever I try to explain Maybe to them the first reaction is normally just 'So why not just use null?'. They see Maybe as just a pointless data structure that is a hindrance more than a help. Explaining it as being a context is hard - I'll have to point them at this article in future.
Your question about which andThen I was using, made me look closer to the andThen usage. I use ccapndave/elm-update-extra. And this also works in 0.18. update msg model = case msg of NoOp -&gt; model ! [ Cmd.none ] DrawerLinkSelected url -&gt; model ! [] |&gt; addCmd (Navigation.newUrl url) |&gt; andThen update (Mdl Layout.ToggleDrawer) If the last line is "|&gt; andThen update NoOp" the code compiles perfectly. The "|&gt; andThen update (Mdl Layout.ToggleDrawer)" throws an error. Mdl is expecting the argument of type Material.Msg Msg but it is Layout.Msg. Somehow I have to send the Msg another way.
Perhaps `Layout.update`?
I should clarify my issue. That example will always toggle the the value in my model and so they would stay in sync. What I'm wondering about is, say a user clicks the checkbox and through some branch of logic I don't update the value in my model. I would want the checkbox to remain checked/un-checked, whatever the previous value was. Though, it seems that even if the model is not changed the checkbox is changing its "checked" value, so it is now out of sync with the model. Maybe I should handle this by disabling/enabling the checkbox. I was just curious why this was happening when I'm setting the value of "checked" to model.checked. It seems like they should always stay in sync, but they are not. I hope that makes sense, and thank you for your reply!!
Nope. Compiler immediately starts complaining. However, I think I am close. Material.elm defines these Msg's: type alias Msg m = Component.Msg Button.Msg Textfield.Msg (Menu.Msg m) -- Snackbar.Msg Layout.Msg Toggles.Msg Tooltip.Msg Tabs.Msg (List m) I somehow have to wrap the Layout.ToggleDrawer into a Material.Msg. Then I should be able to this update function: DrawerLinkSelected url -&gt; model ! [] |&gt; addCmd (Navigation.newUrl url) |&gt; andThen update (Mdl Layout.ToggleDrawer) The code above errors with: Mdl is expecting Material.Msg Msg but it is Layout.Msg
This is usually done with "picking" when you are doing OpenGL stuff in general. I don't think that's supported right now in `elm-webgl` though. Andrey and I talked about picking in the first design session we did on `elm-webgl`. We decided that the changes that came out with 2.0.0 of the library should be prioritized over adding new features like this. (That's why 2.0.0 actually came out, instead of still being in development!) I'm not sure what he is most excited about doing next, but I'll bring this idea up!
I think you are supposed to use [Material.Component.LayoutMsg](https://github.com/debois/elm-mdl/blob/8.1.0/src/Material/Component.elm) for that. Unfortunately, it does not seem to be exported. I opened an issue for it [here](https://github.com/debois/elm-mdl/issues/272).
Show us the index.html and check that you are really loading correct file.
`Cmd Msg` is an asynchronous request for an update while recursively calling `update` is synchronous. Of course the second option is what most people should use most of the time. There are contexts in which the asynchronous version might be appropriate. In those contexts you should use it without fear. It is efficient and does not generate race conditions. It's just asynchronous. 
&gt; Still, I am really curious about examples on contexts where it might be appropriate. It may help me understand where and how and can make my code better. I don't know about better, but if one goes crazy on hierarchical TEA and wants to trigger an update in the parent of a component, they have the option of extending the components `update`signature to include an `OutMsg` or they can lift the child component's update return to the parent's Msg and trigger the update asynchronously. The child's `update` would look like this: update : (Msg -&gt; parentMsg) -&gt; parentMsg -&gt; Msg -&gt; Model -&gt; (Model, Cmd parentMsg) update lift someParentMsg msg model = case msg of ProcessAndInformParent payload -&gt; let ... in (newModel, if needsInform then trigger someParentMsg else Cmd.none) SomeInternalMsg -&gt; let ... in (newModel, Cmd.map lift (someInternalCmd)) again, I don't say that this is good code. It might actually be very bad. 
This not the answer, but i think a similar situation. Sometimes i got similar error when i try to parse json response, that caused by value which have posibility empty like this *see age* // first request { "name": "the name", age: 23} // second request { "name": "the name"} So i use Maybe :)
sorry, was in a hurry: 1) in the elm-grammar folder: elm-reactor 2) browser (chrome in my case): http://localhost:8000/src/Main.elm 3) type a letter into the textbox with title "grammar"
Oh, that's an interesting one! Generally, I try to avoid "component" nesting. But putting that aside, if one does use component nesting, then generating `Cmd Msg` to inform the parent could be usful, I guess. Didn't think of that one, thanks!
Now I have to apologize, I didn't even tried to enter something in that textarea. I see the error and I tried to look at the code but it is too complex for my little mind. &gt; Any hint is welcome. click on the links in the error message and look at the generated JS code around the offending line. It contains hints about the places where the error might have originated. (e.g. it might have something to do with `bindP` and/or `orElse`) Review those pieces of Elm code, maybe something jumps out. Also, please document the process. You might have hit one of the documented issues of the compiler OR you might have encountered something new. In the later case, it might be useful to try and reproduce the issue in a [SSCCE](http://sscce.org/). 
Show complete index.html so maybe I can tell you more
I thought Elm's JS output wasn't compatible with Closure's advanced optimizations? Has this changed?
It probably has - I don't know how it behaved before, but now is compatible.
So the issue seems to arise because of the order of definitions in the generated js. In particular, `rChoice` is defined before `rConcat`. This results in binding an `undefined` parser, and when it tries to run, you get the error. It is not clear to me that your `lazy` would even solve the circular dependency issue, but in this case the Elm compiler seems to be choosing the wrong order for the definitions. One solution I found is to make the lazy parser an actual case of the `Parser` type: type Parser a = Parser (ParserFn a) | Lazy (() -&gt; Parser a) Then `run` needs to be updated to force when needed. This will certainly do more work than necessary, since there is no way to replace the lazy value once it is evaluated. You will also need to use lazy parsers for the whole dependency cycle: `rChoice` -&gt; `rConcat` -&gt; `rAtom` -&gt; `rGroup`. (For whatever reason, I was able to leave off the `rGroup` -&gt; `rChoice` step.)
Oh also: you might check out [elm-format](https://github.com/avh4/elm-format) for code you intend to share. It'll normalize your format and make it much easier for us random internet people to read.
Thanks a lot for your hints! Making `Lazy` a case of `Parser` combined with the use of the lazy parser for the whole dependency cycle solved my issue. Working code is pushed to repo.
👋 good to be here!
There are various ways to do it now, but it's not as useful as you'd think. There's going to have to be some more careful thought about the best way to do server-side Elm. Server-side rendering for SEO and other handoffs though… that's more reasonable, and I believe being worked on by various parties.
Oh yeah, totally! I suggested elm-combine because I learned a *ton* by figuring out elm-combine. Might not work the same for you since you're already implementing your own parser combinators though. ;)
No, but I suspect you have a more specific question. Something like: 1. Can I render HTML on servers for faster page load? 2. Can I write my whole server in Elm? 3. Can I make command line tools with Elm? Number (1) is something that is something I'm focusing on at the moment. If you need that, I strongly recommend waiting until it is done in an official way. If you want elaboration, can you refine your question?
receiving as parameter? what for?
Is there a road map as to where Elm is heading? A release cycle perhaps?
Is there an idiomatic way of "sending messages" up the component tree? If there is, is it what is presented in [this blog post](http://folkertdev.nl/blog/elm-child-parent-communication/)? If there is not, is the way presented in the blog post the best way of doing it?
I think you're looking for `Material.Layout.toggleDrawer`; see more [here](http://package.elm-lang.org/packages/debois/elm-mdl/8.1.0/Material-Layout#toggleDrawer). Likely you want this: DrawerLinkSelected url -&gt; model ! [] |&gt; addCmd (Navigation.newUrl url) |&gt; addCmd (Layout.toggleDrawer Mdl) (Although I'm not entirely sure what `addCmd` does.)
Thank you for the reply. I was heeding the advice of https://www.elm-tutorial.org/. It seemed (for me, knowing nothing) to be giving an example of how to perhaps structure an application in a way that would be maintainable when it would get larger and more complex. That is, it shows an example where different functionality of the application are separated to directories, and these parts do not depend on the main app. What would be a better example on how to create a structure that would "scale well" if that application would aim to be very complex (think GMail rewrite with Elm)? I realize I probably should start simple and then refactor later, but I would like to understand this because I want to try to create a proof of concept that would demonstrate how a more complex app would work, how maintainable it would be, and so on. The POC would probably be rather simple, but it would demonstrate the structure / architecture in such a way that one could understand that it would work well if the app became more complex, and a multi-person team would work on it.
See also: [burrito](http://chrisdone.com/posts/monads-are-burritos).
This post might help https://toast.al/posts/2016-08-14-file-structure-for-an-elm-spa.html
I'm comfortable saying the answer to this is no: there are not currently any plans to do this. :) Might be worth exploring though!
&gt; Might be worth exploring though! If you are referring to "css as a parameter", support for this is like a few lines of JS somewhere in the program code. :) loadCSS = function (document, css) { var style = document.createElement('style'); style.type = 'text/css'; style.textContent = css; document.head.insertBefore(style, document.head.lastChild); return true; } 
But then I could not use elm-reactor
No problem :) I've looked into this a lot, and it's safe to say it'll be a while. I think "having a language" is about 5% of the work that goes into the language being nice in a particular domain, so even if I directed all effort at servers, I'd expect it to be a few years before it was really competitive with other options in practice. As an aside, I think node.js would not be an ideal runtime for something like this. (1) Elm is capable of having light-weight threads like Erlang and Elixir and (2) it is designed such that it's not tied to JS in a deep way. I did all this on purpose from the start, and I think it'd be a waste to not take advantage of that in some theoretical server runtime.
Possibly a better term could be found than product type for this. I mean, yes, they are technically products, but the prototypical example of a product is binary. This type alias Player = { dollarsOnHand : Int , dollarsInBank : Int } is also a product, and is a "better" product than type Dollar = Dollar Int ("Better" here is in the sense of cognitive semantics and prototypes. Robins are "better" birds than penguins are.)
Hi, Thanks for your response, although this looks nice I would rather not use it due to: &gt; However, there is no guarantee that he will and he might even somehow block access to the port converter functions that are essential for Frontier to work, so use at your own risk.
&gt; As an aside, I think node.js would not be an ideal runtime for something like this. (1) Elm is capable of having light-weight threads like Erlang and Elixir and (2) it is designed such that it's not tied to JS in a deep way. I did all this on purpose from the start, and I think it'd be a waste to not take advantage of that in some theoretical server runtime. Maybe someone with enough Erlang knowledge could create an Elm compiler that outputs code for BEAM. It wouldn't even have to be the entirety of Elm, just enough support in order to allow implementation JSON APIs in Elm. :) Couple that with some kind of immutable DB interface library similar to Datomic and you have an insanely interesting value proposition. 
&gt; to leverage + You mean "to use +"? 
I always enjoy hearing about ways to make code naturally more intuitive. The problem that's being solved here is one I have a lot when reading Elm docs. Over the weekend I was working with the Bitwise package, and needed to do a bit shift. Here is the documentation I was looking at: http://package.elm-lang.org/packages/elm-lang/core/latest/Bitwise#shiftLeftBy The function definition for `shiftLeftBy` gives no indication which argument is the value being shifted, and which argument is the shift amount. All we get is this: `shiftLeftBy : Int -&gt; Int -&gt; Int` It can be inferred by looking at the example, but only if you work out the shifts in your head and deduce given the result: ``` shiftLeftBy 1 5 == 10 shiftLeftBy 5 1 == 32 ``` I've also worked in Elm enough now to be generally aware that the value being operated on is the last argument, for the sake of making the function pipe-friendly. Even then, reading docs like this can be painful. The thing is though, it's not practical and doesn't make sense for these packages to define new types. There seems to be something missing, either with the documentation format or function definition, that gives semantic meaning (even if informal) to the arguments a function accepts.
Really cool! But the scrolling on the page makes it impossible to play :P I would suggest reversing the order, putting the selector at the top and then ordering the guesses by most recent at the top. Then the user doesn't have to scroll down to pick blue every time they guess when the list is already full.
You're welcome! In your case, the only risk is that you might have to make hand-crafted decoders later, but by not using it you're guaranteeing you have to make them now. The real risk is for people who use elm-frontier's `call` function because that would be much trickier to get the same functionality with just pure Elm.
It probably does make things harder to read - and you have to implement your own arithmetic functions in order to do 'dollar math', to boot. Its a pain, but the win is that you can't pass non-dollar quantities into functions by accident, because to do so creates a compile time error. If you rely only on variable naming, the compiler can't help verify your code, and you're vulnerable to passing quantities into your function that takes dollars, or [kilometers into your miles](http://www.cnn.com/TECH/space/9909/30/mars.metric.02/index.html?_s=PM:TECH) function. 
Is the elm_stuff directory location listed on your elm-package.json ?
Is it actually possible? It seems to use binary data and Elm does not support Array Buffers I think?
Yes.
Maybe try searching on github https://github.com/search?q=chat+language%3AElm&amp;s=stars&amp;type=Repositories
Hmm interesting, you seem to be planning to write multiple elm applications for your site, which might make sense depending on your use case, but it usually is better to make the rails app serve XHR requests and turn elm into a spa where it can control the pages. But, like I said, it depends m of you're making a multi page elm app or just writing little elm components.
You can't iterate over records like that. You could put all your fields in a `Dict`, and update by key. Something like this: update : Msg -&gt; Model -&gt; Model update msg model = case msg of FieldInput name value -&gt; { model | fields = Dict.update name (Maybe.map &lt;| fieldUpdate value) model.fields } fieldUpdate : String -&gt; Field -&gt; Field fieldUpdate newValue field = { field | value = newValue , validated = True } Here is a working example: https://runelm.io/c/q2l
Yes you cant do that with another **type**, this is an example for inspiration. module Main exposing (..) import Html exposing (..) import Html.Events exposing (onInput) import String main : Program Never Model Msg main = program { init = init , view = view , update = update , subscriptions = \m -&gt; Sub.none } type alias Model = { age : Int , name : String , fullname : String } init : ( Model, Cmd Msg ) init = ( Model 0 "" "", Cmd.none ) toInt : Int -&gt; String -&gt; Int toInt default str = String.toInt str |&gt; Result.toMaybe |&gt; Maybe.withDefault 0 view : Model -&gt; Html Msg view model = div [] [ p [] [ text "Name" ] , input [ onInput (OnInput Name) ] [ text model.name ] , p [] [ text "Age" ] , input [ onInput (OnInput Age) ] [ text &lt;| toString model.age ] , p [] [ text "Full Name" ] , input [ onInput (OnInput FullName) ] [ text model.fullname ] , pre [] [ text &lt;| toString model ] ] type InputName = Name | Age | FullName type Msg = OnInput InputName String update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of OnInput Name val -&gt; { model | name = val } ! [ Cmd.none ] OnInput Age val -&gt; { model | age = toInt model.age val } ! [ Cmd.none ] OnInput FullName val -&gt; { model | fullname = val } ! [ Cmd.none ] 
[removed]
Yes. Well. I am already having a rails app with 10 years history. At some point there was a spaghetti of jquery tricks to automate the views somehow. Then I moved most part of jquery to react components. Then I added haskell backend to make mathematical calculations instead of using ruby computing (5-10 times faster). Now I am rewriting react components to multiple elm components (2 times smaller). I know, that the best would be to make SPA with rails app as rest api server. Or even to use haskell servant api and drop rails at all. But I am not ready to remake this 10 years project from scratch. Little by little ))
I use clojurescript professionally, using reframe, which borrows some design philosophy from Elm (amongst others). We only use it for internal facing apps currently. There is a large learning curve to clojurescript, not only do you have to learn clojure (which I love), but also the nuanced subset in clojurescript, the JS interop and the Google closure API + compiler. If you are already using clojure, then clojurscript is a no brainer. I would definitely try elm, except for the fact that it has no server side rendering story yet. For a public facing site this is something to really consider if you want early &amp; easy SEO wins. I love the type system and the language in general. The error reporting is best in class at the moment and I feel an easier entry point for beginners. Without having used it in anger on a production system, I couldn't say what else you can't do. 
If the problem is the sibling getting injected, then maybe something like `div [id "container"] [div [id "quill-editor"] []]` will do the trick? As long as you leave the container div alone in elm, it should work fine. If you keep having issues, ask around on slack about tricks involving `requestAnimationFrame` and the `Html.Keyed` module. These will keep your virtual dom and manually-manipulated dom playing nicely with each other 9 times out of 10. 
@ElmCommunity - It might be a good idea to have some of these questions answered in a FAQ section in the side bar as there will likely be repeats in the future. @OP - What research have you done already? Many of these questions can be answered by spending a small amount of time on [http://elm-lang.org/docs](http://elm-lang.org/docs). I'm happy to help, and the answer to most of your questions is "yes", but I need some help from you to meet me in the middle so that I'm not copy/pasting information that is readily available.
I'll try and be more helpful than in the above post. Here are some first-pass answers. 1. Yes. You can talk to JS. [https://guide.elm-lang.org/interop/javascript.html](https://guide.elm-lang.org/interop/javascript.html). Please ask follow questions on ports if you have any. They're certainly unique, but they're great. 2. You can build entire web apps in Elm or use Elm for only part of the application. 3. Yes. [Here's one I built](https://hackernoon.com/a-sufficiently-complex-elm-application-c457d4373291#.bs9mq1nlp) 4. This answer will be nuanced and will depend somewhat on the desired user experience, the nature of your data, and your strategy for keeping the data fresh on the client. 5. See the Concurrency section in [http://elm-lang.org/docs/advanced-topics](http://elm-lang.org/docs/advanced-topics). 6. Not sure.
There are unfortunately no comprehensive learning resources for "true beginners" (learners who have no former knowledge of computer programming.) Hopefully as Elm use becomes more mainstream this will change, but until then, if you have no programming experience you're better off starting with a language like Python or JavaScript for which beginner's learning resources are plentiful. This is unfortunate, because Elm is actually a much simpler and better language that either Python or JavaScript, and should be much easier for beginners to learn provided the resources existed. - Rex
&gt; more coincidence Lol. Freudian slip? :P
I've worked in ClojureScript both for hobby stuff and a few months professionally in a pre-existing code base. I've only tried Elm for a very short spike. I've written scathing articles on both Clojure and elm being as I think there are significant problems with both. So here's some pros and cons: ClojureScript: Pros: easy to learn, fairly mature, easy to work around problems. Cons: super slow compilations, bad errors, super hard to debug runtime errors in the browser Elm: Pros: great errors, fast compilation, elm architecture is great Cons: super strict language so you need to drop down to stringly typed stuff in several cases and you can't work around this stuff yourself. Many people seem to end up writing code generators because the language is too simple/strict and you can't d anything about it. Personally I'd go with elm. But that's largely based on less experience with it and a hope that it will be better at scale. But hope is better than certainty of pain I think :P
So.. what was something you learnt building this?
I actually learned a ton. I've [blogged](https://medium.com/@ckoster22/latest) about a couple things so far relating to selectors and model design. I also put together a 14 page write-up where I describe specific lessons learned, some of which generated the content for those posts. I still have that write-up but after writing it I feared it would come across the wrong way (I tend to sound like a jerk in text-based conversations) and I have myself convinced it will not be perceived well. If enough people want to see that write-up I will share it, but it's sitting on the shelf until that time comes.
Ignore the dogma and keep using components! Right now you have two nicely separated programs that you can combine any way or as many times as you'd like using component style. If you merge them into one giant Msg and update they will be much less versatile. For instance, if you make a Checkers game, now you can easily pair it with your chat box component in the same way, Also, suppose you have 20 games that all use the same chat box component, then adding a new feature or fixing a bug in the chatbox for all 20 of them at the same time would be a breeze, because they all use the same file. I'm not actually certain that those who steer the rudder of Elm guidelines would condemn component usage in your particular case, anyways, given that your components are so extremely different, but who knows!
I can tell you that I'm pairing Elm with Elm (using node).
2) depends on your app, but most likely yes. 4) it will shine with complex SPAs
Haha :D I will :P I have the feeling huge update functions are quite common, which feels a bit crappy. Are there any other solutions for that? Perhaps another good solution for my problem might just be to make the chess and chat two different projects, and embed them in the same html page.
Others have answered point by point, so I'll give my two cents without the bullet points. There are definitely some gotchas with elm, where you'll need to Ports to talk with JS, like file handling. But you can always use JS when needed. For me the question I would ask is: how important is refactor-able code to you? In my experience that's the main advantage I've had with elm. Since I have a relatively large elm codebase that changes often, it's been more than worth using ports to deal with javascript every once in a while. If you've got a MVP deadline in the near-term, you might get frustrated with elm. If you want long term refactorability, I would definitely suggest elm.
&gt; In the simple and contrieved example below Can you post the non-contrived version? This is a case where the right approach really depends on the specifics of your code, including how involved it is. :)
&gt; I can't find any information on how to structure a bigger project, with multiple parts, without creating a huge main update. Or is it normal to get a convoluted main update function? Here's how I advise going about it. https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbuu0m4/ This approach has worked great to scale our 80,000 LoC production Elm code base. :) &gt; It feels like, if I make Chat and Game "pure" that all the logic has to go to Main.elm, which will make the main update huge. This is a great point! The key is to focus on treating one symptom at a time. If the concern is that "main's update would be huge," then split up main's update. That's something you can and should do in isolation from the other parts of the app! Having said that, if you're happy maintaining your current code base, then I wouldn't go out of my way to refactor it. At this point you're probably not going to feel the downsides regardless. :) The advice against thinking in terms of "components" is about avoiding problems as you scale. Specifically: thinking "I'll make a new component for that" can lead to painfully overcomplicated code in comparison to "I'll expand my code one function at a time, and then refactor as necessary if the result feels too big." Once you've chosen the former a bunch of times, you end up with a lot of superfluous wiring that slows down development without any benefit. Here's a post with some more on that: https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbkpgbd/
[removed]
Thanks a lot! I will have to look into it a bit more in the coming days, but it's already helping me :D My current project is mainly for learning purposes, so I don't mind refactoring if it makes it better. I wanted to try out WebRTC, but dislike javascript, so decided to freshen up my Elm a bit at the same time. (Hadn't done Elm since 1.6, and I really like programming in it, so it's fun too :D )
Regarding 1, Elm does provide you full access to the browser via JavaScript ports, but because Elm renders a virtual DOM, if you need to access DOM element metrics (like height and width), you might need to use an Elm helper package like `elm-dom`: http://package.elm-lang.org/packages/debois/elm-dom/latest. - Rex
It worked! This is what I did: getLocation : Cmd Msg getLocation = Task.attempt handleLocation Geolocation.now handleLocation result = case result of Result.Ok location -&gt; UpdateLocation location Result.Err err -&gt; ErrorLocation err While this works, i'm not sure how you would use the `Task` directly? Or is that something you don't really do.
Yeah, it very well might not be. Sorry.
To have an effect happen you always need to return a `Cmd` to the runtime (usually by return it from `update`). `Cmd` is very simple and there isn't a lot you can do with a `Cmd` other than return it to the runtime. The value of `Task` is that there are more things you can do with it. You can sequence multiple `Task` together (like you can with a Promise in JS) using the `andThen` function. This ability can be useful because it means you don't have to produce a `Msg` for each step in the sequence. eg. You could get the user's geolocation and pass that to a `Task` that did a HTTP request to send that to your server.
`Task` and `Cmd` have different ideas underlying them. `Task` defines `andThen` with the intention of being able to chain them together as a set of steps which abort if one of them has a failure. A `Cmd` is describing one or more *concurrent* actions which might fail independently. When you wrap a `Task` in a `Cmd` you are saying that it is complete and ready to be bundled with other things to be handed off to the runtime.
Thank you for the link; I have read it before but didn't realize the parallels in his situation and mine until you linked it. thanks!
Thanks /u/AdmiralFisticuffs ! Unfortunately, while I do agree with you, I haven't learned Clojure (yet) and my colleagues expressed disinterest in the syntax. Going to take the plunge into elm; but thanks so much for your input!
/u/xianralph thanks for your input! I do think I will learn clojure in the near future (or at least a lisp-y language). Given the comments made by you and others in the subreddit as well as the book (R. Feldman's - Elm In Action), talks, and online classes that I've already purchased, I'm going to go with elm! Thanks again for nudging me into commitment :P
&gt; easy to learn Maybe easy was the wrong word. The learning curve is nice and shallow at least. You can do simple things easily and fast and learning more of the language is just learning one function/macro at a time. &gt; compilation speeds Yes. It's super slow. &gt; source maps Overrated. The problem is they MASSIVELY increase compilation times. Remember that they were slow before so with source maps on it's pretty unbearable. I worked with them off and only in extreme cases did I turn them on. In those cases the compiler didn't even catch the change so you had to nuke the build dir to force a recompilation. :( &gt; strictness You probably need to go back to fairly weak dicts and stuff regularly anyway. &gt; code generators A big problem is the lack of introspection. For example union types can't be converted to/from a string (or int or whatever) so they can't be used as proper enumerations when dealing without the outside world. Unless you write json encoders/decoders which is copy paste hell. If you also want to generate some DOM list based on a union type it's even more copy paste mess. That's one thing people turn to code generators to fix. Another solution is to just never use union types when it might at any point interface with the outside world. That's what I would recommend. 
Thanks for the feedback, Richard. &gt; This is a great candidate for https://github.com/elm-lang/error-message-catalog I'll go and do this today. &gt; I wish there were a Html.none for this, but in the absence of that I use Html.text "" There were two use cases I have in mind that I'm concerned this wouldn't work with, but it turns out neither is actually a problem after I tried to create a SSCCE. The first one I thought would be a problem but isn't is a use case where the parent div is flexed with `("justify-content", "space-around")` and there is a conditional child `Html.text ""`. I assumed the spacing would be off with an invisible child text node, but turns out it's fine. The second one, which again isn't an issue after all, is a `select` element with a few `option` children elements, and one of those children being a conditional `Html.text`. I expected a blank option in the drop down, but it wasn't there. So, I think I'll be using this trick in the future as well. Thanks! Also, TIL that `Html.text`is a legal child of `Html.select`. Re: "must fix immediately" - I am putting perhaps more urgency on it than necessary. All I can relay is the anecdote of observing Elm beginners in the room looking for `Http.patch` or looking for `Http.delete` and being surprised that such a thing doesn't exist. To which they ask me for help and we pair up and write our own patch or delete. When someone's first go around with Elm gives them a first impression of "Elm is great, but for some reason their Http library is missing basic functions", that's a skewed first impression that is easily worth avoiding, IMO. I'm glad to hear and looking forward to the upcoming improvements to elm-test! Thanks again for the feedback.
Makes sense. Thanks Wouter!
Excellent info! Thank you for taking the time to document this. One curiosity, how big did the app got in terms of lines of code? 
What about the ^ operator like Elixir to match the value in the variable instead of pattern matching? let a = 2 x = 2 y = 3 in case a of ^x -&gt; "x" ^y -&gt; "y" 
Hi! Awesome reply. I'm a Rails/React dev who has dabbled in Elm and wants to learn more - curious when you are releasing the next stage of Elm in Action? :)
Richard, do you have a semi real world example of this? From seeing/listening to other content from you, you advise against a 'component' style. Does this mean you against a structure like this https://toast.al/posts/2016-08-14-file-structure-for-an-elm-spa.html? I get the idea of not using the component style, I'm just not sure how to structure this in terms of folders and files.
Ok, so I've actually got one this week! Is there a reasonable way to do flash messages (á la `ActionDispatch::Flash`) in Elm? API description from Rails below: &gt; The flash provides a way to pass temporary primitive-types (String, Array, Hash) between actions. Anything you place in the flash will be exposed to the very next action and then cleared out. This is a great way of doing notices and alerts, such as a create action that sets flash[:notice] = "Post successfully created" before redirecting to a display action that can then expose the flash to its template. Actually, that exposure is automatically done. Everything I can think of involves sending messages up the update tree to a centralized component… which makes me say the word "component"… which makes me think there's probably a better way! What haven't I considered yet here?
Lovely, can't wait!
My guess is that the [taco approach](https://github.com/ohanhi/elm-taco) is appropriate here. You give the views a context object that can facilitate the flash. 
Is there an open source, reasonably complex Elm web-app that can be used as inspiration for scaling the Elm architecture? I'm looking for something that fits the following bill: - is implemented with Elm best practices - has multiple pages - is mobile first (responsive web app) - implements reusable bits (sidebar, top bar, form elements and composites of form elements, e.g. login form) - has authentication - has tests - has automated building 
Can I ask what the use case is? The coupling of two arbitrarily consecutive messages feels like an XY problem on its surface, so it's possible there are better ways to resolve the use case you're facing. It seems like the behavior described in the quoted text could be accomplished with vanilla `Http.send`, but it's hard to tell without more specifics.
I've made this post on my blog to try and give a simple example of creating a module that contains a reusable view. I've based this off the old component based `CounterList` example that used to be in the Elm guide. Please let me know if it's not clear, or has been implemented poorly!
Not all of these fit your criteria, but a good place to look might be http://builtwithelm.co/
This is a really nice suggestion. It bothered me too, but I couldn't think of a way to it neatly. Feel free to make a pull request on GitHub, otherwise I'll refactor it when I get home.
Is there a way to let long running computations run in the background? Context: I made [this obj. file loader](http://package.elm-lang.org/packages/Zinggi/elm-obj-loader/latest), but the parsing is pretty slow. If I give it a reasonably big file, the browser freezes and nothing happens until the parsing is done. Is there any way around this? Maybe using [Process](http://package.elm-lang.org/packages/elm-lang/core/5.0.0/Process)? And what about indicating progress? Almost seems like this isn't possible with a pure language...
Not much to choose from. Most of those are games or game-like explorations of Elm. [The News](https://github.com/mthadley/thenews) looks quite interesting. 
 String.left 1 string1 |&gt; String.startsWith string2 is equivalent to (String.left 1 string1) |&gt; (String.startsWith string2) This is because function application has higher precedence than any operator. That is then equivalent to (String.startsWith string2) (String.left 1 string1) This is from the definition of the `|&gt;` operator. That definition is very simple: x |&gt; f = f x Finally, because function application is left associative, we can remove a set of parentheses: String.startsWith string2 (String.left 1 string1) If you want String.startsWith (String.left 1 string1) string2 you are probably better off just writing that. It is possible to rewrite without parens, but it would not be likely to increase the clarity of your code.
The |&gt; operator in: a |&gt; b This is the same as b a Which roughly translates to: "I want whatever `a` is, and pass that as an argument to `b`." How is this useful? Well, usually (like in your case) `a` is a function with a bunch of arguments, and `b` is too, and you would pass `a` as the last argument. The reason your example doesn't work as expected is because the arguments in `String.startsWith` are not what you need. String.left 1 string1 |&gt; String.startsWith string2 is equivalent to String.startsWith string2 (String.left 1 string1) Which is not what you need, because the arguments are in the wrong order. If you really want to write it without parenthesis, you could use `flip` for to "fix" the arguments in the wrong order: String.left 1 string1 |&gt; flip String.startsWith string2 But in this example, the version with parentheses may still be preferable. 
Ah, excellent. I'm used to the magrittr pipe function in R which tends to pass things into the *first* position instead of the last position. I understand now. :)
First, that project is awesome. Great work! :D # Optimization I'd start by trying to make the parser faster. Tips include: - Avoid backtracking. You do not want to reparse whitespace multiple times for example. - Avoid char-by-char parsers. A parser for `"hello"` is way faster than a parser for `'h'`, `'e'`, etc. **Can you share an example of an .obj file you can parse?** From there: - I can learn more about where your bottlenecks are likely to be. - I recently made the parser in the compiler a lot faster, and I'm trying to release those same techniques as an Elm package. Not sure when that will be available, but learning more about your case will probably help! # Process Process would be a partial answer assuming lots of things were different: 1. The runtime needs to do preemptive scheduling. JS makes this very hard. 2. The Process library needs to be much more mature. Right now, communication with processes is very limited, so it can't do what you need even if preemptive scheduling was viable. This would let you "run it in the background" but you still couldn't show a progress bar with the parsing libraries we currently have. # Pausing Parsers I think it's *possible* to create a parser that can "pause" after some number of steps. This would let you break the work into chunks and show progress. I think this is much more manageable than the `Process` stuff. I have not figured out how to make pause-able parsers in Elm yet, but having a `parse` function that let you see progress would be amazing, and if any community folks are reading this, figuring out how to do this is a more promising community project than the `Process` stuff.
Really interesting post. I mentioned in another thread that having a suitably sized example to poke holes at would really help me understand why these kinds of practices (such as adding a Config) are recommended, because I'm not so sure yet why they are. This is a very small example, nonetheless I think I'll take this as an opportunity to write up my own implementation from scratch and maybe we can compare notes later.
Alright, finished. [https://gist.github.com/ckoster22/5d61996c3d57c2b0f9509b3457a6bb17](https://gist.github.com/ckoster22/5d61996c3d57c2b0f9509b3457a6bb17) (copy/paste in [http://elm-lang.org/try](http://elm-lang.org/try) to see it in action) There are several things that I want to point out, the first of which is that we're not comparing apples to apples. I changed my `Model` to look like this. type alias Person = { name : String , favoriteNumber : Int } type alias Model = List Person I did that for two reasons. The first is the example feels a little more real. This is an application for managing people and their favorite number, rather than an app for managing arbitrary numbers floating in the aether. It's a little easier for me to think about if the example is more real, so apologies if it feels like a bait and switch. The second reason is I consider it an anti-pattern to put view model information inside of `Model`. I do have a `CounterModel`, but that is derived from something in the model (in this example it's a simple 1-to-1 mapping of `favoriteNumber`), but never will I put view models inside of my single source of truth, because that's not where derivative data belongs. The next thing worth pointing out is that I'm using a `List` instead of a `Dict`. That's just a personal preference since `ID` is synonymous with `index` in this example. No big deal. Next up.. the `Msg`. type Msg = CloneMe | UpdateFavNumber Int Int -- clone index, new num | PurgeFavNumber Int -- clone index Here's our first major divergence. When I review your Msg I see that the reusable counter module is leaking into the Msg. Whereas I think the above Msg is defined more in "business rules", regardless of what underlying reusable modules are used to either present the data or accept input from the user. The update function is self-explanatory given the `Model` and `Msg` defined above. I won't paste it because it's a little long. Again I think the thing to highlight is the update function has no knowledge of the underlying reusable module. I can swap out the reusable counter module with something else and the update function doesn't care. All the update function is concerned about is updating the single source of truth. Lastly, the view is where the single source of truth `Model` gets molded into something the reusable view can understand. view model = let counterViewModels = List.map .favoriteNumber model in div [] [ text "Favorite numbers from different people!" , div [] &lt;| List.indexedMap counterView counterViewModels , button [ onClick CloneMe ] [ text "Clone!" ] ] So I'm very curious in what your thoughts are in comparing the two. The point I want to highlight is the reusable view is contained in the view layer, where it belongs IMO. If I ever decided to use an entirely different reusable view I wouldn't need to change either my `Model` or my `Msg` which is a feature and not a bug. Again, sorry they're slightly different examples. I hope it's an ignorable enough difference that we can still discuss any trade-offs between the two different implementations. **Edit:** After thinking about it more the reusable module could be refactored further to be even more agnostic (more reusable) by accepting click Msgs as arguments. view : Model -&gt; Html Msg view model = let counterViewModels = List.map .favoriteNumber model in div [] [ text "Favorite numbers from different people!" , div [] &lt;| List.indexedMap (\index viewModel -&gt; let decMsg = UpdateFavNumber index (viewModel - 1) incMsg = UpdateFavNumber index (viewModel + 1) clearMsg = PurgeFavNumber index in counterView decMsg incMsg clearMsg viewModel ) counterViewModels , button [ onClick CloneMe ] [ text "Clone!" ] ] -- This would go in a different module -- module ReusableCounter exposing (counterView, CounterModel) type alias CounterModel = Int counterView : Msg -&gt; Msg -&gt; Msg -&gt; CounterModel -&gt; Html Msg counterView decMsg incMsg clearMsg count = div [] [ button [ onClick decMsg ] [ text "-" ] , div [ countStyle ] [ text (toString count) ] , button [ onClick incMsg ] [ text "+" ] , button [ onClick clearMsg ] [ text "Clear" ] ]
Hey I copy pasted your code on runelm.io so that it's easier to poke around with it :) https://runelm.io/c/gv3 Your detailed write ups are awesome, really good to see the reasoning behind a chunk of code
I think this is great, the only thing I find a bit too heavy is the `config` function, as it seems completely redundant. How about just using the data constructor? counterConfig = Config { modifyMsg = ModifyCounter refID , removeMsg = RemoveCounter refID } Awesome post btw! :D
[https://www.reddit.com/r/elm/comments/5o5p63/experiences_with_elm_on_a_small_production/](https://www.reddit.com/r/elm/comments/5o5p63/experiences_with_elm_on_a_small_production/)
Thanks for the feedback!
Ok, let me be more specific then. Let's say I have `Cmd` to persist data. Being an impure function, it can succeed or fail. When it returns, I would like to show a message to the user telling them whether the data was saved or not. I have several different places where data can be persisted, and I'd like the messaging experience to be consistent, without repeating myself too much in code. Actually, now that I phrase it that way a view helper function may be most appropriate. Since the messages are ephemeral, they don't need to live in the model. I'll have to think more on this.
Thank you so much for this very detailed answer! &amp;nbsp; &amp;nbsp; &gt; Optimization You are right, that's what I should do first. When trying to open a 23mb file, my browser froze and I killed it after waiting 10 minutes. For comparison, blender needs 4 seconds for the same file. So there is a huge margin for improvements. I'm using [elm-combine](http://package.elm-lang.org/packages/Bogdanp/elm-combine/latest) for the parser. This is the first time I've used a parser combinator library, so I probably made some mistakes. Maybe using that library was also a bad choice, as the obj file format is very simple and a simpler parser would suffice. It should even be possible to parse it via regex. One place where I'm certain its slow is the parsing of floats. The problem is that .obj files allow leading zeros and e notation. `Json.Decode.float` doesn't support leading zeros, `String.toFloat` doesn't support e notation. As a consequence, [I rolled my own](https://github.com/Zinggi/elm-obj-loader/blob/1.0.0/src/OBJ/Parser.elm#L184-L204), which is most likely wrong and slow. &amp;nbsp; &amp;nbsp; If you have time to look at it, here are [three example .obj files](https://github.com/Zinggi/elm-obj-loader/tree/1.0.0/examples/meshes). These load fast enough. A huge model can for instance be found [here](http://www.crytek.com/cryengine/cryengine3/downloads) (Crytek's sponza model) &amp;nbsp; &amp;nbsp; &gt; Pausing Parsers Yeah, this would be pretty cool, but would require more work for a user, right? A user of my library would need to call `start`, then multiple times `step` until it's complete. Is this where an effect manager comes in? E.g. to provide update notifications via subscriptions? &amp;nbsp; However, even if I could pause a parser, The browser would still freeze for big models, as after parsing, the results have to be processed. (to calculate vertex tangents + indices). This would also have to be made pausable, which might be even trickier. &amp;nbsp; &amp;nbsp; **Other possible solution:** Having a variant of `Task.success` that runs in a web worker would be a lot easier. This way you could wrap any long running computation and get it's result back as a message. This doesn't allow progress report, but might be good enough for many purposes.
I'm gonna read whatever people write on there, so probably doesn't matter. 😄
No problem! And thanks for the examples and code links, very helpful! * * * **Regex:** I bet regex would be faster. The main implementations are decades old C libraries, which I believe browsers use behind the scenes. So if you can `String.split "\n"` and then regex the lines, that may be faster. The Elm `Regex` module was designed when I understood the key bottlenecks less well, so I bet it could be faster than it is. In any case, I would be curious to learn the comparison! **If your open to it, I would love to race .obj parsers written in three ways. One as is, one with regex, and one with my library.** I think we could learn a lot from that! * * * **Bottlenecks:** The only thing I can say about your number parser is that it is probably "reparsing" parts many times as is. I'm not certain. Can you say more about the weird number formats that are permitted? Which of these work? 1. `0123` - In JS, I believe this is an octal number, so it's actually equal to `83`. Is that the case for you as well? Or can you give me an example of a number with leading zeros? 3. `1.34e10.4` - Never seen decimals in exponents. Is that allowed? If I understand the crazy cases, I can do a better job in my library on this. * * * **Progress:** I mean, you would not *need* to call `step` by hand. It could be in various helper functions. Like this: run : Parser a -&gt; Result Error a run parser = case step parser of More nextParser -&gt; run nextParser Good a -&gt; Ok a Bad x -&gt; Err x This would trigger tail-call optimization and become a `while` loop. I'd expect most folks to use `run` directly, and never think about `step`. You could also write a version that did this with tasks. So after a certain number of steps, it would sleep for 2ms or whatever. That way other stuff can do work. That could also be a helper function though. So in my mind, you wouldn't need to know that it's an incremental parser to use the library. * * * **Web Workers:** The trouble is that you cannot send functions between web workers. JS severely limits the kind of concurrency we have *reasonable* access to. 
Hey. Just wanted to say that I enjoyed reading you article and that I'm glad others are thinking about brining GraphQL to elm. Specifically, I liked how you highlighted your thought/design process -- starting with just a simple String representation and then moving to a more complex List/Html like representation. I'd like to offer up a few api suggestions stemming from work which has been made in similar projects. You might already be thinking about these things... and in that case great! :) First off, have you considered representing your Query more like how Decoder is represented? Doing so gives you the benefit of being able to build up both the query and the decoder at the same time. To my knowledge, representing Fields with a list like you have done, although making for a beautiful DSL, makes it difficult (maybe impossible?) to build up the decoder at the same time as the query. Checkout [this lib!](https://github.com/jamesmacaulay/elm-graphql) for some reference. Next, have you considered representing the Schema on the front end? Essentially, you would have a single place where the "shape" of the backend is represented. I've had a bit of success with this in a [library of my own!](https://github.com/john-kelly/elm-postgrest). Although the library is **not** for graphql (it's for something very similar called postgrest), I believe that some of the API could find its way into similar libraries. I call the "Schema" a "Resource" in my library, but the idea is the same -- a representation of the backend on the frontend. I found that representing the schema, in part, as a record makes for a really nice DSL when building queries (thanks to record accessors!). Anyways, thanks again for the post! Was fun to read and it is reassuring that others are thinking about this stuff.
Thanks. I guess I'll try regex and see how much faster it would get. The race sounds like a good idea. **Floats:** The problem is that there is no description of what's allowed and what isn't in the specs, so I don't know actually. I just learned this by looking at many different files. 1. Unfortunately I can't find the one with leading zeros anymore, but from what I remember it was used as padding, so still base 10. (E.g. `002`) It seams to be rare, so I'll probably just switch to `Json.Decode.float` and not support that. 2. I haven't seen this, so I assume it wouldn't be allowed. **Progress:** You're right, for the average user, `run` or a task that sleeps seems to cover most cases, so this seems like the way to go. If I can manage to make every long step pausable. **Web Workers:** I wasn't aware of all the restrictions. Now I educated myself. What a pity -.- &amp;nbsp; [EDIT]: I started some benchmarks, and switching to `Json.Decode.float` doubled the performance of the parser. (still too slow). Also, the parser *is* the bottle neck, the processing takes ~0.1x of the parsing.
You could replace the `onInput (\i -&gt; modifyMsg &lt;| Input i)` with `onInput (modifyMsg &lt;&lt; Input)`. A bit less ugly. Some further and broader thoughts: It looks like in your case, your `Game` and your `Chat` are 2 completely independent entities. * The chat Model holds messages and user input, and this information is not shared or communicated in any way to the game. Any message is filled by user input in the chat view. * The chat view does not output any messages relevant for the game. All messages that the chat view generates are for consumption by the chat update function. * The chat sends and receives messages from the (imported) WebRTC. The outgoing and incoming messages are not used by the game. The `config` that you created is a common pattern. It is really useful if you have some messages for internal consumption by the Chat, and at the same time also have messages to communicate with the rest of your app. E.g. in a datepicker view, where the `PreviousMonth` and `NextMonth` could be internal messages, but `SelectDate date` would be a message to communicate to the rest of the app, to be handled beyond the scope of the reusable element. In your case, all your messages are for internal consumption by the Chat. Which is fine, but you may find that the benefit of the config is minimal. If you expect to get more interaction between game and chat (e.g. copy a game move suggested by the chat into the game, or have someone in the chat propose to reset the game and click that to reset the game, copy game details to a chat message and send) then you may get more benefits from this direction later. What you have now (with or without config), is a reusable chat that requires: * including the chat Model in Model * including chat update in update * including chat view in view * including chat subscriptions in subscriptions The API for your chat is a straightforward all-or-nothing API: to use chat, use all 4 elements or none (in that sense it is different from a "reusable view"). Which looks like it fits your "Main with independent game and chat" just fine. To make it more reusable: what would be another use case for your chat module? What would be different? An approach could be: build a second implementation using the chat in a different app. (I usually do just copy and paste, and then change the copy.) After that, see what you would need to change in the chat module to get a version that suits both use cases. A bit longer than I anticipated, but hopefully this provides some food for thought!
&gt; I did however think of making the game add something like "move 2a to 3a" to the chat. This should be easyer if I refactor the game the same way I did the chat, because I can then just add another function in the game's config which creates messages for the chat. Right? Yep, this would be easier. More interaction between game and chat = more benefit from the config setup. &gt; I feel like any of the examples I found, of components vs reusable-views, lack an explanation why I would choose reusable-views. If you have a reusable view which is just a view, you are much more flexible. The view function takes `data` and probably a `config` and renders the data. So the "parent" takes care of the data (and updates to data) and of the messages. That makes it easier to change bits later on, like sending the data to somewhere else, or doing more stuff with messages coming out of the view. If instead, you start with an all-or-nothing combo of Model, Msg, view, and update, it is much harder to change something later on. The data in the Model is completely hidden from the "parent". The parent cannot read the model, and it cannot intercept messages to do something with them. And very often, at some point, you will need to read the data (like what is in the chat message) or intercept messages (like send them to a game). Then it is much more work to do that: you need to add lots more code to the all-or-nothing combo, or abandon it alltogether. So general advice (or at least the approach I am taking) is to not start with any all-or-nothing combo. Just put all chat messages in the main model, include all chat Msg in the main Msg, etcetera. If one of those gets too large, I just split that part out. In your case, I would keep separate chat messages, but the chat update would have a signature of `chatUpdate : ChatMsg -&gt; MainModel -&gt; (MainModel, Cmd MainMsg)` Hope this helps!
Just a tidbit: the first issue that you mention is solved in Elixir with the pin operator.
I don't think that's the implication given that the example he gives just above is that of Applicative. Unlike pattern guards and where clauses, Applicative is not a syntactic feature. (I'm not sure what you mean by return-ing a monad so I can't comment about that one.) If I understand correctly, his point is that Elm: * does not let you abstract over type constructors (thus you cannot write a function that works "for all applicatives"); * does not encourage as a community the usage of words like "Applicative" and "Monad", which prevents you from learning more by reading non-elm litterature I'm not saying I agree with his point, but I think you're mischaracterizing it.
There is also this https://github.com/abadi199/datetimepicker
If it had existed when I needed a time picker I would have just gone with that one, looks neat. Unfortunately it wasn't there yet when I needed a time picker :)
will be a chat client. Giving the user multiple choices according to the situation but also able to understand and extract some commands from a text input by the user...
&gt; TEA is not composable, but through brute force. (..) The ways around this problem are fairly weak, and amount to, “don’t write components” (**IE don’t intend your code to be re-usable**), (..). Paraphrasing "don't write components" to "don't write reusable code" is just completely wrong. Nothing prevents you from writing reusable code. It just means that there is no silver bullet for reusable things, you have to find the right solution for each specific problem. A general pattern would be nice, but **there is no silver bullet** (not just for elm, in general). &gt; The package manger (..) actively prevents the publishing of code that binds to JavaScript. This (..) will leave gaps in functionality (..) .You can close those gaps yourself, but wont be able to share your solution. This is a bit harsh. You can always share your solution via github or some other service, just not the official package manager. Tools like [elm-ops-tooling](https://github.com/NoRedInk/elm-ops-tooling) or [elm-github-install](https://github.com/gdotdesign/elm-github-install) can help. Also, if your package is really good and wouldn't be feasible to do purely with elm, it can be white-listed.
Thank you. I wish Elm was more widespread, it's a very cool idea. Can you compare Elm capabilities, to react-redux, angularJS and other JS MVC frameworks ?
It should be enough to keep the order of level-0 comments the same. For some reason, when level-0 comment is replied to, it jumps few comments up.
Plus, this one seems not to be material design oriented, if it is an important criteria for you.
The [results from last year](https://www.brianthicks.com/post/2016/04/22/state-of-elm-2016-results/)
You have 2 options, group them all under the same message types (3 total) and then match on the response, or use different message types (15 total). Either way you're gonna have to write conditions for all the branches so you might as well make it easy on yourself and use unique message names. Try not to think of messages as clutter. Think of them more as identifying a specific type of event that happens in your system. When you use words to describe what happened, you'd say "This_type_of request got a response" rather than "A request got a response" because the latter is ambiguous and you'd have to check further anyway. 
Because `(+ 2)` is no different than `+ 2`, kinda like in algebra `1 + 2` isn't any different than `(1 + 2)`...the parentheses don't change anything. Solution as mentioned is `(+) 2` You're right, the syntax might as well be `{+} 2` I suppose
I count 2: 1. message that triggers the request 2. message that handles the response (a `Result` representing either success or error) In the linked Guide example, these two messages are: type Msg = MorePlease | NewGif (Result Http.Error String) So if you have 5 http requests, you'd need 10 messages: 5 for the user interaction, 5 to handle the responses. That seems like a reasonable number as well as a reasonable separation of concerns. :)
A decently likely explanation is that Grammarly is swapping out the textarea for another, meaning when Elm goes to update the element in-place, it's gone and the result is an explosion. If that's what's happening, I'm surprised that reordering the elements makes it no longer reproducible. It seems almost like there's a bug in the vdom where it's recreating elements unnecessarily, and what it actually ought to do is to break every time. 😅 As an aside, "change Elm's virtual-dom so that it is resilient to browser extensions which hack the DOM" is a perliously slippery slope straight into a bottomless rabbit hole, so I don't think this is likely to change on Elm's side. Might be easier to see if Grammarly can change their extension such that it no longer breaks Elm apps. 😬
Nice, thanks for sharing! I have not looked that closely at it, but a couple questions jump out at me. - Why did you decide to implement the search internally instead of having consumers provide a filter function? It sounds like you are thinking of switching to the latter? - It seems like SearchableMenu doesn't provide any extra state and not much extra functionality on top of your SearchableMenu.SearchableMenu (i.e. internal implementation). Could you just collapse these two modules? What advantage is there to have them separate? - You store `selected` state in your internal model. But often there are situations where this state "comes from the outside": for instance, an edit form where something in the menu was previously selected. How would you handle initializing the model in such situations / keeping this state in sync with the state that lives outside ? (To me it suggests that selected state _maybe_ does not belong in the internal model, as unintuitive as that seems). 
Hmm. I guess that is so... Dunno why I didn't think about that.
Wait, shouldn't this create a circular dependency problem?
By prefering the elm variant you mean that you use `-x` much more often than (/ x), (- x) etc? I don't personally like the haskell workaround. It just introduces an ad hoc rule. `0 - x` or even `neg x` would be. much more appropriate. But I don't like the elm solution either. Making `-` prefix by wrapping it into parentheses is just another ad hoc rule solution (because you removed partial application). Both of them don't make sense and need to be memorized. The elm version at least doesn't lead to confusion. But I don't get why elm just didn't forbid using `-` as unary which makes much more sense. You have already showed that error messages can be pleasant experience and wrong use of `-` (as unary operator) is *super easy* to detect. `main = text -1` &gt; It looks like you have tried to use - as an unary operator. In elm +-#...&amp; are all threated as binary opertors (infix functions) **with no exception**. Use `0-1` or `neg 1` instead. 
That looks good! Would you be interested in submitting a PR for elm-mdl? @guid75: Looks pretty close to the Material spec to me: https://material.io/guidelines/components/pickers.html#pickers-time-pickers
Grammarly will have to fix their extension so that it doesn't modify the DOM in that way, with in increasing number of sites using virtual-dom based frameworks they'll be breaking an increasing number of sites.
Could you talk more specifically about what you're trying to accomplish? I'm sure there's an answer, but this is probably not about syntax.
Ramda works like this because… well I think because there is no other way to do it in JavaScript, I guess. The: R.pipe(a(1),b(2),c)(d) will translate to: c(b(2, a(1,d))) which is similar to the |&gt; operator: a 1 d |&gt; b 2 |&gt; c, but in this case, the "d" argument does not get applied at the end. When thinking about it more, I am not sure if R.pipe is equivalent to |&gt; (i.e. application), or is it more like &gt;&gt; (i.e. composition)? 
I know what the desired syntax would be. But I think it may be an XY problem. :)
Thanks for the answer! Trying to explain to you the context, I realized the mistake in my approach. I'm new to functional programming and come from an object-oriented background, and naturally slipped there :) Anyway, I'm still curious why elm doesn't allow this case of record.field expression. I get a very vague error in the compiler when I try it: "I ran into something unexpected when parsing your code!", underlining the dot in "record.field"
That's exactly what I mean, yes. I'm curious as to why this is forbidden in elm. 
Is the ticket public? If so could you link it, I've also received a support ticket from a user and Grammarly turned out to be the culprit. 
This was really helpful.
Nope, not public - but I'll update with any info I get from them.
Let me see if I can summarize. * In `core`, you have `List.map2` which works a certain way. * In `elm-community/list-extra`, you have `List.Extra.lift2`, which has the same type as core's `List.map2`, but it does something different. * Situations like this are error-prone and potentially confusing. Does that sound about right?
Yes, that's what I think as well. However, both are sensible implementations, it's just that there are (at least) two ways to combine the elements of two lists. This, I think, is an inherent problem of applicative functors. It can only be resolved with better naming and/or comments.
Did you have to do a lot of vector math? How was that in Elm?
Is there a canonical way to **optionally** add an element to a list? As an example, I often want to construct my view function as follows: view: Model -&gt; Html Msg view model = div [] [ displayMenu model , if model.condition then displayOptionalElement model else &lt;not sure what to do here&gt; , displayOtherStuff model ] Sorry about any formatting issues above. Hopefully the question is understandable. Thoughts? 
I haven't made any Haskell programs, apart from simple expressions, and I'm still pretty new to FP, so I wouldn't know why. I myself was intrigued by the "coolness" of liftA2 on Lists, when I read about it in Learn You a Haskell for Great Good, but that isn't a particularly good argument for supporting it :)
Come to think of it, for unordered sets, the cartesian product version would be the only sensible implementation of map2, wouldn't it?
Thanks for letting me know! Really motivating to keep posting!
Interesting! I still don't think it's what you want, semantically, but I'm glad that that's optimized!
Hi, OP here. This is right, Elm made this fairly straightforward, though I don't have a good basis of comparison in other languages. You can see a lot of the code in place for this here: https://github.com/mwunsch/hive-city/blob/master/src/Tabletop.elm
My update function looks like this: https://gist.github.com/cschneid/da2a04415b85b9ca5b1773e08a82eed8 It's a very simple app so far, but update is already rather large and hard to reason about. Is there a standard pattern to organizing this or splitting it up into multiple functions?
You could do ``` div [] (List.concat [[text "foo"], optionalItem, [text "foo"]]). ``` If the empty text node causes you issues, that wouldn't make any real nodes. `optionalItem` would have to return an empty list in the case it didn't have anything. 
Thank you for the suggestion, I'll try with a boilerplate to see if it's easier to get going. 
Personally this repo helped me out heaps, just being able to see an actual working implementation was great: https://github.com/rundis/albums
Done, thank you!
I wrote in another comment some background on this decision. Short version is that I think there should be a separate library like http://package.elm-lang.org/packages/Apanatshka/elm-list-ndet/latest to address the **use case** for `lift2` which exists and is quite specific. Just because something *can* adhere to a particular pattern, doesn't mean that's the right design without further reflection. * * * People have a lot of confusion about type classes, so I wanted to address this statement: &gt; since Elm doesn't have type classes, the term "applicative functor" isn't an Elm thing This concept is just a pattern. It exists in every language independent of type classes or any other language feature. Python has them. JavaScript has them. Everyone has them. It is just a pattern: function lift2(f, xs, ys) { // JS implementation } The question is, do languages *emphasize* theoretical concepts before people have any *experience* with those concepts? To put it in different terms, every language has [groups](http://mathworld.wolfram.com/Group.html). It's just a pattern. In fact, addition on integers forms a group. But that does not mean that people get introduced to the closure, associativity, identity, and inverse laws before they learn that `1 + 1 = 2`, `4 + 7 = 11`, etc. Most college students do not learn about groups much, **and yet**, somehow, they can do multiplication and rotate door knobs. So what I'm trying to say here is (1) all this stuff is just patterns, (2) you can recognize these patterns in many contexts (like door knobs!), and (3) we choose not to force this recognition on *everyone* because it is often more confusing than helpful for beginners and ultimately does not give much utility until you are writing quite abstract libraries like `Task` or `Result` that deal with execution order. **In other words, you should not have to be an expert in ergonomics and back physiology to be able to sit in a comfortable chair.**
I used `lift2` in [a demo](https://gist.github.com/toastal/739a16c21d9060e3c2d36eef2bf02e58#file-cards-elm-L44). It could see is being used a lot for tuples to create all of the permutations of two lists--which is what others are basically hinting at. 
`Html.none` has been proposed before. I'm not convinced it's the best option. Ideally, for me at least, there would be a succinct and readable way to conditionally add or not add an element to a list. I don't know what that would look like though.
One option is to take the body of each case statement and throw it into a helper function like [this](https://github.com/ckoster22/lightning-talk-app/blob/master/src/Update/Show/Update.elm) (though I'll probably end up breaking chunks of those helper functions into other files). Another option is to get creative with pipes and helper functions like [this](https://becoming-functional.com/making-the-elm-model-modular-7c8a8dcdbf3#.cqyd1ki2m). This one might actual suit your situation quite well. I'm sure there are other ideas rolling around too. The important thing to realize is it's just a function, and you can clean it up the same way you'd clean up other functions that get too big.
Why not just have a function that explicitly is for this case? Maybe call it `permutations` and maybe have a library all about that kind of thing. Relatedly, I had a draft of a [grid](https://github.com/evancz/grids) library that was built on a similar idea. You would give two lists: row values and column values. It would then put them together into a grid. This specific case definitely exists, but I think calling it `lift2` is pretty silly. In both cases, I do not want to become maintainer of this kind of project and I think it's still a bit too experimental to be in core. It'd be cool to see `list-extras` move towards naming for specific use-cases. So I'd be in favor of dropping `lift2` and adding things like `permutations` and `grid`.
It does add an extra DOM node, it's just that the browser dev tools don't render it in the Inspector. :) Put that code into Try Elm and run this in the console: document.querySelector("body div").childNodes The result will be 2 text nodes, one with a `textValue` of `"Hello World!"` and the other with a `textValue` of `""`.
Here's how I'd refactor it. :) https://gist.github.com/rtfeldman/913e88a9254b3e3ff7473c6747e267f4
[removed]
I'm loving the book so far. When can we expect chapter 05?
Nice man, looks awesome! I'm glad you're living Elm 😁
Port the library 0.18. You'll be helping out others and not replicating a bunch of work that's already done. 
Next step is to sneak it in at work. ;)
I just did! xD
There is this https://github.com/xarvh/elm-audio in elm-0.17 so it should be easier to upgrade. You can find more projects with this https://github.com/search?l=elm&amp;o=desc&amp;p=2&amp;q=audio&amp;s=updated&amp;type=Repositories
[removed]
The current work being done on Elm revolves around asset management so 0.19, the next version of Elm, might have some official approach around this issue. That being said, the Hello World app is around 20k of (minimized&amp;gzipped). Is this big enough to warrant the extraction? 
It just seems weird to me and inefficient to keep downloading the core over and over. I do agree that it is not the biggest problem in the world, but I was wondering if it was possible to bundle it together with my other vendor code.
I don't know why you are being downvoted, there are smaller libraries distributed via CDNs so I think this is a valid concern. The thing is that I don't think you have the entirety of the core in each app. You only have what you need from the core libraries. To my understanding, most of the unused stuff gets thrown away by the minifiers. So, the benefits of this strategy might be somewhat doubtful. In any case, as I said, steps are being made for more optimized distributions of Elm. 
This might be a case of premature optimization.
I actually did ask this morning, but didn't get an answer. Thank you for the detailed response.
This seems like a very interesting framework. Thanks for the heads up!
Maybe try searching for requestAnimationFrame on http://elmlang.slackarchive.io/general ?
Check out comp http://npm.im/comp I'm a big fan of Elm but strict functional programming is too big a leap for our team right now. Comp aims to get your code into an Elm-like shape (while enjoying the benefits of the pattern in the meantime) for a simplified future refactor 
In my current redux/react application some server calls are made when a component is mounted by dispatching an appropriate action in componentDidMount. How would I go about a similar solution in Elm? 
Which parts of the ecosystem are lacking for you in particular?
Clojurescript, specifically with Re-frame, is very analagous to the elm architecture, but with much easier javascript library interop
I was completely unaware that andMap can be implemented subtlety wrong (or at least differently) through an apparently innocuous simplification. I encourage you to hunt for this bug among published packages and file issues where you find it. 
Impressive! How does it work?
Hey guys, Thanks for these threads! I always find the discussion useful. I'm playing around with replacing the bang (!) operator with the [rocket-upate](http://package.elm-lang.org/packages/NoRedInk/rocket-update/latest) operator (=&gt;) that I've seen in this thread. If I'm aggregating the init/update functions from other modules into the main init function, what is a clean way of consolidating all of the child init/updates? Since (=&gt;) is going to produce a list, I have to consolidate all of the various "component" Cmd Msg's together in the root App init. The following example is the root Msg and init function. Login is a child "component" --App.elm import module Login type Msg = ChangePage Page | LoginMsg Login.Msg init : ( Model, List (Cmd Msg) ) init = let ( loginModel, loginCmd ) = Login.init in { currentPage = Dashboard , login = loginModel } =&gt; aggregateInitCmds [] loginCmd aggregateInitCmds : List ( Cmd Msg ) -&gt; List ( Cmd Login.Msg ) -&gt; List ( Cmd Msg ) aggregateInitCmds app login = List.map (\msg -&gt; Platform.Cmd.map LoginMsg msg ) login ++ app I feel like it might get unruly as soon as I have more than a few modules I have to "zip" together.
use the html5 audio element with autoplay=true ;)
You put an action that would make the server call in the `init` of the app and route the info to the place where that info is needed. Official elm recommendations are against thinking in terms of components so moving from a react paradigm might take some well thought restructuring. Alternatively, you can use the old nesting architecture and put the server call in the `init` of the component OR, you can use some experimental approach like [elm-box](https://github.com/pdamoc/elm-box) and, again put the server request in either the init or one of the attribute handlers. 
This is a wonderful write-up, and it meshes well with my own experiences doing game dev in Elm. Mostly I have been the victim of my own high ambitions... even in its unfinished state, the game I set out to make is easily the biggest solo programming project I've done. Programming WebGL is hard. Programming SVG is tedious. Figuring out the architecture for a game for the first time (and in a young language) is a lot of trial and error. Despite not having that perfect final product, I have gotten a lot out of the experience. I love programming in Elm, and am going to keep doing it for the forseeable future. I have fallen in love with mathematics again (something I thought was impossible after dropping out of school). And I have a much better idea of what is possible for me, what is too ambitious, and what I need to learn to grow as a programmer. Thumbs up for moving to Unity. I am trying it out too, and learning a lot (although I'm not the biggest fan of C#). Don't think of your project as being "abandoned." It's only sleeping for a while. Even if you delete the code and swear off Elm forever, this was something you really wanted to make, and I am positive you are going to incorporate these ideas into your future projects :-)
Since the library is so old, I'm not sure porting it to 0.18 would be noticeably less effort than rewriting it.
Thanks for you reply! It took me a second to work out what was going on with your lift function and how composing the two maps gets me what I need. Once I understood that what I *have* is List.map : ( a -&gt; b ) -&gt; List a -&gt; List b Cmd.map : ( a -&gt; b ) -&gt; Cmd a -&gt; Cmd b LoginMsg : ( Cmd Login.Msg ) -&gt; ( Cmd Msg ) loginCmd : List ( Login.Msg ) and what I really *need* is a function with type annotation: f : ( a -&gt; b ) -&gt; List (Cmd a) -&gt; List (Cmd b) I understood how using the (&lt;&lt;) operator (&lt;&lt;) : ( a -&gt; b) -&gt; ( b -&gt; c ) -&gt; ( a -&gt; c ) and thinking of the map functions as producing curried functions, instead of concrete values, was working.
Hmm, so you're thinking that calling document.getElementById would be slower than traversing the document tree? I don't know what algorithm/data structures are involved in searching for an element by id (I imagine that the browser would have a data structure specifically for this since it is such a common task), but it seems like it should be speedy. I most certainly could be wrong, it just *seems* this way to me.
There is probably magic going on behind the scenes (with native JS code) with Cmd that requires it to type check. The concept is called "phantom types", perhaps [this](http://stackoverflow.com/questions/28247543/motivation-behind-phantom-types) will prove useful.
Yeah, the Elm source and its type definition is confusing here. I think you dug a bit too deep here :) The `Cmd` type is used with Native code, which is at the edge of Elm's type safety. `Cmd` and `Cmd.map` is not implemented in Elm itself, but in native (javascript). The internals of the `Cmd` are not defined in Elm. The information is not lost, it is just not defined in Elm. When your code interacts with `Cmd`s, you would still need to use the `Cmd msg` types, though.
I think this is one of the hurdles for beginners - who naturally are looking to learn how Elm types work, and all examples including the most trivial are peppered with Cmd with it's confusing definition. I'm not sure what can be done about it, apart from simply adding more to the docs. Also the '!' operator used with Cmd does beginners no favours at all. Would not be surprised if it is dumped in the next version. 
&gt; I'm not sure what can be done about it, Well, I like to think that answering those questions here or over on slack is actually a good way to help beginners overcome these hurdles. I agree that the `Cmd msg` can be confusing, for different reasons: 1. it is a generic type, just like `List a`, `Maybe a` and many other types 2. it is about side effects, and communicates with the elm runtime, same BTW as `Html msg`, which most will run into earlier. This takes a while to get used to. 