It looks like the lines in question involve constructors. You may want to read about them a little bit: https://medium.com/elm-shorts/an-intro-to-constructors-in-elm-57af7a72b11e 
The decode thing is indeed wierd! Think of a Decoder as more of a specification than a program. It doesn't actually do anything itself, its just a spec that's fed into another function someplace, a function that actually does the work of decoding the json and producing the Elm data type. Here's some random code of mine that creates a decoder for a Tag datatype. tagDecoder : JD.Decoder Tag tagDecoder = JD.map4 Tag (JD.at [ "id" ] (JD.map TagId Uuid.decoder)) (JD.at [ "name" ] JD.string) (JD.at [ "description" ] JD.string) (JD.at [ "tags" ] &lt;| JD.map (EverySet.fromList &lt;&lt; List.map TagId) &lt;| JD.list Uuid.decoder) Of itself the Decoder just sits there doing nothing. But you can pass it as an arg to Json.Decoder.decodeString or Json.Decoder.decodeValue, and those functions will attempt to extract the relevant values from the Json and spit out a Tag. Anyway **TLDR** what playersDecoder is, is a set of instructions for Json.Decoder.decodeValue, saying to expect a list of things matching playersDecoder in the json, and specifying the type of the output, List Player. Generally when I go the other direction, building Json from an Elm data type, I just write a regular function, like so: tagEncoder : Tag -&gt; JE.Value tagEncoder t = JE.object [ ( "id", Uuid.encode (getId t.id) ) , ( "name", JE.string t.name ) , ( "description", JE.string t.description ) , ( "tags", JE.list (List.map (getId &gt;&gt; Uuid.encode) (EverySet.toLis t t.tags)) ) ] Here its not a specification - its actually doing the work of taking the elm datatype and spitting json out. 
Hey, pr06lefs, just a quick heads-up: **wierd** is actually spelled **weird**. You can remember it by **e before i**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Well that is a strategy I hadn't considered, learn a whole 'nother language ;) Not opposed to the idea. I've recently started falling down the polyglot rabbit hole so might as well throw another language into the mix. I was working mostly with JS in node.js and front end. I eventually got really tired of node.js. It seemed like a never ending slog just to get something reasonable going without shooting myself in the foot, so I decided to give golang a try and it's well suited for web back ends, but it's vastly different than most languages and can feel limiting... but it's fast. My ideal situation would be strong consistency between front end stack and back end stack if possible. Is there a Haskell driven back end that pairs well with elm or is that so far outside the norm most people don't even try it? Basically I'm on the hunt for a full stack that is comfortable to work in that isn't all JS based because that isn't working for me.
Thanks, that does help with understanding Json.Decode a little better. I think I need to start smaller than what elm-tutorial.org is foisting on me so I can see what the individual parts do in isolation.
Will do. Thanks.
Hey there! I don't know how much this helps, but the team I'm in is using Haskell for the backend while I use Elm for the frontend - so it's definitely possible. As per learning a new language to get to Elm, it's not a bad idea: if many of the hiccups with learning Elm seem to come from its being functional, a good intro to functional languages might really help. If you want to start with something less complex than Haskell, I can suggest Ocaml - https://ocaml.org/learn/books.html for some learning materials. (I've personally used OCaml from the Very Beginning and More Ocaml in the classes I've taken).
The complexity of Haskell doesn't bother me. I'm familiar with basic functional concepts. I might fall flat on my face trying to learn it but oh well. What I *am* concerned about is trying to set up a Haskell dev environment. Apparently that is not so straight forward. Glad to hear that there is a possibility of pairing Haskell with Elm. I'll have to look into that.
I set up a Haskell dev environment a couple of years ago when I was learning it, and I don't recall having much trouble even back then. With `stack`, things became quite easy. Check out https://haskell-lang.org/get-started for info. By the way, I don't think Haskell is a prerequisite for Elm. 
I just got stack installed. At first I used the ghc arch package. But I learned afterwards that it's a giant mess so I searched around and read about stack as an alternative. Seems ok so far. With stack, is `stack ghci` the only way to use the ghc interactive session?
sadly to really understand `Decoders` you have to dig quite deep. I would concentrate on just the usage part for now (http://noredink.github.io/json-to-elm/ can probably help you quite a bit if you are stuck) Once you think you are ready you could look at what parser-combinators are all about (elm decoders follow those design IMO quite closely) - good intros are IMO F# for fun and profit: https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/ and this functional pearl paper: http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf
well there is `stack repl`;) (it's just a alias though) What other way are you thinking of? GHCi is a bit like `elm repl` - what stack does is separating stuff for different versions of GHC (the compiler) and dependend packages so that you will not run in to global conflicts between the libraries. That's why `stack` does not put `ghci` into a path or something - you might have different versions of it on your development computer. So yes I would recommend using `stack ghci` 
beware: you might find Elm lacking or Haskell overly complex after you looked at both
Yeah, I'm not too concerned about knowing the ins and outs of elm's json decoding, not yet anyway. Just trying to get my head around the type system mostly.
Hehe. That's ok. I've heard Haskell is good to learn just for expanding on programming skills so I don't mind either way.
as I think nobody did yet, let's explain the code there playersDecoder : Decode.Decoder (List Player) playersDecoder = Decode.list playerDecoder this says you are defining a `playersDecoder` that will be a `Decoder`. --- A `Decoder a` is a bit like a promise or task - if you run it against a `String` containing *JSON* it will either be able to parse the JSON and give you back a `a` or it will fail. You usually don't have to run it yourself - but in test etc. you can use [`decodeString`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#decodeString) do *run* the decoder. The Success/Failure is represented using a `Result` data-type again - but as you cannot write a primitive decoder yourself that does not matter in defining Decoders --- back to the code - the `Decode.list` here is something that is often named a *combinator*. It combines another Decoder or more - just `playerDecoder` here - into a new one. In this case it will return a decoder that tries to parse a *JSON array* into a *Elm list* and each list-item is parsed using the `playerDecoder` decoder, that is defined next: playerDecoder : Decode.Decoder Player playerDecoder = decode Player |&gt; required "id" Decode.string |&gt; required "name" Decode.string |&gt; required "level" Decode.int this one is IMO a bit strange for a tutorial, as it uses a non base library named [elm-decoder-pipeline](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest) to help you define the decoder. but the idea is simple: `decode Player` lifts the `Player` constructor (which is really just a curried function that will make a `Player` record for you, once you give it all the parts` into a decoder which will not parse anything but return the very same constructor (yeah sorry - you might want to just ignore this part) - the `require` fields then look into the given fields (for example `"id"`) in the JSON it should parse and try to get out a value at from this field's *value* using yet another decoder (`Decode.string` here to get a `String` back). When successful it glues together the `Player` constructor function with this value - returning a function that looks for the rest of the needed `Player` fields. So after giving `id`, `name` and `level` you get back a `Player` IMO you should just use that as is and come back later once you understand a bit more about FP and maybe about parser-combinators. --- ### remark a base-`playerDecoder` could look like that: playerDecoder : Decode.Decoder Player playerDecoder = map3 Player (field "id" Decode.string) (field "name" Decode.string) (field "level" Decode.int) using the [`map3`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#map3) and [`field`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#field) functions from the [`Json.Decode` module](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#field) 
Wow. I see. A lot more going on in that snippet of code than I thought. I'm going to have to spend more time on the fundamentals before I try to get through the tutorial I think. Thanks for such a detailed explanation. FP is so different than what I am used to...
I think you can mostly ignore the details and still get very productive with this tutorial and elm though Feel free to dig into the fundamentals (personally I love doing this) but be aware that this can get you into endless fundamentals-yak-shaving :D
Fair enough. Someone else mentioned going through "learn you a Haskell" to get a better understanding of Elm's type system. I'm giving that a go at the moment. I learned a bunch of FP concepts when I was learning how to use the ramda.js lib but it always felt weird, like I couldn't use the full power of FP because JS was in the way. Maybe learning Haskell will clear things up, or make it worse! How knows?!
Thanks. I'll see how LYAH goes and maybe check that one out after.
There's a nice elm parser package that follows a similar pattern, only decoding strings instead of just json. You make a Parser but that's just a set of directions for 'run'. http://package.elm-lang.org/packages/elm-tools/parser/2.0.1/Parser
What are the main differences of Elm's model-view-update compared to say Rails model-view-controller?
My little web app has progressed to the point where I want to implement the typical user login process of confirmation emails, hashing passwords or whatever, etc. I haven't done this before in any language, so maybe this is beyond the scope of just this elm forum. But anyway can anyone point me to some best practices docs re this, and/or a nice example with elm on the front end? My server is in rust, if that matters. 
sadfsd
Thanks!
good plan - people coming from a FP background will understand the caveats etc. perfectly fine and people coming from JS will expect it to be array anyways.
you would write the same code with type-classes - what you have in Haskell that can remove some of this boilerplate is the `derive` mechanism and Template Haskell I would have no problem with reviewing/accepting that code although I would add an encoder and write "fuzz" tests to demonstrate that the decoder/encoder part has the decode &lt;&lt; encode = Just property
Yeah, sorry about that. I don't have good front end skills, so I didn't know how to implement mobile support.
&gt; decode &lt;&lt; encode = Just Don't want to be fussy, though shouldn't be `decode &lt;&lt; encode = Ok` ?
not that I am aware of but there are a few GraphQL libs for elm (for example http://package.elm-lang.org/packages/jamesmacaulay/elm-graphql/latest) and there are alternatives to using union-types for the things you want to accomplish here personally I would do just what you did here - it's a bit of copy&amp;paste / editor-macro magic but overall not too bad IMO
Yeah, but I am too lazy for writing all this ðŸ˜¶
Using `create-elm-app` my index.js looks like this: import './main.css'; import { Main } from './Main.elm'; import registerServiceWorker from './registerServiceWorker'; var app = Main.embed(document.getElementById('root')); app.ports.test.subscribe(function (str){ console.log(`Your string is ${str}`); }); registerServiceWorker(); I've declared a port \(test\) to invoke a javascript function \(dummy in this case\). It seems to me that I can declare ports *only* in Main module; is it so ? If not, how can I declare a port on a different module ?
I wrote a little python program that generates an elm module like this from a list of names. Let me dig it up and I'll share it.
Actually I am already using \`graphqelm\` for the graphql related codegen. What I was more interested in was having list of all enum values, etc.
&gt; is it expected that typeclasses will ever make it to Elm? Personally I expect they never will. I think one of Elm's main contributions to front-end development is that it makes *hard things easier.* A big part of that is its focus on simplicity, which means not adding language features without seriously considering their downsidesâ€”of which typeclasses have many. Because of this focus, if I have a gigantic code base, I want it to be in Elm more than I want it to be in any other language! I don't think this topic is ever about rational cost/benefit though. If I used a stopwatch to measure how much time I've spent creating and maintaining code like this, it would be a rounding error over the course of my time writing Elmâ€”and also across in my career in general. Yet we can't seem to help talking about it. A *lot.* The volume of English in this thread vastly outpaces the amount of "way too much" Elm code under discussion, which is typical for this topic. I think trivial code gets spotlighted not because it has a meaningful cost to write and maintain, but because as programmers it bothers us to spend *any* time doing something trivial. It feels beneath us. Maybe it's just my own ambition, but I feel it would be a shame if Elm increased language complexity in the name of making trivial code easier. Trivial code is easy enough already. The world of programming has many serious challenges left to solve, and I want to see Elm focus on the hard things instead.
I would like to know why is that things like this are considered a binary choice? I really appreciate the simplicity Elm has chosen, but at the same time I wish there was some sort of features hidden for the power users, so that those who wish to fully leverage the power of Elm are not handicapped in an artificial way. You know how you have NG+ or you have endgame content for the pro players in RPGs etc, but at the same time you have content for the casual players. The only dowside I can see is that this basically means the language maintainers have to maintain a language within a language and would increase the complexity from the point of view of language maintainers (not users).
Do not consider this, unless you like to work overtime and be underpaid. Rakuten is a black company through and through.
Back when I wrote Rails, I would occasionally hear criticism of ActiveRecord (the ORM) not allowing you to do crazy sophisticated things with databases. I replied that the purpose of ActiveRecord is not to make the hard things easy, but to make the easy things trivial. *Elm is not ActiveRecord.* The point is not to make easy things trivial. The point is to make hard things easy, and impossible things possible. That said, `toString` should work on union type tags, and you can use string capitalization functions from there.
You can have multiple modules with ports. You need to mark your module as a port module, eg `port module MyModule exposing (..)`. However, it's usually a good idea to have a single dedicated port module because then it's easy to see all of the possible ways your program can interact with JavaScript in one place.
Another option for elm is a preprocessor, or "Template Elm" if you like. That would be handy to cover off boilerplate cases like this. However unlike Template Haskell, I'd like it to generate elm-format formatted Elm that you can read with a nice comment at the top saying "Warning this was generated, if you modify you may lose changes". Such code could go in .telm files and automatically get processed.
Thank you. But how can I register a different port module on JavaScript file (other than Main module)?
For these scenarios I usually abstract the functionality like this: type JobStatus = Submitted | Started | Finished | Pausing | Paused | Cancelled | Failed typeMap : List ( String, JobStatus ) typeMap = [ ( "SUBMITTED", Submitted ) , ( "STARTED", Started ) , ( "FINISHED", Finished ) , ( "PAUSING", Pausing ) , ( "PAUSED", Paused ) , ( "CANCELLED", Cancelled ) , ( "FAILED", Failed ) ] allStatus : List JobStatus allStatus = List.map Tuple.second typeMap decoder : Decoder JobStatus decoder = mapDecoder typeMap {-| Convert from the union type representating the Enum to a string that the GraphQL server will recognize. -} toString : JobStatus -&gt; String toString = typeMapToString typeMap -- Helpers mapDecoder : List ( String, a ) -&gt; Decoder a mapDecoder allPairs = let findIn pairs str = case pairs of ( k, v ) :: rest -&gt; if k == str then Decode.succeed v else findIn rest str [] -&gt; Decode.fail (str ++ " is an invalid key") in Decode.string |&gt; Decode.andThen (findIn allPairs) typeMapToString : List ( String, a ) -&gt; a -&gt; String typeMapToString allPairs key = List.filterMap (\( k, v ) -&gt; if v == key then Just k else Nothing ) allPairs |&gt; List.head |&gt; Maybe.withDefault "Serialization Failed"
This is an interesting approach on this. Most of the enum code was generated by [graphqelm](http://package.elm-lang.org/packages/dillonkearns/graphqelm/latest). But I really like this approach you have presented, I am going to see if the author of `graphqelm` is open to this change.
As far as I know, `toString` is being phased out. In `0.19` it will only be available during debugging so that's not really a forward compatible solution. 
This is just a hunch as I'm an Elm noob myself, but after reading [this StackOverflow post](https://stackoverflow.com/questions/49711551/elm-package-json-constraints-of-repo-name-package-name-are-probably-letting-to) and looking at your module's elm-package.json, I noticed the dependency "danyx23/elm-mimetype": "3.0.1 &lt;= v &lt; 4.0.0". In v3.0.2 of that package its own dependency on elm-lang/core was [changed](https://github.com/danyx23/elm-mimetype/compare/3.0.1...3.0.2) so it now requires at least v5.1.1, but your own package still only requires 5.0.0 at least. That means your own elm-package.json says it should compile with elm-lang/core v5.0.0 and danyx23/elm-mimetype v4.0.0, but that's not possible. Now to get the whole picture we'd have to look at the elm-package.json of the project that uses the package, the one that fails to compile. Maybe there's a constraint in there that is compatible with the constraints that file-reader declares, but not with the one it actually requires due to the stricter demands of elm-mimetype?
Really happy to see someone making the distinction between `deriving` and type classes! Type classes were added into Haskell quite early, and as a consequence, lots of _conceptually_ separate features ended up having some integration with them. Taking a broader perspective, `deriving` looks a lot like code-generation, `do`-notation looks a lot like macros, and type class resolution looks a lot like implicit parameters. Lots of experimentation has happened since Haskell 98, and folks have done a bunch of work making conceptually separate features actually separate, and it is kind of a shame that this particular concern about enums is almost always framed as if Haskell 98 was the end of programming language history.
This is really retarded. What is the reasoning behind this?
Thinking about it, and it looks like something like \`TemplateElm\` might be the best way forward considering that many of issues like this are on the backburner for evancz and team. Thinking about it, it seems like \`TemplateElm\` might be possible even without the involvement of the core Elm language developers, although it would be great if they were involved or atleast gave their support to this idea.
Thanks for this? Are you aware of [elm-cog](https://github.com/boxed/elm-cog)?
Yes. I like Elm's syntax better though ;) I don't find it that useful to have a generic boilerplate generation tool, it gets to be as complicated as just typing it out. I quite like @jediknight 's solution too, seeing that now.
I just started learning Elm last week, I'm very new to this, and was building a generic chat app. :) I used the style-elements library. It's amazing!
This suggestion is probably better suited for the elm-lang slack.
I like having a separate port module, makes it easy to see all the interactions with JS in one place. 
May I ask if you could provide an example of this? It'll help me understand how others do this and perhaps avoid making certain mistakes.
If you define your ports in another module, say `Ports.elm`, then you just need to import it in `Main`: `import Ports exposing (..)`. The ports will then be available on the app object (eg `app.ports.myPort`). See `create-elm-app` docs for info about getting access to the `app` object: https://github.com/halfzebra/create-elm-app/blob/master/template/README.md#javascript-interop
&gt; I see no difference between this and telling the human brain to loop through the cases and copy-paste-edit, or using some fancy Vim macro to do the same. Agreed! Importantly, that approach saves time without increasing the complexity of the *system*, in the way changes to the build process or language design can. An analogy here would be [`html-to-elm`](https://atom.io/packages/html-to-elm) over JSX. If a tool can generate the same code you'd otherwise choose to write by hand, then that's a clear-cut time savings that doesn't have to negatively impact the system!
On the topic of elm-mdl. [Material Design Lite](https://getmdl.io/ is being replaced by Google with [Material Design Component for the Web](https://material.io/develop/web/). There is an elm port: [elm-mdc](https://github.com/aforemny/elm-mdc). I'm close to launching an app that uses elm-mdc and I found it excellent.
Thank you, it works !
Also see [https://www.npmjs.com/package/elm\-help](https://www.npmjs.com/package/elm-help)
[https://ealhad.github.io/elm\-screen\-router](https://ealhad.github.io/elm-screen-router) I took the liberty to compile the project and publish the result on GitHub Pages.
Thx a lot for showing me it. I'm switch to it asap.
Thank you for publishing the demo. I should do it myself next time.
I'm new to elm, and the other day I tried using `elm-mdl` in a project, and it seemed too complex for me. It would be nice if you could just import some view functions to get the Material Design look and feel, but that seems to be impossible with the Elm architecture. All the 3 main components of your app, model, view and update have to be coupled with the `Material` module in order for it to work. I found it much easier to just use the mdl stylesheet directly, taking only the little bits that I need. It's a bit more work, but it's better to use my own abstractions over mdl than deal with all the boilerplate and coupling that comes with `elm-mdl`.
If Array is always faster than List, they could be merged. Just provide listviews that allow deconstructing an array.
If you'd read the entire series, you'd see that `Array`s aren't always faster (yet).
Working on a set of material design components for elm. Hoping to have the datepicker done today, and published on elm-package tomorrow. 
I have read some of it. IIRC prepending is slower. Lists will always be faster in algorithms suitable for lists, assuming Haskell's list optimizations work well in JS. Even if the Elm compiler just used JS Arrays for small lists the benchmarks would probably look very different. I don't think that the performance argument is very compelling, but not having to choose is.
It's not a big deal. Do you know how to use GitHub Pages ? You just have to create a branch called `gh-pages` with an `index.html` file, and boom, your page is online.
Auth0
A TODO app for mobile phones (as a "progressive web app"). Basically a ripoff of Temaki, but planning to add some extra features I am missing. I'm utterly amazed at the development speed I'm getting thanks to create-elm-app and elm-mdl, including that I'm a newbie to Elm. The app in current state was built over just a week-long of "evenings"! - you can check the oldest commit's date... The code is at https://github.com/akavel/dodo, a dev build at https://akavel.github.io/dodo. Note it's pre-alpha, no readme, use at your own risk ;) though I already started dogfooding with it :)
Looks Amazing!
probably very incomplete: - F# - Scala - Purescript - Clojure - Erlang / Elixir - Eta for even more blown mind - Idris - Agda - Coq personally I would continue with Purescript if you are into Web and want to see a more powerful type system, Scala or F# for more general stuff, Clojure or Erlang if you want to see FP without types, Idris or Agda if you are interested in really powerful type systems and don't care that your code will probably never run ;) ... or just Haskell of course (don't be scared)
Thanks! I think Idris, Adga and Coq look a bit much for me. I'm interested in something with a bit more scope for practical applications/hobby projects, and it looks like these (although really cool) might be a bit tough to get going? I've fiddled with Clojure as well, which is also really cool; although I missed the type system. Clojure Spec looked good but didn't seem quite as expressive as the type system in Elm. It also lacks the niceties of a compiler. Scala and F# both look cool. How would they compare to learning OCaml or Haskell? Do you know much about the tooling and communities around the languages? Both of these things contributed a lot to making Elm such a blast to learn. Thanks again for the tips
F# is really close to OCalm (minus the module system but plus some things like type providers) - in the beginning days of F# the default syntax was in such a way that you could convert most OCaml code without much effort. Scalas Syntax is IMO very different to the languages in the ML family (Elm, F#, Haskell, Purescript, Eta, Idris, Agda on that list of mine) I use F# in my daily work (besides C#) - the tooling is great (for a functional language - it's not nearly as good as the C# support though). You have basically 3 products to choose: Visual Studio, arguably the best IDE around - but again: you only get the basics with F#, VS Code with Ionide: Together they are on the same level as VS full, Rider: Jetbrains editor/IDE for .net - this one will probably be the best in the end - right now it's approximately on the same level. The F# community is overall great but opinions are a bit more divers than those for Elm IMHO. They go out of their way and try to provide error-messages on the same level as Elm (not yet there but close). Overall I think between F# and Scala F# is closest to what you know from Elm (you could even have your first look at Fable with Elmish - the F# to JS transpiler, and probably see very few differences aside from minor syntax changes and the fact that F# is not pure) Scala: sadly I know much less here - the community is bigger than both F# and Elm combined (AFAIK) but they seem to be split in OO first and FP first and in the FP camp there are probably those wanting to move thing more in the theoretical/Haskell direction and those who just want a better/more functional Java. Tooling seem to be great with things like intellij, ensime, etc. The language itself is a bit different in syntax and has much weaker type inference (it's a bit more on the OO side) but interestingly you get a much more powerful type system than both Elm and F# has. It's of course also on JVM not on .net so you might see this as a plus or not (personally I don't care and I think the times where you could consider a .net dev "not a real developer" and Microsoft "the enemy" are long gone)
Have you considered only loading enough tickers to fill the page at first, then, once you get those, immediately firing off another request for the rest?
If the rendering part is what's slow, you could using http://package.elm-lang.org/packages/FabienHenon/elm-infinite-list-view/latest It can massively reduce rendering time by only putting visible elements on in the dom, and removing them after you scroll past them.
It's not really the requests that slows this down. It's the DOM interaction when the browser needs to repaint.
How is developing F# in Unix-like OS (in my case macOS) ? And deploying it to production? I like the language but sometimes I don't like how it uses mutability or "new" keyword, some OO aspects and async. Maybe I don't have tried it enough :) And what web framework would you use in F#?
Greetings, The type system in Elm is driving me mad! What am I supposed to make of types represented by two or more types? I'm talking types like `Html msg`, `List Int` and of course my favorite `Program Never model msg`. From what I've read, I should interpret `Type1 Type2 Type3` as "`Type1` which relates to `Type2` and `Type3`", but that sounds vague. Is it a partially applied function? If so, why not `Type1 -&gt; Type2 -&gt; Type3`? If not, then what is it? Can I write my own "compound types"? What should I call these types if not "compound types"? I'm sorry my question is pretty aimless, because I don't even know where to start. Long story short, **I don't understand these types**.
You could use 'composition' instead of 'inheritance' (to use OOP terminology). type Shape = Square CommonShapeData SquareData | Circle CommonShapeData CircleData type alias CommonShapeData a = { a | position : Point , color : Color , bordeColor : Color } createShape : (CommonShapeData -&gt; specificData -&gt; Shape) -&gt; CommonShapeData -&gt; specificData -&gt; Shape createShape constructor commonData specificData = constructor commonData specificData 
I'm not sure of the best way to use `elm-make` to compile my application. I currently have only one page using Elm with its own Elm program, but I intend to have several pages, each with their own Elm program in its own separate JS file. Right now, my source directory contains files like `elm/Dashboard.elm` and `elm/Recipe.elm` that I want to compile to `static/js/Dashboard.js` and `static/js/Recipe.js`. Is there a straightforward way of doing this in a single command with `elm-make` and `elm-package.json` or would I need to add something to my makefile like `find | xargs`?
Thanks, after some thinking I also end up splitting common and specific data. However, if you then flip the position of common and specific data, it is possible to use partial function evaluation and point free to write pretty DRY code. type Shape = Square SquareData CommonShapeData | Circle CircleData CommonShapeData createShape : (CommonShapeData -&gt; Shape) -&gt; Point -&gt; Color -&gt; Color -&gt; Shape createShape create position color borderColor = create { position = position, color = color, borderColor = borderColor } createSquare : Float -&gt; Float -&gt; Point -&gt; Color -&gt; Color -&gt; Shape createSquare a b = createShape (Square { a = a , b = b }) createCircle : Float -&gt; Point -&gt; Color -&gt; Color -&gt; Shape createCircle r = createShape (Circle { r = r })
I'm not am expert on efficiency but what I do is compile into a single elm.js file. Then I reference it in both pages...calling the appropriate program from each respectively. Unless there's a big difference in the dependencies or a lot of custom code the majority of the size will be for the Elm runtime and you won't get much benefit from having two separate compiled .js files. 
This is a much better approach than what I had in mind. Thanks, I hadn't realized it was even a possibility to store all the separate programs in a single file.
&gt;One of the many costs of introducing typeclasses is a scalaz bifurcation of community libraries, which from what I've heard, has been extremely destructive to Scala's community and ecosystem. IMO it wasn't about type classes per se. The problem is that scala has 2 groups of developers: 1. The imperative programmers coming from java/c#/... 2. Functional programmers coming from haskell/erlang/... I know that some companies that used scala had blocked scalaz because it's "too complex" for imperative programmers. So projects that used scalaz had to be rewritten without it and vice versa because they used completely different programming styles. I don't think this would happen to elm just by introducing new features, its still all functional ;)
You can define it yourself : recordMap f fields record = List.map (\field -&gt; f &lt;| field record) fields Then you only need to have a List of fields accessor functions for that particular record, for example data = {a = 10, b = 20} dataFields = [.a, .b] recordMap ((*) 2) dataFields data 
As far as I know this isn't possible - there's no way for Elm to know what `map` means in the context of your particular record. If you want to keep the same data format then you'd need to define `map` for it, something like: ``` map : (a -&gt; b) -&gt; SampleData a -&gt; SampleData b map fn sampleData = { introGraph = fn sampleData.introGraph , friendlyTriangle = fn sampleData.friendlyTriangle [etc.] } ``` 
What /u/BobWhitelock said. Even the core types (eg. `Maybe`) have to define their own `map` functions: https://github.com/elm-lang/core/blob/5.1.1/src/Maybe.elm#L56-L65
The reverse uppercase example helped me understand function composition better. Have an upvote!
A registration form for a festival we organise this summer with some friends. It features buying a few different bundles, and booking a slot in workshops for which the amount of places is limited. Since I do not have much time to handle support, I needed a technology that would help me prevent bugs as much as possible. Elm seems like a good choice :) However, I must admit I'm a bit disappointed in how fastidious development in Elm can be when compared to other front-end stacks : routing is hard to grasp and not exempt of problems, fetching and handling data with the RemoteData pattern quickly becomes a mess, and I've found that the Elm Architectureâ„¢ is more often in my way than by my side. On the plus side, almost every modification I do works the first time I run it, so I think the time I spend debugging has really dropped down ! Itis really reassuring, especially in my case.
Iâ€™ve become too annoyed by webpack so Iâ€™m working on replacing it with a simple python script. So far Iâ€™ve replicated all the features I need except watching and live reloading. Itâ€™s a breath of fresh air. I donâ€™t have these overly complicated webpack config files lying around, and I donâ€™t have to spend 10 mins googling every time I want to do something with images. 
``` type Shape = Square SquareData | Circle CircleData type alias Object = {position: Point, color: Color: borderColor: Color, shape: Shape} ```
Elm has the same two groups of developers. 1. JS devs coming to a purely functional language for the first time. 2. Haskell devs looking for something something similar in the browser. If you look back at older Elm packages (especially from the Signals days) you can see a lot of this bifurcation and how removing certain features has actually avoided it.
What is about using elm-live for watching and live reloading?
Yes, you have different groups of developers, not that much different code. In Elm you know that everything is pure and functional. ADTs are used a lot and every function you call has no side-effects. Now compare that with scala: On one side you have the OOP/Imperative programmers that may write spaghetti code (functions with &gt; 100 lines), use Exceptions for control flow and make heavy use of classes/interfaces/inheritance (code + data coupled together inside classes). On the other side you have the functional programmers that make heavy use of purity, POJOs, monads, ADTs, lazyness, etc. First group of developers won't be able to use the code of the second group because of the use of highly sophisticated functional stuff like monads which they do not understand. So they have to write the needed code themselfs in an imperative/OOP way and you end up with two different implementations. You could even argue for typeclasses to remove some bifurcation. Right now if you want a record to be the Dict-Key, you have to use *elm-all-dict*, that means some code will use the default *Dict*, other libraries will use *AllDict*. Just make it as simple as possible, but not *too* simple.
Try to not think of "routing" as existing outside the flow of every other action you handle. Different term, same thing There's `ButtonClick` -&gt; `Message` -&gt; `Update` -&gt; `View` And `Navigation` -&gt; `Message` -&gt; `Update` -&gt; `View` In React/Redux world, routing is a special snowflake. Where route changes aren't actions and route state will be hoarded away in React Router local component state, not redux state. "Routing" is it's own thing. In Elm it's really not. Just de-serializing a url into parameters for a Message. You don't even need url-parser if you don't have route params.
I thought Elm was supported by NoRedInk. Should that have made it into the comparison table at the end? 
Yeap. You are right. I will fix.
I am pretty sure PureScript was made as a "Haskell in the browser" and not an inspiration borne from React. PureScript's [initial commit was also made in 2013](https://github.com/purescript/purescript/commit/291a6d4ddd88c65a8a0c5368441c1b7c639ca854#diff-04c6e90faac2675aa89e2176d2eec7d8), the same year that React was open-sourced. Perhaps /u/paf31 can comment himself, as he is active on reddit.
Nicely done. A lot to learn from here for a newbie like me.
Saying that Elm is pure and OCaml(ReasonML syntax) is impure might be misleading for some. Purely functional code written in OCaml/ReasonML is just as pure as code written in Elm. OCaml, however, also supports pointers, which you aren't required to use. In Elm, your purely functional app codebase sits on top of the impure Elm kernel. If you were to copy this structure into OCaml/ReasonML, you would also have a purely functional app codebase sitting on top of the impure kernel, yet the kernel could be written directly in OCaml/ReasonML because of its pointer support.
&gt; OCaml, however, also supports pointers, which you aren't required to use. That's not what purity means. Functional purity is about side-effects, mainly (though not only) I/O. Elm has an effect-ish system where you return actions to perform and modifications to make, Elm code has no side-effects these are done by the environment. OCaml on the other hand has both pervasive io (you can do io more or less anywhere) and mutable structures (via refs which I'm guessing is what you mean by pointers). And thus OCaml is not pure, side-effects can happen anywhere without the caller being aware that they're possible. 
I've started studying Elm and I've now started to collect together stuff to understand the whole. I was wondering, if anyone knows if there is some kind of "side by side comparison" like this (I found this very helpful when studying Rust): https://gist.github.com/carols10cents/47f87b480e35f65897bf The point is that I'm coming from strong VBA background and now I know some C#, Rust, Javascript (+React) as well. I played a little bit with xmonad (window manager written in Haskell), but I really can't say functional languages have "clicked" for me yet. I understand the philosophy because I have somewhat strong math background, but the syntax is still hard to grasp. For example I find it very confusing that this modified button example still works: https://pastebin.com/PaZLHCjE I use different variable names everywhere, but it still somehow knows "what is what". I would love to understand what is happening behind the curtains that makes this words and to understand when the variable name does matter and when it doesn't. Right now it seems to me that all the naming of the variables is useless.
Finally a positive reddit on Elm... did hell freeze over and I didn't notice? Very glad that it worked out for you!
Yeap. You are right, though one can arguee that these projects would not have gotten so much visibility if react had't been there "bringing funtional programing to the masses" this the message that I intended to convey.
It looks like you believe you are mutating the todo and your model will just receive that change because it already has that item. But there is no mutation in elm When you do `{ todo | completed = ... }` you are returning a completely new todo, on that your model hss no knowledge of. But your update function is expecting your whole model. So that will give you a type error So... 1. Give each todo a unique ID 2. In your update function, you will want something like.. ``` { model | todos = List.map model.todos (\todo -&gt; ... ``` Then in that map, once you see the ID of the Todo you wish to "edit" comes up, you do your "edit" You might see what I'm getting at now. You have to return the entire model with the edited list in it. Because anytime you "change" something, you're really just creating a new entity using the previous as a blueprint. I see in your example you've actually made things a bit more tricky by having a list of todo lists, so you'll need to repeat this pattern to first get the correct list, then get the correct Todo.
Lets start here listTodos : Todo -&gt; Html Msg listTodos todo = div [] [ label [] [ input [ type_ "checkbox", onClick (ToggleChecked todo) ] [] , text todo.content ] ] &amp;nbsp; Here you are trying to use ToggleChecked like a function and sending in the todo as the argument, however. &amp;nbsp; type Msg = ToggleChecked | ChangeTodoPriority &amp;nbsp; Your ToggleChecked Msg is defined with zero parameters, and therefore cannot be invoked with a todo as an argument. When you create a type like your message there each of the unions of that type are also their own type constructor. So for example. &amp;nbsp; type Msg = ToggleChecked todoId | ChangeTodoPriority &amp;nbsp; Now you can use ToggleChecked as a function with an argument for a todoId which here we can assume is an int and it will return that branch of your union type. Similarly you could define ToggleChecked with the parameter of your todo type. I am pretty with Elm myself but this is my understanding thus far :) &amp;nbsp; update : Msg -&gt; Model -&gt; Model update msg model = case msg of ToggleChecked todo -&gt; -- do the update &amp;nbsp; Then when you pattern match on your update type you can retrieve the value carried by the message like the above. From here you will have to find the right todo to update in your model, and return the updated model. &amp;nbsp; Further reading here -&gt; [Elm Union Types](https://guide.elm-lang.org/types/union_types.html)
In `update` you receive a `msg` and you need to update the `model` accordingly. In the case of `ToggleChecked`, you need extra information in order to identify which of the todos' checkboxes was triggered. By looking at your model, it seams that you need 2 indexes to identify a todo. Here is your code modified in order to show this (both the `update`'s case for `ToggleChecked` and the `view` functions: update : Msg -&gt; Model -&gt; Model update msg model = case msg of ToggleChecked listIdx idx -&gt; let updateToDo tidx todo = if tidx == idx then { todo | done = not todo.done } else todo updateList lidx list = if lidx == listIdx then List.indexedMap updateToDo list else list in { todoLists = List.indexedMap updateList model.todoLists } view : Model -&gt; Html Msg view model = div [ flexStyle ] [ div [] [ text "TodoList App" ] , div [] (List.indexedMap listTodoList model.todoLists) ] listTodoList : Int -&gt; TodoList -&gt; Html Msg listTodoList listIdx todoList = div [ marginSpacing ] [ div [ listHeader ] [ text todoList.name ] , div [] (List.indexedMap (listTodos listIdx) todoList.todos) ] listTodos : Int -&gt; Int -&gt; Todo -&gt; Html Msg listTodos listIdx idx todo = div [] [ label [] [ input [ type_ "checkbox", onClick (ToggleChecked listIdx idx) ] [] , text todo.content ] ] 
I would make that argument as well! Glad we're on the same page
Very nice. Thanks for sharing this.
[https://ufile.io/j4tdg](https://ufile.io/j4tdg) Get an error when trying to run Playground.elm saying MyList.elm doesn't exist even though I changed my directory in elm\-package.json to include its source directory "elm\-examples". Any idea where I messed up? 
elm-navigation and [evancz/url-parser](http://package.elm-lang.org/packages/evancz/url-parser/latest/). Not that itâ€™s hard to setup, itâ€™s just tiresome to maintain. In order to add one new page, you must modify : - url-parsing function; - url-rendering function; - Page type; - Route type; - main view function; - main update function. Whereas in Angular, you just have to modify your routing configuration (= one place in one file).
elm-lang.org has a [syntax comparison](http://elm-lang.org/docs/from-javascript) page that compares Elm's syntax to Javascript. The bit about functions might not be too helpful based on your variable rename example so I'll do what I can here. update lol rotflmao = case lol of Increment -&gt; rotflmao + 1 Decrement -&gt; rotflmao - 1 Let's rename these to make more sense.. update msg model = case msg of Increment -&gt; model + 1 Decrement -&gt; model - 1 Alright, what is this saying? The above code is defining a function named "update" and this function expects two arguments, "msg" and "model". We can make this explicit by annotating the function. update : Msg -&gt; Model -&gt; Model update msg model = case msg of Increment -&gt; model + 1 Decrement -&gt; model - 1 The code works the same but now we're adding a bit of extra information to help us and the compiler out. The annotation again says this is an update function with two args. The first is of type `Msg`, the second is of type `Model`. The very last `-&gt; Model` part is the return value. So this is a function that takes a msg and model and returns a new model. The body of the function is pattern matching on the `msg`. This is analogous to a switch statement and if the `msg` is `Increment` return the current model value plus 1, otherwise the current model minus 1. Here's the equivalent Typescript. function update(msg: Msg, model: Model): Model { switch (msg) { case "Increment": return model + 1; case "Decrement: return model - 1; } } If it makes sense syntactically then you'll probably want to look into [The Elm Architecture](https://guide.elm-lang.org/architecture/) to understand what this view, model, update thing is all about.
Wow, thanks for this! I had a lightbulb go off while reading especially with my personal history with React/Redux. This is a great way to explain routing.
There's also `&gt;&gt;&gt;` for Elm's `&gt;&gt;`, but it's a bit ugly. I think I usually do something like `(.&gt;) = flip (.)`, but I'm sure someone else would have a better version of this.
Is Elm still under active development? The last release was in Nov, 2016.
Yes, there's plenty of activity. Look at the Github repos: https://github.com/elm-lang The current release works very nicely, no reason not to use it except for the spotty documentation.
Try out the parcel webpack plugin. Works like a charm
I hate react-router-dom for this reason. It's a weird paradigm. react-router-redux and redux-first-router are much better routers that are driven by the redux store.
Thanks!
Thanks!
Hmm, I'm still not getting from where does the compiler know which model and msg we are referring to? I mean, is there always only one model? And if so, why do we need to name it or why it's not given a fixed name? It feels weird that we have to give it a name like "model" (or msg for message) if that information is not used anywhere. If the structure is always the same, I feel that it doesn't help the developer either, it's just extra work to name the model and the message.
Here is a fully type annotated example which may clear some of it up. [https://ellie-app.com/kwnhwVRkxXa1](https://ellie-app.com/kwnhwVRkxXa1) main : Program Never Model Msg main = beginnerProgram { model = initialModel, view = view, update = update } This is the main function. It's annotated with `Program Never Model Msg`. It's ok to not understand why this looks kind of funny at first glance. The main takeaway here is this is telling the compiler that we want an Elm program using a particular type for its model and msg (actions). However, the compiler already infers the type of your model and msg without that annotation because of how [begginnerProgram](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#beginnerProgram) is defined: beginnerProgram : { model : *model*, view : *model* -&gt; Html *msg*, update : *msg* -&gt; *model* -&gt; *model* } -&gt; Program Never model msg The compiler looks at the record that you pass to the `beginnerProgram` function and makes sure that the model type you use for the `model`, `view`, and `update` fields are of the same type. Same thing for the type for msg. As you already found out in your original example, you can name your models and messages whatever you want. Did you get a chance to read the Elm architecture link I provided earlier? I could provide more helpful feedback if your questions were phrased in a way that related to your understanding of the architecture.
This is what I was "afraid of" :) Yes, I had read that already. It's just the fact that we are not referring to the names of the functions when "calling them" that is so confusing. It wasn't if the names were not there to obfuscate noobs like me. Thanks for explanations, I guess if I keep playing with the code one more week, it will start to assimilate. I just have to see through the naming and see the difference between calling and referring/using a function (without calling it per se).
Care to elaborate on RemoteData becoming messy?
I am trying to start by buikding a small application that basically does CRUD. I have a very simple setup for now, using only elm-reactor (which is super awesome to work with). I have started to split the project into 2 files and ran into a difficulty : elm-reactor does not seem to compile my second file. The first file (main.elm) simply has : import Filter and the filter.elm file has : module Filter exposing (&lt;stuff&gt;) Am I doing something wrong? Or is this not a use-case for elm-reactor? I'd love to be able to continue using it, the time travelling debugger is amazing.
Pretty cool to have decompositions and all :\) There are other matrix libraries, which are not focused on linear algebra like yours but simpler things. Don't hesitate to look at their implementation: * chendrix/elm\-matrix \(elm array of array\) * eeue56/elm\-flat\-matrix \(elm flat array\) * Zinggi/elm\-webgl\-math \(elm tuples\) * elm\-community/linear\-algebra \(js typed\-array\) I myself had started an experiment at some point [elm\-tensor](https://github.com/mpizenberg/elm-tensor). It is on halt for the moment because I don't have much time and it relied on my [elm\-js\-typed\-array](https://github.com/mpizenberg/elm-js-typed-array) experiment. Still you might have interests in the tensor type definition, inspired by numpy ndarray.
Great to see this. At first glance I would say that instead of having `type Matrix = Mat Matnxn | Err String`, it would probably be a good idea to hide the constructor in a module, and expose only the functions that create valid matrices. Otherwise your type is the same as `eeue56/elm-flat-matrix`, except that it uses `Skinney/elm-array-exploration` instead of the core `Array` type. Keep up the work, it would be interesting to do an `elm-benchmark` comparison with some of the other libraries mentioned by /uMattpiz
Of course! Having to check if my data has been properly fetched at *every step* kind of break my coding flow, but thatâ€™s only a very personal grievance. On a more measurable side, I ofter find myself using the following anti-pattern: type alias Model = { catalog: WebData Catalog , â€¦ } encode : Model -&gt; Json.Encode.Value encode model = case model.catalog of Success catalog -&gt; actuallyEncodeModel model catalog _ -&gt; Debug.crash "Youâ€™re not supposed to be here since we donâ€™t encode a model youâ€™ve not fetched" actuallyEncodeModel : Model -&gt; Catalog -&gt; Json.Encode.Value actuallyEncodeModel model catalog = {- encode model using catalog instead of model.catalog -} This pattern feels clumsy, is not production-ready (`Debug.crash` in production probably causes global warming), and doesnâ€™t scale much. Maybe somebody could hint me toward a better design? 
School student importer for my workplace! Quite new to ELM to this is a pretty fun first big \(ish\) app. The aim is to import a CSV into a table to be checked for correctness and also edited if required before validation and finally sent into our database. So far I have built the CSV importer part and rendered the parsed data into a table. The CSV importer is based on a nice project I found here if anyone is interested \- [https://blog.reifyworks.com/javascript\-interop\-with\-elm\-using\-ports\-to\-read\-and\-parse\-csv\-files\-fef60c318b7a](https://blog.reifyworks.com/javascript-interop-with-elm-using-ports-to-read-and-parse-csv-files-fef60c318b7a) My next step is to work out how to edit then save each line with frontend and backend validation :\)
Yeah, Result would be the way to go for that, with `Result.andThen` you can chain a number of computations where each can fail. You might even want to have a sum type for the error instead of String, you can then still say `Err = MalformedRows | MismatchedDimensions | ...`
Not at all. The point is to have them in a server. S3 is just a scalable static storage, but any server would suffice. Anyway, keep in mind that for serving static files, if you don't need any extra security layer, plain nginx is your best friend. Usually elixir/pheonix handles database and APIs, but files are served by nginx. A way to achieve this is to tell nginx that a specific path is mapped to a filesystem directory. In short, phoenix tells were the files are, nginx serves them.
I put up some stats on Elm activity to answer this question: https://korban.net/posts/elm/2018-03-23-is-elm-ecosystem-going-stale/
I was originally trying to deploy Phoenix to a Digital Ocean droplet running Ubuntu. I was never able to get it live though and that was my first experience with nginx. I am currently deploying my applications using a heroku-like service called gigalixir. How does that compare to using Nginx? 
Awesome plan!
Why would you need a certificate? They are useless anyways
Yes, I know. The company I work for focuses on self-development, and a certificate is an ok proof that I have worked with the programming language.
Don't think there are any certificates out there justifying any price tag. .aybe just build a webapp and put the source code on GitHub?
Don't think there are any certificates out there justifying any price tag. .aybe just build a webapp and put the source code on GitHub?
Maybe some of the courses would give you a certificate of completion? * [https://pragmaticstudio.com/elm](https://pragmaticstudio.com/elm) * [https://frontendmasters.com/courses/elm/](https://frontendmasters.com/courses/elm/)
Trying to learn elm by making a dynamic "About me" website to link on my linkedIn
make a elm webapp which prints elm certs. done and done.
Sounds fun! What sort of behaviors will it have?
Firstly I'm gonna make the navbar change the content of the page directly instead of linking you to a new Html. Secondly I'm also thinking of trying to make a side menu which automatically appears when you hover the mouse in that area. The backend will also be Golang, sadly i don't think there's a way to implement Go html templating in Elm
I'm fan of elm-styled :) Tried style-elements, I definitely see advantages but I didn't want a lock-in and it made code much longer and harder to read for me
I don't know about the other projects, but elm-css creates style nodes instead of style attributes, so you can use pseudo selectors like :hover. Personally, I still use SCSS (sassc) because it gives me a much faster workflow to use plain HTML + IDE integration and then using [html-to-elm](https://mbylstra.github.io/html-to-elm/) to dump the HTML into elm.
I tend to feel Haskell's operators are quite ugly, to be honest. Here are three ways to express the same idea: * `abs &gt;&gt;&gt; (+1) &gt;&gt;&gt; sin $ -10` (using Control.Category) * `sin . (+1) . abs $ -10` * `-10 &amp; abs &amp; (+1) &amp; sin` Idk, I feel like all of these operators are out of place, like imagine if instead of `$`, the default would be `|`: `sin . (+1) . abs | -10`. Seems way more elegant to me. I dig the rest of Haskell's syntax, but this area keeps bugging me. The `&amp;` is probably the worst one; not because of its left-to-right piping, but because of the character choice. When I read it I think: "Oh, -10 **and** absolute value **and** plus one **and** sinus". If it were to be something like `|&gt;` however, my association would be "-10 **piped** to absolute value **piped** to...". The `&amp;` operator seems to have nothing with piping in my eyes, so I don't feel comfortable using it. Feelsbadman :(
I'm using Bulma so I use the normal `class` and `classList` Html attributes. I know that `elm-bulma` is a thing but I just feel like using Html like normal with SCSS feels more natural to me.
I'm not very good at CSS and I do a lot of trial and error. I ended up using SCSS because of the sub-second compilation time. Maybe with the speed improvements in `0.19` the experience of using one of the Elm solutions would be better. 
I use elm-css because it's being actively developed. And these days I'm creating some simple functions that can help me avoid writing lots of CSS; https://github.com/azer/elm-ui-styles
In theory you can create a port and pass the selector of the element that you want to target. Messing with the dom generated by Elm from the outside world is dangerous, but if the app state does not change during the animation and if you don't remove anything, it might work. Can you setup a demo at https://ellie-app.com
Oh, nice! Thanks for the pointer.
(|&gt;) = (&amp;) Now there are four ways, but at least your pronunciation problem is solved :)
You might be better off using a lottie webcomponent](https://github.com/splitinfinities/lottie-wc). Here is a [sample elm app](https://ellie-app.com/nxLBHMTkMLa1). Should work in Chrome out of the box. You need to add a web components polyfill for the other browsers. 
Thanks for the answer, but I'm well aware of this solution :( I just think defining infix operators is a bad practice because [it's quite likely to overlap with an existing definition](https://hoogle.haskell.org/?hoogle=%7C%3E&amp;scope=set%3Astackage), and I feel like it may end up confusing. I think overall, composition is the cleanest solution and I'm super fine with that. My original comment was just a small grouch :)
Same thing here. I have given a try to style-elements. It is nice, but I switched back to vanilla elm-lang/html + Bulma or Spectre at work and for my side projects.
&gt; If you are looking to do lots of stuff with maps, you will want to use "ports" https://github.com/elm/elm-lang.org/issues/536#issuecomment-218603133
Here is a talk from Richard Feldman how he used the google maps webcomponent from Elm https://www.youtube.com/watch?v=ar3TakwE8o0
Thanks I will check this out.
That error message is a bit confusing, unfortunately. It would make a lot more sense if both types were fully qualified with their module names: The type annotation for `view` says it always returns: Html.Styled.Html Msg But the returned value (shown above) is a: Html.Html msg The problem is that all of elm-ui's functions are going to return `Html.Html`, but elm-css works with `Html.Styled.Html`. You can convert to elm-css' type using [fromUnstyled](http://package.elm-lang.org/packages/rtfeldman/elm-css/14.0.0/Html-Styled#fromUnstyled)
Could you help me a bit? I'm totally new to elm. How do I call that function? The following does not work: view model = fromUnstyled Ui.Layout.app [ text "sidebar" ] [ text "toolbar" ] [ div [] [ map LoginMsg (Login.View.view model.login) ] ]
I'm curious what error you get from that code? I assume it's something about too many arguments being passed to `fromUnstyled`. Anyway, you want to pass *the result* of `Ui.Layout.app` to `fromUnstyled`. As is, you're passing four arguments (a function and three lists) to `fromUnstyled`. You can use parentheses to change the order of operations: view model = fromUnstyled (Ui.Layout.app [ text "sidebar" ] [ text "toolbar" ] [ div [] [ map LoginMsg (Login.View.view model.login) ] ] ) 
You should give a try to style-elements, especially if you are not a css lover
Ok, now the arguments of the `Ui.Layout.app` are not ok. Do I have to wrap them again now? Do I have to wrap all the elements from `elm-ui`? How do other people solve that? -- TYPE MISMATCH -------------------------------------------------- ././View.elm The 3rd argument to function `app` is causing a mismatch. 16| Layout.app 17| [ text "sidebar" ] 18| [ text "toolbar" ] 19|&gt; [ div 20|&gt; [ backgroundColor hex "55af6a"] 21|&gt; [ map LoginMsg (Login.View.view model.login) ] 22|&gt; ] Function `app` is expecting the 3rd argument to be: Ui.Layout.Content msg But it is: List (Html Msg)
The `div` function in that code returns an `Html.Styled.Html`, while `Layout.app` expects `Html.Html`. `Ui.Layout.Content msg` is just a type alias for `List (Html.Html msg)`. You'll either need to use the elm-lang/html's `div` function, or use `Html.Styled.toUnstyled` to convert: Layout.app [ text "sidebar" ] [ text "toolbar" ] [ Html.div [ backgroundColor hex "55af6a"] [ map LoginMsg (Login.View.view model.login) ] ] -- or Layout.app [ text "sidebar" ] [ text "toolbar" ] [ toUnstyled (div [ backgroundColor hex "55af6a"] [ map LoginMsg (Login.View.view model.login) ] ) ]
Thanks a lot for your help! (off-topic: I'm evaluating elm as a solution that might be used in production. I really like typed languages and maintainable stable robust code but it shouldn't take 10x as much time as other solutions ;-)) Your first idea does not work here (I'm not sure what exactly the problem is) but the second one is working :) Here is the current state: view model = Ui.Layout.app [ Html.Styled.toUnstyled ( Html.Styled.div [ css [backgroundColor (hex "333")] ] [ Html.Styled.text "sidebar" ] ) ] [ Html.Styled.toUnstyled ( Html.Styled.div [ css [backgroundColor (hex "333")] ] [ Html.Styled.text "toolbar" ] ) ] [ div [] [ Html.map LoginMsg (Login.View.view model.login) ] ] Now it looks like [this](https://screenshots.firefox.com/ff9IxJyREcrZIVdk/localhost). I first expected the `sidebar` to be dark but of course that does not work because only the child `div` is dark. Here is what elm rendered: &lt;ui-layout-app-sidebar&gt; &lt;div class="_82efc26c"&gt; &lt;style&gt; ._82efc26c { background-color: #333; } &lt;/style&gt; sidebar &lt;/div&gt; &lt;/ui-layout-app-sidebar&gt; So instead of styling the div I'd like to style the `&lt;ui-layout-app-sidebar&gt;` :-\ Of course I can set the `height` of the `div` to `100%` but that's where all the dirty hacks begin :( But this is probably not a general `elm-css`/`elm-ui` issue anymore. Nevertheless these are the issues I'd have to fight with :( **A bit off-topic:** How do other "non-hello-world-projects" solve this kind of issues? **Even more off-topic:** Elm seems to be pretty young and the community is small, isn't it? I'm working with Rust in production and its a young language too but there is Mozilla that spend a lot of effort to the community and the language itself. Bigger companies like noredink might be ok with the "risk" to use Elm but would you recommend to tiny companies (&lt;4 employees)? What's your personal opinion?
&gt; Your first idea does not work here Whoops! Of course, I should have realized: if you're using `Html.div`, you'd also need all the attributes and children to be compatible. Probably easier to just use `toUnstyled`. &gt; A bit off-topic: How do other "non-hello-world-projects" solve this kind of issues? Personally, I wouldn't mix view libraries, because you're going to have a lot of types clashing. At work, I use [debois/elm-mdl](http://package.elm-lang.org/packages/debois/elm-mdl/latest). I've been tempted to use elm-ui, but 1) it is not published on the package site, because it uses native code, and 2) my limited design experience is based on Google's Material Design, so that's what I've stuck with. &gt; Elm seems to be pretty young and the community is small, isn't it? I'm working with Rust in production and its a young language too but there is Mozilla that spend a lot of effort to the community and the language itself Elm is about 5 or 6 years old I believe, based on the initial compiler commit in 2012. That's nothing compared to Haskell (1990), C++ (1998), or JavaScript (1995). But PureScript was created in 2013, and CoffeeScript in 2009. I don't think PureScript is as popular as Elm for front-end (PureScript is multi-purpose, Elm is only for front-end right now), and CoffeeScript has been declining in popularity. [In this survey last year](https://stateofjs.com/2017/front-end/other/), Elm seems to have beaten jQuery in terms of popularity as a front-end framework. Of course, React, Angular, and Vue are the most popular, but Elm is growing. Elm was the second place "Would like to learn" language, after Typescript ([link](https://stateofjs.com/2017/flavors/results)). According to Wikipedia, Rust was first released in 2011. The 1.0 released was 2015. Elm, as you may know, is still pre-1.0... &gt; Bigger companies like noredink might be ok with the "risk" to use Elm but what would you recommend to tiny companies (&lt;4 employees)? What's your personal opinion? I do use Elm at work, at a "small" company. We have been very happy with Elm. But I think it is very important to consider: what application are you building? What does it need to do in a web browser? Inside of the Elm language, I think things are great. The type safety is awesome. It's the "edge" of Elm that I've found problematic. I can be difficult to work with JavaScript APIs. Ports have certain (necessary) limitations, and the virtual DOM is very closed off during runtime. This is in contrast to React, where you can obtain references to a DOM element after it has been rendered, kind of like an escape hatch. If everything was written in Elm, there wouldn't be a problem, but not everything is written in Elm. You might need a code editor or a markdown renderer. Those kind of JavaScript libraries have been battle tested for years -- the pure Elm equivalents either don't exist, or are very new.
Thanks a lot for that insights! I'll definitely keep elm as an opportunity. Maybe I'll test it in a small project where the front-end isn't too complex. And of course I'll share my experiences with the community :)
Sounds like a plan!
Hello! I've been a developer for some time, and I'm passionate about the functional paradigm. I fell in love some time ago, and have been studying since then. The thing I've found most difficult was trying to build a SPA with routes, and extensible layouts in Elm. It's very clean and beautiful when you have all of your messages in one single component, but when you start working with routes and parent child communication, things get ugly pretty fast. I looked around for some examples, trying to find a good architecture to follow, but everything that I saw was super complicated. Has anyone felt the same thing? Is there an "elm way" of good practices to create like a dashboard for example? Or some solution that abstracts the routing and parenting and let you render only the simple components in elm?
Translate with Json.Decode?
Ah right, so would the type of `init` then be something like `init : Decoder a -&gt; (Model, Cmd Msg)`? Then you would use `decodeString (field todo (List string))` to decode it?
If the flags are simple (records of simple types present in JSON), you can pass the object to Elm as such and it will get decoded using an automated decoder: [here is an example](https://ellie-app.com/qS4VPYrd6Ma1). Please notice that I use the `Flags` type for the `Model` for convenience purposes. 
Hello! I've just started learning Elm and have been loving it so far. I plan to use it to make a CV website for myself. I am an intermediate Haskeller. So far I've been toying with the language and elm-mdl. Do you have any good tips/resources that would help me along?
I have a fork of the google maps web component that adds two features that I needed \(fullscreen and bounds of the displayed map\) and that fixes marker adding/removal through elm. [https://github.com/francescortiz/google\-map](https://github.com/francescortiz/google-map)
The "standard" Elm SPA example is this one: https://github.com/rtfeldman/elm-spa-example There's been talk about integrating some of the routing into the Elm runtime. It was rumored to be part of 0.19, although I think it's been delayed.
A common suggestion is to use [elm-mdc](https://github.com/aforemny/elm-mdc) instead of elm-mdl as MDL has been deprecated. 
&gt; of the routing into the Elm runtime Hello. I am not sure what architecture you use for you SPA. You are not supposed to have parent and child communication and components. Only reusable Html function. What you call child component are supposed to receive data from APP State not "Parent components" For a better routing , i suggest you to use https://github.com/evancz/url-parser 
If you haven't seen it already, the basic guide to reuse is here: https://guide.elm-lang.org/reuse/ The examples there are deliberately simple and don't cover routing but are a good introduction to the basic concepts. The Elm SPA example is extremely helpful to study once you feel you have a handle on the basics. Another good resource is this talk by Richard Feldman: https://www.youtube.com/watch?v=DoA4Txr4GUs&amp;t=1148s 
Thanks, I'll have a look!
i've got a few small questions: * What is the right way to give the type annotations to the following function?: -- (string,int) : String -&gt; Int (string,int) = ("hello",2) -- (\Int -&gt; Int) (\a -&gt; a) * is there a better way to write the follwing |&gt; (\a -&gt; case a of ...) * what is the best practice\naming convension to use variables that only are used once: (\a -&gt; list |&gt; foldl (\b-&gt;...) a ) in this case i would like to make it clear that *a* will not be used in the *(\b-&gt;...)* function.
In what order is the speakers list sorted? 
This looks really cool! Are there any plans for iOS?
in roughly the order they'll appear in the schedule. We don't have times finalized yet so it's not obvious. ðŸ˜…
1. I wouldn't destructure a tuple like that as a top-level definition. But the type of a tuple is `( a, a )` like so: foo : ( String, Int ) foo = ( "Hello", 1 ) 2. in a pipeline, I'd pull the function out into a let block: let nicelyNamedHelper a = case a of ... in foo |&gt; nicelyNamedHelper 3. You'd separate the scopes so that `a` *cannot* be used in `b`. You'd probably do this by pulling the inner function out to a higher-level definition like point 2.
Thanks! I don't have a mac, so I can't develop anything for iOS. But I'm open to contributions, if anyone wants to try. I think the big thing that's holding back an iOS version is that I use quite a bit of the [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) and the support for that might be a bit spotty on Safari. At least that's my assumption after having seen an error message on Safari, I never investigated more, so it might be something else entirely. Once the web app works on Safari, creating an iOS version should be as simple as the Android version.
Awesome! Definitely going to check this out. Will probably get my partner onto it as well!
I'm working on a web app for the new gdpr European law.
I haven't used this, but it might be what you need http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Keyed
I've used keyed before, but not sure it works in this case. Actually, come to think of it, I'm pretty sure it won't work since you used `Keyed.ul` for instance, and that doesn't translate to my example since I'm moving from a ul to a completely different structure based on divs.
Use CSS. Keep the HTML tree as similar as you can, and let CSS work its magic to change the layout.
I don't think it's possible. I think it's a limitation of the virtual dom approach. I also think that it wouldn't be possible with something like react. I guess your only practical solution is to restructure your html, e.g. like this: ``` div [ class (if orientation == Horizontal then "horizontal-layout" else "vertical-layout") ] [ div [ class "media" ] [ iframe [ src "..." ] [] ] , div [ class "media" ] [ iframe [ src "..." ] [] ] ]
I just said I can't use CSS for this. My real code is more elaborate than the example posted above. 
Yeah that's what I figured. I think I would be able to use lazy for this, if the iframes kept the same parent during the switch, but they don't. 
Sorry, I missed that in my haste. I don't think virtual DOM is going to be your friend for solving this problem then.
No, it turned out that even if I could move the nodes it would still reinitialize the players :)
Looking for inspiration, so I can write more elm
Glad you mentioned opaque types, which is quite a useful pattern for library developers. Also the importing of data constructors within a union type tripped me up while first learning elm. Glad you touched on the difference between importing `Plan` and `Plan(..)`
Have you tried encapsulating the functionality you need into a webcomponent and then trying to move that webcomponent? 
Back into my calendar widget again! This must be about the sixth go at it. Good fun.
elm-conf only registration will open next week, in case anyone's wondering. :)
I by far found VS Code plus the Elm extensions (including the linter with auto format on save) the best "IDE" for Elm development, myself. Highly recommended.
I'll go. I'm working through the exercises in the Guide, and I got stuck on the [Forms tutorial][1]. Specifically, I'm trying to implement the suggestion to create a custom function for the input fields to avoid the repetitive code. After a lot of trial and error, I tried using the [Labeled Checkboxes][2] code as a starting point. Here's my current code. ``` type alias FieldInfo = { name : String , fieldType : String , wrapClass : String , fieldClass : String } formField : Msg -&gt; FieldInfo -&gt; Html Msg formField msg fieldInfo = label [ class fieldInfo.wrapClass ] [ text fieldInfo.name , input [ class fieldInfo.fieldClass, type_ fieldInfo.fieldType, onInput msg ] [] ] ``` I haven't replaced the `input` functions with `formFields` yet, as this is already throwing the following recommendation: ``` Function `onInput` is expecting the argument to be: String -&gt; Msg But it is: Msg ``` I've jiggered with it in countless variations, but I think it's time to ask for help, because I must be missing something basic. I'd love to hear any ideas or suggestions! Thanks! [1]: https://guide.elm-lang.org/architecture/user_input/forms.html [2]: https://guide.elm-lang.org/reuse/checkboxes.html
Trying to maybe make [the Elm React-Native library](https://github.com/akavel/elm-native-expo-counter) work in a low-level way similar to [elm-ios](https://github.com/pzp1997/elm-ios) (more details [here](https://github.com/ohanhi/elm-native-ui/issues/90#issuecomment-397703690)). In other words, to remove as much JS code as possible from the equation, so as to minimize and generalize any needed "kernel" code.
Let's see if I can explain this. You've told the compiler that `msg` is one thing, and then used it where that thing can't be used. Wait, what? Ok, in other words, you've said that the `msg` has the type `Msg`. Then you've passed it to the `onInput` function, which actually wants a *function* with the type `String -&gt; Msg`, not just a `Msg`. If you're thinking "when did I say that `msg` has the type `Msg`?", well that's a great question! You defined that in the type signature of `formField`. The fix is to simply change the type in the type signature: formField : (String -&gt; Msg) -&gt; FieldInfo -&gt; Html Msg formField msg fieldInfo = -- Nothing changed here Now the compiler knows you want `msg` to be a function.
I've used VsCode, it seems pretty solid. But I mean the core team uses vim, so that seems worth checking out.
Could you list the VS Code plugins you would recommend?
There's an extension called `elm` - it does everything: syntax highlighting, autocomplete, `elm-format`, `elm-make` etc.
I coded Elm in IntelliJ IDEA and VSCode for ages, but just switched to Atom last week after reading a recommendation on Slack, and with the full set of Elm plugins it knocks the socks off anything else. So at the moment it's Atom for Elm, VSCode for Typescript and IntelliJ for everything else.
Then how about this, by evancz himself: https://github.com/elm/projects ? :)
That's awesome. Thanks for the reply.
I use emacs and you can elm format on save and get auto-complete with oracle. Haven't had much time for elm, lately, but it sounds like that's about what you get from other editors, too!
Thank you, /u/Magnetic_Tree! That works. I understand how the type signature works, I just didn't understand how to relate it to the onInput function.
It sure seems that Atom's plugins for elm go far beyond ones in other editors. Some people prefer not to use those additional ones but for me it has been very helpful. 
On the contrary, this is exactly what you need. Keyed is not restricted to unordered list. You can make any kind of keyed node using `Html.Keyed.node`. Doing so will ensure that if you add, move, or remove nodes from the keyed node their html will be reused accordingly by the virtual dom
I've been refining an internal web app at work. I've written a couple of apps on Elm before, but this was the first SPA. It went pretty well, though I made a couple of design mistakes along the way. I think my biggest problem, though, is design at a lower level. I can't quite put my finger on it, but I feel like things are just a little messy. I suspect it's because of inconsistencies in my style between functions, and not enough information hiding. Is there a collection of Elm idioms that I could look at and practice with? Or, more generally, is there a functional language version of the book, Code Complete?
Working on a Super Mario Bros clone in Elm
A common way to handle this in SPAs (not necessarily just Elm) is to prevent the default event on anchors, canceling the browser's built-in navigation, and always handle the URL change in your app's logic. If the page indicates it needs confirmation before leaving, don't change the URL/page. One problem with this is that middle clicking (and right clicking?) links no longer works, since you can't selectively cancel events in Elm. You either cancel all occurrences of an event, or none of them. I believe this is fixed with a new way to dynamically set preventDefault and stopPropagation in 0.19.
See Magnetic_Tree's comment for a direct solution, but here's a small suggestion: Blocking user interactions with a modal warning is not very friendly - if that's your intent, I would suggest looking for a less obstructive experience. Eg. for a form, you could let the user leave without blocking their exit, but automatically save it as a draft so that the user can come back and continue filling it out if necessary.
&gt; you can't selectively cancel events in Elm Good news! This actually is possible. `onWithOptions` takes a JSON decoder, and if that decoder fails, the options are ignored. So it would be possible to only prevent the default event on a left click, and let middle/right clicks work as necessary. On the other hand, this approach seems like a lot of work. If I understand correctly, I'd need to find every part of my view code which generates a link, and augment the link with an onclick handler. And then if it's a polymorphic `Html msg` type, I'd need to either force it into a concrete `Html Msg`, or make it into a function `msg -&gt; Html msg`. And just about every `update` function would need a navigation message added. Or... I guess I could use a subscription to `click` events, and check if the target is a link? I wouldn't be able to use the `Mouse` module because it doesn't let you use a custom decoder, but https://github.com/dkodaj/globmouse might work. That sounds like a reasonably hairy decoder though, if it works at all. (Would a json decoder be able to examine an event's target element?) I'd also be a bit worried about accessibility. The question that comes to mind is, does pressing enter on a link generate a click event? (Looks like yes, and I might need to specifically have my decoder check for that possibility.) But I'm not confident that that's the only question I should be asking. (Then again, I'm also not confident that the approach I describe in the OP has no accessibility problems.)
Yeah, we've tried to avoid having a modal, but couldn't find a good alternative. Roughly speaking, they're creating a form and then filling it in and saving. But if they leave before saving, they can edit the form that they're filling in, and that would lose all the data they've entered, even for parts of the form that don't change. We can't really avoid that data loss, at least not without a lot of work that we don't have time for now. So a modal warning seemed the least-bad option.
&gt;&gt; you can't selectively cancel events in Elm &gt; &gt; Good news! This actually is possible. onWithOptions takes a JSON decoder, and if that decoder fails, the options are ignored. So it would be possible to only prevent the default event on a left click, and let middle/right clicks work as usual. Oh, you are correct! I swear I read a conversation about how this wasn't possible, but I can't find it anymore. And it makes sense that when the event decoder fails, the event isn't canceled. I found [a fairly robust solution here](https://github.com/elm-lang/navigation/issues/13#issuecomment-272996582), which allows the Elm app to handle left click, but right click, middle click, and Ctrl / Cmd + left click are handled by the browser. &gt; On the other hand, this approach seems like a lot of work. If I understand correctly, I'd need to find every part of my view code which generates a link, and augment the link with an onclick handler. And then if it's a polymorphic Html msg type, I'd need to either force it into a concrete Html Msg, or make it into a function msg -&gt; Html msg. And just about every update function would need a navigation message added. For better or for worse, I believe that's correct. I was curious how Richard Feldman handled it in [his elm-spa-example](https://github.com/rtfeldman/elm-spa-example). Looks like click handling is left to the browser. But I just thought of something... does the `beforeunload` fire when the page has enabled push state? If so, I suppose you *could* use the `beforeunload` event, even in an SPA.
With the date picker finished I've been working on the remaining material implementation of form control components. [Text input and autocomplete/super-select](https://abradley2.github.io/elm-form-controls/) are pretty much done. The autocomplete select was particularly tricky but I find this to be such a useful component that im in frequent need of it.
It's been suggested to Evan before. We'll see what he decided when 0.19 is out.
&gt; I was curious how Richard Feldman handled it in his elm-spa-example. Looks like click handling is left to the browser. Just to clarify, you're bringing this up out of interest, not because the app uses any modal confirmations that I could learn from? (Which is totally fine. I'd just feel really silly if I missed a useful resource because I misinterpreted you.) &gt; But I just thought of something... does the beforeunload fire when the page has enabled push state? It seems sadly not, that was our first attempt. Unless by "enabled push state" you're referring to something we might not have done?
&gt;&gt; I was curious how Richard Feldman handled it in his elm-spa-example. Looks like click handling is left to the browser. &gt; &gt; Just to clarify, you're bringing this up out of interest, not because the app uses any modal confirmations that I could learn from? (Which is totally fine. I'd just feel really silly if I missed a useful resource because I misinterpreted you.) Right, that example app doesn't ever cancel a navigation based on the page state, like you're trying to do. I was just curious how links were handled! &gt; &gt; But I just thought of something... does the beforeunload fire when the page has enabled push state? &gt; &gt; It seems sadly not, that was our first attempt. Unless by "enabled push state" you're referring to something we might not have done? Sorry, that's the correct terminology, I suppose I'm referring to when the page is listening for `popstate` events, which I believe is what changes the browser's navigation behavior? (where events that would normally cause a page load simply change the URL and fire a `popstate` event)
Hmm wasn't working for me in Firefox when I tried the Ellie demo.
Maybe someone with more Haskell knowledge can comment on this: Isn't this the same module system that Haskell uses? Where the module header has to match the path?
Should work now, there's a hack I had to add for Firefox to work correctly.
In my opinion, it's a useful little redundancy. You have a remainder of the module you'r working on at the top of the file. Regarding refactoring costs, it is actually a tiny additional cost. If you import this module in N other modules, you have to change N+1 line instead of just N if we didn't have to put a module name.
Generally speaking, your Elm application would need to make use of AJAX calls or WebSockets to send/receive data from a back-end web service. 
No, what templating does is generate the HTML file the backend eventually sends dynamically. Templating lets you use variables in HTML which gets swapped out for raw data BEFORE the file gets sent via HTTP. Since ELM compiles to .html files i don't see why this wouldn't be possible
Elm compiles to JavaScript. The compiled application generates dynamic HTML.
How does that make adding Go template compatibility impossible? I'm suspecting you don't use templating
I'm sure benthepoet is familiar with templating languages, Elm is kind of a templating language itself! Currently, Elm only supports client-side rendering. There isn't any native support for server-side rendering, which would allow HTML to be sent with a web response. Generally, how I would send information from my backend would be by getting that data in a format that Elm can understand when the page loads! For me, that means using a templating language to render JSON on the page, so Elm can use it as flags when it gets initialized. For more information on flags, here is the official guide: https://guide.elm-lang.org/interop/javascript.html If you have any questions or ideas for a new module, check out the Elm slack. The community is super friendly, and always excited to help out!
Elm needs to support server side render, which to my knowledge it doesn't. 
You'd effectively just be embedding the compiled Elm application when writing your Go template. You can pass JSON in the flags when initializing the application as /u/BaoDur mentioned. &lt;script&gt; var flags = { someData: [1, 2 ,3] }; var app = Elm.Main.embed(document.querySelector('main'), flags); &lt;/script&gt;
You can give Elm only a portion of the app by using `embed` and render the rest of the page using Go's templating system. I'm using Phoenix for by backend but the principle is similar. I use Phoenix's templating system to generate some of the HTML that is being sent to the client and Elm does the rest. 
So you're thinking i should Encode data into JSON in Go and Decode it in Elm? That could work. Thanks
I think Evan did one to demo the time travel debugger
I've just started using Elm, I have a question on the text input you've made. In React I'd have some local component state for the active focus implementation â€“ I usually wouldn't want to concern my global store with that. How do you deal with this in Elm? Does the input have some kind of UID that's stored in the model?
So components cannot encapsulate their own state. They can however encapsulate all the logic around initializing, managing, and updating that state. Generally any ui library you find in elm will export a `view`, `init`, `update`, `Model`, and `Msg` and ask you to plug it in to your model and update logic. From there. Unique ids are generally needed when you have a varying number of the elements on a page and the `Msg` must be routed accordingly. [The readme in the elm-community/datepicker is a good example of something describing this approach](https://github.com/elm-community/elm-datepicker) There's alot of pros and cons. Its generally a bit cumbersome to initiatilize reuse this way as you probably immediately noticed. You have to wire more up. But the great part is since `Msg`s and the `Model` are accessible to you, there's no _"I wish this component had a callback for this but it doesn't"_ or _"I need to implement this as a custom behavior but I can't"_
I prefer to use [elm-decode-pipeline](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest). 
Yes, I'm actually try to get to an actual clone now :)
Yes, me too. But it's good to know that `Json.Decode` can do these things I think. 
This is so well written I want to cry.
Elm case statements do not allow multiple conditions to share the same branch body, working with this constraint if you want to avoid duplication the best you can do is extract out the branch body into it's own function and then have both conditions call the newly created function? Possible answers: (True | False | NotApplicable)
Ah, this is great. I just added decode pipeline as a dependency to a project just because if a single model. I don't mind having some dependencies, but when it contributes so little...
Not sure I understand the question. Are you talking about something like this?: case (nodeType, relationName) of ("Seq Scan", "projects") -&gt; highlightNode Color.blue node (_, "projects") -&gt; highlightNode Color.green node _ -&gt; displayPlainNode node 
Yes, that's what I'm talking about. You can't do anything resembling multiple conditions having the same body: case (nodeType, relationName) of ("Seq Scan", "projects") -&gt; (_, "projects") -&gt; highlightNode Color.green node _ -&gt; displayPlainNode node case (nodeType, relationName) of ("Seq Scan", "projects"), (_, "projects") -&gt; highlightNode Color.green node _ -&gt; displayPlainNode node
Join the slack for updates. There is plenty work being done for 0.19
Oh I see. No, I don't think that's possible. 
I really, _really_ hate this attitude of oh just join the slack. Not everyone has the time to spend lurking around the slack all day. Slack isn't googleable, or even easily searchable. Old conversations may as well have never happened. It leads to a lot of the issues we see repeated over and over again here and in the slack. Beginners may post the same questions over and over again, not able to search Stackoverflow for a link. You get people coming here and slack asking if elm is dead on the regular, because slack makes it appear that way. It's honestly toxic imo, but clearly the people with the power to do something don't care. Sorry, rant over. 
&gt; "Things take the time they take. Donâ€™t worry." - Mary Oliver Everything is fine. Relax. If you want to use Elm to solve real problems, join the Slack workspace or the Discourse server and there are plenty of people there to help. Nobody there is worrying that Elm might be dead. :) 
&gt; I really, really hate this attitude of oh just join the slack. I'm sorry you feel this way but this has been the main place for discussion of the Elm community. Now there is also [Elm Discourse](https://discourse.elm-lang.org/) for questions that might require a more extensive treatment. &gt; Beginners may post the same questions over and over again, not able to search Stackoverflow for a link. What do you mean? [There are plenty of Stackoverflow questions and most of them have answers](https://stackoverflow.com/questions/tagged/elm). &gt; You get people coming here and slack asking if elm is dead on the regular, because slack makes it appear that way. It's honestly toxic imo, but clearly the people with the power to do something don't care. It is unfortunate that people think Elm is dead but this mistaken perception can be clarified by looking at the commits of the official repositories. As for not caring, again... it is a mistaken perception that can be easily clarified. 
Then check the elm-dev mailing list
&gt; It is unfortunate that people think Elm is dead but this mistaken perception can be clarified by looking at the commits of the official repositories. As for not caring, again... it is a mistaken perception that can be easily clarified. I also would expect stuff on the website. I can see things are happening on the git repo, but I have no clue about what they mean, what is expected, what is the roadmap, etc. And I do not want to spend time on slack either!
The new update 0.19 is coming in a few months.
This problem, real or no, is not on the users to fix. If elm appears dead don't blame the users for not using what you picked to distribute information. 
Elm is basically owned by one guy. Give him a break, he's working on what really matters (the compiler for 0.19). Also Elm is incredibly stable, and updating the website or writing blog posts doesn't decrease the stability. Like others have already said, join the Slack channel for updates. Lack of updates != deprecated (unless you're in JS land ;) ) 
In my opinion, It is not that Evan doesn't care about the appearence for potential newcomers. It is that he cares more about the experience of acual newcomers (and everyone else) and out time is limited. I think elm, with its design and community is making web development great. The reason it's moving slowly is because Evan prefers to make careful progress, with feedback from people he trusts (cf https://discourse.elm-lang.org/t/what-is-constructive-input/977) than putting all things always out in the wild wild web. As someone who has been following elm for the past 2.5 years, I can assure you that is it living and growing, and that you can start elming with confidence now. Updates, blog posts and world wide elm conferences (elm europe: https://2018.elmeurope.org/, elm-conf: https://www.elm-conf.us/) are coming soon!
&gt;Elm is basically owned by one guy. It's what scare a lot of people, without being in the bad side of the JS world where everything move all the time, it maybe time to grow the Elm team. Evan can focus on the compiler while other members write blog post about the last progression. Elm is great but the communication around the project is terrible. I don't see other example of project of the same scale with less communication ;/
I'm the the OP of "Is Evan Killing Elm's Momentum". After I wrote that post, to my shock, it took a few more months to update the copyright notices on the bottom of main pages of elm-lang.org site. It was still "2012-2016" or "2012-2017" on some of the pages until fairly recently. Why is that important? Because if the language looks dead, it impacts the overall growth and adoption of it. I see some people have argued, " If you want to use Elm to solve real problems...". That's a very bad view. I bet no newcomer who is looking at Elm now, is going to use Elm to solve real problems. By "real problems" I mean a solution that needs money, or time investment of several developers. Why? Because you're not just looking at what the solution can do now, but you also asses if it's something you can build a team around. If it's some technology that is going be around 2, 4, 6 years from now. Currently (intentionally or not), Elm comes across as a side project for weekend hackers. Elm talks about all these companies using Elm on production. That is a misleading positioning. Because at the same time you see comments that Elm is not ready for production and should be avoided. Then I do not understand the marketing emphases of Elm adoption on actual projects and promoting as such if that's not really what Elm can do today. I picked up Elm 2 years ago. And I fell in love with it. But now that I'm considering between staying with React for our internal product or using Elm, I'm going with React again. As much as I would want to use Elm, I just have no confidence it'll be a good business decision. Elm in many ways would be ideal for this project as it helps me reason better about the state of our model, etc. But I just don't see Elm making it anymore. I don't think with the current pace, Elm has enough people and resources behind it to stay relevant outside of some academic stuff. Worse of all, Evan has not shown he is able to bring in other high-level thinkers to help contribute to the overall planning and the future of Elm. It's really a small one-person project by a very smart person. But this makes it a very risky option for many businesses. People say there is a lot of activity on Slack and .19 is coming. But that's not the point. First of all, no one can say with certainty when it's coming. Secondly, I've spoken with Evan on couple of occasions. He is very thoughtful and articulate. Yet, he is unable to fully articulate his vision and roadmap on a simple blog post on Elm-lang.org. Why? I suspect that he himself doesn't really know. I get it, he wants to analyze and take his time to come up with a perfect solution. But the perfect solution is not always the best business solution. Companies adopt technologies for various reasons. It's mostly should be around the best tool to solve a problem. However, you also need people who are proficient with this tool so that you can hire them. With so little visible traction and other entities quickly copying some better aspects of Elm. Elm will become some niche forgotten platform. I still recommend it to friends as an intro to functional programming, but I tell them, they should treat it just as an intro to functional programming and look elsewhere for production work. Ultimately, analysis-paralysis and inability of Evan to recruit people smarter than himself to drive the future of Elm destroyed Elm. I'm guessing Elm .19 and all the useful stuff around it, wont be in until 2019 (maybe that's why it's called .19) and by then many developers have looked elsewhere. In 2-3 years, probably NoRedInk itself will also have moved to one of those other solutions. So, you didn't have a heart attack, Elm did! 
Folks, this discussion was very unproductive last time and there is no reason to believe it will be productive this time, especially given the way this post is framed. Conversations like these are not an effective form of feedback, and this is not a place to vent frustrations.
The claim: &gt; Elm has no genericity mechanisms Is an odd start. Polymorphism is a pretty standard mechanism for this. Like `map : (a -&gt; b) -&gt; List a -&gt; List b` is generic in the type of the incoming and outgoing list. When folks talk about "there are no generics in language X" they are usually talking about polymorphism, so I found that first line ambiguous at least. Have you ever read [On the bright side of type classes: instance arguments in Agda](https://dl.acm.org/citation.cfm?id=2034796)? I think it gives a helpful understanding of what "user-definable type classes" really give you. Namely arbitrary implicit parameters.
I have added as precision "for structures"
The name `Reader` comes from Haskell. It is a technique to hide arguments. I have found in my Haskell code that I almost always prefer to (1) just pass in the arguments or (2) model outcomes more explicitly. ## Pass the Arguments This usually means having an `Env` type with all the stuff functions may need to know about. For example: ``` view : Env -&gt; Model -&gt; Html msg update : Env -&gt; Msg -&gt; Model -&gt; Model ``` Now it is very obvious whether you need the `Env` or not. Is it an argument? The fact that it is not in the result means that it cannot be modified by the function. This is how I prefer to use read-only arguments. ## Modelling Outcomes There are other cases where maybe you don't want to specify everything. I would probably model the result specifically. In the example in the README, I might do: ``` type Query a = GetDog String (Decoder a) toRequest : String -&gt; Query a -&gt; Http.Request a ``` Now imagine how things go as your code gets more complicated. In the explicit model here, it gets _more_ explicit. If we want to ask things about other domains, we can add `GetCat`. And if we have two endpoints, we need two API keys. Implementing `toRequest` will make that obvious. Whereas with a reader, the whole point was to hide arguments, so things start becoming _more_ implicit. Why does `run` need two arguments? Well, if we look through all the code we will find out. ## Summary In all these cases, we are just pushing the argument around. When will you give the `Env`? And my point in this post is that I think there are a lot of things to try before "the reader type" is clearly the simplest approach for the long-term health of your code. In my Haskell code, I have found that these cases are getting smaller and smaller, and the remaining cases are (1) code that interfaces with dependencies I cannot drop, (2) code that requires particular designs to work with certain language features in Haskell, or (3) code that relies on the particulars of how the GHC optimizer works. But those are all Haskell specific scenarios.
Learning how to get Elm to talk to GraphQL using Elixirâ€™s Phoenix WebSocket channels and their Absinthe GraphQL server library. Ported Evanâ€™s TodoMVC Elm application as the frontend just to use as a simple, fun example. GraphQL beats the pants off of REST IMHO. Code is here: https://github.com/pzingg/todo_absinthe
Couldn't you just move the `apiKey` argument to the end of the argument list and let partial application do it's work?
Nice, saving for later :)
This is mostly cosmetic, but I'd like to know why sometimes closing a brace on the line following content fails to compile while moving the brace to the end of the last line of content will compile just fine. Example: type alias Model = { element : String } model : Model model = { element = "" } This won't compile, complaining about the final closing curly. But if you simply move that closing curly to the end of the line above, like this: element = ""} Then lo, it will compile. Notice that the same stricture does not cover the type alias above it. :P So is there a real ambiguity of some kind at play here?
I hope this becomes a thing
&gt; ou simply move that closing curly to the end of the line ab Because your curly bracket is equal to m of model the "good" indentation is model : Model model = {element = "" } 
Great initiative! I was just trying out elm-native-ui &amp; on their Github page they use react-native version 0.44, while you use the most recent one. Are there breaking changes? Should they bump the version on their dependency in your opinion?
For upgraded ENU, see: https://discourse.elm-lang.org/t/tell-elm-native-expo-counter-upgraded-to-react-native-0-55-expo-27/1374 As to a bootstrap script, yes, I do have such plans; more like usage guide, because I'm hoping this should be installable into a regular create-react-native-app project.
Dude.. nice.
Thanks! It does not deviate much Elm wise from the tutorials. Could you commend on the */static/* bit? Why the js things?
He is just putting appart all elm related javascript, like ports or the call to elm. I think it is a good practice to help keep code organized.
Indeed, maybe 'static' is not appropriated folder name. For the js things, at work i build proof of concept, most of the time i use port to interact with javascripts library. 
Really hoping Elm-Native becomes a thing
 reportsToRender model |&gt; List.filter (\{ name, subtitle } -&gt; tupleList |&gt; List.member (name, subtitle) )
I wrote it like below, but it gives only one match. hpagFilterReports : List { a | name : String, subtitle : String } -&gt; List { a | name : String, subtitle : String } hpagFilterReports reportTiles = let tupleList = [ ( "Full Text Report", " " ), ( "Deficiency Report", "Detailed" ) ] in reportTiles |&gt; List.filter (\{ name, subtitle } -&gt; tupleList |&gt; List.member ( name, subtitle )) logged = log "tiles" (hpagFilterReports (reportsToRender model)) I want it to print all records which has the name and subtitle pair match.
Your code works, but in your \`tupleList\` you've got a non-breaking space inside the quotes instead of an ordinary space, which is why it doesn't match the value in \`reportsToRender\`, and you get one less element in the resulting list.
this should be possible using just elm and the [mouse](http://package.elm-lang.org/packages/elm-lang/mouse/1.0.1/Mouse) package as you can see there you can have subscriptions for each of the events you mentioned From there you can track you the state in your model
Ah that's interesting, I did not know about the Mouse library at all before. But I went from 0 to infinity blowing by 1 entirely, because now I see like 3 mouse libraries, don't know which one to use, and don't see any proper documentation for any of them. ;) * [elm-lang / mouse / 1.0.1 / Mouse](http://package.elm-lang.org/packages/elm-lang/mouse/latest/Mouse) * [elm-lang / core / 2.1.0 / Mouse](http://package.elm-lang.org/packages/elm-lang/core/2.1.0/Mouse) * [mpizenberg / elm-mouse-events / 2.0.0](http://package.elm-lang.org/packages/mpizenberg/elm-mouse-events/latest) (which in turn claims to be deprecated in favor of [mpizenberg / elm-pointer-events](https://github.com/mpizenberg/elm-pointer-events) when Elm 0.19 comes out?) Something like a page-wide subscription to "now the (left) mouse key is Bool" sounds like it would suit my needs just fine. elm-lang / mouse / 1.0.1 / Mouse has a Mouse.isDown that sounds a lot like it would do that too, but if I try to "import Mouse" and use it anywhere I get the error "`Mouse` does not expose `isDown`. " :o
What do you mean by non breaking space?
Maybe you need something like that http://elm-lang.org/examples/drag.
It's a different character than a "normal" space, but they're not visually distinguishable. Try writing the strings containing a single space again.
I'm also seeing this behavior.
Hi u/jesset77, if you want to track mouse events over the whole page, the best approach will be to use elm-lang/mouse, i.e. the first one you cite. The second one is an old api. As for the third (elm-pointer-events), it is better suited for managing events in nodes of your dom. Using elm-lang/mouse, you simply subscribe to downs and ups in the document and toggle a field in your model. If you are just beginning with elm, I suggest that you get familiar with the way subscriptions work at first by following the guide: [https://guide.elm-lang.org/architecture/](https://guide.elm-lang.org/architecture/).
Yep, it will take me a little time to digest that to 100% confirm but from first scan through that looks magnufique. Thank you :D
Great news, u/mewhit had recommended http://elm-lang.org/examples/drag to me and I was getting an import error through elm-reactor so thank you for clarifying which of these packages said example was trying to import. Example runs smoothly now, so I've just got to work out how to adapt that to my more specific needs but it appears I've got all the tools I'll need to get that done now. So thank you everyone. :D
It's advertised on the "major focus" list for 0.19, so the posibility's there
How can i close a modal window when clicking on the translucent part? if i use the `onClick` attribute, it will close even when clicking the non-traslucent part
Mind unpacking why you think you'll lose safety in a refactor using wildcards? If I did: ```elm update msg mdl = case (msg, mdl) of (CheckAuthMsg, CheckAuthModel) -&gt; // do success stuff (CheckAuthMsg, _) -&gt; // do catastrophic error stuff ``` I'd feel confident that if I accidentally ruined my app in a refactor that bad states would be handled as errors.
It would be handled as _runtime errors_,which is not a good thing, right? Basically, how do I express the fact (at compile time), that it is not even **possible** for my app to emit a `FetchUserProfile` message if it in the `Login` state.
Fair enough, I shouldn't have used the word error - it is handled appropriately (by you) at run time. + Solution I'd use: I think if I wanted compile time guarantees about the Msg/Model combinations that could be emitted I'd take the full plunge and move the separate components into their own modules. In fact I think that's what I've done any time I might have otherwise been tempted to make my model a union type. Last time I used elm-mdl I thought it was a great example of that model https://github.com/debois/elm-mdl/blob/v8/src/Material.elm#L216 starts with the exposed Msg m type and with the docs should be a pretty easy follow along for making an app split along those lines. + Less useful response: Of course it's possible though, that's why you have to handle it, just because you **think** you have written code that can't implement that behavior doesn't mean that's the case (I have a lot of experience with that...). What I think you're asking is, how can I make it impossible. But I'm also not sure you would want to. Imagine you decide in the future to load your app's state from local storage, with your app design would you need to trust your users and clients to not muck with that store in a way that makes it impossible for your app to emit a FetchUserProfile message if it's in the Login state? Do you trust your code to prove out that assumption enough that you want the compiler to ignore the possibility?
You are overthinking this. The truth is that this whole "We can make illegal states impossible in elm" thing **is a lie**. The elm compiler can only know so much about your code without actually running it. Any view code can send any `Msg` value at any time to your update function so the compiler has no guarantees that `CheckAuth` is sent during a particular model state. You are just going to have to accept the fact that at some point you *might* make a mistake and end up in an illegal state. Just pattern match with a wildcard so that if there is a model with an "impossible" constructor it just shows an error. If you are still feeling a bit paranoid about it, write some tests. I don't think there is a better solution for this right now. In this particular case you could also consider moving the login code out of your elm app and just use a dumb html form that posts credentials to the server with little or no JS. Once user is logged in you could pass the `User` data as flags to your elm app. This approach to authentication avoids a lot of security vulnerabilities.
What is the overall difference between a \`Subscription\` to the Esc key versus an \`on "keyup"\` event? 
Messages are data representations of asynchronous events. Being asynchronous makes them potentially arriving at any time. So you might not really want to make it impossible to receive a message that should be impossible, since it might not make sense to prevent them. The best option I think is to pattern match in pairs the messages and the relevant corresponding parts of the state. Ignore any (Msg, Model) combination that should not be legal. Basically what bkrn is proposing.
I think "am I making illegal states impossible" and "do I have nonsensical msg/model combinations in my update" are two related, but fundamentally separate concerns. Sometimes, modeling the domain better increases the number of nonsensical cases, sometimes it decreases them, it really depends on the particular situation. Some `(Msg,Model)` pairs result in a state change, others don't. There isn't a nice way to represent which do and which don't in the type system, so you gotta do it in the update function. One trick is to return `Maybe (Model, Cmd Msg)` from your update function to make it a bit more explicit. Then you can easily log whenever it returns `Nothing`, or mix and match smaller update functions with the helper functions from `elm-community/maybe-extra` 
I would second the dumb login form with user passed as a flag. Itâ€™s how we do it and seems to work well. 
A simple login form could send a POST request do the server, the server saves the userid in the session and then redirects to the real Elm app?
Is this any use? http://package.elm-lang.org/packages/myrho/elm-round/1.0.0
I think that's what I'm looking for. Thank you!
Yes. you can also send the html with your elm app on the response of the POST request to avoid using any JavaScript.
Yes, I didn't think about the async nature of `Msg`. 
That link requires username and password.
Someone seems to have linked to a staging server, accidentally. Removing `staging` from the url, seems go get the article: [https://www.imaginarycloud.com/blog/elm-javascript-reinvented-1-overview/](https://www.imaginarycloud.com/blog/elm-javascript-reinvented-1-overview/) Enjoy!
I'm not sure if the community here would agree with this, but I found that replacing the native `window.requestAnimationFrame` function with a function that was called more frequently actually improved the FPS of my app. If you are interested in experimenting with your app, you may want to consider using this polyfill as a template: https://gist.github.com/paulirish/1579671
Reading the [Elm syntax](http://elm-lang.org/docs/syntax) and the [Types](https://guide.elm-lang.org/types/) chapter of the Guide should provide you will the information you seek. 
There's an rfc for react about this feature: [https://github.com/reactjs/rfcs/pull/34](https://github.com/reactjs/rfcs/pull/34) 
Hi u/boomshroom, I'm not myself doing game dev, but I've manipulated a lot of svg. My feedback is that in chrome, it is pretty fast! You can have a look at this game for example: [https://discourse.elm-lang.org/t/svg-game-at-60fps/1424](https://discourse.elm-lang.org/t/svg-game-at-60fps/1424). There is also this list of games that could help you figure out what is in the realm of possibilities in elm: [https://github.com/rofrol/elm-games](https://github.com/rofrol/elm-games). In slack, there is a dedicated channels (#gamedev) for discussing all this also. Happy coding :)
If this is a common case, setting up a company just to sell certificates seems like a good business idea :)
Terribly sorry, I will upload it again later with the correct link.
Uploaded this again as I've messed the link up last time.
Thanks Iâ€™ll have a look!
This might be true, but you also have to keep in mind that requestAnimationFrame automatically adapts to the performance of each device. If your computation takes too long you might force de browser to delay a frame. In this case, I would try to lighten the render function either by use case optimizations or by creating calculation loops separate from render loops. The game ticks happen at a regular state, frame rendering happens when the browser says it is the right moment to render. This will also help keep the game experience more even among different system configurations.
One thing you need to know is that you can't "change" things in elm. (Pure functions, immutability, all that...) The function producing your view simply has to get it right the first time. This isn't a problem, it just requires you to provide all the necessary information relevant to the view together. Then it can make the decisions about which vertices should be highlighted before they actually get rendered.
I wouldn't use javascript for that; Id probably use CSS. I know it doesn't answer your question but it will take less time to change the underlying HTML elements to achieve what you want using the `:hover` pseudo-class.
I feel like that would be very strange for current syntax of the language. Assignment (i.e. `=`) would no longer indicate the definitive definition of a identifier.
I'm not Evan, but couldn't function overloading quite easily conflict with currying and partial application? For instance if I have 2 functions `f: string -&gt; string` and `f: string -&gt; string -&gt; int`. Which function should be called if you apply it with `f "foo"`? The first one or the second one partially?
There are multiple ways to handle that. One option is to report a type error due to the ambiguity. Another option is to use the expected type. If a `string` is expected, choose the first overload; if `... -&gt; ...` is expected, choose the second. A third option is to have intersection types `string &amp; (string -&gt; int)`. Haskell uses constraints, eg. `read "xyz"` has type `forall a. Read a =&gt; a`.
The Haskell approach is typeclasses, actually, not "constraints". You can define a set of functions (well, values) which can be implemented per-type (a typeclass), and then *add* a constraint to functions' types which require something from a typeclass. This allows stuff like equality to be defined on a lot of types - but keep one operator - without Elm's compiler magic.
If you represent your network graph as an array of vertices and edges, each vertice have a unique id. In your view function, you can then have mouse event listener on the vertice view element (if you are using svg for example) that will let you "toggle" highlighted cluster. Basically, this just means that if your view function knows the id of central vertice of the highlighted cluster it can draw it differently. viewNetwork : Network -&gt; Maybe Int -&gt; Svg Msg viewNetwork network maybeHighlightedId = ... I suggest you have a look at [elm-visualization](https://github.com/gampleman/elm-visualization) that have an [example of force directed graph](https://code.gampleman.eu/elm-visualization/ForceDirectedGraph/). You could find every inspiration needed from there I think for your "react to mouse" aspect of the graph.
Idris has support for function overloading, as long as the use is unambiguous. Ambiguous functions need to be qualified. So it is definitely possible. Idris may however have different circumstances than Elm when it comes to type inference. E.g. you are required to provide type-signatures at the top-level and being dependently typed might already affect type inference.
Yet another approach is to use something like [modular implicits](https://arxiv.org/pdf/1512.01895.pdf) or [instance arguments](https://archive.alvb.in/msc/thesis/reading/typeclasses-agda_Devriese.pdf). Kind of prefer them to the Haskell way tbh.
An animated illustration of scenery I saw earlier this year. Combining static svg, mapped to elm code with different animations. It is a side project to learn more about interactive illustration.
Hi again u/boomshroom, one thing I would warn you against is that: &gt;My guess is that if it's possible in JavaScript, that it shouldn't be too hard to write a small wrapper. The web (including JavaScript) is a huuuuge platform, and Elm only natively support few of these. But in doing so, it tries to provide the best API possible. Wrapping of JS libraries is often discourage because we want to keep the guaranties that Elm can give us (like no runtime exception, semantic versioning, etc.). But that's enough for the aside note. You can ask plenty of questions about that on slack. Regarding you question, the answer is Yes :) -&gt; How to do it? "it depends ...". In particular, it depends one two things: 1. Does your elm application have control over the whole DOM? 2. Do you want to detect click anywhere on the page? &amp;#8203; case (1,2) of (False, True) -&gt; Here is the trouble, the API provided in elm will not help you in this case. You should handle the events in JS land and "port" the result to your elm app. _ -&gt; // any other case Welcome to happy land! You can attach mouse events to any view element you wish, and use the `button` property from the `MouseEvent` API ([https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)). Doing this directly would look something like this (though not exactly): type Button = NoButton | MainButton | MiddleButton | SecondButton | BackButton | ForwardButton buttonDecoder : Decoder Button buttonDecoder = Decode.map buttonFromId (Decode.field "button" Decode.int) buttonFromId : Int -&gt; Button buttonFromId id = case id of 0 -&gt; MainButton 1 -&gt; MiddleButton 2 -&gt; SecondButton 3 -&gt; BackButton 4 -&gt; ForwardButton _ -&gt; NoButton view : Button -&gt; Html Button view : lastButton = Html.p [ Events.on "click" buttonDecoder ] [ Html.text (toString lastButton) ] I've set up a working Ellie to get you started if you want to experiment on your own: [https://ellie-app.com/J2xtpwFS3ka1](https://ellie-app.com/J2xtpwFS3ka1) Shameless plug, you can also directly use this package: [http://package.elm-lang.org/packages/mpizenberg/elm-pointer-events/2.0.1/Mouse](http://package.elm-lang.org/packages/mpizenberg/elm-pointer-events/2.0.1/Mouse). Here is another Ellie using this Mouse module: [https://ellie-app.com/J2LgX38CSva1](https://ellie-app.com/J2LgX38CSva1) The full code is: main : Program Never MouseEvent MouseEvent main = Html.beginnerProgram { model = None , view = view , update = \newEvent _ -&gt; newEvent } type MouseEvent = None | Click Mouse.Event | ContextMenu Mouse.Event view : MouseEvent -&gt; Html MouseEvent view event = Html.p [ Mouse.onClick Click , Mouse.onContextMenu ContextMenu ] [ Html.text &lt;| toString event ]
You can handle the `mousedown` event and extract the information you need from the event object using a decoder. [Here is an Ellie with how to do it.](https://ellie-app.com/J2ScfPWRzDa1) Notice that I disabled the context menu globally with `&lt;body oncontextmenu="return false;" &gt;` in order to prevent the menu popping up on right click. 
[This minesweeper game](https://github.com/dc25/minesweeperElm) distinguishes between right clicks and left clicks. ([game demo here](https://dc25.github.io/minesweeperElm/)) . It's used for svg elements but I think it will work in general. Search the code for onRightClick, to see how it works. 
Thank you. The easy case is definitely mine, though I'm not entirely sure at this point whether I want to catch everything everywhere, or if I want to isolate things into the SVG area. Doing the latter would simplify things if I wanted to add some kind of border. `elm-pointer-events` seems like exactly what I'd want if I don't end up just keeping everything contained in a single SVG object.
I agree with this argument. It seems to me like this would create more problems than it would solve. I donâ€™t like the idea of adding more features to the language to solve problems created by other features. Something I love about Elm is its sheer simplicity. If I want Haskell or Idris or Coq, I could go use those.
Not that I _worked_ on Elm at actual _job_, but I had an experience. (i) How did it start? What was your previous stack before elm? I used GHC/stack before. Elm looked promising, and it was nearest to Haskell-like thing to translate into js. (ii) How is your effectiveness/efficiency as a programmer with elm compared to your previous tool? Mostly the lack of `where` and unability to abstract out `Functor`-`Applicative`-`Monad` chain and therefore make and use any monad transformer looked like show-stopper. But i could still code without it all. The "document everything or I won't compile it" thing diminished my speed and my mana reserves. I tend to write/test and only then cover the thing with docs, since while you writing and before release, the API can change drastically. (iii) How would you rate your satisfaction while working using the language? I'll rate it as _meh_, honestly. 1) The row types look nice, but I almost don't use that feature. 2) Lack of `where` feels bad, because I used to describe function bodies from big picture to small details, and now details precede picture. 3) `MultyWayIf` was nice till it was removed. 4) The API changed with each second (minor, I assume, major is still 0) release, which is very *not* nice. Everything from the past stopped compiling and you had to, basically, rewrite it. 5) Good night, sweet `Elm Graphics`. 6) Big thing: lack of proper ways to abstract things hinders the composition process. You can't just describe an interface and use it (you can describe record-of-functions to emulate typeclasses, but lack of higher-kinded-types will always put itself in your ways). (iv) Was the shift from imperative to functional paradigm easy or hell difficult? IFAIR, it was tedious, but I liked both the process and the result. (v) I'm also particular in implementing algorithms that can normally be written in imperative method, how did you handle them in elm? Honestly, I write them in Haskell first and then translate to Elm. I still can't think _in_ Elm. (vi) Do you still believe that elm is the future? If you fix: 1) Bus factor - Evan seems to be the single core dev I know. 2) Proper interfaces or modules/signatures - so big things can be done. 3) Higher-kinded types, unless module/sig route was done, as they can emulate those.
Wow, thank you for this very honest response. This kind of response is what I wanted to read. Would you suggest any other functional web programming language in order to improve my understanding/coding in functional way?
Are you trying to add the `disabled` attribute to one of the accepted input elements and it doesn't disable the element? What are you actually trying to do and what do you see that's not working as you expect it? 
I'm not sure what you mean with "publish/subscribe" in JS/jQuery (this could mean DOM-events or something like Rx-js, ...) can you give an example of what you want to do?
I love your experiment and I thank you so much for developing this POC, though to be honest, I'd rather focus on the an Elm-to-native integration, without using React Native. The reason is that, as a React Native dev, I've already pushed it to its limits and I don't think it would be a viable solution for a non-trivial app which requires API interaction, local storage, deeply nested navigation, modals, interactive section lists, and smooth animations. If a developer has to cope with React Native's tradeoffs *and* the Elm abstraction layer, that could become overwhelming pretty soon.
I love you both
I love you both
The *not working* tag is: a [ class "button is-outlined is-primary", disabled True ] [ text "Next" ] that generates the following html: &lt;a class="button is-outlined is-primary"&gt;Next&lt;/a&gt; The work-around is the following: a [ class "button is-outlined is-primary", attribute "disabled" "" ] [ text "Prossima" ] and the generated html is: &lt;a class="button is-outlined is-primary" disabled=""&gt;Next&lt;/a&gt;
[`disabled` is not a valid attribute for an anchor tag](https://stackoverflow.com/questions/18711317/is-disabled-a-valid-attribute-for-an-anchor-tag). [here are the tags that it can be used on](https://www.w3schools.com/tags/att_disabled.asp). Of course, you can bypass this as you had with the custom attribute but it would be simpler to just add the a `disabled` class like this: `a [ classList [("button is-outlined is-primary", True), ("disabled", True)] ] [ text "Next" ]` 
I prefer to do it on save. I just love the feeling I get when I see my code snap into the proper form. It's like a small reward for the fact that I have written something that is at leas syntactically valid. :) 
Interesting reply, thanks! I personally have 0 experience with RN, as JS makes me tired too fast to be able to do any hobby dev in it. Could you try describing some specific limitations you've run into with RN in some more detail? For example, with local storage, I imagine this is something basuc, so I expected RN has some features for it? If yes, then what particular limits or trouble did you experience with them? As to "elm to native", I have no idea how else this could work. I've only seen the elm-ios experimental project exploring the space. And the underlying mechanism it used is AFAIU similar to RN's JSON-based MessageQueue aka BatchedBridge. I'm looking at elm-expo as going in the same direction, but initially reusing Expo as a prototype native-side companion, conveniently already written by someone else ;) I imagine Expo can be forked in future if needed, I don't feel particularly tied to it. Do you see the limitations as tied to Expo/RN in particular, or more fundamentally to the underlying idea of JSON bus, common to RN and elm-ios?
Used it for a while, but unfortunately it locks in 4-space tabs, even though the official Elm Style guide uses both 2 and 4 spaces. Besides that, it's a great library- but I have to modify the source every time I update. XD
No, everything is run with commands an messages. You don't manually bind event listeners in elm. You can hack your way around if if you need something really simple like an alert. See this example: [https://ellie-app.com/Kb2d48Nmc9a1](https://ellie-app.com/Kb2d48Nmc9a1)
Can you try modifying `file1.elm` and `file2.elm` to use different module names? Elm module names should generally match their file names, e.g. `module File1 ...` in `File1.elm`. I think I've noticed issues in the past where I've copied and pasted code between files, forgot to change the module names and had things messed up as a result (pretty similarly to how you've described). So it could be there's some caching going on via module name...
The main issues, for my team, were: - the only local storage available is the AsyncStorage (key/value strings, no IndexedDB equivalent or abstraction layer) - the available navigation solutions JS based are all still quite buggy and slow, with `react-navigation` being apparently the most used one - hybrid native navigation solutions (see Wix's for instance) force you to build and maintain... two native + one JS codebases - animations are overall tricky to implement and difficult to execute at a fair fps rate, when it's not impossible - the Modal system has a few visualization bugs on Android (still being broken at any new release) and still suffers from a deadlock issue when used with Alerts which forces each team to implement and maintain ad-hoc solutions or use obscure and experimental npm packages which in turn are forked and abandoned on a monthly basis - long lists can become quickly slow and laggy, while the SectionList is apparently not in the top priorities of Facebook, thus if you need it you can either implement your own one or work around the default one I think this is more than enough for this thread, I've already gone off-topic. Don't get me wrong: it is a great framework for prototyping or for very small applications. That's it. This is why I wouldn't waste time porting Elm to RN if we can work on a stronger and more flexible solution.
Thanks! Would you be OK with me linking to your note from the Readme of my project? Also, do you have ideas how you'd imagine a stronger and more flexible solution would/should work?
**Purescript** is _said to be mostly fine_, but I did use it at all. And it is complex. You need to implement `Semiring` interface to get `+`/`*`-operators on your datatype. This is _good in some cases_ but can scare you away. Oh, and `-` in the `Ring` interface. Also, the **ReasonML**. Its closer to OCaml. Actually, it is a syntax for OCaml - it uses OCaml-to-JS compiler, Buclescript. It forces you on completely different programming style (still functional, but different than PureScript-Haskell one). The stablest language. It is supported by Big Dudes, so it won't disappear one day without a trace. There is **Closure**, but, you know, it being untyped does things not so purely-functional as I like it to do, and its a LISP with all its pros anc cons. I personally recommend you **Haskell**. It _will_ increase your understanding, provided you can withstand its abstractions - `Functor`s (any type which can `map`), `Monad`s (any type to which you can stick a callback), and so on. It is not for web in general - there exists GHCJS project, but it not of _dwarven quality_ yet and it is behind last stable GHC (Glasgow Haskell Compiler) version. If you find youself able do into Haskell, you can automatically use PureScript. It is very stable language, &gt;25 years old - but it still receives pretty neat updates with nice features with each major release. And the tooling is of decent quality.
It's ok for me to link my post here, just bear in mind that it is meant to be only an input for a discussion, I'm not ranting against React Native. I actually like it :-) About the ideas: I'm not the right person to ask to as I'm not a native developer (I came to mobile dev from the frontend via Javascript (!)). Though I see an interesting paradigm behind [Flutter](https://flutter.io) and [Xamarin](https://github.com/xamarin) where a codebase (Dart the former, C# the latter) is compiled to native code (via AOT compilation and a virtual machine in Dart's case). In Flutter's case, there's still a message-based FFI for the native integration. I don't know the details as it's not my field and I never studied it. Probably I should wait to give Flutter a try and come back to you with my findings :-) Thanks!
My study of functional programming actually started when I read the book titled â€œMostly Adequate Guide to FPâ€ by Dr. Boolean. I got really intrigued but to be honest, I struggled understanding it. Then I shifted to haskell book which, again, is very difficult for me because of math jargons. Then I came across Elm which got my full interest. I liked the language a lot because with few lines of code and simple logic, I can create a working webapp. And because of it, I did not stop reading about functional programming. My reading then led me to ramdajs. Upon looking to its documentation, I saw type signatures and some bizarre functional terms which made me remember the concepts in the first book that I read (Mostly Adequate Guide...). So my study circled back to that book and eventually to haskell. And because you give me a very good claim about the haskell language, I think I will not hesitate to learn it by heart. Thanks a lot man for your very good insight. I will not look into other functional languages anymore. I will stick to haskell. :)
I wanted to find a project that could showcase `elm-geometry` (which is amazing), so I started to play around with making a solar system. If you check out the code on https://github.com/2mol/solar-system, there is an earth/moon version, and a more advanced (in progress) one with the sun, venus, mars and earth. Everything is actually simulated in 3d, with a very naive algorithm to solve the gravity equations.
[firebase](https://firebase.google.com/)
[Postgrest](https://postgrest.org/en/v5.0/) combined with Postgres is another option. You can set them up using docker-compose and if you're just prototyping you can sign a single JWT manually and embed it in your webpage without setting up all an entire authentication process use that to authenticate. Though, if you want real-time syncing Firebase will be the better way to go.
Text files! Certainly doesn't have the security aspect covered.
what about jsonstore.io?
Very cool!
yes. this is perfect. thx
Here's Richard's elm-spa-example w/ a postgrest backend: [https://github.com/john-kelly/elm-postgrest-spa-example](https://github.com/john-kelly/elm-postgrest-spa-example) It includes auth/login. Disclaimer: I'm the author of elm-postgrest
â€¦and I think I managed to eject the moon oh, nope it came back just took a while HA! made it bounce off the earth
I have been happily using http://package.elm-lang.org/packages/ggb/numeral-elm/latest for a long time!
ok but the credibility of your experience as an indicator for others is ... underwhelming.
Looks really good! Only things I'd note having 'conditions' and 'violations' is suspicious. Especially violations, putting this allows for them to get out of sync. Violations should just be a computation based on the model. Currently, it's possible to have mis-matched passwords, and an empty list of violations.
I see what you're saying. I refactored the model to have a `showViolations : Bool` on it that gets flipped when a `Submit` message is read and `viewValidation` to be let violations = if model.showViolations then produceViolations model else [] ( message, color ) = if List.length violations &gt; 0 then ( "Errors:", "red" ) else ( "Ok", "green" ) in div [] ...
How beginner should the questions be?
Perfect!
It seems a little strange to put the validator functions in the model. They aren't something you'd generally want to change. Of course, if they are going to be dependent on some user action (I'm not sure why that would be, but perhaps), then it would make more sense. I'd probably do something like ``` validators : List (String -&gt; Bool, String) validators = [ ( \ password -&gt; String.length password &gt; 8 , "Password must contain more than 8 characters" ) -- ... ] ``` Which I would then map over.
Thanks for the feedback. Now that I'm thinking about it, I don't know why I choose to put the validators list in the model. One of the only reasons I can think for doing this would be if I abstracted the view to be resuable and let the parent provide the fields and any validators for them. 
Native modules are an undocumented internal API that is being replaced and will not be available in the next version. Is advisable to switch to a `ports` based solution. If you think that what you are trying to do is impossible to do with ports, please describe what you are trying to achieve. 
you could: ```javascript return { ctor: "CTOR" } ``` It's not documented and I don't remember off hand but I do know anything within an adt was structured as a js object with the CTOR field. 
This is awesome!
Yes, I also prefer 2 space tabs. It makes things line up a lot nicer when you stack first item on same line as open paren. ðŸ˜‹
Please see https://discourse.elm-lang.org/t/native-code-in-0-19/826
I'm new to Elm, and I heard somebody say one time that elm's compiler offers many of the same benefits as TDD. But it's nice to see some demonstration that actual testing is still a thing in this ecosystem as well. ðŸ‘ Also a good intro into the mantra behind fuzz testing, which I've only ever peripherally heard about before. ðŸ˜‹
Now I'm curious (and on mobile in holiday where it's challenging to test), but do any noteworthy browsers actually do anything with a disabled attribute on an anchor tag? ðŸ˜®
If you are interested in elm from a language perspective (as it seems you are), I suggest checking out other functional programming languages, especially Haskell. What you describe is commonly called "refinement types". There is a really interesring implementation on top of haskell: Liquid Haskell. So I suggest checking that out! Cool might later also be Idris or Coq, although those are highly theoretical and fairly hard to grasp.
I donâ€™t think you need that. Make opaque types like â€œIntBetween1and6â€ and expose only a constructor function like toIntBetween1and6 -&gt; Int -&gt; Maybe IntBetween1and6 Do your validation and construction inside.
&gt; any noteworthy browsers actually do anything with a disabled attribute on an anchor tag? Chrome, Firefox and Safari do nothing. IE11 disables the link (the link looks the same but it doesn't work anymore). 
I'm creating a web app for multiple choice quizzes. The app creates a random set of questions. The user select an answer and obtains immediate feedback. The whole set of questions (4000) is loaded at start time by flags elm feature.
It seems you might be better off using List.scanl, which will give you not only the final answer, but all intermediate ones too. Have a function that computes the next position from a given position (essentially calculateIntersection, but might be more accurately called "nextPosition"). Feed in the start of the list and your starting position, then repeat (using scanl) until you have used all your instructions. You should not have a list of positions. Intersections will occur whenever a given position appears more than once in the list. So you could have another function that, for each position in the list, counts how many times it appears subsequently. Then you can filter your list down to positions that are intersections, then the head of that list will be the first one.
Or, if you want your snake to not to grow indefinitely (or grow at a slower pace) you can change your state from Location to a List of Locations representing the grid locations where your snake is. You can update the state by calling \`nextPosition\` on the head of the List (also the head of the snake), adding this location in front of the List and removing the last element of the List (the tail of the snake). You can check for intersections by checking if the new head of the List is in the rest of it.
Similar to jsonstore, but local: https://www.npmjs.com/package/json-server
In that case I'd recommend that [u/gscacco](https://www.reddit.com/user/gscacco) do something like have elm only render the Anchor element at all when their condition is met, and when it's not met â€” instead of trying to add a disable attribute to the surrounding tag â€” just have no tag, or render a span instead optionally with CSS to make it look like it might have been a hyperlink in an alternate universe. :J
I threw together a simple math quiz app to drill my son on single-digit arithmetic problems, here: [http://lightsecond.com/Arithmetic-Drills/](http://lightsecond.com/Arithmetic-Drills/) Primary code: [http://lightsecond.com/Arithmetic-Drills/Drills.elm](http://lightsecond.com/Arithmetic-Drills/Drills.elm) Some supplimentary code: [http://lightsecond.com/elm-modules/FindRecord.elm](http://lightsecond.com/elm-modules/FindRecord.elm) Being able to pop up a dialog box was the most challenging part, I had to cheat a little bit and use a method that's not a port, but that does much the same job as a port due to my desire not to use ports (I'd rather make JS subordinate to my elm code than the other way around). But by an large everything has gone pretty well on this one. :)
you could do all that using sum-types (for the dice not to hard: `type Dice = One | Two | Three | Four | Five | Six`- for strings quite a bit more verbose as you first had to do something similar for all characters but whitespace and then use a tuple of one such non-whitespace character, a normal string and then a non-whitespace character again - so just not practical and probably slow as hell) I think it's fair to say, that Elm probably won't go the refinement types route - and to be honest I think it a good idea for a front-end language that wants to be beginner-friendly not to do it.
Is this similar to contracts in OO?
To be fair, can you imagine trying to use that strategy on an actual dice game? You would basically only be able to interact with that structure through case statements. ðŸ˜
for the dice one it's actually not too bad to write helper functions etc. - but yes for the other one it just sucks (don't do this at home) btw: just saw that I forgot the positive numbers (which is the easiest one as there is the peano encoding) but I think it's better to not mention the details at all (not really beginner friendly and it's 99% math anyway - use your favorite search engine if you want to know more)
In actual Elm programs this strategy is used for dates (and yes, it is painful). The package Date-Extra makes it much much pleasant to work with
(if check it out myself but I'm still limited to mobile for the time being) which date elements use union constructors in place of data? All of them, like day of month too? Sounds like a metric wtf of duplicated code, to me. 
Only months and days of the week are treated in this way. The rest of the validation is tied the js runtime as it will fail to create new dates from invalid strings (eg."01-111-2018"). Because of that the parsing of strings to dates are wrapped in a Result type.
This is probably the way I'd go, too. Also, I would suggest the use of a `Result String IntBetween1and6` for a better error handling, especially if the input comes from the user or a 3rd party API.
This is only possible in dependently typed functional programming languages as far as I know. For instance in Agda you could define natural numbers as this: data Nat : Set where zero : Nat suc : Nat â†’ Nat Then you could use it in functions like this: add : Nat -&gt; Nat -&gt; Nat add x y = x + y
This is great, now we can stop worrying about using an undeclared type and we can put a hook in the CI to check if the schema is always updated ! I wonder if the same tool exist for Hypermedia RESTful APIs. 
actually dependent types are little overkill. As long as one only need an upper and or lower bound it can be done with refined types. While dependent types need addition proofs in order to compile, refined types should be able to be completely comileable by a computer. that said, im no professional compiler-builder so please take my word with a grain of salt.
contracts are more generell. a contract would be "result is a prime number" while a refinement is something like "result is smaller 10". the first conditions must be checked with every result, while the second just defined an upper bound. Thats why contracts are done in run-time and refinement types in compile-time.
Contracts would be sweet to have. You could have them only only in debug builds so you can catch bugs early without adding complexity to the compiler.
no lower limit! Or upper, for that matter! But I'm about to make a new thread for this week, so maybe ask your actual question in there. :)
actually this can be done quite easy with an assert function: assert:(a-&gt;Bool)-&gt;a-&gt;a assert fun a = if (fun a) then a else log("Contract violation" (fun,a)) place an assert at the beginning of the function for a pre-condition(a requires-statement) or at the end for a post-condition(a ensures-statement)
Yeah, I question the usefulness of this as a mega-thread topic, we only had two comments last week and neither got \*voted\* on, let alone replied to. ;)
Iâ€™m gonna start learning elm. Been having to use react with typescript and find it difficult to read at times. Elm looks dope and want to give it an honest shot. 
 For about two weeks I have been working on a boulder dash game in Elm. I wanted to see if I could use the Actor-Component system from game programming in a strict and pure functional language. I exposed the components as "assets" (Just exposed them to json) which allows you to create enteties by combining and configuring components. For example the main difference between a "Pet" and an "Enemy" in this game is that a "Pet" does not have the "trigger-exploable" component. ... "enemy": [ {"type": "render", "data": {"colors": ["#ce5c00"]}}, {"type": "rigid"}, {"type": "physics", "data": {"strength": 20, "shape": "circle"}}, {"type": "ai", "data": {"type": "walkaround"}}, {"type": "explodable"}, {"type": "trigger-explodable", "data": {"triggerStrength": 20}} ], "pet": [ {"type": "render", "data": {"colors": ["#75507b", "#ad7fa8"], "ticksPerColor": 8}}, {"type": "rigid"}, {"type": "physics", "data": {"strength": 10, "shape": "circle"}}, {"type": "ai", "data": {"type": "walkaround"}}, {"type": "explodable"} ], .... The game is not finished yet and that brings us what I'm going to work on this week: - Be able to restart/succeed/fail a level -- What desides a level is succeeded or failed in a component way - Add menu's with text The game plays in a 12x12 "pixel" matrix. Therefor I can not just draw text to screen. But I will need to map letters to something readable in a 12x12 fasion. I tried to make the game in a functional/monad fassion with the result that the file that holds the actor-components only has one let-in expression while it has 1700 lines of code. The github page is here: https://github.com/JordyMoos/elm-pixel-boulder-game The demo is here: https://jordymoos.github.io/elm-pixel-boulder-game/ Please let me know if you have any feedback in any way. Like what would you have done diffent coding whise etc. Cheers! 
Maybe there needs to be some kind of incentive, or the title needs to be shortened to make it more eye-catching.
I just returned to this project, and what I was doing originally was indeed dangerous and buggy, as the app state would change during animation. /u/jediknight suggested using lottie-wc above, which actually worked out perfectly.
Thank you for this! I recently returned to this and lottie-wc works just as I would hope with Elm.
to be honest, i dont know what i should write here. im currently working on a small 2d-retro-game. And it seams like i can splitoff the graphic engine into a seperate project. the special thing about the graphic engine is that it will be 100% made with css and not with canvas or webgl. To my knowledge this would be a very unique engine and a good contribution to the game-maker community of elm. but currently i dont have anything, but a prototype and 4 weeks of spare time. so should i start to post my progress in here in this mega-thread? Or should i wait untill i have a question or a finished project? i honestly dont know what this mega-thread is for, but i do know that if im sucessful i will need help polishing the graphic engine and to put it somewhere where people can find it.
Is Elm (or functional programming in general) recommended for beginners? I'm trying to learn JS but it' so confusing. I want to create web sites, web apps and 2D games (I'm not interested in employment, just hobby).
You'd get more of an audience if you posted this meta-discussion to its own thread. That would include, for starters, people who have no use for these threads.
elm is extremely beginner friendly once you get started. you'll have a great time
Hehe, I figured I would first at least pose the challenge to whoever did. On par with "hello, anybody in here?" ðŸ˜
Looks similar to https://github.com/Janiczek/silent-teacher
is there a package that implements a pair? type alias Pair a = (a,a) and useful functions that come with it?
I have 2 quick questions: 1. What is the best way to use external css in an elm project? Specifically something like Bulma or bootstrap. 2. Should my model be a kitchen sink? I'm building basically an ecommerce app and it just feels weird to be throwing everything (user state, product data, shop meta data) into one massive model. Is that right?
I have 2 quick questions: 1. What is the best way to use external css in an elm project? Specifically something like Bulma or bootstrap. 2. Should my model be a kitchen sink? I'm building basically an ecommerce app and it just feels weird to be throwing everything (user state, product data, shop meta data) into one massive model. Is that right?
What are you looking for? It seems like a normal tuple might cover this pretty well.
 map : (a -&gt; b) -&gt; Pair a -&gt; Pair b map2 : (a -&gt; b -&gt; c) -&gt; Pair a -&gt; Pair b -&gt; Pair c are the main functions that i need.
1) for bootstrap i use rundis/elm-bootstrap, there are similar packages for bulma. 2) If you got some time you should watch https://www.youtube.com/watch?v=XpDsk374LDE (Evan Czaplicki - The life of a file) and https://www.youtube.com/watch?v=x1FU3e0sT1I (Richard Feldman - Make data structures) **for the short answer:** yes, everything that needs to be changeable should be in the model. But you can create new data strcutures and move specific functions into its own file. This way your mode could look like this: type alias model = {user:User,product:Product,shop:Shop} if a function only uses a part of the model, move it into a seperate file: addProductToCart addProductToCart ({product,shop} as model) = {model | shop = shop |&gt; Shop.add product.id} and in a seperate file module Shop expose (add) type alias Shop = { cart:List ProductId } add:ProductId -&gt; Shop -&gt; Shop add productId ({cart} as shop) = {shop|cart=productId :: cart} 
For those who have not stumbled upon the file drag-and-drop problem in the past, I considered these as the solutions: 1. Elm only. You can probably do that in Elm, but it is very hacky. You would need to install a separate package manager (elm-github-install) to use an unauthorized library that contains Javascript bindings. Library's documentation is not available on [package.elm-lang.org](http://package.elm-lang.org/) and its API is very sub-par. Eventually, I decided against it. 2. Elm with simple ports. The way I expected it to work was: I receive drag-and-drop events in Elm, store hover state in the model and reflect it in the view. As soon as the file is dropped, the whole event object is passed as a JSON value to the Javascript world via a port, where the files in `event.dataTransfer.items` are read as strings and returned back to Elm via another port. This approach did not work out because `event.dataTransfer` is inaccessible from the event received from Elm. 3. Elm with complex Javascript. The only remaining solution is putting a dropzone outside of the Elm program, handling its hover state with side-effecty functions and sending the resulting CSV string to Elm via a port. This is a messy, error-prone but working approach.
I want to create animations using css and controll them with elm. For this i used the css property "transition" that makes a smoth transition to any css chances. if i now change the "top" value of my div it works, but for my "left" value id does not. I noticed that this has to do with the way elm is rendering its content but i do not know how i could fix it.
I've had to implement select2. Both the regular styled dropdown variant and the multiselect with tags. There are pure elm implementations but they are lacking and buggy. I had to use ports, send an element selector through and use jQuery to manipulate the dom and then send the selected/unselected values back to elm through ports. It's messy and maybe it could be solved in a better way with custom elements (e.g. a `&lt;select2&gt;` element). I tried but couldn't get that to work. 
does someone know what the negation of `maybeString == Nothing` is? Strangely i can't pattern mach, so (maybeString == Just \_) does not work.
I'm using the elm bootstrap library and wanted to put a form in a modal. Well for some reason as of now, bootstrap modals in elm can't scroll. So I'm limiting my form size to what would fit in a medium-sized window :P There's an issue out there for it. Secondly, I have a bit of routing/navigation going on and my current issue is that if I'm scrolled partway down on the first page and navigate to a second, the scroll will be at the same position. Like I need to *tell* elm to scroll to top upon navigation :(
I'm not 100% sure, but one more alternative might be possible: IIUC, I've read somewhere that you can add javascript event handlers in Elm nodes, by embedding raw javascript code as a string in Elm `Attribute`. This way you could maybe write just the "onDrop" (or whatever the name) handler in JS. The handler would extract the `event.dataTransfer` in JS and pass it via ports to Elm. I think it's also considered more or less a hack, but I think still cleaner than (1) and safer + better maintainable than (3).
Based on your edit, if it's really the case, and you still don't know how to fix it, I suggest having a look at [Html.Keyed](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Keyed). AFAIK, it exists exactly for marking some nodes as distinct for the Elm DOM diffing algorithm.
It's probably not the point of the discussion, but in case it helps, your solution 2 actually works. You can have a look at [this Ellie example](https://ellie-app.com/Pv4h6mphLma1) where I'm using some of the functions from my [elm-pointer-events](http://package.elm-lang.org/packages/mpizenberg/elm-pointer-events/2.0.1/Drag) lib to ease the work. For display reasons, I only extract "meta" data of the file in the Ellie, but you get the full file and could send it as a JS \`Value\` through a port. The difference is that I retrieve the file value in the event and not just the whole event (which is not accessible later due to async events handling in Elm 0.18).
This. There's no great way to have UI elements that manage their own state without some complex routing through through Msg and update. 
(not maybeString == Nothing) ?
Don't do that. You'll hate your guts. This is what you do. Run your animations as expected. Then, when animations are finished, turn all transitions off, and rearrange the DOM to match its new state. Then turn transitions back on. I know this from experience. I'll have a blog post about it eventually. I assume it's not an issue specific to Elm, but to virtual DOM.
Html.Keyed won't do the trick. I've tried it for this very same situation.
Convincing people to use it at my job.
It's funny that Elm is so strict and pedantic about ease of use and no runtime errorsâ„¢, yet to use anything Evan hasn't written a library for, you have to write JS in attributes or use experimental web components, effectively removing any of the guarantees Elm gives you.
**It WORKS!** I already had implemented unique identifyers for all divs with transitions, so this worked beautifully. Also as a side-node: i move all divs with transitions into a seperate Keyed div.
Good lord, it actually worked! `mpizenberg/elm-pointer-events` was exactly what I was looking for, it worked wonderfully. Thank you so much, this problem would not have been solved this gracefully without your help. It really just took 2 simple ports (one to send files to Javascript and another to feed the contents of the files back to Elm).
Yeah. Nevertheless, I don't think it entirely defeats the purpose of Elm. Elm is a masterpiece. I only hope to see it grow strong enough to cover the best parts of the Web platform one day.
It's so different which definitely puts people off
Theoretically, custom elements allows for "hidden" state. Unfortunately, custom element support is a bit lacking, but it should work in Chrome at least.
`maybeString /= Nothing` :)
LocalStorage is very easy, but I would like to use without ports :D
Why not just make it a monthly thread, not weekly? The community is not big and active enough to warrant a weekly thread.
...and most of the fronted devs are just lazy as hell
I created a small pixel-Roguelike-Game. During that process i extracted the graphic Engine into its own project and now i have a graphic engine with an example game ;) The game can be found here: [https://orasund.github.io/pixelEngine/](https://orasund.github.io/pixelEngine/) (saidly i don't have the time right now to create a tutorial, so i hope its still fun without.) the core idea of the gaphic engine was to not use a continous loop but to only chance the graphics whenever the model chances. This ment i needed to rethink how to create animations. All animations are done using only css,same as smooth transitions between states (moving the player). For now this is all i have time for, but the idea is to someday in the near future publish the engine to elm-package. 
As a fellow novice I would recommend you to learn basics of JS first for the following reasons: \- First, some things that are easy with Javascript are more difficult with Elm. For example, integrating common Javascript libraries or making API calls requires quite a bit more understanding with Elm than with Javascript. This isn't due to Elm being badly designed or anything, it' just needed to preserve the high reliability and lack of runtime errors that Elm offers. \- After you've done something with a bit of complexity with JS you'll be able to understand the value of Elm, it's type system and lack of runtime errors much better. \- Eventually Elm compiles to Javascript, and IMO that alone is a good reason to understand that side too. 
That may be a step in the right direction. Alternately, since volume is so low would it be so bad for people to post about what they're working on as a separate post? When/Where was the discussion that this ought to be put into a megathread? I'd bet that if they used to be posts and that caused problems, we could read about what those problems even were there. :J
https://refinement-types.org This is a link in the end of a really talk I just watched: https://www.youtube.com/watch?v=F2tYCxb30WU This talk is quite understandable for anyone with elm knowledge and some haskell syntax knowledge.
I agree with you but what are 'basics of JS' ? I was advised to start with Elm because 'after few weeks you will start making apps which would take months in Javascript'. Then Jessica Kerr in one of her lectures said 'you need to know VERY LITTLE of Javascript to start with Elm'.
With basics of JS I mean enough knowledge to do something you find fun and interesting, like basic web apps and games. Then you could try doing similar stuff with Elm. At least for me making small apps with Elm takes more time than with JS, though of course that might change once I get more used to the language. I think the real benefits and time saving starts to happen once your app grows more complex and difficult to maintain, then you're likely to spend much less time debugging with Elm in comparison to JS. 
Javascript will be replaced with WebAssembly one day ;-) And Elm is WA-ready.
It's nice to hear about such opportunities, I'm from Argentina and if this was a Remote job it would be a great chance to work with Elm.
For me, the post you've just written is exactly a kind of thing I'd expect to read here :) For me, it is interesting and inspiring to read about what others are doing. You can have a look at a similar thread in r/rust, it's much more active so more examples there of how it can look like.
I am sorry, I wish it was on remote.If I come along any remote ELM positions I will be posting it on here :)
No problem, I'm currently employed full time, I would love to get involved in some Elm magic job, at least part time. I just happy to see positions on Spanish speaking countries. 
Your usage is non-standard just FYI. Refinement types can be any predicate, so long as it is statically verifiable.
Thx. Thats good to know.
How do I decode a json, where I only care about one nested object? eg: `{` `"name" : "Bob",` `"age" : 20,` `"pets" : [` `{` `"petname" : "Denise",` `"animal" : "Goldfish"` `},` `{` `"petname" : "Jackson",` `"animal" : "Cat"` `}` `]` `}` I don't care about name or age, I just want to decode the "pets" into an array of records
how about something like this? type alias Pet = { name : String, animal : String } petDecoder = Json.Decode.map2 Pet Json.Decode.string Json.Decode.string rootDecoder = Json.Decode.field "pets" (Json.Decode.list petDecoder)
You'll need some field decoders in that `petDecoder`, right?
Here is an example of how to do that; https://ellie-app.com/RSNY4Vw8yYa1 or with the Json.Decode.Pipeline package; https://ellie-app.com/RT2mFzBnqGa1 
Thank you!
How can I "pretty print" a string in the repl so that all newline characters are printed as a new line? Eg if I type this in the repl myStr = "a\nb" myStr How can I get the output to be a b Thanks!
Glad you're finding `elm-geometry` useful! Apologies for the late reply, I meant to look at your code when this was first posted but got distracted and just remembered now. Just a couple minor questions/comments from looking through the code - will `center` always be the point (0,0)? If so it may be simpler to leave it out of the record and just use the `Point2d.origin` constant instead. I also think I would be tempted to modify the `euler` function a bit to improve performance; right now you're constructing a tuple with the updated position coordinates, immediately destructuring that tuple into three `Float` values, then constructing a new tuple from those three `Float` values to pass to `Point3d.fromCoordinates`. In this case, especially since you're not using the coordinates for anything else, I would rewrite this to euler : Float -&gt; ( Body, Body ) -&gt; Body euler dt ( fixedBody, movingBody ) = let ( x, y, z ) = Point3d.coordinates movingBody.position ( u, v, w ) = Vector3d.components movingBody.velocity quot = dt * constG * fixedBody.mass / (x ^ 2 + y ^ 2 + z ^ 2) ^ (3 / 2) updatedPosition = Point3d.fromCoordinates ( x + u * dt , y + v * dt , z + w * dt ) updatedVelocity = Vector3d.fromComponents ( u - x * quot , v - y * quot , w - z * quot ) in { movingBody | position = updatedPosition , velocity = updatedVelocity } This should reduce the number of object allocations made in each call to `euler`, which is always a big help for performance! 
You could use `Cmd.batch` to batch a bunch of tasks together, but you'll still have to handle each response individually instead of in a single return. update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of SendThing -&gt; ( model , Cmd.batch [ Task.perform HandleTask1 task1 , Task.perform HandleTask2 task2 ] ) HandleTask1 x -&gt; ( model, Cmd.none ) HandleTask2 x -&gt; ( model, Cmd.none ) 
Is there some sort of limitation of elm preventing something like promise.all?
What do you do if one fails and the other succeeds?
In Promise.all this case considered as failure. So basically the error handler should be executed 
You can send a message to a JavaScript function through ports, which uses fetch and Promise.all to make the request and return the results. Yes, the fact that this is not easy to do in Elm proper is a problem with Elm.
It is possible to do something similar to `Promise.all` where you gather all the responses from several tasks. You just have to map the tasks into a single task like below. ```elm type Msg = Loaded (String, String) update msg model = case msg of SendThing -&gt; ( model , Task.perform Loaded &lt;| Task.map2 (,) task1 task2 ) Loaded (responseOne, responseTwo) -&gt; ( model, Cmd.none ) ```
Does this execute the tasks in parallel?
Yes, this executes in parallel.
Can anyone point me to a place to give me an in-depth look at Http.send and commands. I'm not 100% sure how it's working from the example in the tutorial. The signature for Http.send is `Http.send : (Result Error value -&gt; msg) -&gt; Http.Request value -&gt; Cmd msg` My understanding here is When Http.Request is resolved the value is passed into the Result and then a message is sent to update with that value. Am I on the right track here or am I far off? Thanks in advance for any help
It's a good question. My intuition is that it's not possible because it introduces nondeterminism - the results to be collected into the list come back at different times on different runs. There isn't a way inside of Elm, a pure language, to deal with this. At least, I don't see it. Correct me if I'm wrong. There could *perhaps* be some support added to the runtime like `sendBatch : ((List (Result Error a)) -&gt; msg) -&gt; List (Http.Request a) -&gt; Cmd msg`, which could collect the xhr results before feeding them back into the update as a list. But practically speaking I'd say either (1) use ports and fetch/Promise.all on the js side, or (2) `Cmd.batch` and include an index with your results to update state accordingly, e.g.: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of BatchSend -&gt; ( model , Cmd.batch &lt;| attemptIndexed HandleWithIndex someTasks ) HandleWithIndex (Ok ( i, result )) -&gt; ( { model | results = model.results |&gt; Result.map (Array.set i result) } -- note Array instead of List , Cmd.none ) HandleWithIndex (Err error) -&gt; ( { model | results = (Err error) } , Cmd.none ) attemptIndexed : (Result e ( Int, a ) -&gt; msg) -&gt; List (Task e a) -&gt; List (Cmd msg) attemptIndexed tag tasks = tasks |&gt; List.indexedMap (\i t -&gt; t |&gt; Task.map (\r -&gt; ( i, r )) |&gt; Task.attempt tag ) 
Wow, TIL! I really thought the Task.mapN functions ran in parallel. Oh well.
Yes, you're on the right track. Also, if the request fails, the `Result` value will carry an error instead. You could look here for more information: http://elmprogramming.com/http-requests-get.html
Elm has by design no build-in print function. I dont know exactly what you mean with repl, but i would guess you can find an package that does this for you. 
Haskell is a pure functional language. In the repl `"a\nb"` will print as `"a\nb"` but `putStrLn "a\nb"` will print as a b I just think its the way the elm repl handles newlines. I sometimes have some big json objects decoded from an elm record that I'd like to see in the repl.
Oh, that's great, thanks! I didn't know that those tuples would be extra allocations, but it makes sense. It would be fun to benchmark the difference. &gt; Just a couple minor questions/comments from looking through the code - will center always be the point (0,0)? If so it may be simpler to leave it out of the record and just use the Point2d.origin constant instead. The center will be dynamic at some point. I have some plans to make this into a more full-fledged solar system simulation (see the other module `SolarSystem.elm`), maybe even a little game or something educational. I have a hope that for converting between frames of reference, `elm-geometry` will help keep the math kinda clean.
Elm definitely has overhead that you will spend time working around or removing in a realtime, high FPS game. It all depends on what you're building. For example, I've built a 2D spaceship scroller by using Elm at the core for game logic and then sending state updates over ports to be rendered via Pixi.js which was nice. 
i guess one hack would be to apply your own fn that escape control characters like \n to \\n.
Agreed. I love just writing the code I want, saving, and letting the computer doing the work for me. Manually changing indentation is something I never want to do again in any language.
remove `.post__audio { height: 23px; }`
I canâ€™t remember why thatâ€™s there. Iâ€™m updating the site with gatsby v2 soon. Iâ€™ll get that fix in. Thanks. 
Will //n print a new line in the repl?
For the following code im using elm-css as Css: unitToLength : SupportedUnit -&gt; Float -&gt; Css.ExplicitLength units unitToLength unit = case unit of Px -&gt; Css.px Cm -&gt; Css.cm Mm -&gt; Css.mm In -&gt; Css.inches Pc -&gt; Css.pc Pt -&gt; Css.pt so the idea behind the function might be quite obvious: give a Unit and a length, return a length that can be recorgniced with elm-css. But saidly this code is not compilable: while the result will be of type *LengthOrAuto*, the individual braches have different types for *units*. So my question is: how can i fix this?
/u/rtfeldman has some opinions on this that are also worth reading.
Indeed; I linked his talk "Scaling Elm Apps" in my post.
Thanks; I saw that after I posted, but left my post in case he wanted to chime in, or other people wanted to go looking.
Will Elm be able to have new features if its compilation target changes? Or will it be only something invisible instead (speed of execution, package size, etc.)?
Doesn't this kind of defeat the point of elm?
I'm not a web assembly expert at all, but from what I've read it's a long ways away and performance gains mostly wouldn't be something we notice. Most performance costs come from repainting the DOM and web assembly doesn't help much with that. Areas where WA could help is stuff like "Take this list of 10 million records and sort them by this complex sorting logic". Stuff that most of us don't deal with on the daily, but is a big deal for scientific calculations, charting etc. There was a post on here some time ago that talked about how Web Assembly isn't really that much faster for 99% of the stuff frontend developers do.
Oh, thanks so much. That was really comprehensive :)
&gt; There was a post on here some time ago that talked about how Web Assembly isn't really that much faster for 99% of the stuff frontend developers do. It's more compact though, so the download is faster.
It only stores the difference. It's called [persistent data structures](https://en.wikipedia.org/wiki/Persistent_data_structure).
**Persistent data structure** In computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure. The term was introduced in Driscoll, Sarnak, Sleator, and Tarjans' 1986 article . A data structure is partially persistent if all versions can be accessed but only the newest version can be modified. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elm/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I think that the main selling point of wasm is that you can write fast code for things like data manipulation, and reuse code in any lib that has codegen for wasm (e.g. C, rust)
Not necessarily, cause you'd need to include a runtime. For instance, web assembly has no support for closures. So if Elm were to compile to wasm, it would have to figure out how to do that, and hope that it would be smaller than `() =&gt; body`.
Elm would suddenly get 64-bit integers, instead of 53-bit integers that javascript supports. Other than that... Mostly invisible things.
This is exactly the answer I was hoping to get. Thanks :)
How?
Awesome, thank you!
Well. You could use it to write smart contracts for the ethereum blockchain. One of the ethereum node software you can run is called Parity, and they're working on being able to run WebAssembly programs on the EVM as an option. https://wiki.parity.io/WebAssembly-Home.html That way, any language that can compile into WebAssembly can be used to write smart contracts. The current language to compile into EVM is called Solidity, and for various reasons, it kinda sucks. Toolchains are immature, so it's hard to reason about state. And if the program decides it's in a weird state, it'll revert, and the entire state of the contract reverts to what it was in the beginning of the initial call. However, it won't tell you which line it reverted on, and what the error was. Only that the state reverted. Being able to program in Elm would not only make a large class bugs go away, but also makes it easier to reason about state.
Looks handy! From a brief read of the docs, it looks like this library implements something like a Lense for accessing and transforming elements of nested data structures. It doesn't actually go any mutation or in-place updates right? If so, it might be better to avoid describing it in terms of mutable data, as it can give the wrong impression.
How it is better than monocle? Example https://toast.al/posts/code/2016-10-30-crocodiles-and-alligators.html
You can do this with Elm quite easily in the JS entry point to your app: * first, create an iframe element ``` const iframe = document.createElement("iframe"); document.body.appendChild(iframe); ``` * then, create a container element for your Elm app inside the iframe and embed the app in it: ``` const container = iframe.contentDocument.createElement("div"); Main.embed(container); ``` * on iframe load (I found that you have to do this because in Firefox, because the iframe's content gets cleared out when on load), append the container into the iframe: ``` iframe.onload = () = { iframe.contentDocument.body.appendChild(container); }; ``` That should be enough to get you started. If you're using any events (such as mouse or keyboard events), you'll also need to add listeners to your iframe body and re-create these and dispatch them onto the parent's document body. As a note about polyfills, if you're using Babel, don't use babel-polyfill, because this one modifies globals. What you want to use instead is [transform-runtime plugin](https://babeljs.io/docs/en/babel-plugin-transform-runtime/), which transforms your code for compatibility.
I think it's just that front-end devs typically only know Javascript. They will learn new libraries or CSS abstractions, but picking up a whole new language is a scary thing for someone who's only familiar with one.
To tell the truth, I've thought that "Hmm... this data type is similar to the Lens...", but finally decide to release as an independent library. There are three reasons why I developed this library. First, this is not completely the same structure with Lens. `Reference this root` can be rewrite by following definition. ``` type alias Reference this root == ( this, Lens this root ) ``` The main target usage of this library is updating list value when some events are fired on sub view as example app in the library docment. So, it is important to hold current value (`this`) itself in the data type. Second, it is recommended to target a concrete use case as [Designing APIs of elm-package](https://github.com/elm-lang/elm-package#designing-apis) says. It means `elm-reference` should be published as an independent library to handle concrete use case described above. Third, the `Reference.List.unwrap` function is so powerfull for such a usage but not so easy for end users to implement by themselves. It is worth publishing `elm-reference` to provide `Reference.List.unwrap`. 
Thanks for helpful feedbacks! &gt; It doesn't actually go any mutation or in-place updates right? That's right. It only makes it possible to handle data *like* mutable languages, but does not actualy do any mutation. (I commented the relation between `elm-reference` and Lens as a [reply comment to rofrol](https://www.reddit.com/r/elm/comments/92sh6v/ann_elmreference_an_elm_library_to_handle/e3a1a3t/).) &gt; it might be better to avoid describing it in terms of mutable data, as it can give the wrong impression. You have a point. Can I pick your brains to improve document? Any PRs are welcome. 
Your introduction example can easily be solved by using a Dict instead of a List: https://ellie-app.com/VfySD2Zc6Va1 I've yet to go over your tree example; but i get the feeling, your package is actually trying to solve a problem that does not exist.
I was having a hard time understanding the scope of the library, but apparently according to other comments it doesn't actually mutate in place.
Wow, awesome answer. I'll have to try this! 
I ALWAYS end up using ports for push state SPA navigation. Its so much easier especially if you've made an app according to elm-spa-example
Thanks for taking your time to reading document and survey related works. It's super helpful to improve library. &gt; Your introduction example can easily be solved by using a Dict instead of a List: That's right! I'm interesting how you can do with `Dict` over tree example. (Or is it your conclusion to use Zipper instead of `Dict`?) &gt; is there something that your package does better as the other ones? In fact, I've created this library to use part of applications people tend to use Zipper. In Japanese Elm community, some people were trying to implement [Vue tree view example](https://vuejs.org/v2/examples/tree-view.html) in Elm. Their conclusion was to use Zipper (and my thought was same at first), but Zipper is not exactly for the purpose of updating an element by View events. I guess it's not so easy question "How to resolve Vue tree view example in Elm using Zipper?". In that point of view, `elm-reference` is more suitable to handle such problems. (Of course, you should use Zipper if an application requires tree navigation feature.) From another point of view, `elm-reference` is one of the abstruction of tree Zipper. The Zipper is specialized version of `Reference` (`type alias Zipper a = Reference a (Tree a)`). It means `elm-reference` can handle any structures in addition to Tree. One example Zipper cannot handle is strange Tree structure such as `type BiTree = Node (List BiTree) (List BiTree)`. Another example that is possible because `Reference this root` has independent type `this` and `root` is [UpDown example](https://github.com/arowM/elm-reference/blob/master/example/src/UpDown.elm) I've added now. 
Are there any general patterns for generating Union types with data coming back from a server? I assume you could get the data back, say a list of \*\*Characters\*\* and map that to a function that checks the discriminating field and runs it through the appropriate constructor but a follow up question would be to ask if that's an anti-pattern.
This is what we use for parallelizing tasks: parallel : (Result x a -&gt; msg) -&gt; List (Task x a) -&gt; Cmd msg parallel tagger = List.map (Task.attempt tagger) &gt;&gt; Cmd.batch 
But then you can't take the results of those tasks and do something without sending a bunch of `Msg`s into your app. Lets say I wanted to get details of 10 customers, each having a `/customer/:id` endpoint. We need a `Task.All : List (Task x a) -&gt; Task x (List a)` to handle this elegantly.
I totally agree, it's a shame we have to got through \`update\` for processing each \`Msg\` individually, though that's the only way we have atm, and it works. Though +1 for having a decent \`Task.parallel\` impl. available in core. 
I have a bit of a general question. I haven't looked at Elm in at least 2 years (might be more, I'm not sure if I remember right). Back then I decided to not use Elm because of several pain points. I was wondering if anything changed since then. These are the problem areas: - Is JSON deconding easy or at least [easier than this](https://medium.com/@eeue56/json-decoding-in-elm-is-still-difficult-cad2d1fb39ae) these days? - Is JS interport easier than it used to be? Last time I tried out Elm there were Ports, which sort of work but are pretty cumbersome, and then there was an unofficial undocumented API for calling JS directly with manual checking. Are these days ports easier? Whatever happened to the unofficial API? - A quick look at r/elm suggest there's no wasm support. Is it comming? Thanks. 
I think you're looking for \[Json.Decode.oneOf\]([http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#oneOf](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#oneOf)).
Most of these are pretty much unchanged. * JSON decoding stayed the same. * JS interop is the same, ports are unchanged and the way to go. The 'unofficial undocumented API' is going away in the next version and it's very much discouraged to make use of this.. But [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements) are a nice way to replace most of the use cases for native code, see [this](https://www.youtube.com/watch?v=tyFe9Pw6TVE). * There is a lot of interest for wasm, but I don't think there are any official efforts yet. But it's probably coming! 
Take a look at Json.Decode.andThen.
Ok, I guess most of that is an "oh well" to me. Thanks for the info.
Thanks, I'll take a look at that!
I appreciate the response, I'll take a look at this.
I realize it would've been a lot simpler if I was using ubuntu LTS and unthinkingly bought into installing the npm package.. but to let me take a second to step back and try to relay my thoughts for why this feels so unreasonable: * Using npm as a method for distributing a tarball with some statically compiled binaries + shims feels really dirty. The project has nothing to do with node or serverside javascript, so why bother maintaining a misleading npm package? * Why wouldn't Elm maintain their software in the repositories for the language that it's written in? It seems like such an obvious decision that the elm-* packages should live in hackage. * Bonus: If Elm were thought more of as a haskell app, and maintained in hackage, a CI check could've easily caught this build failure, and the cabal maintainer could've fixed the deps. * Bonus 2: If Elm were maintained in hackage, dh-haskell and cabal-rpm could be used to provide real distribution specific packages, rather than trying to re-invent the role of a binary package manager in npm.
I suggest you watch the linked video. The point of Elm is to get JS devs a really great front-end experience, hence the focus on npm (which is used for both client side and server-side JS libraries). Elm on Hackage would not support this goal.
people said a lot about elm/npm (personally don't care) but for the Haskell part I suspect that `elm-plattform` is not the one where the development is happening (did not find it but we probably should not find it(?) - so that might be the reason why it's not on Hackage too)
[https://github.com/isRuslan/awesome-elm](https://github.com/isRuslan/awesome-elm) [https://github.com/atomicits/awesome-elm](https://github.com/atomicits/awesome-elm)
These don't seem to be maintained anymore unfortunately.
From looking at the console error message/stack trace, it looks like the problem is actually in the Elm syntax highlighting package you're using - it looks like it's hitting some very deep recursion while trying to parse the Elm code that you're displaying. I suspect if you temporarily disable syntax highlighting, or see if there's a different way it could be done, then it might work...and maybe take the raw string of Elm code that causes the crash and submit it as a bug report to the parsing package!
Thanks for the suggestion, I didn't know about Decode.lazy. I've added it, but it didn't seem to help. [ianmackenzie](https://www.reddit.com/user/ianmackenzie) suggested that it may be unrelated, and after commenting out the code that follows the decoding, it works just fine. Looks like I jumped the gun by blaming decoders.
Oh I linked my dev environment, facepalm. Thanks I edited the post.
Looks like you're right, thanks for your help. May I ask how you came to this conclusion by looking at the stack trace? All I can see is Arity related calls (A2 etc). I will dig a bit deeper to see if I can pinpoint what triggers it, and then submit a report. Thanks again for your help!
In my init cmd, I need to make two HTTP requests to setup the page, but I'm a bit confused about how to do it. It's easy to handle one like this: initialCmd : Cmd Msg initialCmd = itemDecoder |&gt; Http.get itemEndpoint |&gt; Http.send LoadItem What sort of options are available for kicking off the second one immediately after? Should I make a special message `LoadFirstItem` that returns another message to start the second request? Is there something else that's considered idiomatic?
I've sent you some screenshots in Slack of the errors I see in my Chrome and Firefox consoles, with a couple comments - hope that helps!
&gt;The supplied binaries don't even run on modern debian. If you would like to report a bug with any of Elm's installers, the way to do that is to open an issue on [https://github.com/elm-lang/elm-platform](https://github.com/elm-lang/elm-platform) with an [SSCCE](http://sscce.org/). &gt;How is there such an active community of users around a piece of software that is visibly rotting? A big part of the reason we have such an active community is that we put a strong emphasis on treating each other with kindness. Many volunteers spend a lot of their free time working on Elm and then giving away the results of that work at no charge. Describing their efforts as "visibly rotting" is not an acceptable way to participate on /r/elm. This thread has been locked and removed from the front page. Some folks have linked to explanations for what Elm's priorities are. Working on making the compiler easier to build from source is not among them. You may believe that Elm should have different priorities, but [this is not constructive input, and posts like this take an unacceptable toll on community members](https://discourse.elm-lang.org/t/what-is-constructive-input/977).
im looking for a way to get the current time of the client without knowing the timezone. something like new Date() in javascript
I've built an app with this [Elm - Material Design UI library.](https://aforemny.github.io/elm-mdc/). The app is responsive desktop, tablet, and mobile app so it's similar to what you are asking.
Just a note to OP that the previous version "Material design light" has not been abandoned by the creators. You want "Material design components".
See [here](https://www.reddit.com/r/elm/comments/7713wm/elm_ui_libs/) for a great summary of all the UI libraries in elm so far. This should be in the sidebar or wiki I think.
You probably want [`Time.now`](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Time#now), which will give you a `Task` that gets the current time. You'd use it like this: type Msg = GetTime | GotTime Time update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of GetTime -&gt; ( model, Task.perform GotTime Time.now ) GotTime time -&gt; -- do whatever you need with the time
What's the best way to integrate with [Facebook Login](https://developers.facebook.com/docs/facebook-login/web) and other OAuth providers? I tried wrapping Facebook's SDK in a JavaScript that interacts with the Elm app via a port. Is there an all-Elm option for this or having a separate JavaScript wrapper + port is the best / recommended way? All search results and GitHub examples use the old Signal API. Thanks in advance!
Do you all use Debug.log for logging api errors to the console (even in production)? Or is there a better way?
What other language would you recommend to complement Elm?
Have you finished the book? &gt; The treatment is as nontechnical as possible, and it assumes no prior knowledge of mathematics or functional programming. Does this part in the description holds true all throughout the book? 
Yeah. Each section of the book assumes you learned everything in the previous section pretty well, but it doesn't start introducing extra concepts that you haven't already covered. You definitely need to work through the book with a pencil and paper and do the excercises--if you skim through it, you'll quickly get to a section you don't understand.
[This overview](http://alexott.net/en/fp/books/) has a lot of great resources. The list starts with SICP and that book is one of the greatest resources that you will ever find. Rich Hickey's talks were also a great resource for me. The main challenge ahead of a JS dev is to switch from an imperative way of thinking about problems to a declarative way. 
Nice! Thanks for the recommendation :D
I would say a language that can handle effects (like IO) in a functional way. Right now I think the best contenders are Haskell and functional Scala. If you're familiar with Java, Scala will soon feel like home, but sadly you're also allowed to do ugly imperative things in Scala, which might be tempting if you don't yet know how to solve it in a functional way. I think [this video](https://www.youtube.com/watch?&amp;v=sxudIMiOo68) is great to get key functional concepts. It goes from a small non-functional imperative program and gradually makes it FP in as much as the application as possible.
There is always a need for testing, no matter what language you use. The Elm compiler will catch many errors that JS won't catch, however you'd still need to test to see if your code actually does what you want it to do (even if there likely won't be any runtime errors). We have tools like [elm test](https://github.com/elm-community/elm-test) for this.
In a sense yes and no. In elm you wont have to test anything that would be a type error. But you still have to test your business logic, your algorithmic correctness. However because its so quick and simple to define new types you can model many more thing with types, making some of your business logic errors type errors. (less tests) I think one of the particular strengths is that type can define APIs very succinctly, which is rather helpful when multiple people work on a code base and need each others code. It makes it easier for them to use other peoples code correctly. Another strong suite I believe is the encoding/decoding of data. In elm you have to decode JSON for instance, meaning you'll see immediately if your passing an Object instead of an Array somewhere for instance, or a missing key in an Object. As a result such errors never propagate into the system.
What helped me coming from a similar place was to first look at resources that were written in a language you know (js). Take a look at ramda.js, get a feel for currying, and what functions like map, ap, and commute would be useful for. Try using them in a project. Take a look at their implementations. Also, especially (but not only) if you are planning to learn Elm, take a look at js implementations of the Elm Architecture. I think there are several of them out there now. At the same time, the resources written in js are a bit thin, or veer off in idiosyncratic directions. Not to say they aren't useful in some ways. But it also helps to grasp the practical motivations for using FP concepts, and for that it may help to look outside the js world. Two books that helped me were Learn You a Haskell and Functional Programming in Scala. Neither book is focused on the language, but in teaching the concepts from a practical (not theoretical) perspective. You could work through either and try to reimplement the problems in js or typescript.
Tests are overrated.
I've noticed the following pattern over the last two years where I slowly introduced Elm more and more into my projects (Now I pick Elm 80/90% of the time where I'd go for React before). \*\*Getting something on the page\*\* It's actually faster to get something up on the page now. You'll usually hear the contrary, but this past week i decided to set up a project with Typescript, Redux, Sagas and Firebase as the backend. Holy crap that's a lot of pieces that have to be configured and an unbearable amount of boilerpate code... I spent almost 3 days getting everything to work properly, with many refactors during that process, because I wasn't happy with how things were connected. With Elm you just configure webpack to load ".elm" files and you're off to the races. \*\*Refactoring\*\* SO much faster and SO much more pleasant. You can re-arrange half of your entire data model, commit the changes, go home for the night and start off right where you left off the next day. With JS I would be very paranoid doing those things because you have to keep track of all the consequences of such a refactor in your head. TypeScript helps a little, but because it's not type safe like the compiler in Elm, you have no guarantees. \*\*Testing\*\* Depends largely on what you're building. Let's say you doing a calculator app. Then, of course, you still have to test that clicking the division button actually divides two numbers, but a lot of my tests in JS used to be testing for types, mocking server responses and simply trying to figure out how to test functions with side effects. Those are all gone in Elm so I'd say you save a lot of time writing tests. In short, I'd say most aspects are faster in Elm for me now. The time consuming parts are the things where I could hack my way around certain problems before or where there are NPM modules for things that elm doesn't have yet. E.g. Select2
Debug.log is certainly the easiest way to get stuff into the browser console. The problem is that putting messages in the browser console isn't particularly helpful in production, you want the frontend to notify you when there's an unexpected error. There are quite a few services for this (or you could create your own). I believe NoRedInk uses Rollbar. They've got an Elm library for interfacing with Rollbar on their Github org
I would say â€˜at leastâ€™ write it to the Console. But one better would be to interface with an error service yes :) Thanks
Lol that game is ridiculous. You should be able to make that game in Elm no problem. I personally think Elm is simpler (more focused) than React actually and as a result like it more.
Lol, what a ridiculous and fun game! That's super cool you made that, I'm sure you'd be able to use Elm. Elm is quite the fun language as well!
If it is to learn, why not? If you have never experienced fp, elm is one of the best way to dive into fp for the first time.
Oh really. Thank you. I have seen a lot of people talking about how awesome the error messages in Elm are. Will definitely try out the language.
Glad you like it, had a lot of fun developing it as well. I will check out Elm for sure! Do you have tips on where to start? Any specific tutorials I should check out? I learned React using CodeAcademy. 
I think Elm as a language is great for beginners as it is so small and simple but keep in mind that you will need to interop with JavaScript at some point (via ports or WebComponents) - so you'll eventually have to dable in JS whether you like it or not.
Use [sample](http://package.elm-lang.org/packages/mgold/elm-random-pcg/5.0.2/Random-Pcg#sample) (or [this](http://package.elm-lang.org/packages/elm-community/random-extra/2.0.0/Random-Extra#sample) if you use the core random library). But if you're new to random generators in elm, I'd recommend to first get familiar with them, it can be quite hard to grasp how randomness works in a purely functional world. Unfortunately I don't know of any good resources for learning, but maybe someone else can provide some good links.
For me I learned from elm-lang, and when I got stuck the beginner slack channel was a lifesaver. Also feel free to message me if you ever want, I super love Elm and I'm always up for a bit of Elming ;)
Glad I could be useful. Yup, seems about right
If you consider the main value of unit tests as preventing regression errors and thus enabling you to refactor fearlessly, 99% of that need is satisfied by Elm's compiler without the need for tests. Also, amen to everything else that /u/ElectricOrangeJuice said. 
Make sure you have an "in" block after the let. Example: onUpdate : Model -&gt; Result Http.Error Todo -&gt; ( Model, Cmd Msg ) onUpdate model res = let \_ = Debug.log "onupdate" res --- &lt;&lt;&lt; need to have an in block below for the debug log to execute. in case res of Ok todo -&gt; \-- loops through all todos and replaces the one with id with the updated. let updateTodos t = if [t.id](https://t.id) == [todo.id](https://todo.id) then todo else t in { model | todos = RemoteData.map (\\l -&gt; List.map updateTodos l) model.todos } ! \[\] Err error -&gt; \-- TODO! model ! \[\]
That was basically the problem. I was compiling to one JS file but actually referencing a different one. Crazy mistake. Thanks, and sorry for the inconvenience.
The Elm docs are helpful, but I found that they weren't enough. Manning has an early-access ebook on Elm available that closed many gaps for me on the way to writing my first application. Otherwise, people on this forum have been friendly and helpful in the questions thread.
Oh, I thought I didn't need Javascript at all by choosing Elm. Clearly I have misunderstood, haha! I will check it out for sure, thanks!
Wow, I never thought of diving into the source code for specific libraries since I'm still new to JS. Thank you very much for the fresh ideas. :D
Unit tests are always incomplete: they only test a particular set of inputs. Even with fuzzers, you only get a statistical validation at best. However, tests cover a much broader scope than the type checker. But the type checker's "tests" are complete in that a type signature will always be true and you can mathematically prove, for instance, that certain states are impossible. But those checks have a very narrow scope. In other words, they are precious because they are mathematically proofs, but insufficient. Therefore, I tend to supplement the type checks with business logic tests (check my api performs as expected), view tests (given a set of actions, the view should contain such and such an element), update tests (after a set of actions, the state should verify certain assertions) and wiring tests (performing actions on the ui such as click, hovering, etc., should trigger certain messages).
As a backend person I really like Elm. Obviously you need to know HTML, CSS, and the DOM first, but the web platform is so terribly unsuited to app development that anything that provides safety, simplicity, and focus is great. IMO JavaScript on its own is a joke language for a project of any size. Typescript or Elm help so much when you pass a certain size.
Wow, looks great! Just tried it out myself, was one of those rare times where everything just worked as I expected. Excellent documentation!
Here is a thought: unit tests are useless. What you really care about are Integration tests. Also, you will introduce your team to the pain if ports.
The mobile layout seems to be completely broken :/
recent regression. fixing. sorry :-/
Great article! Good on you for writing it up, I need to get to blogging myself.
I just wanted to thank you for saying that, it absolutely made my day. I'm going to be graduating next spring, so hopefully I'll be able to use this to land me a job.
I really hate where JS is going after ES2015. It's mixing way to many programming styles into one. Part of the community is working towards a functional style while another part is moving towards a object-oriented style and it leaves us with a mess that'll turn into PHP if we keep going down this road. Even React (And don't get me wrong, I used React for years and loved it and still think it's better than the alternatives) is having an identity crisis. It started out as a mostly object-oriented library with internal component state, lifecycle methods and mixins. Now those are all considered bad practises and are being weeded out. However most of the community packages are still built around those principles. My frontend journey was jQuery --&gt; Backbone --&gt; React --&gt; Elm, so it took me quite a while getting used to the Elm syntax and way of doing things, but man it stinks going back now... I mean wtf is this: ``` const mapDispatchToProps = (dispatch: Dispatch) =&gt; bindActionCreators({ increment, decrement, }, dispatch) ``` I have to re-read it like 5 times before it's clear to me what's going on, and this is best-practises, modern JavaScript. 
Electron is an evil concept that should be avoided
I used [web-view](https://github.com/zserge/webview). There is a wrapper in [rust](https://github.com/Boscop/web-view) 
Use QT bindings for any general purpose language you feel comfortable. Could be Go, rust, C, python etc. Or just any other native UI library The problem with electron is that it uses hundreds of times more resources than other alternatives
**[Set (card game)](https://en.wikipedia.org/wiki/Set_(card_game))** &gt;Set is a real-time card game designed by Marsha Falco in 1974 and published by Set Enterprises in 1991. The deck consists of 81 cards varying in four features: number ; symbol ; shading ; and color. Each possible combination of features appears precisely once in the deck. [Image](https://upload.wikimedia.org/wikipedia/commons/8/8f/Set-game-cards.png) ***** ^[About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about) ^| ^[Leave](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[me](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[alone](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) 
Wonderful job! I especially love the way it handles `style` attributes properly. I'm currently using the [Sublime plug-in](https://github.com/michaelniepel/html-to-elm). It would be wonderful to have that behave as well as your project. :) Oh well, I'm saving this post in case I will need to convert larger html files. 
I don't have a huge project (specific to healthcare), but it works well for making a quick helper tool so far for testing a project at work. The only struggles I've found are mostly related to navigation, as most of the Elm SPA examples deal with routing using the url (i.e. /foo -&gt; open the Foo view), but you don't have that in Electron. So far it's been an advantage to building the app. I originally screwed up with the layout of the code (too many files), but since it's Elm, it was easy to refactor. The only limitations are stuff that is on the "server" side of Electron (file access, TCP interaction), where Node.js has to be written. If interested, it's located [here](https://github.com/making3/hl7-sender), though I won't claim to have written the best Elm at all.. There's also an app called [Mobster](https://github.com/dillonkearns/mobster) that is written in Elm / Electron too.
There's some strange behaviour with respect to back-off and reconnects. Most of the time things seem to work fine, but sometimes the Elm client seems to fail to even try to connect to the server. This github PR might be relevant: [https://github.com/elm-lang/websocket/pull/18](https://github.com/elm-lang/websocket/pull/18). And then it's hard to tell client-side whether you're actually connected or not. That both makes debugging hard, and makes it hard to make the UI behave well when connectivity is poor. In another project, we ended up writing a dedicated low-level websocket module to work around this: [https://github.com/alicebob/siren/blob/master/elm/Explicit.elm](https://github.com/alicebob/siren/blob/master/elm/Explicit.elm)
Elm is not a good fit for Electron. You need to interface with a lot of non-standard JS APIs (like IPC). You'll either need to use Ports for all of those interactions (cumbersome), or use Native code (illegal!), or wait for the implementers of Elm to add support for the platform.
That function syntax makes me think that JS programmers are a bit tragic, like abused children. "If I don't love the new syntax enough, they'll take it away and make me write function(){} again" They're doing that even in ReasonML. It's nuts. It's the only part of the syntax that's *worse* than OCaml.
I'm not too certain but I think there are two factors: 1. For consistency between `foldl` and `foldr`, so that you can fold in both directions with the same function. 2. Because elm uses extensively the `(|&gt;)` operator and it makes writing pipeline transformations of the type `a -&gt; b -&gt; b` much more pleasing to work with.
1. You can fold in both directions with `b -&gt; a -&gt; b` too. 2. I do not see how `|&gt;` influences this in any way. Can you provide some code snippet that illustrates this? 
&gt;You can fold in both directions with `b -&gt; a -&gt; b` too. Right, the point was more on *with the same function*. What I mean is that in haskell, you have: foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b So you cannot use the "same" function as first argument of `foldl` or `foldr`, you'll need a `flip` or similar. &gt;I do not see how `|&gt;` influences this in any way. Can you provide some code snippet that illustrates this? Now that we have to make a choice between `a -&gt; b -&gt; b` or `b -&gt; a -&gt; b` we choose the first one because of pipeline transformations. Indeed, if you have transformations ending in the form `x -&gt; x` you can chain them very easily with partial application. foo : a -&gt; x -&gt; x bar : b -&gt; x -&gt; x baz : c -&gt; x -&gt; x pipeline : a -&gt; x -&gt; x pipeline someA someX = someX |&gt; foo someA |&gt; bar someB |&gt; baz someC This is a pattern much fostered by the rest of the elm ecosystem.
Exactly :)
I had to sign in and comment on this since I am experiencing this feeling so strongly right now. After starting to play with Elm over the last few years, In the last few days I started looking at creating a react/redux application in an effort to build out my portfolio... and I just want to vomit. After using elm, react/redux is just hideous. I guess I'm fortunate to not have a job as a developer and get to choose what I spend my time hacking on. I honestly don't think I could go back to using react/redux after using elm. It's just such a mess... and you get none of the benefits like static typing and a helpful compiler. I seriously feel sorry for anyone having to code that way.
Yes.. I have looked into ReasonML, and would really like to use it... but it's like they are taking all the great things about functional/ML syntax and trying to make them more like javascript. It just does not feel nearly as clean/easy to read/reason about as Elm.
Elm can be a good fit if (A) you can look at Elm as the "engine" of your app instead of something that needs to implement everything and if (B) your app relies on enough state/logic (e.g. imagine a board game) where Elm can actually help. I think a lot of perceived problems with Elm come from the idea that you shouldn't have to write any Javascript once you use Elm. But consider, for example, a game simulation implemented in Elm and Javascript used to hook it up to user input and/or rendering, and it can run on the client and server. You wouldn't want your "engine" doing "Javascript's job" in this case even if it was written in Javascript because you want your engine to be portable. That said, there's no doubt that Elm could be improved to make it more pleasant to use in this way. I had to write my own plumbing to compile my own game for use on the server (for authority) and client (for client simulation) where my client was a web browser or Electron.
"Just rewrite it, it's that easy. Look how easy it was to suggest it!"
"Rewrite" OP didn't specify if he already had code written in elm he wishes to run as Gui or if he's just asking if elm is good for electron gui's, i merely pointed out that electron guis are not a good thing at all
Thanks for sharing this. I was dealing with something similar issue a couple of weeks ago. Curious to hear if you had performance problems before..? I ended up just filtering in my update function, because it seemed the easiest way to deal with it e.g.: ```TimelineMoveMouse event -&gt; -- Ignore mousemove events on the add post btn if event.target == "timeline-add-post-btn" then model ! [] else ( { model | mouseEvent = Just event } , Cmd.none )``` This was part of an app with thousands of lines of code and a lot of stuff going on. I noticed no performance problems at all. I think what you have is quite a bit cleaner than my solution though.
Yes, I started going into that direction, too. And, no, my reason was not performance, only code structure. I use the same component, an input text field, in multiple forms. An event like yours would have required new message variants for each message type, where it is used. Basically, an extra `KeyPressed Int` rather than just using the `Submit`, which I already had. That would have introduced quite a bit of code duplication, which I really wanted to avoid.
I'm not sure which bugs are outstanding on the navigation library, however the core team has been working on a new "browser" package for single page apps that will accompany the new version of Elm (0.19). I imagine that will provide a better way for developers to structure their web apps using pushState routing.
`elm-lang` is the old organization holding the core libraries of elm. With the advent of `0.19` there will be a switch to the `elm` organization. &gt; And what's the deal with these widely used libraries that seem dead Some of the changes in various libraries rest on very complex changes in other libraries. This is why fixing some of the issues has been delegated to the next release `0.19`. [Code is the Easy Part](https://www.youtube.com/watch?v=DSjbTC-hvqQ) and [What is Success?](https://www.youtube.com/watch?v=uGlzRt-FYto) talks by Evan provide more information about why certain things in Elm are the way they are. 
There is another interesting choice. ETA - an alternative to Haskell on top of JVM.
Thanks, that clears up a lot
Hi all I am building my web app with reasonreact and using reasonml. But I also interested in Elm language, because it similar to Haskell. Can someone help me to decide between ReasonML an Elm. Thanks
I never try reasonml, but i do a lot of react. The first advantage of Elm, you don't need react, because Elm enforce the architecture. Like this, you will never have some incompatibility with your framework and the language.
It can help you eliminate some kinds of tests. Such as having to test invalid input (that would go against the type parameters). If you encode business logic in the types, then that can also help reduce the amount of cases you need to test for. However you should still test your expected result / ideally as many of the input combinations that are feasible. 
Awwwwww yeah
HOLY SHITBALLS!!! Today in hell, forecast is for extreme blizzard, motorists are warned to watch for frozen icy roads.
The optimizer sounds fantastic!
Congratulations to Evan and to everyone else from the core team that made this release possible! I imagine that last year was quite a stressful time with all those people (me included) panicking about the future of Elm. Now it's time for celebration! 
Sweet! I would like some more detail on why it was such a difficult cycle and took so long, though I guess that would probably be more appropriate for a separate post. I'm also curious whether we can expect something similar for future releases, and if there's lessons that can be learned from this release. But for now: good job on a new release!
Nice! Is there an upgrade guide like before? Is there anything we need to change in 0.18 code or do we just start using the new compiler?
So excited for the new Broswer package! Can't wait to go home and get my projects updated tonight!
Great news ! Re-motivate me to learn Elm seriously this time, is there already a book/documentation to learn Elm 0.19 ? :)
Yep, https://guide.elm-lang.org/ is fully updated already! I also did some pretty significant rewrites to make it easier and clearer.
It takes a long time to rewrite every part of the compiler and a bunch of the core libraries. ;)
One of the potential resolutions I remember reading about this release was embedding multiple apps in a page without needing 2 compiled versions of the elm runtime. I suppose smaller package sizes makes this a non-issue now
As far as I know, this was already possible in elm 0.18. Just pass multiple files to elm-make, e.g. `elm-make MainA.elm MainB.elm --output=out.js` This should still work in 0.19
The big goals were (1) do really well on asset sizes and (2) make the compiler faster for big companies. Number (2) is particularly unglamorous and difficult, but I know the new version here is saving one team ~20 minutes. So that cost a lot of development time, but it's something that will save so much time across the ecosystem that I think it'll be very worthwhile. Everything else was a consequence of exploring those two major goals. It turns out that they are just both big and difficult problems! I'm really happy that changes like `elm/time` and `elm/browser` made it in as well, but that was a mix of "man, I need a break from shaving bits" and making some changes to support the broader goals :)
Is there any upgrade guide for package maintainers? Should I just update code along a new `elm.json` file and `elm publish` or should I be careful with specific stuff? 
Beefzilla will upvote any Elm card game.
&gt; Number (2) is particularly unglamorous and difficult, That is absolutely true - it's amazing that it even got finished at all! It's so easy to get distracted by things that are more fun (which I guess `elm/time` and `elm/browser` were, but apparently they did not prevent the rest from getting finished).
[It's been 84 years.](http://www.reactiongifs.com/r/84.gif) Memes aside, this is awesome! I'm looking forward to elm-conf even more now!
what's actually missing for calling it elm 1.0? I started with elm 0.18 and that already felt very solid and reasonably complete to me.
I'd recommend reading through [the release notes](https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md) and the notes on the new `elm.json` format [for packages](https://github.com/elm/compiler/blob/master/docs/elm.json/package.md). Other than that, it should be pretty much the same. If you are having trouble or just want to talk about it more, ask around on slack. There are a bunch of folks who have been using it for a while and can help!
I'm so excited! Great works, Elm team :)
The implementation is not considered complete *enough*. For example `elm-lang/date` was pretty difficult to use. The new `elm/time` is much better. That kind of breaking change is something you'd want to avoid after 1.0, since there would be a greater expectation of not breaking the APIs on every update. The removal of previously available functions on each update is also a sign that it's not "ready" yet. 
Typo detected. https://guide.elm-lang.org/install.html &gt; elm repl lets interact with Elm expressions in the terminal. Should probably say "elm repl lets us interact..."
Busted markdown hyperlink on the install page &gt; Do you need [elm-lang/time][time]?
I read the last bit of this a bit snarky, but hopefully that was not the intent! Either way, it may be a fine time to say: It is hard to update a written work (no compiler!) so please be cool to folks who have stuff to update. Open source people also have stressful jobs and lives, and they struggle to balance everything and still take care of themselves. E.g. open source people tend not to talk about it online when they get married, move, have medical trouble, get divorced, visit their parents, etc. and it can hurt extra bad when even the thing you do for fun starts bringing you down. Again, not sure the intent, and it's not a big deal. I just think it's worth mentioning this perspective as often as possible!
If I understood correctly, there's no asset splitting because the resulting file is so damned small anyway?
Hmm, is there a short summary somewhere for someone who isn't lingering around in chatrooms or watching 48m videos? I think the thing I'm looking for is not so much a desire to see more frequent releases, but an idea of what is going on, i.e. a quick way to see that the reason for the time it takes to develop a new release is not "the project is dead". For example, TypeScript (which _also_ has frequent releases, I know) has [its roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap), which is linked in every release post and which allows casual followers to see in a few seconds that it is being developed and what is being developed. Of course, TypeScript is somewhat the gold standard in this regard, but some way in that direction would be nice. In other words: it would be nice if the 0.18 release post, or a short article after that, would have said "The big goals were (1) do really well on asset sizes and (2) make the compiler faster for big companies. Number (2) is particularly unglamorous and difficult." Those two sentences alone would have provided insight in where the language is standing. So what I guess I'm saying is: is there such a two-sentence summary for the focus of 0.20? Or is that simply not known yet?
How do I use `elm-test` in 0.19? I'm trying to upgrade a package, and have installed `elm-explorations/test` with `elm install`, but there's no obvious way to run it. `npm upgrade -g elm-test` as suggested in the README gives me `0.18.12` which isn't very helpful. The documentation is quite obviously outdated since it references `elm-package.json`.
The summary is more or less a waterfall approach to development. But done in a thorough and thoughtful way, not simply to have a rigid process. An example being how all the packages are now on version 1.0.0 and there is no trace of 0.18 packages; Evan's taken his time to collect ideas where they belong and restructure a lot of stuff. The roadmap you're requesting may be this one: https://github.com/elm/projects/blob/master/roadmap.md And my impression from rage-googling why 0.19 "wasn't out yet" (a few months ago) is that lessons have been learned and that it will probably not take as long for 0.20. And if it does, we're likely to see minor bugfix releases (0.19.1) along the way. At least I hope so, since seeing dead "obvious merge" PRs is one of the most disheartening things I've dealt with when it comes to Elm and anticipation management.
&gt; The roadmap you're requesting may be this one: https://github.com/elm/projects/blob/master/roadmap.md Yes! I guess I'm blind then. Or just forgetful, because the first paragraph ("What is the timeline?") does sound familiar... Thanks, anyway :) &gt; lessons have been learned Hmm, that implies that mistakes have been made? As in: I wouldn't be surprised if everything that went into this release simply took as long as it did. In any case, I'm looking forward to hearing what those lessons were, especially since they're probably also relevant to other projects. My two cents would be that delays or whatever are not really a problem; it's mostly communication that could be improved (and in terms of "killing the momentum": communication can keep up/increase a lot of momentum without actually releasing anything). But of course, communication is practically a science in itself :) &gt; seeing dead "obvious merge" PRs is one of the most disheartening things I've dealt with when it comes to Elm and anticipation management. Not just in Elm :) As a personal anecdote, it was extremely disheartening when I found out that I hadn't turned on project notifications for a really small utility library I made for a year long, with three hanging pull requests. Such a shame...
&gt; it's mostly communication that could be improved I agree. I feel that the heavy reliance on and constant referrals to Slack is a problem, as it vastly raises the bar for finding answers through searching. And the fact that you have to be logged in makes it even worse. https://discourse.elm-lang.org/ is a step in the right direction in my opinion.
Updating my elm packages for 0.19 and running into some interesting results. I will file the second one as I don't see a corresponding issue yet. What's the consensus on the first. The error is confusing but it is legit? Am i missing something? ``` import Json.Decode as JD restDec : String -&gt; JD.Decoder x -&gt; JD.Decoder (x -&gt; y) -&gt; JD.Decoder y restDec field db da = JD.andThen (\sas -&gt; JD.map sas (JD.field field db)) da ``` Yielding ``` Detected errors in 1 module. -- TYPE MISMATCH --------------------------------------------------- src/Try.elm The 1st argument to `field` is not what I expect: 4| restDec field db da = JD.andThen (\sas -&gt; JD.map sas (JD.field field db)) da ^^^^^ This `field` value is a: String.String But `field` needs the 1st argument to be: String.String ``` And ``` import Json.Decode as JD -- restDec : String -&gt; JD.Decoder x -&gt; JD.Decoder (x -&gt; y) -&gt; JD.Decoder y restDec field db da = JD.andThen (\sas -&gt; JD.map sas (JD.field field db)) da ``` Gives ``` elm make --output try.js src/Try.elm Success! Compiled 1 module. elm: problem getting Opt.Def binary CallStack (from HasCallStack): error, called at compiler/src/AST/Optimized.hs:262:16 in main:AST.Optimized ```
Congrats. Any news on server-side rendering? I thought this would be part of 0.19: [https://github.com/elm/projects/blob/master/roadmap.md#how-do-i-make-a-single-page-ap](https://github.com/elm/projects/blob/master/roadmap.md#how-do-i-make-a-single-page-app) The lack of server-side rendering in 0.18 was actually the only thing holding me back of using Elm professionally :(
Where are you running these screens? Do you have multiple running on a single machine? Are they just individual Chrome tabs? Try running on Firefox and see if you get the same kind of errors.
Working on it now! Thanks for your patience. :)
Nope, the numbers really are that good!
They're all running on individual Chrome tabs. I actually discovered this error in production, where they were all being run on different tablets with Chrome.
Last week I recorded an "Intro to Elm" course for Frontend Masters (as well as an "Advanced Elm" course for the first time ever!) and both used 0.19. They should be on [frontendmasters.com](https://frontendmasters.com) within a couple weeks!
Thanks!
SSR wasn't included in 0.19 unfortunatly but that's only because compiler performance took priority. Now that's knocked out, SSR is one of the next major features on the roadmap.
Great news, thank you Evan and contributors! I was worried about elm since there wasn't much happening for awhile. Now to see how I can sneak some elm in as an embedded react component at work
Congratulations, can't wait to use it. Thanks for the hard work.
Yes, removing functionality may harm users. That said that's even true if the version number &lt;1. I like rust's approach there: keep the library scope for which to keep compatibility relatively small. With the language itself, it is something else. While I completely agree with the decision to remove custom operators, for a "stable" release that would have been problematic. But you can always do 2.0. Subjectively, elm's version number is at odds with the great, relatively mature state of the language but I can follow the arguments. I guess Evan is a perfectionist ;)
Can we no longer use npm to install elm? Or is that planned to be updated but just hasn't happened yet?
I publish via gitbook. It does not have an option to have past versions, but it should be possible to read the old version [here](https://github.com/evancz/guide.elm-lang.org/tree/a4b34b537117aa92fd8eba28cbdb3c93454f28db). You can go through things in the `SUMMARY.md` file, or if you want to get fancy, you can try to generate it locally with gitbook.
Here is an [archive](https://web.archive.org/web20180814175725/http://guide.elm-lang.org/web/20170423232110/https://guide.elm-lang.org/) of the version from August 14 for The Guide. 
&gt; To my eyes ReasonReact code is an unreadable mess Could you point to any examples of this?
I tried it and it seems it does not support &lt;img&gt; tags. It just removes them. I see that you didn't fork and PR the original project. Though it is good to start from scratch for learning purposes, I think it is better to always fork and PR before starting over a public project, for the sake of the Elm ecosystem. I would not like it to be like the JS ecosystem, where you have tens of projects that supposedly do the same thing with some kind of improvement each other, but where in the end none of them is good enough for the task. Fork + PR helps projects get better. If projects get better, the Elm ecosystem and thus Elm get better. Then, we all benefit from that.
Personally I prefer Elm's elegant, Haskell-inspired syntax, and its purity (all effects are clearly marked in the type signatures). It's also a very well designed language, with care taken towards developer UX. Elm's compiler has had a lot of improvements in the recent release, but BuckleScript is tough to beat. It generates excellent JS that is very JIT friendly and that works nicely when being both nested within JS, and being called from JS. This is very important for migrating to it, and more importantly, migrating _away_ from it if things don't pan out with the language long term. The JS escape hatches are also super important if you want to do something the language designers didn't initially consider, especially in-between long release cycles. Elm makes it harder to do JS interop which locks you into its ecosystem, but it brings with it greater reliability with regards to type safety. It will depend on your use case which of these trade-offs win out. Reason also has a very excellent module system that makes it easier to build up reusable components of functionality. This has the potential to cut down on a lot of the boilerplate that you end up writing in Elm. I'm not sure how much the community is taking advantage of it right now though, so it might not be much of a point of comparison.
Thanks for referencing that commit! Maybe adding a tag for that one as reference for others, too? 
Elm uses a concept called ports for JS interop. This isolates the JS side of things from Elm. There is also Flags if you just need a value at the beginning of the program. 
This is result of having a stale (pre-release) .elm directory left over just so others can see the result.
Does ReasonReact provide strong/safe typechecking? as safe as Elm? 
Can I write the following code in Elm &lt;head&gt; &lt;script src="keycloak.js"&gt;&lt;/script&gt; &lt;script&gt; var keycloak = Keycloak(); keycloak.init().then(function(authenticated) { alert(authenticated ? 'authenticated' : 'not authenticated'); }).catch(function() { alert('failed to initialize'); }); &lt;/script&gt; &lt;/head&gt;
Or var keycloak = Keycloak('http://localhost:8080/myapp/keycloak.json'); How to handle promises in Elm??
Says on the web site that it is a WIP.
I tend to work on data modelling first! I think about the data my application will need to deal with and its _valid_ states, then I model it and expose an API to work with it. This amazing talk by /u/rtfeldman talks about this: https://www.youtube.com/watch?v=x1FU3e0sT1I
You need to write this part of your app in JS, then use ports to call that code from Elm. In my experience (with 0.18), the JS part is likely to be large. Ports work by sending JSON data as messages (think window.postMessage). That means that \- basically Elm treats talking to JS similar to talking to an HTTP server \- data needs to be marshalled to a JSON data structure, and unmarshalled on the way back \- every call is async; synchronous JS function calls are not allowed in user code (it is allowed only in packages written by the Elm maintainers) \- request/response-type interactions with the JS code (like promises) use manual boilerplate and are hard to get right \- unlike the JS promises seen in your snippet, messages don't compose well; it becomes unwieldy if you need to go back and forth between the JS part and the Elm part of your application If you can live with these severe limitations depends on your application, e.g. on how much you rely on 3rd party code like Keycloak.
I do a third path. I start with [custom types](https://guide.elm-lang.org/types/custom_types.html). From there I will create the minimal `update` and `view` functions like this: update : Msg -&gt; Model -&gt; Model update msg model = case msg of NoOp -&gt; model view : Model -&gt; Html Msg view model = text "TODO" From there I progressively add functionality, bouncing back and forth between `view` and `update` as I support more things. 
In Elm there are no promises. All code is synchronous, and async behaviour is performed by passing messages to the runtime. It's very different to the JS approach, I'd recommend going through the Elm architecture tutorial to get an understanding of how this works in practice.
Does it work in Chrome or Firefox for iOS? Your first step should be pinpointing the failure. I would be surprised if this was a broadly-iOS issue, and not a browser specific issue.
I would say yes. I would even say it's more type safe because it models dom element attributes as optional arguments rather than a list of variants. On the other hand, to get to get the text of an input element in a `change` event, for example, you'll have to use a dynamically typed object because it just gives you the dom element directly instead of encapsulating it in a safe type.
Yeah, this happens in Safari, Chrome and Firefox in IOS forgot to clarify this
So my issues with ReasonReact specifically are just do with noise. This isn't really anyone's fault, mapping ReasonML/ OCaml code to something that works with JS and React in particular is obviously tricky: they have different requirements and very different semantics. I guess the initial problem is that Components are just Objects (state + methods), which for a functional language doesn't make much sense but ReasonML can't rewrite the React API. So in RML you have to create a template for a component, then you decalre a `make` function that returns a record and spread the component template's defaults in the record. Then you can define the fields you need inside the record, things like `render`and lifecycle methods (`didMount`, `didUpdate`, etc.). A basic component might look like this: let comp = ReasonReact.statelessComponent("MyComp"); let make = _children =&gt; { ...comp, render: _self =&gt; whatever } `self` is just to deal with javascript's `this`. This code is okay, it reads fine. My concern here is that I switched to ReasonML so I could write functional code, this just feels like weird JavaScript. But this is okay, maybe people just want types and pattern matching, which is reasonable. The problem is when you actually want to render things you have to use these helper functions. You can't return arbitrary data in ReasonML because of the type system , which is great but it just means your code is littered with `ReasonReact.string`, `ReasonReact.null`, `ReasonReact.array`. You will use these a lot too, I just find it all very messy. Working with callbacks is just strange, I won't go into this one in too much detail but its fine if you don't need access to `self`, its a little odd if you do and its pretty awkward if you need to pass multiple parameters and have access to `self` (You need `self` for access to `state`, `send`, etc.). Likewise you might need to access the `event.target`, sounds reasonable: `ReactEvent.Form.target(event)##value`. Everytime I do something it feels like I have to take the hard route because I wanted type safety, better quality code and all of the goodness that OCaml provides. I just feel like ReasonReact works against me because of the JS/OCaml collisions. Working with routing in ReasonML is actually really nice because of pattern matching. I'll stop now, I don't want to go through the entire API and keep criticising the same things. [Take a look at this code](https://github.com/reasonml-community/reason-react-example/blob/master/src/todomvc/App.re). This is a part of the ReasonReact ToDo App, it's readable, I guess? I just think its a sprawling mess. It is littered with these helper functions a more complex codebase would have more ReasonReact specific workarounds for standard React features. Maybe it is a preference thing but I don't think it is particularly readable; I think there are better ways of doing things. Like is say this is just a result to trying to get a decent ReasonReact API that maps down to React's JS API. It isn't an easy task and I don't want to put people off using it too much, I've just found it to be a little tedious to work with, and the code just looks messy to me, too much noise. Elm has an unfair advantage in that it is built for that very purpose, the 'framework' is built in to the language. So we keep the nice functional approach and can keep it as pure as possible. Elm doesn't do much else, but what it does it does well but more importantly, for me, it does it cleanly and simply. 
Wow I didn't know that! Thanks! So the problem might be only with Safari then
Oh, I totally get where it's useful. I have flipped, and had expected to flip again, but alas, 0.19 has no flip. I'll bet it's a part of their strategy of trimming stuff off the language wherever possible. Furthermore, I betcha in the next twenty milliseconds a package will appear in package.elm-lang.org with the name "flip" which has only one function, "flip".
Sadly the bug doesn't happen in the safari on OSX
\&gt; I am using REASONML with REASONREACT on my current project. \&gt; I would like to switch Elm and would like to know, if it is worth it. I'm confused about the motivation for switching here. * If you've been using it and you're happy with it, why switch? Switching will certainly take time and energy, so even if you end up happy with Elm too, will it have been worth the cost? * If you're unhappy, what are the pain points? Elm might or might not actually address them, depending on what they are. * If it's just curiosity to try out a new technology, then what else is there to know? By all means, try out the new technology! You don't have to \*switch\* to try something out. Far be it for me to discourage anyone from trying Elm, but I think it's important to have clear expectations on something like this. :)
There is no compile-to-JS language as safe as Elm, because they all allow calls to arbitrary JavaScript functions from their own functions. If I have this function in Elm: `String -&gt; Int` I can tell you **for sure** that it will not compile to JS code that does side effects or has a runtime type mismatch. In every other compile-to-JS language, a `String -&gt; Int` function might secretly make an inline call to JS code, which might in turn have a type mismatch, run side effects, monkey patch `window`, mutate the world, etc. There is no way to tell if it's doing this or not. The cost of this safety is that Elm's JS interop is not as seamless. You can't drop a JavaScript function into the middle of your Elm function, you have to go through an immutable message-passing system ("ports") to talk to JS.
Elm applications are not intended to have lots of JavaScript in them. Ideally they are 100% Elm and 0% JavaScript, but it's common in practice to have a little bit of JS. In general, Elm's philosophy is that **JavaScript is for workarounds**. If there's something you cannot do in Elm - for example because it requires using part of the Web Platform that doesn't have first-class Elm support yet, like Web Audio - then you reach for JavaScript interop. Otherwise, the default plan should be to write everything in Elm. The one exception is if you're introducing Elm to an existing code base, in which case it's normal to use JS interop as a way to have the embedded Elm application talk to the surrounding JS application.
Keep us posted if you find out, I'm curious now.
&gt; Take a look at this code. This is a part of the ReasonReact ToDo App, it's readable, I guess? I just think its a sprawling mess. It's worth pointing out that this is at least partly because this code has been auto formatted, and the reason formatting tool (`refmt`) isn't particularly good. It recently got significantly better, where it will at least preserve blank lines, but someone would have to make the effort to add blank lines again. Personally, when I write Reason code, I avoid `refmt` like the plague. Unfortunately most in the community does not seem to care much about readable code and apply the formatter on every save, which then makes the formatting style spread virally.
Ah, I see. I think I probably use that as well (I think it is recommended somewhere) and probably doesn't help with my experience. That said I hope this didn't come across as overly critical, I wouldn't want people to avoid ReasonML or OCaml/ Bucklescript on the back of a personal preference. Because that is really what this comes down to, and its the ReasonReact part that I'm uncertain about; I find ReasonML pretty pleasant to use (although I'd rather just write OCaml). As always, I'd recommend people just try things out and find what works for them, I'm no expert. I also don't want to disparage the great work that lots of people (yourself included) are doing to improve the ecosystem, whether it is Reason/BS or Elm. I think both still have a lot more to give and I'm intrigued as to where it will take us.
&gt; You also have access to the JS ecosystem which is vast but you lose any guarantees of safety by doing this. I think this is a bit exaggerated. You would typically encapsulate unsafe code in safe abstractions that give you safety guarantees at the boundary. Which is as good as anything that interacts with the outside world can get. And if there are ready-made bindings to the js libraries you can use, you can consume js libraries without having to deal with anything unsafe at all. If possible it would of course be better to have the entire library covered by the type system, but remember that even significant parts of Elm's runtime and core libraries are written in JavaScript. That's why the concept of native/kernel code exists, and what caused that whole debacle when it was restricted to only "blessed" code.
Oh, and when I said &gt; in the next twenty milliseconds a package will appear in package.elm-lang.org with the name "flip" which has only one function, "flip" ... I guess I meant two hours, because I went and published that bad boy! https://package.elm-lang.org/packages/pilatch/flip/latest/
&gt; That said I hope this didn't come across as overly critical not at all. I made a comment on your first post, but other than that it would just be nitpicking I think, and overall seems like a fair representation that's honest about its subjectivity :) &gt; As always, I'd recommend people just try things out and find what works for them, I'm no expert. Even if you are an expert, I think the best you can do is make others aware of the defining differences, and encourage them to experience and investigate it themselves. It's too easy to get stuck in the blub paradox and overemphasize aspects that will look completely different when experienced in the context of the actual language, compared to the weird imaginary language their mind will cook up from all the disconnected information they've consumed.
You're right, this was poorly communicated and overstated. I was really referring to the fact this trade off between Reason and Elm, with Reason being mostly safe all of the time and Elm being one extreme or the other. Also you can just dump JS code into reason and it will work (and you lose), I'm not sure relying on developer discipline counts as safety. As I said in my edit above, you can have the best of both with Elm too: you can have your Elm code with everything that brings, and you can always write your JavaScript ports with something like Reason (or something similar) to give some assurances when you have to interact with unimplemented browser APIs and such. Which I think might be a better alternative to going from Elm to pure JS.
This technique is also known as "Type-Driven Development", if anyone is interested in searching for learning material. I'd go as far as saying it is life-changing for a programmer, and that it helped me finally get why some famous programmers such as Linus Torvalds and Rob Pike claim that getting data structures right is the most important thing.
Talking about internal implementation of modules, is there a plan for elm/http to be implemented on top of the fetch api instead of the deprectated XMLHttpRequest one? Only fetch is compatible with service workers.
Indeed, the differences are explained in the release notes: [https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md#elmjson](https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md#elmjson)
&gt; Do you search for comparable real world stuff? No. In your example I'd ask questions like "does my marketplace have text field?" Okay, how should I model that? "Does it have to load things?" How should I model that? Etc. It is more looking very specifically at the exact things you want to do and using the mindset mentioned in my [types as sets](https://guide.elm-lang.org/appendix/types_as_sets.html) appendix.
well, the api is not stable. this release has breaking changes. i wouldn't consider stabilizing around a semver 1.0 major release until the other three checkboxes on the roadmap are ticked.
i call dibs on packages `|&gt;` and `+` once they are removed from elm 0.20!
When would you need a text field? Registration, auth? Comparable to a marketplace where you'd show your ID at the entrance, or use your credit card for payment. The text field that is supposed to be associated with the chatbot would become a chat field, because realistically you could only talk with a pitchman in that situation. Would this work? Type textfield = auth | registration | chatfield Thx for Elm btw, lol! 
You can read the old version mentioned by u/wheatBread here [https://guide.elm-lang.org/v/a4b34b537117aa92fd8eba28cbdb3c93454f28db/](https://guide.elm-lang.org/v/a4b34b537117aa92fd8eba28cbdb3c93454f28db/) If you want to see a different commit, just visit \`https://guide.elm-lang.org/v/commitSHA\` and it should work if the given commit was successfully built by GitBook.
&gt;Reply Hello :) You can use the [plugin-versions](https://www.npmjs.com/package/gitbook-plugin-versions) to add a version selector to your book. Here is a doc that uses it [https://docs.feathersjs.com/](https://docs.feathersjs.com/) &amp;#x200B; This legacy gitbook plugin is a bit old. And at GitBook, we have switched our focus to the new version during the last year. But I think it still work. I'd suggest to either use the \`tags\` option, or to list all the links you want yourself in the configuration. If you have any trouble, do not bang your head and reach for me and I'll help you. 
ELI5, how can I use this to make desktop apps in elm?
IOS skips my birthday, I dare them!
It's certainly possible, but hasn't been discussed much!
I mean, I'd do mocks. So I know what visuals and interactions I want to create before I start programming. But when it comes to the programming part, I always start with types. I feel like I may be using the word "model" different than you are. Perhaps that is the root of the confusion. I mean "designing a really precise type" when I use that word.
I think i will try migrating first to 0.19 then since i haven't been able to identify where the bug comes from. Hopefully the datepick from elm-community will be migrated to 0.19 soon too! Thanks! &amp;#x200B;
I'm inspired by [The Elements of User Experience](http://www.jjg.net/elements/pdf/elements.pdf). I usually start with a boilerplate SPA structure. You can start with something as simple as [elm-hnpwa](https://github.com/rl-king/elm-hnpwa). 
&gt; I was really referring to this trade off between Reason and Elm, with Reason being mostly safe all of the time and Elm being one extreme or the other. Indeed, and that's a really good point that should be mnetioned. &gt; I'm not sure relying on developer discipline counts as safety (I feel that Reason's JS interop is a little too flexible). I'm not against having unsafe features in a language in principle, as long as they're contained. `bs.raw` for example can at least be linted and searched for. Even better would be if the type system was used track certain effects, like I think Rust does with its unsafe blocks. As long as it's clear where the boundary between safe and unsafe is, and that they're easy to spot during reviews, I think it can be worth it to include some unsafe features.
I get what you mean, I'm interested in how you and other Elm users get to the point of knowing what to code, or what types to model. The whole process basically, and to which levels of the process Elm connects and overlaps. My definition of models is that they describe how something works. This could start on a high level with customer jobs or the change and progress users want to make by using products (where many psychological push and pull mechanisms come into play), the products and functionality of the products aligning with that progress (deciding what kind of product to build), your UI that makes the product usable, and the scalability and maintainability of the product (architecture, code quality). [Here's a good free read](http://www.whencoffeeandkalecompete.com/) about high level product stuff and corresponding "models". It has an elmy vibe because they're also questioning previously established methods. 
Hi - I've asked this on Slack, but I hope it's OK to ask in 2 places ? I have reached that stage of beginner-ness where I don't understand the difference between Task and Command... so thanks in anticipation for your patience. I get the Elm runtime being the place where effects/actions/launching the rockets takes place. &amp;#x200B; Two minimal examples (modified from Introduction to Elm, using 0.19) &amp;#x200B; Random: \`\`\` type alias Model = Int &amp;#x200B; &amp;#x200B; init : () -&gt; ( Model, Cmd Msg ) init \_ = ( 1 , Random.generate Face ([Random.int](https://Random.int) 1 6) ) \`\`\` &amp;#x200B; When the page is loaded, it displays a random number b/n 1 and 6. I think I understand this: [Random.int](https://Random.int) returns a generator of random integers between 1 and 6 Random.generate takes a "Tag" (Face) and applies it to the Int and returns that Face Int to my update and away we go &amp;#x200B; Second example: Time &amp;#x200B; \`\`\` type alias Model = { time : Time.Posix } &amp;#x200B; &amp;#x200B; type Msg = NewTime Time.Posix &amp;#x200B; init : () -&gt; ( Model, Cmd Msg ) init \_ = ( Model (Time.millisToPosix 0) , Task.perform NewTime [Time.now](https://Time.now) ) &amp;#x200B; \`\`\` &amp;#x200B; In this example, the Cmd \`Task.perform NewTime Time.now\` is constructed by applying \`Task.perform\` to [Time.now](https://Time.now) (a Task), and return the tagged (NewTime) time to my update. Why not just \`[Time.now](https://Time.now) NewTime\` in the same way as \`Random.generate Face ([Random.int](https://Random.int) 1 6)\`. Or another way, why don't we need to say \`Task.perform Random.generate Face ([Random.int](https://Random.int) 1 6)\` (or something). &amp;#x200B; This is sounding slightly incoherent - sorry. &amp;#x200B; The docs for \`perform\` say: &amp;#x200B; \&gt; So we have changed a task like "make delicious lasagna" into a \&gt; command like "Hey Elm, make \&gt; delicious lasagna and give it to my update function as a Msg value." &amp;#x200B; Well, why don't we need to do the same thing for the Random example? Change "generate a random int b/n 1 and 6" to "generate a random int b/n 1 and 6 and give it to my update function as a Msg value" &amp;#x200B; I suspect that if I knew Haskell, this might be clear - I see tasks have "andThen", and faint aromas of (&gt;&gt;) are in the air... &amp;#x200B; I really appreciate the patience and help of folk on this forum. Thanks
What about [Ellie](https://ellie-app.com/)? 
&gt; Tuples limited to a max of 3 elements - you'll need to use a record for anything larger. What's the point of this decision? Unless it has something to do with making the compiler faster, it seems arbitrary and makes it annoying to handle complex case expressions (where tuples are essential). Contrived Example: case (a1, a2, a3, a4) of ( True, _, _, _ ) -&gt; True ( _, True, _, _ ) -&gt; False ( False, False, True, _) -&gt; True .... This is not an appropriate place to use records. Now has to be rewritten with nested tuples, making it confusing to read. case (( a1, a2 ), a3, a4) of ( ( True, _ ), _, _ ) -&gt; True ( ( _, True ), _, _ ) -&gt; False ( ( False, False ), True, _) -&gt; True ....
i have this bug where a click on mobile takes about 300ms to register. According to this [article](https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away) i can remove the bug by inserting &lt;meta name="viewport" content="width=device-width"&gt; into the head or using html { touch-action: manipulation; } i need this for a libary i'm making, so using a special html-file with inserted elm-code is not an option for me
Elm is the Go of functional programming languages.
how about the following code type Bool4 = Bool4 Bool Bool Bool Bool case bool4 of Bool4 True _ _ _ -&gt; True Bool4 False True _ _ -&gt; False Bool4 False False True _ -&gt; True _ -&gt; False
I saw Bill St Clair mention the following on Slack: "3. elm-test is much easier to use, but you have to upgrade: `npm install -g elm-test@0.19.0-beta4` You no longer need `elm.json` in the `tests` directory, just your test files. The test files themselves donâ€™t change, except as necessary to make them work in 0.19. You need to put in elm.json: `"test-dependencies": {` `"elm-explorations/test": "1.0.0 &lt;= v &lt; 2.0.0"` `}` "
Thank you. I think the reasoning for the restriction on tuples was to improve readability/maintainability as it can be hard to remember the order of tuple values.
I also use this pattern, though usually when I reach the &gt;3 level I find myself refactoring because some of the combinations can be better understood and handled before.
How so?
Have you asked around on [Slack](https://elmlang.herokuapp.com/)? You can chat with folks in the #beginner channel and get help much more rapidly. I recommend trying out that path!
Yes, but no one response. &amp;#x200B;
Instead of manipulating the DOM yourself, you simply tell Elm what the entire page looks like every time there is a page change. This is done via the â€œviewâ€ function. Elm then figures out which parts of the page changed and efficiently manipulated the DOM for you.
Same basic idea about vdom diffing. Why don't you go through the official guide?
In many cases, there is no good alternative. The current approach has made it impossible to properly support websockets, to give a single example. If you want to use them in 0.19, you have to write it completely from scratch using ports and a shitload of external code, and due to the limitations, that will not change. It is literally impossible to write a decent websocket library.
That's a xy problem. The issue is not that there is no access to the internals but that there is a lack of a good websocket library and much of the web platform.
Lack of a good websocket library? The websocket library was written by Evan, so I would imagine that should be the best websocket library Elm can offer. That package uses native modules, so any other attempt at writing a websocket library would most likely require a mess of ports. Same goes for the rest of the web platform APIs too.
Just to clarify, I am not a PL enthusiast. I'm a commercial user and lead a team of software engineers that write a lot of Elm. This change to me seems inappropriate in the same way that the compiler telling you your function names are too short / too long would be inappropriate. Yes, perhaps a one letter function is a code smell. Perhaps it isn't. Should the compiler throw an error for that too? If you go down the rabbit hole of "code smells" being compiler errors, where do you draw the line?
&gt;The websocket library was written by Evan, so I would imagine that should be the best websocket library Elm can offer. Evan doesn't think so. That's why 0.19 doesn't have one, he's still thinking. He suggests to use ports if you are in a hurry.
That's a good workaround, but this decision still seems arbitrary and unsupported.
The problem is that there's no telling when you'll run into these kinds of issues, where there is a prescribed Elm package that uses native modules that suddenly has a bug or doesn't support a feature your app needs. Sometimes ports can be a simple fix for code that is already asynchronous (like websockets), but sometimes ports would require an entire rewrite of your app for what should be a simple change. With 0.18 native modules could ease the pain here, but with 0.19 these simple bugs can be landmines that fully derail your app.
I think this article summarizes my experience as well. We ported Elm to Bucklescript for internal projects, and have arguably created a better experience than Elm provided. I haven't seen any technical reason for us to go back.
Shutting down discussion is never the right answer in any context. 0.19 doesn't break any of my stuff but the restrictive totalitarian approach to the language that leaks into the developer experience makes me want to switch to PureScript, even if it's less mature.
I may not agree with all the decisions made by the people behind Elm but I see no reason why they shouldnâ€™t be able to make those decisions. They obviously prioritize crafting something as great as possible over trying to make everyone happy. Iâ€™m sure they had people like you in mind and itâ€™s just a trade off they were willing to make. Iâ€™m not familiar with Purescript options but for Haskell there is a project called miso (https://github.com/dmjio/miso) that is quite close to Elm. If you already know Purescript, Haskell should be quite easy to pick up.
No programming language works by democracy. There's always a BDFL.
I have no problem with a language making different design choices than I prefer-- my issue is that the development of Elm is so restricted as to practically be closed source. Even in your post it's "I'm sure they have a reason," as if "they" (really just one dude, Evan) is a godlike figure who dictates the truth of the language with no further discussion allowed. Not only does that approach not scale at all, but it leads to a shitty developer experience when the language is constantly being stripped of super useful features. (See: extending records, custom operators, kernel code, websockets)
The issue is just that Elm's BDFL is just a DFL.
What are you still doing here? Either go find a language you like better of fork Elm.
If youâ€™re looking for a model-view-update library, Haskell has Miso. Donâ€™t get me wrong, GHCJS tooling is a mess, but there actually is an effort to maintain backwards compatibility. 
I don't understand why Elm's cultish "friendly community" boils down to "GTFO" when any discussion is attempted.
Iâ€™d agree. In general, not maintaining backwards compatibility is disrespectful towards big library authors (aka the ones who have contributed the most to your community). Itâ€™s a pretty dire sign for any reasonably sized company. 
Because you are just ranting about things that aren't going to change and if Evan was to engage in that pointless debate we wouldn't have Elm 0.19 before 2024. Elm is not the language for you. No hard feelings.
Because it's the nature of every software to have internal parts?
That's not really what happened here.
Then go use that and stop whining in /r/elm.
&gt; Elm is not the language for you. No hard feelings Or... anyone, apparently, since writing Elm code can be considered a liability at this point.
&gt; Either you are a blind fanboy or youll get banned if you dare to question the great evan Meanwhile, boasting about the "great, beginner-friendly community." Uhh okay.
I believe the suggestion is to power through and come up with different names. I'm not a big fan of types creeping into variable names either. 
It was a tough decision, but we chose to implement Elm directly in OCaml (BuckleScript). We did explore ReasonReact as a possible destination, and also experimented building our own lightweight platform on top of ReasonReact, but inevitably decided against both for technical reasons. Rewriting Elm is not as crazy as it sounds. The platform/architecture essentially boils down to 2 files; the scheduler and the platform: https://github.com/elm/core/blob/master/src/Elm/Kernel/Scheduler.js https://github.com/elm/core/blob/master/src/Elm/Kernel/Platform.js Once those are implemented in BuckleScript, everything else in the ecosystem (Browser, Fx Managers, Http, Vdom) hooks into them.
Does this absolute statement also apply to purescript?
I really enjoyed building this game with Elm. It took a few nights this week. I had started with 0.18 and the very next day 0.19 dropped, which was surreal. My upgrade process was not too bad. The code is open source at [https://github.com/andrejewski/urinal-picker](https://github.com/andrejewski/urinal-picker) if anyone want to know how to win.
Sorry, but I don't think the author is on here. I posted this to start a conversation to discuss.
Oops. Ok!
Interesting. I may look into bucklescript and reason after I feel comfortable with Elm. Do you avoid the reason syntax and code directly in ocaml, then use bucklescript to compile down to JS?
Ha, I wonder how bad all these removed comments were 
163 urinals. Fun to play. 
4 years ago I decided on Ember.js for our app. Sure, it's not the coolest framework anymore. And I won't pretend that upgrades were always painless (although they are usually pretty simple). Or that every Ember.js user agreed on every decision. Or that the Ember.js vision has always been consistent and has never evolved or staggered trying to get to where it is now. But I've been using Ember since 0.x and have never experienced anything like this. Especially not people like redalastor telling people to GTFO if they have any criticism to offer. Why would anyone choose Elm for their company's app knowing they have zero expectation of an upgrade path if the author feels like breaking the language on a whim?
Hi /u/senorsmile, sorry you walked into a minefield! People have very strong feelings about some of the topics in here, including: * Some believe that Elm 0.19, which was 18 months in development, should not have been released until a rewrite of the (flawed) Websockets package was also complete. Evan decided [not to block 0.19's release on that package](https://github.com/elm-lang/websocket/issues/28#issuecomment-415831336), and some people are vocally upset about that decision. * Some believe that a [longstanding compiler flaw](https://discourse.elm-lang.org/t/native-code-in-0-19/826) was actually (or should have been) a first-class feature. No amount of explaining the history or unequivocally stating the design goal seems to be able to change their minds about this, or to discourage them from loudly lobbying for their position. * Some believe that Elm should add various features that other languages have. A common request from Haskellers is to add Haskell's typeclass feature, or something like it. Explaining [why that has not been done](https://github.com/elm/compiler/issues/1039) does not stop them from requesting it louder, over and over again. * Some state that Elm is "not open enough" because - reading between the lines - they do not personally have as much say in Elm's direction as they would prefer. * Some (apparently) believe that the people who make Elm are not **people**, but unfeeling robots who exist to provide them with free software and then to take unlimited amounts of abuse on their own forum. If these people are subsequently banned, they denounce the moderators as tyrants. The core team has spent countless hours explaining and re-litigating these issues. Posts like this are [what makes contributors want to quit](https://www.youtube.com/watch?v=uGlzRt-FYto). These diatribes are hardly unique to Elm, and they do a lot of damage. As [Rich Hickey put it](https://www.reddit.com/r/Clojure/comments/73yznc/on_whose_authority/do1olag/): &gt;I have to say now to those for whom such expressions are cathartic - they hurt people, a lot. I don't believe the sentiments in the post are widely held - most people who are happily using Clojure aren't as vocal. But it doesn't take many arrows to bring someone down. Again, I'm sorry that this is your first introduction to Elm. If you'd like to discuss Elm's trade-offs, both pro and con, there are plenty of people who are willing to talk openly about them in a calm way. I'd recommend opening a thread on [Elm Discourse](https://discourse.elm-lang.org/) if you're interested in that. I hope you can understand why we're locking this thread and removing it from the homepage. That's what we'll do with the next diatribe, and the one after that.
Brilliant. Was this inspired by [the original flash game](http://gamescene.com/The_Urinal_Game.html)? I recall playing it something like 10 years ago. The main difference is that it included a door to leave when conditions were unfavorable.
Oh, that's cool. I thought of this independently. As I was planning it last week, someone recommended I add a mechanic to "wait" when there was no good option. Instead I just always remove one random occupant so there is always at least one available urinal. There may be some cool things I can borrow from this older one. Thanks!
Dang, as far as I know you hold the high score. I'm flattered.
This is great! I think one great feature would be showing the rule you violated when you lose!
&gt; isAdjacentTheShortestOccupants i don't get why one need to stand ajacent to the shortest person.? Also i would have thought that i've posible one should always keep one urinal free between two man.
They both have the "my way or no way", adding limitations not because there's any technical limitations, but because they want to stear developers towards writing easier-to-understand code. Which is one of the reasons they're both great, by the way. Elm is Haskell on the web without the things that make Haskell programs so incredibly hard to understand.
&gt; without the things that make Haskell so incredibly expressive FTFY. In my view the way in which Go and Elm are similar is that they both disallow abstraction, forcing programmers to repeat themselves over and over again for little benefit.
Oh that's very cool! I didn't realize the game had such depth until I went to read the source code. I thought it's all about the empty vs non-empty urinals but it's about the people too!
I agree with the decision to disallow shadowing for the reasons you just stated. Yeah, I suppose the variable name you should use depends on the context rather than just prefixing it as `maybeX`.
The taller people can peek over and get a better view of your stuff 
The accumulator is the subject. If a function has a clear subject, it comes last by convention. This allows for convenient partial application since the subject is the argument that is most likely to change between calls. Imagine a function `putHummus : Hummus -&gt; Grocery -&gt; Grocery`. You could apply this to a hummus variety and get `putPinenutHummus : Grocery -&gt; Grocery`. The partially applied function is a simple transformation: grocery in, grocery out.
Yeah and naked people are !!FUN!! to be close to.
My sonâ€™s review: â€œThis game is disturbingly addictive.â€ â€”Graham
List.head, List.tail and List.isEmpty now have a small remark in the doc: &gt;Note: It is usually preferable to use a case to deconstruct a List because it gives you (x :: xs) and you can work with both subparts. I believe this means they will be removed in a later version.
Well, this feels pretty valid the way you have explained it, but to me at first it was the same exact reason why the other way around seemed more intuitive. In case of a fold the accumulator is actually the sort of more "static" parameter of the folding function because that is what it gets applied to over and over again, but from a functional standpoint you have convinced me that it's indeed more like a subject and the current element is more like an actual varying parameter.
Oh haha, that does make sense :P
Cool game! I think I found a [bug though](https://i.imgur.com/TVk2dyA.png). There's only one urinal available but I'm 99% certain to never ever pick a urinal next a naked dude.
Trying to guess the game mechanics is made harder by hiding the last urinals state when losing. In my opinion, I would have appreciated the score to be displayed in front of the last state to be able to examine the guys last position and appearance. Another option is to give some clues, for example with some slightly related quotes. For example: "Stars donâ€™t beg the world for attention; their beauty forces us to look up". Anyway, really fun game. Well done!
This emulates the real world: when you gotta go you gotta go.
Thanks for the pointer! You inspired me to contribute [a simple Elm example](https://github.com/Boscop/web-view/pull/31) to the Rust wrapper.
Awesome conversation as always.
[As you can see](https://github.com/elm/elm-lang.org/issues/450#issuecomment-260735856) Evan doesn't care about "out of date" pages. 
I've posted this on the elm discourse board. It got taken down without reasoning so I don't know what's going on there. 
I am watching this course [https://courses.knowthen.com/courses/86520/lectures/1772699](https://courses.knowthen.com/courses/86520/lectures/1772699) It's about infix functions. I'm trying to find documentation about it. But I can't find it. They guy in the video writes with the tilda. Is it always necessary to start an infix function with tilda?
hey /u/tmountain! Thanks for pointing out the link. Sounds like you got around it for now. Coincidentally that's the example that [ellie-app.com](https://ellie-app.com) loads by default. ðŸ˜‚ &gt;With new users coming in to check out the language, it's probably worth making sure all the URLs are up to date. Otherwise, it can lead folks towards the impression that the website/language are not fully maintained. Sure! I don't think anyone would argue the opposite! Over time, we'll definitely get all these sorted out. The problem here is that the compiler+packages+guide+site+community spaces form a pretty large surface area, and documents are updated in response to finding better paths elsewhere, so everything sort of shifts around a bunch before the release and dangling pointers like this don't always get caught. I'd bet we'll be picking dead links out of our teeth for a bit yet, but it'll all be resolved eventually. Thanks again for bringing it up; many eyes make light work. ðŸ˜Š
Ah! So as of 0.19, there aren't any user-defined infix functions. This was basically because very few of them have an intuitive meaning, and those get taken quickly, so we're left with stuff like `|=~~&gt;&gt;`, which is much clearer as a regular, named function. So where before you'd do `a |=~~&gt;&gt; b`, now you'd reverse the argument order and write `a |&gt; whatever b`
Read [the entire thread](https://github.com/elm/elm-lang.org/issues/450). The purple "Merged" badges indicate the 30+ PRs where people fixed links. After that, some examples did not have links from the guide or website anymore, so the issue had helped us track down everything that it made sense to fix.
I encourage people to read [the entire](https://github.com/elm/elm-lang.org/issues/450) thread. I counted more than 30 PRs where we were fixing all the links that existed in the new websites. It took some time to do that. At some point it was done, and not all the pages that existed in the past made sense anymore.
I wanna create an Array of random integers and I used the Random.Array.shuffle function to do so. It gives me a Generator back and I've read that the only way to deal with it is using Cmds? Am I right here? Seems to be kind of overengineered from my newbie perspective. :D
Yes, you're right. Here's an Ellie showing how it works: https://ellie-app.com/3bcZgrgF24Ta1 I also included a bit of code to get the current time in case you need a seed. The reason it's so complicated is that generating pure numbers (and getting the current time) cannot be done with pure functions and involves side effects. The side effects are generated via commands which are then dealt with by the Elm runtime. 
Intervened by merging more than 30 PRs. **After 4 months of inactivity**, it was closed. Leaving threads open forever is not a reasonable strategy, especially because the site changes over time and not all check boxes correspond to reality forever. You are saying "It seems to me that it was an unfinished task." Find someone who was part of that issue you linked that think that. Find another person who thinks that Elm is doomed because there were some broken links in 2015. If this thread is actually about some other anxiety, make that argument explicitly instead.
A benchmark or some paragraph about performance between them would be awesome
Thank you for clarifying things.
I really like how the author is comparing without (even indirectly) preferring one. â€œThe right tool for the right jobâ€ should always be the main concern and this series definitely helps!
This was a great series, thanks for sharing!
Very interesting, thank you!
Code written in elm with no javascript is called native code. So basically using no ports.
This was a pretty great read; easy to follow and informative :) As someone who isn't used to working with Elm, I'm curious about some of the things in the code. Mainly, the author defines the `SelectNote` message and uses it when the user manually selects a note. But when he creates and deletes notes, he programmatically selects a note by writing the note ID to the model directly. I imagine having a message like `SelectNote` as similar to defining a function, and to stay DRY, you would send that message whenever you want to make a selection. But is that actually the right way to view it, or is it better to view the operation of deleting a note and selecting a new one as atomic, such that it should be one update? Also, /u/peterxjang, is your conclusion about Vue.js bringing the smallest payload still true after the upgrade in Elm 0.19? :)
Thanks for pointing out the note about the payload, I updated the article accordingly! As for your question about the code, I guess you could reuse the SelectNote method when creating or deleting a note. From what I understand it would trigger another draw step, since you're not calling a function so much as you're triggering another update-model-view cycle. Since you already can figure out the selectedNoteId when creating or deleting a note, it seems more straightforward to me to update the model accordingly in one step. To be clear, my Elm code in this article should definitely not be considered to be canonical - I literally taught myself Elm while writing it! I put a lot more focus on making the code understandable from a learning perspective as opposed to making it follow best practices. That being said, I'd be happy to hear any feedback if there are some major points that I missed in terms of style!
You're right, that would be awesome! Unfortunately I don't think I have enough experience with each framework to provide fair performance comparisons. I've seen time and time again where framework authors make these types of benchmarks (which get a lot of attention), only to be corrected for not properly configuring the other frameworks (turning off dev mode, etc.) I would also say that the notes app I'm building here is great from a learning perspective, but it's too small in scope to draw any meaningful conclusions about performance across frameworks. Benchmarks tend to make people focus on which is "best", whereas I'd like to focus on the design decisions of each framework - what's easy/difficult/simple/complex to implement in each approach. All that being said, I did check out the minified/gzipped size of the Elm code after the 0.19 update, and got the same results as r/SkaterDad, around 8 KB. That's astoundingly small (I can't remember what it was using 0.18, but I believe it was one of the larger payload sizes in this comparison). Definitely exciting times!
That was my first thought as well but it is quite the opposite as you see in other comments. To clean up the confusion it has been renamed to **kernel code** *tldr:* it is not something you have to care about as an application developer. It is how core elm functionality is implemented.
WAT? You can do this from within Elm now? Thatâ€™s crazy!!
What I gather, you could do it before 0.18, now you can't do it if upgrading to 0.19.
Thanks for the helpful reply.
You were able to in 0.18, although it was discouraged each time it was mentioned. Ports are the intended way; native code is disallowed in 0.19 for user code.
Look at [getViewport](https://package.elm-lang.org/packages/elm/browser/latest/Browser-Dom#getViewport). The terminology changed a little, there is a comment about that on the top of the docs. I haven't used that function myself yet, but I think its what you're looking for :)
Stay away?
Not a great beginner tutorial. It's a good showcase of some more advanced techniques and how to structure a medium-sized Elm app.
Roger that, I like official. Thanks!
You could try ReactNative + Elm. Check out the following package. https://github.com/akselw/react-elm-components
&gt; and just use Angular/NativeScript or React/ReactNative instead? How about using actual native technologies rather than force a webform to be an app?
I'm writing a to-do list in .19 and it's working well except my input loses focus after I add an item. How can I set focus back on my input?
Don't forget that modern web standards allow web apps to do lots of things that "only native apps" could do in the past. For example, you can install yourself on the app home page, send push notifications, even talk to USB and bluetooth devices!
webpack 4 has been out since February; why did you pick webpack 3 instead?
Good points, I never got problem with 3. But I will upgrade webpack this week for using the latest versions. Thanks for you comment
The best supported option is to create a "Progressive Web App". (This is currently enabled out-of-the-box with [create-elm-app](https://github.com/halfzebra/create-elm-app/blob/master/template/README.md#making-a-progressive-web-app), which was also [recently upgraded to work with Elm 0.19](https://github.com/halfzebra/create-elm-app/issues/275).) On a minus side, the set of supported mobile functionalities in PWAs is limited as of now (but there are already many things you can do). There was some big table with compatibility notes for browsers and supported APIs in various areas, but I can't find it now. Then there's elm-native-ui. It's highly experimental, but was used by some people in production. It has access to more APIs than a PWA (via React Native), though still not 100% of what is available to a purely native app (i.e. JVM or Swift). On a minus side, the library considered not idiomatic for Elm and effectively a "dead end" long term. Also, I don't know of anybody updating it to Elm 0.19 (it is Elm 0.18-compatible). I personally did [a fork](https://github.com/akavel/elm-native-ui) which upgraded it to React Native 0.55 (still in Elm 0.18). Then there's [elm-ios](https://github.com/pzp1997/elm-ios) for iOS and my [elm-expo](https://github.com/akavel/elm-expo) for Android. They're both pre-alpha stage, proofs of concept; in current Elm nomenclature, they're "explorations". They explored a more low level path than elm-native-ui, a bit more in line with what's currently considered the least bad publicly known approach how Elm on mobile could be implemented. But still not sure if that's the *best* path that could exist. They're at super early, pre-alpha stage of development: they demonstrate how a simple "counter app" could work, but they miss a lot of more advanced APIs. Also, none of them are currently actively developed either. I don't know of anything else in Elm world. Out of Elm, if you want to stay in JS-like ecosystem, you could try ReasonML as a more sane language than JS, it has some support for ReactNative AFAIK. However, note that ReactNative is also known to have limitations. On the other hand, going fully native has its own annoyances (e.g. the Android APIs are sometimes crazy retarded). Also you have to maintain separate codebases for Android vs. iOS (though I heart that in RN you still often need to make the code platform-aware anyway). There are some more technologies alternative to RN, especially for writing cross-platform mobile games. RN is somewhat of a current popularity winner, but not the first and probably not the last one in this area. I personally haven't yet found a tech that would hit the sweet spot in this area for me.
Hi, I changed my other cases but this has meant the signature of my update method is incompatible with the Browser.sandbox. I get this error: `This argument is a record of type:` `{ init : Model , update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) , view : Model -&gt; Html Msg }` `But \`sandbox\` needs the 1st argument to be:` `{ init : Model, update : Msg -&gt; Model -&gt; Model, view : Model -&gt; Html Msg }` p.s. here is my broken app code for reference [https://pastebin.com/x9PKGnTD](https://pastebin.com/x9PKGnTD)
Okay, since you are now using commands you need to swap from using \`Browser.sandbox\` to Browser.element\` but \`Browser.element\` expects slightly different things in the record you pass to it. &amp;#x200B; update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) init : () -&gt; ( Model, Cmd Msg ) subscriptions : Model -&gt; Sub Msg &amp;#x200B; The update is dones o you'll need to change your \`init\` signature to the above and change the value to a function, we can now pass it flags if we need to (there is more on this in the guide), we aren't interested in them at the minute so we'll use an underscore to show its unused: &amp;#x200B; init \_ = ( { content = "", contents = \[\], Cmd.none ) &amp;#x200B; Subscriptions are new, again there is a section on these in the guide if you'd liek to find out more but the \`Browser.element\` expects it even though we don't need to use it right now so we can do something similar to before when we used \`Cmd.none\`. You need to need to have this in your file somewhere: &amp;#x200B; subscriptions: Model -&gt; Sub Msg subscriptions model = Sub.none &amp;#x200B; Other than the unhandled case in your \`update\` this should work fine. If you have any more problems just let me know. 
Thank you very much for this prompt reply, I'll try this tomorrow as it's late here.
Yes, it should be doable through ports, it was also suggested to monkey patch xmlhttprequest so it actually calls fetch, which feels kinda hinky but I'm an adult and I can run around the pool with scissors if I feel like it.
What's also interesting is that this person did not run into the guide before you linked it to him in a Reddit comment. Maybe its not easily searchable through certain keywords? Or it should be linked more often on certain other pages?
Monkey patching xmlhttprequest seems safer because if you do all of your http requests through ports you lose all of the safety of the http module.
I think it's because folks search "elm tutorial" and my guide probably does not use that term at all. Sites like `elm-tutorial.org` look good enough that I know many people assume it is the official intro, not knowing it has quite divergent advice. Not really sure what to do about that!
I started looking into elm and had some problems when the website, as homework, asked to add a submit button to the form. Maybe it's eager at that point because in any way I tried to add a button of type submit, the onClick function was always returning error. Stack overflow helped me fortunately :) Probably it would be better to expand a little bit more the Buttons section with a regard to the type=submit button? Just a suggestion
this hearts me. you can do &lt;button type="button"/&gt; to make it not fire up the form.
Man, this could've been useful two weeks ago as I wrote and rewrote an XML parser for Elm 0.19, back before the documentation had been uploaded for Elm/parser (For those curious: Nope, still not done. Currently sidelined while I participate in js13k.)
Thanks. Let us know if you've any feedback or question via [https://github.com/OpenAPITools/openapi-generator/issues/new](https://github.com/OpenAPITools/openapi-generator/issues/new) &amp;#x200B; We also have a public chat room: [https://gitter.im/OpenAPITools/openapi-generator](https://gitter.im/OpenAPITools/openapi-generator)
&gt; when the website, as homework, asked to add a submit button to the form. Could you provide a link to this?
Sure, here https://guide.elm-lang.org/architecture/buttons.html See at the bottom of the page, there's an exercise 
Personally, I'd like to express my joy that the feature was removed! One of the main obstacles for my learning Haskell is the overabundance of custom operators. I agree they are sometimes useful; also fortunately the Elm language &amp; community seemed to have rather sane approach to them. But the danger was always there in the shadows. I've seen sone "good ideas" in C++, in stdlib as well as in the boost library, and they did not do good. The `|&gt;` pipe op is actually the one which makes most others unnecessary. And actually I'm slightly uneasy with the fact that some Elm libraries were treated exceptionally (e.g. parse).
Could you show examples of your use case? More often than not, operators tend to make code difficult to understand by others who didn't write the code. This is part of the reason Haskell adoption is so low. Elm wants to be a great language for everyone, and so I think the removal of most operators makes sense.
My opinion is that removing it for published packages would have been a nice compromise. In our production project using custom operators made our code more readable. I know that there was memory issues with the implementation of infix operators in the elm compiler. So that may be a more significant issue that we realize.
This is one of those things that you miss when you have to go through and remove your usage, but you love when you go to use a library. Yes, sometimes something can be made more elegant with an infix operator - more often than not it just becomes unintuitive, hard to search for, and harder to read in general. 
Let me know how that goes! I've been working on card animations in my spare time. https://experiments.pilatch.com
Why did parsing get special operators? Is it because Evan has been working with parsers for a while now and personally found them useful? Hmm
This is a terrible response. Of course any use case can still work. It just become ugly. And Haskell's adoption is better than Elm's.
&gt; I think we can all agree that "This is a terrible response" to something you disagree with is counter to the goals of the community, no? I disagree. This is a legitimate criticism of an unhelpful response to a legitimate complaint. &gt; Do you deny my point that nearly inscrutable operator symbols hurt Haskell adoption relative to what it could have been? Yes, of course. Though 'nearly inscrutable operator symbols' is a pretty loaded way of putting it.
I've agreed with Evan on most things but infix operators being removed sucks. This kind of keeps us locked into the elm-lang parser combinator library rather than allowing a new one with a similar api. Also string formatting in a similar fashion to url parser (string formatter library) was a very nice way imo to handle interpolation. This also definitely locks us in to evan's url parser. ```elm hello = s "Hello " &lt;&gt; string &lt;&gt; s "!" print hello "world" ``` I do understand the ugly having come from Haskell myself, but blocking use (outside of blocking it in repo packages) does make life a bit harder for some things. Not to mention the removal of the modulus operator, that's pretty standard in most languages. 
Im going to disagree. One of the major issues with Haskell is the profusion of custom operators to the point of toxicity.
It might seem ugly at first but you'll come to love the simplicity. I know I have. \_Most\_ languages don't have custom operators and they seem to be doing just fine.
Then show us a use case where it becomes ugly?
I like reading function names just fine. I went to a presentation on scala and they had a listing of all the freaky scala operators in use among the libraries. I would way rather see a function name than have to deal with an inscrutable quadruple turbofish that just turns out to mean 'append' or something.
Thank you!
&gt; Not to mention the removal of the modulus operator That's nonsensical absolutely
&gt; Do you deny my point that nearly inscrutable operator symbols hurt Haskell adoption &gt; relative to what it could have been ? I probably hurts it, but the effect is infinitesimal compared to other factors, one of them being people clamoring Haskell is too complicated for reason X or Y.
When you need multiple `andThen`. Also lol `Json.Decode.map8`. 
Confused here, what exactly does it do? Generate Elm decoders/encoders automatically??
Why not use `let ... in` to give meaningful names to each of the different "stages" here? let someMeaningfulName1 = append t1 t6 someMeaningfulName2 = append someMeaningfulName1 t2 someMeaningfulName3 = append t3 t4 someMeaningfulName4 = append someMeaningfulName2 someMeaningfulName3 in append someMeaningfulName4 t5
Yeah! "Hello " &lt;&gt; toString name &lt;&gt; ", it is " &lt;&gt; toString temperature &lt;&gt; "outside!" vs. let helloAndName = append "Hello " name helloAndNameAndItIs = append helloAndName ", it is" ... 
Good chance it will get even worse.
Some alternatives: String.concat [ "Hello " , toString name , ", it is " , toString temperature , " outside!" ] Or add some functions like: "Hello" |&gt; space (toString name) |&gt; comma "it is" |&gt; space (toString temperature) |&gt; space "outside!" which allows to avoid forgetting one space like in your `"outside!"` ;] Anyway `++` does not go anywhere.
Dreading updating our linear algebra library. `project !*! toViewSpace !*! toWorldSpace` is considerably more readable than `multiplyMatrices (project (multipleMatrices toViewSpace toWorldSpace)`. This is a completely valid use of infix operators, but I am literally not allowed to think this thought.
Python has operator overloading, C++ has operator overloading, Haskell lets you define custom infix operators, Ruby has operator overloading, Java has operator overloading, F# has operator overloading *and* infix operators, Haskell obviously has infix operators, Agda has custom mixfix operators. Sure, operator overloading is not the same as arbitrary custom infix operators, but in Elm we have neither. I don't buy that most languages don't have custom operators - in fact I can't think of any big languages that don't have some support for custom operators.
Not sure if \`!\*!\` is sarcastic but if it's not, I'd suggest using PureScript where you can do anything you want.
No, it's not sarcastic. `!` means "matrix". So `!*!` is matrix-matrix multiplication, and `!*` is matrix-vector multiplication.
Yes I have, it seems to validate that custom operators are sometimes sorely needed.
Math operators are mentioned in [this gist](https://gist.github.com/evancz/769bba8abb9ddc3bf81d69fa80cc76b1#root-design-goal).
The ability to handle the URL is the only thing separating \`Browser.application\` from \`Browser.document\`. The reason these callbacks are specific to the \`Browser.application\` is that they go together as a package with the \`Key\` you get that enables you to also send the URL change commands.
Just made a servant client API yesterday, see their example: type API = "position" :&gt; Capture "x" Int :&gt; Capture "y" Int :&gt; Get '[JSON] Position :&lt;|&gt; "hello" :&gt; QueryParam "name" String :&gt; Get '[JSON] HelloMessage :&lt;|&gt; "marketing" :&gt; ReqBody '[JSON] ClientInfo :&gt; Post '[JSON] Email then: api :: Proxy API api = Proxy position :&lt;|&gt; hello :&lt;|&gt; marketing = client api Not that bad, but it adds up. 
[removed]
I guess I would write: ``` unions [d1, d2, d3, d4, d5] ``` It is a matter of taste once you master the operators, but until then, not so much. Also they are very difficult to search on google.
This pretty much sums up Evan's notes (https://gist.github.com/evancz/769bba8abb9ddc3bf81d69fa80cc76b1#root-design-goal): &gt; One thing I learned from discovering The Elm Architecture is that it is really lovely to be able to show up in any codebase and know what is going on. I think custom operators detract from that enough that they are not worth it for the whole ecosystem, even if they are great for specific individuals.
&gt; (as google is really not operators friendly). That's why we made our own. https://www.stackage.org/lts-12.9/hoogle?q=%3A%3C%7C%3E
Thank you very much. I didn't know I could search operators in hoogle (I just used it for types).
And this is exactly my point. Asking for a use case is just setting up to dismiss the concern. 
OpenAPI Generator can generate fully functional Elm (and other languages) REST API clients given an OpenAPI specification (v2, v3). &amp;#x200B; For example, if you provide the Petstore spec ([https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/test/resources/2\_0/petstore.yaml](https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml)), you will get the following Elm API clients (0.18 or 0.19 depending on the option you provided) &amp;#x200B; Elm 0.18: [https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/elm-0.18](https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/elm-0.18) Elm 0.19: [https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/elm](https://github.com/OpenAPITools/openapi-generator/tree/master/samples/client/petstore/elm) &amp;#x200B; Please let me know if you still have questions.
Which finishes with &gt; Worth exploring! Which we can't do.
&gt;However, I do not see how completely banning them is useful in any way. So that they don't get complaints about backwards incompatibility of private APIs in the future.
The operator was replaced with two functions, one for modulus and one for remainder, to clearly separate the semantics of the two operations and make the user select the correct one instead of opting to use the operator one like I've seen countless folks do in other languages (some of which map % to mod and some to rem).
They clearly have no problem with this. 
Try to chain two of them, and compare to &gt;&gt;= in haskell . You will notice a difference. 
The reasoning is like this: 1. If you do not hear about a URL change, it is almost certainly a bug. The UI will get out of sync with the URL. 2. Subscriptions can be on or off, allowing you to not pay attention to things. This is good for mouse movements, where you don't want to always listen. If you just combine these directly, the result is a category of bugs becomes possible. If you do it like in the current API, that category of bugs is _not_ possible! For some more info on this, check out [this link](https://github.com/elm/browser/blob/master/notes/navigation-in-elements.md).
That's not easier to understand. You could apply the same argument to addition. Nobody would claim that let someMeaningfulName1 = plus t1 t6 someMeaningfulName2 = plus someMeaningfulName1 t2 someMeaningfulName3 = plus t3 t4 someMeaningfulName4 = plus someMeaningfulName2 someMeaningfulName3 in plus someMeaningfulName4 t5 is more readable or easier to understand than t1 + t2 + t3 + t4 + t5 + t6
Excellent. Thanks. I guess I should have looked there first.
Yeah, exploring this would require access to a repository in github/elm-explorations. &amp;#x200B;
If there is an alternative to what you want to achieve, how is that bad?
You can create the spec manually or using 3rd-party plugins to generate the spec from the code. For example, if the REST API backend is using C# Web API, you can use [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle) to auto-generate the spec. (OpenAPI spec 2.0 was previously known as Swagger spec 2.0)
This has been a major barrier for me in understanding multiple third party libraries. I'm not saying that there shouldn't be overloading, but I find onboarding most of them to be extremely painful, to the point where I spend days trying to understand |: in Json.Extra back before Pipeline.
Here what I use **extensively** in 0.18: (?) f x = f ( toString x ) infixr 0 ? (?.) f x = f ( toString x ++ "px" ) infixr 0 ?. (#) a b = (a,b) infixr 0 # (#.) a b = (a, toString b ++ "px" ) infixr 0 #. Examples: --Svg rect [ x ? 10 , y ? 20 + 30 // 40 , width ? 200 , height ? 300 , strokeWidth ?. 3.1 ] [] --Html A.style [ "padding" # "0px 20px 10px 30px" , "height" #. h , "overflow-y" # "auto" ] --Json.Encode f (x,y,z) = object [ "X" # int x , "Y" # int y , "Z" # int z ] Not only they are very easy to read (these operators are used **extensively** and are everywhere), but also very fast to type. Any suggestions on how to replace them?
There are some answers [there](https://gist.github.com/evancz/769bba8abb9ddc3bf81d69fa80cc76b1#root-design-goal).
&gt; Not only they are very easy to read To me the `?` and `?.` look like a ternary conditional operator. I don't find their actual meaning intuitive at all. It is subjective though. &gt; but also very fast to type I have never found that "typing"` was the bottleneck in programming productivity. I think it may be preferable to favor code reading over code writing to help newcomers and facilitate maintenance. For SVG, if you want to use typed values instead of strings, you could use [`elm-community/typed-svg`](https://package.elm-lang.org/packages/elm-community/typed-svg/latest) (and `&lt;|` as it seems that you want to avoid parentheses): rect [ x &lt;| num 10 , y &lt;| num &lt;| 20 + 30 , width &lt;| num 200 , height &lt;| num 300 , strokeWidth &lt;| px 3.1 ] [] The general `toString` has been removed in 0.19 anyway, now there is [`String.fromInt`](https://package.elm-lang.org/packages/elm/core/latest/String#fromInt) and [`String.fromFloat`](https://package.elm-lang.org/packages/elm/core/latest/String#fromFloat). For `style`, the function prototype [has changed](https://package.elm-lang.org/packages/elm/html/latest/Html-Attributes#style) in 0.19, it would be now: [ style "padding" "0px 20px 10px 30px" , style "height" h , style "overflow-y" "auto" ] which is close to yours. You could also use [`rtfeldman/elm-css`]( https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/): css [ padding4 zero (px 20) (px 10) (px 30) , height (px h) , overflowY auto ] And for the Json object encoding, you could use [`Tuple.pair`](https://package.elm-lang.org/packages/elm/core/latest/Tuple#pair): f2 x y z = object [ pair "X" &lt;| int x , pair "Y" &lt;| int y , pair "Z" &lt;| int z ]
Thanks for suggestions, elm-community/typed-svg looks very tasty. The thing which I like the most about operators in these contexts is that they are always saving me from two pipes: `y &lt;| num &lt;| 20 + 30` is just a `y ? 20 + 30` in operator form, which is only 1 character vs 9 for implementing extremely typical relation. Typing typical things fast is a good thing, and not other way around.
This looks like an editor issue to me. You could add some macros in your editor to type `&lt;| num` or `&lt;| num &lt;|` in one key press. 
Well, readability is still bad, because logic is visually messed up with boilerplate.
`num` and `px` are important for clarity, because they tell explicitly which length unit is used (or none), which is not the case with `?` and `?.`. So to me they improve readability, which is not about conciseness only. Also do you have another operator for `em` and another for `rem`, and... ? If not you will have to use another way to use them, which will make your code mixing operators and functions, thus lowering readability by degrading consistency.
I generally agree on you point. The thing is, that if pattern or function or whatever appears in my code very often (and almost 10% lines of code for `?` is **very** often), I always consider it being an exception from general practice and treat **specifically**, not by default. So my specific decision on `?` was that it dramatically increases readability, my team agreed on it, and here we go. Clarity seem to became even better, because now every number in styles defaults to "px", and if there is "em" somewhere (which appears rarely in **my** case), you immediately see it, as it differs visually from default. We actually tried creating operators for "em" and other stuff, but banned idea almost immediately. Because, yes, your argument is generally correct. To think about it, from all my practice with Elm, I have only 4 exceptions where operators are actually useful. The problem is that they are little bit too much useful to simply scrap them. Like `goto` in Linux source.
This code is exactly the reason why custom operators were removed. It might take a bit more typing right now but in the long run, idiomatically named functions will be easier to understand to whoever reads your code. Elm's vision spans multiple decades into the future (see Evan's keynotes). Code maintainability trumps saving a couple of parentheses.
Please elaborate, how `x &lt;| num &lt;| 20 + 30` is easier to read that `x ? 20 + 30`.
I've run into this before, though under some wildly different circumstances. Everything boils down to the Browser.Document type, which is defined as a type alias of something along the lines of: ``` { body: List (Html.Html msg) , title: String } ``` Unless your view function returns a record of the same shape and types, Browser.document isn't going to like it! Now, for your case, I think the elm-css toUnstyled function returns an *Html msg* type. Now, this is exactly what a regular Elm view function wants in something like Browser.sandbox or Browser.element, but the body field of the Browser.Document alias wants a *List (Html msg),* representing the children of the HTML Body tag. Your solution is perfect, as it transforms the single *Html msg* you have into a singleton *List (Html msg),* ie a *List (Html msg)* with only one element. That is exactly the right solution for this case. There is likely some miniscule performance gain to be squeezed out of elm-css if the package author were to add a toUnstyledList function, but we're likely to never see those gains in practice and it requires another function in the API that may confuse package users like yourself. tl;dr: Your solution works because it is the "correct" one. Good job!
This is very insightful, thanks!
Sure thing! I recommend reading through the docs of any packages you find yourself needing to use, paying special attention to any exported type aliases or custom types. Often the shape of data structures that a package makes visible is key to the pattern of using the package!
Just to provide another solution, I simply used an anonymous function like so: [https://github.com/ryan-senn/elm-snekk/blob/master/src/Main.elm](https://github.com/ryan-senn/elm-snekk/blob/master/src/Main.elm)
And a [PR](https://github.com/elm/virtual-dom/pull/136).
&gt; The replies on his tweet give very good reasons as for why boilerplate is not a good thing. Well he has responded to most of the arguments.
Most of what I read there is basically â€œI learnedâ€, which doesnâ€™t really add any substance.
There isn't quite anything like Elm for the backend, Haskell's HappStack is probably the "best" but high learning curve. F#'s Suave is based on Haskell's HappStack, but is less nice and only slightly easier to learn. Those are the only two decent statically typed fp languages I know that work well server side. Elixir and Clojure also have some quite nice servers. I might perhaps recommend Elixir, they have quite a lot of Elm support, and it's a pretty good experience. Also, another possible option would be not having a backend? Depending on your use case, there are some quite nice cloud services. Tldr; There aren't as good an option as Elm IMO, perhaps Elixir or maybe go serverless.
This isn't a recommendation, but I've started experimenting with Elm (on Node) server. Works nice, as expected :) You can see it here: https://github.com/Janiczek/nu-ashworld/blob/master/src/Server/Main.elm Haven't tried working with PostgreSQL or file IO yet but it would be just another usage of ports (and some npm dependency), as with the HTTP server.
&gt;perhaps Elixir I tried very hard to like Elixir, but the syntax and lack of compiler guarantees puts me off. F# is definitely a good option. Recently they have been promoting Giraffe, which sits on top of ASP.net Core, so you get to inherit all of the perf work MS is putting into that. At an even higher level is Saturn, which aims to be easy. Another fun language to try out is Rust. The web frameworks are pretty early, but the language itself is really neat! The compiler errors and great, and the performance is excellent. Actix-Web, Tower-Web, and Rocket are a few of the popular libs. My day job projects use C# backend, so I can knock those out very quickly. It's gradually adopting functional concepts, so it's really quite nice nowadays.
I would say Haskell, with servant. It is however a bit more complex than Elm, so it will very much depends on the specifics. Generally, I would recommend learning Haskell to every developer, and Elm can be seen as a "gateway drug" to it. There is a seemingly endless list of things to learn, which is exacerbated by what the fact people like to talk about on social media, but you can be productive very quickly, especially with your Elm experience. And most of the things are actually not hard at all once you get to them! There are Haskell packages for generating a ton of boilerplate on both sides (especially json encoders/decoders, and declaring types only once). This is really handy, but will really pay of if you have a lot of endpoints/types. I personally find Haskell's error messages much more informative than Elm's, but I am very much used to them.
&gt; Another fun language to try out is Rust. The web frameworks are pretty early, but the language itself is really neat! The compiler errors and great, and the performance is excellent. Actix-Web, Tower-Web, and Rocket are a few of the popular libs. I feel that Rust is awesome when performance is really paramount, or when you want to have fun with it. It is however a low level language, so it is a lot less productive than something like Elm ... I recently rewrote part of a Purescript thingie in web assembly with Rust, and it was a lot of fun. It was however a lot more work, even though it was basically porting the algorithm ...
I feel like I know Haskell pretty well, but can never learn how to use many libraries due to the vast number of compiler extensions I need to know
I'm surprised nobody's mentioned Rust. It's statically typed, follows the same null-avoidance idioms, has some support for functional programming, and has decent web libraries nowadays. The learning curve is shallower than Haskell, too.
I think Node.js fills a nice back-end role here because of how simple it is. For example, adding websocket support to Node involves downloading a module like `ws` and then using just about the same code you use with the browser's native WebSocket. Also, the server often has the much simpler job of just marshalling data to/from a database while a SPA is much more complex with state, so you don't necessarily need something particularly advanced.
For example, I'd prefer the parser to just look like the latter: |. char "(" |= int |. char ")" vs |&gt; skip (char "(") |&gt; get int |&gt; skip (char ")") 
Ocaml has the Ocsigen framework, which is neat because types are shared between the client and the server, but you have to write all your code in ocaml
Folding code behind indirection isn't always an upside. In your own example, you demonstrate that it makes something easy that was already easy. `x (String.fromInt (20 + 30))` yet you incur the indirection of an operator with a rather arbitrary name. I'd say that your other operators are even worse. `(?.)` folds in the fact that it's a pixel amount. Frankly I'd rather just see something like `width (px (20 + 30))` where it's just `px : Int -&gt; String = String.fromInt n ++ "px"`.
Back in college we had a project and I used Elm for front end and Haskell (Yesod) for back end. Yesod is a full stack web framework, but I would say that it works fine just for the API. I would also recommend Clojure, since it is one of my favorite languages. Also very easy to code and fun. 
Whichever backend youâ€™re familiar with. Otherwise, whichever backend has the best library ecosystem for your task. 
Hum, I feel that you don't need to understand most compiler extension to use libs. Some of them require you declare them (like `RankNTypes` with lens), but you do not have to understand what they are for ... 
I know this won't be popular but I think Rails is a great choice. It's so easy to get a REST api only Rails app going with an Elm frontend. You can bundle it together in a single repo or do what I did and keep them separate. Here's a backend project for Elm Spa Example: https://github.com/gothinkster/rails-realworld-example-app
Don't think Elmers will be happy with Servant (the philosophies seem to be really different) AFAIK the Elm-code generation is not maintained any more (Author moved on) I would start with Scotty and maybe Spock
There is still elm-bridge, but it does not generate requests, only JSON and types. I feel servant is perfect for SPAs, but it even has type level operators, so yeah, might not be ideal here. 
I have just gone through quite a bit of this book and it's pretty good [https://pragprog.com/book/jfelm/programming-elm](https://pragprog.com/book/jfelm/programming-elm) Some of it is in beta since the author is updating parts for v.19 but it's been a great starter so far.
[use multiple style attributes](https://package.elm-lang.org/packages/elm/html/latest/Html-Attributes#style).
Haskell+WAI+Warp work wonders for me. Especially if you scope down requests to task-tailored datatype and then pattern-match against it.
Clojure + spec (validation library) + datomic (immutable database) is my backend of choice. It really is unlike anything I've ever worked with.
It's fine for web, really. The thing is, Rust *can* be low-level *if you need it*, and this seems to have sort of given it a bad reputation. Productivity is good, because the compiler is helpful; and as a bonus, you get speed :)
That's a whole lot of styles to be defining inline, is there a reason you're not using CSS
Elm CSS lets you do stuff like this. The end result is kinda like importing a CSS module in webpack.
I don't understand the image of it being "low level" really. It has automatic memory management, it just happens at compile time instead of run time (mostly). You've got strings, objects (more or less), interfaces, and all the abstractions that make programming in something at a higher level of abstraction easy. It's not like you're twiddling bits, you're just responding to web requests like you would in any well-organized Go or PHP or Python program.
There are some good examples of where you woud want to have infix operators: - You implement dates and you need (&lt;=), (&lt;), (&gt;=), (&gt;) on your types. - You implement trees, non empty lists and other data strucutres and (++) is simple, consise and well known. Imagine i want to sum integers from `1` to `5`. I much prefer writing ```elm 1 + 2 + 3 + 4 + 5 ``` than ```elm plus (plus (plus (plus 1 2) 3) 4) 5 ``` and what names could be meaningfull for intemediate variables? ```elm let sumFrom1to2 = 1 + 2 sumFrom1to3 = sumFrom1to2 + 3 sumFrom1to4 = sumFrom1to3 + 4 in sumFrom1to4 + 5 ``` Let me give you an example: ```elm let hoursInADay = 24 minutesInAnHour = 60 secondsInAMinute = 60 millisInASecond = 1000 in hoursInADay * minutesInAnHour * secondsInAMinute * millisInASecond ``` 
Exactly. Once you get the hang of writing correct Rust, more of your programs will come out correct in general on the first go. It's fun.
I didn't try elm-style-animation, sorry. :( What I can tell you is that nothing worked as expected if there was any nesting in the DOM. So I had to have one parent element, which I called the table-top, that all the cards moved around on. My approach to handling animations is abstraction via custom elements, or web components if you prefer that term. https://www.npmjs.com/package/pilatch-card#usage That's the custom element I use for all my cards. To animate a card being flipped, Elm's view function will add or remove an `up` HTML attribute. There is other CSS on the page that understands the concept of the table-top, and when CSS classes are added or removed from `pilatch-card` elements that will cause them to animate to different spots on the page. For instance to move a card from a player's hand to the middle of the table, I would remove the `up` attribute, and add a CSS class of `placed-card-area`. The CSS does all the animation. Elm just worries about how to render HTML. The big gotcha is that after cards move around visually, you need to sneakily update your model to match how things _look_ on the table. Because you have CSS transitions that do this, you need to perform a transition-free re-render. So your CSS needs shut off all transitions when the cards have to be rearranged. I wouldn't be surprised if there were a smarter way. This works for me and I'm sticking with it until I can get my game playable. :)
Looks like those packages haven't gotten the upgrade love to 0.19 yet.
`elm-css` will generate a class name based on the hash of the style and define the class in a `style` node upper in the DOM tree to avoid duplication. This is not the same as using the OP `style` that will be duplicated in the DOM as many times as it is used.
Approved. https://github.com/elm/virtual-dom/pull/136#pullrequestreview-154027199
I don't think this would work (at least not "out of the box"). ReactNative has its own set of "native" components or other components you've exposed (either built up from them or implemented the native code required to expose a component to it). Elm isn't going to know about them by default. There's also some more differences (styling, navigation, animations, etc.) between it and standalone React. One way I could see it working is if you reference custom node elements in your Elm code, then in your react code you interpret the returned list of components and convert them to the ReactNative components. 
I recommend checking out \[elm-ui\]([https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/)) to handle all your styling needs.
Do you happen to know whether it handles absolute positioning and works with SVG?
Total noob question: I am trying to apply a List (String, String) as a style to an element. Here is what I have: ``` import Html.Attributes exposing (style) styles = [ ("display", "block") , ("border", "none") , ("margin", "0") ] unpackStyle: (String, String) -&gt; Attribute Msg unpackStyle tuple = let (key, value) = tuple in style key value view : Model -&gt; Html Msg view model = div [ List.map (\s -&gt; unpackStyle s) ] [] ``` And it errors out saying: ``` This argument is a list of type: List (List (Attribute Msg)) But `div` needs the 1st argument to be: List (Attribute msg) ``` The error makes sense to me, but as a FP newbie, have no idea what to do. Any pointers appreciated!
Your view function needs to be a bit different: view model = div (List.map unpackStyle styles) [] First, `List.map` already produces a list, so you don't need square brackets around it (otherwise you're making a list of lists). Second, you didn't pass any list to `List.map` so it's only partially applied. 
It does work with such! It has a special Html element for it. It doesn't do absolute positioning, but provides alternatives. If you still really need it, (but I've find I don't) you can use it directly with Html attribute style.
&gt;First, List.map already produces a list, so you don't need square brackets around it (otherwise you're making a list of lists). &gt; &gt;Second, you didn't pass any list to List.map so it's only partially applied. &gt; &gt;Third, unpackStyle is already a function of one argument, so you Thanks, that clears up my questions!
I just started learning Elm today. I'm following the [Guide](https://guide.elm-lang.org/) and, while I find it generally clear and accessible, one thing's bugging me. I'm following the examples in the *The Elm Architecture* section, and they're explained part by part, except that some parts are not mentioned, and file structure or what you'd do to run these is not discussed. I want to follow along by writing them, maybe while making some idiosyncratic changes, and running the code, then figuring out when I made any mistakes by reading the compiler output. It seems like this part in the guide was not conceived to be followed along in this way, which seems weird to me given that the previous *Core Language* part compelled the reader to try stuff out in the REPL. So I guess what I want to ask is first, is there any good reason to this? And second, if I want to follow along while coding, is there any better way than: clone the repository, make a new file in `examples/`, write the code part by part, add in whatever was left out, then run `elm reactor`?
Go has absolutely amazing http in the standard library. It's also very simple to get into. It's also what YouTube, twitch and cloudflare uses so you know it's fast I've used the two together and been having great fun
No grumps against this subreddit, but in my own newbie experience you can get answers to stuff like this pretty quickly on the beginner's Slack channel. &amp;#x200B; [https://elmlang.slack.com/messages/C192T0Q1E/](https://elmlang.slack.com/messages/C192T0Q1E/)
I'll check it out, thanks!
[removed]
Just started learning Elm, and I'm wondering if I'm supposed to see an elm debugger thing on my pages when compiling them with elm reactor? My programs are made with Browser.sandbox if that makes any difference. Turns out the debugger appears when I manually compile with the --debug flag, but not when using elm reactor.
In case you are not aware, OCaml ([Bucklescript](https://bucklescript.github.io/)) may be the perfect option for you: * On the frontend, you have [bucklescript-tea](https://github.com/OvermindDL1/bucklescript-tea). It follows the Elm api very closely. * On the backend, you have [multiple options](https://discuss.ocaml.org/t/about-web-development/154), including NodeJS+Express while still staying with OCaml (see [bs-express](https://github.com/reasonml-community/bs-express)) * You can think of OCaml as a superset of the Elm language. It offers all the features of the Elm language plus a lot more.
@turner in the Slack channel helped me with this answer: ``` import Url.Parser as Parser exposing (Parser, oneOf, s, map, top) -- Define your routes and your parser type Route = Home | About | NotFound parser : Parser (Route -&gt; a) a parser = oneOf [ map Home top , map About (s "about") ] -- Create a helper function that converts a url to a route using the parser fromUrl : Url.Url -&gt; Route fromUrl url = Maybe.withDefault NotFound (Parser.parse parser url) -- Inside UrlChanged, you could save the route to the model UrlChanged url -&gt; { model | route = fromUrl url } -- Then decide what to show based on the route view : Model -&gt; Html msg view model = case model.route of Home -&gt; viewHomePage About -&gt; viewAboutPage NotFound -&gt; viewNotFoundPage ``` This is the code I have so far: ``` import Browser import Browser.Navigation as Nav import Html exposing (..) import Html.Attributes exposing(..) import Url import Router exposing(Route(..), routeParser, fromUrl) -- MAIN main : Program () Model Msg main = Browser.application { init = init , view = view , update = update , subscriptions = subscriptions , onUrlChange = UrlChanged , onUrlRequest = LinkClicked } -- MODEL type alias Model = { key : Nav.Key , url: Url.Url , route: Route } init : () -&gt; Url.Url -&gt; Nav.Key -&gt; ( Model, Cmd Msg ) init flags url key = ( Model key url Router.NotFound, Cmd.none ) -- UPDATE type Msg = LinkClicked Browser.UrlRequest | UrlChanged Url.Url update: Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of LinkClicked urlRequest -&gt; case urlRequest of Browser.Internal url -&gt; ( model, Nav.pushUrl model.key (Url.toString url) ) Browser.External href -&gt; ( model, Nav.load href ) -- UrlChanged url -&gt; -- ( { model | url = url } -- , Cmd.none -- ) UrlChanged url -&gt; ( { model | route = fromUrl url }, Cmd.none ) -- SUBSCRIPTIONS subscriptions : Model -&gt; Sub Msg subscriptions _ = Sub.none -- VIEW view : Model -&gt; Browser.Document Msg view model = case model.route of Router.BlogPost _ _ -&gt; viewBlogPage model Router.BlogQuery (Just _) -&gt; viewHomePage model Router.BlogQuery Nothing -&gt; viewHomePage model Router.NotFound -&gt; viewNotFound model type alias Page msg = { title: String , body: List (Html msg) } buildPage: String -&gt; List (Html msg) -&gt; Page msg buildPage title body = { title = title , body = body } header: Html msg header = div [] [ p [] [ text "Header" ] , ul [] [ viewLink "/home" , viewLink "/blog/1/test"] ] footer: Html msg footer = div [] [ p [] [ text "Footer" ] ] template: Html msg -&gt; List (Html msg) template content = [ header , content , footer] viewHomePage: Model -&gt; Page msg viewHomePage model = buildPage "Home Page" (template (div [] [ p [] [ text "Homepage" ] ])) viewBlogPage: Model -&gt; Page msg viewBlogPage model = buildPage "Blog" (template (div [] [ p [] [ text "Blog Page" ] ])) viewNotFound: Model -&gt; Page msg viewNotFound model = buildPage "Not Found" (template (div [] [ p [] [ text "Not Found" ] ])) viewLink : String -&gt; Html msg viewLink path = li [] [ a [ href path ] [ text path ] ] ``` 
Thank you! And sorry for posting this in the wrong thread. Was aiming for that beginners questions one.
Can auth0 be configured to use cookies instead of `localStorage`?
Change your data model that you're padding from js to elm, and include enough info that you can handle a message without needing to know anything else about what's happened other than the message at hand. 
Total beginner here. Is elm-make still present in 0.19? I'm having issues finding it after multiple installations. Also some plug-ins require elm-package.json, which you get after command "elm package install" in the project dir, but the new "elm init" creates just an elm.json file. Is there any difference or am I doing something wrong? 
&gt; The learning curve is shallower than Haskell, too. As a data point I found the learning curve of Haskell shallower than of Rust.
elm-format and linter-elm-make for example, plugins for atom 
NPM is probably the easiest way: npm i -g elm@0.18 You can also use NPX (comes with node 8.2 I believe) to run a command from a specific version without installing: npx elm@0.18 make
maybe you could use 0.19 with a port-based implementation for websocket? it does't look like a lot of work to me!
Funny you should mention this, I just had to hunt down 0.18 for an old project after upgrading to 0.19 to check it out. You can get the elm binaries for 0.18 here: [https://github.com/elm-lang/elm-platform/releases](https://github.com/elm-lang/elm-platform/releases)
[removed]
To download: https://github.com/elm-lang/elm-platform/releases (but it's easier to use npm) For packages documentation and the official guide, your can use: https://dmy.github.io/elm-0.18-packages/ (unofficial)
You can use Elm with Docker. See this light-weight image &lt;https://hub.docker.com/r/wunsh/alpine-elm/&gt; and documentation [here](https://github.com/wunsh/docker-alpine-elm).
Rust has a lot of the guarantees that Elm provides but learning curve can be high. For pure simplicity in rust look at the warp framework. It's going to get wrapped into tower at some point but is great as a standalone server. If you are familiar with ruby and Sinatra, I would loo into Crystal and the kemal framework. Also fairly simple but philosophically different from Elm.
Does the elm-format plugin require an elm.json or elm-package.json? I was under the impression it just delegates to the `elm-format` command. It does have an Elm version in the settings, but I think that's just passed to `elm-format` as a flag. linter-elm-make is not updated for 0.19 yet. In the meantime, you can use [elmjutsu](https://github.com/halohalospecial/atom-elmjutsu) (which I would highly recommend using anyway!). It recently got the ability to display errors, in addition to the other stuff it does.
What's Alpine?
Alpine is a super lightweight base system with only needed dependencies installed. this let's the image be much smaller than when it would be based on Debian or something else.
thanks a lot! maybe you could add how/if you can get tooling like elm-format working from outside the docker-container?
At the moment there is no way to use `elm-format` on Alpine, AFAIK. But you can use it on Ubuntu or Debian base images. If you want, I can write how to do this. Later I can try to add this tool to my Alpine images.
I had the same. Unfortunately, I couldn't find a solution, so I moved to webpack.
[removed]
Oh, you'll also want to make sure you have the latest elm-format installed, separately from the Atom plugin!
Doesn't look like it: https://github.com/elm/compiler/blob/904fc5a1822c29a22f647456cda5b069c09795d2/ui/terminal/src/Develop.hs#L44-L56
[elm-live](https://github.com/wking-io/elm-live/blob/master/Readme.md) is a nice alternative to `elm reactor` that can take any `elm make` option (particularly interesting for `--debug` and `--output`), supports port/interface binding and pushstate (great if you do an SPA with routing). I find it very useful and simple.
Maybe checkout elm-ui. But I think it is a little low-level.
The git repo seems to say it won't be ported to 0.19 but at the same time has a branch for 0.19 and calls for contributions, is that actually usable on 0.19 yet ?
Ho, that wasn't what I was looking at, indeed. Thanks, I'll try it out
Looks good! Amusingly, I was looking for guides on this just this morning. It just so happens I came up with almost the same solution! Love how Elm forces you to make the "right" decisions in writing software.
mdgriffith/elm-ui is extremely well though as a user interface foundation (check out a [presentation of its beginnings](https://youtu.be/NYb2GDWMIm0) under another name). But I guess you are probably looking for some guidance. You might be interested in [https://github.com/lucamug/elm-style-framework](https://github.com/lucamug/elm-style-framework) which is based on elm-ui.
Why not use a css framework like Bulma?
I've been using elm-ui a bit, I miss the pretty by default of elm-mdl but elm-ui is easy to use and does the job while I develop the rest. I'll just get someone else to rewrite my views when I'm done I guess !
https://package.elm-lang.org/packages/surprisetalk/elm-bulma/latest/
Hi all I would like to know, if I resolve the type correctly. The example is from [https://package.elm-lang.org/packages/elm/url/latest/Url-Parser#map](https://package.elm-lang.org/packages/elm/url/latest/Url-Parser#map). The type signature of \`map\` is: `map : a -&gt; Parser a b -&gt; Parser (b -&gt; c) c` The example is: `type alias Comment = { user : String, id : Int }` &amp;#x200B; `userAndId : Parser (String -&gt; Int -&gt; a) a` `userAndId =` `s "user" &lt;/&gt; string &lt;/&gt; s "comment" &lt;/&gt; int` &amp;#x200B; `comment : Parser (Comment -&gt; a) a` `comment =` `map Comment userAndId` &amp;#x200B; Then I resolve the type from: `map Comment userAndId` as following: `Comment -&gt; Parser (String -&gt; Int -&gt; Comment) -&gt; Comment -&gt; Parser (Comment -&gt; c) -&gt; c` The \`b\` from \`map\` becomes to \`a\` right? (edited)
&gt; Should the syntax for using infix operators as prefix operators exist? ((+)) Yes. It's not a difficult concept to understand and comes in handy for the reasons you mention. &gt; In retrospect, was it a good idea to have all functions be curried by default? Yes to the nth degree. This is a core aspect of functional programming that permits reusability by default. Removing these features from the language may permit beginners to fully understand the language 10-20 minutes faster, but they will make their long-term experience with the language far, far worse. Especially the second item. This would be a very bad tradeoff. The question is what are we optimizing for? The very nascent stages of learning functional programming, or the hopefully much longer span of time where it's actually put it to use. &gt; Why do constructors and types look so similar? In type Tree = Leaf | Node Int Tree Tree, Node is a constructor being defined, but Int is a type from elsewhere. And yet they're just sitting next to each other in a line of capitalized words. Can you expand on what the warrant is to why capitalized words next to each other are any more confusing than any other programming concept where two like things are next to each other? What is it difficult in contrast to? What makes GADTs so substantially better that it would be worth changing every codebase to fit it? I would contrast most of these arguments to a language like Ruby that has pretty widespread adoption. In Ruby there are often (frustratingly, IMO) many ways to do the same thing, and yet I don't think it's seen as a "difficult" language to understand. In functional languages there are *different* ways of doing things you'd do in OO or imperative language but that doesn't necessarily make them more difficult. I would generally be skeptical of any solution that involves making the language be closer to non-functional programming languages, although it's good to be mindful of how newcomers are approaching the language/functional programming and the best way to communicate these new ideas to them.
Is there anything like array-extra? 
Not sure why all the downvotes. You bring up some good points which at least warrant discussion
Tried it just now, it does look nice but I can't figure out how to make anything fit together. Turns out elm-ui solves a problem I didn't know I had with it's layout system !
&gt; Can you expand on what the warrant is to why capitalized words next to each other are any more confusing than any other programming concept where two like things are next to each other? In Elm, types are generally capitalised, while functions are not. A type constructor is a function (or even a value) rather than a type so it's odd that it is capitalised. On the other hand, most functions can't be used in a pattern-matching context whereas type constructors can. From this I can understand the objection to a type constructor looking exactly like a type. &gt; I would generally be skeptical of any solution that involves making the language be closer to non-functional programming languages For the specific objection of confusion between types and type constructors, this does not apply e.g. OCaml formats them differently (though it conflicts values and types instead by writing both snake_cased).
Those are quite interesting points in my opinion. &gt;Should the syntax for using infix operators as prefix operators exist? (`(+)`) I wouldn't mind having to redefine some of these operators if I need them infix, like `prepend` mentioned here for example. The comparison operators or any non commutative operator really are not good friends of this syntax. &gt;Why do constructors and types look so similar? Fair point. Since the `'` (prime) cannot be used anymore for variables names, maybe it could be used for "variants" (new 0.19 terminology here). For example: type Maybe a = 'Nothing | 'Just a &gt;In retrospect, was it a good idea to have all functions be curried by default? For this however, I'm very much in favor of curried by default. Having the space separating arguments and function application produces a code that is way cleaner. That is one of my favorite elm features.
I'm not the one who did it for our game so I don't know much, but I know that we used Howler.js to emit the sounds through ports. It has been working pretty well. Basically, we have in `index.html`: app.ports.sounds.subscribe(SoundManager); And a file `soundManager.js` which contains: ;(function SoundManager() { const sounds = { bullet: new Howl({ src: ['assets/sounds/bullet.wav'] }), collision: new Howl({ src: ['assets/sounds/collision.wav'] }), goal: new Howl({ src: ['assets/sounds/goal.wav'] }), }; window.SoundManager = function (name) { const sound = sounds[name]; console.assert(sound != null, `Unknown sound: ${name}`); sound.play(); }; }());
Hey that's great! Thanks!
as it so happens, yes! [https://package.elm-lang.org/packages/elm-community/array-extra/latest](https://package.elm-lang.org/packages/elm-community/array-extra/latest)
Here are the signatures, as I understand them, with the same type variables in each: map : a -&gt; Parser a b -&gt; Parser (b -&gt; c) c comment : Parser (Comment -&gt; c) c Hope that helps!
&gt;Can you expand on what the warrant is to why capitalized words next to each other are any more confusing than any other programming concept where two like things are next to each other? What is it difficult in contrast to? What makes GADTs so substantially better that it would be worth changing every codebase to fit it? &amp;#x200B; type A = B C D | E F In this code block, the `B` and `E` are a completely different type of thing to the `C`, `D`, and `F`, but the syntax makes it look like they are the same type of thing. This can be confusing. For example, look at this [StackOverflow post](https://stackoverflow.com/questions/34093092/how-to-cast-union-types-elm?rq=1). The user wanted something that could be of type `A` or type `B`. Elm's syntax lead them to (incorrectly) write `type Content = A | B`. &amp;#x200B; A clear, but possibly too verbose, syntax would be something like this: type A = B containing C, D | E containing F This clearly separates `B` and `E` from `C`, `D`, and `F`, making it more obvious that they are different types of things. &amp;#x200B; In GADT syntax, the declaration looks like this: type A where B : C -&gt; D -&gt; A E : F -&gt; A Again, it separates `B` and `E` from `C`, `D`, and `F`. I wasn't saying that GADT syntax is the best solution, only that it avoids this particular problem. &amp;#x200B;
\&gt; In retrospect, was it a good idea to have all functions be curried by default? Wow, I've never heard anyone question this before, but this is really interesting to think through! (It might be moot for Elm at this point, because of how big a breaking change it would be, but it's still interesting to consider.) Currying is a convenience at best - clearly Elm would still \*work\* if all Elm functions weren't curried, just like how Elixir and Clojure don't have it and it's fine - so it's not an unthinkable change. What would removing currying get us? * More helpful error messages around function argument mistakes, I'd expect. These are currently some of the hardest errors to understand, because they often end with "the type needs to be \`Foo\`, but instead it's \`Bar -&gt; Foo\`" whereas if you had to specify exactly the same number of arguments every time, it could immediately say "this function is being passed the wrong number of arguments," which would save a lot of time puzzling through those errors. * More explicit code. Certainly it is more obvious that \`(\\x -&gt; foo bar x)\` is a function than the (currently) equivalent expression \`(foo bar)\`, even if the latter is more concise. * I personally have a large sample size of teaching Elm to beginners, and currying is right behind JSON decoders as the thing people struggle with the most. All else being equal, Elm would be significantly easier to learn if functions were not curried by default. * Removing currying could facilitate other language features that could be nice in different ways. For example, there are complications with introducing named arguments and optional arguments if all functions are curried. (Not saying those are necessarily good features to add, but they're the first examples that come to mind.) What would it cost? * I do things like \`List.map (foo bar) stuff\` all the time. It wouldn't be a disaster to have to write \`List.map (\\x -&gt; foo bar x) stuff\` instead, but I assume I would miss it. * For \`|&gt;\` and \`&lt;|\` to continue to exist, they would probably have to be language keywords like they are in Elixir (keywords which would curry the functions they receive on the fly) instead of being vanilla operators that rely on pervasive currying, the way they do today. This seems like a minor downside as far as I can tell, but I could be wrong about that. * A **lot** of existing code would break. \`elm-upgrade\` could probably automate a lot of the fixes, but it's unclear how nice the resulting code would be.
Probably because OP is trolling.
&gt;Should the syntax for using infix operators as prefix operators exist? (`(+)`) I've personally stopped using it, and wouldn't mind if it were gone. I don't think it brings much to the table, and as you noted, it is sometimes a footgun in cases like `(&lt;) 0`.
&gt; Clojure don't have it That's likely because Clojure uses variable arity. `+` for instance may take any number of arguments. `(+ 1 2)`, `(+ 1 2 3 4 5)` so it'd be hard for it to know when you are done adding args. &gt; It wouldn't be a disaster to have to write `List.map (\x -&gt; foo bar x) stuff` instead, but I assume I would miss it. We could do like Clojure there too: `(def inc-by-2 (partial + 2))` `(inc-by-2 3) ; =&gt; 5` 
Wow, this is one of the most thought-provoking posts I've ever read on `/r/elm` and it's sad to think that anyone would downvote it.
I mean the ocaml solution is a less verbose (but potentially confusing to newcomers) version of your first example `type t = | B of c * d * a | E of f`
Which part, that it is not optimized for experienced FP programmers (missed an 'r' ...), or where I think the design focus was?
&gt; If `Maybe` were defined like this, though, I imagine the connection would be clearer: This! I now have a very limited experience teaching Elm to newcomers, and this has been a big pain point in all the cases. My sample size is 2 though ;) Obviously, as that is `GADTs` syntax, this would involve supporting types that are a bit more complex.
Entertaining and relateable blog post. Thanks ðŸ‘
Both parts. ðŸ˜„
&gt;or we just have different standards to what's a garbage pile or what. heh, perhaps... it looks like you got a lot farther than me (including using elm for the data-viz stuff I guess?). &amp;#x200B; I think starting from a template is really useful â€” although if I had done it from that SPA template I might have gotten a bit overwhelmed, and it would have taken me a while to carve out what I needed. But, as far as I know, Richard Feldman's single page application is the biggest/most well known example out there for SPA related stuff. I definitely looked it over -- it's quite impressive, and I was particularly interested in how he broke up the update function and aggregated it in the single file. I found it a bit tricky to glean how to go about doing things just from reading the code â€” but then again, it's just me hacking away. &amp;#x200B; Thanks for reading :)
Glad to hear it was of some use! Much appreciated. 
I think that this is a good language for beginners : lots of focus on docs, and making things clear. Tooling is efficient and simple, especially compared to the javascript ecosystem. As for the other part, have you tried doing any of these things: * a form with 10 text fields? * updating nested records? * a dictionary with your own type as keys? * abstract over `update` so that you do not have to write the same code over and over again? * have a child component that needs to convey information to its parent? * having several "zoom levels" over the same model, with editors that work over part of that model and *then* having to pull the original data structure back together to send it back to a server? * having inter-dependent "childs" in a model? All of those use cases range from annoying to impossible in Elm. The usual answers in the Elm ecosystem seem to be "helper functions" and "you should not do this in the first place". But this results in very repetitive code. But these pain points could be "solved" at the expanse at adding more features to the language, which would move the cursor away from beginners and more towards experienced FP'ers, and "possible nightmarishly abstract codebase".
&gt; adding more features to the language, which would move the cursor away from beginners and more towards experienced FP'ers I've only been working as a full-time Elm professional for 4 years so far, so maybe I'm not experienced enough yet, but right now I selfishly appreciate Elm's simplicity and would be upset if it were to add more language features to "fix" those use cases you mentioned - with the one exception of custom types for dictionary keys. I guess we'll have to agree to disagree that adding features to a language makes it nicer for experts. ðŸ™‚
\&gt; â€¦I found updating nested records to be annoying. We are all waiting for #635 listed in [https://github.com/elm/compiler/issues/1375](https://github.com/elm/compiler/issues/1375)
&gt; I guess we'll have to agree to disagree that adding features to a language makes it nicer for experts. ðŸ™‚ I don't think we disagree that much! I mean that adding features will make some code more elegant, and sometimes even possible, at the cost of requiring more learning, and sometimes a higher cognitive load. Experienced users, (and experts!) might like either side of the trade-off. Obviously, Evan is a proficient Haskell developer, and does not have Stockholm syndrome. But I *do* have it! I can't figure out how leaving out typeclasses or something equivalent is a good except in the very short term. Many types have `map`, but it is not obvious they is a fundamental property behind it, and that it is possible to reason about it on its own. Even worse, `Dict.map` is not like the others, so this opens the door to random `map` functions. Worse, json decoders and parsers have the same structure, but why don't they have the same functions? Why do I need an extra library (`elm-decode-pipeline`, which I am pretty sure you are familiar with ;) ) in one case, and why do I get access to `|=` and `|.` in the other? Are they the same thing? While `map2` is a nice name, who will recognize it is a fundamental building block for chaining decoders? To me, this is denying a huge expressive power that would have no cost at all, because you already have all the same fundamental stuff in many types (`map` for functor, `map2` for applicative, `oneOf` for alternative, and `andThen` for monad), and hiding this does not seem to make it any easier to learn (see how json decoding is a stumbling block).
I like that GADT syntax. But what about: type A = B : C -&gt; D -&gt; A | E : F -&gt; A For me this makes it much clearer that the created constructors are actually functions. 
&gt; I do things like List.map (foo bar) stuff all the time This could be resolved with a bit of syntactic sugar, e.g. `foo(a, _, c)` could be equivalent to `\b -&gt; foo(a, b, c)`. This would also keep using pipes easy. `type alias Point = { x : Int, y : Int }` could then produce `Point : (Int, Int) -&gt; Point` `decode-pipeline` could still work almost the same way if `Point(_, _)` is understood to mean `Point : Int -&gt; Int -&gt; Point`, but that might be a bit confusing.
&gt;might be the most clear initially, though perhaps containing could be replaced with has to make it more terse. Check out the ocaml/F# syntax of using `type A = B of C * D | E of F`
It is easy to add restrictions to `GADTs` that make them have exactly equal power to normal custom types, so using `GADT` syntax does not require supporting more complex types. Whether we would want to support the extra power of `GADTs` would be a separate discussion. (Note: This is why I linked the `GADTSyntax` extension, rather than `GADTs`.)
Yep, I use Elm make to create a JS file, and then include that as a script in my html view. Iâ€™m using Ruby (Sinatra) as my backend and it works great.
Elixir.
Mainly Erlang/Elixir, because I love the Erlang VM. I miss static typing though, so I am also interested in Haskell.
Also worth having a look at the source code for the elm site. It is also a SPA but takes a slightly different approach in some places to Richard's excellent example. I used bits of both to help get started writing my own SPA. I am not very far along myself. Great work so far.
Go+elm. About as modern as It gets
If you're willing to try something new then mdgriffith/elm-ui is a complete departure from HTML and CSS. It has slider as a premade function
Ruby on Rails, Golang though Iâ€™m in the process of replacing a lot of endpoints with Postgrest and I think my next big project will use Haskell as it made my life so much easier on a non-API project.
That's interesting. I would have thought that anyone's that's sold on Clojure would be using Clojurescript on the front end. May I ask why you chose Elm over Clojurescript? 
I'm most comfortable with Javascript or Ruby. However, I want to make a backend with Rust, just for a laugh. 
I was sold on Clojure before discovering Elm. Elm was the first language that I've tried where I actually liked static typing. So I'm been doing Elm for a while but haven't really felt the need to replace Clojure. :)