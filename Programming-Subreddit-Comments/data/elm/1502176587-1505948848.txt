Disregarding a language based on its name does not seem very wise. It has everything you just mentioned Elm is lacking. 
Ah, yes. That looks like a bug in the ports implementation but not an issue with the ports architecture.
&gt; A half decent FFI to JS, for example, would be nice. Purescript definitley has this. It has far better code-gen than Elm does, and it's much easier to nest foreign code within it, and nest it inside foreign code.
Would love to hear more of this kind of discourse. An understanding that the limitations _do_ exist and that they do cause awkwardness, but also that care must be taken to judge the best way forward to maintain the nice qualities are maintained. I think the frustration comes when the response is met with dismissal, and when it is unclear what the design process is, and what the bus factor is on that process.
&gt; There are practical considerations related to deployment of large apps that take and will continue to take the design and development time of Evan in the short to mid term. Has there any thought been put into how to scale up the community processes so that more stuff can be taken off Evan's plate? It is a bit concerning that there is so much blocked on him.
Elm is opinionated - it's a taste thing - I like the debate, but it's a bit like coming onto a coffee forum and telling everyone it's not as delicious as tea : ) Pun intended ; )
&gt; Problem with synchronization of cursor position in input, because how Elm uses requestAnimationFrame This is an implementation bug. It will/should be fixed. &gt; No local state for functions (meaning sth like components) This is part of the paradigm that is pure functional programming. You have to think in expressions rather than statements. It's not something you do overnight, like most programming paradigms, but once it clicks you'll understand a whole new world on how to build simpler, safer and more maintainable codebases. &gt; Ports don't support everything javascript does What are you specifically looking for? &gt; Probably no rich text editor written in Elm &gt; Probably no code editor written in Elm You can be the one to do it :) Or at least, write bindings to a pre-existing one.
&gt; This is an implementation bug Still a problem &gt;&gt; Ports don't support everything javascript does &gt; What are you specifically looking for I can't recall now what is the problem but remember there is with automatic conversion. &gt; This is part of the paradigm that is pure functional programming I know, but this is nontheless pitfall when trying to use elm-mdl &gt; You can be the one to do it Yeah, and then dwelve into Native code :/
&gt; Still a problem Not a pitfall of the language. It's also only been recently filed, I'd guess it won't take long until it's fixed. &gt; I can't recall now what is the problem but remember there is with automatic conversion. Ports support all types available in JSON. As long as you prepare the data type properly in JS land, you'll get it correctly on Elm, which is the standard for all FFI implementations. If you know an exception to this, please bring it up. &gt; I know, but this is nontheless pitfall when trying to use elm-mdl The library follows The Elm Architecture so you have to manage the state on your own logic, and the things it does are really stateful. If you wanted to write an implementation that subverts this architecture and keeps state outside of your application (communicating with commands/subs instead) you can do so. I went for the easier route and simply dropped it in favor of simpler, pure solutions. &gt; Yeah, and then dwelve into Native code :/ Not if you stick to pure Elm. If you want to write bindings, then yes, of course. But that goes for all compile-to-JS languages, if the abstraction doesn't exist you'll have to write native code to get there; the alternative is to write everything in JavaScript :P.
&gt; All of these claims about Elm having 'no production runtime exceptions' are because Elm has specifically avoided throwing errors I don't see how this would introduce runtime errors. I was talking about compiler errors in the case of undetermined type and of course a generic `fromString` would produce a Result. &gt; Elm is intentionally simpler than what is possible; it isn't a result of ignorance or inability to implement these features. I know all these. I too appreciate the simplicity of the language. &gt; What you are asking for requires adding a complexity to the language which has been considered and rejected. If you are talking about typeclasses, as far as I understand it, this is an undecided topic. The answer is not "never" but "not until we can figure a good approach". 
&gt; Has there any thought been put into how to scale up the community processes so that more stuff can be taken off Evan's plate? Yes. There have been discussions. It appears that what we have now is the best that can be done considering Evan's vision for the language. &gt; It is a bit concerning that there is so much blocked on him. There is no perfect solution. There are trade-offs to each approach. 
&gt; Not a pitfall of the language I'm not talking only about language but as already written: "things that aren't mentioned on elm homepage but you can encounter them". &gt; I went for the easier route and simply dropped it in favor of simpler, pure solutions. Me too, but that's the consequence of it being hard to use imo, which comes from where? functional programming? I don't know &gt; Not if you stick to pure Elm Not sure If I won't have sync problems like in https://github.com/elm-lang/virtual-dom/issues/107
&gt; Ports support all types available in JSON. As long as you prepare the data type properly in JS land, you'll get it correctly on Elm Actually, JSON /= JSObject. The issue @rofrol mentioned is happening with Date: while Date is a JS type, it doesn't exist in JSON http://www.json.org/ I also find it disappointing, but as you correctly said: ports are for JSON.
&gt; I'm not talking only about language Look, it *is* a problem, all bugs are. But unless bugs aren't getting fixed or are abnormally high in number this isn't what's traditionally called a "pitfall". The one thing you mentioned that can be considered a "pitfall" is state management; where you're either forced to do it through TEA (not a great fit for stateful operations with cross-cutting concerns) or natively with Commands, which are easy to understand when treated as a black box but not as clever a solution as Haskell monads. And since you brought it up again: This is a bug, not an irremediable design failure that requires breaking backwards compatibility. It will get fixed. You can certainly develop a rich text editor either with the workaround mentioned in the issue tracker or dropping an occasional character when your system's overloaded; by the time you get to production readiness it'll most likely be fixed already.
Indeed, I mentioned JSON on purpose. It's midly annoying in practice but since we're talking about FFI, it comes with the territory. Just need to serialize it before passing it off to Elm so it can be parsed.
&gt; https://github.com/elm-lang/virtual-dom/issues/107 This is a **known bug** that is there for **years**, and every time it is brought up the answer is always that it will be fixed, and it's not the only one. 
&gt; Using packages from github is problematic - https://github.com/gdotdesign/elm-github-install isn't reliable for me Could you elaborate more? I would like to know the issues you are having so I can fix them.
My 2 cents on the issue with cursor position: &gt; Not a pitfall of the language. It's also only been recently filed, I'd guess it won't take long until it's fixed. https://github.com/elm-lang/html/issues/42 It was filed 14 months ago. First reaction from Evan - 13 months later. Having bugs is not a pitfall of a language\library. Ignoring them is though. Not having bugfix releases is.
&gt; Probably no rich text editor written in Elm &gt; Probably no code editor written in Elm Both of these would be nice. For many apps you don't need it but from time to time you do. I assume sooner or later someone will write one
Sorry - don't remember what was the problem but was trying it couple of time ~6 months ago and it wasn't working. Will try to submit issue next time
&gt; by the time you get to production readiness it'll most likely be fixed already. I doubt it 
You could just link to the Github issues page, which would be more complete. I'm not sure what a complaints list here, where it won't be tracked, is supposed to accomplish.
This was meant as a discussion about Elm ecosystem and problems someone may encounter. And everything from this list qualifies as an issue. 
... I actually recall Evan mentioning on an Elm Town episode that typeclasses were *never* going to happen - and he made a great argument for why not (...which I am not smart enough to fully understand, but it was certainly interesting!) Does anyone know the episode I'm talking about? - Rex
Yeah, that's definitely a problem.
&gt; nest foreign code within it, and nest it inside foreign code. That sounds REALLY painful.
&gt; that is there for years The virtual DOM rewrite was released last year and I see no earlier reports. Are you sure or are you just guessing? The one problem regarding this issue is how long it took Evan to acknowledge.
I'm working on an application launcher for linux, similar to projects like [albert](https://albertlauncher.github.io/), [synapse](https://launchpad.net/synapse-project), [GNOME Do](http://do.cooperteam.net/), etc. I believe mac's spotlight is also similar. For this I'm using electron and elm (obviously...). In the process I also wrote an ini parser and some other things that I'll probably release as a library at some point
Yea the array is faster and takes radically less memory. 
That's not the ideal state, but it's pretty good if you want to gradually transition a project, or if you are required to interop with other JS libraries like React. Or if you want to share components with other teams who are using JS but can't convince them yet to switch.
&gt; Probably no rich text editor written in Elm &gt; Probably no code editor written in Elm I fail to see how either of these is even relevant as a "pitfall". Lots of languages exist; are they somehow lessened by the lack of an editor written in them? 
I'll reframe this in a more civil way: &gt; I like Haskell's typeclasses, and I'm frustrated that Elm doesn't have them. Are there plans to add them anytime soon? The answer is no. /u/astral-emperor You are more than welcome to criticize, disagree with, or otherwise complain about Elm on /r/elm. Please find a way to do it in a civil way next time. Consider this a warning from a moderator.
If I'm correct (hi btw I'm a Clojure guy) if Elm is just a way to not write in plain JS while also expanding on what you can do in the browser (in a more sane fashion), wouldn't making an editor with Elm just be making a different Atom (Coffeescript) or VS Code (TypeScript)? Atom's been under fire ( [one example-ish](https://www.reddit.com/r/programming/comments/6s3tcu/atom_needs_a_whopping_845_megabytes_to_open_a_6mb/dl9xw1y?context=1) ) because it takes up way too much RAM and there was something about an exploit in Atom ( [talked about in comments here](https://www.reddit.com/r/programmingcirclejerk/comments/6qx5bb/sublimers_got_tracked_by_a_plugin/dl0npd6?context=1) ). So the question would be *why* would there need to be an editor written in Elm? 
sorry, but i'm not sure i understand the thought process behind the warning. i thought astral-emperor introduced the topic in a way that was interesting and has the potential to start an interesting dialogue. having him reframe his idea in the manner you suggested would fundamentally change the ideas he is trying to convey. not implying there necessarily is a problem with that, but do you not see a possible problem with that?
It certainly doesn't have to be the way I reframed it, but saying Elm is "stunted" and "a toy" and "Haskell's kid brother" who needs to "grow up" - this is how you start a fight, not a civil discussion. There is plenty of reasonable ground between what I wrote and the OP.
I've personally offered to help add examples in the docs and was ignored. I get the impression that Elm is a one-man passion project, but am then confused when I see that isn't necessarily the case. I agree that the lack of a roadmap is confusing given the amount of (now petering out) hype there is.
i'm not saying those ideas are true, but, suppose they were (as insulting as they are. but insults can possibly be true). and let's say in the course of discussing them and other ideas generated from them, it does generate antagonism, hostility, and fighting. bad blood and insults being hurled towards each other, insecurities poked at and inflamed. because the ideas are true in this hypothetical, discussing them would provide the opportunity to develop our understanding, change our perspective of elm in a way that is valuable, and generate new truths and understanding. so then in this hypothetical, it is a tradeoff between 1. a situation where people end up cut, bruised, damaged, and feeling awful, but come away bearing fruit that promises valuable growth in the future, and 2. avoiding getting hurt in any way but foregoing the opportunity of gaining knowledge and truth. since it is possible these ideas are true, do you not think it is worth pain, cuts, bruises, temporary antagonism, for the possibility of progress and improvement? or is avoiding all of those worth distilling, changing, and stunting full expression of ideas? because it is true that bruises heal over time.
Names aside, I reject the idea that I should have to choose a transpiled language *implementation* in the first place. This isn't a choice between languages so much as compilers. And I hesitate to use the word choose given that the differences between the options are mostly petty. Most of the comparisons between them end up devolving into how big their payload to the browser ends up being, and the number of terminal commands they need to run to minimize it. This is despicable. The fundamental goal is being able to write front end web applications in Haskell. Fragmenting this task into half a dozen independent projects is a total waste of time, and I'd be more than happy to see most of them abandoned for the sake of unifying the task force. I bought the idea that Elm was necessary as a bridge for everyone who is rightfully intimidated by the barriers to entry with Haskell. For a week or so. Then I realized that it wasn't a bridge so much as a safety net from the real power of the paradigm. Just like Java tried to do with Smalltalk, and JavaScript with Scheme. Making the divine more palatable to the average programmer by clipping its wings. Most of Elm's hype comes from people who are still high on the joy that comes from being able to write a front end application without the abomination that is JavaScript, but have yet to wield the far stronger sword that is Haskell. And those that have are immediately aware that they've [been shortchanged](http://reasonablypolymorphic.com/blog/elm-is-wrong). So why am I singling out Elm? Well, it *seems* like it has the most momentum and support of all the current options. PureScript still hasn't released version 1, and for all its promise, I can't even get GHCJS to run on my computer. But I'm starting to seriously doubt that Elm truly is the most worthwhile target, considering just how closed off the project has been, even when it comes [to periphery aspects of its development](https://www.reddit.com/r/elm/comments/6saztw/when_will_elm_grow_up/dlcnt41/). I'm more than okay with the benevolent dictator for life model, and it has been already employed to great effect in the context of programming languages by Rich Hickey with Clojure. But one developer as the gatekeeper for all progress on the language, squeezing development in between larger projects? That's a recipe for burnout and stagnation and ultimately disaster.
&lt;sigh&gt; Further evidence of just how low JavaScript has lowered people's standards and expectations. The same is true of people coming from Java to something like Scala. "Everything's an object! Higher order functions! Pattern matching!" Sure, but... We've already had [better solutions](https://en.wikipedia.org/wiki/OCaml) for decades, and in some cases, [half a century](https://en.wikipedia.org/wiki/Smalltalk). And relative to them, Scala is a step *down*.
&gt; I think the frustration comes when the response is met with dismissal, and when it is unclear what the design process is, and what the bus factor is on that process. Exactly. Evan may be doing good work in protecting Elm from JS, but he certainly isn't protecting Elm from the bus factor, nor from falling behind the future that it is supposed to be leading front end development towards.
Passion project or quite possibly a vanity project at this point. If you haven't already, check out what Rich Hickey did with Clojure for a good example of the former. You can outsource and delegate without losing integrity. In fact, integrity is only increased by eliminating bottlenecks. The bus factor is a big one.
A simple graphical user interface for a web-kiosk was my first Elm project. It was a great way to get familiar with the language. It combined a lot of the key elements of a web application, but didn't have to be overly fancy. A couple of possible page states, a couple buttons/actions, and the ability to periodically ping a server, pushing simple numerical data, and requesting simple updates. From my personal experience, parsing JSON was actually one of the more vexing parts of learning Elm, so having a project which integrated some JSON parsing was good. Its probably nothing for people coming from a functional programming background, but I came from a more imperative background, so I had to do a decent amount of experimenting before I figured out how to deal with it relatively painlessly. *edit:* in case you wanted more direct advice: Decide what things you want to be able to do with Elm, then figure out the absolute *minimum* thing you could build which does a bit of all of that. You'll get a chance to reason about how to do all those things, and a chance to experiment with ways to make your components fit together.
I really appreciate your thoughtful perspective on this! Thank you for writing this. &gt; since it is possible these ideas are true, do you not think it is worth pain, cuts, bruises, temporary antagonism, for the possibility of progress and improvement? There is a bigger picture here than this one interaction. One of the many costs to the community of excusing antagonism is that other potential contributors who (quite reasonably) don't want to spend their free time dealing with that sort of hostility will decline to contribute. I'm happy to insist on civility with open eyes. ðŸ™‚
Made a minesweeper clone
Happily, this has been fixed in the development branch and will be out in the next release! The fix was very invasive, and doing a bugfix release for it would be very risky. There is a high chance of unintended consequences, so waiting for a major release in which more people will surface edge cases during an alpha period seems like the responsible thing to do. I agree that bugs should be fixed, but it's worth noting that the more complex the project, the more bugs that will be filed, the more time it takes to comb through the issue backlog and engage in dialogue (there's no such thing as responding without creating dialogue, unless you immediately lock the issue after responding), and the more time bugs take to fix. This phenomenon is not unique to Elm. Here's a bug in React from 2014 that has never been addressed: https://github.com/facebook/react/issues/1159 Here's another : https://github.com/facebook/react/issues/427 Here's a bug with no responses since 2014: https://github.com/facebook/react/issues/1253 Here are some unfixed Ember bugs from 2014: https://github.com/emberjs/ember.js/issues?q=is%3Aissue+is%3Aopen+sort%3Acreated-asc+label%3ABug Here are some unfixed Angular bugs dating back to 2012: https://github.com/angular/angular.js/issues?q=is%3Aissue+is%3Aopen+sort%3Acreated-asc+label%3A%22type%3A+bug%22 Again, I agree with the premise - bugs should be fixed, and bugfix releases are a good thing. But this pitfall is not noteworthy; it's shared by every large project. ðŸ˜„
Probability calculations using big integers for a widget displaying odds of bridge splits.
What would happen if I don't comply? And to be clear, I'm asking for the sake of transparency, not as an implicit threat. I don't want to start a war, but I do think the Elm community needs a better perspective on what exists beyond what it currently has to offer.
I haven't had to use any moderator features yet, and I hope I don't have to. I don't have a specific guidebook for "x means do y," but the options include deleting posts, banning, etc. To be clear, my preference is that we all have civil discussions here. I'd like to think that's achievable without using moderator tools. ðŸ™‚
I rewrote a query parser I had just written in JavaScript. That code was a god awful mess. But it taught me that Elm was a real language. 
I would advise that you implement some kind of UI that interrogates [an available repository of information that has a clear and well documented API](https://github.com/toddmotto/public-apis). For example, take a look at GitHub API and implement some kind of UI that would display some info you would want to find out. Let's say, the first 10 repositories where the language is Elm. This would put you through a huge part of the language (Elm Architecture, Http requests, JSON decoders). Back when I learned Elm, I had a series of challenges. Challenge 4 read: &gt; Write a program that asks the user for a Github username (from a text field) and displays this user's name, avatar and lists his/her programming languages. Fetch the information only after the user stops typing for one second. After this challenge I implemented a Snake clone. 
Not only moved to the Debug module but also disabled in production code (https://github.com/elm-lang/core/blob/master/src/Elm/Kernel/Debug.js#L44-L47) which is good because people have been abusing it to break the type system.
Yeah probably years since the virtual DOM was introduced with https://github.com/evancz/virtual-dom and the blog post about it: http://elm-lang.org/blog/blazing-fast-html (23 July 2014). There were probably an issue on it with the old repository (evancz) but not available now.
So... generics?
&gt; Growing up is about choosing to do the right thing rather than the expedient thing. It's about considering the long term effects of design decisions. In these respects, Elm is quite mature. Agreed on that. But Elm needs to be able to grow up with its users. Elm's ceiling seems to be rather low, and deliberately so, and while this helps with onboarding, it doesn't help after you've ascended from beginner to professional. &gt; Now, just to get a better understanding of the level of discomfort that you are having, how big is the largest Elm codebase you have? Largest currently is 1,000 lines, but I'm looking to rewrite an AngularJS app that's almost 30,000. So I need the architecture to be able to scale, and not be concerned about having to resort to raw JS to get everything I need from it. The fact that I need to write JS to do something as simple as [change the page title](https://stackoverflow.com/a/40491689/4199200) is not at all reassuring.
Let me know when you find it. The only justification I've seen is that it's a turn off for beginners.
&gt; So I need the architecture to be able to scale, and not be concerned about having to resort to raw JS to get everything I need from it. Elm is able to scale and resorting to JS is not as bad as it might sound if you do it properly. I view it as writing drivers for the runtime. The code is usually small (few lines) and once it's done, it seldom needs to be updated. The key thing is to keep it on the edges of your Elm program and to follow the proper safety protocol. &gt; The fact that I need to write JS to do something as simple as change the page title is not at all reassuring. That's 3 lines of JS that once you write, you will never ever have to touch again. Sure, it would have been nice if you would not have had to write that but... as far as dealing with code, it is manageable. 
Experimental lightweight SPA web client for my company's CRM system (raynetcrm.com). Ditched it after a while, but it was very promising :)
Most of the "pitfalls" you list are features of the language clearly stated in every elm presentation or tutorial I've seen. Elm claims to avoid most of runtime exceptions, so yes, functions are mathematical ones, values are immutable, types forbid silly bugs (head of empty list, index out of bound, undefined and null, etc). JavaScript is inherently unsafe so Elm must be very cautiuous when interfacing JS. That's why ports are like that. It's an opinionated design choice, a pretty good one actually. Elm is not a superset of JS, it's a completely different language which happends to compile to JS. If you want to use loops, mutations, seemless JS integration, then there are many languages you may use instead. Indeed, it may requires some time for beginners who come from imperative and object oriented languages to familiarized themselves with pure functional languages. But that's not a pitfall, it's the paradigm of the language. By the way, Elm does have a solid IDE experience thanks to the plugin for Atom, VS Code and others. The editor is not written in Elm but does it really matter? By the way I don't understand your point about Native/Kernel code. 
I am rather new to elm and fp in general, but isn't curring different from partial application? Because the author states that they are more or less the same. If I understood it correctly, PA means to bind one argument to a function taking multiple parameters and returning said bound function. E.g. create a tripple function from a multiply function, where one param is bound to 3. Currying on the other hand means, that every function only takes exactly one argument, and returns a new function for the next and so on. So in a language like JS, which is not auto curried like elm, you would have a curry function, which takes a function with multiple parameters and returns a function which takes one argument and returns another function taking the next argument and so on, right? So while PA and currying are similar they are not the same.
Working on a [logic game](https://sftm.schlussweisen.com) completely in Elm.
Yes PA and currying are different, however the primary (if not only) practical use case of curried function is to facilitate partial application. Currying in and of itself has relatively little interest. `curry` would be possible but of limited interest in JS: * JS's call syntax fairly heavy so it is not that huge a gain compared to .bind or arrow functions, especially if you apply (partially or terminally) multiple arguments at the same time * essentially all JS functions are variable arguments, through both the `arguments` internal object and the fact that you can omit any positional argument so curry becomes significantly more complex if you want it to be somewhat foolproof
Thanks for the elaborate explanation :)
Regarding Native/Kernel code. Sometimes if you need to do something more advanced, you need to use Native/Kernel code and this is maybe not be pleasant. What do you not understand about it? 
code and rich text editors are quite common widgets used on web pages. Absence of such essential widgets may be a roadblock. I'm not talking specifically about language but ecosystem.
You can still use currying successfully in JS with libraries like Ramda.js.
Just released a package that behaves like select2: http://package.elm-lang.org/packages/MadonnaMat/elm-select-two/latest
I made this to measure git stars for programming languages http://gitranklangs.herokuapp.com/
&gt; considering Evan's vision for the language. Which is?
Adding on to this. Would you censor someone if they were overly _positive_ about Elm in an unrealistic way? I think we should always allow people to be as passionate as they truly feel. The internet does not need to be dispassionate necessarily. Allowing people to express how they truly feel is a great gift. If the person expresses themselves in a dishonest way, then that becomes apparent in the following dialogue. If anything, the passion expressed by OP shows that he _cares_ about Elm in some capacity.
Passion is great! Hostility and antagonism are not. If someone were praising Elm by hurling insults at others, that would likewise be unacceptable.
That's awesome! I'd be really excited to see a language that compiles to Elm and isn't just interpreted. :-) Do you have any specific goals for this langauge, or any target use-cases? Best of luck!!!
I created some buttons that, when clicked, displayed different content. I recently revisited this project to shore up some of my newer skills: https://ellie-app.com/HFdwVJfmQfa1/0 -Rex
Coming from typescript, Elm only has limitations :p
Excellent! Maybe you can explain to me when would you use a union type instead of an enum in TypeScript? 
As the comment you replied to says, the VDOM was fully rewritten. Previously a third party VDOM was being used, it had a few performance issues and it was brought in hourse and **fully rewritten** ***last year*** to fit Elm's model.
Yes then it's there for over a year not years, the point is the same.
I made a game: https://github.com/crazymykl/elm-drench.
Basically a todo app - but for quotes &gt;&lt;. I didn't get to finish it at the time, but I plan to add at least 1 more thing. https://quothers.gitlab.io/quoth-elm/
It feels to me like you're justifying your post by pivoting from pitfalls in the language, to pitfalls (?) in USING the language, to "shit I don't like".
I made a single page web application (SPA) that acted, more or less, as my personal journal: https://github.com/srid/chronicle
The main practical use of currying functions is to make function composition simple. Every function taking only one argument allows you to easily write functions that compose functions. eg. the &gt;&gt; operator would need to be repeated for every number of possible arguments to a function and every combination of those. 
Once you add a feature to the language people will use it and it will be very difficult to take it away so... better make sure that the feature is properly designed. Evan's vision for the language, as far as I understand it, is to implement things after they are properly designed, after the advantages and disadvantages are properly weighted. It is very easy to ask for typeclasses and they might not even be all that difficult to implement but very few people truly understand how big of an impact this would have on readability for beginners or on teaching the language to people. Haskell is notoriously difficult for valid reasons. 
I think he was talking about something like TinyMCE &amp; CodeMirror, not Word &amp; Atom. Elm is theoretically a general purpose language but practically is a language used to implement web apps. When implementing web apps one needs these kind of editors. A rich text editor is quite frequently needed if one has content generated by the users or admins of the site. Using JS implemented libraries that interact with the DOM is rather difficult in Elm and having Elm options would be wonderful. 
The way I did it in a recent project was to have an errors list in the model and to check for it in the view. If the list is not empty, show the appropriate errors. In `update` I would simply validate the model when appropriate. Here is one of those functions: validate : Model -&gt; Model validate model = let errors = [ String.length model.firstName &lt; 3 =&gt; "The First Name must be longer than 3 characters" , String.length model.lastName &lt; 3 =&gt; "The Last Name must be longer than 3 characters" , String.length model.password &lt; 5 =&gt; "Passwords cannot be shorter than 5 characters" , model.password /= model.password_confirm =&gt; "Passwords do not match" ] in { model | errors = List.filterMap (\( v, e ) -&gt; if v then Just e else Nothing ) errors } and in `update` I have: Submit -&gt; let newModel = validate model in case newModel.errors of [] -&gt; newModel =&gt; registerCmd newModel _ -&gt; newModel =&gt; Cmd.none in `view` I have: errors = case model.errors of [] -&gt; text "" xs -&gt; div [ class "alert alert-danger col s12" ] (List.map warning model.errors)
You don't really need Tasks for this kind of a behavior. [Here is another approach](https://ellie-app.com/3YJ65RSsjGRa1/1) What I do is basically keep track of the time when the mouse was last moved. This is done by setting the `active` field to `Just 0`. This activates the subscription and on the first subscription message, the time is saved. On the next subscription messages, I check to see if the `activeTime` has passed. 
&gt; Evan's vision for the language, as far as I understand it, is to implement things after they are properly designed, after the advantages and disadvantages are properly weighted. You mean like Signals were? or the first version of Navigation package? or the adding / removing fields to records? the first version of the Html package? the list goes on. All software goes through iteration, Elm included. The only thing different here is that in Elms case it is really slow and contain a large amount of features per iteration, take 0.19 as an example (what I know so far just by looking at the commits and diffs, probably a lot more): * Fixes the `value` bug by introducing a feature to make events synchronous, which is by default so it **will** cause performance issues in other events like mousemove, and such. * Change how events work: `onBubble` `onCapture` * Something about handing routing within the language SPA style * Redesigning the `elm-package.json` into `elm.json` breaking every package there is * Redesign Native modules into Kernel modules thus breaking every native package * Use new Array implementation * Remove (!) * Add (=&gt;) to the Tuple library * Move `Regexp` to it's own package * Move `Color` to it's own package * Lots of bugfixes Some of these could have been limited to major version changes to packages, some could have been straight up bugfix releases, and I think smaller updates would benefit the community more. Anyway I think none of us can really influence how it works. I just wanted to point out that not everything in Elm is "properly designed" If it were the langague would be perfect and done, so as I see it that phrase doesn't justify the road Elm is on now.
&gt; The main practical use of currying functions is to make function composition simple. Not really, except through partial application. You don't usually do HoF composition which is what you need if you want to compose e.g. `(a -&gt; b -&gt; c)` with something unless it's the very last element in the chain, usually you partially apply (or more rarely uncurry) it then compose it. That's why HoFs (map, filter) generally take the *function* as first parameter in curried languages, that's the element you want to partially apply before composing them into a processing pipeline. In uncurried languages it's often the opposite. 
&gt; You mean like Signals were? or the first version of Navigation package? or the adding / removing fields to records? the first version of the Html package? the list goes on. The reason why Signals could be dropped is the Elm Architecture. Without pushing the signals to the edges, the language change would have not been possible. A typeclass-like implementation would be impossible to be treated the same. Once you put one in the language it will stay there to haunt you for a long time. &gt; - Redesigning the elm-package.json into elm.json breaking every package there is &gt; - Redesign Native modules into Kernel modules thus breaking every native package The first one can be addressed by tooling. I doubt that `0.19` will launch without `elm-upgrade` being able to automatically convert `elm-package.json` to `elm.json` Then `Native` redesign is not as impactful. The percentage of people with sufficient knowledge of elm internals to venture into the `Native` land is very small and I think they will be able to upgrade their code. Sure, it still sucks but hey... it's a major version update, it is to be expected. &gt; Some of these could have been limited to major version changes to packages, some could have been straight up bugfix releases, and I think smaller updates would benefit the community more. In theory yes, in practice, sometimes is more complicated. If you are mid-way through a redesign of a core library that rests on next version features and a bugfix becomes feasible you might not be able to implement that bugfix just as easily in the previous version of the compiler. &gt; I just wanted to point out that not everything in Elm is "properly designed" If it were the langague would be perfect and done I'm not arguing that it is perfect... only that it is better than the alternatives. We live in an imperfect world and every choice Evan makes has tradeoffs. Some of these tradeoffs are not obvious to me because I do not know enough implementation details and theory. The only choice I have is to trust Evan or not to trust him. I choose to trust him. I'm grateful for the language that he has created. I choose to focus on the things that work and what they can afford me and focus less on the thing that do not work or that annoy me. The alternative would be to switch languages and I would do that in a heartbeat if there would be something that I would like better but there isn't. Other people think differently and they have already jumped ship. 
&gt; I would like to understand better how to import modules and data from different files. Have you read the [Modules section](https://guide.elm-lang.org/reuse/modules.html) of the Guide? &gt; The other one is navigation, I am very confused with that. &gt; I have been reading the elm-spa example by Richard Feldman. Richard's `elm-spa-example` comes with [a warning](https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa): &gt; Fair warning: This is not a gentle introduction to Elm. My advice is to start from the `url-parser` [example](https://github.com/evancz/url-parser/blob/master/examples/Example.elm). It is a lot more beginner friendly. In the `elm-spa-example` there is a distinction made between a `Route` and a `Page`. In simpler apps one can have a single model and use the information from the `Route` to present a different view in that model. In more complex apps it might be useful to break the app into a common part (a context or session data structure) and a set of `Pages` that hold and update their own models (this is what `elm-spa-example` is doing). 
&gt; The alternative would be to switch languages and I would do that in a heartbeat if there would be something that I would like better but there isn't. Yes that's why I'm here as well. That's way I'm kind of angry. That's why I'm doing `elm-github-install` as well, I've invested a lot of time and effort into it and I still like it. I can sense what this language could be if more people were allowed to contribute, I can sense the potential in it. Seeing that features that are not at all related to issues that people are having being implemented makes me feel that it's not treated as a community language, it's not treated as a product that people use, it's treated as personal playground for some people and **it's not communicated as such** giving a false message to those who get involved.
&gt; Seeing that features that are not at all related to issues that people are having being implemented makes me feel that it's not treated as a community language, it's not treated as a product that people use, it's treated as personal playground for some people and it's not communicated as such giving a false message to those who get involved. I'm sorry that you see it like this. It is easy to understand why you would be kind of angry if this is what you see. I see it somewhat differently. A lot of people bet on Elm and are starting to have scalability problems either with the outputted JS or with compile times. I think that this creates problems for Elm in the sense that it hurts the people who invested most in the language. The code splitting and SPA related changes are in line with this kind of issues. The changes might not really allow new capabilities but they might bring a user experience improvement for the people who have Elm codebases in the tens of thousands of LOC. 
&gt; A lot of people bet on Elm and are starting to have scalability problems either with the outputted JS or with compile times. I get that, so why hasn't the libsysconfcpus issue has been fixed yet? :D Anyway I'm working on a project where we have ~18K LOC ruby code (frontend) and an other here I have ~7K LOC Elm one with (if we count Elm-UI which included then ~16K) and Elm one compiles way faster, but still both is in the usable category. What I suspect is that NRI has a problem with it and they don't use SPA at all so solving this for them takes priority. Â¯\_(ãƒ„)_/Â¯
&gt; When implementing web apps one needs these kind of editors. Sure, and I appreciate your point here. That said, I'm skeptical of 2 presumptions made (not by you): * That having one of these rich editors needs to be written IN the language that it edits, and... * That the presence or absence of such an editor says anything about the language. In NO case certainly does this qualify (to me, anyway), as a "pitfall" in the classic, accepted definition of the word.
What is most useful will depend in part on your coding background. Personally I found of most importance was to get my head around functional programming, so I found working my way though https://www.gitbook.com/book/johncrane/ninety-nine-elm-problems/details invaluable. They are nicely graded and have answers and hints to help you on your way. I find writing apps, *so* much easier now as a consequence.
Here https://github.com/NoRedInk/elm-style-guide are some answers.
This is nice and quite a bit simpler than my approach. Thanks for sharing!
Thanks. Yes I had seen NoRedInk's style guide but the emphasis of their guide is structured more around the Elm architecture. For those that are more directly relevant (e.g. use of pipes; let bindings), I wasn't sure if the guidelines from NoRedInk were more widely recommended for the Elm community and am interested in views more widely.
1. Look at the core and the `elm-lang` libraries for guidance. `isGreen` is better than `green` because I suppose you want a `Bool` not some `Color` value. :) You can find something similar in `Basics.isNaN` or `Basics.isInfinite`. `sum` and `root` are better names since you are describing what they produce. Elm is declarative and names should avoid reflecting imperative ideas (calculate, get). 2. I try to keep the type definitions at the top of the file and keep them grouped and limited in number. For example, if I have a complex alias and few support type I keep them in the same file. If the support types get complex too, I move the complex ones to their own file. One exception to this rule is triad modules. Sometimes, I do implement "components" that have their own `Model`, `update` and `view`. In this case I keep the `Msg` type and supporting types above `update`. 3. I use the `x::xs` pattern when I don't want to think about it too much but there are some cases when the list item have extra meaning. For example, I would use `year :: month :: day :: [] -&gt;` to pattern match on a list of 3 elements that have a specific meaning assigned. 4. I would use the meaning ascribed to that tuple element. If it is the `x` part of a coordinate then by all means use `x` but if it means something else, use something appropriate. Also, if you think that the extra context provided by the unused variable might be useful, type it in. You will always spend more time reading the code than writing the code. :) 5. I'm not consistent with this one. Sure, I can understand the advantages of using stuff declared above but I sometimes use the second form. The most frequent pattern for the second form is with helpers functions that I feel should have not been in the module but in some kind of library. I put them towards the end of the file and if I find that I need them somewhere else, I extract them in their own module. If not... they stay there. 6. If the function does not need context to be useful, I tend to extract it at module level and make it as generic as I can. I've had some experience where a function starts very coupled namewise to the place of call and progressively gets tweaked and generalized ending up with a generic name. 7. I prefer expressing things vertically. If I can chain things with `|&gt;` I will do that. I use `&lt;| in contexts where I might end up with a lot of parentheses at the end of the line. 8. If you find yourself using more than 3 parameters maybe it is time to split the function and/or collapse the parameters into an explicit record. Also, keep an eye out for partial application and if it feels that it could be an option, decide then the order of the parameters. Trying to decide this from the beginning might be a sign of premature optimization. Elm is amazing at refactoring code. This means that you can change your mind and do things differently very easily. 
I am the author. I've been working on elm-serverless over the past 3 weeks. Getting ready for release 4.0.0, which simplifies pipelines, fixes JavaScript interop, and protects against further breaking changes by making certain types opaque. Would appreciate feedback on the current design before publishing a release. Thanks!
Where did you get that series of challenges?
It was a random `elm-discuss` user. I don't remember seeing him around since 2015. 
For function names I really like the pattern of having the function name refer to/flow through to its first argument, like `Bitwise.shiftLeftBy` (in the core package) takes the amount to shift by as the first argument. As for list destructuring, my personal preference is `first :: rest`, which I think is a bit more straightforward and clear than either of the other options.
Thanks for responding! You are a much more advanced Elmer than myself! I think I mostly understand your solution but have a few questions... &amp;nbsp; &amp;nbsp; `String.length model.password &lt; 5 =&gt; "Passwords cannot be shorter than 5 characters"` `model.password /= model.password_confirm =&gt; "Passwords do not match" ` - What does =&gt; and /= do? - Why does your update return a Command? I had thought(from my limited understanding) that commands were to tell Elm to run longer running tasks like generating a random number? - What is the xs getting matched in the view?
good questions! &gt; What does =&gt; and /= do? `=&gt;` is an infix function that combines two items into a tuple. People are calling it the rocket operator or fat arrow. String.length model.password &lt; 5 =&gt; "Passwords cannot be shorter than 5 characters" is the same as (String.length model.password &lt; 5, "Passwords cannot be shorter than 5 characters") I tends to use it a lot when I declare a list of tuples. JSON encoders are a prime candidate. Inline styles are another place where this is used frequently. I should have probably avoided it in the example. `/=` is just how inequality is checked in Elm. In other languages you might have `!=` for this operator. &gt; Why does your update return a Command? I had thought(from my limited understanding) that commands were to tell Elm to run longer running tasks like generating a random number? Generating a random number is not a long running task but it is a task with a side-effect and so it must be delegated to the runtime. [Elm has managed effects.](https://guide.elm-lang.org/architecture/effects/) In my case, the app calls a server. Http requests have side-effects and are packaged as commands. You basically ask the runtime to execute this side-effects producing command. &gt; What is the xs getting matched in the view? It gets match on everything else. Considering that I don't use the variable, I might as well used `_` Naming things is difficult and what you see above is a failure to properly name things. It would have probably been better to name it like: errorsContent = case model.errors of [] -&gt; text "" errors -&gt; div [ class "alert alert-danger col s12" ] (List.map warning errors) in this case I pattern match `model.errors` either on the empty list or on an actual list of errors. 
&gt;You can't just use json objects like in Javascript - you have to build decoders/encoders. I recorded a Video for my blog about why Elm has JS Decoders [Why Does Elm Require Javascript Decoders](https://youtu.be/nY0Uo3e_GnY) The truth is that in Javascript you can just call `JSON.parse()` on a string and get a data structure back, but in general, you want to have some kind of reality check on the back side of that. What the decoders give you is an assurance that the data you got from an API is in the shape that you expect. I have been burned in the past in JS Projects when the shape of a JSON changed a little bit and suddenly I was getting strange bugs because when the data was loaded nothing checked on that. 
I turned the toggle example (http://elm-lang.org/examples/buttons) into a game. My version as a game. http://tally.thoughtsfromplac.es/ Use the right and left `cmd` keys to move the spinner. It is meant to be a two player game. Hit spacebar to reset. It was a good project to learn the basics. I've since gone on to build several other elm projects. Snake being the latest http://snake.neillyons.io/
A few things... * More on the Elm video course for Manning (Stay tuned) * launching an [Elm Youtube Channel](https://www.youtube.com/channel/UCMXPX2dNVZUIArP7r8PCO4Q) * [A Weekly Elm Training Product](http://elm-weekly.training/) Oh and a day job doing Erlang 
Just have one list of tasks, with a status field, and filter out the ones you need for each view.
I haven't used Elm + Haskell together yet, but I've written a fair amount of Haskell. Haskell is awesome and you should totally use it. That said, let's talk about the issues with it: + Laziness Lazy evaluation isn't necessarily a bad choice. In fact it may be _slightly_ a better choice than strict evaluation, but since pretty much every other common language is strict this adds to its learning curve. + Category theory informed typeclasses Awesome, but also adds to the learning curve. + Crufty Haskell's an old language, and a lot of things are odd or outdated. The normal Prelude isn't good so you have to pick an alternate one, the import syntax is weird, the package description notation (`.cabal`) is ad-hoc, the documentation syntax (Haddock) is ad-hoc, GHC has a bunch of extensions to the language that are so common everyone uses them (like `ScopedTypeVariables`) but haven't been merged into the main language yet so you have to list them in every project, that kind of thing. None of this is a huge deal, but when combined with the other issues it just keeps making the learning curve steeper. So while I think Haskell at it's core is the best language in common use right now, it does have downsides. There's a reason Elm wasn't implemented as just a fork of Haskell =)
I really like FP but I never really got into Haskell even though I learned it in university. Multiple types of strings, IO awkward to use and other nuisances made me drop the language. I turned to another functional language, Elixir, in which I fell in love. The actor model, fault tolerance, tooling, pattern matching, etc.. are amazing and I had great experiences running it in production.
I also really like Elixir. Elixir+Phoenix+Elm seems like a great combination for web apps.
I'm going for this exact setup with my app right now, Elm is wonderful, Elixir is fine, Phoenix is just... something else.
The thing I like most in Elm is the superb type system: very expressive and also it enables compiler to check your code before you run it. That, in turn, let you write without so many tests and still having a confidence the code will run after adding new features or refactoring. As far as I can see, Elixir is dynamic, so you write code, it works, then you (or someone from your team) adds/changes something and it breaks at run-time (this is my regular JS+Node.js or Angular experience). Elm, on the other side, let us write a code with almost no unit tests and then its quite safe to modify it without introducing bugs. What it is about Elixir that Elm devs like it so much? :-)
At work we use elm and Haskell for one of our projects and I love it! Code seems so much easier to maintain and refactor! AMA
I thought Haskell was a fun language to play with but it has very confusing error messages and in my opinion confusing terminology. Elm has put a lot of focus on using concepts from Haskell and functional programming but making it much much more user friendly. 
Thank you for the detailed explanation, I appreciate it, you've taught me some things!
I'm writing Elm on the backend. In fact I've written 99% backend Elm full time for a year. 
&gt; It's probably a bad idea to think of Elm as that closely related to Haskell, they have very different design philosophies even if they use some common syntax. How would you distinguish their design philosophies? To me, they just seem receptive at different maturity levels. Elm for beginners, Haskell for experts. And neither offer much for the other category. &gt; I am very interested in languages which are built around stronger totality guarantees Where have you found this? I'll take strong and total over pure any day, and hate that Haskell and Elm both rally around purity. I *like* that side-effects are made explicit with Haskell's IO monad and Elm's Commands, but not with the implication that they're dirty foreigners that don't belong. The power of this paradigm is in modelling and *exposing* interactions with the outside world, not on shutting oneself off from it.
&gt; Multiple types of strings Are they all used equally-ish in all situations? &gt; IO awkward to use How so?
&gt; &gt; IO awkward to use &gt; How so? The IO monad has a pretty steep learning curve. Compared to python where you just (for example) `import random; random.randInt(0, 10)`; in Haskell you need to lift the result out of the IO/RNG monad in order to make an equivalent random choice. More like this example (found on stack exchange) rand :: (Random a, RandomGen g, MonadState g m) =&gt; a -&gt; a -&gt; m a rand lo hi = do r &lt;- get let (val, r') = randomR (lo, hi) r put r' return val Not nearly as friendly for newbies. Also my understanding re: strings is that they're not all used equally, usually you'd use the overloadedstrings pragma and `Text` not `String` in many cases. I think /u/kuryama is talking about the overhead of needing to think about the minute details of which implementation you're using and the differences between them. I don't actually use Haskell in production, so take all of the above with a grain of salt. 
How does this work? I didn't think Elm had any support for backend stuff.
&gt; More like this example Don't know what SO question you've seen, but this looks like it's tailored for the very specific case of storing and tracking custom random seed. It appears that basic case is not that much different from the python one: import System.Random x &lt;- randomRIO (2.71, 3.14 :: Double) With the `Double` distinction because it can generate any values of a `Random` class, not just numbers (e.g. cities, names). &gt; overhead of needing to think about the minute details of which implementation Yeah. That's what I tried to assess with what question. My gueess if you stick to "Use strict Text everywhere for textual data and Bytestring for IO" this shouldn't bother one too much. Basically, like the python unicode/bytes.
&gt; x &lt;- randomRIO (2.71, 3.14 :: Double) Keep in mind that doesn't include the type signature, and also doesn't look at how RNG/IO 'infects' other functions higher up. My personal experience is that it's much harder to use than python, especially if the intuitive place to stick the random call is deep within the program. I suspect that using RNG/IO is actually not all that more difficult in Haskell than python, just that the learning curve is steep by comparison and that makes it difficult to get accustomed to initially.
FFI and Node get you there
Ahh, that makes sense. Will look into it (previously excluded Elm for backend since you don't get much when Googling, using Typescript and Elm at the same time is painful to say the least).
I'd go with Haskell. Id read the Haskell book and try to work with haskell-servant, which has a lib to generate and API wrapper in Elm for you providing type safety over the language barrier.
Have you looked into Idris? I don't really know much about it but I remember reading they 'fixed' a bunch of these problems.
The type of `randomRIO` is `Random a =&gt; (a, a) -&gt; IO a`, very get-to-business: "give me two examples and I'll *produce* a new one inbetween". The "infection" thing is that line that you have to draw: either you're talking about, explaining or promising things (with `=`), or you're actually doing stuff (`&lt;-`). That way haskell can have custom guards and various "pure" expressions in places where Erlang can't and have to rely only on tools provided by language authors.
&gt; haskell-servant, which has a lib to generate and API wrapper in Elm for you providing type safety over the language barrier Neat! I just heard about servant the other day, and love the idea. Super excited to start playing with it.
It is. But starting Haskell can be a bit "steep". Therefor many advise to use the "Haskell Book" to get going, it will give you enough baggage to start the journey. (Though coming from Elm you might just pick it up; might, as it has a lot more bell-and-whistles)
I have not used FFI. Just node libs. Also the huge benefit is using Elm packages on the server AND the client. Writing in Elixir or Haskell doesn't get you this level of reuse. My Postgres Effects Manager can even run on the client via an authenticating proxy on the server. So APIs can be written that work on the server and the client with no difference in code except for the initial setup. 
I have been using Erlang for years, so I have stuck with that. I probably will start moving to Elixir at some point. It turns out that the background of Erlang is very well suited for building web servers.
1. What does your stack look like on the server side? 2. How big is your Haskell codebase? 3. Why did your team favor Haskell?
I haven't used it myself, but I've heard the same thing. However I don't think its library ecosystem is mature enough for it to be a good general purpose language choice at the moment.
I'll bite: how does package management/versioning with Elm compare to Haskell? Have you ever run into problems there?
&gt; they have very different design philosophies even if they use some common syntax. Both have a first-class type system. I think it's worthwhile to not understate that! &gt;Haskell is a fine language and it has some very interesting projects and a lot of very intelligent developers. I do think it is a bit bloated and I am very interested in languages which are built around stronger totality guarantees Haskell has two full-time developers, so a good amount of the bloat is due to the fact that we're using Haskell2010 in 2017. Elm improves on virtually everything that's just plain wrong about Haskell, but it's not hopeless.
Idris isn't anywhere near the same level of production readiness. And error messages can be confusing sometimes. It's a great language, just not as mature as GHC.
Laziness is actually the feature of Haskell I miss most when I use other languages. It's caused me a lot of confusion in Idris :) &gt;Category theory informed typeclasses On the plus side, monads are incredibly versatile and I keep learning new tricks 5 years since I started learning Haskell! 
1) I assume you mean the tech stack and not my stack.yml file, right now we use keter as a service monitor and just run yesod without any proxy. Currently we use MySQL, but I plan on switching to Postgres when I can (seems to have the best support) and probably add some type of caching service when it becomes needed. 2) it's growing but I'd guess 10k lines or so. 3) honestly it was mostly up to me and I had fallen in love with Haskell learning it on the side. My manager didn't care and it was just him and me at the time. We've since hired a boot camp graduate and he doesn't like it as much as it is different then what he knows, BUT he is still able to add to the code base and get things done so not a big blocker.
I would say that elms package management is more strict and as such less likely to have a problem. Elm enforces sem-ver so you know when there are public facing changes made to a package. So far the only problems I've had was when we had 2 package files that had code the used the same files (don't recommend it, instead just have one package file and use 2 or more main files) Haskell with stack is pretty good, Haskell with out stack is a pain in the butt IMHO, but doable.
&gt; Elm has put a lot of focus on using concepts from Haskell and functional programming but making it much much more user friendly. It also dumbs down a lot of things (most egregiously typeclasses). What you gain in nicer error messages you lose in code reuse.
&gt; IO awkward to use and other nuisances made me drop the language. I think IO is actually one of the best parts of Haskell. It's the only mainstream language where IO is typed. Elm has a good model too, but that's because it builds on Haskell.
shameless plug : [elm-bridge](https://hackage.haskell.org/package/elm-bridge) (and obviously, I also have elm/haskell applications).
Your code is beautifully concise!
If you don't mind me asking more questions, What would you say you spend most of your time on with regards to debugging or maintenance? What category of program errors or technical debts take up most of your time?
&gt; I mainly write Elm for the backend so I'd love more power. Can you link to some examples of how you're doing this if they're public? I would love to do server-side Elm, but I thought it was still in the distant future :D
I have used that, but there was some weird things with persist generated types that I didn't have time to figure out. I think it had something to do with type families. Other then that it was a great! ðŸ˜Š
Honestly I'm not sure I fully understand what you're asking, but I'll take a stab at it. Since I use Yesod which uses classyprelude there are a lot of gotchas that you just can't do. So if you focus on making small total functions there is a lot less stepping through code and a lot more using GHCI to pass params to functions to verify results and using GHCI's type command to verify that types line up the way you want. Maintenance is more of the needs changing and having to adjust the code and types to match (compiler helps a bunch) or I'll learn about a compiler extension or style of code that makes things better and then refactor the code to use it (again compiler helps a bunch) As far as errors, since Yesod has type safe urls and type safe sql as long as your persistent definition matches the DB most errors related to input are gone. Most the debugging we end up doing turns out to be some form of logic mistake, such as forgetting a necessary step, because the types prevent a lot of stuff. Idk if that helped. Feel free to ask more. Tl;dr: types are awesome.
I'm reading about your project. Sounds so interesting. Why do this? Humans are adept at denialism. The author therefore presumes that only a data-centric approach can be effective at improving human well-being and productivity. Over a period of data collection, one can't help but gain insights into what actually causes â€” as opposed to what one remembers or is taught to be causing â€” one's happiness and unhappiness.
Take a look at our github: panosoft and elm-node. 
i'm just trying to understand something here based on this post and your replies: you want something that closely approximates haskell on the client, which elm does not, but you don't want to use purescript or ghcjs over elm because elm's user experience is better?
&gt; Probably no code editor written in Elm i'll offer from experience that i don't think this is really a pitfall
I tried GHCjs a while back and I have to say it didn't click for me. I like Elm's focus on do the simple thing and ensure that it will never crash at runtime, while haskell lets you do a lot more things, but seems to not use its types as well to ensure that you get no runtime errors. I did a video on this subject https://youtu.be/fOkkwqF3HTA
Someone should make a catalog of all the TEA style libraries for various languages. 
yes there are a lot
Not to mention the utterly massive amount of JS-soup that's required to send to the client, bundling the whole runtime regardless of what you end up actually using. I'm much more interested in BuckleScript for OCaml, for all kinds of reasons actually.
Check http://fable.io/
Definitely looks interesting too - but seeing as I already use and love OCaml and not F#, I'm not sure it provides enough of a better solution over BuckleScript which offers very impressive output. I'd have to learn a whole new language and ecosystem, even if the syntax is really similar. I've never touched .NET before.
How much back was that "while"?
I'm on the same page, but I wanted a language to do front and back dev and ocaml is not the best option to build application servers out there
What makes you say that? I know a few Reason/OCaml devs and they seem to be compiling to JS and using Node + Express for backend stuff.
I can't speak for /u/mrkaspa but I'd personally prefer to avoid Node - though i wouldn't necessarily say OCaml is a terrible choice anyway. Haskell is also well suited to the task, but they're specifically looking for a language that's good at both.
I agree with you not a fan of node
Last fall
When I look to improve code, I look for similarities and patterns I can exploit. Instead of rewriting this for you, I'd suggest that you add type annotations to the functions. I think you'll see similarities after that. Also notice how the if section is just associating the result of a function call to a string. Now imagine how much code you're going to have to add to add another association. I'd want a function to process a data structure. Then I can just add a new entry to that data structure. Also by having a data structure, it's far easier to see the associations than the if then else code. 
That's the gist of it. I see each of those three options as compromises, and I hate compromise. PureScript compromises the lazy evaluation model. GHCJS compromises the tight feedback loop that makes web development tolerable. And Elm compromises a lot of the higher order functionality of Haskell that make it awesome. As for why I chose Elm, it's for a lot of same reasons [outlined here](https://www.reddit.com/r/elm/comments/6qlwhk/elm_in_production_25000_lines_later/dl0l2cm/). Onboarding and protection from JS hell are particularly important for me. And yes, for the user experience. Elm is designed for exactly what I need it for. Even with it's Elm-ish web libraries, PureScript does less of what I need it for and more of what I don't. And since they're all fairly new and immature, I'd rather invest in the one that's dedicated to the domain I'm working in.
What do you think of reason? 
Still working on my game "Words at a Time": https://waat.fun/ It is a fairly significantly sized project, still in beta. It will have a design overhaul soon.
I would put the definitions to the top level and (as another commenter said,) add type annotations. How does the code look afterwards? Any opportunities for a refactor?
What is the easiest way to add a css file to elm reactor?
You can use a `style` node and an `@import` rule with the url of your css file. [Like this.](https://ellie-app.com/42Z77hwktx2a1/0) Please note that this is the easy way... it does not mean that it is advisable to do this in production. 
Not interested. Again, I already use and enjoy OCaml - I don't need a different syntax. But if it succeeds in bringing more people to the language, then great.
Why node when OCaml has a great native compiler?
I am currently working through the Learning track problems from: https://johncrane.gitbooks.io/ninety-nine-elm-problems/content/learningtrack2_md.html
I don't quite grasp in its entirely when and where you are allowed to define variables in Elm. From my experience it seems you are only allowed to define variables - At the top level of a file - Within the "Let" of a "Let"/"In" statement * Is what I said correct? My next question is about how you typically break things up in these "Let"/"In" statements when you have multiple variables. * Do you typically do all the work and combinations in the "Let" then merely let the "In" be the return of the result? * Do you break your "Let" variable definitions up into multiple smaller ones for readability or do you favor one larger compound one? Thanks!
Elm is a declarative language. An Elm program is made of a bunch of declarations. You have the module level scope in which you can put declarations and you can introduce new scopes in which to declare things (you use `let ... in` syntax for this). You don't really have variables as Elm is immutable but you can think about these declarations as being the equivalent of declaring variables (the closer concept from JS would be `const`) &gt; My next question is about how you typically break things up Most of the time you will have some input that would need to be processed. Some of that processing could be done by declaring a bunch of intermediary values of the transformation (i.e. using this equivalent to variables). Some of the processing can be done by declaring a bunch of smaller functions that process the data some way and joining them together with the pipe operator (`|&gt;`) It depends on the actual need which one is more appropriate. &gt; Do you break your "Let" variable definitions up into multiple smaller ones for readability Yes. I do this frequently. I sometimes end up declaring a bunch of functions between the `let` and the `in` and join them together in a pipe after the `in`. &gt; do you favor one larger compound one? Compound expressions can become difficult to understand. Sometimes they are appropriate but more often then not one is better served by just being explicit about computing some intermediary values or some arguments. 
Beautiful!
I began working on another small side project with [genetic algorithms](http://package.elm-lang.org/packages/ckoster22/elm-genetic/latest). It's a simple conference scheduler that optimizes a conference schedule based on various requirements.
[Here's](https://github.com/ckoster22/techRadar/blob/master/src/Main.elm#L64-L86) my solution
Do you have some kind of build/deploy process? Something scripted? I use the webpack template for my SPA it comes with a 'yarn build' command that I use to deploy to gitlab pages. I ask because you could build something takes in your markdown articles and processes them into Elm pages before your deploy script runs. That might be too many moving parts for your liking but it's what jumped to my mind when I was reading your post. 
No particular (automated) build process. I develop and test using elm-live, with periodic commits. When everything is stable I push to github and it's all set. I'm fine with doing the processing before building, and I have yarn as well... I guess your suggestion would have js doing the heavy lifting? In terms of building a tool that converts mkdwn to elm? 
Just use `Markdown` package and load the articles as markdown. The only real issue is reading the contents of the folder holding the articles but you can solve this by manually maintaining the list of articles. Alternatively, you could install Jekyll and get this information from the something like an [auto-generated sitemap.xml](https://rubygems.org/gems/jekyll-sitemap) (I have not done this but it) 
The more I think about it the more I think it's not a good idea. Unless you had really simple markdown you'd end up writing too much conversion code. Some of the guys in the Elm Town podcast have talked about markdown editors in the browser using Elm. I wonder if there's something there you could use?
Utilizing the Markdown package was my very first goal, but I got held up trying to figure out how to fetch the markdown from the folder. I'm trying to find an example where someone does this. It would require to maintain a reference to the articles in my Elm code but that's fine. Jekyll feels slightly above and beyond right now, but I'm reading through their docs so see how well it would play with an Elm app.
take a look at [this page too](https://learn.cloudcannon.com/jekyll/output-json/). 
Take a look at [this presentation.](https://www.youtube.com/watch?v=Dr3kQB8byEo) It might provide some extra information. 
&gt; like Elm's focus on do the simple thing and ensure that it will never crash at runtime, while haskell lets you do a lot more things, but seems to not use its types as well to ensure that you get no runtime errors. The way I avoid runtime errors is never writing partial functions by turning on warnings of various sorts. Admittedly, Elm does a far better job of this since it's designed for frontend.
I currently use a markdown editor called [madoko](https://www.madoko.net/). I really like it, because it very extensible, integrates with Github and local files, etc. So I can make the files pretty quickly and easily. It's just figuring out how to fetch and embed them.
This is interesting, but I'm not sure I understand a few things. All the jekyll content is from the perspective of "Set up a Jekyll site and you can have different interactions." Would I be able to use Jekyll without having to build a Jekyll app, or is the idea that Elm just becomes the js of the Jekyll app? Sorry I'm so slow on this. Part of the reason I'm trying to find the most elm-centric solution possible is that I'm still learning how all these different components interact, and introducing complexity to the codebase one step at a time. 
I don't want to spoil anyone's fun but since a blog is largely static content, might Elm be overkill? I'll excuse myself now.
The website currently has (and will have) more than a blog. No fun spoiled here :). Although I think I would *still* try and use Elm even if it was completely static... 
thank you!
My biggest Elm project, [a game](https://github.com/lattyware/massivedecks) uses Scala for the back-end. I've enjoyed that experience. Scala and Elm have a lot of similarities, but also a lot of differences - the design philosophy is almost reversed (Elm being a very small set of features carefully thought out, Scala being a huge grab bag of features). Using them both really lets you see the pros and cons of both. Elm often feels very limited and awkward to do complex things in due to the lack of meta features, but because of that design basically falls out - you pretty much have to work in a given way. Scala feels extremely easy to over-complicate things in by comparison, but often leaves you with much more satisfying results if you are careful and diligent.
Relevant summary of experiences building and shipping an Elm native UI project: https://robots.thoughtbot.com/elm-native-ui-in-production
You can run Jekyll and have the Elm produced `index.html`served by Jekyll. Effectively, you will use Jekyll as a very simple webserver that only serves you the information you need about the blog articles. You don't need to integrate them beyond that. 
You should add elm-stuff to .gitignore. 
Idris is a dependently typed programming language. This is useful for implementing a theorem prover but (probably) not the back end of a web app.
problem is that there are partial functions in the core of Haskell like List.head, I like knowing that If I do something stupid the compiler will catch me :) Remember the past tense of "I Know what I am doing " is "What the F*** was I thinking" 
I did a short video on this topic https://www.youtube.com/watch?v=aNQVu0naPJY
I'm late! I built a math scrabble board game. You can play with friend or family, it is a 2-players game. http://amath.morphism.io It is a complete beta. You can play til the end of the game with winning results and points. It is also backed by elixir (also thanks phoenix's channel and presence)
For the interop with NodeJS libraries and leveraging of deployment platforms such as AWS Lambda. I can't say anything about the suitability of the OCaml ecosystem for making web application servers but the NodeJS ecosystem provides a lot here. /u/mrkaspa above suggests OCaml is not great here. Personally I would rather use the native compiler.
I find Node the runtime to be not bad, though I dislike the Javascript language. My preference would be the BEAM, but running a language such as OCaml or Purescript on the Node runtime sounds fine. The limitation is the lack of threading and parallelism, but Elm, Purescript and OCaml can't do this either.
Thanks for this post, man! Makes me want to go head-deep into Elm. What are the best resources to get my feet wet with Elm? Cheers!
I think you can start by reading the book "Why Elm - I mentioned in the blog post. It will give you a good understanding high level of Elm and make you feel good about the language. After that, you can take a look on https://github.com/isRuslan/awesome-elm If you are a JavaScript Developer, you can start reading the series: "Elm for JavaScript Developers" in the DailyDrip blog: https://www.dailydrip.com/blog/general-aspects-between-elm-and-js And you can also watch the DailyDrip videos for Elm: https://www.dailydrip.com/topics/elm, it has about 90 videos coding on Elm, from the beginning to the advanced level! Hope you enjoyed it! 
I haven't had a chance to play with it yet, but [Alpaca](https://github.com/alpaca-lang/alpaca) looks pretty neat, though nowhere near complete yet.
Thank you, muchly!! :)
Done! Thanks!
Yeah. It's not a great situation for frontend. (I personally think exceptions are terrible, but there probably *are* places they're justifiable, even if they're overused).
That's very interesting, sometime back I was working on a similar scheduler.. genetic algorithms didn't occur to me. 
The book link doesn't work at least on mobile. 
This is actually a more elegant solution to the problem raised here. 
It's funny, because they are really just a spillover from a smelly OOP convention. So yeah, totally agree. Name after intention from the caller, not the effect of the callee.
I've also wondered why people like Elixir so much. The syntax is super off-putting, and it has a lot of weird concepts like macros which you just have to trust.
Is there any sample code/tutorial to checkout?
Google for "elm in node". There's some stuff out there
I built game of life clone first: https://github.com/girishso/elm-game-of-life Then used the same ideas to build lights out game: https://github.com/girishso/elm-lights-out
I want to write a program that beta reduces Lambda expressions as text. i.e. a string input of "\x-&gt;x x" should output "x". I originally wanted to do this in Haskell because I'm more familiar with it, but I decided to do it in Elm because I thought it would be cool to make the program a web page and I wanted to refresh my knowledge of Elm. The entire program can be found [here](https://ellie-app.com/446k3vtYTw2a1/8). I'm not sure what the problem is at the moment, but I'm going to be coming back to it later and was hoping I could get some input from someone who knows more about this language than me.
I have some data that can be modelled as a limited (but large) number of fields of the same type. I want to be able to access each field individually by name. My choices seem to be either to use a record, or to use a dict. Since I know how many fields there are at compile time, and this isn't going to change at runtime, I figure it makes sense to use a record - that way the compiler can help me a lot more, and I don't have to faff around with Maybes every time I want to look something up. However, I *also* really want to be able to map/filter/etc. over the fields, and as I understand it, it's not possible to do this with a record, because the fields aren't enumerable. So I've been fooling around in Ellie, and I think I've come up with a workaround that will do what I want. Essentially, each field in the record contains not only the value I want to store in that field, but also a sort of 'pointer' to the next field that should be accessed. By following the pointers and aggregating the values, I end up with a list of values that I can then map over. Does this seem ok, or does it smell like a dirty hack that will cause me problems in the future? Is there a better way to accomplish the same thing? Thanks! https://ellie-app.com/446W5v3xTmKa1/2
This is more of a chicken and the egg kind of issue. Nobody is using Elm on the server because nobody is using Elm on the server. It takes courage to venture into this uncharted domain and there are folks who are courageous. [elm-serverless](https://github.com/ktonon/elm-serverless) is one example. From my own exploration of this topic, there is nothing preventing people from writing Elm on the server except the lack of official libraries. In order to have an official library, there first needs to be a lot of design around how to best do this and, as far as I understand, this is far down on the priority list of Evan. Elm as a language is more than capable of handling the task with the current set of abstractions. I have not seen any detailed explanation to convince me otherwise. 
true, personally I would rather just use erlang, for a lot of reasons which I will cover in a future video
Hi, I used cordova to make an Android application using Elm. I didn't encounter any major hassles, however the app I made was essentially a static HTML page, so I didn't need to use any of cordova's plugins to, for example, access the battery state, local storage, camera, accelerometer, etc.
I'd like to see Elm become as good as Haskell and Clojure is with this kind of thing. Haskell is almost there, the GHC-JS compiler is coming along nicely, and Haskell has a number of excellent server-side libraries. Like you said in your video, it is a matter of making a library that makes front-end development in Haskell more practical. That said, Haskell already has some pretty good front-end FRP frameworks defined, especially things like *Reactive Banana* and *Netwire*, it is just a matter of compiling these libraries to the most optimal JavaScript as possible, which is going to take more time. Clojure is pretty good for doing both front and back-end coding as well, if you don't mind running your server on the Java virtual machine. There are good web service libraries for Clojure, and there is also ClojureScript which compiles to JavaScript for the front-end. The only problem is the dynamic typing, which for me is a deal breaker. There is [Typed Clojure]( http://typedclojure.org/ ), and I've never used it, but I suspect that Elm and Haskell have much better type systems because they are built-in to the language and the compiler.
I have never used Typed Clojure (or any clojure really) but my experience with Erlang is that the success typing you get there is a major help but is not nearly as good as it is in Haskell or Elm because it was something added latter and not every package uses it. In addition I would rather use the Erlang runtime than node.js any day of the week
I made a hackernews SPA clone with real-time updates. http://hackerpunk-news.surge.sh/top https://github.com/gfrancischelli/elm-hackerpunk-news
I rather term 'success typing' as 'smoking crack typing' or just 'optimistic typing' if you want to be less flowery. It's terrible...
Duh, I'm using Elm server-side
It does, I've been meaning to try it for some time now :)
How? Do you have any sample code to share? I'm very much interested in using Elm on server. 
I've done it using ports to node.js. I don't have any sample code, but it should be pretty simple, you basically just compile the elm file and use `require` in node to use the ports.
I've been writing server-based node for the last year (along with 2 other developers) full time using Node. Here are some things we've open sourced that are for the server (there are other non-server specific repos too): https://github.com/panosoft/elm-node-main https://github.com/panosoft/elm-websocket-server https://github.com/panosoft/elm-postgres https://github.com/panosoft/elm-pgproxy https://github.com/panosoft/elm-emailer https://github.com/panosoft/elm-aws-sns https://github.com/elm-node/core We are working on an AWS S3 lib to do basic GET/PUT operations and I'm currently working on a replacement for `elm-github-install` called `grove` that handles everything `elm-github-install` does PLUS local repo linking, uninstalling and NPM installs automatically for the whole dependency tree. AND IT'S WRITTEN IN ELM!! I'm going to open source this too so others can learn both what to do and what not to do :-) Here's the thing... Elm compiles to Javascript. The brilliance in this is that you can leverage the full Javascript ecosystem. We've written Elm Servers, Elm Electron App (early prototyping), Elm Phone App (proof of concept) and with `grove` a command line program. So please stop saying that it's not possible when what you mean is that someone else hasn't made it really really easy for you to build a server application like they have on the front end. (Not you loovjo but everyone in general) If you want to write on the server, then damn it, write on the server. Don't wait for the NoRedInk boys. Get out there and contribute. This community is only as good as the contributions. EDIT: to clarify that I wasn't being an old man and yelling at loovjo to get off of my lawn.
https://github.com/jfacorro/clojerl Here is a new project that try to implement Clojure on the Erlang VM Or another project with the objective of developing a ML inspired functional programming for the Erlang VM https://github.com/alpaca-lang/alpaca the first results look promising... 
Cool! Could you possibly explain what you needed to use elixir for/what functionality does it add?
I wrote a wrapper around ports in node. My code ain't ready to become open source, and probably shouldn't because Elm serverless is better. https://www.npmjs.com/package/elm-serverless
Link: https://medium.com/@mostlovemusic/building-a-static-website-with-github-pages-and-elm-for-free-c05e80ee149d
heh, whoops. thanks for that ;)
&gt; Clojure is pretty good for doing both front and back-end coding as well, if you don't mind running your server on the Java virtual machine. If you *do* mind running your server on the JVM, people claim that server side ClojureScript works really well these days (though I haven't personally tried it).
What I did in this case was this. If CmdB requires CmdA to run before: * set CmdA to trigger a message (like `CommandDone id` with id unique to that instance of CmdA) upon execution * store CmdB in a list of `(CmdB, idOfCmdA)` so that it carries the dependency's id * on `CommandDone id`, check the commands' queue and run the messages matching the id of the completed command 
Usually you can do this with `Task.andThen`
Hmm, this is a really interesting setup. I can't think of anything off the top of my head to fix your problem (sorry!), but I'm curious as to what your reasoning for doing this is. Are you sure that you need to do it this way? In particular, why do you need to be able to access each field individually by name? 
When it comes to gaming, all critical logics must live in the backend. I use Elixir for arithmetic validation and all game rules. Elm is only responsible for rendering and interaction, it ONLY trusts data that's from Elixir/Phoenix as view (JSON) rendering is fast. So no one can mess/hack the game. Phoenix also plays the realtime role, it detects when other user joins or leaves the room. It broadcasts data when other user makes a move via web socket which is easy thing to do in Phoenix. Elm also plays nicely with Phoenix Channel/Presence. 
Give me a gist and I'll help you out. Sounds more like a css problem than anything. Reply to this comment so I get notified Edit: Notify me
I have an Elm app generator: https://github.com/danneu/generator-elm/ npm install -g yo generator-elm yo elm my-app cd my-app npm start # and visit http://localhost:3000 Also comes with a gh-pages deploy: npm run deploy # aka `webpack -p &amp;&amp; gh-pages --dist dist` Check out https://www.npmjs.com/package/gh-pages for an easy way to make a gh-pages branch from a given directory.
I dunno, might be fine. Some of the abstractions that elm chose are great for client side applications, but not necessarily server side. For example, erlang decided to go w dynamic typing because it simplifies hot code loading across nodes.
Please refer people to [this roadmap document](https://github.com/elm-lang/projects/blob/master/roadmap.md#can-i-use-elm-on-servers) on this question. Keep in mind that Elm is about six years old now, and there is still work to do to make it great in browsers. To think you can just show up in a domain like servers and be good is extremely naive. I think /u/jediknight's answer is not correct. It's not about "courage". Designing an *ecosystem* that works well in a particular domain is extremely difficult and takes time. It takes coordination between the compiler, language design, core libraries, package ecosystem, testing tools, editor tools, etc. I really hope that the community respects that I am trying to move us to a place where we can do this in an **excellent** way. This will take time, and in the meantime, I highly recommend using a language that actively claims to be good for servers!
&gt; experience has shown that type classes are a big stumbling block for people trying to learn Haskell. Whose experience? Your earlier claim that, â€œ[w]hen people ask "what is a monad?" or say "monads are complicated" they're actually confused about type classesâ€ does not jive with *my* experience. I understood type classes just fine when I read LYAH, but it took me a while to grok monads. I think this was almost exclusively down to bad educational materials. In my opinion, the most straightforward resource on Monads (for Rubyists, at least) is Tom Stuart's talk, â€œRefactoring Ruby with Monadsâ€. I'm not alone in that either; when I showed my Ruby-using colleagues that talk, they all came away much less confused about monads and their usefulness. So, I'm just wondering, is this simply your personal experience, or some amalgamation of what others answered when they were asked why monads were confusing to them?
Thanks - this is this gist: https://gist.github.com/anonymous/bd3ba2b8be097a4d86c16f21312544a3
This is a css issue, since you haven't set the elements to use border box, the innate 1px of padding along with 1px of border on each side so in total that is 4 extra pixels per box. Box-sizing border box allows the element to contain the padding and borders without increasing the size of the element. You should set the element box sizing to border box (html inputs) and it lines up perfectly. noteInputHtmlElement = ..., style [ ( "width", toString c_NOTE_INPUT_WIDTH_PX ++ "px" ) , ( "box-sizing", "border-box" ) ] ... Edit: Trying to sound like less of a douche
I think the most straightforward way would be to make some helper functions like these: https://ellie-app.com/453cMHX5KkZa1/0 (edit: fixed link) To be even nicer you could put these in a `Data` module and call them as `Data.items`, `Data.map` and `Data.filter`.
Thanks!
Sawat di kap everybody ðŸ™ I'm sorry that I haven't been active in this community. I thought that I would be, but things just didn't go that way. I started a Shopify custom storefront product in Elm, but then switched over to Choo because I really wanted full spider compatibility. I wanted to be able to render meta tags (Twitter cards, etc), and for that one I wanted to pre-render to CDN (â¤ï¸ [Netlify](https://netlify.com)), but in some cases I see that universal rendering or even just server rendering is more appropriate. For talky.cards, for now anyway, I'm doing universal rendering with Choo on [now](https://zeit.co/now) because it's a frontend product for [api.ai](https://api.ai), and they don't send webhooks to drive a pre-renderer, and I don't want to ask my customers to manually drive it when they update their [welcome intent](https://api.ai/docs/events#default-welcome-intent). I've been writing CoffeeScript because of it's terse syntax and nice features; I thought, if I'm going to use a compiler anyway (babel), I might as well use the more comfy language. But I realize that I'm wayy to dumb to be writing code without a helpful compiler and type system. Anyway, hi Elm friends. I need to launch talky.cards (almost... there...) and get users... or get a job writing a typed functional language... *like right now!* or I'm gonna be an illegal alien in Thailand ðŸ˜¬. Turns out, I'm a crazy person, and I can't stop trying to prioritize my own startup ideas over paying work, and I've now pretty much just blown away a whole year trying to build a productized consulting business around Shopify custom storefronts, and juust haad to stop because I was months in and broke and still couldn't see when payday would come... and so I decided to make another quick consulting website, and got to the lead capture form, I was like "hmmm, I want this to be like a conversation..." and became absorbed in conversational UI. Accidental pivot? Whatever, it's ridiculous because I couldn't afford it. I should be trying to get a job, but I feel like my portfolio sucks relative to my capability. I felt like I needed to make something new anyway, and it might as well have a shot at making money. So this time, it's a **micro saas**. A website (or embedded widget) with conversational content backed by api.ai. (That way I don't have to build an editor.) Whatcha think? Well, I didn't plan to prematurely launch in this post... but anyway, wish me luck... and when it fails I'll be back asking for a job, okay? 
[Looks like server-side rendering will come with 0.19](https://github.com/elm-lang/projects/blob/master/roadmap.md#how-do-i-make-a-single-page-app)
&gt; There are times in the Simon game when I want to be able to fire a command, then wait for that command to be done, then fire another command. you need to translate behavior in a series of messages that alter the state of your Elm program. What you described in the quoted segment above translates to me into the following series of messages: 1. `FireFirstCommand` message. It's `update` handler returns the Cmd that needs to be executed. Let's say that is a port call to play some sound first. In JS land you play the sound and then you need to inform the Elm program that the sound finished playing. So, you also need a subscription port. 2. 'CommandFinished` message that comes from the subscription port. That's about it. If you want to play a series of steps with their sounds, all you need to do is have this series of steps saved into your model. If you have a field name `replay` in your model that's a list of moves, you can check to see if this field is empty in `CommandFinished` and proceed to the next command. You can also use the contents of `replay` to deactivate the UI and inform the user that they are seeing a replay and that the interaction buttons are not active. You can also give the user the ability to step through the replay or cancel it. 
Cool, thanks Petre.
Thank you! This is a really good idea, and it hadn't occurred to me to do it this way. I'm sure this will be very useful in the future. However, I see now that I didn't really explain my use case properly, because I was trying to simplify it for the Ellie example. I'll give a proper explanation in a reply to jlubi333's comment.
Thanks for replying! I was trying to simplify the problem so that I could give an easy-to-understand Ellie example, but probably I should have started with a higher level explanation of what I'm trying to do. Basically, the domain I'm working with (a cricket scoring app) involves quite complicated data collection, which I've decided is best modelled using a set of questions. From the initial input, the app then decides which questions it needs to ask the user. Of course, this could be easily handled by writing separate view functions, each of which contains a number of questions, and then routing the user between the views. But I didn't want to write and maintain dozens of nearly-identical view functions, each containing a different combination of similar questions. Instead, I wanted to encapsulate all of the questions, answers and routing logic in my model, and then have a single generic view that would display whatever questions are appropriate, depending on the initial input. The idea is to use the "pointers" to turn the questions (i.e. the fields of the record) into a list that can then be passed to the view function for rendering. The cool part is that each question can include some logic about which question should come next in the list, depending on the answer to the first question. So the set of questions in the model might look something like this: { firstQuestion = { label = "Which pill do you want to take?" , answer = "Red" , choices = [ "Red", "Blue" ] , next = [ ("Red", SecondQuestion), ("Blue", ThirdQuestion) ] } , secondQuestion = ... } Then I have a function that takes a starting question, checks the "answer" to see if there are any "next" questions that should be added to the list, and recurses until there are no more "next" questions to add. This list is then passed to the view function. It seems to me like a decent way to handle the problem, and I've got it working already using a dict instead of a record to store the questions. But I think the record way will be much more elegant, because it's more compiler-safe and doesn't involve handling a lot of Maybes. Does that make sense?
Note that, as far as I've seen, Evan hasn't promised that server-side rendering will be in 0.19. He's said that features supporting single-page apps will be the focus of 0.19, and that server-side rendering is one feature that falls under that umbrella, but not that any specific set of features in that category is guaranteed for any specific release. I'd be happy to be corrected on this, as it's a feature I'd love to see as well. 
if this is entirely out of scope, please excuse me for asking: can I compile a bunch of "packages" like Stock Management, Order Entry, etc - and have web clients 'sign in' and let the server lookup the user and decide which "packages" he/she signed up for, and start to push to the client?
This does sound tricky - I don't see an obvious way to do it. However, it's possible that the "write a bunch of view functions" might actually be OK - it's pretty easy to extract helper functions that can be shared between different view functions, so the amount of duplication might actually be quite manageable. The "pointer to the next question" does feel slightly fishy, like you're mixing data with behaviour instead of separating the two...
This is considered experimental but works very well: https://github.com/eeue56/elm-server-side-renderer As I understand it, in 0.19 it will become possible to send a static DOM from the server, then start running Elm and make the first diff against that DOM. Currently, if you switch from static to client-side rendered you will need to clear the whole DOM and re-render on the client, so you see the screen blink.
Thanks, yeah I noticed that.
Interesting repo. Still reading through it... Yeah, you really need to diff against that initial document. That's why I like the [morphdom](https://github.com/patrick-steele-idem/morphdom) approach. I still have a 'page blink' live even though I used Choo: https://lucid.gallery. The reason is that as soon as the app runs it does a render before the data has loaded from Shopify. Duh. So in the next version (and everything since) I started using `await` on models with async initialization before mounting the app, and that way the server-rendered DOM just isn't touched until everything is ready. app.use await shopify apiKey if not module?.parent then app.mount 'body' Morphdom (actually nanomorph) just makes that kinda thing super easy because it always diffs against the real DOM.
Hey! I kinda got [nerd sniped](https://xkcd.com/356/) on this one, but here's my shot at it! I had a really fun time trying to figure out my favorite solution. :-) It's a tricky problem! Basically, instead of having the pointer setup that you described (which, I agree with /u/ianmackenzie, feels just a _bit_ fishy [nothing egregious per se, though]), I invert the data: each question has a _requirement_ to be active, rather than a list of follow-up questions. To me, this feels much more declarative, because we are simply stating a fact about the data: "this question _requires_ XYZ". Then there are no pointers, just facts about data. Here is a link to a working prototype on Ellie: https://ellie-app.com/45xpXgyC6tka1/0 I would scroll all the way down to the "Main" section and take a look at the mini-API I created for making new questions. I feel like it's quite clean and readable, but of course I'm biased because I wrote it! ;-P In this setup, you get the compiler-checkedness that you had wanted from records with the `QuestionId` type, but you also get to avoid the pointer-linked-list-thingy that you (and I) felt a bit uncomfortable about. I definitely don't claim that this is the _best_ solution, but I think it works pretty well. What do you think? It's definitely a shift in perspective from what you saidâ€”and I'm not sure if this way is better / truly avoids the problems you had. In the end, it's up to you to choose what "feels" best; all of the proposed solutions really seem fine to me. At this point, it's just a question of what is optimal. :-) Thanks for the fun, challenging problem, and good luck with the rest of your program!
[Image](https://imgs.xkcd.com/comics/nerd_sniping.png) [Mobile](https://m.xkcd.com/356/) **Title:** Nerd Sniping **Title-text:** I first saw this problem on the Google Labs Aptitude Test\. A professor and I filled a blackboard without getting anywhere\. Have fun\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/356#Explanation) **Stats:** This comic has been referenced 245 times, representing 0.1474% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dlwrjdm)
I'm gonna be deploying the Ellie browser compiler stuff to production this week or die trying
Oh, that looks *nice*. I will take a proper look at this when I get home. Thanks for putting so much time into this, and apologies for the nerd-sniping.
pls no dying Luke T_T
I think my friend Hian Bricks would be really interested in this for a thing he does, fnoc-mle.
No worries at all! Glad to help.
That's up to my DNS provider at this point
More Elm Videos! https://www.youtube.com/watch?v=Dz8fwk2CldM I am trying to put out 1 video a day (Monday - Friday) Most will be on Elm with Some Erlang, Elixir and other stuff 
What kinds of factors are you trying to balance or optimize for when scheduling speakers for a single track conference?
Some things we take into consideration: - Keynote speaker should be first or last - Probably don't want all veteran or newbie speakers together - What would be the best to stir discussion before a break? - What will draw the crowd back in after extended breaks, like lunch? - When to best schedule breaks? - How long should the sessions be? - How much buffer time is there built into the schedule? - How do the talk topics play off of one another? ("these two talks are about styling" is only one dimension here. There's also "I can use this right away" vs "wow, that was cool and inspiring".) I'm interested to see what you come up with!
The meme is reversed https://i.snag.gy/aW10fd.jpg?nocache=1503377445977
I don't think PureScript is better than Elm. It made different choices which make some things better but other things worse. For Example, PureScript's ability to directly call JS Code means that it can not offer the static guarantees that Elm does. https://youtu.be/Dz8fwk2CldM
Video linked by /u/get-finch: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Why choose Elm over PureScript](https://youtu.be/Dz8fwk2CldM)|Pain Free Web Development|2017-08-21|0:04:00|3+ (100%)|100 &gt; Elm and PureScript live in similar worlds, why did I... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/get-finch ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dlyjcu0\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Interesting. I wonder how you would force Elm to render the inital view client side against the same model that the server side rendered? The initial model would need to be serialized accross to the client too?
Hope we get a SSR isomorphic framework for elm soon. React has Next, vue has Nuxt Maybe we can go for Nelx for elm.
Depends, I guess. I'm doing it that way with talky.cards; serializing the app state after the server run, and adding it to the document (in a script tag for now). In this case I want to continue the session after the 'handover', and not send a duplicate request for the welcome event. In the Shopify apps I just fetch the data from Shopify on both sides, but in that case the app is pre-rendered to Netlify in response to Shopify's webhooks, so it happens way less often, and the data from the pre-render could be just a little stale. 
I think this [list of examples](https://github.com/mdgriffith/elm-style-animation/tree/3.5.5#examples) would be a good place to start. I've done a little bit of work with [Elm Style Animation](http://package.elm-lang.org/packages/mdgriffith/elm-style-animation/3.5.5) as it uses spring-based animation (rather than duration-based) which, [arguably](https://twitter.com/andy_matuschak/status/566736015188963328), leads to better looking animations. That library seems like the best option at the moment for the stuff you can't do with CSS animations and transitions. If you're dealing with enter/leave animation (eg. adding or removing items from a list) I posted a question a few months back that had helpful replies: https://www.reddit.com/r/elm/comments/6aynwq/animating_element_enterleave_transitions/
Cool, thanks for this, I'll check out the links you provided. 
I got a runtime error in elm yesterday. Turned out to be caused by doing a = b % c with c = 0.
But can't this happen in PureScript, too?
There are other cases too. You shouldn't take that tag line too seriously. 
yea that gives you a runtime error. It should give you Infinity or NaN or something
How about "Maybe No Runtime Exceptions"? I've also experienced a division by 0 problem in Elm before. At the time, I also wondered whether the division function should return a Maybe. That would sort of make sense... at least, to me, as a very beginner-level hobbyist programmer.
Interesting. I am currently building it on the assumption of fixed length sessions and breaks but I hadn't thought of making sessions / breaks variable. I plan on starting with a super simple use case and build off of that. I'll keep you posted.
Also infinite loops and types aren't noticed by the compiler and can stop a page from loading, even before you can start a debugger
So that is the halting problem and is unsolvable. However, if you don't use recursion in your code and stick to folds and maps, you should be able to avoid that problem pretty well.
He,he we need a math monad
"Barely any Runtime Exceptions" then. but that's also true with typescript in strict mode :p
I'm actually experiencing this at the moment with a few solvable special cases. In this case a function name was reused and elm was not warning (which was bad), but this led to functions calling the wrong function (which the called itself unconditionally). This unconditional self call is the special case I'm concerned about.
There are a few known ways to crash Elm code, A bad Regex will do it too I think. That being said it will eliminate 99.999% of the things that would cause problems and I will take that.
&gt; I hit two runtime exceptions last week: division by 0 and modulus by 0. [this is a known issue](https://github.com/elm-lang/core/issues/590). &gt; Guarantee "No Runtime Exceptions (mostly)" The "No Runtime Exceptions" thing is related to runtime exceptions in deployed code. What you have here looks like a development runtime exception. These happen from time to time due to any number of factors. [Potential runtime exceptions](https://github.com/elm-lang/core/issues/377) are being closely monitored and fixed. If you develop your code defensively and have tests that check for problems with your code you will catch these kind of exceptions long before the code leaves for the final user. 
I can't talk about reasonML or Fable, having never used them. There are some things about Elm I really like * If code compiles it will almost always work https://youtu.be/AadpZQlRHds * Amazing Error Messages https://youtu.be/VCOEUSVinbw * Logical naming of things (That is the elm build tool is **elm make**) * A simple language * Packages have SemVer enforced * A lot of thought has gone into not only the language but also how to build web application * Time Traveling Debugger * Strong guarantees * Focused on only Also, the Elm community is pretty active and friendly, there are books and video courses etc on Elm, now oCAML and F# have such things but I don't know how much they focus on web frontend stuff. One problem I had with [GHCjs](https://youtu.be/fOkkwqF3HTA) Was that there is a lot of documentation on Haskell, but very little on how to construct a web application in GHCjs.
It probably can, and since you can call any JavaScript code in theory you can get runtime errors anywhere
What cons do you see in Elm? I would like to develop for mobile with Elm but it's on beta, other concern is that there are some missing apis for the language like local storage
Hi guys, I'm not the author of the post but I am the creator of Ocalog and author of the "Ethereum from scratch" series [here](https://ocalog.com/post/10/). If you have any questions/comments about the site, feel free to ask here.
If this is a large project that will be implemented over a long period of time, maybe you could do a trial run of a few days to a week with each of the available options. Opinions might be useful but direct experience is better. &gt; I would like to develop for mobile with Elm but it's on beta [elm-native has been used in production](https://www.youtube.com/watch?v=Dr3kQB8byEo). &gt; other concern is that there are some missing apis for the language like local storage Elm has a ports architecture that can be used to compensate for missing API. Once you write the couple of lines of JS that solves the localstorage issue, you will probably not have to touch them again. 
Video linked by /u/jediknight: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Elm Europe 2017 - Josh Steiner - Elm native UI in production](https://youtube.com/watch?v=Dr3kQB8byEo)|Elm Europe|2017-07-04|0:21:18|12+ (100%)|789 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/jediknight ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dlz4478\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Cons * Not every web API is supported (Yet) * Ecosystem is active but not as big as you might want * Mobile is not there yet (from what I understand) * some best practices and anti patterns are still a work in progress
Elm is the most established of the three. The focus is on being easy to learn. The elm model is the current most favored way to build a frontend app and since there's an official blessed implementation everything in the elm ecosystem expects to work with it. The ecosystem is small compared to the mainstream languages but large enough to be useful so you won't necessarily need to write everything yourself. Elm is the only pure language out of the three and they leverage it in the package management system and the time travelling debugger. On the negative side, I don't know of any IDE-like support for Elm (completion, scaffolding, etc) and the language is focused on the browser so support elsewhere is limited if it exists. The most common complaint about the language is the lack of type classes and/or macros so certain things like extracting JSON into records are more verbose than they are in languages with those features. Neither F# nor OCaml have exactly those features but they either have workarounds (Ocaml) or it's on the roadmap (F#) while Evan has said he really doesn't want type classes. I did a few small projects in Elm this past winter but I moved onto the other two because I don't like the language's purity. I found interacting with time, timestamps, and other libraries to be awkward and that plus some quibbles about the js output and data structure implementations (that I don't want to argue about, keep rocking on Elm peoples) led me to move on to... Fable is the next most established. I learned F# when they first open sourced it and it's still my favorite syntax of the three languages but I've never used it for a serious project because I'm not on Windows. Microsoft's recent full embrace of open source software has made F# considerably more attractive: VS Code with the Ionide plugin provides a good editing experience (including type providers!), .Net core has first class support for posix environments, and Kestrel as an app server looks good. All told, F# has the best server side story out of the three, which may matter to you if you're wanting to write the whole project in one language. As for Fable itself, the project very much embraces the javascript ecosystem. Things are distributed through npm and the JS code generation is done by transforming the F# AST into a Babel AST and having Babel do the js output so the output JS is pretty good. I also find it easier to consume javascript APIs in Fable than in Elm. On the downside, the transition to .Net Core has been kind of a mess and I really dislike everything around project setup and the build process. Fable itself has a reasonably good setup that kind of exists independently of the rest but I find figuring out all the different options and how they fit together to be exhausting. The other downside is that the ecosystem is small enough that if you aren't leveraging js libs you're pretty much going to be writing your own stuff. Finally, the compilation process produces pretty good results but was fairly slow compared to the other two. Reason is the newest and is still getting established. As an alternative syntax for OCaml it shares with OCaml's rather quirky ecosystem. OCaml has been around for a fairly long time but it's not a popular language. This is usually not a good thing but the people who do use OCaml are super serious about using OCaml so the things that are there are really high quality. It's also led to some ecosystem splits where there are two standard libraries and two async abstractions. Part of the Reason project's goals are to decide on which libraries are blessed and make them all work together so this may be reduced but it's still there at the moment. OCaml is used as a research language so it has more fancy language features than the other two. Modules have overlap with what people do with type classes, the ppx system provides compile time hooks for code transformation (albeit with super ugly syntax), and I'd like to see what an algebraic effects system delivers in a larger ecosystem. OCaml is currently single threaded so it's not particularly attractive server side but it's fast enough that it's not completely hopeless and the effects system seems to be the community's answer. Language aside, Bucklescript is the best to-js compiler I'm aware of. It's extemely fast and produces excellent code a module at a time that works across both languages seamlessly. Merlin provides fairly good editor assistance. The Reason project itself has been spinning on a package and build system but I didn't have much of a problem getting my simple projects going. The browser side ecosystem is firmly based around React (as you'd expect from a bunch of facebook devs) and I believe they're finally happy with the ReasonReact bindings. So that's my two cents. I've done light work in all three but nothing serious. I don't have any immediate demands for them in a project so I'm content with sitting and waiting to see how they develop.
Good analysis I've checking these three, also dabbled with some haskell and purescript but to complex to teach to other devs, I'll keep on the loop with these three languages to check who evolves better
div returning Maybe would make sense to me, well worth the boilerplate.
I don't know F# much, but Elm is definitely a lot simpler than Ocaml (and thus reason). This is the soul of the language, makes it easy being productive with, and prevent a lot of "too clever code". On the other hand, coming from Haskell I miss a lot of features. And I mean *a lot*. Also, the ban of native code in public packages increases the feeling the users can't be trusted with anything.
So my program is guaranteed not to crash as long as I don't make any mistakes?
how do you make infinite loops when you don't have for/while, but rather iteration methods like map and fold? Serious question.
Recursion without any reachable base cases.
Haskell has cycle which turns normal lists into infinite ones, very handy unless you forget how long they might be.
You can't just call a listed feature that's not true a tagline. Elm Lang front page, staring you in the face: "no runtime exceptions". Looks pretty serious to me?
I understand and agree. My good man I take issue with the false advertising. 
til;dr Elm is the least risky of those three unless you need to ship an iOS/Android app in addition to a web app. Of the three, Elm is: * The most battle-tested in production, by a lot * The one with the largest front-end package ecosystem, by a lot * The one with the largest community, by a lot * The one with the most user-friendly compiler, by a lot (Elm's compiler is widely considered the gold standard for user-friendliness among all programming languages, not just among compile-to-js languages) * The one with the nicest package manager, by a lot * The one with the best reputation for beginner-friendliness * The least likely to give you a production runtime exception For these reasons I would choose Elm by default unless you are already an F# programmer, in which case I would consider Fable. If you are already an OCaml programmer I would consider BuckleScript. If you very strongly want to keep using literal React.js (as opposed to any alternative virtual DOM system, such as Elm's), I would consider Reason. Arguments for Reason would be: * It has bindings to literal React.js, so you if you love React you can keep using it. (Definitely relevant if you want React Native. At the moment Elm has some highly experimental bindings to it, but I'd consider it very risky to use them in production.) * Facebook is using Reason in production - only on messenger.com, and I haven't heard any stories of it spreading elsewhere, but still they *are* using it. (I haven't heard of any production Reason success stories anywhere else.) * The editor tooling inherited from OCaml can do some cool things that Elm's editor tooling doesn't yet * OCaml allows mutation (either a benefit or a drawback, depending on who you ask) Arguments for Fable would be: * There's already a good story for using the same language (F#) on both client and server. (Elm has no story for this, and from what I've heard, the OCaml web server ecosystem is very immature right now.) * Microsoft has a good reputation for developer tooling, so I wouldn't be surprised if the F# dev tools were the best of the bunch. (I haven't used them personally.) A controversial argument for either Fable or Reason would be that they have unsandboxed JS interop. This means it's easier to do, but also that you'll inherit some of the problems you're trying to get away from by choosing an alternative to JS - whether you want to or not, because third-party libraries will do it even if you are super disciplined in your own code. In contrast, Elm packages are not permitted to do JS interop, and application-level interop is sandboxed. This means JS interop is more work to do in Elm, but that unreliable JS code cannot sneak into your Elm code to cause bugs and crashes in code you thought was safe, the way it can in Reason and Fable. Finally, I'd note that knowing what I do about the designs of all three, my only interest in ever learning Fable or Reason would be curiosity. Assuming I knew all three as well as I knew Elm, I can't imagine the real-world front-end project where I could make a credible case that either of the other two would be a better choice than Elm. :)
Totally agree that these are shortcomings Elm has...but worth noting that other than mobile, all of these bullet points are _much_ more true for the other two languages than they are for Elm. ;)
As long as you don't make any big mistakes. In JavaScript, even a small mistake will do you in.
Hopefully no one trusted with writing software is naive enough to believe the claim literally. You can also write bad recursive code, use `Debug.crash`, or fiddle with the runtime while it's running to break it.
I don't think this is a very significant problem, but perhaps the compiler can attempt to detect potential bad math. Changing the output of a division operation to be a Maybe would cause far more problems than it would solve.
The problem is that almost every arithmetic operator can cause a runtime exception. Even our simple friend the PLUS function ('+'). I can't remember if ELM uses Bigint or is limited to 64 bit integers. But even if it uses BigInt numbers, your computer could add a Googol (10^100 ) to a Googol, but it would fail to add a Googolplex (10^10^100 ) to a Googolplex because no computer can store that many digits (even if it stored a bit in every Planck space in the known universe). Division of floats can overflow and underflow. 
I just don't know much about them other than the fact they exist.
&gt; So that is the halting problem and is unsolvable. It's not unsovlable. It's a tradeoff. Check out Idris and [total functional programming](http://sblp2004.ic.uff.br/papers/turner.pdf).
So long as a language is turing complete, it is undecidable. You can remove certain things from a language (recursion) and still have 99.9% of the functionality but have it not be turing complete and in that case you can transform it into a solvable problem. 
I also understand you and yes, if you take that to the extreme it can seam like false advertising. I don't view it as false advertising. From my own experience the claim stands. I'm currently programming a web app that has the backend in Elixir and the frontend in Elm. From the point of view of runtime exceptions, Elm has the better experience and Elixir is a wonderful language. 
I also used to be a bit angry about it :P
So I wouldn't call the halting problem "unsolvable". It presumes some very strong conditions on what you actually want to do in your problem domain.
You can't do it with map or fold. But with recursion, you can.
It is better to think of it like "Elm doesn't let you make a lot of the mistakes that end up generating runtime exceptions so the probability that you will have runtime exceptions decreases so much as to practically have NoRuntimeExceptionsâ„¢ in deployed code". 
Or worse than crashing, integers in Elm are actually floating point numbers in Javascript, aren't they? It's easy enough to pass off arithmetic as being done mod 2^n, but it gets to be even worse when suddenly incrementing becomes an idempotent operation on very large numbers.
I've been reading/watching videos about how to construct Islamic geometric tiling patterns using only a ruler and a compass. To help learn Elm I'm trying to follow along in SVG, making an animated howto for a couple of patterns.
In terms of native code, I see your point, but the problem is as soon as you start to allow it then all the purity and type assurances go away. So if you did allow it then any package could have side effects. So the choice is to allow it and live with the fact that you now can not make any guarantees about your packages or don't allow and make the guarantees. 
There are other choices, like tagging such packages as unsafe and letting the users decide. In the end, it is their code base.
The problem isn't that division causes a runtime exception, but that the Elm web page claims "no runtime exceptions". Elm is a new language with a small community, and needs to attract new users. As a new user, when you read "no runtime exceptions" and proceed to get a runtime exception doing simple arithmetics, you will start wondering what other claims are lies or exaggerations. I think it is a significant problem, and it could be fixed very easily by adding the word "almost".
that is one of the most polished // complete // beeeautiflly written answers to this question I have read to date! I am personally in love with F# for many reasons BUT all in all is less of a pleasure when it's time to write stuff for the web (IMHO). 
True. I for one like the idea that I can be sure that all of the packages in the repo are infact safe. Maybe some sort of compromise could be allowing packages to install some kind of code that would be invoked over ports so you could limit things at a type level but still be able to access the outside world
in all fairness, the frontpage says: "Elm code does not produce runtime exceptions **in practice**."(emphasis added) which is a fair statement considering, as you said, that if % returned a Maybe it would become impractical.
Elm is not a full programming language and it shows. That can be a good thing and a bad thing. You'll probably need to do code generation at some point for example. 
So, that's actually pretty easy to set up: https://ellie-app.com/46LmtHfkwdSa1/0 The issue is that those really aren't very nice types to work with. So you'd start writing function to actually extract info from that and marshal them into your own types. The API you'd end up with would be what we currently have under the form of `Json.Encode` and `Json.Decode`. I actually use that exact structure to give a mental model of what json decoding does.
Would it be easier for newcomers to learn to write decoders by using case expressions, instead of having to learn the current Json Decoder API? Also, if it is a useful mental model, then why have I never seen it mentioned as a way to think about decoders? One other thing to note: when you use the decoder you defined in your example, you end up with a `Result String JSVal`, even though decoding can never fail, because you have accounted for all options. Edit: In that last point, I'm referring to decoding from Values, not Strings.
Values are just JavaScript variable. So if this can only ever work on plain JSON: sure. If it needs to work on arbitrary values, then yeah, not really. Cyclic references (for example in DOM nodes which have a `parent` _and_ `children`), functions, etc. Patternmatching on this structure for anything other than a tiny example (or when your domain truly is arbitrary JSON), would be quite horrendous. I think it would definitely be less convenient, much more verbose, probably more error-prone and less flexible than learning how to use JSON decoders. The API for json decoding also transfers nicely to working with a bunch of other things in Elm, like Random generators, fuzzers and parser libraries to name a few. It's cool to try and build the Json.Decode API on top of that union type, tho; even if only as a means of gaining some insights.
Last time I tried dividing by 0 in Elm I did not get a runtime error, I got a wrong answer of 0. Did something change?
Certainly looks that way. A wrong answer would piss me off 
The only people I've heard of doing Elm code gen are using Haskell on the server, and they're doing it to avoid the JSON marshalling synchronization everyone normally has to do by hand when using different languages on client and server. It's an opt-in benefit, not a mandatory cost like you're suggesting. &gt; You'll probably need to do code generation at some point I don't know if you know this, but making such a wildly inaccurate claim in such a confident tone primarily serves to undermine your credibility.
I kind of miss PureScript and Haskell/GHCJS (both strongly types, compile-to-JS langs). Also Elm comes with more batteries included, so you need some "app framework" in conjunction with the other languages/compilers. 
That makes sense. That's a good point about cyclic data structures. I had forgotten that that was possible. Now that I think about it, I agree that my idea would be less convenient and more verbose. But why do you think it's more error prone? Now that I'm looking at the normal Json.Decode API, I'm realizing that the "Json Decoders are hard" meme tricked me into thinking that they were something complicated and obscure, even though they just use the same mapN/andThen pattern that shows up everywhere. This is kind of ridiculous, given that I had already done the exercise of building the Json.Decode API out of the union type. Anyway, although I still think we should look for ways to make Json Decoders easier to learn, you have made it clear that my idea is not the way to do it. Thanks for taking the time to respond!
Why would you need to do manual synchronization when using different languages but code generation for Haskell? That makes no sense. Just use code generation for all combinations of languages (except Elm/Elm obviously) for Json marshaling. There are also good reasons to do code generation even without the json parsing problem. Look at my project Elm-Cog for some examples. "Probably" isn't the most confident word I could have used. Not even close. 
I just wrote some decoders at work and the thing I find disturbing is the lack of keyword arguments for stuff where the types are just a bunch of strings. Very easy to screw up and trivial to fix with code generation. 
I'm just gonna leave [this here](https://ellie-app.com/46WzmVYwwVKa1/0). Also, if you really want to create something cool you could try to do something like [this tool](http://www.engineering.uwaterloo.ca/~alopyrev/cs791/islamic_stars_report.html). If you really want to create something useful, create a background generator like [this one](http://www.heropatterns.com/) or [this one](https://philiprogers.com/svgpatterns/). 
That's quite shallow :(
Thaks for the feedback, I will make a more in depth one in the next week or two
You could define a decoder combinator like this: (|=) : Decoder (a -&gt; b) -&gt; Decoder a -&gt; Decoder b (|=) mf mx = Json.andThen (\f -&gt; Json.map f mx ) mf infixl 0 |= Then you can write the following: import Json.Decode exposing (..) fooDecoder = succeed Foo |= (Json.at ["a"] Json.string) |= (Json.at ["b"] Json.string) |= â€¦ etc It is a little more verbose than what you are suggesting, but it gives you the type-safety you want.
Isn't that exactly the same thing as my example but with slightly different syntax? I'm not asking for type safety since the types are all strings. That won't save me. I'm asking for matching keyword-style in the decoder instead of positional. 
It is exactly the same. Oops. :)
I know of a few solutions, each with tradeoffs. This post describes one of them: https://medium.com/@eeue56/json-decoding-in-elm-is-still-difficult-cad2d1fb39ae The big catch is that it requires significantly more boilerplate, so I'm not sure how practical it really is. If you also happen to use Json.Encode with the same types that you're decoding, then fuzz testing the round-trips is a very good idea: https://www.brianthicks.com/post/2017/04/24/add-safety-to-your-elm-json-encoders-with-fuzz-testing/ And if you don't want to actually write separate encoders but still want the round-trip fuzz tests that will catch field-ordering bugs, there's this library I wrote: http://package.elm-lang.org/packages/jamesmacaulay/elm-json-bidirectional/latest You'd still have to write the fuzz tests yourself, but at least you get the encoders for free. I have an un-merged branch that would give you the fuzz tests for free too: https://github.com/jamesmacaulay/elm-json-bidirectional/pull/3 ...but if you use that then your production code would get a bunch of Fuzzable unnecessarily compiled into the bundle along with your app code.
I think it's the other way around. In general computing, determining if a program in a turing-complete language, on a turing machine, will complete is indeterminable. If you impose specific conditions, you're no longer talking about a general case of the halting problem.
It's a little more verbose bit you can use closures and record update syntax.
Could you elaborate with a short example?
sure [here](https://ellie-app.com/477Nc3S4tvya1/1) is a bit of what I'm talking about. Like I said, it's a bit verbose but it does map key to key. 
Thanks! Yea that is pretty bad as far as verbosity goes. Hmm... but I might use that as the output of the code generator I'll write to deal with this. It makes it a lot easier to quickly verify that the code generator outputs correct code. 
Do you really need this as a record? Why don't you use a [Dict](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Dict#Dict)? Then decoding becomes [easy](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Json-Decode#dict).
How did you get a runtime error? https://ellie-app.com/47cvVqQbD7Va1/0
Strange. Replace the division with a modulus.
It's cool that you're into code gen, but statistically that makes you an outlier among Elm users. Saying that the typical person will "probably need to be" an outlier in the same way that you are undermines your credibility. ðŸ™‚
Can't wait to try this! Needed something like this today after seeing gotchas in other tools.
Hey, thanks for the interest! Let me know how it goes, and please report any bugs you find under the repo issues.
The moment you realize that the only thing more friendly than elms compiler messages is itâ€™s creator
hear hear
I'm into not writing error prone boilerplate. I would hope that elm gets some features so we don't need that, but right now code generation is the lesser evil. I agree that you can get away with writing tons and tons of error prone boilerplate instead of doing code generation. And upon further reflection I also agree with you that's what most people will probably do. But that's a bad thing that hurts their productivity and produces buggy code. You claiming statistics without actually having any undermines your credibility more I think than my much less confident statements. And continually talking about credibility instead of tech makes you seem petty imo. 
If I decode to a dict I need to decode the dict later. Don't think that's much better, and I assume it's slower. 
What are the pros of using Elm Factory instead of Elm Reactor?
Great question. The primary features that Elm Factory provides, which don't exist in Elm Reactor are: - a build system for production environments - out of the box elm-css support - livereload with css injection - the ability to use custom html templates so you can load additional css/scripts etc
Is this live reload also for when you're embedding Elm inside an existing app? That would be pretty great!
I've just invested more into elm-cog instead of trying to find some way of doing this inside Elm: https://github.com/boxed/elm-cog It was pretty easy to implement a really nice code generator based on the work I already started. 
Decided to use the more standard syntax in my code generator: https://github.com/boxed/elm-cog
See my code generator for a solution to this: https://github.com/boxed/elm-cog
IMO the fix for newcomers is to update Elm so you don't really need to write decoders for the vast majority of cases. Look at my code generator for an example of how this can be automated until Elm has this feature: https://github.com/boxed/elm-cog
And so I did fix it with my code generator: https://github.com/boxed/elm-cog
If you settle on Elm, look at my code generation system: https://github.com/boxed/elm-cog It can vastly cut down on error prone boilerplate.
&gt; The only people I've heard of doing Elm code gen are using Haskell on the server Well, maybe you've just not heard enough. I'm pretty confident I'll introduce elm-cog at work shortly. Especially for encoding/decoding and enums it's obviously superior. Check it out: https://github.com/boxed/elm-cog
If you were to embed the script from the dev server, then yes. I am currently using Elm Factory with an electron project and getting live reload.
Cool. I'll definitely try this out at work Monday. 
Haha I was wondering when this was going to be uploaded. This is a great sequel to impossible states
oh god. please just come up with a sensible name that stands on its own.
Really great talk. Definitely bookmark-worthy to go back and watch again. [This part](https://youtu.be/XpDsk374LDE?t=572) is certainly interesting and IMO is the start of a conversation with the UX/Design team. If the user experience of these two checkbox list views should truly be the same and consistent (**they have the same invariants**) then that is an opportunity for reuse. Implement both features and reuse the same view functions if they have the same invariants. Now let's say requirements change. In one view there is a behavioral change. We need nested checkboxes. **The invariants for that module changed.** That's fine. This is the start of a conversation. Should the fruits checkboxes exhibit the same behavior? The fruits list still need the original behavior? Ok, let's create a new module that allows for nested checkboxes and guarantee the invariants we want for the nested checkbox module. **We are no longer reusing the same code because there is a significant difference of invariants.** Requirements change again. The "fruits chooser" needs to allow a maximum of two fruits. Ok, no big deal. That's another convo with the UX design team because the invariants changed again. Does the original checkbox list need to exhibit bounded behavior? No? Ok let's make a module for a bounded checkbox list and discard the original checkbox list module. I don't think the fact that we're talking about reusable views makes it different than any other Elm code. We're still talking about reusable functions and creating modules that maintain invariance.
Okay, thanks for making your position clear.
Why? Atom is free and it works great with Elm. 
Theoretically, sure, it *could* compile to whatever you want it to compile if someone took the time to reimplement the compiler and the core libraries. Practically, why would you want it to compile to some toy language that's barely 2 months old? (I'm assuming that you are referring to [this](https://github.com/MaiaVictor/moon-lang) project)
I personally view the checkbox argument as being flawed. If I have a data structure and a widget, I sometimes would rather adapt my data structure to the widget than reimplement the widget. This is not so obvious if the reimplementation of the widget is not sufficiently complex. Things change if the app has to follow a visual identity (let's say Material Design) and the widgets need to be WCAG compliant. The argument also ignores the fact that in 80% of the cases, you want the simple checkbox list. It's similar to arguing that providing a grid layout is pointless because layout is complex and a lot of the cases don't neatly fall into a grid paradigm. 
ha ha. any name will do. i just want my elm on ssr. :D
I would not call it a *toy language* and obviously we can wait for it to mature. To answer your second question. Why should we compile elm to some form of *(functional) assembly* instead of javascript directly? For the same reason Haskell, Java and C# do.
I do not think so. But last time I checked it was not so hard (cca 10 minutes) to create your own. 
&gt; I would not call it a toy language and obviously we can wait for it to mature. Please forgive my ignorance. Is this language used by anyone (other than the original creator)? Maybe there is something I'm missing here. &gt; To answer your second question. Why should we compile elm to some form of (functional) assembly instead of javascript directly? For the same reason Haskell, Java and C# do. As I said, Elm (just like every other language) could theoretically compile to a lot of targets but to move from theory into practice one would need a practical reason. If someone implements a compiler for any other target and shows practical advantages, then the theoretical possibility could turn into some practical implementation. In theory, a lot of things sound wonderful. In practice, there are tradeoffs to consider because every design decision has advantages and disadvantages. On a more realistic level, the next compilation target might be webasm but even that is probably years away. 
ReasonML has decent React interop... I hear - never tried... So perhaps that ameliorates things
I mean... the readme explicitly calls it a toy language. Edit: I was looking at [this project](https://github.com/glampert/moon-lang), not the one linked above (which seems more likely what OP was talking about). Was on the phone.
Look at the open issues. Still looks like a toy to me...
I just glanced at the js code gen and it doesn't look like a lot of code unless I just missed big chunks. Doesn't look too bad as long as the other target is not too different from js (C would be hard, Nim/Swift/Go probably a lot easier). But it would of course require someone to actually care enough to do it which is probably the hard part! 
Evan has [answered this one directly](https://github.com/elm-lang/projects/blob/master/roadmap.md#when-will-elm-compile-to-x). :)
&gt; Can we achieve this? Or should I just go for code generation which is what I'm considering now? If the JSON is coming from a third party, the answer is to write tests. Field ordering mistakes are only one of many things that could be mismatched between your business logic and third-party JSON; there is no reliable way to avoid testing this! On the other hand, if you control both the client and the server, then sure, using code generation between the two is a reasonable way to keep both sides in sync automatically. People do it in Haskell, and it looks like you can do it in Python too. Incidentally, if you want to tell people about your library, you can just post a link to it. People will see it. You don't need to invite discussion and then respond to every poster that you've decided to use your library instead of what they spent time suggesting.
Is your point that when requirements change, you have to change your code? I agree with that, but I'm not sure how it connects to this talk.
&gt; If I have a data structure and a widget, I sometimes would rather adapt my data structure to the widget than reimplement the widget. I don't think we have to choose either of these! My general approach is to model my data in a way that makes sense for my business logic, and then if I want to use an off-the-shelf widget, write a transformation function that takes data in my format as an input and outputs the format the widget needs. That approach has served me well so far! ðŸ˜„
I had this problem at work. Only after seeing the responses did I decide to add it to my lib. You can check the timeline in git and compare to this discussion if you want to verify the order. It's not just about keeping the server and client in sync if I control both though, it's about not writing code that is easy to screw up that a computer can write perfectly. Tests aren't the solution to this, just as the solution to a lack of static typing isn't tests (which is why I so strongly recommended Elm at work over ClojureScript in the first place, and why we all decided to go with it!). 
To be more clear, the part I linked to in the video was a bit of a bait and switch. We are shown two checkbox lists that appear to have the same behavior and are asked what we think the code will look like. It's reasonable at this point to think that there will be shared code. They appear to exhibit the same behavior after all. Later we learn that the two checkbox lists have very different behavior. That's fine, but at that point I'm not sure anyone is still thinking there will be significant amounts of shared code like the linked time in the video implies.
Oh, and I don't want people to use my lib, I want something built in in Elm. Like "deriving enum", "deriving decoder" etc. This would be way superior. 
Not really showing anything new if you're already familiar with Elm but I love listening to him sharing his way of thinking about anything really. 
You could do better than ask support: put a button on the page to report an issue and that automatically sends the data. 
Very interesting way to introduce the idea of invariants and isolation into modules. I still wish there where ways to define those `member`, `empty`, `remove` and `insert` as Protocols tho.
Could you tell us why, do you think, should Elm compile to the moon-lang?
Noredink has like 200k lines of Elm code and they did not detect any runtime exception on production. It does not mean it is not possible to create a RTE, but in practice, there are no exceptions. On the other hand, when coding in JS there is almost no a single day without noticing exceptions on production servers.
Released a UI library for expandable menus and other "accordion" interfaces. http://package.elm-lang.org/packages/ericgj/elm-accordion-menu/latest/AccordionMenu
&gt; I want something built in in Elm. It sounds like you've gotten the same idea that [Evan did in 2014](https://groups.google.com/forum/#!topic/elm-discuss/hA18E1Dseck). He's well aware of the tradeoffs here, being a longtime Haskell programmer as well as the very first author of Elm code that talks to a server via JSON! So this is not a new idea; it's actually an incredibly old idea. If you think you have some new information to add to the conversation, cool - but I'd suggest starting by reading through the elm-discuss mailing list to catch up on what has been covered already. It's important to note that Evan has shown himself to be very receptive to exploring new ideas, and fiercely resistant to giving the loudest complainers what they want in hopes that they might leave him in peace. I get that you "want something built in Elm," but you should know that you're not helping your odds by hopping around to every JSON-related comment on /r/elm lobbying for it. It won't bump your feature request to the top of the priority queue, but it will alienate community members who are tired of people publicly lobbying Evan to spend his time how they see fit.
&gt; Tests aren't the solution to this Here is [GitHub's public JSON API](https://developer.github.com/v3/). Without using tests, how would you verify that your decoders work with it as expected?
Yeah. It was a very nice talk. Not preachy, but doing justice to what Elm has that React doesn't. And very upfront about the intentional trade-offs that are very likely to turn certain people off at first.
I added google's closure compiler to my projects, and with the latest version, it gets my projects down to about 8kb. 
I do agree with Evan that language design should be slow and steady and not just quickly cobble together stuff. But in the mean time before the features arrive people shouldn't write bad code. 
That's not the "this" I referred to in my comment. I meant making sure your encoder, decoder and data structure are in sync. I've read blog posts suggesting fuzz testing just to make sure encoders and decoders are in sync (which won't even check that they're in sync with the data structure). This seems quite unnecessary if you just have a computer make sure they are generated (however that happens) from a single source of truth. Obviously you need tests at some point!
There are definitely memory/performance implications, I've run into some myself: https://github.com/elm-lang/virtual-dom/issues/90
Very very nice stuff! Thanks for the links. Gives me something to aspire to, as well as good info. This is the article that got me going - a howto for one particular design.
Are you installing from Hackage? It's woefully out of date. I'd recommend either using npm to install it, or the BuildFromSource.hs script.
you can install it in two steps, really. curl -L https://git.io/n-install | bash npm install -g elm 
I like the immutable data &amp; syntax remark at the end - never thought about that before (wrt Elm at least!)
I was thinking of compiling Elm to go. But just don't know where/how to go about it. 
My first instinct would be to: - compile the elm compiler - create some very simple example - change the output from the compiler piece by piece And expect to fail and throw away all the work at least once, probably twice or more. Once you've got something that works you'll need to figure out how to abstract the compiler backend so that the compiler can support two backends instead of just one. 
I do not think that really address this particular case. Moon is an assembly for functional languages. It is a man in the middle - intermediate representation. It does not provide some great ecosystem of libraries - **its feature is simplicity**. Now I am aware choosing different back end is not a priority. On the other hand, somebody from community might find this idea interesting and will not mind to invest his time into implementing a prototype.
Via Cabal so maybe it pulls elm from Hackage? The Idris packages is up to date so...beats me. I guess I'll try npm.
I can't say anything about that project in particular, but to the larger questions of: - Can I run Elm on servers? See [this](https://github.com/elm-lang/projects/blob/master/roadmap.md#can-i-use-elm-on-servers). - Can Elm compile to node? See [this](https://github.com/elm-lang/projects/blob/master/roadmap.md#when-will-elm-compile-to-x)
Yeah, the Elm maintainers have stopped uploading packages to Haskell, which is where Cabal pulls files from. You can use Cabal to install it a local copy from the Github, but you might as well use BuildFromSource.hs which automates the process. Npm is the easiest since it just installs a binary.
I think elm uses javascript numeric values, which are floats. That means for integer arithmetic it is just using the mantissa, which is 56 bits. So integer arithmetic in Elm is a bit weird compared with other programming languages which tend to be 16/23/64/128 bits following the powers of 2 sequence. I may be wrong about this...
Agreed. 
Have an error doing the npm way Error extracting linux-x64.tar.gz - Error: EACCES: permission denied, mkdir '/usr/lib/node_modules/elm/Elm-Platform' npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! elm@0.18.0 install: `node install.js` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the elm@0.18.0 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR! /root/.npm/_logs/2017-08-27T21_45_17_560Z-debug.log 
Two guesses. First, what happens if you try with Sudo? Second, does the node command point to the right executable? I'm assuming you're on Linux, and I know a few other packages use it.
Okay got it with Yarn fine. Can't start up a repl because of an error regarding `lintinfo.so.5` not existing.
To quote Evan's post (emphasis his): **The hard part of supporting a domain is not the compiler. It is making a good ecosystem.** As you noted, Moon "does not provide some great ecosystem of libraries" - which is to say, it does nothing to address the hard part of supporting a new domain!
Does Anyone mind being my mentor and look at this file and let me know what mistakes I'm making as I try make an Elm app. Right now I'm having difficult posting Json to a server using Http.post , a little confused on where I should call it and whether I should use Http.send. Basically information overload. https://pastebin.com/RatM86uS 
Sorry - left URL out: https://www.theguardian.com/science/alexs-adventures-in-numberland/2015/feb/10/muslim-rule-and-compass-the-magic-of-islamic-geometric-design
&gt; My general approach is to model my data in a way that makes sense for my business logic, and then if I want to use an off-the-shelf widget, write a transformation function that takes data in my format as an input and outputs the format the widget needs. This is by far the best approach and it is what I meant by "adapt my data structure" but in order for it to work, there should ideally be a reasonable large set of off-the-shelf widgets that would allow this. Elm simply doesn't have this large set of off-the-self widgets. Just to be clear, I'm not saying that it is not possible to do this with Elm, of course one can do this using one of the adapter libraries like `elm-mdl` or `elm-bootstrap` or manually adapt some other framework. It's just that an approach like this did not make it high enough on the priority list in order to get a proper design and the blessing of Evan. This makes it a subpar experience. Actually, I think it is worst than that with the whole "**We do not think in terms of reusable components**". There is this wonderful whitepaper I read some time ago that breaks the UX in five planes: Strategy, Scope, Structure, Skeleton and Surface. With its amazing data types Elm covered the Strategy level (Business Objects) very well. With the advent of The Elm Architecture, the Scope level (user stories, business objects transformations) got solve very well. Now, with 0.19 I assume that the Structure (pages) level will also get solved. The last two levels will get solve in a single go as the solution to providing Structure (layout) and Surface (styles) will probably be the same (CSS equivalent). Then we will have a wonderful experience at all levels. :) 
Very nice article! I haven't seen it before. It reminded me of the small TEDTalk about [The complex geometry of Islamic design](https://www.youtube.com/watch?v=pg1NpMmPv48).
Video linked by /u/jediknight: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [The complex geometry of Islamic design - Eric Broug](https://youtube.com/watch?v=pg1NpMmPv48)|TED-Ed|2015-05-14|0:05:07|20,547+ (98%)|553,485 &gt; View full lesson: http://ed.ted.com/lessons/the-complex-geom --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/jediknight ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm84k8j\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
You can setup your server to serve the debug version if it sees debug anywhere in the url. (e.g. `/#/page?debug=true`). This way, the regular users are unaffected and the users that want to provide feedback can provide it in the way that is currently supported. 
Good idea!
&gt; He's well aware of the tradeoffs here What tradeoffs are you talking about? I have read the discussion and nobody mentioned any tradeoffs whatsoever...
The TL;DR of this is to be smart about what you do and don't expose, and make sure you take your time to plan your API in a way that doesn't expose itself to being broken by users misusing or misunderstanding your API (including yourself in 2 weeks) Good post :) I look forward to the next one.
&gt; he wants us to pick something that won't fizzle out after a few years Would be interested by this too, what did he pick? More seriously, this is religious territory, and you can't really "win" with technical arguments. Perhaps you can have some luck with starting a small project, with some of your coworkers, to win them over ...
He hasn't picked anything. It's up to the developers. That's just his desire.
And I thought this will be an article about proving some theorems with Elm :D
We recently chose Elm at work, switching from Angular. It went something like: - Everyone agreed that angular sucked - Everyone agreed that javascript sucked - We wanted something that was fun/interesting to work with and something that people would be excited about when interviewing (this might appeal to your boss: it's not really interesting finding people who have already done something, you want people who say "ooh, you use Elm? I want that!") - We evaluated ClojureScript (used elsewhere in the org) and Elm by rewriting a page in both, watching a bunch of videos etc - We discussed, and discussed, ad neauseum... - At last we just took a vote. 100% of people who voted voted Elm. Now we're looking at rewriting a page in development that hasn't yet been released. I was gonna start today, but got other things on my plate :P
Well, as much as i would like to use Elm in production code, i know its a nogo for us. The semantics and fp concepts are too different to get new people onboard fast enough. That said im quite happy with TypeScript for now. A good and easy transition. For hobby stuff, small protos im always reaching for Elm, and even tried Purescript.
&gt; The semantics and fp concepts are too different to get new people onboard fast enough. Out of curiosity, what do you mean by "fast enough" for your team? What kind of on-boarding experience are you aiming at? I'm asking this because this topic is dear to me. I do understand that Elm might appear weird at first look to people without experience in ML-derived languages but actually learning the language is quite a pleasant and fast experience as long as you trust it. 
&gt; He wants to be able to pluck a framework X developer off the street in the future If he wants average it is better stick with one of the more famous frameworks. If he wants to [beat the averages](http://www.paulgraham.com/avg.html) he might be better served by Elm. &gt; and he wants us to pick something that won't fizzle out after a few years. Elm is growing and with each version, new things become available and more people are ready to investigate it seriously. I'm updating from time to time the Elm Dash docset and each time there are more and more packages. When I started out, there were 120 packages, now there are 684. I'm sure that this is reflected in other metrics like the number of people in the slack channels or here on /r/elm . NoRedInk has grown their codebase to about 200k LoC of Elm. This provides such a large investment that it practically ensures that Elm will continue to grow and get better at least as long as NoRedInk exists. So... no fizzle in the foreseeable future. &gt; I need some hard data to turn the recalcitrants to my side! You want to use reason in order to persuade. This works sometimes but some other times it is best to approach things differently. Take a look at [this video](https://www.youtube.com/watch?v=_DGdDQrXv5U), it might provides a few ideas about how you might be able to approach things differently. 
Video linked by /u/jediknight: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Mr. Rogers and the Power of Persuasion](https://youtube.com/watch?v=_DGdDQrXv5U)|Will Schoder|2017-06-17|0:23:41|4,179+ (99%)|67,132 &gt; Produced by Yellow Bear Films (https://www.yellowbearfilms.c --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/jediknight ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm8u44t\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
[removed]
You cannot prove anything "has legs". Technology comes and goes. Frameworks in Javascript are fickle as fashion. Let's imagine you were trying to pick a framework a few years ago with all of the same constraints and you picked Angular 1. Other than sharing the name with another framework today, that framework has "fizzled". Also, being able to "pluck" a developer off the street to just plug in and have them start working is an ideal based in ignorance (your boss's). Even if I know your framework, I probably won't know your application or your business. You want developers who excel in learning because there's more to your technology than just a simple framework. Also, one thing to consider is that once developers start using Elm, they won't want to go back to Javascript. So they won't want to leave. And you'll be very attractive to other developers at other companies who want to leave but also don't want to go back. And developers who long to program in Elm but cannot at their current jobs. You'll also find that those early adopters are typically the cream of the crop developers. Don't you want those type of developers over commodity programmers? Maybe you do but your boss doesn't see value it that. Once again his ignorance. You will improve your developers capabilities and understanding with a functional language. Elm is great first dive into that. There are no guarantees. When we developed in 0.8.x of Node, people thought we were crazy, but I saw the future in Node. Now look at it. Geez, even Walmart uses it. Now we are at the same point in Elm's life. Are you going to be ahead of the curve or not on this? Maybe your boss has other constraints so he doesn't care about a lot of the things I've mentioned here. If that's the case, you may want to look for employment elsewhere. Perhaps an Elm shop :-) 
A lot of what you said has been on my mind, but I don't trust that thing because it's so subjective.
I totally used the Blub Paradox in my presentation. Thanks for the video link!
At its' heart, programming is about automation. They should not be searching for a technology that allows you to pluck a framework X monkey from the local zoo. When you think you want lots of monkeys, what you really want is a technology that provides great automation and a few thoughtful humans to control it. The automation intelligently used automates away the need for lots of monkeys.
Yea, we may just end up tossing TypeScript on top of the apple cart. However it wouldn't help us in our current situation. My coworker and I have been hammering away at the React/Redux app for a few hours now and can't figure out how to make it do something simple that the Elm app didn't break a sweat over. There's some magical glue missing somewhere that we don't understand yet. There are no types for magical glue. :(
Good for you, random redditor. May you sense my envy waves from afar.
Oh sorry. I have no idea how to do that. Proofs were my least favorite thing in math classes.
Works great! I've already changed my package.json to run elm-factory as default for `npm run dev` for my project. Pretty much drop in with no problems. Does `dev` need to have an output option? Works for me but wondering if having an option to spit out `bundle.js` or something like other watchers would be helpful? If this is nonsense, just ignore this suggestion. :)
Move to Stockholm. We're hiring :P
Hello, I have a small issue setting up elm with atom. I followed [this guide](https://github.com/knowthen/elm/blob/master/DEVSETUP.md) but when I try to save an elm program an error pops up saying "Can't find elm-format binary" while I downloaded it and set up its binary-path in the settings as "/usr/bin/elm-format" the place where I put the unzipped file. What did I miss ?
Working on improvements in [elm-ast](https://github.com/Bogdanp/elm-ast)!
Best snippet from that: &gt; Folks like to think languages are â€œgeneral-purposeâ€ and if the language is good, it should be good at anything. People say C++ is a general-purpose language, but it is not so nice for web apps. People say Python is a general purpose language, but it is not so good for operating systems. And you cannot just â€œmake Python good at operating systemsâ€ by compiling it to C. More notes on â€œgeneral-purposeâ€ as a questionable concept [here](https://github.com/elm-lang/projects/blob/master/notes/on-general-purpose.md).
Hey squarism, glad you ended up trying the package out! What you may be looking for is the `build` command? Try `elm-factory build --help`. The build command will compile your elm application and extract any assets that you have tagged with an `AssetUrl` type (tag will be configurable in the near future) and rewrite urls with the defined `--public-path` I am currently working on some guides of how to integrate the elm-factory pipeline into existing projects, and a better getting started guide. Stay tuned, lots more to come!
I'm super new to elm so I'm building a simple Uno clone! Planning to add a backend in Haskell later to help learn that and make it multiplayer.
Oo neat idea! Fun. I've wondered if there's some libs that are very generic for card games. I found a js one but I haven't kicked it around yet to see if it can be adapted for Poker / Magic / anything. Not that I'm building those but I'd want something *that* flexible.
I'm working in TypeScript (with Angular2) right now and I sure wish I was working in Elm. The problem with TS is that it doesn't change the semantics of the underlying JavaScript, so you can still have `undefined` and `null` creep up. Also the TS type checker isn't as smart as the Elm type checker, so if I get something wrong TS doesn't infer the correct type so I have to walk through the entire codepath from REST call to component view and infer the type of the value flowing through the system. In Elm, the compiler just does this for you.; I've been at this job only 2-3 weeks and I've already convinced my coworker to make our next project in Elm :) I basically just kept pointing out the technical superiority of Elm but without going too far into category theory. I just make Elm look way simpler than all the complexity of JS/TS (which it is). &gt; There's some magical glue missing somewhere that we don't understand yet. There are no types for magical glue. :( There kinda are types for this, monads and functors are basically type safe design patterns, and Elm's runtime allows you to cover almost all side effects with the type system. In TS/Angular you have to follow a specific design pattern, and if you screw up the design pattern the app just doesn't work. In Elm if you screw up the design pattern by forgetting a case branch in your `update` function, then the compiler tells you.
Thanks for sharing your experience with TypeScript.
Off the cuff - a few weeks? One coworker guessed that it would take four to six months to ramp up on Elm. I dunno where that number came from. We don't have any set time that's expected. What I can speak for is the small Elm lexicon, type annotations in the documancy, and the compiler making ramp-up smaller than it might be in some other alien language. Functional programming concepts and ML syntax increase ramp-up time. However my team has agreed on using something immutable and functional. So my coworkers have agreed to jump in, but without the floaties on their arms, i.e. Elm's compiler. I think they still are in the honeymoon phase with JavaScript.
An Elm production web app with Crystal backend for the "Customer Magazine" in my city. I used a bootstrap clean template but I needed to cut off all the JQuery trash. I am really missing something similar to Elm in backend &lt;/3
Making a stateless web app using web sockets and authenticated using jwt. Let's everyone at a party sign in with this favourite music streaming service (spotify etc) so that I can get their music preferences, and play a good mix for the whole party. Really just want this for myself and my friends XD.
I am prepping a talk for the Tel Aviv Elm Hack Night, on using types as a design tool. In addition, I am putting out more videos on Elm on my youtube channel https://www.youtube.com/watch?v=H4hvkR3Kypg
Video linked by /u/get-finch: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Using Elm Types to eliminate broken icons](https://youtube.com/watch?v=H4hvkR3Kypg)|Pain Free Web Development|2017-08-28|0:04:39|2+ (50%)|144 &gt; Ever have a web app not look right because a CSS class got... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/get-finch ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm9q6aw\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
If you have the opportunity to find a new team to work with, this sounds like your signal
&gt; Off the cuff - a few weeks? &gt; One coworker guessed that it would take four to six months to ramp up on Elm. I dunno where that number came from. I spent 2 years wishing to learn Elm. I always seamed like it would be such a big undertaking since I was never exposed to this kind of syntax. Pattern matching looked like magic back then. I bit the bullet in 2015 and decided to **actually** try and learn it. It took me a week of very relaxed coding (few hours per day) to get to the point where I was like "I know Kung Fu". I wrote less than 1000 lines of code to get to this point. Sure it will take longer to get to the point where one has control over crazier things (like decoding weirdly formatted JSON) but a new developer should be able to become productive very fast. Also, because Elm is such a safe language, one could give production code to new developers since a lot of the silly mistakes like misspelling field or variable names are caught by the compiler. I remember Richard telling the story of a form that used to be a dread zone to edit for senior developers that after the move to Elm became junior level safe. &gt; Functional programming concepts and ML syntax increase ramp-up time. They are under-estimating their brains ability to pattern-match. If they look at enough small examples in a short period of time, their brain will be able to pick up these concepts in no time flat. Elm is just `smart data` + `functions`. You learn how to - define custom types - pattern match the custom types - define functions - define functions that take other functions - compose functions so you can pass them to functions that take functions - The Elm architecture - managed effects - JSON decoding/encoding - Collaborate with JS via ports That's about it. Each of these lines take hours to learn, not months. Your colleagues intuitions are wrong just as my own intuition was wrong before learning Elm. I believe that if they would spend 2 hours per day for one week, a total of 10 hours with Elm, it will be impossible for them not to readjust their estimate. Another, more compact, way of doing it is with [a two day workshop](https://frontendmasters.com/workshops/elm/). 
Hi, Quite new myself, but I guess you can just make a union type: type YourThing = App (List Application) | Pro (List Project) That way you can check what your state is... case state of App appList -&gt; Do something with the list of apps Pro projectList -&gt; Do something with the list of projects That means that your model is as simple as: type alias Model = { someName : YourThing ...rest of model } But maybe the state sometime does not hold anything you want your model to be: type alias Model = { someName : Maybe YourThing ...rest of model } Then initial state will be: init = { someName = Nothing ...rest of init } 
The best approach I found so far is to view each Page as an entire Elm application, each with its own model, update and view. In your Main.elm you tie this together by saving some common context data that will be needed by all pages (something like a session) and either all the models of all the pages OR just the model of the current page. type alias Model = { session : Session , pageOne : Pages.One.Model , pageTwo : Pages.Two.Model , currentPage : Route } or type Page = One Pages.One.Model | Two Pages.Two.Model type alias Model = { session : Session , currentPage : Page } Each approach has its own tradeoffs. The [elm-spa-example](https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa) uses the second approach. 
There are lots of great responses here, so here are a few more bits of thought that cover some areas I didn't see already: **"He wants to be able to pluck a framework X developer off the street in the future."** Based on the way things are going, the following is likely to be true over the next few years: * Angular will be popular and well understood and will have a fairly similar ecosystem * React+Redux will be popular and well understood, and most of the major libraries that are popular today will be popular or have similar newer alternatives. However, tons of the little supporting libraries will die and be replaced and lose trendiness and require retooling and relearning. * The Elm Architecture will be fundamentally the same and will thus remain *extremely* similar to react+redux (since redux is essentially a reduced version of itâ€”no pun intended). Elm will be almost identical. if your boss wants to pull someone off the street, they'll be able to pull nearly anyone with solid react+redux experience and A. have them learn all the particular libraries you pair react+redux with and your application architecture B. teach them elm instead In my experience, the amount of time each of these takes is actually incredibly similar. The big difference is that half those JS libs will be swapped out in the next two years, while Elm will still just be Elm. **"he wants us to pick something that won't fizzle out after a few years"** In my mind your choices are: angular, react+redux, elm. Everything else is considerably more risky. I think elm is the riskiest of the three, but also consider this anecdata: &gt; my company has a small internal elm app and a small user-facing elm app that have been in production for over 6 months now. I have had to do 0 upgrades of packages or of elm to keep things working. We even changed the backend data model for some cases and, thanks to the robust decoder system in elm, the elm app _never broke_. Also, if the entire core elm team decides to jump on a rocket and head to mars, you *still* can use everything as you do now and simply migrate it over to a react+redux app that behaves exactly the same. Same architecture, same actions, exceptionally similar view and updater code. The worst case scenario is, honestly, just not that bad. **Lastly** If you don't go with Elm, then you should go with react+redux and bring elm in for a page so everyone can experience it side by side. Then, slowly cannibalize your app with elm as you convert people over. If you can't go all-in, win them over bit by bit! Hope that helps! For context, I'm the lead front-end dev at my company &amp; write our main production app with an _exceedingly_ elm-like JS architecture &amp; toolset. All our internal front-ends &amp; one secondary external one are in elm. I think, had I chosen elm when I started this codebase, it would be in just as great, if not better, shape than it is now.
Why not just use Haskell in that case?
Thanks for the comprehensive answer. It's a good reminder that we can hire by architecture experience rather than language experience.
We're running a Rails +JS app (with Elm soon, hopefully!) with the same issue. The problem of integrating any client side framework into RSpec is common and, IMO, a sign that your test suite lacks specificity. Our solution was to divide up the test suites between Rails and JS entirely. This applies, as well, for Elm (check out `elm-test`). That means that the Rails views are being lightly tested with RSpec (did the server render the correct containers, metadata, and page info?), Rails controllers/routing is heavily tested with RSpec, and JS components are tested independently with Mocha, Chai, Simon, and JSDOM in the rare case that we have to test some sort of DOM manipulation. If you can separate this logic out, then Elm functions are the easiest to test of all, since they're pure! You don't need to have a DOM, a web driver, or automation to test a pure function: you just need to test inputs and outputs. These kinds of tests are the Holy Grail of testing, and are generally fast enough that the difference in speed and grok-a-bility will more than make up for the effort expended towards moving client side tests away from RSpec.
Thanks for putting ramp-up time into numbers, and the link. Had not heard of that website before. &gt; I know Kung Fu LOL.
Nah, I gots my dream job! It's the right job for right now. I'll convince them. The responses to this post have given me confidence.
Using ports to hook up to a mutationObserver to watch the size of an SVG element. When the it changes size its viewport is updated to reflect its exact pixel size - this way my SVG avoids suffering from aliasing effects and looks nice and sharp.
Money 'has legs' because we all believe in its purchasing power. If we stopped believing that, it would just be paper, small pieces of metal, or numbers on a computer. By analogy, Elm has legs if your developers believe in it. Disucss the options then put it to a vote, and find out what they believe in that way.
"For my fellow developers, they seem put off by the HTML generation. They're used to angle brackets and equals signs. So I guess HTML-like templates are more appealing to them." I've been learning Angular 4 recently (there are no Elm jobs where I live :-(). A few months back I converted a site that was using handlbars templates to Elm. Now I am practicing Angular 4 by converting a site from Elm back to HTML templates with {} in them. It feels so weird to be treating HTML as HTML its like some strange and not very powerful DSL that someone came up with for writing HTML. Templates suck badly compared to the power that having a full functional language gives you.
Thanks elr0ndhubbard. I agree with good test segmentation and management. However, are you not running feature tests aka integration tests aka end-to-end tests aka acceptance tests? These, by their nature, must act as a user and therefore a headless client. Since Elm is essentially JS that renders the UI, we _must_ use a js-enabled (pronounced 'slow') test in order for Capybara to have DOM elements to `fill_in` and otherwise interact with. My question is about how to face these feature tests: simply accepting that they will, by their nature, be slow; or by applying some magic tricks to get them to be 'fast'. One thought I had is applying graceful degradation so we have some explicit DOM elements in the markup that Elm overwrites.
I've decided it will come down to them actually trying it. They will not see the benefit of it by eyeballing code alone.
Thanks for sharing your experience.
Good questions! Some answers: &gt; are you not running integration tests First, let me preface this by saying I have a [strong aversion to end-to-end tests as a replacement for unit tests](http://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam) (not my article, but I like the author's point). If you're asking about high-level smoke testing (Can a user log in? Can they do Y? Can they then do Z?) then yes, we have a very light automated test suite that runs periodically. This suite is built on Selenium, is very brittle, and everyone hates it, but is seen as a necessary evil. I definitely wouldn't run these kinds of tests through RSpec, and I wouldn't make these the backbone of your testing framework. &gt; how to face these feature tests Usually, these kinds of "feature" tests aren't really testing an end-to-end feature like the ones I described above. These kinds of "features" are usually just testing _side effects_, most commonly DOM-related side effects. Things like, "when a button is clicked, it emits an event/`Msg`/what have you". In Elm, testing these "side effects" is easy: you can check the contents of your HTML to verify that a certain listener exists with a certain message that will be emitted on click, and you can test how your `update` function responds to different `Msg`. If you really, really, really want to test the events themselves, you can also take a look at [elm-testable](http://package.elm-lang.org/packages/rogeriochaves/elm-testable/latest). &gt; we must use a js-enabled (pronounced 'slow') test in order for Capybara to have DOM elements to fill_in and otherwise interact with This wasn't phrased as a question, but it should have been, because this isn't true in the JS world either. For purely functional JS code, you don't need a DOM at all (just like Elm). For side effects, take a look at [JSDOM](https://github.com/tmpvar/jsdom), a DOM that runs in Node instead of a browser. I hope this helps!
Thanks. I was looking at the SPA Example and trying to wire in my code. Obviously there is a ton more than I need or want given my app only has two models and is a small project. If I go the way of using the second example with type Page = Pages.One ,Pages.Two etc... I assume I need to call the appropriate Http.get for each list inside each page or is that something I do on the update. I was originally using the Navigation.Program from the basic tutorial but if I switch to each Page having its own model, view update then I assume that is where i make the Http call ? Thanks
What amount of elm developers know haskell? and work in haskell is not so friendly as eml, the compiler is too slow
I would recommend [elm-animation](http://package.elm-lang.org/packages/mgold/elm-animation/latest) for its simplicity.
Chrome is going to show insecure warnings on HTTP sites with forms sometime in mid-October. Our webstore doesn't react well to being put completely under HTTPS... So I'm hurriedly writing a replacement for us in Elm + Haskell: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Got Products/Categories mostly done, just refactored the Elm code from a 1k LoC file into multiple modules, now gonna start on the search and then move on to static pages.
"Don't do that. Only use Elm to take over the entire view in a Rails app." I'm pre-empting this anticipated response. :) 
I assume that you've already tried running `/usr/bin/elm-format` from your terminal to make sure it actually works/is executable and everything?
Elm is front-end only, so that's not likely a response!
I'm very new to Elm. in order to learn Elm, I am taking [this site](http://www.contextfreeart.org/gallery/) that is written in 2005-era PHP and reimplementing it with an Elm front-end talking to a Python back-end.
From what I read online, Elixir seems to give a similar experience. Its also very functional and runs on Erlang. It seems like when you try It you fell in love with. Just like you do with ELM when you first get it and try to go back to Javascript. The users of Elixir forums also seems very positive to Elm since it gives them a similar experience on the frontend. Phoenix is a library in Elixir that make it easy to create API's and I think there is packages in elm to communicate to a Phoenix server.
Haskell? It is after all what Elm is written in and inspired by.
Do you recommend any resources for learning Haskell? Are there any web frameworks/libraries do you recommend? Are there simple no-configuration tools like elm-format? How would you get to the point where you can write a server for authentication, serving static files, sending JSON, storing stuff in a database, and handling realtime messages?
I've heard good things about [this Haskell book](http://haskellbook.com/). I've not used it personally but my friend that's right into Haskell uses [Servant](http://haskell-servant.readthedocs.io/en/stable/index.html) for web development in his day job.
We use Elixir/Phoenix and Elm at work. I can tell you that I prefer Elm over Elixir, but /u/atlewee is right, Elixir is also a developer-friendly language. Elm is a more beginner-friendly language (read simple to get started, friendly error message). There's a little bit of a shift your brain has to do when switching between Elixir and Elm code. Elm is much more strict and has friendly error messages. Elixir is a dynamic language and therefore isn't all that picky about what you do. There are tools such as [Dialyxir](https://github.com/jeremyjh/dialyxir) to help with type-checking. Since you mentioned Flow in your original post, its similar to that, but for the bytecode that Elixir is compiled into. All in all, I have happy thoughts about the tech stack we use. I recommend you give Elixir and Phoenix a try. They pair well with Elm.
I use Firebase which might also interest you. Then you don't need a backend at all. Authentication is built in, it serves static files and you publish new code with a CLI and can revert back to earlier snapshots very easily. It is also a fully realtime database. It can also store files in pentaByte size if you like. Now there is also Firebase functions which let you run backend code without creating your own backend. You will come a long way with the free plan. I use it with ports now and it works just fine. But I'm currently developing a pure Elm firebase client that will make it very easy to use Firebase directly in Elm to make it even simpler.
Check F# and OCaml.
F# and OCaml do not enforce purity and safety as much as Elm do. It makes them very different from it. Elm is much closer to Haskell but still i find Elm safer (and arguably simpler). My guess is there is no server side equivalent to Elm, unfortunately.
I've been writing Elm on the server for over a year full time. Checkout https://github.com/panosoft/elm-node-main and https://github.com/elm-node/core. In https://github.com/panosoft there are lots of server oriented Effects managers and native libraries. You have to learn to write your own interfaces to node libs. Look to elm-node/core for good examples. And there is no webserver framework for Elm that I know of. We aren't writing one since we aren't developing a tradition webserver. But there is no reason that one couldn't be developed. If, however, you want a fully formed ecosystem then you will be disappointed. But I've always found that by the time a fully formed mature ecosystem exists, I've already moved on to better tech. I suspect that I'll remain an Elm developer for quite a long time though since it's an amazing language to work in. 
I've been using Facebook's ReasonML for like two weeks now. I like it a lot. It has a familiar Elm-like syntax (though they're changing it to make it a little more like JS, syntactically, but still familiar). You can run it in basically any environment (though some are more put together than others). it has a friendly community. The compiler has pretty good error messages, though not as good as Elm's, but they're working on getting it there. It has a really solid type system, and the type inference is really powerful. It has a format utility like elm-format. The one big difference between ReasonML and Elm is that you can do mutation and side-effects, though immutability and purity is the default. But yeah, I haven't done it yet, but you can write it to compile out to Node, or to compile out to native using OCaml's web apis.
In fact, at the moment I can't even get feature specs that rely on Elm-owned DOM elements to pass. The capybara selectors aren't finding the elements. I'm in the midst of debugging to find out what's up, but if anyone has some obvious tips I am all ears.
+1 for servant, aeson for Json, hlint + hindent for linting / formatting 
The purity enforcement probably makes that not very practical. Server side Elm would be good in relation to what other server side language you use with ports I think. Would be cool to compile Elm to C and have ports for Python, Ruby, PHP, etc
Elixir is dynamically typed, correct? From what little I've looked I saw that and looked no further. Elm has raised the bar for what a good type system and a good compiler should do and I speculate Elixir doesn't give us that developer experience, let alone basic type guarantees. Thoughts?
One benefit of Node is that you can reuse your Javascript logic (like, say, a Markdown/BBCode renderer) in your Elm app by talking to it via ports.
The core language design is the same but the experience op was mostly talking about is VERY different. If you want simple to manage and easy to install look somewhere else than haskell.
Last time I checked you can't do asp.net properly in f#, which is a cornerstone of the windows backend eco system, am I wrong?
Internering
&gt; elsewhere Where?
This, besides Haskell, is probably the best answer
Currently the best resources are: * The talk itself ++ [the slides](https://docs.google.com/presentation/d/1s7VPbvuv6m9-S7ePm0R5loqRnHsZEHHVbZALJpWAARo/edit?usp=sharing) * The two examples in the examples folder * Coming to the #style-elements channel on the elm slack and asking any questions you might have. That being said, there is some more illustrative documentation in the works as well :)
Love the brevity of this. Information dense, is how i like it. (Too often tutorials're sparse af)
Thanks! You can check more tutorials on Elm, if you have time.
Have a look at Crystal, it's crazy fast compiles using LLVM and has type inference. It's new but looks amazing https://www.dailydrip.com/topics/daily/drips/web-server
Elm is definitely a special language. Evan's done a terrific job. Elixir doesn't give any of the type guarantees that Elm does, but it has its own qualities that are also nice such as fault tolerance. Since our server side is essentially just providing a thin REST/websocket layer over the DB, compiler enforced type safety isn't important here. The sections of code that touch the data structures are small and easy to fit into my head. I'm definitely not the person to strongly argue for or against a static vs. dynamic language; they both have their pros and cons. I'm very happy to have Elm's type safety and Elixir's expressiveness. They're both good quality.
&gt; but it has its own qualities that are also nice such as fault tolerance This is something that, as primarily a Javascript web developer, it's hard for me to reconcile. In Javascript, the vast majority of "faults" are type errors. Hands down. This is due to Javascript having no enforceable types. It's dynamic. Elixir is dynamically typed. Am I wrong in framing Elixir as being good at recovering from the choice of being dynamically typed? The creator(s) of Elixir chose to make it dynamically typed, but they also made it good at making up for the fact that unchecked types cause a lot of problems (it's fault tolerant). Is that fair to say, or am I missing the bigger picture?
Elixir goes deeper than just ignoring its own dynamically typed warts. You can create supervision trees to automatically resume sections of your code when they crash. Elixir code runs on Erlang's virtual machine (aka the BEAM) which was designed to control the phone systems. Because it wasn't practical to ask everyone to stop using the phone to update the firmware, the original creators made it possible to do hot code reloading. You can essentially upgrade a version of your software live without taking the system down or using a load balancer to only take down certain servers. Pretty cool stuff considering they did that back in the late 80's. I don't want to come off as a Elixir zealot. Evan's made it clear that and officially support server side Elm isn't happened any time soon, so we looked at other options and are happy with Elixir. If someone is interested in using Haskell, they definitely won't want to look into Elixir. Neither is perfect. Both are great at what they do. For us, our server side doesn't need strong typing. Most of our Elixir modules are less than 200 lines of code and we haven't run into any issues with the missing type safety.
Try F# with .NET Core 2 using Visua Studio Code and Ionide. It's not exactly as simple, but it's really much simpler than Haskell. Also, compares to OCaml it has much more content online from my experience, I have found tutorials for many things. Also try Giraffe for web services, it's ASP with a functional twist, but it's intention is to keep access to everything from ASP so for web stuff it can mean a lot.
Fortunately you are! Thanks to the recent release of .NET Core 2 and using Giraffe https://github.com/dustinmoris/Giraffe you can get use ASP with a functional style and the performance impact should be minimal.
They all have strong and weak points. I'd not say that Haskell's tooling is "really much simpler", it's different. The `stack` tool in Haskell is awesome (next level dependency mgmt), and IDE integration is getting better with `intero`. I had to check out Giraffe, and it looks nice. A welcome addition in the F# ecosystem i suppose. But in the other corner there are Yesod and Haskell-servant: Giraffe is just not there yet. Also micro frameworks in Haskell such as Spock, are nice IMHO then Giraffe. As said, i think "different" is the word. In its current shape I think Haskell+ecosystem *is* "simple to manage and easy to install".
Crystal doesn't look like a *functional* language to me.
Fault tolerance and getting rid of type errors are orthogonal concerns. I'm a bit of an Elixir fanboy, but I've been using Erlang for a long time as well. One of the reasons Erlang (and thus Elixir, in the end) never added strong typing (and there have been historical attempts) was that adding a really good strong typing system is an unsolved problem for Erlang's concurrency model. There's still active research in this area, 30 years later. But to get back to the original point, re: fault tolerance, you can think of it like this: with Elm, you have to handle every possible state your program can be in. You're forced to handle that, and there's some stuff out there to make it less painful. With Erlang/Elixir, you code the happy path and you make assertions based on that. Language properties like pattern matching (there is no assignment) make it very easy to code a simple and assertive way, verifying that you're on the happy path the entire way. Unexpected behavior results in a limited "crash" and you define how that little entity of state needs to be restarted. The benefit of this is that you do not have to handle the *entire* state tree, so you can collapse entire classes of error into a single case that results in the same behavior, a return to some notion of the last good state. And just a reminder, (from what I understand about type systems research) it is *still* not a 100% known/solved problem of how to offer Elm-like type guarantees around Erlang's concurrency model.
I haven't used Elixir, but it seems to to be offering some optional type-system ["typespec"](https://elixir-lang.org/getting-started/typespecs-and-behaviours.html), which looks like ["flow"](https://flow.org/) for Javascript or ["typing"](https://docs.python.org/3/library/typing.html) for Python (in stdlib since 3.5). These tools let you add type definitions to your code. If you use them in a good IDE it will highlight type errors right away, before compilation. I'm using *typing* for Python a lot and I find the working experience it offers quite similar to what I'm used to from statically typed languages.
No I don't think it is but I do like the look of the type inference. Hard choice Haskel is hard to pickup, Elixir is dynamically typed (though there are optional typings...). Idris seems interesting but it's super new. Maybe clojure? It's got a new type system that looks interesting 
Hi chabv, do you still need help on this question?
Hello, this topic actually comes back once in a while. I for one agree with you that encapsulated components that can easily be reused without knowing all the boilerplate needed for it are handy and can boost a project productivity (providing some good components were laid out before the bulk of the devs joined the project) Some people tried to sell a similar approach in the past but were discouraged by the feedback and either left the community or just reverted to using the 100% approved TEA. Most of the community like the status quo and will say that this boilerplate is a comparatively small price to pay to have this and that feature (time travelling debugger, which doesn't seem to be used that much anyway :p, etc), and generally a fractal composition of components.
&gt; Only use Elm to take over the entire **view** in a Rails app. So use Rails just to serve JSON and let Elm do the rendering client-side (or is there a way now to have SSR in Elm with Rails?)
This is a common theme, see [this article in the guide](https://guide.elm-lang.org/reuse/). TL/DR; For now use functions and if you need to extract something it is common to have a (model, update, view) triplet with a sub Msg type that a parent needs to incorporate. 
&gt; Ideally, what I'd like to do is something like creating my view functions with Component objects instead of Html object. Component objects would contain whatever update, subscriptions and init functions are required. My [keynote at Elm Europe](https://www.youtube.com/watch?v=DoA4Txr4GUs) aims to be a comprehensive explanation of why it's better to do the exact opposite of this. :)
Just want to quickly emphasize that the section of the Guide you linked to is saying in very clear terms that the OP should not expect a good outcome from this approach. :) To quote that page (including its emphasis): &gt; If you are coming from JavaScript, you are probably wondering â€œwhere are my reusable components?â€ and â€œhow do I do parent-child communication between them?â€ A great deal of time and effort is spent on these questions in JavaScript, but it just works different in Elm. **We do not think in terms of reusable components.** Instead, we focus on reusable functions. It is a functional language after all!
&gt; Some people tried to sell a similar approach in the past but were discouraged by the feedback and either left the community or just reverted to using the 100% approved TEA. Importantly, quite a lot of people tried it, found that they were unhappy with it, tried the alternative approach that others recommended, and found that it was unfamiliar at first but ultimately led to a happy scaling experience. This is not uncharted territory. It's been charted with a big "wrong way, go back" warning because we've seen so many people go down the "try to recreate OOP in a functional language" road and report back that they found pain and suffering at the end of that road.
And it's a great keynote! To me, it's definitely the most complete and understandable explanation of why you should not go the component route in Elm. Kudos for hitting it home Richard \^_^
You're thinking in terms of components. This is natural if you're coming from react or some other frondend library from an object oriented language. However, elm does not have components, because components are objects. In elm, the base unit of composition is a function, not objects, nor components. Architecture learned from other toolboxes does not work well in elm. In fact, trying to use those paradigms in elm is actually harmful and will destroy your productivity. Don't go down that road, elm wasn't designed that way. Instead, **let your code grow naturally**. Don't draw borders upfront, don't follow an arbitrary pattern. Start with one file. Once it gets too large, move out parts that belong together into separate modules. Don't try to group some particular update logic to some view function, instead look at them independently. Try to find dependencies in your model and extract those into a datastructure. Once your `Msg` type becomes too big, group related messages into sub messages. I know it's hard to believe that this actually works, as your whole previous experience tells you it wont. Trust the ones that have already made these experiences and know that it works. This talk by Richard Feldman is also very relevant: https://youtu.be/DoA4Txr4GUs
Do you have any examples of people who have tried and failed? Like I said I tried looking for something but did not manage. I'd like to find out what they did and understand why it failed. After all they might have gotten at it all wrong.
**Disclaimer:** I am the author of this framework. If you are interested in deploying an HTTP API to AWS Lambda, [ktonon/elm-serverless](http://package.elm-lang.org/packages/ktonon/elm-serverless/latest) is an Elm framework for doing just that. Currently has [CORS](http://package.elm-lang.org/packages/ktonon/elm-serverless-cors/latest) and [JWT auth](http://package.elm-lang.org/packages/ktonon/elm-serverless-auth-jwt/1.0.0/Serverless-JWT) middleware. The [demos](https://github.com/ktonon/elm-serverless/tree/master/demo) are the best way to get a feel for the framework. I'm not using it in production yet. Also, not aware of anybody else using it in production.
Hey thanks for your feedback, good video. I had already figured most of the things out but did pick up one or two interesting patterns. Would it be a correct summary to say using components is a bad idea because it forces a certain type signature on the functions? I have to admit I do tend to pass additional arguments to my view functions.
I'm very curious about what features would have to be sacrificed and why. I'm a bit naive perhaps and rather unknowing about the inner workings of elm so apologies if it's obvious.
Maybe and erlang approach where each component has an state and be a separate module, and the components communicate through messages, ok no
I agree with you on small components, but I recall a talk where it was explicitly stated - by you if I recall correctly - that there are *some* valid cases when using the triplet is actually not a bad thing :-). I see where the react crowd is coming from, they're used to making their components as small as possible and they try to apply their intuition in the Elm world as well, so they want to separate out "components" as Elm packages where you don't have a choice but to use the triplet. I'm not a fan of the triplet thing either, I just wanted to give the OP a short summary, it might have been too favorable to the triplet though ^.^
Because state is immutable in a functional language, attempting to encapsulate state does two things. a) try to destroy all the benefits of having immutable state to begin by bringing it back. b) wreak havoc on the type signatures because of the weaving you have to do. The units of composition in FP are datastructures on one side and regular functions on the other. The units of composition in FP are NOT objects, for the very reason that the purpose of objects is to encapsulate a state which FP just does not even have. Try to reason about your code as a series of data transformations and not a progression of state. 
I just today wrote a "component" in Elm. Yes I agree that it's a bit awkward to put it in three (or more) places and there is some potential for mistakes but it's not a lot of boilerplate I think. Certainly not a big problem compared to other parts of Elm like json encoding/decoding! Having three places that must be in sync and can only really go wrong if you have multiple components of the same type next to each other in the view hierarchy isn't terrible. I'll gladly accept it as a downside as compared to doing any JavaScript whatsoever :P I couldn't find a good guide on how to do this type of thing in Elm when writing that code though, which made it rather painful to figure out. I might attempt a blog post with examples tomorrow... 
&gt; there are some valid cases when using the triplet is actually not a bad thing Oh, sure! Just want to be clear that: 1. Thinking of a "model-view-update triplet" as a "component" leads to all the wrong intuitions and I discourage it as strongly as possible. 2. I think it's much more productive to think "Elm does not have components" because it leads to the obvious question of "so then how should I organize my code so that it scales well?" which I think is the right question to be asking. ðŸ˜„
&gt; I couldn't find a good guide on how to do this type of thing in Elm when writing that code though, which made it rather painful to figure out. That's because it is explicitly discouraged as an antipattern in the biggest, boldest terms possible. Many people have tried this and been unhappy with how it scaled. It is the number one beginner mistake people make when transitioning from trivial to nontrivial Elm applications. &gt; I might attempt a blog post with examples tomorrow... That sounds like it would be confusing and harmful to beginners. I would urge you to reconsider.
It's come up many times on Elm Slack - I don't have links offhand, but here are the archives: https://elmlang.slackarchive.io/
&gt; Would it be a correct summary to say using components is a bad idea because it forces a certain type signature on the functions? I don't think that's quite it. Maybe this is a better summary? https://twitter.com/czaplic/status/903266544544878592
Maybe I was unclear. I put component in scare quotes quite explicitly for a reason that I thought I made clear: because it's just packaging a type, a union type and three functions into a module. That, I believe, is not the anti-pattern but the pattern. Maybe I've misunderstood though? What is the suggested way to reuse code? Like if I'm writing a list control that I want to be able to use. Something like https://github.com/inkuzmin/elm-multiselect/blob/master/README.md The guide OP linked to does exactly what I intended to write a blog post to do but I think it does it in a bit unclear way. I know I read that and didn't get it and had to figure it out myself looking at the code linked above. Now that I understand I can read the docs and see what it's trying to explain...
I like that very much, making impossible states impossible once again *g*. Reminds me of 1984 where the idea of newspeak is that people can't do things they have no language concept of.
I don't know why are you downvoted. Objects are about message passing and I have a memory of Joe saying that maybe Erlang is a pure form of OO. 
1984 as a roadmap. What could go wrong? :)
Yes I know that, I use elixir at job but probably is complex to implement in front end because of schedulers but would be interesting to have subapplications (process akka components) that communicated between them
https://groups.google.com/forum/#!searchin/elm-discuss/components%7Csort:relevance
&gt; Is there another obvious solution I missed? Not really. If all the state of the component is essential state (e.g. the toggle state of a checkbox) you can use a function and messages that would alter that state in the way that it needs to be altered (e.g. toggle it). If you have accidental state (state that is local to the component but is not essential to the larger context that is using the component) you have two choices. 1. If the component requires effects you use the triad as explained in the page you linked. 2. If the component does not require effects (http, random, time, etc) you can use the pattern you find in `elm-sortable-table` which is basically the same as the triad but the state is updated in the view and the call to update is replaced with a simple replacement of the component state. As far as I understand it, the simplified pattern would look [like this](https://ellie-app.com/4bhSXJFzbjNa1/0) or [like this](https://ellie-app.com/4bhSXJFzbjNa1/1) (the second version has some name tweaks and a flip in the model and msg in the definition of the internalUpdate in order to avoid needing to flip it in the view). &gt; Is there some theoretical limitation making implementation of these components hard or even impossible? Invisible state that mutates can create hard to understand bugs. Just look at the [issues people have with the input element](https://github.com/elm-lang/html/issues/105). I have created an experimental custom elements implementation where elements can be Elm programs. It works quite OK but it is dangerous territory. It has been theorized that this approach could be used to break the purity guarantees of Elm and introduce something like a mutation provider. 
The reality is far more dull: it's just a plain old *confusing* word in the context of Elm.
&gt; it's just packaging a type, a union type and three functions into a module. That, I believe, is not the anti-pattern but the pattern. Yeah, this happens all the time. So it's not *the pattern* but rather *the last resort.* I'd recommend trying all the simpler techniques first, and then building up to this only after each of the simpler has gotten unwieldy. In practice, I rarely need or want it. For example, in [`elm-spa-example`](https://github.com/rtfeldman/elm-spa-example) I ended up using it for a total of two use cases: SPA page routing (the most common use, by multiple orders of magnitude) and a reusable Article Feed that was too complicated to reuse in a simpler way. None of the other reusable [views](https://github.com/rtfeldman/elm-spa-example/tree/master/src/Views) ended up using this technique. Reaching for this approach eagerly (as opposed to as a last resort) might seem fine early on, but can lead to lots of headaches at scale. In the old days (like 1-2 years ago) people would come to [Elm Slack](http://elmlang.herokuapp.com/) saying they'd taken this approach and had all these problems that needed solving, and the solutions typically ended up being major rewrites. Since then I've tried to steer people away from this trap early on, before it becomes a big problem for their code bases. &gt; What is the suggested way to reuse code? I don't have a quick answer, unfortunately, but about half the purpose of this talk is to answer that question: https://www.youtube.com/watch?v=DoA4Txr4GUs
I'll watch that today. Thanks. 
I figured it out, but can I contact you if I have more questions ðŸ˜‡? Thanks 
Why so many super tiny files that just makes things complicated?
I tend to prefer this style as well. For me I think it's because I find the code that gets written (both by me and others) when things are carved up into isolated pieces tends to be cleaner than the code that gets written when many things are co-located in fewer files. Also I don't see it as changing complexity at all because I rarely navigate by directory hierarchy or by typing file names or anything that would be O(n) in the number of files. I mostly navigate by jumping to definitions or using project-wide fuzzy search, etc. Finding something in the same file I'm already editing or in another file in the project are both accomplished with the same ease in the same amount of time (regardless of the number of files).
I also navigate by symbol/grep mostly but that to me argues against super tiny files because more files is then no up shot, just creating more files. I can't see why super tiny files would create cleaner code. Especially in Elm where people can't abuse global variables etc. Do you have a theory or an anecdote to shed some light on your preference? It's also the opposite of what Evan says :P
56 minutes in it seems like you're talking about the anti-pattern you're warning me about here... namely of doing some kind of components with super wide types just to get the same type signature... did I get that correctly? It seems to me that you're assuming that I am saying X when I am not. You are saying &gt; I ended up using it for a total of two use cases but the word "it" here references something that you haven't actually defined, and I haven't defined either. So you're urging me in strong words to not do something that neither you or I have defined. You're assuming. Maybe based on the hostility we've already developed between us in other discussions. I hope we can step back from the precipice here and calm down. I know I've been too harsh and I think you have too :P I thought the talk was good and I agreed with 100% of it. And I see nothing about it that conflicts with what I was already thinking. I did like the part about extensible records and I'll keep that stuff in mind but I don't think it applies to what I'm doing now.
Let's take this a bit more concrete to see if we're actually on the same page or not. This is the test program that uses a list control I've made: import Html exposing (Html, button, div, text) import Html.Events exposing (onClick) import ListControl main = Html.beginnerProgram { model = init , view = view , update = update } -- MODEL type alias Model = { listAModel : ListControl.Model } init : Model init = { listAModel = ListControl.init } -- UPDATE type Msg = ListA ListControl.Msg update : Msg -&gt; Model -&gt; Model update msg model = case msg of ListA msg -&gt; { model | listAModel = ListControl.update msg model.listAModel } -- VIEW view : Model -&gt; Html Msg view model = div [] [ ListControl.view ListA model.listAModel ] The last line where I embed the ListControl.view is the only thing that I think looks different from what I've read in other places. ListControl.view is: view : (Msg -&gt; msg) -&gt; Model -&gt; Html msg view externalMessage model = Html.map externalMessage &lt;| internalView model I want to avoid having all that fiddly stuff where you're using the module so that's why I did that. Is this a bad pattern do you think?
One advantage is easier to resolve conflicts when working on a larger project with many team members.
Never used components before and haven't done a lot of OO (mostly did low-level graphics programming). I've started thinking about components only *after* my code grew naturally and I noticed ugly patterns with lots of boilerplate. It might in fact be wrong to call what I want components, maybe it should be agents. On the other hand the 'triplet' might work just fine with something like (but different from) haskell's deriving keyword.
Oh, I automatically assumed you'd be coming from an OO background, as many that have similar questions do. Sorry for assuming your background. In that case, since you already have some (presumably large) code to look at, why don't you ask on slack (or here in a new post) for advice specifically for the areas that you perceive as boilerplate? I think it's much more productive to talk about concrete code instead of trying to find a general pattern, as such a patterns doesn't really exist. 
I had the same problem with a problem similar to pathfinding. I did the simple-and-stupid approach of adding a "fuse" countdown to limit the number of recursive calls. You can then `Debug.crash` with some debug info, or recover properly. You can probably do better with unit tests. And I also suspect that there is a better solution, something about cyclic graphs.
I found a GitHub / demo which aims to _automatically generate_ JSON encoders / decoders for Elm - based on a given ("prototype") individual JSON object: https://github.com/eeue56/json-to-elm http://eeue56.github.io/json-to-elm/ --- Below are two examples of running the online demo. I haven't tested this yet - but it looks pretty good! Maybe you might have to do some tweaking in order to correctly handle "nested" objects. --- **Example 1** This example uses an object with _no_ nesting. It was obtained from from https://jsonplaceholder.typicode.com/ (and subsequently modified slightly, to remove all the nesting). **Input:** toplevel alias: `Customer` { "id": 1, "first_name": "Margaret", "last_name": "Nash", "address": "1854 Luame Street", "city": "Dupziohe", "zipcode": "85265", "email": "cubbicur@ceowaba.net", "birthday": "1993-09-19T01:32:03.399-03:00", "avatar": "https://robohash.org/d100921f46b281f1e4533505abae818b.png", "has_newsletter": false, "has_ordered": true, "first_seen": "2015-10-22T09:24:56.422-03:00", "last_seen": "2016-01-11T00:29:54.702-03:00", "latest_purchase": "2015-12-07T19:25:05.307-03:00", "nb_commands": 3, "total_spent": 1296.84 } **Output:** import Json.Encode import Json.Decode exposing (field) type alias Customer = { id : Int , firstName : String , lastName : String , address : String , city : String , zipcode : String , email : String , birthday : String , avatar : String , hasNewsletter : Bool , hasOrdered : Bool , firstSeen : String , lastSeen : String , latestPurchase : String , nbCommands : Int , totalSpent : Float } decodeCustomer : Json.Decode.Decoder Customer decodeCustomer = Json.Decode.Pipeline.decode Customer |&gt; Json.Decode.Pipeline.required "id" (Json.Decode.int) |&gt; Json.Decode.Pipeline.required "firstName" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "lastName" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "address" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "city" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "zipcode" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "email" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "birthday" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "avatar" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "hasNewsletter" (Json.Decode.bool) |&gt; Json.Decode.Pipeline.required "hasOrdered" (Json.Decode.bool) |&gt; Json.Decode.Pipeline.required "firstSeen" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "lastSeen" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "latestPurchase" (Json.Decode.string) |&gt; Json.Decode.Pipeline.required "nbCommands" (Json.Decode.int) |&gt; Json.Decode.Pipeline.required "totalSpent" (Json.Decode.float) encodeCustomer : Customer -&gt; Json.Encode.Value encodeCustomer record = Json.Encode.object [ ("id", Json.Encode.int &lt;| record.id) , ("firstName", Json.Encode.string &lt;| record.firstName) , ("lastName", Json.Encode.string &lt;| record.lastName) , ("address", Json.Encode.string &lt;| record.address) , ("city", Json.Encode.string &lt;| record.city) , ("zipcode", Json.Encode.string &lt;| record.zipcode) , ("email", Json.Encode.string &lt;| record.email) , ("birthday", Json.Encode.string &lt;| record.birthday) , ("avatar", Json.Encode.string &lt;| record.avatar) , ("hasNewsletter", Json.Encode.bool &lt;| record.hasNewsletter) , ("hasOrdered", Json.Encode.bool &lt;| record.hasOrdered) , ("firstSeen", Json.Encode.string &lt;| record.firstSeen) , ("lastSeen", Json.Encode.string &lt;| record.lastSeen) , ("latestPurchase", Json.Encode.string &lt;| record.latestPurchase) , ("nbCommands", Json.Encode.int &lt;| record.nbCommands) , ("totalSpent", Json.Encode.float &lt;| record.totalSpent) ] --- **Example 2** This example uses an object _with_ nesting - from the example in the OP. **Input:** toplevel alias: `Obj` { "Site1": { "PC1": { "ip": "x.x.x.x", "version": "3" }, "PC2": { "ip": "x.x.x.x", "version": "3" } }, "Site2": { "PC1": { "ip": "x.x.x.x", "version": "3" }, "PC2": { "ip": "x.x.x.x", "version": "3" } } } **Output:** import Json.Encode import Json.Decode exposing (field) type alias Obj = { site1 : ObjSite1 , site2 : ObjSite2 } type alias ObjSite1PC1 = { ip : String , version : String } type alias ObjSite1PC2 = { ip : String , version : String } type alias ObjSite1 = { pC1 : ObjSite1PC1 , pC2 : ObjSite1PC2 } type alias ObjSite2PC1 = { ip : String , version : String } type alias ObjSite2PC2 = { ip : String , version : String } type alias ObjSite2 = { pC1 : ObjSite2PC1 , pC2 : ObjSite2PC2 } decodeObj : Json.Decode.Decoder Obj decodeObj = Json.Decode.map2 Obj (field "site1" decodeObjSite1) (field "site2" decodeObjSite2) decodeObjSite1PC1 : Json.Decode.Decoder ObjSite1PC1 decodeObjSite1PC1 = Json.Decode.map2 ObjSite1PC1 (field "ip" Json.Decode.string) (field "version" Json.Decode.string) decodeObjSite1PC2 : Json.Decode.Decoder ObjSite1PC2 decodeObjSite1PC2 = Json.Decode.map2 ObjSite1PC2 (field "ip" Json.Decode.string) (field "version" Json.Decode.string) decodeObjSite1 : Json.Decode.Decoder ObjSite1 decodeObjSite1 = Json.Decode.map2 ObjSite1 (field "pC1" decodeObjSite1PC1) (field "pC2" decodeObjSite1PC2) decodeObjSite2PC1 : Json.Decode.Decoder ObjSite2PC1 decodeObjSite2PC1 = Json.Decode.map2 ObjSite2PC1 (field "ip" Json.Decode.string) (field "version" Json.Decode.string) decodeObjSite2PC2 : Json.Decode.Decoder ObjSite2PC2 decodeObjSite2PC2 = Json.Decode.map2 ObjSite2PC2 (field "ip" Json.Decode.string) (field "version" Json.Decode.string) decodeObjSite2 : Json.Decode.Decoder ObjSite2 decodeObjSite2 = Json.Decode.map2 ObjSite2 (field "pC1" decodeObjSite2PC1) (field "pC2" decodeObjSite2PC2) encodeObj : Obj -&gt; Json.Encode.Value encodeObj record = Json.Encode.object [ ("site1", encodeObjSite1 &lt;| record.site1) , ("site2", encodeObjSite2 &lt;| record.site2) ] encodeObjSite1PC1 : ObjSite1PC1 -&gt; Json.Encode.Value encodeObjSite1PC1 record = Json.Encode.object [ ("ip", Json.Encode.string &lt;| record.ip) , ("version", Json.Encode.string &lt;| record.version) ] encodeObjSite1PC2 : ObjSite1PC2 -&gt; Json.Encode.Value encodeObjSite1PC2 record = Json.Encode.object [ ("ip", Json.Encode.string &lt;| record.ip) , ("version", Json.Encode.string &lt;| record.version) ] encodeObjSite1 : ObjSite1 -&gt; Json.Encode.Value encodeObjSite1 record = Json.Encode.object [ ("pC1", encodeObjSite1PC1 &lt;| record.pC1) , ("pC2", encodeObjSite1PC2 &lt;| record.pC2) ] encodeObjSite2PC1 : ObjSite2PC1 -&gt; Json.Encode.Value encodeObjSite2PC1 record = Json.Encode.object [ ("ip", Json.Encode.string &lt;| record.ip) , ("version", Json.Encode.string &lt;| record.version) ] encodeObjSite2PC2 : ObjSite2PC2 -&gt; Json.Encode.Value encodeObjSite2PC2 record = Json.Encode.object [ ("ip", Json.Encode.string &lt;| record.ip) , ("version", Json.Encode.string &lt;| record.version) ] encodeObjSite2 : ObjSite2 -&gt; Json.Encode.Value encodeObjSite2 record = Json.Encode.object [ ("pC1", encodeObjSite2PC1 &lt;| record.pC1) , ("pC2", encodeObjSite2PC2 &lt;| record.pC2) ] --- 
Try as much as possible to use map/fold to traverse data structures rather than recursion. They are optimized to not pop like that. If you must recurse, ensure your function can be tail call optimized ([TCO](https://en.wikipedia.org/wiki/Tail_call)) and the compiler will optimize it into a simple loop rather than full stack recursion. EDIT: it would help if you commented your code or otherwise provide a description of the attempted algorithm.
**Tail call** In computer science, a tail call is a subroutine call performed as the final action of a procedure. If a tail call might lead to the same subroutine being called again later in the call chain, the subroutine is said to be tail-recursive, which is a special case of recursion. Tail recursion (or tail-end recursion) is particularly useful, and often easy to handle in implementations. Tail calls can be implemented without adding a new stack frame to the call stack. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elm/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
If you know what you are doing, you can split your app right from the start following the folder structure you can find in `elm-spa-example`. Spend some time as a team designing the business objects you know you will need and once you have that reasonably well fleshed out, created the app infrastructure (especially the) `Data` folder. You can then split responsibilities in such a way as to not step on each other's toes. It would also be useful to have a process that lays out the work that each person does (maybe using the issue tracker) so that you know what everyone's working on. 
Just post them either in the "Easy Questions" thread for the week, or as a new thread. I check it most days and if not me someone should reply. 
Modern merge tools easily handle two people working in the same file as long as they arent working on the same place in the file.
I just want to say: really impressive work!
Signals were great in Elm's early history, but they were especially great because they guided the community toward The Elm Architecture (TEA). They were then dropped because they added more complexity than was necessary to power TEA. I suggest embracing TEA and seeing how far you can go with it. I haven't yet encountered a problem that is better modelled by any kind of FRP than by TEA. I also highly suggest listening to this interview with Evan on the history of Signals and why they were taken out of Elm: https://elmtown.github.io/2017/04/03/2017-4-03-History-Signals-Episode-11.html
Understandable concern, but I wouldn't expect it to be a problem. Hope you have fun with the project! ðŸ˜„
I messed around w style elements and have to say, it was maybe the best front end templating experience ive had. Really solid work. Would love to see a "bootstrap" style ui library because as a mostly backend programmer, im very very lazy.
&gt; the word "it" here references something that you haven't actually defined, and I haven't defined either. So you're urging me in strong words to not do something that neither you or I have defined. You're assuming. Maybe based on the hostility we've already developed between us in other discussions. I hope we can step back from the precipice here and calm down. I know I've been too harsh and I think you have too :P That's totally fair. You're absolutely right, and I apologize for uncalled-for harshness. :) To clarify, what I meant by "it" was "breaking out a separate Model, view, and update triplet" as the primary means of reuse. I've heard colloquially refer to this idea as "Elm components" which was what I assumed you were referring to above. Sorry I jumped to conclusions about that, and separately sorry for my tone.
I'd say it all depends on what the full implementation of `ListControl` looks like, honestly. Would you mind showing the code for that?
&gt; 56 minutes in it seems like you're talking about the anti-pattern you're warning me about here... namely of doing some kind of components with super wide types just to get the same type signature... did I get that correctly? That's the general gist of it - although I think it's more often "to use the same pattern for reuse everywhere" than to get the same type signature, if that makes sense. The broader point is that there's no one-size-fits-all pattern for reuse; in my experience the best way to do reuse for a good scaling experience is to find the minimal API that will get the job done on a case-by-case basis.
I do agree that it's not a good hammer to go to first thing, but don't you think it makes sense for reusable, general purpose GUI elements like lists, buttons, etc? The alternative seems to be to use local state (like the HTML GUI elements) and event handlers which seems icky to me. 
Thanks for pointing me in the right direction. I gave the episode a listen, I suppose it makes sense that FRP in a purely functional language can be at odds and TEA pattern was developed out of the common use-cases that people were using Signals to setup. I will research TEA more but in so far it sounds a lot like the Redux architecture pattern with React which inspires some skepticism, for instance in this gist here: https://gist.github.com/anonymous/314d269505652f73c5aadbb1329e519d I am creating a Drag &amp; Drop stream for drawing a box on a canvas. With RxJS it is trivial to keep increasing the box's height while the user scrolls down the canvas by moving their mouse to the bottom without having to keep a lot extra state flags. Imagining modeling that in Redux I see a lot of extra Boolean flags and if branches and generally less quality code for what is a lot of subtle interaction niceties such as ignoring sloppy clicks. Could something like that interaction be well handled by The Elm Architecture without just adding more app state?
It's an implementation of a list like you'd find in windows with full shift, ctrl selection behavior. I'm not really done and I need to run it past people before showing the source/open sourcing. Plus right now I'm at home and the code is at work :)
Well then I think we just actually agree :P I'm building towards writing a multiselect control that fetches data with Ajax and can be used for gigantic lists (10s or 100s of thousands of entries). And we need many of these on the same page for filtering purposes. The list control I'm building is a small part of that, but it should be useful for other things which Is why I'm trying to make its API reasonable. 
I'd say it all depends on the list, and it all depends on the button. :) The only rule of thumb I have is to find the simplest API that works on a case-by-case basis.
Okay, fair enough. My main point is that I'd use this pattern if the list has a bunch of messages (let's arbitrarily say 4 or more, but that's not a hard-and-fast rule or anything), and the state is a record with (again, arbitrarily) 4 or more fields in it. If it's just storing some items, and which one is selected, I'd go for a much simpler API. :)
Fair enough. I'm interpreting "simplest" as implying "most restrictive types too. 
Ah. Yea I can describe the state at least: - the items (probably an abstract type and a method to render it down the line) - focus point - shift anchor - selected items There are way too many messages right now because it's a mess with both mouse and keyboard input but there will be quite a few no matter how I cut it. Or each message will be quite complex (containing shift, ctrl/meta data). 
Sure, but mutability is not an option in Elm. You need to change your view: view model = div [ prop model.prop ] [ ... ]
From reading the virtualdom code it looks to me like Html nodes are implemented on the js side outside Elm so aren't normal Elm datastructures. 
"Same place" often is a bit too broad in my experience though. 
Thanks for the answer. I will definitely have a look at the spa-example and make sure that we thoroughly plan out the project. An issue tracker is a given anyway :)
I know, but we are all pretty inexperienced with elm, so it's hard to tell how much we are going to refactor while working on the project. That way it is hard to guarantee that we don't step on each others toes.
Great, thanks for the answer. I am still only half-way through your talk from elm-conf, but so far it has been really insightful. I just started out learning elm, so it is a lot to grasp, but I am pretty sure those concepts will be very helpful in the long run. Besides that, one of my coworkers will be part of the team working on said hobby project. He has not had any contact with elm whatsoever and deep inside I hope he'll like it so much that I can convince him to try to use elm in production as well :D.
No. Html elements are opaque and final. There is no way to update their contents after their declaration. You could however implement your own datastructures that render to Html and modify those.
Had no idea that you could do this. Thanks for writing an easy to understand blog post! 
A common pattern is to pass in the onClick handler (Msg) to the render function. Another way, if your click handler is at the top, is to return a structure like this instead of Html: type alias HtmlDetails msg = { attributes : List (Html.Attribute msg) , children : List (Html msg) } And then button ((onClick HandleClick) :: attributes) children 
For most vcs you need to be within about three lines of each other to cause a conflict. More importantly you should be communicating with your co-developers about what each of you are doing, so that of a merge conflict does arise you already know what the resolution is because you have been talking.
If you cant avoid stepping on each others toes, that's probably not a fault of the language. You need to communicate to solve that. In other languages these sorts of issues dont pop up as compiler errors or merge conflicts but state reconstruction errors.
You're not quite "thinking in elm". Instead of transforming the Html Msg data, you want the original render function to return a function. I.e. instead of render : a -&gt; Html Msg render a = html [ prop 42 ] [ a ] you want render : a -&gt; prop -&gt; Html Msg render a p = html [ prop p ] [ a ] Then calling render with just one argument gives you a function prop -&gt; Html Msg that you can use as a generator for the Html Msg that you actually want to render. Sorry, my elm is a bit rusty, I hope you get the picture.
 ] [ A ] ] / [ / [ ] [ A ] ] A [ ] [ ] A ] [ A ] ] ] / ] / ] [ A ] ] 
Well, it can just be blatantly obvious because it's just two added functions in the same place. 
From what I can tell (my rxjs reading comprehension is pretty poor), because Elm's `Subscription` doesn't have a `filter` function, you would have add some more state to handle sloppy clicking in the way you want. However, Elm has [Union Types](https://guide.elm-lang.org/types/union_types.html), which allow you to model state much more expressively than a slew of boolean flags. Instead of running a bunch of complicated boolean logic to query the state, you just pattern match on your union type and you have each case right at your disposal (assuming you've thought all the cases through, which is sometimes tricky). I'd encourage you to read up on Elm and TEA some more, and try your hand at reimplementing the box example in Elm to see how it compares. The general idea would be to build a type that represents all the possible states of the box, render each state to canvas/svg (with the necessary event listeners) in `view`, and in a `subscriptions` function specify what other event streams (mouse drags, window resizing, etc) to subscribe to in which states. If you need help, we'll be here on reddit and on slack!
Ah interesting, I see that could make the code more comprehensible without RxJS or FRP-like library so I will keep exploring TEA and try implementing that box system to see how it goes. Thanks again.
That type of thing assumes the code that he wants to modify is his unfortunately. 
The `view` function is called after every change to the `model`. If you want to conditionally include an `onClick` handler just do something like view model = let attrs = if model.enableButton then [onClick ButtonClicked] else [] in button attrs [text "Go"] 
Hmm, what are the tradeoffs with say, just having a 'smaller' record for that function? As in if your main model had {a: String, b: String.....z} but your smaller function just took {x:String, y:String} It seems like the main advantage is not having to write the boiler plate to 'cut out' the smaller record from the larger one.
Thank you!
Can you clarify your question with a few lines of example code? It sounds like you're asking about an intermediate step to transform the model into a smaller record that matches the record shape of the function being invoked, but I'm not certain if that's what you mean.
It isn't really a templating engine, is it? More of a layout engine, really. There isn't anything being templated. But if you *did* want to template all of the static content that would just be a matter of referencing static values inside your elements.
&gt; How would you get to the point where you can write a server for authentication, serving static files, sending JSON, storing stuff in a database, and handling realtime messages? One library at a time, unfortunately. AFAIK, Yesod is the only monolithic solution, but that comes at the cost of, well, having a monolithic solution. But even though I haven't gone that route, I don't disagree with it in principle, IF you can swap out components that don't work without having to rewrite your entire application. But yeah, the amount of time you have to spend building, configuring, and bridging all the basic components of a full stack web application is ridiculous. Especially since countless developers are doing *the exact same thing*.
How is this different from row polymorphism, if at all?
Exactly, you do not have to write the boilerplate to *cut out* the smaller part and *put it back in*.
[This is a diagram](https://github.com/Sch3lp/pokerchip-dealer/blob/elm/Dealer.jpg) of the thing I'm trying to achieve. So really the thing I'm trying to achieve is that I need to solve a Knapsack Problem using Dynamic Programming, and to generate all the solutions I need a Cartesian product of all the amounts of different chip colors in a (poker)stack. I try to write code so that it's expressive enough not to need a lot of comments. Can you point out where/what made it incomprehensible? It would help me a lot. During my checkin with the Trampoline stuff I made my loops tail recursive. And while I was on the elmlang Slack we changed those calls into more simple `List.foldl` calls, which improved performance somewhat, but it still broke.
My mudder used to yell "White Power, Chippa!" but never when her friends Reggie or Lamaar were around.
Thanks for the reply! I don't think I need a `Debug.crash` since I've got unit tests covering the breaking case. And I don't like it as a solution to my problem. When you say _You can probably do better with unit tests._, did you mean my unit tests need to become better (more readable, more constrained, ...)? Or did you mean Unit Tests are better than `Debug.crash`?
I am very new to Web dev and Elm and am building a simple one page app. Gotta start somewhere! I'd appreciate some help here: https://www.reddit.com/r/elm/comments/6xtjym/beginner_question_calling_two_functions_onclick/
&gt; To switch the view instantly when pressing the second button I need to flip the Bool values of both variables. ShowUrlBarAndPremium -&gt; { model | showUrlBar = not model.showUrlBar, showPremium = not model.showPremium } in the view div [ buttonStyle ] [ button [ class "siimple-btn siimple-btn--teal" , onClick ShowUrlBarAndPremium ] [ text "Try Now" ] **OR** ShowUrlBarAndPremium (showUrlBar, showPremium) -&gt; { model | showUrlBar = showUrlBar, showPremium = showPremium } and in the view div [ buttonStyle ] [ button [ class "siimple-btn siimple-btn--teal" , onClick (ShowUrlBarAndPremium (not model.showUrlBar , not model.showPremium)) ] [ text "Try Now" ] --- The event handlers in the `view` should just inform the `update` that something happened in the view. They can cary contextual information if that's needed but they should do as little as possible. The real handling of the event should happen in the `update`. Please note that in the above examples I tried to stay as close to your code. I would probably name things a little bit different, e.g. if it is a `ShowSomething` it should care less about previous state and just toggle something to true. If I want to toggle between states, I tend to call that `ToggleSomething` 
Great, thanks! I'll try that later! Did understand correctly, that elm-navigation is really meant for switching to an entirely new part of a website? 
If the booleans are always opposite you only need one Boolean.
You might want to consider using a union type to model this instead of two booleans. Maybe something like: type ActiveSection = Premium | UrlBar 
They're both start out as False. But I'll consider changing the launch page to start with one of the Buttons enabled, only then I could use your suggestion, thanks!
I'll consider that. Still having a hard times with the docs sometimes, but it's really fun so far. Thanks!
Ah. Missed that. Then you should probably use a union type with three states. 
&gt; Did understand correctly, that elm-navigation is really meant for switching to an entirely new part of a website? `elm-lang/navigation` is used to implement SPA features (e.g. pages) to an elm application. I guess you could call that "switching to an entirely new part of a website". 
In my specific case, I knew the problem had a solution, and that the code was faulty. But my code was stuck "looping" in recursion where it shouldn't. So I added this "fuse" recursion-iteration counter, and then did a `Debug.crash` when a loop was detected while also logging more debugging info. Once I corrected and fixed my code, I removed the "fuse" and `Debug.crash`. You could probably do better writing a unit test instead of debugging in the browser like me.
So I've looked over a lot of the links everybody posted and tried a few things on paper myself. I think I can summarize the current state of affairs as follows: * If you describe something as a component people assume usage as in React, i.e. turn every tiny Html element into a component. * Turning simple Html elements into components is not sensible. It merely ads complexity. * In some cases the need arises to use (view, update, subscriptions, init, Model, Msg) tuples. For instance in large Html elements which do not need to communicate with other elements on the page but require complicated, isolated logic, e.g. entire pages in an SPA from the routing module. In these cases using such tuples is acceptable, although it adds boilerplate code. This is what I intended with this post. * If you'd try to get rid of the aforementioned boilerplate by giving components independent update functions and states, you're causing one of two problems when you want any communication (such as getting the state for the view function): 1. You have to pass messages between components through the runtime with the update function, causing even more boilerplate than you had previously. (this also violates the *single source of truth* paradigm) 2. You violate the constraints/assumption of functional programming languages. Causing hell-knows-what kind of problems. * Using some syntactic sugar/meta-programming, e.g. something like macro's or a deriving keyword, to reduce the amount of boilerplate code could be an alternative, but how this might look is non-trivial. Ideally though, this could also make coding less error prone by ensuring you're using all of a module's subscriptions, update, etc. functions. * Above solution might, however, encourage developers with certain background, e.g. React, to be lured into the trap of using the tuples just like components wherever they can. I hope my points are clear enough. To me at least, this seems like a pretty complete summary of why components or agents that 'manage themselves' are a no-go, at least when web-page/UI design is concerned.
With regards to what you are trying to do, the file you linked had like 3 implmentions of the same thing all without documentation. The code will document the what and how if its well written you still need to document the why. If you need a Cartesian product I believe there is one in elm-community/list-extra
Cheers!
Oh right. Cheers!
Gotcha, yeah that sounds totally reasonable! "It needs a whole bunch of messages" generally means `Html.map` :)
Yep, agreed!
Here is a pretty minimal refactor to fix *just* the problems you have been experiencing. I removed all of the style calls because I didn't have them and didn't want to figure out what to replace them with. https://ellie-app.com/4cHhgX5dFQWa1/0 Since you don't seem to want to have a state where url-entry and user-entry exist at the same time (but sometimes neither), we model that with a union type with three states. We have three actions, show the url-form, show the user entry form, hide whatever is shown and those update the model state to the appropriate thing. We change the messages that the buttons produce depending on which state we are in. More work could be made to DRY up all of this button code so that you describe how they should look and act in a single place, reducing opportunities for errors when things change.
ehh close enough. Behind the scenes it templates the css/html using standard flexbox/border box rules.
The library you seem to be using, elm-xml, exposes the constructors of its Value type so that you can pull it apart using case statements. Here's a function you can write that tells you whether or not a Value is a DocType node: isDocType : Value -&gt; Bool isDocType value = case value of Xml.DocType _ _ -&gt; True _ -&gt; False With this function, you can write another one that filters out DocType nodes from a list of Values: filterDocTypes : List Value -&gt; List Value filterDocTypes values = values |&gt; List.filter (\value -&gt; not (isDocType value) ) With these functions defined, you can now write a function that takes any decoded Value and strips out any top-level DocType nodes that it finds: stripDocType : Value -&gt; Value stripDocType value = case value of Xml.Object children -&gt; Xml.Object (filterDocTypes children) _ -&gt; value Here's an example you can play with: https://ellie-app.com/4cJdWQhCP45a1/1 If you wanted a similar function that would strip out certain kinds of nodes from anywhere in the document, not just the top level, then you could use recursion to do so.
Thanks for your help. I have one follow-up question regarding your strategy. Your method currently does not use the fact that the DocType should only appear once at the beginning of the an xml document but instead filters the whole thing. In my current case I do not believe this to be very expensive because I think the doc tree isn't being fully parsed (this will be the next step in my project). However, I built from your example here to create such a method and would appreciate any further feedback on why you tackled the problem with `List.filter` and if there is any way to improve on my changes to the `filterDocType` method (as I feel it's best to address bad habits ASAP). filterDocType : List Value -&gt; List Value filterDocType values = let firstNode = values |&gt; List.head in case firstNode of Just val -&gt; if isDocType val then values |&gt; List.drop 1 else values Nothing -&gt; [] Some areas I am currently struggling with are `Maybe`, why I cannot `pop` (notice 2 list operations), and if it's possible to avoid this nested if (which was how I addressed the `Maybe` here). Thanks again for your help. Cheers.
This should have the same effect. filterDocTypes : List Value -&gt; List Value filterDocTypes values = case values of (Xml.DocType _ _) :: rest -&gt; rest _ -&gt; values You can't just `pop` because values are immutable, so you would need something of `List a -&gt; Maybe (a, List a)` which wouldn't be difficult to make, but isn't so nice to work with. It has to be `Maybe` because you can't get an `a` out of `[]`. The solution I provided handles all of these problems in a better way. It basically says that if you have a list where the first thing is a `DocType` return everything after it (even if it is an empty list), otherwise don't change anything.
Great. If I end up writing a blog post I'll put in your warnings then!
Cool. I'm glad we managed to get back to a constructive argument here. 
I have to correct myself. If the only communication happens in the view function you could use a special program with a different signature view function, one that also passes agents / components as arguments, and avoid both message passing and violating functional principles. This is not useful in the SPA example though as you might want to 'clear the memory' of agents that are not currently being displayed, which requires communication.
It is worth noting that most so called "components" have the entirety of the state being essential state and as such they can be implemented as simple functions. You will then have another subset of components that don't need effects and those can be implemented with the `elm-sortable-table` pattern. Only a very tiny minority need the full triad. This means that the boilerplate issue is often over-emphasized. These being said, there are contexts where this stops being true. One example would be requirement for full adherence to Material Design guidelines, more precisely `ripples` effect. In order to implement that, one needs accidental state in most UI components and this explodes the boilerplate use. 
I'm not sure if this will be of use to you, it depends how you are implementing your knapsack algorithm, but I wrote a general purpose AI search library that can handle a wide variety of searches: http://package.elm-lang.org/packages/the-sett/ai-search/latest Lazy lists can help, or sometimes just introducing some laziness through a continuation "() -&gt; ..." can fix problems. Basically, your code needs to be tail recursive to not eat the stack, and needs to be lazy enough to not compute the whole search space when finding just one solution to not eat the heap.
This is quite brilliant. I wonder if then in a larger app where a Model is composed of various sub models (with their own particular update functions and so on) would be cleaner in a "larger" flatter style using extensible records... a single Model type entirely. Actually now that I think about it, it's not far from what I ended up with, but this is indeed cleaner. Really interesting!
Thanks for your suggestion. Yeah, I'm still figuring it out.
Thanks! This is exactly the kind of tricks I was hoping to pick up earlier rather then later. I found this resource on [Destructuring(or pattern matching)](https://gist.github.com/yang-wei/4f563fbf81ff843e8b1e) and am leaving it here for anyone seeking further information on this trick. If you have other resources on this, I appreciate any material you can offer.
I have hacked my way out of this by removing elm-format and reinstalling it using the command to install the experimental version: npm install -g elm-format@exp Found it on [elm-format's github](https://github.com/avh4/elm-format)
Oh shyat. What have I gotten myself into :) Thanks, I'll check it out some time. That last phrase is indeed the problem I'm up against at this point. Where can I find more info on _introducing laziness through continuation_?
Elm has its roots in ML, which is a strictly evaluated language. Haskell is lazily evaluated. Consider this code that returns a pair of values: pair x = (expensiveComputation1 x, expensiveCopmutation2 x) with this code that returns a pair of functions: pair x = (\\() -&gt; expensiveComputation1 x, \\() -&gt; expensiveCopmutation2 x) In the second example, the caller can evaluate the left or right result by passing it (). It may chose to only evaluate one of the branches. That's the basic idea, and you can see how I made the code lazy by inserting a '\() -&gt;' into it. Often code which runs in Haskell will take advantage of its laziness and functions will be written that if fully evaluated would take a lot of time/space to work out, but that actually only ever evaluate a small section of the total result. Getting them to work in a strict FP language is often a case of judiciously inserting a few continuations to add sufficient laziness. Another way, as you have already found is to switch lazy lists for lists. I recommend trying to implement lazy lists yourself to understand this. And take a look at the lazy lists source code too: https://github.com/elm-community/lazy-list/blob/1.0.0/src/Lazy/List.elm
Still chipping away at my Elm/Haskell replacement e-commerce site: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Finished up the product/category details pages, abstract &amp; implement the pagination I built for [the FIC site](https://github.com/Fellowship-Of-Intentional-Community/Wordpress-Theme/blob/master/src/Directory/Pagination.elm) into it's own package: https://github.com/prikhi/paginate Implemented server-side pagination &amp; sorting. Added the search form, advanced search, &amp; search results pages. Working on the static pages and special product listings(all organic/heirloom/etc.). Almost done that, once I finish up I'll add customer accounts, registration, authentication etc. 
Currently working on a package to generate elm code from an ast in haskell. The package is here https://hackage.haskell.org/package/language-elm, but the api kinda sucks. So I'm rewriting parts so it's nicer to use.
Could you be a bit more specific? You can use padding and margins as CSS styles, or the simplest way may be to use the `br` function
Elm pipes to the first parameter of the function you give it, commonly this function is the result of partially applying some arguments to a function with more arguments. Elixir also pipes to the first parameter of the function you give it and then magically (syntactically) applies additional arguments after that. The 'pipe operator' syntax originally comes from F# which like Elm has curried function allowing for easy partial application. So the 'normal' way this operator should work is the way it works in Elm and F#. Elixir needs syntactical magic because it doesn't have curried functions that can be partially applied. In Elm and F# the 'pipe operator' isn't special syntax, it's just a regular operator that you could have implemented yourself. https://github.com/elm-lang/core/blob/b06aa4421f9016c820576eb6a38174b6137fe052/src/Basics.elm#L542-L544 
Are you reusing the parser/AST from Elm itself like Elm-format does?
The easiest way would be to [add margin to a `div`](https://ellie-app.com/4dfbSGf7zfsa1/1). The best way would be to use some kind of styling library like `style-elements` or `elm-css` or plain CSS. 
The Elm version is a norm for languages with currying.
This *is* row polymorphism.
Wow didn't realize they were just fn implemented in elm, very cool. Thinking about it as partial application it seems to make more sense how F#/elm do it and the piped result is going as the last parameter. Guess its just something to get used to. 
No I'm not. I have a simpler ast that doesn't take into account types and spacing. Also, I think elm format defines it's own ast. At least it looked like it did when I read through the source code.
You can also write your function in Elixir as `div = &amp;(&amp;1 / &amp;2)`
Seems a pity so many people are writing parsers for Elm independently. Hmm.. maybe but from what I gathered the plan is to use the same code soon. In any case it would be great if we could have a code generator that plugged into Elm-format. One parse step for both generation and formatting would be great. 
As I mentioned, it's not the last parameter, it's the first parameter. This distinction matters because you might be piping to a function that takes more than one parameter. eg. add1ToList: List Int -&gt; List Int add1ToList = let add1 x = x + 1 in add1 |&gt; List.map Here the value being piped is a function `add1`, it's being piped to a function that takes two parameters `List.map` the result is another function value (`List.map` partially applied with one parameter). Note that `add1` isn't applied as the last argument to `List.map`, but as the first. 
Yeah that would be nice, the current kinda hacky way is to code generate, and then run elm format on the output file.
I do code generation that comes out formatted correctly. It's a bit of a pain to do but I only do fairly simple stuff right now. 
Another question I have: what do you use the code generation for? My project is here: https://github.com/boxed/elm-cog We're starting to use it at work to generate types and json decoders from Python classes and type info. But I'm hoping my lib is useful for people who aren't using python on the backend. It's not very nice though, since you define types with the python syntax... I would much rather have a good code generator for json encoders/decoders, enums, enhanced enums and other useful building blocks that is stand alone, and just generate the code for the data structures with my python code (plus some kind of annotations for the other code generator I guess).
I'm working on generating form components. So you would use a command line interface to specify what form elements you need (text fields, check boxes, ..). And then the cli would spit out a component you could embed in your view.
Would this be a generate once and then use the generated code kind of thing? As opposed to a system where you keep the original code generation commands and re-run the code generator when requirements change. 
Thank you, I appreciate it!
Me too, thanks for your patience!
So ideally you would just regenerate the file when you needed to change it. I also realize however, that it would be difficult to support everything in the generator. So it may be necessary to edit the generated file. I guess it's not really a solved problem yet.
Likewise.
Yea... my idea is to stick strictly to requiring the generated code to not be something people touch. The plan is to check in generated code and having the CI job run the generator and throwing an error if the code changes after that step.
That's pretty cool. Would you use git to see the files changed?
I'm very new to HTML, so excuse my vagueness. I was looking for a quick &amp;nbsp command or similar. Doesn't break move to a new column?
The output of Cog says "(changed)" if any files were changed. Will probably just use that. 
Yes I have; I don't use turbolinks and I give Elm the CSRF token using programWithFlags Seriously turbolinks is a minefield that interacts badly with most other JS.
What it gives you is the ability to limit what a function can access, so you can prove that a function only accesses the fields you think it does.
You would be better to ask in /r/html. Be sure to follow the instructions in the sidebar.
&gt; The 'pipe operator' syntax originally comes from F# No, F# got it from OCaml just like most of the stuff in it. I'm not familiar with OCaml's ancestors but I suspect it comes from upstream.
I'm working on a portfolio/tracker for cryptocurrencies. It's still really early in the development, so a lot of expected features are missing, but it's moving forward! Here is the source: https://github.com/tylermassey/elm-coins
Just a note you can make the Elm pipe behave in the elixir way by using flip div x y = x / y 10 |&gt; flip div 5 2 Or an anonymous function. Also you can make the Elixir pipe behave in the Elm way by using an anonymous function. Example: https://www.youtube.com/watch?v=ePlkx7xayAM 
I managed to find a quite a bit of free time lately to learn parts of Elm that I didn't know before and write a few of these posts. I hope they're useful! I'm going to take a breather before writing the next one but I plan on looking at phantom types next.
Great writeup!
Hi Richard, Just to be sure, are you advocating for or against how https://github.com/gdotdesign/elm-ui works? It would be really helpful if you could voice your opinion on this way of doing things. Thanks!
I wasn't aware this was part of OCaml, as far as I can tell the spelling `|&gt;` was only added to OCaml in 2013 after it appeared in F#. Haskell spells it `&amp;` but that seems to be very rarely used. 
Right, in both its the first parameter, it's just that in the case of Elm the FN is partially applied when i call div(5) so it ends up being the equivalent of div(5, 10) whereas no partial application in Elixir means it will end up as the first parameter meaning div(10, 5). Thanks!!
Thanks for the writeup, I 'never' really understood the Never type.
No. Pattern matching is done on things that need to be known at compile time. So, if you want to select a few greetings based on the age, create a function that processes the age and creates a pattern. like this: type AgeRange = Young | Adult | Senior toAgeRange : Int -&gt; AgeRange toAgeRange age = if age &lt; 18 then Young else if age &lt; 65 then Adult else Senior greet entity = case entity of Person name age -&gt; case toAgeRange age of Young -&gt; "Hello, young one!" Adult -&gt; "Hello, Jedi" Senior -&gt; "Hello, Master Jedi" If you have only one pattern you can also pattern match in the parameter: greet (Person name age) = case (name, toAgeRange age) of (_, Young) -&gt; "Hello, young one!" (_, Adult) -&gt; "Hello, Jedi!" ("Yoda", Senior) -&gt; "Master Yoda, Hello!" (randomMaster, Senior) -&gt; "Hello, Master "++ randomMaster++"!"
Oops, the title is misleading. I am aware they are two different concepts. I just wanted to unite them under the same keyword. 
Glad it helped!
Thanks!
`if cond then ifTrue else ifFalse` is the same as case cond of True -&gt; ifTrue False -&gt; ifFalse So, in a way we don't really need them. What you seem to be asking for is something called 'guards' and many languages with pattern matching have them. They add complication to the language without a big payoff, so they are unlikely to make it into Elm.
Haskell has this in a way, with guarded cases. But the general consensus in Elm is that simplicity of features outweighs code brevity.
Thanks a lot!
/u/Ulmusignobelia has it right! I don't think this will be added to Elm as it would complicate things with no real benefit. Rewriting your code in Elm as it exists now is plenty clear: foo person = case person of Person name age -&gt; if age &lt;= 1 then "You are one year old." else if age &lt;= 10 then "Your age is between 1 and 10." else if age &gt; 100 then "You are pretty old, " ++ name else "Hello"
You get a javascript error if you % by 0
&gt; They add complication to the language without a big payoff, so they are unlikely to make it into Elm. It seems to me, it is the complete opposite. It actually makes the language simple, because you can get rid of `if then else`...
This is actually what my Elm conf talk is about! I hope it's not frustrating, but here's my feedback: Instead of trying to wrap a JS API or a JS library with ports, I recommend instead treating everything that happens javascript-side as a black box, and designing your own API for interacting between Elm &amp; JS. The reason you're frustrated wanting to use callbacks with ports is that ports follow a design pattern used heavily in the area of fault-tolerant, highly concurrent distributed systems called the "Actor Model", and that design is different from a design that uses callbacks. In the Actor Model, parties communicate only by sending messages and receiving messages, not through the request-response relationship that we're used to with callbacks, promises, or HTTP requests. I recommend using just one port in your application to communicate with javascript, and then passing meaningful information back and forth through that one port using json encoders and decoders. My talk still isn't done yet, but you can find the example code for what I'm talking about here: https://github.com/splodingsocks/a-very-im-port-ant-topic/blob/master/example/src/OutsideInfo.elm That "OutsideInfo" file contains the code that is in charge of the communication between JS &amp; Elm. Here are the slides for my talk, if that's at all useful (like I said before, it's not done yet): https://gitpitch.com/splodingsocks/a-very-im-port-ant-topic/master?grs=github&amp;t=black If you want more help feel free to message me on the Elm sack channel: @splodingsocks.
I would say that handling asynchronouse messages in elm is definitely possible using ports. But you should send all necessary state to identify what connection or queue a message belongs to. I'm not sure if I really understand what you are trying to achieve. But I think that your code should allow the browser to subscribe to messages on multiple STOMP connections (each with their own path). This is separated in two steps: First the establishing of a connection, then subscribing to changes on a channel. **First step:** Establish a connection Assumption: Inside the elm code you want to know if a connection was established or if it failed. That is what you have the outgoing *newConnection* and the incoming *connectionMessage* for. I'm guessing that you currently keep track somewhere inside the elm model, which connection path is currently being tried to connect to. I would instead change the definition *connectionMessage* to this: port connectionMessage : ((String, String) -&gt; msg) -&gt; Sub msg This way the message can be handled independent of a specific order. You receive the tuple (&lt;connection-path&gt;, "CONNECTED") in elm and can store in elm that the Stomp connection with the passed path was established (or not, or has thrown an error somewhere) and continue accordingly. **Second step:** Subscribe to a queue Handle the message that was received depending on the connection and on the message queue. app.ports.subscribe.subscribe(function(elmtuple) { var url = elmtuple[0]; var queue = elmtuple[1]; if (STOMP_CONNECTIONS.hasOwnProperty(url) || !(STOMP_CONNECTIONS[url]["connected"]) ) { // this is executed if a connection for such an url exists // or if the connection for such an url is NOT in state "connected" (are you sure that is what you want?) // I guess you want // if (STOMP_CONNECTIONS.hasOwnProperty(url) &amp;&amp; STOMP_CONNECTIONS[url]["connected"]) { var conn = STOMP_CONNECTIONS[url]; conn.client.subscribe(queue, function(message) { console.log('Received message on connection ', url, ' on queue ', queue, ': ', message) app.ports.receive.send([queue, message.body]); }, {}); } else { console.log('Not connected to ', url) app.ports.connectionMessage.send(url, "NOT CONNECTED"); } }); At work we also have a custom binary data format we use for WebSocket communication, and we used a similar approach. If you plan to have more ports, I would also suggest that you have a look at the decoders that @splodingsocks wrote about, but if there will be only the two interactions, I would rather keep the two ports. About &gt; My attempt so far gets stuck in Elm's task handling work queue (Elm internal function 'work()') during the websocket connection in stomp.js. How does it get stuck? If you add a debugger break point before executing *app.ports.receive.send*, is there a problem with the scope? Have you tried wrapping it in *setTimeout* or *requestAnimationFrame*? It could help if you are stuck in the event loop for too long.
Two additional notes: 1) This is called the "bottom type" in type theory 2) It can be considered a nullary sum type; that is, the type of 0 choices. With this view in mind, we see that it does indeed serve as the identity on sum types: `t + never = never + t = t` for any type `t`.
Great article!
Great series of posts.
I recommend watching this talk by Rich Hickey about the meaning of 'simple'. https://www.infoq.com/presentations/Simple-Made-Easy Guards complect conditionals with case pattern matching because now instead of having two things that are not connected you now have one thing that does 2 things weaved together. 
This is one of those things which boils down to aesthetics. Do you like minimal languages with no syntax sugar? Then `case` alone would suffice. Alternatively, do you want to pander to familiarity? Then `if then else` is good.
Eh.... This is technically true. But only technically. My comment above is still valid here. It's more opinion than anything else whether guards are good to include in a language.
It might be worth it to do one of these on the unit type
Yeah its probably worth mentioning Bottom in the article. 
I like this
Take a look at [this article.](https://pragmaticstudio.com/blog/2017/5/12/elm-with-rails-5-1)
The simplest way would be to create a rails app in api mode: $ rails new my_app --api Then, you will need to add the "rack-cors" gem to your rails app in order to allow Elm to access your API. https://github.com/cyu/rack-cors For example, if your rails app is running on port 3000 and your elm app is on 8000, you will need to add an origin to your rails app that allows 'http://localhost:8000'. You can see example code in the rack-cors link above. After you've got this setup, it's just a case of making requests as normal from Elm to your locally running rails API.
There are few other people who came up with this before: - https://github.com/unbounce/elm-debounce/ - https://github.com/eeue56/elm-debounce-effects - https://github.com/pyoner/elm-debounce - https://github.com/mceldeen/elm-debouncer This is a very good example of why people should be allowed to publish any package they like. 
hej /u/flecks6 &gt;Those superfluous updates, although they didn't change anything to our app state per se, still triggered a useless dom rendering each time they were executed, has they were handled by our own update. Would it be possible to see this happening in a gif or something ? As far as I understood the render is triggered only if needed, not always. EDIT: also, nice I like this! 
Each time your update function is called, elm re-calls your view function with the new model outputted. That means it re-renders the virtual dom, checks if there is anything that changed since the last render, and makes patches if there is. That whole process happens even when you change parts of your model that don't affect your view. Although it isn't that big of a deal, since that process is pretty fast most of the time, it's still an unnecessary overhead that affects performance. So my general mindset for the apps I make is to try to keep the amount of those messages that aren't related directly to my app to a minimum.
Yes, indeed I know there are a lot of people who implemented a debounce command with effect managers, but none of them were offering throttling, which isn't the same. 
Should or shouldn't?
&gt; Each time your update function is called, elm re-calls your view function with the new model outputted. That means it re-renders the virtual dom, checks if there is anything that changed since the last render, and makes patches if there is. Have you tried [Html.Lazy](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Lazy)?
Should. In this case for example people would have discovered the package instead of writing the whole thing themselves again and again, or maybe a PR for that package with the new feature.
Sorry I just saw denounce and effect manager and jumped to a conclusion. Very nice package, any plans to merge it with a package above, so both options would be at the same place?
Agreed.
I know Html.Lazy, but the useless re-renders are still a thing whether you use lazy view functions or not. Sure, Html.Lazy makes them more or less efficient, depending on simplicity of the arguments of your view functions, but the performance boost will never be as great as if those re-renders were never done in the first place. It's sure is a tiny performance boost, but still a performance boost. I might have put too much emphasis on that point in my post though. My objective in making this module was more to reduce useless noise in application code than to have a big performance boost.
&gt; It actually makes the language simple, because you can get rid of if then else Everybody understands `if then else` and it is an extremely simple concept. In some languages you can even implement it as a function. The one language where it makes some sense not to use it is Elixir, because of the "let it crash" philosophy where the norm is to pattern match on modules. And this is more because of ecosystem consistency than any other particular reason; it's not so different from say, naming the first parameter of a Python method as "this" instead of "self".
Split your model up into two parts, one for state and the other for debounces. Then make your view function this view model = lazy realViewFunction model.state This will stop unnecessary rerenders 
A limitation to that example is that while it shows how to have a bunch of isolated pages, but not how to do page-independent things very well. If what you are doing does not rely upon the page that you are doing it with, just add it to wherever the case statement is that switches based on messages. In this case it is [updatePage](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L321). Not knowing *that* well how user sessions are handled in this app, it might be implemented something like: (Logout, _) -&gt; {model | session = {user = Nothing}}
What about if you want to send this message from within a page, from a link? I know that in the example it's not necessary because to logout the path is set to `#logout` and then the session is cleared, but I'm thinking about other events.
Maybe post this to other js related subreddits, not sure that a video is the best way to reach out either 
`Logout` is handled as a route. https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L286-L295 So presumably any page that has a logout button/link could handle this by sending `Route.modifyUrl Route.Logout` as a Cmd. But are you asking in general about changing 'common' (top-level, app) state from a particular page? In this example app, it's done through the `ExternalMsg` pattern. See for instance on the `Register` page: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Page/Register.elm#L150-L153 and how `SetUser` is handled in `Main`: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L420-L438 
Guards already exist in this package: http://package.elm-lang.org/packages/Fresheyeball/elm-guards/latest
I think the best way to approach this (without tons of out-messages) is sending messages to root update. Not sure if there is an easy way to to this in 0.18 -- child update msg m = case msg of ReceivedUser u -&gt; model ! [ Messages.send (SetUser u) ] -- root update update msg model = case msg of ReceiveMsg msg_ -&gt; case msg_ of SetUser u -&gt; { model | user = u } ! [] -- Root Subscriptions subscriptions _ = Messages.recv ReceiveMsg 
My main issue with rails is it doesn't seem possible to use the reactor or debugger. Let me know if you find a way.
Facing a similar issue, but with displaying Error messages. How do I display error messages from multiple pages at one place?
This is a very beginner question, but I can't seem to find an answer anywhere. Suppose that I have two type aliases: type alias User = { token : String , email : String , password : String } type alias Model = { user : User } Then, I have initializers that build those models: currentUser : User currentUser = { token : String , email : String , password : String } initialModel : Model initialModel = { user = currentUser } In my updates, how do I take a user input from a view that updates the model and use that to update the user within the model? Something like this doesn't seem to work: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of SetEmail email -&gt; ({model | user = { user | email = email}}, Cmd.none) I know how to do it if I were to extract out the user into a separate module and import it, but is there a way to do it this way as well in the same file? Thanks for any help!
https://github.com/elm-lang/projects/blob/master/roadmap.md#how-do-i-make-a-single-page-app
What do you mean by elmjobs?
https://github.com/FidelisClayton/elm-jobs &amp; https://twitter.com/elmjobs_
so check jobs channel https://elmlang.slack.com/messages/jobs/details/. I think it's the most active.
&gt; Hopefully itâ€™s a little more clear that because `Never` is recursively defined it is impossible to use it as a value. `List` can also be recursively defined as `type List a = Nil | Cons a (List a)`. This definition allows creation of values of type `List` because it has a base case as well as a recursive case, while the definition of `Never` does not.
 currentUser : User currentUser = { token : String , email : String , password : String } This is a value declaration, not a type declaration, so you need to actually assign values to the fields instead of just declaring their types: currentUser : User currentUser = { token = "" , email = "" , password = "" } In your update you have: ( { model | user = { user | email = email } }, Cmd.none ) Nested record updates aren't allowed, so you have to assign the updated user to a variable, then use that variable to update the model: case msg of SetEmail email -&gt; let updatedUser = { user | email = email } in ( { model | user = updatedUser }, Cmd.none ) But you'll have to repeat that `let ... in ...` for every field, so you probably want to nest your message type &amp; update functions: type UserChangeMsg = Token String | Email String | Password String type Msg = UserChange UserChangeMsg update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of UserChange subMsg -&gt; ( { model | user = updateUser submsg model.user }, Cmd.none ) updateUser : UserChangeMsg -&gt; User -&gt; User updateUser msg user = case msg of Email email -&gt; { user | email = email } Token token -&gt; { user | token = token } Password password -&gt; { user | password = password } Usually try to have my msg/update nesting match my model nesting. The sub-updates can return whatever data you want to give to your main update, could be just `User`, `(User, Cmd UserChangeMsg)`, `(User, Cmd Msg)`, etc. Edit: Also, I wouldn't store the password of the current user in your model, just the auth token. I do store entered passwords for my login forms, but I make sure to clear it out after successful authentication &amp; just use auth tokens for future requests. 
`()` is not "empty parentheses", it's "unit" a type with a single value (which is `()`). Underscore doesn't stand for "empty parentheses" but is rather a placeholder for any value.
Against. I would not use it. :)
 Nice of you!
Related, I own reactivecast.com and have never done anything with it. If anyone promises to build something cool, DM me and it's yours. Recently renewed until Oct 2018.
Then that answers my question. :)
Thanks, will do. Not much of a Slack fan tho :/
Thanks, I'd seen those two ways but in my head both seemed a bit awkward. What would be the best way to handle path based routing, in your opinion? It's possible to configure the server to always serve index.html for pages that produce a 404 but this results in a flash when each link is clicked as the browser reloads everything. To prevent this, each link needs to prevent the browser's default behavior like so: onLinkClick : msg -&gt; Attribute msg onLinkClick msg = let options = { stopPropagation = True , preventDefault = True } in onWithOptions "click" options (Decode.succeed msg) A helper function can be written to aide in writing links: link : (Route -&gt; msg) -&gt; Route -&gt; List (Html msg) -&gt; Html msg link toMsg route linkContent = Html.a [ href route, onLinkClick (toMsg route) ] linkContent But this means that the `link` function requires a page message to send a command to modify the browser's url. For example: view : User -&gt; Model -&gt; Html Msg view user model = Route.link ChangeRoute Route.Article [ text "Article" ] type Msg = ChangeRoute Route update : User -&gt; Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update user msg model = case msg of ChangeRoute route -&gt; ( model, Route.modifyUrl route ) So every page would need to have a `ChangeRoute` message to handle links? And the `ExternalMsg` pattern seems worse. Or is there a better way? In case you're wondering why I want to use path based routing over hash based, for query parameters. Evan's urlparser library doesn't support them if using hashes. Technically, it would be possible to append the query parameters to the hash and do some custom parsing but I'd prefer to keep the urls RFC compliant and I would like to keep the hash for it's original purpose, to refer to a specific part of the page.
It sounds like you'd need to store your errors in your top-level model and then use the `ExternalMsg` pattern as described by /u/ericgj.
yeah, but now you're coding around deficiencies instead of writing clean code that just works. ideally performance doesn't dictate how you write code. it's like when you change `.forEach` into `for...of` in javascript because the latter is faster for a hot loop. ideally you wouldn't have to think about that.
Hey people I just made my first medium post ever and I decided to make it about Elm. Its more of a rant about my experience so It may lack content but posting it either way just in case someone finds it helpful. Cheers
Nice write up. Getting these anecdotes collected helps with making Elm better in the future so thanks for writing it. What are your next steps?
Interesting post. Are you planning on using Elm in a production environment?
We were discussing about introducing it to a React project the other day. It will be probably either that or making some internal tools first to try it out.
Probably will be using it for my own projects but the other day we started thinking about introducing elm in some existing React projects we have.
We've done most of our internal tools in elm and have found it to be an excellent experience. It has tended to dampen elm's weak points and allow its strengths to really shine. That's not to say it'll be any less great as part of a react appâ€”we just haven't done that quite yet!
&gt; for query parameters. Evan's urlparser library doesn't support them if using hashes. Are you sure about that? I haven't tried it, but I think it should work as long as your urls are like /some/path?key=value#page and not /some/path#page?key=value. [Relevant issue](https://github.com/evancz/url-parser/issues/27) &gt; So every page would need to have a `ChangeRoute` message to handle links? Yes. But it's just one Msg to handle _all_ links and other user-triggered redirects from the page. And it's just one line. And if you go with hash routing, you don't need it for links since you can rely on the browser's own link behavior. A bigger question is, do you _need_ query parameters - could you just use the url hash? Or stick some of that state in localstorage? 
Well, if you follow the example app, there's no need to "pass error messages back up", because everything that can result in an error is done in Main -- routing, http requests and checking login status basically. Any of these are considered 'page loading' errors which sets the active page to `Errored`. Particular pages deal with input validation errors themselves of course, but I assume that's not the kind of errors you meant. If you have a situation where users can (re)load data from within a page, typically you don't want to redirect to a general error page when there's an error, because you want to preserve the context in which the error occurred, maybe let the user retry, etc. Depending on the kind of error, usually you'd want for example a dialog box or notification that appears on top of the page - no?
I actually had a similar Elm v. Redux conversation yesterday with some coworkers. I ultimately referred them to the [buttons example](http://elm-lang.org/examples/buttons) and we talked about it in terms of Redux. This is the action. This is the reducer function. This is how I would add a Reset action and button. The compiler will force me to handle that action to guarantee no type errors at runtime. Even though it was a brief example it very quickly went from "what the heck is this syntax" to "oh wow that's cool".
&gt; seeing types being used as entities by themselves without having necessarily any value associated with them was a little confusing in the beginning I'd just like to point out that those are values not types. type Process = Queued | Active | Finished Is a type called `Process` with three possible values `Queued`, `Active` and `Finished` 
If you aren't using combineReducers how do you handle multiple reducers? Unless you have all your state inside one reducer? 
If no one will grab elmexamples for the few days, I wanted to put together list of tiny elm apps for learning internally. Can grab elmexamples and post/open source there.
Let is older than Haskell and not everything is related to JavaScript.
If you don't use combineReducers when using Redux, then you start off by having a single reducer function which consists of a switch statement that handles each action. When that single reducer function gets too big or difficult to understand in certain areas, you can naturally split it out so that you have more reducer functions that get called at each case statement and you explicitly pass the section of the state that that reducer function handles along with the action. The idea is that you can easily see where the action goes because it only gets handled by a single reducer function. This is the same sort of thing that you do when you program in Elm. When you use combineReducers and pass in X number of reducer functions to combineReducers, every time an action is dispatched, each of those reducer functions gets passed the action, so any of those reducer functions can change their state. So if you want to understand what state is being changed when an action is dispatched, you have to look at each one of those X reducer functions instead of explicitly being shown a single reducer function that handles the action.
&gt; Let is older than Haskell Elm originates from Haskell so it makes sense to use it as an example. Anyway you can replace Haskell with Ocaml or any other functional language with `let in` and my points will still hold. &gt; not everything is related to JavaScript Elm *is* related to JavaScript. 
Thank you very much for the info. I'll fix it in the article.
Right but Elm's existence is neither per JavaScript nor is it per Haskell. It's its own wonderful thing. Personally, I'd love to have a where clause because some functions come out better that way. But since let/in in Elm allows functions, an additional where-clause makes less sense.
&gt;Are you sure about that? I haven't tried it, but I think it should work as long as your urls are like /some/path?key=value#page and not /some/path#page?key=value. Yes, that works and I tried that. But, unfortunately, it causes a full page load from the server which isn't ideal. &gt;Yes. But it's just one Msg to handle all links and other user-triggered redirects from the page. And it's just one line. And if you go with hash routing, you don't need it for links since you can rely on the browser's own link behavior. Okay, good to know. &gt;A bigger question is, do you need query parameters - could you just use the url hash? Or stick some of that state in localstorage? I think so because when loading the page I need to instruct it what to initially load. For example, filtering dates `?start_date=2017-01-01&amp;end_date=2017-06-30`. I suppose I could do this by local storage but it means users cannot manually edit the url themselves (which they like to do) and also if the page cannot be linked to from an outside source. I'm in two minds now whether to keep using path based routing (with the link hijacking), which seems more proper in some ways, or to use a url hash with the query string appended to it and then use some additional parsing like in the Github link you mentioned. If you have any opinions on which is better I'd like to hear them but there doesn't seem to be much consensus.
How do you log output in Haskell? I have noticed that as I write more Elm I write fewer and smaller `let` blocks and instead I use pipe and compose more frequently. But I do find them convenient for logging output `_ = Debug.log "Value" value`.
I think it would be difficult to parse or to throw understandable error messages if there is something wrong
`let ... in ...` has the benefit of making scoped assignment blocks explicit by wrapping them in an expression. The proposed change would add in other, more subtle points of confusion as assignment statements in Elm are not order-dependent and can even be mutually recursive. Making this transition initially easier just kicks problems down the road. JavaScript developers already have a problem of putting too many ideas into their functions, the extra syntax and indentation can serve as a reminder that you should probably be using this sparingly. All of that said, your points are also interesting. I don't know of any dominant arguments on either side. Elm has dropped syntax in the past to simplify things and very well could in the future. Just be aware that 'ease of access for JavaScript developers' often ranks near 'promotes good coding practices' and I think this proposal creates a conflict between the two.
Personally I prefer hash based bc it's less work - you're not fighting the browser. If i needed query params i would probably do the latter (workaround in that github issue). But if your users want to manually edit the url I can see a case for path based. I just don't have much experience with it. If you haven't already, I'd ask in the #routing channel on elm slack. 
Cool, thanks very much for your help. I didn't know about that channel, I'll check it out. For what it's worth, according to [Section 3.5 of RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.5) which specifies urls, it's acceptable to have query parameters in fragment identifiers: &gt;The characters slash ("/") and question mark ("?") are allowed to represent data within the fragment identifier. Beware that some older, erroneous implementations may not handle this data correctly when it is used as the base URI for relative references (Section 5.1). So Evan's urlparsing library should probably parse the querystring contained within the hash in hash mode.
Here are some historical facts: - Elm does not "originate from Haskell" any more than JavaScript "originates from C++". Languages like Standard ML, OCaml, Haskell, Elm, F#, etc. all have [ML](https://en.wikipedia.org/wiki/ML_(programming_language\)) as their common ancestor, and it explains most of the similarities. - The `let` syntax was in the original ML language from 1973 because it was crucial to making full-type inference decidable (i.e. efficient) - Having the `let` paired with `in` makes parsing less ambiguous and less dependent on whitespace. In C-style languages, having `var` paired with `;` does the same thing. The C-style you are encouraging goes back at least to C which came out in 1972, one year before ML. Which syntax is "better" is a pretty bad question. It is kind of like asking if the Arabic or the Korean alphabet is better. A better question might be "how does the syntax fit into the rest of the language?" In Elm, curly braces then are primarily associated with records. Unlike C-style languages, we have no `for`, `while`, `do`, or `if` statements that use curly braces. This means there is no strong association between "control flow" and curly braces. So functions using curly braces in a C-like language makes sense because it is about control flow, but it functions using curly braces in Elm is weird because it has no relation to the record system. So this question is kind of like saying that Japanese should use English-style quotes because more people in the world speak English. But the `"` looks just like the modifier on `ãŒ` that distinguishes between `ka` and `ga`. That would be confusing! And in the end, the goal of Japanese is not to please English speakers. If people find it useful to learn Japanese, they will do so. If they do not, they will not. It's fine.
That would add so much extra verbosity simply to communicate something that should be easy to learn if you're learning elm: functions are always curried.
&gt; The reason I find `a =&gt; b =&gt; ...` superior to `\a b -&gt; ...`. [Yeah, well, that's just, like, your opinion, man.](https://www.youtube.com/watch?v=pWdd6_ZxX8c) But now, seriously. The lambda expression is quite fine as it is. I have spent enough time answering questions in #beginners on Slack and I don't have memories of people having issues with the anonymous functions. They learn how things are done in Elm and move on. People of different backgrounds will find familiarity in various syntax details but this is no good reason to change. In order to change things now we have to come up with real advantages that would warrant breaking other people's code. Marginal advantages are no longer an option. The advantages you presented are marginal at best in my humble opinion. Other people might see it differently. 
As I understood it they weren't, they were just used as values but were also types themselves, kinda like polymorphic typing.
What about `where`? It's not a big deal but I kinda miss it.
Not order dependent? Is this documented somewhere?
I can't find any docs yet, but it is a holdover from haskell, and you can verify it yourself with this [example](https://ellie-app.com/4gJtGsDHFXga1/0)
Debug.Trace.trace maybe what you're looking for https://hackage.haskell.org/package/base-4.10.0.0/docs/Debug-Trace.html#v:trace
This confusion happens from time to time. I guess it might be because the tags of a type are capitalized and this makes them look like type names. 
Yeah, getting your `update` spammed is a bad solution. Even a `lazy` no-op is going to be noticeable on an older device when it's spammed. Something like this library is pretty necessary.
Think they just mean that this works: test : Int test = let b = a + 1 a = 1 in b test == 2 
It's bikeshedding. No one really feel confident suggesting changes to the power plant so everyone discuss which colour the bike shed outside should be. It's a chronophage activity that detracts from the work Evan is doing on the core thus quite counter-productive.
The thing I love about let/in blocks is that they force you to not have variable assignment in random places, it has to be at the top. Really this is necessitated by the fact that there's no side effects and everything is a pure function so ignoring the return value of a function call makes no sense. I think the "in" makes this more clear than ; or whitespace. It serves as a reminder to your brain that this is a pure language and you can't program the same way as you do in JavaScript or Ruby or X other side effect allowing languages. 
ReasonML has syntax like this (https://reasonml.github.io/guide/language/let-binding) they introduce braces for block scoping and added semicolons in place of `in`. I think this is actually worse for people coming from JS, it's familiar syntax with unfamiliar semantics which is going to lead to confusion.
[redux-loop](https://github.com/redux-loop/redux-loop) gets you a lot closer to the elm side effects.
Sure sounds good. I'll give it a week from this post and if no other suggestions it's yours.
Thanks!
The type signature of functions already makes the currying explicit. `fold : (a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; List b` says that `fold`is a function that takes a function of type `(a -&gt; b -&gt; b)` and returns a function of type `b -&gt; (List a -&gt; List b)` If you like the verbosity you can write out the the anonymous functions but it's kind of a pain. `fold = \function -&gt; \base -&gt; \list -&gt;....` 
Thanks [splodingsocks](https://www.reddit.com/user/splodingsocks) and [marcwalter](https://www.reddit.com/user/marcwalter) for your input. I'm just back from a short trip and will get back to my playing with this port module this week. I like the idea of using a single port each way for input and output. I did realize that ports, especially something like STOMP, requires an an async mindset. I've been doing various TCP socket protocols for a couple of decades, the inner workings of Elm and Websockets are somewhat new to me. I think Marc's idea of using setTimeout() or requestAnimationFrame is likely to get me over my current issues. I also found this post by Evan: https://gist.github.com/evancz/8521339 and updated for 0.18 near the bottom of the page, seems like another possible approach for the mechanics of getting this working.
Thanks, and love your podcast.
You don't have to use 'let in' if you don't want. Just use the forward pipe operator (|&gt;). 
&gt; I think this is actually worse for people coming from JS Didn't we learn with JS that the same syntax with different semantics create confusion?
What makes combineReducers useful is that each reducer now operates on its own subtree of the state. It works well when you need to listen to API actions to update data models and want to keep them separate from each other, and any other data you may have. This isolation is more important in JS because of how things tend to get intertwined and have action at a distance. Because of Elm's immutability, it's more natural to look at several parts of the model together. When it makes sense to operate on only a subtree, that's a good candidate for an extracted data structure (see Evan's recent Elm Europe talk).
Elm is not JavaScript. Functional programming is a side feature in JS but in elm anonymous functions are used often. It makes sens to use a short syntax. It is certainly also a good idea in JS to be extra verbose to help people figure out quickly what the code is doing. But in elm we have the type system that does this job, and very well by the way. What i mean is that in JS, to understand someone's code you have to look at the code. But in Elm it is usually enough to just look at the type signature. 
Why would you do fuzz testing on that decoder instead of generating it from the schema? 
Slowly working on a Magic the Gathering collection manager app, and the elixir backend is at the point that I need a frontend to get an MVP to show. Going to look at setting up Elm + channels as the bulk of the UI. What's the easiest way to do phoenix channels w/ Elm - anybody have a reasonably up to date blog post on this?
There is no library support for that yet (as far as I know) and also I want to retain control over the types and names. Look at the decoders generated by http://eeue56.github.io/json-to-elm/ for example. They are a good start, but I would not commit them verbatim.
Thanks :)
Writing your own code generator seems like a better solution to me...
I agree! I'll try that if I get the time.
If you're comfortable with Python I've started a code generation project at https://github.com/boxed/elm-cog Or just use it as a discussion point. I try to make sure the generated code comes out formatted properly. It's nice to not worry about an extra elm-format run. 
You don't. You just send any request and then check where that request came from on the backend. 
It was that feeling that got me into programming originally. Nerdy people solving cool, and interesting problems together for no good reason. 
 You can get the IP using a technique like [this one](https://stackoverflow.com/questions/391979/how-to-get-clients-ip-address-using-javascript-only/32841164#32841164) but you will not be getting the information you look for. In my case, it shows my computer's local address not the address of the router I use to connect to the internet. So... 192.168.0.6 will not be very useful to infer where I'm located. ;) 
You can do it by utilizing a 3rd party server if you don't want to write this for your backend. https://www.ipify.org/
The fact that they not order dependent can be inferred from variables in Elm being single assignment, immutable and not able to be undefined (ie. variables in Elm are names for values). Given those attributes you can't make the order they are defined change their meaning. 
Making good progress on my Elm/Haskell e-commerce site: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Finished up static pages &amp; product type pages(listings for All/Organic/Heirloom/etc products). Kinda cheated on the product type pages by making them [special cases of the search results pages](https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/9520fad24fd2792afe1f397aa39d9e2d603ff881/client/src/Search.elm#L121-L150). Did a little page transition stuff, added breadcrumbs &amp; a 404 page. Started adding Customer accounts in, I've got the Registration/Login pages done, which included the first bit of validation on both the client &amp; server(client validation could use some refactoring or more design work). Gonna implement authorized routes on the server &amp; then do the Account details/edit pages. Then password resets &amp; reset/registration emails. At some point soon, I'll need to refactor the views, update and commands. They're the last couple things left in Main and it's getting close to 1k lines. 
Oh I didn't know anyone was using my lib \^\^ . You're right on the "cleanness" of the code. Even though I tried to minimize the impact, once you have multiple signals to debounce/throttle, it becomes cluttured! At some point I was tempted to add an identifier to each signal controlled, meaning you would have only one state attribute. The downside would be that the implementation would require something like a dictionary and probably lower performances. Another issue with my approach that you didn't mention is the fact that attaching an event to an element of a view function depending on some other state condition (when should we start throttling, etc.) can lead to unexpected triggered events (especially when throttling high frequency signals like mouse moves). You have to be very rigoureous with your update message conditions to avoid problems with this. I wonder if your approach prevent this. Anyway, thanks for the feedback here, it would be awesome if you could also give me some through issues in the github repo, even make a PR to mention your work using an effect manager (which would indirectly also give your repo visibility in the package manager \^\^ ). Hope to hear from you, Matthieu
Hi guys! Once I read Elm compiles to ES3, is this right? If so, why that specific version?
I'd assume it true as code generation is based off the `language-ecmascript` haskell package, which is spec'ed to ES3: https://github.com/elm-lang/elm-compiler/blob/dev/src/Generate/JavaScript/Builder.hs
Not sure where you heard this, but this is definitely not the case since Elm compiles everything to strict mode, an es5 feature.
Sure but it could still be a single pass compilation over let statements. 
ah, that's certainly true. It could be an arbitrary limitation imposed by a compiler. But that would prevent mutually recursive definitions within let expressions, which are also possible in Elm.
It's also pretty common. C works like that for example. 
Yep, but C was designed to work on a PDP-11 in the 70's with such limited resources that a single pass was the best you could manage. 
There are other reasons, like the entire build model but yea. 
I believe the _generated_ JS is ES3. We only use things like `if` and `function` and `while`. Not even `this` or `prototype`! We basically don't need any other features past that. We can build everything from there! :) The kernel code (code that backs `http` or `html`) attempts to use the oldest thing that is still reasonable. So there is some limit on browser age determined by these choices. For example, we use `addEventListener` only, rather than doing some old IE tricks as well.
I continue rewriting https://github.com/1602/elm-json-schema (validator and form builder based on JSON Schema). This project has been started quite a long time ago in order to facilitate form building based on JSON Schema, now it's time for the second iteration and cover whole draft-6 spec, polish API for schema building and manipulation. Work on the core itself is done, now I'm validating UX of API via making form and documentation builder. This week I intend to finish form builder and extract it as a separate project (to keep the core clean of UI dependencies). P.S. it is the first time I expose this project to the public, it is far from a polished state, so if you find time to look into code - you could find a lot of reasons to start a chat with an author, please do not hesitate to do so in gh issues :)
Hi! Wasn't sure whether to make a new post for this but figured I could do with the noob friendly advice so here goes: I should preface this q by saying I'm a total front-end noob. Zero html, zero css and zero js. I hate js, and have avoided frontend because of it. I figured I might reconsider after I heard of Elm, as it seems tailor made to address my issues with js... I'm basically trying to build on the [dragMe](http://elm-lang.org/examples/drag) example by adding a background image, and assigning an image to the draggable object, but I think my lack of js/css (and possibly svg??) knowledge is preventing me from knowing how to manage it. I have 'kind of' managed it, but due to browser behavior (I actually drag the png 'out', I've seen it called ghosting?), it looks a mess and needs an extra click to place the object once I've 'dragged' it. Here's my stab at it: https://pastebin.com/v7p8Hh5Y I'd love to be educated on what I'm missing in order to achieve this, I'm guessing it's some sort of Html or Svg Attribute I'm not giving it. I've tried a couple (can't recall them now). But on top of this, I have kind of a bigger picture question: I thought I could avoid having to learn html, js and css for the most part, as everything would be possible in Elm. This experience has shown me that just learning Elm is not enough, I have to learn the other stuff. Is this right, or have I missed a trick? (It's not a complaint, I am willing to learn). What are the recommended (preferably exhaustive) resources for learning? Another question: How come Attributes are string tuples? It occurs to me that Elm missed a trick here by not using its strong typing to enforce correct usage of Attributes. As it is right now, things fail silently. Elm has excellent compiler messages, but if you don't know your shit (html css js) you're out of luck here. *This aspect of elm makes it slightly hostile to frontend/coding beginners*. I'm sure there is a reason, I'd like to know what it is. Thanks very much for your time!
You're right that you need to know HTML and how the DOM works quite a bit to be really productive. It's because the browser is the platform and you are trying to make it do stuff, so obviously you need to know something about it. The big payoff is that you don't need to know JS and the Elm architecture makes handling the state of the DOM super nice. 
Haven't tried it myself but this seems like a good example: https://github.com/fbonetti/elm-phoenix-socket/blob/2.2.0/examples/Chat.elm
&gt; Is there any reason not to embed the Elm in the &lt;body&gt; tag? This is what `Elm.Main.fullscreen()` does. &gt; How would I do this without nesting them all under something like a div node? What are you trying to do exactly? This looks like a [XYproblem](http://xyproblem.info/). 
Both questions are looking at the same problem, really. I'm not a fan of all the unnecessary wrapping of everything is several layers of &lt;div&gt; elements. What I would prefer to get as my html is more succinct. Something like this: ... &lt;body id="app"&gt; &lt;!-- Generated by Elm --&gt; &lt;header&gt;&lt;/header&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- End Elm --&gt; &lt;/body&gt; This would be desired. There are no examples that I've seen that achieve this since nearly all examples follows the embed pattern I mentioned originally.
I understand now. There is no way (to my knowledge) to do what you want. The output of an Elm program is an Html node, usually a div. This div ends in the body or in the embed div. So, you have one extra div at the top of the tree. 
So you don't think it's ok for there to be one unnecessary div? 
An issue that comes up with all virtual-dom libraries like Elm's and Reactjs is that they need control of all children of the tag they're mounted on. Mounting them on the &lt;body&gt; tags tends to lead to conflicts with other third-party scripts and browser extensions as other scripts often want to add some element to the &lt;body&gt; tag too. 
This is very true, I had a problem with Lastpass adding it's topbar to the page which caused a runtime exception in VirtualDom (JavaScript), I actually suggested that they change the API of `fullscreen` to have it's own div for this reason. 
Made some improvements to https://github.com/OzTK/elm-view-engine, a template engine for Express allowing to have Elm views on the server. I fixed an issue with Elm module names an added some unit tests to improve reliability. Version 2.1.1 just released yesterday!
what would you do with annotated functions like below? In "let ... in" you not only create constants, it's about having an expression that evaluates to a value. "const" doesn't do that. let increment : Int -&gt; Int increment n = n + 1 in increment 10
Of course people are using your lib ;P It was the best documented lib we could find for the purpose we were trying to achieve. But yeah, I'm not sure I ever came across the issue you mentioned, so I could not tell if my implementation fixes it or not. Did you have a code example that could demonstrate this by any chance?
Are you using the JSON schema for some other extra information or presentation somewhere? I'm wondering if you couldn't just use the models from your API to do some code generation instead.
Yep, this is not related to the library and it can happen with any high frequency event (throttled or not). I think this is due to the fact that events are still recorded before your next dom operation is performed. I've put a simple example on Ellie (https://ellie-app.com/4hYqTYg44Pqa1/0). I do some long computation on mousemove, then 3s later remove the mousemove event. In theory, the third branch of the update function should never get triggerred.
It would look exactly like top level definition (except the indentation). 
If you want location data you can ask for that directly using navigator.geolocation.getCurrentPosition(function(position) {}) and just ask through a port. No need to get IP address unless you want it for something else. 
&gt;So... 192.168.0.6 will not be very useful to infer where I'm located. ;) Get out of my house!
Sure! You can use `Http.expectStringResponse` and handle the raw response yourself. Here is [the cats http example](https://ellie-app.com/4jqy6vM77wta1/0) modified to log the raw response (open the Console to see the raw response) 
I am always a lil concerned when a smart person seems to skip college... Obv no need to follow a cookie cutter life, but... (Another great ep as always!)
Excellent, thank you!
My site isn't https yet, so, according to Mozilla, it's not available
How would such a tool handle ambiguities?
If a file compiles, there are no ambiguities. If it doesn't compile, it is reasonable (as a tool) to request to make it compile (solve the ambiguities). 
Did you do this? And if so is it available somewhere?
Why not just expose them as you code?
It doesn't help that there are often types with a single constructor that is named the same as the data type, eg. type Ratio = Ratio Int Int In this case, the `Ratio` on the left hand side of the equals sign is the name of the type and the `Ratio` on the right hand side of the equals sign is the constructor. `Ratio 1 2` is an application of the `Ratio` constructor to the values `1` and `2` to get a value of the type `Ratio`. When you're new to ML style languages this can be confusing, but you get used to it quickly.
+1. I have this exact same issue. I basically want this structure: ... &lt;body&gt; &lt;main&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; And I need this structure, so I can use flexbox layouts for a sticky footer. To be more precise: For my flexbox layout footer to work, I need to set `display: flex` and other properties on the element surrounding my footer. The closest I can get is this css rule: body &gt; div { display: flex; ... } 
Laziness. I tried to do that, it takes some discipline to keep adding to that expanding list and refrain yourself from just replacing everything with `(..)`. 
Ha. I know. I tend to start with (..) and deal with conflicts as they come up which is the 1% case. Other times I simply fully qualify by adding the module name. It really depends on the module and the code that's using it. 
When the user interacts with your webpage it needs to generate events which update the model. These events are of type `Msg`. Having a parmeter here allows you to define the type of your messages. button [ onClick MyClickMsg ] [ text "Click Me" ]
&gt; What is Html Msg? [Html](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#Html) is a *parameterized type alias*. In plain English, `Html Msg` says here is some Html capable of producing "actions" of type `Msg`.
Thank you, that was very quick! I understand the application in your example and in the code I wrote. It's the theoretical concept and its implications I don't fully get. I figure it's all wired through Html.beginnerProgram and .program. But how does (Model -&gt; Html Msg) return both those things and return them separately? A function runs once and produces only one thing.
That gives a name to the idea, at least. But that implies that Html is the type alias there (which I understand is VirtualDom.Node), and Msg the parameter. In the source code, everything is Html Msg. How does one take the Msg of an Html Msg value? How does one take the Html of an Html Msg value?
It might be better to say that `Html Msg` is HTML which can produce messages of type `Msg`. We need to record the type of the messages being produced because what would happen if some `Html` produced messages of a type different from what the `update` knows how to handle?
That makes sense and I understand its purpose (telling Html.beginnerProgram what type to provide to update), it's just awkward to me. It looks similar to the type variable in for instance List a, but the effect (and the inner working?) is very different. Isn't it?
`Html` has a bit of magic behind it, so it isn't a great example, but I think that `Random.Generator` is close. Let's look at the [type definition](https://github.com/elm-lang/core/blob/master/src/Random.elm#L453). type Generator a = Generator (Seed -&gt; (a, Seed)) A `Generator` is really just a function which takes a `Seed` and produces an `(a, Seed)` tuple. The type `Generator` needs to document what that `a` is in order for the type system to ensure that whatever uses it will handle this value correctly.
&gt;How does one take the Msg of an Html Msg value? You don't. Your html emits Messages of type Msg which are caught by the runtime which feeds them to your update function.
I think I get it, though I'm not sure I care about the minimalist syntax. It's all just separated by spaces. In my mind, this is most similar to GenericList&lt;T&gt; as you would use in C#, which was easily explained and obviously implemented. What if I have a view that will not produce messages though? Returning Html is not an option, since all Html functions return Html Msg.
Got it. But that means that I cannot introduce a nested view from another module, as it will be returning its own kind of message. Unless I pass the Msg type to the Modulex.view function as a parameter... right?
Yep, In C# `Html Msg` would be spelt `Html&lt;Msg&gt;`. The `Html msg` type always needs a type for the messages that could be produced even if that particular html doesn't produce messages. Just like a list `[]` doesn't contain any values so it could be any type of list, but it still needs to be some type.
I'm basically going through the process of rubber-duck-debugging of the concept as I understand it in my head. Thank you guys for your patience!
They actually return `Html msg` where `msg` could be `a` or `typevariable` or whatever. It's just documentation to call it `msg`. div : List (Attribute msg) -&gt; List (Html msg) -&gt; Html msg If neither of the lists include elements which define what `msg` is, it remains undefined, which means this is `Html` that never generates messages. `text` is an example of a function which never sets the type of `msg`. text : String -&gt; Html msg I can't help you as far as syntax goes, those are battles not worth fighting, in my experience. As for `List` it has some compiler trickery, but conceptually it could be implemented something like type List a = Empty -- equivalent to: [] | Cons a (List a) -- equivalent to: a :: List a This gives us a singly-linked list, which is what Elm uses.
Thanks for asking this question, OP. I've just started learning Elm and while I think I get most of it, this was one of those loose ends for me too. And of course thanks to those who've responded to the question. 
It's probably important to point out that `Html msg` isn't a 'union type'. It's a 'parameterized type' AKA. a 'generic type'. Just like a `List a`, an `Array a`, a `Tree a`, a `Maybe a`. A Union type (aka. ADT aka. tagged union) is something different. https://en.wikipedia.org/wiki/Tagged_union
**Tagged union** In computer science, a tagged union, also called a variant, variant record, discriminated union, disjoint union, or sum type, is a data structure used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a tag field explicitly indicates which one is in use. It can be thought of as a type that has several "cases," each of which should be handled correctly when that type is manipulated. Like ordinary unions, tagged unions can save storage by overlapping storage areas for each type, since only one is in use at a time. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elm/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
If you had `List Int` and you need to return a `List Float` from your function, what would you do? The solution is the same for `Html msg` as it is for `List a`. You use the `List.map` function to convert between different types of lists and the `Html.map` function to convert between different types of html http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#map
&gt; My motivation is that I'm trying to learn how to nest views from separate modules, and how to handle messages of nested modules inside those modules while still having update : Msg -&gt; Model -&gt; Model do the work in each module. This happens from time to time. People come with an Object Oriented perspective and they reach for it by trying to split their app in "objects" or "components" and then compose them. Elm approaches things a little bit differently. Maybe [Elm Europe 2017 - Scaling Elm Apps](https://www.youtube.com/watch?v=DoA4Txr4GUs) presentation by Richard Feldman could help you get a better grip on how to grow a code base. &gt; What is Html Msg? `Html Msg` is a concrete type of the parametrized type `Html msg`. In `Html msg`, `msg`is the parameter. You can think about `Html` as being a box that can hold something, that something is labeled `msg` in the parametrized type description `Html msg` but in the case of `Html Msg` is an actual type. You can also think about `Html` as a function that takes a type and returns another type. If you understood `Maybe`, `Maybe a` is to `Maybe String` as `Html msg` is to `Html Msg`. In both cases `a` and `msg` are conventions. You can just as easily annotate your functions `Html action` or `Maybe contents` and it will work just the same. Lower case elements of type declarations are parameters and the actual name you chose for the parameter does not matter*. *- there are exceptions to this rule in the form or restricted parameters like `number` or `comparable` and `appendable`. If you chose one of these names, the types that are accepted need to conform to some constrains. e.g. if you chose `number`, you can only use `Int`and `Float`. 
Isn't whether a type is parameterized or not orthogonal to whether it is a union type? And isn't `Html` technically a union type with just a single tag? (Honestly asking, I don't know the answer to either). Edited: actually I just noticed someone mentioned below that `Html` is a type alias, so obviously not a union type, but then the thing that it's a type alias for (`VirtualDom.Node`) that I would've expected to be a "single tag union type"... I've found [where that's defined](https://github.com/evancz/virtual-dom/blob/master/src/VirtualDom.elm) and it kind of looks like I might be right except it also has no parameters so there must be more going on I guess.
Yes, technically all user defined types in Elm are 'union types'. But the OP's question doesn't involve this aspect of types and instead focuses entirely on the fact that the type has a type parameter, so I assume they are confused about what a 'union type' is. It's easy to see how one might think that `Html Msg` is a union of the types `Html` and `Msg` and thus confuse 'union types' with types that have parameters. The weird looking definition of `VirtualDom.Node` is because it's actually being implemented in JS. The type in Elm is just a placeholder for the more complex type defined in the JS. 
Thanks. I get why you explained it the way you did, I just wanted to check my understanding.
what do you mean by that?
what I found useful in understanding algebraic data types is simply thinking of them as + and * from maths: For example if I had 2 sets A and B (or String and Int for that matter) and I needed some type that holds information from BOTH sets then that would be a Cartesian product of A and B. In elm terms it would be a tuple of a A and B values **(A, B)**, or a record of A and B values **{ something: A, somethingElse: B)**. On the other hand if I needed a type that holds information from EITHER A or B I would have a union of A and B, something like summing them up. That would be a type that can have 2 values, either an A or a B, but not both like above. In pseudocode I would have **type Something = A | B** but when I have a function that has a signature like **Something -&gt; Int** how would I be able to implement it If I cannot do a case expression to check what **Something** is: f : Something -&gt; Int f x = case x of -- cannot put anything here because I cannot know what set does x come from. Is it from A or from B? So in order to be able to work with **Something** I also need to keep information about where are its values coming from: type Something = FromA A | FromB B and that is why it is called a tagged union, a Union of 2 sets but where we tag the values so that we can always tell from which set is the value from. And working with **Something** becomes clear: f : Something -&gt; Int f a = case a of FromA a -&gt; -- I know now this a is of A type (coming from set A) FromB b -&gt; -- And b is of type B Therefore a value of **Result String Int** would be of type **String** (and then it would be tagged with **Err**) OR of type **Int** and then they would be tagged with **Ok**. The major breakthrough for me was realising that **Result** is a type (a set) and **Ok** and **Err** are values of that type that carry some more information with them. Hope this helps.
Very well put, thank you. I am watching Scaling Elm Apps now. I did get the whole type parameter thing, the syntax threw me for a loop. It's all spaces everywhere!
I used a similar feature in Haskell that was provided by a compiler flag IIRC. It generated the complete set of `import` statements used by each file, limited to the set of actual symbols that were used: import Codec.Utils (i2osp) import Control.Monad.ST (ST(..)) import Data.Array.Base import Data.Array.ST (runSTArray, STUArray(..)) import Data.Bits ((.&amp;.), (.|.), complement, shiftL, xor) import Data.List (foldl') import Data.List.Split (chunksOf) import Data.Word (Word8, Word32, Word64) import Numeric (showHex) import Text.Bytedump (dump) I could then copy/paste the compiler output to the actual source code files.
When importing `Html`, for example, it is much easier to import `(..)` then go back and "fix" the imports to the set that I actually used.
I think there are a lot of great answers here. To just add a snippet from https://guide.elm-lang.org/ *One thing to notice is that our `view` function is producing a `Html Msg` value. This means that it is a chunk of HTML that can produce `Msg` values. And when you look at the definition, you see the `onClick` attributes are set to give out `Increment` and `Decrement` values. These will get fed directly into our `update` function, driving our whole app forward.* Additionally, you also mentioned: &gt; My motivation is that I'm trying to learn how to nest views from separate modules, and how to handle messages of nested modules You can accomplish this by using `Html.map` [http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#map](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#map) This enables you to write a view with a module-specific union type and convert it to the type that *beginnerProgram* or *program* expects (conventionally called `Msg`) 
&gt; I did get the whole type parameter thing, the syntax threw me for a loop. It's like a getting started flu. It should subside in about a week or two and then you will have full immunity. :) 
&gt; If you look at my KeyDown message, I set the code to be 111 (for testing). Elm is a pure language. This means that you cannot change a value, only create new values. `Model input ("sending" :: []) "112"` creates a new `Model` but it does nothing to the old model. You do not `set` anything, you create something new where one (or more) of the fields has a new value. `WebSocket.send "ws://localhost:3000/verify" verificationCode` is just using the `verificationCode` from the old model. the code should have been closer to: if key == 13 then let newModel = Model input ("sending" :: []) "112" in ( newModel , Cmd.batch [ WebSocket.send "ws://localhost:3000/ws" input , WebSocket.send "ws://localhost:3000/verify" newModel.verificationCode ] ) else if ...
Great thanks! Yeah, still having some issues with "elm thinking", but the experience has been great! Enjoy your weekend
Thank you. I understand the usage of unions now, it's just that it almost seems like, in the corner of my eye, that not all the information is there to make this work in all situations. It seems so loose, as if the mechanism by which this works is a dark force that operates in the shadows. I'm used to the hard and mechanical way by which imperative programming works! But thinking about it, all the information is there to make this work. It's the notation with spaces separating everything, and leaving out anything not strictly necessary (no decorations anywhere to guide your mind). It takes some time to understand the meaning of a cloud of words in a line.
I need to look into that. Thanks!
Awesome fix. (Still trying to learn elm)
I think nobody said what it really is so I'll say the "naughty words": It's a pointer/reference to a JavaScript object hidden behind the private JS-interop API Elm has that's used for internal parts. The JavaScript object behind it is the actual Virtual DOM backing your application, which is impossible to implement in native Elm since it does things such as referential comparison to perform the diffing efficiently.
Thanks. I stopped looking in the Elm Virtual Dom source code when it didn't immediately make sense to me what happened to Msg behind the screens. I think I have a grasp of the concept now though.
The source: https://github.com/Janiczek/foosball/ Not really mobile friendly, it's kind of one-off thing for our company "hackathon" and will be shown on a big TV :) PRs welcome though!
You have two options: 1. you return a Http Cmd from your `init` the way you can see in the [http cats example](https://ellie-app.com/cjFwV4xWra1/0). 2. you render the needed model data as JSON as part of the page render and feed it into the Elm app through the Flags. [Here is the same example with minimal modification to show this](https://ellie-app.com/cjFwV4xWra1/1). In this case, the information needed was just an url so the Flags were just a String. 
Great post, ChuckDuck22! I'll be looking forward to the one about phantom types which, oddly enough, is how I found this post via DDG.
&gt;How can a function (view) produce both Html and Msg? And not a the same time? What is this notation called and how does it work? It's not a tuple, Html is not exactly a type you're used to but rather a *higher-kinded type*. That means that `Html a` is not a type you can use, but `Html Msg` is - `Html` takes a type, and returns *another type*. 
It looks great, nice work! :D
Thanks a lot! :)
Love the design!
[Here](https://github.com/rails/webpacker/blob/master/docs/props.md) is an example how you can do that in Rails (Elm section at the bottom). Simply render your data within an element, parse it, and pass it down as flags.
I like these bite sized videos! It would just be great to have a better audio (less echo). Thanks for the videos! :)
I am working on it, I will probably be ordering a new mic soon
Just use a tie/clip on Mic and have your phone do the recording. Just clap your hands befor you begin and use that to sync the audio.
The right equipment can sometimes help, but it can't do magic. Try bringing the mic closer to your mouth, and turning down the sensitivity. You can also drape some blankets on the walls to reduce the echo. Also turn off the AC/fan when recording. You can remove some background noise with audacity, but the higher the level of noise, the more distorted and distracting the removal will be. Good sound is all about a good signal to noise ratio. A better mic will often just pick up more noise along with signal. I learned this producing my own videos.
echooooooooooooo
This looks like it would be a nice feature for `elm-format`.
You are assuming that there is no other data validation or transformation going on for one thing. But yes in the simple case it is a bit of boilerplate
Why runtime? Wouldn't it make more sense to do at compile time?
I guess you would want elm to "embed" the body tag inside the html document? ie after head? Then all items under body would be controlled by elm?
There is a use case scenario where the developer controls both ends of the pipeline and can handle JSON in whatever form needed. In these case, it would be a great benefit to be able to say that the JSON encoding/decoding follows the type declaration. A certain class of bugs (like forgetting to encode a certain field and having the server crash because it is written in a dynamic language like elixir) would disappear. In theory, this should be possible as it is already possible with the ports automatic decoders/encoders. I do not know why this does not exist. What I imagine is that other things took priority. I'm one of the people hoping to see sometime in the future a `serializable` pseudo-typeclass that would take care of this issue. :) 
Making improvements to a pretty complex admin app. It's in production for about 40 clients. This would be a nightmare in JS. 
This is why you'd use a code generator with Elm. Well.. one of several reasons. 
&gt;In these case, it would be a great benefit to be able to say that the JSON encoding/decoding follows the type declaration. You can do it if you use a code generator like cog but that's not as good as native support.
I guess I was thinking that the validation could be done at run-time via Java-like reflection. Though, I'm not saying that's the only/correct approach and it certainly _could potentially_ be done at compile-time. It's also possible that I'm just confused. :$
Interesting. I'd not heard of [Cog](https://github.com/boxed/elm-cog). (Link for anyone else who hasn't heard of it.)
I'd be curious to know what (you think) some others are.
You can also use the [elm-cog fork](https://github.com/boxed/elm-cog) or just steal its elm.py file. Look at the example file, it illustrates the decoders you wished for.
If you were to do that, you probably want compile time introspection instead of runtime. The API for runtime introspection would probably be so loaded with Maybe's or Results as to almost as/if not more verbose. Moreover, you are presuming an exact 1 to 1 mapping between your Elm data structure and the JSON encoding.
Enums (union type and a list of that union types members) is an obvious one I think. I'm starting to think about nesting apps/components but I've been very strongly encouraged to not do that so I'm gonna try real hard not to do that :)
Thanks for linking to my little project :P Just to clarify: Elm-Cog itself isn't a fork but some helper functions that plug into my Cog fork. The fork itself is really silly and just adds a very trivial command line option. 
Or maybe you want to generate your types based on a GraphQL schema.
It seems to me like one could express those other transformations separately anyway and that would be much nicer. 
&gt; Enums (union type and a list of that union types members) is an obvious one I think. Interesting. I've never bothered to consider this feature in the context of Elm or Haskell before. Unsurprisingly, it seems like there are more than a few ways to achieve this in Haskell. (`... deriving (Enum)`, the DeriveDataTypeable extension, etc.).
&gt; Shouldn't it be enough to say that you'd like to decode a Student, without having to explicitly state the fields and their types? Ideally, yes. However, this would raise a new issue, namely, what would be the type of `decode`? Either `decode` would have to be a primitive in the language (complicating the language over a domain-specific concern and ruining first-classhood of `decode` as a function) or else it would require some very fancy types. (You'd need a universe for Elm's record types and a primitive for reifying them. People like to play these sorts of games with dependently typed languages).
Good point. Personally I'd probably generate the graphQL schema and types from some other definition in the server side language. 
There's lots of food for thought here. Thanks for the reply! Are there any materials you'd suggest for someone interested in learning more about dependent types? The extent of my knowledge is a presentation I saw about Liquid Haskell at a conference a few years ago.
I don't really know of any good material. There are scattered papers online, but they aren't really easy reading. I would recommend trying out Idris or Agda, though. Benjamin Pierce also has a good free textbook online called Software Foundations which introduces Coq... which isn't as nice or as easy too learn, but could suffice.
Elm/Haskell E-Commerce Website! https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Finished up the initial Customer stuff. The "My Account" page leads to edit forms for login/contact details, so Irefactored existing form rendering code into it's own module &amp; used that: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/client/src/Views/HorizontalForm.elm Also added in the password reset pages as well as the first email-sending stuff on the server. Moved the remaining Views in Main &amp; to sub-modules. Refactored my API calls into a separate module, made an Endpoint type so I only have to specify URLs once, request methods, &amp; handling of the standard error response my server uses: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/client/src/Api.elm Now I'm starting on Carts. Got the DB models in as well as an add route for authorized users. Working on the add to cart forms now, then gonna move on to the Cart page &amp; add tax/shipping/coupons for that. Updated the old elm-decimal package to 0.18 so that I can turn my Cents &amp; Milligrams into dollars &amp; grams: http://package.elm-lang.org/packages/prikhi/decimal/latest 
I might just misunderstand what this is supposed to do, it seems I often accidentally delete the task at hand by pushing the + button or other ones. It's really cool to see a PWA in Elm though, this is awesome. 
Finishing schema builder demo for https://github.com/1602/elm-json-schema First draft of the demo has already been deployed to gh pages last week: https://1602.github.io/elm-json-schema/
Thanks for the feedback. You are absolutely right, the creation process is confusing. The thing is that right now, the + button adds a new job to the queue, which then you can edit to set the right title. The queue is mnavigated using Yield/Skip. This is a fast UX when you know the behaviour, but a confusing one if you don't. I'm going to add a confirmation button when adding jobs, to correct this .
Great!
Use [Http.getString](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http#getString). :) These kind of questions are better served by the #beginners channel of [Elm slac](http://elmlang.herokuapp.com/)k. 
Is it that you want to display the string, or you are just wanting to use the JSON for some other purpose, like sending it to a server or through a port?
Fyi - got that setup, and working almost immediately. Haven't done any stress testing on it yet though (reconnect, going offline, etc). API was super friendly w/ good docs.
&gt; I'm sure there must be a flag for it? There isn't, yet. There are some optimizations in the Elm compiler but not all the optimizations that you can think of. Elm is a pure language and it could benefit tremendously from various optimizations like [compile time function execution](https://en.wikipedia.org/wiki/Compile_time_function_execution). These optimizations will probably end up in the language at one point. Until then, I'm afraid that "profile it and benchmark it first" is what you need to do. If you benchmark and identify certain parts of your code that are performing poorly, you can come to the community and request assistance with a concrete case. There are a lot of helpful members who will be glad to take a look over your code and suggest improvements. Don't worry about stuff that you see in the outputted JS. Some of that is optimized by the JS JIT compiler anyways. 
**Compile time function execution** Compile-time function execution (or compile time function evaluation, or general constant expressions) is the ability of a compiler, that would normally compile a function to machine code and execute it at run time, to execute the function at compile time. This is possible if the arguments to the function are known at compile time, and the function does not make any reference to or attempt to modify any global state (is a pure function). If the value of only some of the arguments are known, the compiler may still be able to perform some level of compile-time function execution (partial evaluation), possibly producing more optimized code than if no arguments were known. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elm/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
&gt; There isn't, yet. Good to know I wasn't missing anything (such as bleeding-edge stuff not yet documented or so) &gt; Elm is a pure language and it could benefit tremendously from various optimizations like compile time function execution. These optimizations will probably end up in the language at one point. Will be happy to take a stab at it when the time comes and nothing has materialized by then &gt; Don't worry about stuff that you see in the outputted JS. Some of that is optimized by the JS JIT compiler anyways Sure.. at load time.. "ideally-ultimately" of course I'll want to "offline" some of the effort. But yeah, I know =) was just checking!
I want to send it in a file that downloads via the browser on client side 
Seeing as different browsers might execute things slightly differently than what a pure language like Elm would expect, I suspect this is a more difficult and dangerous task than one might think at first glance.
Say you have List of Maybe Int and you want to turn it into a List of Int in very simple way. If there is Just Int put the value into the new list. If there is Nothing put zero (or any other given constant). I can do this by applying List.map with function which has cases for Just and Nothing. But it is pretty lengthy. Is there a more simple way to turn Maybe a to a? Thanks!
If I recall correctly, some of the efforts of 0.19 was to put lots of optimiser comment annotations for uglify and closure. If you tell them that some things can't happen, they optimise much more aggressively So you should get some of what you are wishing for.
That's great! Hard to give general suggestions, but I think you are right about focusing on something the students would be interested in. I like that example you gave. Perhaps given their experience with Python you could ask them how they would model the same thing in Python. Start with what they know. Given it's a club and not a class, it seems like the main thing would be to get people confident enough with the concepts and syntax that they can propose their own ideas to work on and help each other with. Maybe you'd want to spend a little time introducing a new concept each session and then they could try it out on their own or in pairs the remainder of the time. Tools that give quick feedback like http://elm-lang.org/try and https://ellie-app.com would be useful, obviously. You may find that there are other students with some experience with Elm or functional programming, perhaps you can bounce ideas off each other. Anyway, just throwing out some ideas. There are other folks with a lot more experience than me teaching Elm basics, including to teenagers. Are you on the Elm Slack? There is a #teaching channel, I think you may get some useful feedback there. Good luck! It would be great to hear updates from you about how it's going. 
 List.map (Maybe.withDefault 0) listOfMaybeInts
Might have some success with https://prepack.io/ EDIT: https://i.imgur.com/BXad8Z3.png - yeah it does something :)
Very cool, noted =)
I tend to be cautious when hiding `Nothing`s in this way. After all, the reason `Maybe` exists is to force explicit treatment of empty values. If you genuinely want empty values to become 0s (or any other constant), `Maybe.withDefault` works well. But often you may wish to exclude the `Nothing`s entirely. In which case `List.filterMap` does the job nicely: myList = [ Just 1, Just 2, Nothing, Just 3 ] cleanList = myList |&gt; List.filterMap identity (`filterMap` excludes the `Nothing`s and strips the `Just`, while `identity` ensures the remaining values are left as is, making `cleanList == [1,2,3]`) You can also apply this to idea to `Result`s by mapping them to `Maybe`s and filtering: numbersText = [ "1", "2", "three", "4" ] numbers = numbersText |&gt; List.map String.toInt |&gt; List.map Result.toMaybe |&gt; List.filterMap identity which makes `numbers == [1,2,4]` If you like to make your code compact, you could create a single function using 'point-free' notation to do the conversion of the list of strings to a list of valid integers: toInts : List String -&gt; List Int toInts = List.map (String.toInt &gt;&gt; Result.toMaybe) &gt;&gt; List.filterMap identity which further reduces to toInts : List String -&gt; List Int toInts = List.filterMap (String.toInt &gt;&gt; Result.toMaybe)
Oh been there too with the wiring and boilerplate! I'm gonna try it out - what does "id" mean in leading : Time -&gt; Id -&gt; msg -&gt; Cmd msg ?
I get it now. If you are using the Throttle functions in two (or more) places in your application, you may be ignoring the throttled input from place one if you start inputting stuff in place two before the first one fires. As long as each place has an id - they won't be competing. Right?
&gt;Elm is a pure language and it could benefit tremendously from various optimizations like [compile time function execution](https://en.wikipedia.org/wiki/Compile_time_function_execution). These optimizations will probably end up in the language at one point. It might not be of great use, at least according to the architects of clojurescript. They claim that JavaScript optimisers are so good that this would be very premature optimization and the best thing to do is to output optimiser friendly code and let it do its job.
**Compile time function execution** Compile-time function execution (or compile time function evaluation, or general constant expressions) is the ability of a compiler, that would normally compile a function to machine code and execute it at run time, to execute the function at compile time. This is possible if the arguments to the function are known at compile time, and the function does not make any reference to or attempt to modify any global state (is a pure function). If the value of only some of the arguments are known, the compiler may still be able to perform some level of compile-time function execution (partial evaluation), possibly producing more optimized code than if no arguments were known. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elm/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
It's promising but to alpha right now. When the medium term goals are achieved it will probably be pretty good.
The immediate thing to think about is what problem you're solving :) So, what pain is this actually addressing? Another way to think about it is "does this actually lead to nicely organized, readable code?" It's really easy to introduce features into a language that seem nice initially but lead to weird situations farther down the line. The idea of setters has been brought up before, I'm sure there's something on elm-discuss about it. You might look there to see what people have talked about before! 
Well I know that manually writing a bunch of setters isnâ€™t really useful. I mean, itâ€™s pretty obvious from anyone who has ever seen Java code ;) The problem Iâ€™m trying to solve is to no copy paste lots of boilerplate. The â€œ.fooâ€ syntax helps a bit but without its mirror and being able to convert to the mirror itâ€™s not that useful for higher order functions. 
The problem is that programmatic setters sorta point at organizing your code in a highly nested manner, which isn't necessarily a good idea. As far as I see it, there's only additional boilerplate if you're using nested data, otherwise I'm pretty sure the current syntax and having a setter function for a field would be roughly equivalent. Somewhat related, but I highly recommend checking out [Richard Feldman's Talk on code organization from Elm Europe](https://www.youtube.com/watch?v=DoA4Txr4GUs) which has some excellent advice.
Converting a getter to a setter is not possible. They are both functions, and the only thing you can do with functions is call them or pass them as arguments, there's no way to introspect. How would you know if the argument you gave was actually a setter? Additionally, what would the type of toSetter and toGetter be? As for setter notation, that's totally possible, and would be really nice, but it hasn't been a priority I guess.
Hopefully soon, given all the work that's been done on the browser package which [depends on v0.19](https://github.com/elm-lang/browser/blob/master/elm.json#L11)! I too would like to know. I've convinced my coworker to use Elm for a new project, just waiting for the right time to get started, and the Elm v0.19 release would be a good excuse to start the project :)
What do you mean â€œnot possibleâ€? Itâ€™s obviously computationally possible. And also obviously itâ€™s not possible now as Iâ€™m talking about something that I explicitly said up front doesnâ€™t exist. &gt; [what would the type be]? I donâ€™t see how that is a reasonable question to ask? It would be the type of one -&gt; the other. 
&gt; highly nested Sure, thatâ€™s what I have now. I disagree with the sentiment that the language should make that so very terrible. That just outright makes SPAs horrible in Elm which seems like a bad idea. &gt; boilerplate if youâ€™re using nested data Maybe but Iâ€™ve yet to hear a compelling alternative. Iâ€™ve seen the talk and I donâ€™t think it addressed this question. For some cases absolutely but not in the general case. Iâ€™m planning to rewatch it though. I also found https://medium.com/elm-shorts/a-reusable-dropdown-in-elm-part-2-9659ef988441?source=emailShare-8ad86cc82e5f-1505817722 which sounded good but as far as I can tell, again, only addresses part of the issue. 
I suppose my experience is different then because I've found SPAs in elm to be great :) The trick is that the intuition and best practices that may apply in something like java don't necessarily apply to elm. I would also argue that a language that pushes you towards nice solutions is great! The point of the talk is to not simply stamp out nested "components", but to limit scope and separate concerns by narrowing your functions instead. That's actually a fascinating thought that I found very compelling.
So how would you deal with having say 10 pages that you now want to turn into one Elm app? &gt; pushes you towards nice solutions is great! Sure. If it did, which I donâ€™t believe in for this specific issue. &gt; narrowing functions instead Thatâ€™s all fine and good when possible or when it makes sense. But sometimes itâ€™s not or doesnâ€™t. 
Huh, so why do they still use google closure?
Just start. Since the removal of Effects, upgrade has been straightforward and even partly automated. 
Can you give some examples of code that this would simplify? That might clarify things. As for the possibility: 1. Are `toSetter` and `toGetter` functions, or built in syntax? If they're functions, then they don't work, because you'd need a *single* type for `toSetter`. And what would that look like? It would have to be something like: `toSetter: {fieldName : x}` where fieldName is somehow a variable, which Elm currently doesn't allow. You could certainly write a type for a flipper for a specific field: `toSetterPartyGroup : ({party_group: t | r} -&gt; t) -&gt; {party_group: t | r} -&gt; t -&gt; {party_group: t | r}` but you'd need a different type for every possible record field in your program, *and* it would be impossible to implement this for the reasons in (2) below. The problem here is that the type of a getter is different for each possible field name. There's no single generic type that captures all getters, or all setters. Again, you could avoid the type issues if you made them built in syntax instead of functions, but there's still no way to implement them. 2. You say: &gt; Itâ€™s obviously computationally possible If it's obvious, describe how to do it. Yes, it is computationally possible to turn *the literal* `.party_group` into `!party_group` and vice-versa. But what's the point of that? When would you ever possibly want to use `getSetter .party_group` when you could just use `!party_group`? The only use I can see for such a function is if it works on times when you have a variable. Something like this: type alias Vec = {x : Float, y : Float} f someBool = let get = if someBool then .x else .y set = toSetter get The problem is, now `get` is a variable, and at runtime we don't know if it's .x or .y. But .x and .y are functions, and there's no way to compare arbitrary functions, for a few reasons: * Elm currently doesn't let you compare functions, see [this example](https://ellie-app.com/J8hyWz6Pa1/0) * There's a theorem that says in any programming language, there's no way to turn a function back into its syntax tree at runtime. You *could* do this with some kind of reflection, but that would require carrying around the AST for *every function* in the whole program, which would be massively inefficient. Then, on top of this, what are the semantics if what you give it isn't a getter? What is `toSetter (\r -&gt; 1 + .party_group r)`? The function has the *exact same type* as .party_group, but it's clearly not a getter. So what is its setter? Is this a runtime error? Or are there some other semantics? 
I understand that people follow my work quite closely (it is actually quite uncomfortable for me!) and are excited about the ongoing projects. That said, **I want to present my work on my own terms.** I am doing my best to make a great release and to do it efficiently. It would be extraordinarily sad if I worked this hard for so long only to have the broader community learn about the details through weird speculative stalking of commits. The way all these pieces fit together is the cool part, and it 100% is not recorded in the commit log, so I really hope folks will have patience and let me present the work when it is ready and in a good way. Until then, I think speculating on things is not a positive thing. It distracts people from their work. It puts additional pressure on me to rush things, which no one _actually_ wants. So again, **please let me present my work on my own terms**! I think it'll work much better for the whole community!
It's worth mentioning that this is very much the Elm-specific philosophy on how to do things. The setters that /u/kankyo describes are basically a lead-in to [Lenses in Haskell](https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html).
I'd follow the [elm spa example](https://github.com/rtfeldman/elm-spa-example) if I wanted 10 pages in an elm app. I've found that narrowing your functions is usually more possible than is immediately obvious. It's also a great way to guide your thinking when writing new functions.
That example is a good case of what I'm talking about. It's full of copy paste code that is trivial to machine generate. 
&gt; Can you give some examples of code that this would simplify? That might clarify things. https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L440 &gt; 1. Are toSetter and toGetter functions, or built in syntax? Built in syntax obviously. If they could be functions I could have built them myself and not suggested them as a feature of the language. &gt; Again, you could avoid the type issues if you made them built in syntax instead of functions, but there's still no way to implement them. What do you mean "no way to implement them"? The compiler could literally dump out the getter to a string, do a trivial regex transformation and then compile the result. &gt; If it's obvious, describe how to do it. To be concrete: if the operator "toSetter" is used, take the AST of the function argument and dump it to text. You'd get something like (\x -&gt; x.foo) then use a tiny bit of regex magic: https://regex101.com/r/5h4EdP/1 Then you get a string that you can compile. The toGetter case is pretty much the exact same thing, but in reverse obviously. I'll leave that as en exercise for the reader :P &gt; There's a theorem that says in any programming language, there's no way to turn a function back into its syntax tree at runtime. I'm talking about compile time...
&gt; I'm talking about compile time... Ahh, that makes a *huge* difference. Sorry for the confusion! What you're talking about is basically a macro, or at least some kind of syntactic sugar. This is definitely possible! But I suspect that, unless you are only using it on the literal `.party_group` or whatever, you'd probably get a type error when you just flipped them in any larger expression, since getters and setters have different types.
That is their strategy. Output closure friendly code, let closure do its job. As opposed to optimising the js code directly.
It's boilerplate in the simple examples, but in my experience, domain models rarely map 1:1 with the JSON coming over the wire. Even in Java where every JSON library comes with a feature that uses reflection to build classes from JSON, I prefer to explicitly map JSON &lt;-&gt; domain models. I even ported Elm's JSON decoder to Kotlin: https://github.com/danneu/kotlin-json-combinator ## Advantages: - Specify errors directly in the decoder - Specify transformations directly in the encoder and decoder - Each domain model may potential need multiple encoders/decoders to different APIs or different versions an API ## Disadvantages: - Boilerplate - Learning curve Elm itself tends to err on the side of explicitness + boilerplate in general, and as I get more and more experienced with Elm, I tend to agree with those trade-offs. 
Iâ€™m confused. Wasnâ€™t your previous comment that js optimization is isnâ€™t needed at all?
It's not needed by the clojurescript compiler itself because the google closure compiler does such a good job that optimising at the cljs-&gt;js stage would be wasted dev efforts.
&gt; What you're talking about is basically a macro, or at least some kind of syntactic sugar. Sure, just like ".foo" is already. &gt; This is definitely possible! But I suspect that, unless you are only using it on the literal .party_group or whatever, you'd probably get a type error when you just flipped them in any larger expression, since getters and setters have different types. Sure, you'd only be able to do it in some special cases since if you passed around the function and the compiler can't figure out exactly where you came from, it can't know exactly which function it was. Hmm.. yea, maybe this would require having to statically inline the method, which, as you hint at, is basically a macro. Ok, how about a modification to my idea: instead of toGetter/toSetter which would suck without full blown macros.. how about just ".!foo" (or whatever) that would produce a tuple of (.foo, !foo) :P Then you pass that around like normal functions. 
Ah, now I see what you meant. I read "javascript optimizers" as "javascript optimizers in browsers", but you meant "javascript optimizers like google closure". Gotcha. Thanks for clarifying.
&gt; depends on v0.19 I see your point, just please avoid exclamation marks while stating twice in a row *[let me/I want] present my work on my own terms*. It really sounds bossy and unfriendly, and I'm sure that *you are not that kind of person*. The Internet is a free space and curiosity is mandatory for good developers. Continue your work and take the time you need: we'll discuss freely as it has been done for decades before Elm.
I think the same holds true for Elm. When prepack will be out of alpha we will have our compile time function execution. Closure is terrific, if Elm 0.19 emits code that works with the advanced mode it will reduce the output quite a bit. And doing the optimisations before takes Evan's time and probably would make the compiler more complex which means even more of Evan's time in the long run. As long as we're properly taking advantage of the purity annotations the minifying tools should do a great job.
Yeah, that'd be nice. Performance definitely comes into the equation when you're supporting older mobile devices, especially if your app has any sort of real-time component. I've been reluctant to use Elm in those cases because I don't want to figure out down the road that something like immutable datastructure garbage is causing unforgiving GC pauses for older phones. It takes some thought just to avoid allocation in Javascript. I think this is just going to be something Elm and its ecosystem will improve as it matures and more people are working on performance-sensitive applications.
&gt;Until then, I think speculating on things is not a positive thing. I think that having no idea at all of when things are coming out encourages speculation. If people had a very rough idea (early work, about halfway done, final stretch, polishing for release, whatever) they would have less of a reflex of stalking commits trying to find if the release is next week or next year.
Glad to hear it!
I definitely understand that. I tried to address this with [this document](https://github.com/elm-lang/projects/blob/master/roadmap.md). I know not everyone agrees with how I do this, but I think this approach produces the best quality and has the lowest cost for the community overall. It's complex and I see how other people would think other things. I'm just making a personal request to the community to not get too into speculation.
It does address the high level view of what the release is about but we are still wondering if you are still exploring or converging.
Yeah I think I will, I'm also learning that it's easy (or seems easy) to embed an Elm app inside a larger JavaScript app, which would make our Angular codebase a lot less frustrating :)
Converging. It's not a simple binary switch that you flip one day though. As you refine a design, you learn how it fits together. That can in turn require you to revisit "completed" designs to make them fit together nicely.
Ain't that the process of anything written *in* Elm? :)
Anyone have a transcript?
&gt; Elm is a pure language and it could benefit tremendously from various optimizations like compile time function execution. By the by, just occurred to me this becomes even more profoundly the case once one devises eDSLs / sub-languages via ADTs + evaluator-interpreter-transformers =) ^(to anyone who played in pure-FP for a while, this becomes easily second nature as the code-base / spec grows in complexity, in the Elm context will become particularly handy for highly-user-tweakable UI views etc)