you should read also the comments about that episode
why?
Yeah. That's 3 seconds per year of downtime. Right.
You fail at arithmetic, it's 31 milliseconds of downtime per year, 3 seconds would be seven nines.
You are correct. I fail.
Why not? If you define "downtime" to be any period where a customer can't perform some function, and it's never happened, isn't that 100% uptime (so far)? That is, if I have a cluster of ten machines, and maybe they fail constantly, but at no time are *all* of them down, and at no time is a customer able to tell that one is down, isn't that 100% uptime?
why?
cough *CouchDB* cough...
As the author of said article -- the point was to illustrate how to use OTP in a useful way with minimum overhead. I'm not seriously advocating anyone to use the example code for anything else except learning.
Having been tinkering around with Erlang for about a month now, I've been looking for an Open Source erlang-based project to contribute to, but haven't found many. Any thoughts? Suggestions?
The CouchDB folks seem pretty approachable. I'm working on virtuerl -- a wrapper for part of Amazon's web services -- which could always use some help. The MochiAd guys have mochiweb and then there's always erlyweb. I guess it depends on what you're interested in.
&gt; The Dryverl Project Is it me, or do erlang projects have really terrible names? :)
most of them match with this regex [A-Z]?[a-z]*erl[a-z]* 
Because it's not possible to take failing machine out of cluster in 31ms (if we're talking about normal server hardware) If erlang process fails on one machine you need to wait at least 1 network communiaction timeout, which shouldn't be less than 2\*rtt to monitoring machine + 2\*avg. processing time. Also you're probably monitoring with max frequency of 100ms. Then there's time for distributing information about failed node and time for updating routing. In other words - good luck if you even want to detect a problem in less than 50ms. Then what if machine which failed was already processing some data? What if that was border router/switch? Even VRRP won't save you here with default settings ((3*1s)+skew - that's 4s max, 3s min). I'd be amazed to ever see 4 nines in real life...
Thank goodness. There is a total lack of quality webby frameworks for Erlang
Looks interesting but I don't have teh moooonnnnaaayyyyy!!!!
&gt; In fact, Twoorl right now wouldn’t scale well at all since I prioritized simplicity above all else. Not that the erlang approach doesn't offer better potential scalability, but...
Choas, your title is disingenuous--yariv did not present his project as a full-scale replacement for twitter.
&gt; Many people written about Twitter’s scalability problems and how to solve them. You're right, I misinterpreted this sentence.
Better see http://www.nabble.com/Twoorl%3A-an-open-source-Twitter-clone-td17527792.htm - a lot of good hints - no db backend, rabbitmq (messaging) etc.
Unless you already need a Makefile to integrate other stuff, i highly recommend you look at "sinan" for building erlang applications. (see http://erlware.org ) It builds, but it also is integrated with eunit so unit testing is a no-brainer; it automatically generates code coverage files from the unit test runs. It also has tasks for converting the inline docs to html, and running dialyzer (static analysis).
people who haven't bothered to learn erlang shouldn't be having "thoughts about the erlang runtime". right or wrong, this guy is essentially pulling shit out of his ass.
Yes, but i was too polite to say it in that way.
politeness on the internet?!? inconceivable! ;) and i guess i was upset after reading this post, i think it's like the 100th or something in the last year talking about erlang, positive or negative, from the standpoint of someone who didn't know anything about erlang, but goes off on why it's great, or why it sucks, or why their pet project XXXX, which happens to be vaporware, is so much better than erlang. If it were someone who had taken the time to *REALLY* learn erlang, write code apps (and libraries!) in it, and then said "i've done X,Y Z in erlang. here's what i think" , i'd have taken it *MUCH* more seriously, and given it due consideration. but this article? sigh. COME ON PEOPLE! you CAN DO SO MUCH BETTER!
aw man, I was hoping it would be narrated by ViewAskew's Kevin Smith.
Please stop posting stuff like this. This is 100 words, a graph, and that's it. This is no benchmark. What are the parameters? What type of machine? What does the results mean? Hell, where is the code used to benchmark these two platforms? Please, people, use some common sense when posting stuff on reddit. Editted: Ok, he (the blogger) got the graphic from the presentation on the Kilim website, but it really doesn't answer any of the other important stuff.
Is this supposed to scale like commercial RDBMSs?
Or you could just use $whatever-language and MPI.
The author needs to learn a bit of English.
*gasp* If that is true it would mean the multicore crisis was solved back in the 90's. No, I refuse to believe the Scala and Erlang fanboys have been yanking our chain all this time.
Does anyone have any more information about this port and QDBM? What are the advantages and disadvantages of using this type of database technique? engine? storage-algorithm? (Not sure what to call this.)
I have been playing with tcerl for a bit and it appears to be an interesting alternative to dets. It is ordered-set only at the moment but this is not a major problem. The benefits to an erlang user is that this gets around the 2GB dets file limit, it has better performance characteristics for large data sets, it does not have the unpleasant rescan/rebuild issues if you have a dirty shutdown (although the safedets module can be used to avoid this issue), and it seems reasonably fast. The downsides are that it is not as easy to use as dets and the tcerl build system requires you to install another build system framework if you are not doing a linux install. I don't know how tokyocabinet compares to berkeley db and other similar engines, but getting bdb integreated into erlang is a real PITA compares to this option. The recently-released mnesiax bits also provide the option to use this as a persistence engine for mnesia, which may end up being a very big win...
Computers can be faster, by utilizing multi-core - but which applications *need* that extra speed? Historically, most of Moore's law's performance was not delivered to users, but used up by developers. It has gone into making development faster and easier (by freeing up the effort programmer's had to spend to get adequate performance). Assuming *ease-of-development* is the driver, then if the switch to multi-core requires *more effort* from developers, it simply can't happen. The paradigm switch has to be *easier* for programmers than what they do now (it's not) - or the switch has to have some other *overwhelming* benefit. For example, enabling an application to be faster that desperately needs to be faster (which I argue doesn't exist, today...). 
Thanks for the response.
Do you know of any performance comparisons of Tokyo Cabinet? I am seeing a lot of spontaneous buzz about it, and I haven't yet seen anything quantified. I'm eager for more Erlang storage backends..
DTrace on erlang? I'll... I'll be in my bunk. 
The article says that Erlang doesn't share memory between processes, it passes messages instead. The article gives two reasons for Erlang *also* having immutable data structures: 1. it enables the same type semantics for calling a function in another process, and for calling a function in the same process. 2. it enables efficiency gains. I'm just learning Erlang at the moment, but these reasons don't seem compelling to me. *EDIT* I think there must be other reasons, otherwise message passing between imperative modules seems to have the same key strengths...
&gt; The article says that Erlang doesn't share memory between processes, it passes messages instead. In fact these are the same thing. I think the author tries to say that Erlang on the conceptual level doesn't share memory but everything that is passed between the processes is done via the specified interface of "messages". Passed messages on the implementation level are just pointers to a shared memory. Because it's immutable it can be shared very easily and processes can't hurt each other. Also because everything is immutable, lists (and trees and so on) can use the tail part of the existing data structure.
&gt; Passed messages on the implementation level are just pointers to a shared memory. Because it's immutable it can be shared very easily and processes can't hurt each other. This is not actually true; processes have independent heaps and are independently garbage-collected (this is important for Erlang's soft-real-time properties). There are experimental builds of the VM with a so-called "hybrid heap" but they have yet to show significant performance benefits.
pretty decent ideas in the paper, first class mailboxes, mini-language. if they were speced out a bit more i encourage him to submit them as EEPs
This was new to me, thanks for the info. I have always been in impression that when processes are in the same VM, the messages are not copied but passed as reference (I think I read some Wigers post that talked about this?).
&gt; I have always been in impression that when processes are in the same VM, the messages are not copied but passed as reference (I think I read some Wigers post that talked about this?). He probably said it would potentially be possible, but as far as I know only big binaries are shared between processes right now.
doesn't really say anything new. This is a blogpost written solely for the sake of posting to his blog, imnsho 
Armstrong's [A History of Erlang](http://www.cs.chalmers.se/Cs/Grundutb/Kurser/ppxt/HT2007/general/languages/armstrong-erlang_history.pdf) (pdf) says that: - immutable data structures prevent processes from corrupting each other's memory - message passing ensures each process has its own copy, even if the sending process later fails --- Supporting quotes (both from page 6-2, right hand column): &gt; 1. One problem to be solved in any system having very large numbers of processes is how to protect the processes from **memory corruption problems**. In a language with pointers, processes are protected from each other using memory management hardware and the granularity of the page tables sets a lower limit to the memory size of a process. Erlang has no pointers and uses a garbage collectible memory, which means that it is impossible for any process to corrupt the memory of another process. It also means that the memory requirements for an individual process can be very small and that all memory for all processes can be in the same address space without needing memory protection hardware. &gt; 2. ...the failure of a process or of hardware should only influence the immediate transaction involved and that all other operations in the machine should progress as if no failures had occurred. An immediate consequence of this on the Erlang design was to forbid dangling pointers between different processes. Message passing had to be implemented by **copying message buffers** between the memory spaces of the different processes involved and not by passing pointers to a common memory pool. At an early stage we rejected any ideas of sharing resources between processes because of the difficulties of error handling. In many circumstances, error recovery is impossible if part of the data needed to perform the error recovery is located on a remote machine and if that remote machine has crashed. To avoid this situation and to simplify the process, we decided that all processes must always have enough local information to carry on running if something fails in another part of the system. Programming with mutexes and shared resources was just too difficult to get right in a distributed system when errors occurred. 
via: http://www.nabble.com/ANNOUNCE%3A-logger-for-erlang%3A-Log4erl-tp18182624p18182624.html
My problem with learning Erlang is that the OOP stuff just pops out naturally in my mind. I have to clear my head a a great deal to get in the Erlang flow. The article certainly has valuable insights into getting into that Erlang perspective.
While it's true that * The hype is atrocious * it's largely backed up by false understandings of the language and libraries (which leads to bad exchanges on the mailing lists) * it's largely fed by false information in the first place (e.g. that Google is using it or that IMDB has "switched"), this is *still* a terrible article: &gt; Ah in the end I only wish for some more functions in Java So it could have just read "Erlang looks new, and I'm looking for reasons to hate it." Uh, thanks?
I like to see languages get hyped. It's part of a healthy cycle where the community sees languages or frameworks grow. Something gets hyped up and then fades away quickly--just part of the natural selection. Those that remain become mainstream and form solid communities that support economies, among other things.
Not only that, but as is often the case he seems to have a fundamental misunderstanding about the way the the two virtual machines differ.
I bought these the other day. I'd highly recommend them to anyone wanting to learn erlang. The pragmatic screencasts are the best I've seen. It sounds like I've been paid to say this.
via: http://www.nabble.com/compile-error-with-bits-unit-syntax-td18522424.html#a18522424
that's freaking epic. I was just proud to get it working under wine. 
This is one of the best comparisons between imperative languages and the functional ones. Period.
It's pretty terrible Erlang code, however.
I think erlang has real potential to be the next "big" language, in the ruby sense. Still awaiting the killer app to bring it to the mainstream though. I'm not so sure about scalaris. 
submitted twice in different subreddits because no tag system (nothing to do with karma!). There are more comments on the other submission: http://www.reddit.com/info/6sqka/comments/ 
I've always pictured SAX as a building block for a DOM parser. Am I correct in thinking that you would typically build a DOM parser on top of a SAX parser (perhaps stripping out the parts of SAX that you don't use)?
that's often ohw it's done yes, sax is essentially stateless, and you build a stateful dom parser on top of it :) that's sorta what i had to do at my previous job. though i only wanted a handful of info so i wrote a minimal pseudo-dom parser :) 
via: http://www.nabble.com/scalaris-code-posted-td18620830.html#a18620830 
I like how the author presents, as an example of tail recursion, a function that is not tail recursive. He desperately needs a clue.
i don't think that code is valid erlang either. 
Indeed, the first clause should be square([H|T]) -&gt; [H*H|square(T)]; the brackets are missing.
Discussed here: http://www.nabble.com/Copy-of-mnesia-tables-from-a-node-to-a-another-node-without-linkage-tp18660448p18660448.html
17 chapters in two weeks. That was fast.
I really want to see Scalaris' distributed structure and PubSub with CouchDB's view system bolted on top.
Charging for screencasts... interesting idea.
Not again! Sigh!
This is a stupid blog post. Could be written in two sentences: "Ok, start with sudo port install erlang and than go to that other blog and do the stuff he said. Works great for me!"
Interesting indeed. Not very technical and nice to hear about erlang.
Did he enable link-time optimization with -O4? That's really the big win for LLVM.
panic i compiled with same flags so -O2, but when i tried building something with llvm-gccc -O4 it fails to build anything even the test program from configure, all other -O3, -O5 etc seem to work. this is with debian testing llvm-gcc
upgraded to llvm2.3~1 in debian experimental and still have same problem, you sure that is supposed to work panic?
via: http://www.salientblue.com/blog/?p=42
via: http://www.salientblue.com/blog/?p=40
via: http://www.salientblue.com/blog/?p=33
via: http://www.salientblue.com/blog/?p=36
via: http://www.salientblue.com/blog/?p=47
via: http://www.nabble.com/%22Design-patterns%22-for-functional-languages--td18826616.html#a18859955
&gt; This line will be replaced by dynamic content. hehe. EDIT: Can somebody explain why an empty web page gets so many up votes? 
i fucking hope so :) 
Yeah, look, this stuff is from mid-2007 and SlideAware has since exited from the startup stage, so to speak. Check out the message on http://www.slideaware.com/index.html: May 1, 2008 Dear Slideaware user: Thank you for your interest in our service. We've decided to shift our business to focus on larger deployments of our service. In preparation for this shift, we are discontinuing our service effective May 15, 2008. Until May 15, 2008 you can continue to use the service, however we suggest you use this time to remove any materials or content you have uploaded and to identify a replacement service. If you were a subscriber to our paid service, you will be refunded for any amounts pre-paid for May 1, 2008 forward. When we discontinue our service, all the information and content you have provided us, including your user name will be permanently deleted. We thank you for your support and apologize for any inconvenience. Sincerely, The Slideaware Team 
They were using SQlite as a backend db. Database with 0 concurrency (on writes it locks the whole db) and then suddenly they decided to jump to Erlang? If they need to scale, why not just change the db?
Using list\_to\_atom/1 this way could be dangerous: http://www.erlang.org/doc/efficiency_guide/commoncaveats.html#3.3 **DON'T USE THE WEBSERVICE EXAMPLE!** 
Oh neat. Sunnyvale, huh? Free Food?
I've always imagined Mnesia is an extension (built on top of ETS) to do all the things you would program on top of ETS to manage the tables, writing to disk, etc. etc. With that in mind, I am not surprised that Mnesia worked for the writer "out of the box" whereas ETS required extra work. Am I wrong?
Mnesia is not really an extension to ETS. ETS is more a part of Mnesia. That is. The whole reason for writing ETS was to write Mnesia.
Weird, I come at the two the opposite way. I always found ets really intuitive, and consider Mnesia kind of an overly-elaborate scaffold shoved on top. I guess because I don't like the syntax of Mnesia
A nice coincidence. I was looking up the Pearson Correlation Coefficient to implement in some code yesterday... and here it is on Reddit a day later.
Sold out? You mean the event doesn't scale well?
Openfire may be simple but I had a private XMPP server and decent online presence script in less than a day. It took some hand coding to wrap it up but even a sub par PERL hack like myself managed it allright. CPAN is your friend.
Towards hard realtime would be a better title.
&gt;Haskell, Erlang, O’CAML have been effectively exploited in many application fields, demonstrating how high–level languages can help in writing efficient, readable and almost bug–free code, rapidly stealing the prominent position gained in many fields by OO languages such as Java and C++. Love this quote
You like her to throw stuff when you do something wrong?
You do realize that if you attempt to qualify the search a bit (to exclude telecom, dogs named "Erlang", etc.), there is insufficient data to plot a curve.
You missed an I: http://www.open-mpi.org/
a) Haskell is a compiled, strongly statically typed language b) Haskell MVars are more specialized / limited than Erlang's message queues (and slightly faster as a result)
Huh? &gt; So... here’s the results. First on my MacBook Pro, without HiPE: ... &gt; Now on Linux 2.6 with HiPE: How is that comparable?
He is using similar/same hardware for testing a task which is almost completely CPU-bound and which makes no direct calls to the OS. The reason for the switch is that HiPE is not available under OS X without some hackery that may itself introduce overhead and instability. 
So why not do both on Linux?
Because I don't happen to have easy access to a Linux machine this week, so I did everything initially on my Mac. A friend offered to run the code on his Linux box with HiPE, so I took him up on it. I suppose we could have run both on the linux box, but it's not really meant to be a super-rigorous scientific comparison.
Because I don't happen to have easy access to a Linux machine this week, so I did everything initially on my Mac. A friend offered to run the code on his Linux box with HiPE, so I took him up on it. I suppose we could have run both on the linux box, but it's not really meant to be a super-rigorous scientific comparison.
this article is not (only) about regular expressions ... &gt; Note that what holds Erlang back is that people believe these things, a distinct matter from their truth. Let's look at both the beliefs and the truths.
I downloaded erlSim yesterday and have started playing with it. The code is shockingly compact: very few lines of code to do what it does. For example, the main simulation-engine source-file has 139 lines; the one include file is another 38 lines. Besides the simulation engine, there is code for generating probability distributions. At a quick glance, this code looks well thought out and the author, Lee Barney, seems to know what he is doing. Erlang is particularly well suited to discrete-event simulation because both are based on a message-passing paradigm. I look forward to testing erlSim's performance in terms of the number of events per second it can simulate. 
A bit early when all there is are a list of goals. 
&gt; this article is not (only) about regular expressions You may have been misled by the title. This article is just the latest in the long-running **Regular Expressions** column by the same authors. It used to be a regular feature in the now-defunct *Unix Review*, and almost none of their articles were literally about regular expressions.
Darn it, I wish I still lived in the Bay Area...
see also: http://www.ideaforge.org/blog/?p=9 MailSentry released
via: http://www.erlang.org/pipermail/erlang-questions/2008-January/032386.html
Recent erlang-questions list discussion is relevant, since other folks seem to have similar single-VM scaling issues: http://www.nabble.com/My-frustration-with-Erlang-td19456593i20.html 
see also: http://myfcci.com/yab/2008/09/11/my-faxiensinan-cookbook/ My Faxien/Sinan Cookbook
alt-f, alt-b don't work for me (erl in linux). I just get funny control sequences: Eshell V5.5.2 (abort with ^G) 1&gt; this is \303\242 &lt;- that was alt-b, \303\246 &lt;- alt-f example text Joe's book doesn't mention them either (only ctrl-a and ctrl-e, which do work). Or maybe my xterm is misconfigured in some way? (but all the bash editing commands work fine). Or maybe I have an (old) version of erlang without that support: Erlang (BEAM) emulator version 5.5.2 Compiled on Sun Dec 3 16:13:18 2006 Finally - this really, really irritates me, and I've had it in mind as a project to fix it, when I've learnt enough erlang... but having a project is a good way to learn, eh? Maybe I should just start on it, before I know enough... 
Does this really warrant a reddit post? Someone asking a question? Really?
this works for me: &gt; Press Control and click into the xterm window. You'll get a menu. Select "Meta Sends Escape" from the menu. http://cygwin.com/ml/cygwin-xfree/2003-11/msg00181.html
awesome! now it works, thanks so much :-) (at first I forgot it was alt-b and -f, and was trying alt-arrow keys). 
We videotape everything, so check back in a few days...
http://www.bayfp.org/blog/2008/09/22/slides-and-video-from-september/
Fail. It's not about can, it's about want: Guido didn't like any of the syntaxes suggested, and ruby-style blocks with magic applications (as in the reia map example) wouldn't have worked with the language anyway (here's a hint: if there's magic in it: most pythonistas won't like it and guido will nuke it). With pythonic multi-line lambdas (assuming we re-use def) this [1,2,3].map do |n| n * 2 .reverse() Would look something like this: reversed(map([1, 2, 3], do (n): return n*2)) which creates a gigantic problem when you need to add yet another argument (there have been threads on the subject in both the python ML and artima). Furthermore it's not like Ruby-style blocks are that interesting given that they're limited to a single block per call. In the end, as far as Guido's concerned anyway, this just doesn't give enough ROI compared to explicit function pre-definition when the disadvantages and issues into reworking the grammar/parser are factored in.
guido explains rationale: http://www.artima.com/weblogs/viewpost.jsp?thread=147358 and we are all free to disagree.
Kevin Smith???? wtf?!
uhm, they cost money to see? Also, skipping the blogspam: http://www.pragprog.com/screencasts/v-kserl/erlang-by-example
via: http://www.trapexit.org/Special:UserContributions
Man DonS is just shameless any more. I love you man, but not everything is an opportunity for language evangelism.
&gt; It's fast. Not as fast as C, but probably less than 3x slower. Since most other high-level languages are an order of magnitude slower than C, this is a big, big difference. Erm... the rest is ok, but that's completely false, Erlang is much slower than C even when using HiPE. Much, much slower.
LFE does not compile to bytecode, it compiles to Core Erlang which is a language underneath the regular "sugared" Erlang as well. So the whole optimizer is used as in normal Erlang code. 
I have some comments to this in the blog. 
Reia is a neat idea, but the guy working on it keeps making silly comments like "we need mutable variables to do objects" and copying weird properties of Python and Ruby (like using capitalized variables for compile time constants instead of assign-once variables).
via: http://ulf.wiger.net/weblog/2008/10/04/contribution-summary-page/
via: http://www.pragprog.com/news/pragmatic-thinking-and-learning-more-iphone-and-erlang?319835 In this final episode of Erlang in Practice, we’ll focus on two mechanisms that OTP provides to manage the lifecycle of processes in an application: supervisor and application behaviors. We’ll write a Web Supervisor and a Messaging Supervisor to manage those subsystems, and then layer another meta-supervisor on top to manage the entire chat system.
Don't forget 'erlang odbc'... but that's probably not what the author have in mind. CouchDB is also hot lately.
Ericsson?
The Mochi people were hiring a Python/Erlang person at some point.
How well does it scale?
Come on guys, how can you upvote Vaporware like this?
Weeee! That's about time...
It’s a shame the author skipped the Mnesia chapter, it’s not just your everyday database. Just like the rest of the book, the section on Mnesia introduces new ideas and paradigms. Otherwise I think it's a positive review with the author picking up the book for all of the right reasons.
Purely on the genius of the API, if you ask me.. watch the video.
What video? There's no video on the submitted page and the site was absolutely empty when submitted four days ago. Should I go and check again?
So... guy discovers Erlang and writes "hello world". Why are you constantly posting all of this to the Erlang reddit, gst? It's of no interest to the community
**Open**Poker is *closed*-source software, WTF with the stupid name?
http://www.xach.com/misc/openpoker/
This is an older edition, which was GPLed. Current releases are closed source.
Right... but now Shmurk knows WTF is with the stupid name.
There is an open version available, though not containing the most recent closed-source additions. If you're after a copy why not drop Joel a line or leave a comment on his site? He's usually pretty quick to respond. I think he's also looking to sell the source with the closed-source additions as well.
I am no OpenPoker historian, however I believe OpenPoker started out as a Poker Server which was Open Source. I also believe the original OpenPoker is still Open Source, hence still being called OpenPoker (Open source Poker server). There are Closed Source additions to the Open Source OpenPoker which Joel is selling for use with OpenPoker, which is Open Source.
2.4 Best practice is not what I would do. vanilla_reverse([H|T], Acc) -&gt; vanilla_reverse(T, [H|Acc]); vanilla_reverse(_Any, Acc) -&gt; Acc. --- 2.5 Translates to "because". Someone should list some ways to make it fast. 
To see how you can use it, http://hopper.squarespace.com/blog/2008/5/29/leex-and-yecc.html
He mentions a lot of "weaknesses" in Erlang, but then talks about a more "modern" Erlang. However, of the weaknesses listed, I don't see any that are because it isn't "modern".
The author seems a bit overly obsessed with "regular developers", who apparently only write CRUD web applications and are incapable of using anything other than C-style syntax (except when they are, c.f. Python and Ruby). Personally, I really don't care that much if that crowd keeps using PHP for the rest of their lives, it'll just keep salaries higher for those of us who can work on a broader range of problems. Going point-by-point: 1) Get over it. Seriously, the syntax of Erlang is dead simple. 2) Absolutely agree. And, dare I say on behalf of the maintainers, patches welcome. 3) Also true, although there's a handful of new, more real-world books coming off the presses in the near future from those experienced users, so hopefully that helps. 4) I'd write this off as a failure of imagination. Erlang has modules with well-defined interfaces. Tools like dialyzer allow you to do quite a bit of static type analysis. What are you looking for exactly? 5) You're not looking very hard. Check out Wide Finder and the Alioth shootout pages, for example. 6) Indeed, Erlang is a relative new-comer in the world of web frameworks, although there's rapid progress being made (and stay tuned for a book on the topic) 7) Binary / raw IO is plenty fast in Erlang. Line-oriented IO is indeed lacking at the moment, although with a hundred lines of code or so, you can write a vastly improved version (or just go copy what was done for Wide Finder, if you can't figure out how to do it yourself). Strings are not especially fast, it is true, particularly if things like regular-expressions are your standard go-to tool. That will probably change to some degree with time, and there are some techniques to get better performance, but it's probably never going to be a primary design goal of the language. In closing, all the applications where the author says Erlang is a good fit sound vastly more interesting than the applications that aren't. So, I'm not losing any sleep, and I suspect most of the Erlang community isn't either.
via: http://www.nabble.com/Bug-in-trapexit-article-%22How-to-use-ei-...%22-tp20516290p20516290.html
No, it is not a good idea to make a language built for concurrency from the start run on a virtual machine that is anything but built for concurrency just to (assuming the same motivation all the other 'make X run on the Java or .NET runtime projects have) allow reuse of inherently not thread-safe libraries from a language that makes code that isn't thread-safe impossible by only allowing single assignment. The two models are just too different which is the reason why Erlang is so successful in tackling the problems that are handled poorly by "traditional" thread models. If you want to do anything to improve adoption of Erlang in the Java or .NET communities try to come up with a C-like syntax for Erlang while keeping the semantics of Erlang as they are.
This is similar to one of the many many articles I read when starting to use Erlang with other languages. This article uses Erlang IMPROPERLY (for the most part) wherein it adds a layer of complexity (parsing, matching, and dispatching) that you can do away with up-front using OTP. A better overally way to do Erlang networking (generic) is http://www.trapexit.org/Building_a_Non-blocking_TCP_server_using_OTP_principles 
To me that whole very short connection problem sounds like just another symptom of the flawed PHP model of keeping no state at all between requests.
I actually outline that in a future article, here: http://20bits.com/articles/erlang-a-generalized-tcp-server/
Oh come on, no stream?
Ah, what a misuse of Erlang, especially considering that all the 3 programs presented are all O(n) far from the optimal O(1). The guy should learn some math rather than experimenting with 'creating a process for every number'. His next post about problem 2 is not much better (he does 'find the sum of fibs below 4mln' by evaluating fib(n) from scratch until it becomes bigger than 4mln), but at least there he confesses: 'I am really let down by my lack of maths at school.'
Please post the O(1) solution, of course I'm very interested to learn it. I am learning the language and maths side by side. Have a look at the other solutions too, I'm interested to hear your thoughts.
Added the O(1) solution. Thanks for spurring me on.
Well, there are floor(n div 3) numbers below n that are divisible by 3, floor(n div 5) are divisible by 5, and floor(n div 15) are divisible by both. Each of these subsets form an arithmetic progression, and it's easy to figure out its sum: the sum of numbers from 0 to k * p in steps of p is p * k * (k+1) div 2, for instance the sum of numbers from 0 to 333 in steps of 3 is 3 * 333 * 332 div 2. If you add up the sum of those divisible by 3 and of those divisible by 5, you'll account those divisible by both twice, so you need to substract them. Thus, the answer is: d3 := floor(n div 3) d5 := floor(n div 5) d15 := floor(n div 15) arith(p,k) := p * k * (k+1) div 2 result = arith(3,d3) + arith(5,d5) - arith(15,d15). 
Thanks. I have posted a version of that, too. I hasten to add that I got there by different means but your solution is the same as the one I learned. A work colleague told me it as part of a story, of how a young Gauss astonished his teacher when asked to calculate the sum of the sequence 1...100. Then my colleague explained how the technique Gauss used was n(n+1)/2. That is the basis for the solution for problem 1. my colleague took the time to show this by writing out 1,2,3 and underneath writing 100, 99, 98. It is so simple when explained so. It is a hugely pleasurable thing for me to be learning all this at my age but it is tinged with a some anger at my teachers. I was led to believe that i could not understand this sort of thing: clearly they could not explain it.
Well, then surely Project Euler is the right thing to learn with. However, beware: it's addictive like a drug, it steals dozens of percents of my productivity.
This is about http://en.wikipedia.org/wiki/Erlang_unit not Erlang the language. Buried.
Yes, but it's very interesting anyway! It's probably the type of calculations that shuld be done often when planning.
Yes, but it's very interesting anyway! It's probably the type of calculations that should be done often when planning.
It shouldn't be under Erlang. It should be under programming or compsci or some relevant topic.
It could use improved db drivers (yes I know it has them, they just aren't as good as for most mainstream languages), and a better means of persisting mnesia (I'm aware that tokyocabinet looks promising). To my mind this comparatively poor ability to persist large amounts of data to hard disk is erlang's only serious weakness. Erlang has a great track record in huge distributed systems, but in many large systems, big enough that they have to be implemented on a cluster, you really want very good mechanisms to persist everything to hard disk.
hey look, it's a scalable functional language that isn't functional and hasn't implemented anything for scalability. I too have invented a flying submarine that is ruined if it gets wet and cannot fly.
From what I understand, Reia is effectively an Erlang pre-processor: the Reia code compiles down to Erlang code. So Reia doesn't need to implement anything special for scalablilty as it gets that for 'free'. I'll still stick with LFE, though. 
Without some OTP or supervisory overlay, the scalability is faulty (with no hope of recovery). This is a failure of Erlang (which I &lt;3) and subsequently Reia. If he managed to shoehorn OTP in there, with object-like behavior models (which is how OO programmers see OTP behaviors) that you could extend, he'd have something imo.
Harrop spam :/
Synopsis: Erlang good. // I &lt;3 erlang
How does this relate to the Erlang programming language?
it does not. Reported (for spam). BURY IT WITH FIRE.
del.icio.us uses also erlang : http://news.ycombinator.com/item?id=322998
Using Erlang for Web Development is like using Lisp for Web Development without any libraries. Yes you can invent the wheel from a molecular level, but there's no compelling reason to do that (without a budget, a team, and a design document with clear goals).
No, there are some good libs/frameworks out there and more keep popping up: * [http_server](http://www.erlang.org/doc/apps/inets/http_server.html) * [yaws](http://yaws.hyber.org/) * [mochiweb](http://code.google.com/p/mochiweb/) * [ErlyWeb](http://erlyweb.org/) * [WebMachine](http://code.google.com/p/webmachine/) * [erlycomet](http://code.google.com/p/erlycomet/) * [CouchDB](http://couchdb.apache.org/) I'm sure there are a few I've missed and that doesn't even cover templating and HTML rendering at all.
nitrogen is pretty slick as well http://nitrogenproject.com/
To say that there aren't any good libraries or tools for building web services or APIs is ridiculous. Not only are there the usual bunch as cdub posted but there are plenty of libraries for data formats and exchange. Consider xmerl, rfc4627, mochijson2, and protobuffs. With MochiWeb and one of those you can very quickly create fast and extensible services and APIs that take advantage of all that Erlang has to offer. When I read this post the impression I got was that the writer has a hard time following through with projects that are different than what they are used to. This post isn't talking about the inability of Erlang to provide solutions, but the author's inability to think of them.
The post on ycombinator is a bit misleading. Delicious itself wasn't entirely rewritten in Erlang but, as the slides that I put together point out, some critical components were. This includes the migration system for d1 to d2 and some of the spam and algorithmic services.
Ooops, see, I forgot a good one. Definitely a nice project.
As I said, there's no reason to make a new web framework out of Erlang. While it provides scalability, the string handling alone means you have to be a masochist to want to use it for a template parser. There is no compelling reason to use Erlang for a web framework (although people do make things just to make them) but lots of performance metrics that show you shouldn't. //I've written 3 erlang servers for Java RIAs, none of them web-based. Choosing erlang for web dev is choosing the wrong tool.
Why is the Erlang reddit this totally contentless beginner crap? There hasn't been a good article here in weeks. I'd really rather see nothing than read the same story about ten people discovering how to write fib(x)
I was thinking the same thing. I've seen at least a half dozen fib examples since I've subscribed.
indeed, a far more cooler example would have been an icmp echo server, solving towers-of-hanoi...(fwiw, i have done it in c and python)
I'm the moderator 'round these parts, and I'm going to just start banning them. Honestly, there can't be any Erlang programmers that are actually interested in them if they've written more than one line of Erlang code. It's almost all `gst`, who I've asked to stop
ICMP echo would indeed be interesting, since I don't think Erlang has ICMP bindings. You'd need to write a tun/tap module and construct the packets by hand, as well as find a way to keep the OS from responding to the packets long before you received them. Maybe you mean TCP echo?
no i mean icmp ping. what you want your server to do is send out hanoi moves as icmp echo response sequence numbers when you ping it. on a linux host, you can turn off icmp echo using 'echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all' then your server can do the needful. i generally use sequence numbers as '&lt;icmp-packet-count&gt;&lt;disk-move&gt;'. thus, first couple of packets would be '112', '213', '412', '531' ... have fun ! 
Same here. I'm by no means an expert but enough with the "hello world" crap.
In short: the error_logger process' message mailbox was filling faster than messages could be written to disk. It seems that asynchronous writes ought to take care of that, but I believe the typical solution is rate-limiting.
Ahh, I see. I saw &gt; icmp echo server, solving towers-of-hanoi and thought it was a list of ideas, not just one idea :)
Oh, brother. Again? I'm getting depressed at all the new frameworks. I know it's fun to reinvent the wheel, but the Erlang community could help Erlang's cause a whole lot more by focusing attention on one, or _maybe_ (very maybe) two, frameworks right now. I recently wrote a document evaluating the choices available to a web startup. This covered a whole gamut, from Rails to Seaside. Naturally I wanted to stuff an Erlang framework in there, but there wasn't much to say: a whole lot of fluff about how Erlang's used in the telephony world, and how mature some tools are... and how the largest of Erlang's web frameworks is pissant tiny, with a nonexistent community and dubious longevity. Nartually, despite Erlang's merits, there's almost no chance Erlang will be used in that startup. Seriously, guys. If you want Erlang to spread in the startup world, stop masturbating over your own shitty toy frameworks and start working together. &gt;:(
this is totally bogus. there is no "fast packet loss" problem.
Here's what may be a fast way to get at the data: skip(B, X) -&gt; skip(B, X, 8). skip(B, X, Len) -&gt; case B of &lt;&lt;X:Len, Rest/binary&gt;&gt; -&gt; Rest; &lt;&lt;_:Len, Rest/binary&gt;&gt; -&gt; skip(Rest, X, Len) end. chomp(B, Bytes) -&gt; S = size(B) - Bytes, &lt;&lt;R:S/binary, _:Bytes/binary&gt;&gt; = B, R. dememcached(B) -&gt; chomp(skip(B, $\n), size(&lt;&lt;"END\r\n"&gt;&gt;)). 
The Erlang is strong with this one.
what a time consuming user interface! would be nice if it was part of the 'make test' output. maybe an easy fix?
It's possible, but really up the developers to figure how to consume the results. This is just a demo of how to use it in a very basic way.
I had some trouble finding how to download the video so here's the instructions: http://fora.tv/fora/showthread.php?t=26347
This is a fantastic post, I'm really looking forward to seeing some data about how these things perform with an actual workload behind them. 
Bah, code or it didn't happen.
I don't know why this isn't getting modded better, this is fantastic. 
I am new to Erlang, and after I did these exercises I thought it might be useful to put it somewhere others can read. Otherwise, most probably these exercises will buried soon among other junks in my hard drive (short attention span and interest :P). Who knows I might get feed back, or probably other will continue the rest 70 problems. Edit: [Original 99 Lisp Problem](http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html) and [99 Haskell Problem](http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems)
This is great, please do post more. Just yesterday I was looking for some stuff to work out in Erlang, great stuff!
if you havin lisp problems, i feel bad for you son
I am willing to share the code. Never did it though. There must be the right may for Erlangers to share code. Please advice.
There is a problem. When the socket is open in active mode (by process #1) and then a new controlling_process (process #2) is assigned to it, some packets may be delivered as messages to the process #1 and be buried in its mailbox. Then the process #2 will not be able to excercise its rightly acquired control over the socket. In my implementation of Erlang there is no way to change the controlling process though X Erlang behaviour with respect to sockets is a bit distant from classic. With X Erlang you need to signal a port (by sending a message) that you want to receive a message from it of arbitrary or given length. 
No, lisp ain't one of them. I have 99 Erlangs problem not lisps :P.
Very cool. Example of not only a hot code update, but also on the fly schema migration. I likey...
But not only on the fly schema migrations, the comments include a slick way up updating gen_server code.
Don't waist your time on meaningless problems please.
How about http://feedproxy.google.com/planet_erlang ?
It's a shame Google Groups is terrible. Very very rarely do emails actually arrive, unless I use my gmail address and have gmail forward them... and then I'm stuck on a real-only mailing list.
If you're primarily consuming erlang-questions by email, [subscribe directly to the email list](http://www.erlang.org/mailman/listinfo/erlang-questions); don't bother with the Google Group. If you want to use Google Groups to browse the erlang-questions archive, though, it's important to know about this new group, because the old one has been unsubscribed/deprecated.
Why not using code.google.com? Decide of a license and you're good :)
Covers encoding and decoding JSON strings in Erlang.
I really like what I'm seeing here. Between this and Nitrogen, Erlang seems to be encouraging some "sideways" thought in the web framework category. Good stuff!
got there thru this blog: http://erlanginside.com/tic-tac-toe-in-erlang-76
What an exceptionally uneventful interview.
Where's the code?
Misleading. Link doesn't point to a minimal Twitter-like service in Erlang. It points to an empty repository supposedly for a Twitter-like service in Erlang. That's akin to telling someone you have a million dollars in the bank account, but in fact you have a bank account capable of holding a million dollars. 
Goes to a goDaddy parking page.
Interesting service, http://messagepub.com , the 'library' is just a very thin wrapper for it.
My god, poor Armstrong, those were dumb and useless questions. How do you like your eggs? Fried or scrambled?
Has anyone had an opportunity to evaluate recent builds of ErlyBird and Erlide? Are they contenders against Emacs+Distel yet? Most reviews seem to be a couple of years out of date.
Great! You can't make out the presentation or hear the presenter half the time! Next time zoom out even more, and put a sock over the microphone. edit: ok that was harsh
harsh yes but very true. 
The cameras were as close as they could be. ETC will have to invest in or rent better cameras and microphones next year because I don't think you will get much better quality out of these, considering that you shoot indoors with speakers who don't always have very strong voices. I have helped out recording at FSCONS as well, same thing there, great talks recorded with small handheld cameras. It just doesn't cut it.
I was trying to use erlide but I could not make it working. It was crushing my eclipse as far as I remember and I was not able to use it. But it was 6 months ago so probably it is better now...
Attention managers! What is the black magic stealth technology behind feared Goldman Sachs and its whispered microseconds-fast automated trading systems? [Serge has been pretty active online, it seems.](http://www.google.com/search?q="Serge+Aleynikov"+caml+OR+ocaml+OR+erlang)
[From Paul Murphy's FT blog](http://ftalphaville.ft.com/blog/2009/07/06/60561/the-great-goldman-black-box-heist/): &gt; For what it’s worth, Aleynikov told the cops that he thought he was just accessing “open source” files on which he had worked, and only later realised he had accessed more data than he realised. He’s also denying that he distributed any of Goldman’s proprietary code.
So being mentioned parenthetically in an article by "Tyler Durden" is marketing coup?
he appears to be an erlang person as per his linkedin: http://www.linkedin.com/pub/serge-aleynikov/2/432/405
Sure. Check out [that Google search](http://www.google.com/search?q=%22Serge+Aleynikov%22+caml+OR+ocaml+OR+erlang): he's been active on Erlang and OCaml lists. Here [he exchanges emails with Jon Harrop](http://caml.inria.fr/pub/ml-archives/caml-list/2006/12/480f7f173c28800865b6c112f3e54064.en.html)!
I am loving this news story!
I've been downloading the slides and watching them concurrently on my second monitor. ;)
&gt; Joel Reymont, a freelance developer who lives in Tenerife, one of the Canary Islands, / ...proposed a challenge - $1000 to the first person who can get the broadcast under one second. How about airfare and a week to hang out in the Carnary islands? :) Not that I can improve his [code](http://github.com/tinycode/janus/tree/master)
Here's the [whole thread on the mailing list](http://www.erlang.org/cgi-bin/ezmlm-cgi?4:sss:45332:200907:oeehoembhmfnhkoojeof#b)
And it appears to have been [solved](http://www.erlang.org/cgi-bin/ezmlm-cgi?4:msn:45341:oeehoembhmfnhkoojeof) already!
Thread has been updated with [a new one](http://www.erlang.org/cgi-bin/ezmlm-cgi?4:sss:45375:200907:aamcilnakngmhgipillp#b) He's now asking to basically double his performance (again), while adding more safety. I'm not sure he'll be able to get the results without using a C-node to do the I/O and whatnot.
Here's the [message board history](http://groups.google.com/group/erlang-programming/browse_thread/thread/1931368998000836/b325e869a3eea26a) of the first challenge. Have fun! :)
This code will be used to simulate a world spanning brain.
It is not web server framework. Look at erlang-web or erlyweb if you want web framework. mochiweb or misultin is only http library. and misultin is very simplistic. inets is better imho especially in some more advanced usages. 
Not to be pedantic, but I would argue that this is a web SERVER framework (along with yaws, mochiweb, and inets), and erlang-web, erlyweb and nitrogen are web APPLICATION frameworks. 
Thank God, because the other templating alternatives for web development with Erlang are usually pure crap.
Starndard XML based wparts wasn't very bad, but it would be nice to have both wparts and dtl mixed, on one page. Especially that some wparts have some additionall usefull parameters. Currently your whole project need to have one kind of templates. 
Why not just use OTP applications and application:get_env?
They are more static. Additionally some components tends to be composable and reusable by many applications. And sometimes you have so big configuration that you want to have them in many separate files. .app files are more complex, for normal user simple file with only needed options is better. 
Registration needed for .pdf download :/ Will try at home. 
Hello reddit, I'm the guy who wrote the LYSE site! I Hope you'll enjoy it :) I'll always be fixing mistakes and technical points that were not caught in the reviewing process, so it's much appreciated if you give me comments and criticism. Feel free to speak your mind!
There's another one a little bit more user friendly (it lets you copy links!). http://erldocs.com
It is really good introduction. Nice style. Few errors: atom can have dots (but not at the end or two near each other), so cl.x is atom, or cl.x.y or .g.h (which is the same as g.h actually), but not cl..x, or cl.x. After quoting in ' you can put there pretty everything. But few interesting things, like Binary Comprehensions which i didn't know exists. Rest is really nice, pictures beautiful. Mayby installing step is missing, just notice about apt-get install erlang on Debian or Ubuntu, or where are .exe files for windows (erlang.org) Waiting for more :) 
Thanks. Interesting. Coping links are much easier, right. But: 1. it runs/scrolls slower than erlapi 2. there is no overview section with just signatures of function like in erlapi 3. lets look at http://erldocs.com/otp_src_R13B/kernel/gen_tcp.html?search=gen_tcp&amp;i=0 code is not formated poperly, it is in code html tag, but and is using fixedwidth font, but isn't preformated so newlines are ignored. 4. there is no application browser, so we don't know to which application belongs modules. 
I'll fix this about atoms when I have time (hopefully tonight after work!) As for the apt-get and the .exe for windows, [it is there already](http://learnyousomeerlang.com/introduction#what-you-need). I couldn't provide much support because it would be a lot of stuff to worry about (I think the Erlang VM runs on even more hardware than the JVM)[citation needed]. I just hope what's there is enough to get most people going. 
Can't argue with that. The function signatures are pretty useful. I'd like to see what both of these guys could in coop mode, though.
No offense, but why ape someone else's style? Honestly, I find _why's stuff impossible to read clearly. I'd rather have a nice straightforward tutorial.
I couldn't exactly read _why's stuff either, but I could read through http://learnyouahaskell.com quite easily, liked the formula and thought a similar tutorial would be good for the Erlang community (assuming I pull it off correctly). (also answered in the site's [FAQ](http://learnyousomeerlang.com/faq)] If you really want a more straightforward tutorial you can read the [getting started](http://erlang.org/starting.html) sections of the official erlang website. It's how I started before buying books, too.
Looking very good, I love the style. I read LYSH a while ago but haskell never clicked with me. I started looking at erlang with this tutorial and really fell for it. I've gone on since and been able to very simply create things that would have been a nightmare in C or the like (such as a distributed processing node, which can accept or lose processing clients and "customers" without crashing, for distributing processing on arbitrary functions, 40 lines!). Anyway, this was just a long winded way of saying thank you :)
Thanks to you! For some people, the Erlang model really fits better than for others. Actors, message passing and the concepts of concurrency as implemented in Erlang seem to match some people's mental model of program design in a more natural manner than with other paradigms. Alternatively, this could be why some people just can't like Erlang at all, although it wouldn't be the only reason.
It looks that erldocs.com have be improved a lot. Code formating and example, and general design (colors, etc) is very good. Still there scrolling is slower that erlapi.prepor.ru (Firefox 3.5). 
Well I would say why *ape* another straightforward tutorial as well?
Because tutorials are generic and brandless. It'd be like me painting replicas of Van Gogh's work.
Personally, I think you have done a great job so far ... looking forward to more chapters.
I remember Scalaris being in RAM only. Has it changed with time, making it possible to write to disk?
It is ongoing work to remove RAM size limitation. But still even with disk storage, Scalaris will not be permament storage (on disk and ram data will be fully discarded when node will disconect from network in any way). It can also help in controled restart procedure. Currently ets (but not dest yet) and tokyocabinet is supported as backends. ets stores just in ram like ets, tc stores data in files. http://code.google.com/p/scalaris/wiki/Tokyocabinet dest is probably not supported due to the limitation of dets to 2GB files. More information in FAQ http://code.google.com/p/scalaris/wiki/FAQ
Oh well, for small datasets you can still copy ets to dets, so I guess for some applications that can be enough, although it's more likely I'd be using the database for something it wasn't meant to be. The FAQ is really helpful, too. Thanks for the link
This is of course one of my favorite books.
In Python, it seems that you cannot beat the simplest solution: def median(seq): seq = sorted(seq) return seq[len(seq) / 2] 
I'm glad to see you can sort a trillion random numbers in memory like that, on a single computer. I'd like to have such a machine in my possession.
Increasing processing time 2.3 fold increases the number of threads required to somewhere between 2 and 3 times? Colour me unsurprised. 
Actually you should split it as suggested, sort parts on workers (maybe using something similar to [this technique](http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html)). What I would do next (on master/coordinator): 0. Set counter to 0, seq = first integer from every worker 1. current = min(seq) 2. if counter == len(all_numbers)/2 then this is your number, else discard it 3. increment counter 4. fetch another from winning worker 5. go back to 1. This is the trivial approach that comes to mind without any deep thought process.
pity that the sound quality is so unforgivably horrible.
There is a mike right in front of you. Talk into it.
[non-audio/video, html text+slides format](http://riak.basho.com/nyc-nosql/index.html)
perhaps you didn't read that this was an interview question with specific criteria ?
Why not set it up as an Erlang application rather than a lib? Especially since `send_packet` might take a long time (even more so over networks) and re-reads the conf file every time.
One thing to note is that this item is already out of date with regards to the way you build controllers. Just a little change, though. The controller modules are now parameterized, with the one parameter being the Req. So instead of the Req being passed into the functions, it is just available to all of them, and the HTTP method and a list of extra URL parts are passed in as the two arguments. It's a much nicer interface than what it was before, I'd say.
I'll try to do that, I read about the inets application, Will try to do that. Would you put the cfg in the top level then pass it through/down to the payload generation ?
kind of a , uh, strong reaction, in proggit http://www.reddit.com/r/programming/comments/9xc3q/new_pragmatic_press_book_seven_languages_in_seven/
20% to 30% from gcc to intel? I call foul.
Maybe GCC has improved a lot the past few years, but before 4.* 20-30% wasn't unusual.
There is a volume control knob right in front of you. Turn it up.
Over-exaggerating.
This is good stuff! Thanks Bryan!
Pretty interesting, I don't know much about this stuff, but is this basically a new class of dictionaries that are distributed?
It's supposed to be a distributed key value store afaik. It uses erlang and it allows you to customize your confidence level when retrieving data.
exmpp is a XMPP library written in erlang so if if you were looking at using erlang to write XMPP applications, it's sure a good bet (since there's nothing else anyway). Aside from that, well it's nothing new. Note to self: Never use blogspot for a tech blog. It hurts your reader's eyes since it cannot correctly display code snippets.
The interview is not very interesting - in few words, they work together on better integration of the frameworks. However [nitrogen](http://www.nitrogenproject.com/) is interesting. 
Could someone explain why the latest thesis is dated 2000? Are there anything fresher?
That's pretty nice, but I think the next trick is learning how to bind erlang processes (both os and application level) to specific cpu/cores so that things don't get swapped out. 
&gt; I have made a erlang deamon that acts as a "polyport" - ie just open port 1234 (say) on the server and start talking in any protocol you feel like - the port analyses the input and starts the appropriate middle man. Hah! This is at the core of the WebSocket and other BWTP proposals for the future of persistent connections within browsers.
[note](http://www.manning-sandbox.com/thread.jspa?threadID=34547&amp;tstart=0): &gt; A while back we decided to focus just on intermediate erlangers and concentrate directly on OTP. ... &gt; We would love to see something that focused on using various technologies in Erlang. However, we felt that getting people well grounded in the fundamentals of writing large scale Erlang apps (basically knowledge and use of OTP) was more important in the short term.
A simpler way to do it would be to use the --dump_callgraph=file option to dialyzer, if file is *.dot you get a dot version if it is *.ps you get a postscript version, probably not terribly documented though. 
4 erlang books in preparation: by Cant, by Gerakines and by Logan/Merritt/Carlsson on Erlang, and on couchdb (Anderson, Lehnardt and Slater) The couchDB/Oreilly and Logan/Merritt/Carlsson //Manning books have prepublication PDF's out for purchase / comments. I bought one a couple years ago from Oreilly, submitted a bunch of errata, and was surprised to be sent a complementary hard copy and to be named as a Technical Editor in the book. http://oreilly.com/catalog/9780596155902/ http://apress.com/book/view/1430227699 http://www.amazon.com/s/ref=nb_ss?url=search-alias%3Dstripbooks&amp;field-keywords=erlang&amp;x=0&amp;y=0 
some outstanding question-answering folk there: Gordon guthrie, zed, JLdupont, rvirding, raloi, archelus, Christian
The 1st chapter and a "Green Paper" excerpt are available free http://www.manning.com/logan/ I'm witholding judgement til i see all the draft chapters &lt;2pt font&gt;top secret discount code at top secret website: www.erlang.org&lt;/2pt font&gt;
Nice perspective on how he deals with the FP features that are "missing" in Erlang. He raises an interesting question at the end: where is the next order-of-magnitude improvement in programming productivity coming from? He doesn't have an answer. I suspect the answer is coming in the form of libraries or programs that can be stitched together to create mash-ups.
Downvoted for not mentioning it's a video.
good point, should flag .PS, .tgz, PDF, vid, pod/screencast, anything else?. Never had a downvote explained before
How exactly is it broken ?
slides from a E Letuchy talk, this may not be same talk http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf
the title to this post is questionable in it's implications, and you should also link to the erlang-factory video post. they say they don't use the OTP because they didn't (possibly still don't?) understand it well enough, not that it's bad or anything
http://lambda-the-ultimate.org/node/3673
Ulf Wiger's report is more up to date http://ulf.wiger.net/weblog/wp-content/uploads/2009/01/damp09-erlang-multicore.pdf Forgot to mention it's a PDF of slide deck http://www.erlang.org/pipermail/erlang-questions/2008-September/038231.html 
i love reading performance tests
The worst possible algorithm implemented badly in many languages. 
... eight to six years ago, benchmarked on a then already obsolete system.
http://www.doc.ic.ac.uk/~susan/jerlang/ for a technical report (19 pages only) and the tarball for the library.
The admin looks really nifty. I'll probably give it a try at some point even though I'm not a huge fan of CMSes
Generic, no identity, faceless, and unwelcoming.
This is a very ugly website. Please do not replace the erlang website with this. Thank you.
This design makes poor use of screen space and emphasizes the wrong sections in the wrong places. More importantly, it conveys a confusing impression of the erlang community and open source project. I really suggest you reconsider using this.
still works, Saturday 14th
It's ugly!
Generic? Looks rather unique (compared to most sites)
In the sense that it feels completely unrelated to the product. This design could be used for *anything*. It just looks like a bland corporate site.
I don't think I really understand, how could it be improved to be less bland and be more erlang-esque?
If by unique you mean very similar to dojo's website, then sure. http://www.dojotoolkit.org
For one thing, design around the logo it already has (and its colour scheme) rather than shoving it into the corner of some previously-trendy design filled with round corners, gradients, and dropshadows.
good point, though round corners, gradients, and dropshadows have little to do with what colorscheme is used EDIT: taking another look it seems that the logo is at least based on the current erlang logo, a truncated e 
good point, although that layout seems to be popular among programming languages and libraries in general. It'd be interesting to look into whether it's following the leader or if that layout helps those find what they are looking for better.
warning all - paper dated june 2007. things have definitely changed in erlang's scheduler, VM subsystem, etc. since then. 
Is this what it appears to be? A simple way of having C coded functions in erlang? If so, great! Does this have the same issue as linked drivers, where if the driver crashes the whole VM dies?
Good question. Also does each process has its own copy of the NIF in memory or do they all point at a shared one? How does it work with concurrency? In any case that looks nice at first sight.
It does seem to crash if there is a segfault. I'm not sure if there is some way of "catching" this, but with a quick test in the interpreter it just kills the VM. 
That's silly. Why is this any better than linked in drivers then? Honestly I never really understood why people were screaming for a foreign function interface anyway. 
Hmm, looking at [a pdf from the erlang user conference](http://www.reddit.com/r/erlang/comments/a6r6w/pdf_erlang_user_conference_2009_kenneth_lundin): &gt; New feature (still experimental) for native implementation of functions (in C) &gt; Complementing the driver concept. &gt; Exciting, Really Useful, But dangerous &gt; We call these functions NIF's (Native Implemented Functions), to &gt; differentiate them from BIF's (Built-in Functions) which are more or less part of the language. &gt; NIFs offer an easier and more efficient way to implement synchronous functions in C than the driver concept. &gt; Dynamically loadable and upgradable &gt; Several functions in a module can be implemented in C using this technique. Metadata in the module, the on_load attribute, tells the loader which function to call for loading and initialization of the shared library containing the NIF's &gt; But as said, really dangerous, use with care! At the very least it looks a lot easier to use and work with. 
Bah! I feel like this could all be done in Erlang with something similar to SWIG, configured with proplists, that would output and compile C and then call it using the regular, very safe port interface. 
You linked to a reddit-clone discussion of this? Bozo...
Wasn't sure whether to post this here or r/coding, so thought the erlang-centric community would be a good first stop. Working through the Okasaki book, trying to implement what I can in Erlang, and found RB Trees sufficiently mind-bending, esp. the balance/4 action. I know Okasaki has further improvements, like breaking up balance (which I will get to next), but wanted some feedback to make sure I'm getting the essence and the Erlang right.
You could compare with [this one](http://www.cs.auckland.ac.nz/~fuad/rbtree.erl), as it seems to be the canonical Erlang version on the Internet.
Yeah, I consulted that during my investigation, but didn't find it illuminating the way Okasaki's is, at least with regards to insertion. I am looking into deletion, and since the book doesn't cover it and Okasaki doesn't seem interested in expounding on it on his blog (and with good reason as near as I can tell), I'll probably develop something sub-optimal and refine it as I go.
I have a version of both dict and sets called rbdict and rbsets which use RB trees which are compatible with the OTP dict/orddict and sets/ordsets modules. They can be found at [rbdict/rbsets](http://github.com/rvirding/rb). It's the delete code which is the tricky bit. In the same place there is also aadict and aasets which use an algorithm created by Arne Andersson which is simpler and almost as good. 
That's great! I'm going to reason through the erase/2 and erase_aux/2, and see how that goes. What was/were your source(s) for implementing the algorithms?
I've searched, and I cannot find an implementation of the proposed protocol. Looks interesting, tho.
Just heard about this from the erlang-questions mailing list and found it really helpful.
nice
The coolest part of Erlang is the vm (hot swapping and lightweight threads).
I had a few relatively good references, I will try to find them for you. Please remind me again or I will forget.
Here a a few references I found which are ok: http://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html http://www.eli.sdsu.edu/courses/fall95/cs660/notes/RedBlackTree/RedBlack.html http://cs.wellesley.edu/~cs231/fall01/red-black.pdf More when I find them again :-) 
Much appreciated.
yeah I wasn't impressed either. I'm sure most people who think this is good probably are afraid of learning anything other then Java.
Hey cheers for the post, this is mine. once ive got the silly bugs out the way I am looking to add user comments, feel free to post feature requests and whatever
Sounds great...
Hi, I've just released rev 31 of the book, and code listings are working now. Thanks, Luke
Give some love to the error management. The supervision trees are nothing short of awesome.
&gt; Clearly the experts agree on this, because every sizable Erlang program I've looked at makes use of the process dictionary. It's time to set aside the rote warnings of how unmaintainable your code will be if you use put and get and instead revel in the usefulness of per-process hash tables. Now what's really being preached against, when the horrors of the process dictionary are spewed forth, is using it as a way to sidestep functional programming, weaving global updates and flags through your code like old-school BASIC. So you're telling us that if we play by the rules of erlang functional aspects we will be good and sound. Hmm, well that is kind of a given, don't you think? No need for such a convoluted paragraph. In my book, the process dict is fine when for processes that are almost pivotal to your application. Think about a process that will act as a gateway service for other processes. But in such case, it's so much better to go for a gen_server than it's rather rare you may need the process dict in the end.
Don't use the process dictionary...99 times out of 100 it is not suitable...pretend like it isn't even there.
Seems like the Erlang is doing more: using precompiler macros for the type codes, returning structured/tagged tuples, etc. The actual "case" statements themselves are basically the same. What am I missing?
That seems about right. The switches are pretty much the same and readability should just be a question of familiarity with each language. Unrelated: It looks like he didn't know where he was going with his Erlang: the doc about the function's input and return values are not the same as what the code does.
Rather, the rate limiting was added later on when it became important. Good catch :) What is quite impressive here is that Haskell is able to encode the same structure without any specific language support for decoding binary data at all - not so much the structure of my Erlang code.
It seems to be just a switch that then reads more data if necessary. Erlang's strength in binary parsing comes from more complicated patterns that involve different data widths and matching more than one field at once. Am I wrong?
Who is this booked aimed at? 
It's definitely possible (in fact wxErlang has been included in the standard Erlang/OTP distribution since April with R13A). Whether it's advisable is a different issue, mostly dependent on what you're building a GUI for.
I presume a GUI database app is a fools errand. 
There are two I can tell you about: gs, this is built into erlang. It's simple, but very erlang-y. Depending on what you want (is this supposed to be impressive for clients, or just a display, or what?) this might be the best / easiest solution. [http://erl.dougedmunds.com/](GS tutorial/reference style thing) WxErlang. An interface to wxWidgets, AFAIK it's got all the functionality of WxWidgets. I've not used it, but if you want a nice interface it's where I'd start. [http://www.erlang.org/doc/man/wx.html](Man page) Advisable? I think so. Your program can be written very easily to run things in parallel, so you can easily do things like updating progress bars. Also it should mean that your interface is responsive at all times (you might have to consider this if you don't want people pushing buttons while something is running). *Finally*, it should also be incredibly easy to have the interface running on one machine and rest of the program running on another. Well, hope this helps some, I've not really done much interface work (as you might be able to tell :) ) but I've played around with gs and it worked perfectly well for my needs.
I'm not sure what you mean by "fool's errand," in this context, but I can think of lots of reasons to go for it, and only one not to (basically if your goals don't involve learning and something sufficient exists). If you want to be more specific about what you had in mind, I might be able to give you some advice, point you at existing projects, or just say "hey, cool! I'd use that."
Honestly, you should go with PHP or something similar. Unless the database is Mnesia which in that case you should still do it in web and see what you can do with Erlang Web which is the more mature web platforms for Erlang specially when combined with Nitrogen (I reserve myself for recommending Nitrogen because I haven't really tested it, but I heard it is a killer). If you want something with quick response time perhaps a native GUI is better but in almost all cases the Web is more dynamic and flexible AND it is (almost) platform independent AND you can access it from remote. Personally I like the native GUIs because they have a faster response time in terms of GUI interaction (not counting in such things as fetching data etc). GL HF
My goal is learning. I am thinking of learning erlang and thought it might be fun to code up something I can touch and play with.
gs is being deprecated; as mentioned by masklinn, wxErlang is now part of the standard distribution
gs is the only one that has worked for me so far. I've been trying to get wx working over the past couple of days, but to no avail (I've got R13B1, so I would have assumed it's included). Ah well, gs does what I need for now. Edit: (Ah I understand the comment now, damn ctrl-z, I had originally written about wxErlang as well)
Cool :) You'd probably find more library support, docs/discussions, and end-users if you went with a web gui- especially an ajax/xmpp4moz/&lt;insert-web-messaging-system-here&gt; based one, and especially for a db that there isn't one for, already (I haven't looked, but I might soon- would be happy to exchange links w/ you). I use mysql, a bit of mnesia/(d)ets, and my own sort-of-db-thing, and would love an erlang-interface to a db-gui of some kind, (especially one which works well with lots of realtime updates (unlike the official (d)ets/mnesia table browser)).
It's very possible. Who cares if Erlang isn't considered a common choice for GUI apps? That's what makes it fun. Programmers used to think for ourselves; now we follow some lame vague hive mind made up of couch surfing wanna-bes who like buzzwords more than the hated enterprise types do. Take a look at Wings3D, a most respected 3D modeling written in Erlang. It was started years ago, when Erlang was much slower and less portable than it is now. They use SDL as their graphics engine. 
Possible, yes. Advisable, no. Much better to use the apache erlang module and make a web frontend for whatever you're doing. I use erlang with a Java swing frontend in one of my projects, just because it's faster to develop for and maintain. AWT and SWING are not known for being consistent or intuitive, but they are leaps and bounds more advanced than erlang's basic funs.
If you are doing that doesn't it make more sense to use something like scala?
Not sure it would "make sense". Are you thinking that Erlang and Scala are both supposed to be functional, so they would work together well? Not so much. Scala can wrap swing functions but it just gets in the way of how swing works internally. There's no benefit and a large amount of knowing which parts of swing are threadsafe and which are not (along with the prerequisite conflicts of multiple components on screen). Your backend can be as functional as you like because backend processing/services are generally atomic. When you figure out how to connect with sockets (or whatever transport you end up using) there's no reason to use a functional language over mature procedural languages with nice GUI and network libraries who don't care what produced the messages or how. This is why I suggested using a web frontend. You can have the backend in whatever technology you want. This at least, halves the "am I doing it right" factor.
&gt;Are you thinking that Erlang and Scala are both supposed to be functional, so they would work together well? Not so much. No. I was thinking scala has tried pretty much duplicated most of the core features of erlang like actors, supervisor trees etc. 
It always seemed to me the best route would be to code up most of the app's behavior in Erlang, and provide a GUI through message-passing using anything that can access the C libs for OTP's msging (pretty much anything). It sounds daunting but the OTP docs have quite a few examples of the concept. EDIT: I also wanted to mention that this is pretty much how Erlang apps will be created once Websockets is finished, you can see some discussion of this here: [Erlang and Websockets almost working](http://groups.google.com/group/erlang-programming/browse_thread/thread/a73efebabf352d19)
I've been using medici. Not linked in, but it supports more than just hashed tables. Still, nice work, I hope you continue working on it.
Disclaimer: I think this idea is kind of dumb and I don't support it. The article doesn't actual link to the source which is on GitHub. Here is a link: http://github.com/maximk/teeterl
I've been using erldocs.com for a while now and find it way more useful than trying to dig through erlang.com/docs.
It's always worth profiling your code. Looking at it quickly with much smaller sizes (10 - 40), I found that the grid method eats up a very large amount of time. As you increase the size of the grid from 10 to 40, it goes from taking 5-10% of the time to 25%. It looks like it carries on growing, too. Edits to code: I changed width and height to N I also changed it from plists to lists. Your code is probably using much more time just creating the grid than mine.
Use lists for a grid instead arrays it's crazy. You are reading the whole list to get a simple cell. http://www.erlang.org/doc/man/array.html 
He's not reading the whole list per cell, he's reading the list per lists:map. There is no random access needed.
How do you profile easily in erlang?
I thought list comprehension is a good way to create this grid. How can I make it quicker? I also tried creating the grid in a list of rows, and then only running separate processes on the rows (see below). It's not a lot faster, the bottleneck does seem to be the generation of the actual grid. grid(N) -&gt; [grid_row(N,Row) || Row &lt;- lists:seq(0,N)]. grid_row(W,N) -&gt; [{float(X)/W,float(N)/W} || X &lt;- lists:seq(-W, W)]. 
Sorry I should have said how I did it. You can use tools like [fprof](http://ftp.sunet.se/pub/lang/erlang/doc/man/fprof.html) or what I did here was the timer module. The timer module is a great one to run quick tests :) Try the function timer:tc, here's how I tested your code: timer:tc(mandelbrot, mandelbrot, [20,1000]). The format is timer:tc(module, function, argumentlist). It returns a tuple of the runtime and the result. I'm fairly new to erlang though. I've been trying to make your code faster but every optimisation I try makes it slower!
I'm not sure, this is really confusing. I've removed ScreenGrid, since you never actually use the values, along with the zip and extra unpacking needed, and it got slower! Baffling.
Change your write\_pixels\_to\_ppm function like this for a 4x speedup on my machine: write_pixels_to_ppm(Width, Height, Pixels, Filename) -&gt; Header = io_lib:format("P3~n~p ~p~n255~n", [Width, Height]), Body = [io_lib:format("~p ~p ~p ", [R,G,B]) || {_,{R,G,B}} &lt;- Pixels], file:write_file(Filename, [Header|Body]). Edit: I give up trying to put the underscores in normal text... Edit2: Escaping the underscores seems to do the trick!
plists:pmap/2 is only really useful when the calculation cost for each element is greater than the cost of spawning a new process for each element. I'd not use it for generating the ScreenGrid. The main culprit appears to be the mand/5 function, which can be called up to 5000 times for each pixel in your sample run above, _and_ is maths-heavy. [http://paste.lisp.org/display/92851](http://paste.lisp.org/display/92851)
Yeah ScreenGrid was a remnant from another technique. Damn, I sure hope someone will be able to explain how to do it right. It seemed like a problem well suited to concurrent programming. One mistake is that I took a too haskellish approach by building the list first and then mapping over it.. in haskell this is just as efficient due to laziness. But I have no idea how to do it otherwise!
Yes, but in C this is about a thousand times faster, and isn't mand tail optimized? I would like to use Erlang in a situation where agents correspond with processes and each agent performs variations of the A* algorithm, with some maths involved. I'll check your optimisations but at first sight nothing seems changed on mand apart from the type check? Edit: I discovered the type check actually makes the code two times faster! I never saw this mentioned in Joe Armstrong's book. 
40&gt; timer:tc(mandelbrot, mandelbrot, [200,5000]). {19141000,ok} I got it down to 19.4 seconds now by removing the screengrid and the useless zipping: http://paste.lisp.org/display/92851#1 I guess that's acceptable. Of course the chaotic nature of the fractal doesn't allow optimizations like dictionaries. Maybe the program runs faster if you pmap on rows instead of individual pixels, I'll try that.
Yes, mand/5 (mand/7) is tail-call optimised. But tail-call optimisation alone will not make an interpreter as fast as native compiled code, especially for sequential number crunching. :-) If you know C, then perhaps this is a great opportunity to learn about Erlang's new NIFs? I did three things with mand: 1) Expanded all the tuples so that the VM doesn't have to construct and then expand them out at each call, increasing the arity from 5 to 7. 2) Reordered the parameters in mand/7 so that the arguments that get passed straight through to the recursive call are at the beginning. This allows the VM to re-use that stack space without needing to overwrite values to it. 3) Added type checks, which means that the beam code generated for the function body does not have to include additional checks and alternate code paths. You might like to peruse the [Erlang Efficiency Guide](http://ftp.sunet.se/pub/lang/erlang/doc/efficiency_guide/users_guide.html); I've picked up lots of hints from the Erlang mailing list, too.
Build and map at the same time. :-)
url changed: http://nealabq.com/blog/?p=953
Fragmenting a large existing table can cause out of memory crashes. Much easier to create a new empty table with all of the fragments needed, then copy your data over. Also be sure to set the mnesia env var {mnesia_access, mnesia_frag}, or you'll have to call mnesia:access with mnesia_frag as an argument.
Did you know about Kevin Smith's work on non-blocking servers when you wrote this? http://github.com/kevsmith/gen_nb_server
I'm very keen to see if anything comes of it.
Wow. This is going to add about 10 years onto my life. Happy programmer is happy.
If records are the problem then you are doing it wrong. There is only 1 single thing which is bad about tuples and that is when you upgrade an existing system and you have data in tables using the "old" format of the records. To say that removing pattern matching capabilities is "not a terrible omission" is such an understatement it is comedy. Pattern matching is probably the single most important reason why you would want tuples over other structures (gb-trees, dicts etc) and if you invent a new one intended to replace tuples it will never be used unless you can pattern match as effective as tuples. Interesting thoughts but the "need" to "fix" tuples seem fabricated and what everyone wants without knowing why.
You don't agree that the issue with Mnesia and upgrading record definitions is a huge one? In contrast to your statement and agreement with the article, I think proplists (i.e., his solution - [{k, v}, {k2, v2}]) are quite obviously the answer. Reasonably small due to the atom cache table, reasonable to search, easily permits "empties", easy to update/vary. Pattern matching is a requirement, though. Perhaps it would just be a matter of creating a relaxed BIF to handle searching?
Of course I do, it was the first thing I said.
I have to agree with mazenharake that not having pattern matching is definitely a terrible omission.
Pulled this function out from a [mailing list](http://www.erlang.org/cgi-bin/ezmlm-cgi/4/24959) from a while back because I've been needing to connect to various remote shells within emacs and needed to set different cookies and snames while doing so. Hope you find it helpful. Thanks to Mats Cronqvist for posting it to the mailing list.
I prototyped an approach to more 'dynamic records' when the index of a field within a tuple representing the record is determined at module load time. This approach is compatible with pattern matching compilation. When matching records of the same type there is no difference. Matching between a record and an arbitrary tuple will bear a small performance penalty as fields of the record values will have to be sorted first. Marginally slower module loading and slightly slower pattern matching in unusual cases brings no worries about record versions, no hrl files includes.
fantastic. finally a clean way to distribute erlang. My only concern is perhaps the lack of packaged libs and products. I haven't tried yet but I would assume that ejabberd, rabbitmq, couchdb, redis, etc. aren't yet part of erlware?
That was interesting. But what are they gonna do to fix the 10x slowness factor they still have in the end ?
Destroys? Really?
I still think that this is a joke to see what the Tom and the GitHub crew can get away with. Formalizing a protocol based on Erlang terms is ridiculous.
I *love* Erlang, and I'll follow this project closely, but this is pretty ridiculous hyperbole. At certain loads, and for certain functions, PHP will a) be faster, and b) be much easier to administer than Erlang. The vast, vast, vast majority of people who use Wordpress will have zero need for this, not to mention even having the capability. And the off-hand rips on RoR and django are off-putting to me as well.
Can't agree more. And when I read this: &gt; I checked out Ruby on Rails, I checked Django and some other frameworks. They promise a lot. They fall short when you benchmark their efficiency on modern cpus and server systems. How? What kind of test was performed? Because reading this later on: &gt; Informal benchmarks gave more than 6000 page requests per second **(famous helloworld templates)** on a low end server. That should be enough. Is not convincing (besides Tornado and Node.JS would do probably better in that example). &gt; As I often say, the best way to achieve high performance is to not hit the database. That's a given. Thank him for that. Wondering if he used that logic when he benchmarked RoR and Django. I also like erlang and think it's great for many things but using in that context makes me cringe. I'd rather try Javascript server side if really I wanted to fancy up my product.
He was talking about his own project, and the challenges he faces with different language choices. I'm straining to detect any hyperbole, perhaps lack of elaboration. He just tried stuff, and talked about the results. I don't recall him saying PHP was inherently slower than Erlang, he simply reported on what he tried and saw when implementing the feature set of his particular project.
&gt; On the other hand the deeply embedded dependence on PostgreSQL (SQL meta-programming in every model module) can be a turn-off if you want to leverage erlang distribution. I'm not sure what you mean by this. PostgreSQL is one of the most scalable free/open source SQL servers available. Erlang has some great scaling facilities, but its not magic. Can you expand on this?
Erlang has several distributed databases, including mnesia, couchdb, riak, and scalaris, with varying capabilities. They aren't sql databases but if they fit your needs they let you scale horizontally with very little effort. I'm guessing that's what he means.
I'm aware of the options for "distributed" databases in Erlang (although, I don't believe that CouchDB can really be considered "distributed"). I'm more interested in the OP's the belief that PostgreSQL is a poor choice to leverage erlang "distribution", because, in my experience, this is just plain wrong. PG is very capable of scaling, albeit non-trivial. With an appropriate driver, function-based access patterns, and careful partitioning (PL/Proxy or other), PostgreSQL and Erlang could be powerful allies.
&gt; I'm straining to detect any hyperbole "Zotonic destroys Wordpress and rethinks the CMS" doesn't strike you as hyperbolic?
Not meaning to diss Postgres. I like relational databases, I work with one all day, and good ones scale vertically quite well. My point is just that, if you want to scale across multiple machines, it's more complicated than, say, Scalaris, where you just plug in a new machine and it all works. The tradeoff is that none of the nosql databases have near the features that sql databases do. If they support what your app needs, they're good options, other times only sql will do. In any case it sounds like you have some intriguing ideas along these lines.
Yeah, that is hyperbolic.
No worries. I just hear a lot of hate for PostgreSQL and sometimes it sounds misinformed. The problems seen with scaling a relational system aren't often because of relational features or SQL. Rather, it is due to implementations and the impedance mismatch between normalized data and denormalized access patterns. In the future, we will see much better replication facilities in postgres, but I would also like to see automatic partitioning/sharding (like that seen in scalaris and others), and an intergrated implementation of a column store backend (like cstore or vertica). It would be nice to see some of this work in horizontel scaling be applied to postgres or something as mature. Its a vertical scaling monster, and has the components to scale outward, with some work. In addition, a standardized denormalized (or NoSQL) access pattern would really close the gap between pg and these next gen systems. In fact, I suspect that we will see a standardized (or de-facto standardized) REST data access pattern arise out of the couchdb project. And from my understanding, postgres preforms excellent as a key-value store, so this may be only natural. 
I don't have my work in front of my, but off the top of my head I tried something like this.... [http://gist.github.com/329817](http://gist.github.com/329817) 
Not much info there...what does it do?
Bend time and space itself... But seriously I'm not sure, it looks like mishmash of different utilities...telnet stuff, a midi library for OS X. I'm sure there are some gems in there, but it would be nice to have an index or something
I'm not sure I favor C++ readability over to erlang's.
sounds very painful. :) ~ anyway good luck.
He mentions in the comments that their newest code keeps track of some statistics about the queues, so they're basically tracking length (and other things) separately from the actual queue data structure. 
Good stuff, keep it up =)
Nice! I've been looking for something like this. 
Personally I'm not much of a fan of Erlang's syntax so I'll happily welcome a project like this. Prettifying (and extending) the record syntax is one of the smartest things anyone could have done.
Early April Fools?
No, its regular april fools for us not in the later timezones. The other side of the planet reads reddit too.
Oh, thank the sweet lord, I was about to cry.
Apress havn't got their book there anymore, no idea why.
This is my first try into the erlang realm. I have yet to find a good implementation of kd-tree in erlang. That maybe because its not practical, but I thought it was a good experiment to dip my hand in. Any feedback and criticism are welcome. What I am actually more interested in is what optimizations can be done to the kdtree library. My main bottle neck appears to be transversing the tree.
I'm not actively programming in Erlang, but I definitely have an interest in the language. There used to be a Meetup group around here, but I think interest dwindled. 
It's a little known fact that they can't survive outside of Sweden
You sure? I hear they can work elsewhere in parallel.
any opinion, question or review is really helpful.
lol
Looks clean so far. I have never worked with kd-trees myself. From a quick glance at your code, I would probably change the way you use sublist to build the tree. You're traversing the list 3 times: once to get the current value, once to get the left, and once to get the right. You can probably use lists:split/2 to get 2 sublists (and then get the first element out of the second one as your current value) or some more complex function inside a fold or a custom recursive function. Welcome to Erlang.
Woooooooooooooooooooooooooooooooooooooooooooooooooooooooo!
With Websockets on the way, is it fruitful to invest in Comet-based architectures anymore? I realize Websockets is still restricted to bleeding-edge FF 3.7b and WebKit dev chan builds, but that will surely change in a few months? EDIT: I'm glad to see that the Nitrogen project is using the term "full-stack" to describe this kind of integrating framework. Does anybody know of other places this term is being used? I'm doing my best to get people I know using it.
I know the pythonguys use it a lot to describe many of their frameworks. You have full-stacks (providing solutions every step of the way), glue frameworks (bundling a bunch of existing libraries) and whatnot. The terms are standard enough.
What do you mean "change in a few months"? The web doesn't work that way. You can't just start using a feature as soon as it's in a stable build on only a couple of browsers. Basically, until Internet Explorer supports web sockets, and the majority of users are actually *using* that version, comet isn't going anywhere.
Nitrogen wraps the comet interface in erlang message passing. Websockets are actually a much easier implementation model for nitrogen. I imagine the next version or so will see Nitrogen using websockets where supported.
Why did you choose the C style syntax? I kind of like the ruby style syntax of reia. Seems a little easier to read to me.
Got another question... does using something like this have a performance penalty? Any downsides at all? 
efene generates almost the same bytecode as erlang, in fact if you run "fnc -t erl file.fn" you will see the equivalent erlang code, so I will say the performance is the same. in the only place where performance may be different is in the object notation, because erlang doesn't have anything like that, but the cost for any operation is a function call so not so bad :) since you can get the equivalent code and it's almost one to one I will say that the performance is the same.
a lot of people come from C like syntax languages, so it seemed the best way to reach a broader audience, a more python/ruby syntax is something I would like to work on, we will see.. :)
That's really great. I read your spec and I really like your syntax better than the erlang syntax especially when it comes to defining functions. I also noticed that your implementation is further along than reia (which is another one I was thinking about). I bought the erlang book and half heartedly tried learning it a couple of times and it still bugs me once is a while that I haven't learned it. Do you think using your language would be a help or a hindrance? I am thinking it might be easier to from erlang to efene rather than the other way around. P.S. I am pretty sure if the community got behind something like your language erlang would become more popular. 
Why not join the reia project and help them out. I think they are struggling in finding time to work on the project. 
the idea behind reia is to add some features like destructive assignment and other things that I don't think aren "the erlang way", efene is just another way to write erlang programs.
I don't have any problem if efene is just a step towards learning erlang, but for me was just like you, I struggled with the new concepts *and* the syntax, you should pick one fight at the time, you may learn the concepts using efene and then try to learn the erlang syntax when you fill confident, or you can translate efene modules to erlang automatically and read the code to improve your understanding. after coding in efene for a while I feel that my erlang coding has improved (efene is written in efene, so I code primarily in it).
Got it thanks. 
Thanks for all the info. I hope the erlang community embraces your project and uses it to gain more members. Erlang seems to me to be only functional language that people can use to actually do something. The rest of them seem to be good at mental masturbation and puzzle solving more than anything else.
Nitrogen is one of the most exciting things happening in Erlang land, from the "lowly developers" point of view. Good work guys.
The short answer is that you should not be doing your matrix operations in Erlang. The longer answer is that you should find a nice C library for doing the matrix operations that you like and offload the matrix operations to this library. Start by doing a quick google hunt for information on the new erlang nif interface for C code, then set aside an hour or so and grab the presentation slides and video from Cliff Moon's talk at the recent SF Erlang Factory conference. He explains the general decision tree for nif vs. linked-in drivers and walks through an example of wrapping up some C code in the nif interface. The general strategy here is to use erlang to manage the system and coordinate/marshall the data but use the highly-tuned C code for the heavy lifting on the matrix operations. 
oh that sounds great, we already have a couple of C libraries we use for matrix operations but I didn't think of integrating it with Erlang. Thanks for pointing me into that direction!
I've used numpy before, but I had never heard of zeromq, it sounds very interesting I will definitely take a loot at it. I haven't looked into Python vs Erlang performance but I would have thought that Erlang would be faster... I guess the purpose of those two languages is very different and its going to vary on the type of application. I'm very interested in the distributed/concurrency part of erlang. I already know that if I were to write my C programs multithreaded and run them on the farm they would be much faster than erlang. But the reason why I'm going towards Erlang is because I feel I could save so much time developing since Erlang already has a lot of features that were developed with concurrency in mind. I'm going to try writing a simple NIF to do simple matrix operations (multiplication/addition) and benchmark it against numpy. The current piece of software that I'm writing is not so much of "high performance scientific commuting", rather its just A LOT of data that has to get processed and occasionally there is some matrix operations. I'm willing to sacrifice 'some' performance for some peace of mind while developing :) In the entertainment industry (visual effects/commercials/film... etc..) there are a lot of TD positions (technical directors) TDs usually do both, 3D/2D (Artistic stuff) and Programming (more technical stuff). A Pipeline Dev, or Pipeline TD is someone who works on the tools that are used through the "pipeline" (getting from one piece of software to another for example). Here is [job description](http://www.vfxtalk.com/forum/pipeline-manager-t14721.html) so you can get an idea of that they are responsible.
Hey newb.erl here. I still need to man up and finish up that vim tutorial. So for now I am using SciTE as my IDE, and it is totally awesome. It took me a little while figure out how to compile and execute code from it, but it it totally worth it for me. 
Hi, i'm also erlang newbie. I started with notepad++, and then tried emacs. now i think n++ really sux. So either you will find some good scripts for vim, or just start using emacs (you can use emacs for erlang, and vi for rest)
I assume you are referring to [BLAS and LAPACK](http://www.netlib.org/).
I use vim all the time for Erlang. The syntax highlighting as a bit annoying at times (depending on the version you have), but I find it does everything I need. Of course, emacs with distel is much more advanced and can do instant syntax checks and highlight errors for you. I found it useful to set myself a few shortcuts in vim to do equivalent stuff from the CLI - compiling, running unit tests, reading skeletons for some modules from my home directory, running type checks with dialyzer, etc.
HELLO
I think building the library you describe would be a great way to learn Erlang from top to bottom! Start with just the math operations in the simplest way you can implement, then transform them into the most efficient Erlang you can using the profiler, then learn about embedding by porting specific parts to C. Then release the Erlang Imaging Toolkit and get rich and famous and be seen at all the best Hollywood parties. What fun you will have. Don't listen to people who say you can't do this or that in Erlang. You can do anything you want in Erlang. 
you are correct sir. Atlas, which includes BLAS and LAPACK. I started messing with NIFs today. So far so good, I'm just figuring out the basics, getting data in and out. Its very similar to writing MEX files for Matlab. Maybe once I have something decent I'll put it up in github so other people can expand (and correct/optimize all my C code :p )
hehe nice, the geek roaming around in the Hollywood parties. upvoted for the vote of confidence... I'll probably make it open source though... 
I'll suggest something a bit different...gVim :P
http://dukesoferl.blogspot.com/2009/10/linear-programming-with-erlang.html http://code.google.com/p/glpkerl/
I'm the creator of efene/ifene, any question or observation is really helpful.
Do you have any stats regarding how many people use efene?
the project has only 4 months, AFAIK no one is using it seriously, but that make sense since this is the first release that I consider usable. I need to focus on documentation and making easy for people to try the language. if someone help me to spread the word about the project that would help ;)
Well I've been quietly working on an annex for Learn You Some Erlang where I get on the question of ugly syntax. I could eventually add something about efene and LFE, maybe reia too.
you are the creator of Learn You Some Erlang? It is a great tutorial! I was thinking on writing something like that for efene, I find the way you write really easy to follow. congratulations for that!
maybe the chicago boss BossRecords? http://www.chicagoboss.org/api-record.html
What do you mean by ORM? There are no objects in Erlang. Mnesia is a database for tuples.
I realize there are no objects. I meant a higher level way of dealing with databases rather than scattering SQL all over the code. 
Encapsulate your sql in a single module?
That, and probably don't use an SQL database with Erlang. Mnesia is a much better choice if you need a relational DB. Also, you've got the qlc module (http://www.erlang.org/doc/man/qlc.html) for doing list comprehensions over a database table.
[erlyweb](http://erlyweb.org/) includes a database abstraction layer. Here's some [example usage](http://github.com/yariv/erlyweb/blob/master/test/erlydb/erlydb_test.erl).
Aren't there limitations on Mnesia like how much data it can hold?
Correct. Some info here: http://web.telia.com/~u83304791/erlang_faq/faq.html#AEN1402 But still, putting the sql in one place is a better plan than scattering it about your code.
Thanks for the suggestion. I'll look into adding it. I've recently added an example usage to the project, so people can see how I've used it.
Not that I have tried yet, but it would be really syntax friendly to be able to change the response calls to something like this. Response = response(Req, Root).status_code(200).header("Content-Type", ContentType).data(Data).build_response() or with whitespace/indenting: Response = response(Req, Root) .status_code(200) .header("Content-Type", ContentType) .data(Data) .build_response() To me this just looks cleaner, rather than having to assign RequestN variables all the time. Of course to do this you would have to imply a coding convention.
Chicago Boss has the beginnings of something like an ORM: http://www.chicagoboss.org/api-record.html If you end up writing one, keep me in the loop: Erlang's dynamic capabilities seem like a good fit for this.
I am just contemplating starting to learn the language. I am intrigued by it, I bought the book and like the concepts behind it but I find the syntax horrid. Being a ruby programmer I am also spoiled by effortless string handling, expressive code, a massive library that is easy to install and upkeep, and just a general ability to quickly get shit done. I realize ruby has certain shortcomings and erlang as lots of strengths. The ruby community has made a few attempts to bridge the two so that gives me some encouragement.
What is so special about this one?
There are two fundamental sources of Erlang's quirks: 1) Actual language weirdness - things like every statement having to return a value (i.e., the one-branch if problem) ain't going away. 2) Age issues -- things like Ruby Gems will eventually be available, as will better documentation. In fact, these are good things to work on if you need a project!
My understanding is that the lack of proper namespaces kind of hinder a proper package management system.
How so? http://www.erlang.se/publications/packages.html
as always, any question or opinion is more than welcome. (I'm the programmer of efene)
I think it's very cool myself. Anything to make erlang a little less obtuse and a little more readable is very welcome. I hope the erlang community is embracing your efforts. 
I think they are at least taking it into account http://www.erlang-factory.com/conference/London2010/speakers/MarianoGuerra :)
That's great. Congratulations.
How do you maintain compatibility/provide an alternative syntax while adding objects to efene? It seems like both features are contradictory.
objects are something like "glorified closures", you can read more here: http://marianoguerra.com.ar/efene/docs/reference/statements/object.html if you have any doubt just ask.
Ah, that's clear enough, thanks.
qlc and MNesia. It lets you write what I think looks a bit like LINQ for Erlang.
Are you expecting your language to remain forward compatible ? (For most parts ?)
yes, I think from now on I will add only new features that don't break compatibility. unless you have a good reason right now to break compatibility, people won't start using it if they know they code will break.
viper emacs+vi
It'd be nicer if it didn't auto-forward you. Perhaps the user wanted to try some more arithmetic operations etc? Otherwise, a fun if not very very basic tutorial. Still, fun!
Very nice, although I think you should change the text &gt; and to have it evaluated type Enter.! to &gt; and to have it evaluated hit Enter!
Please be forgiving when I ask this. I'm a beginner and sometimes I get screamed at for asking stuff like this (not the Haskell guys, they are pretty chill)... Am I looking at a reference for all the stuff that comes built in with a standard Erlang installation?
hah thats no bother, http://erldocs.com/R14A/ is a function reference for all the stuff that comes with the erlang install (R14A is the erlang version, you can pick old versions R13B04 etc as well), its basically just a different presentation format for the same information you will find on the official erlang docs. http://erldocs.com/R14Aextra/ has some extra libraries not included with normal erlang, this is more for an example of building custom docs
Who "screams at you" for asking what you're looking at?
Just someone in the Ruby IRC channel. No big deal, I was exaggerating about the screaming thing. I was having a lot trouble with regular expressions and I think I pushed the limit of the person's patience. I really tried to figure this stuff out before I asked. Regex just fries my brain. Especially if I see an entire string of it. On the other hand I know what it can be frustrating trying to explain something that's really simple to you to a curious beginner.
not to be facetious, but i use emacs. It has a very good series of functions to make coding faster. For instance when defining functions within a module if you press ';' at the end of a clause instead of '.' and it duplicates the function signature on the next line with the cursor in the empty argument position. 
Grabbed from this presentation: [Erlang - software for a concurrent world](http://www.infoq.com/presentations/erlang-software-for-a-concurrent-world)
how about these: http://medevyoujane.com/blog/2008/8/21/erlang-make-rake-and-emake.html http://zhekov.freehostia.com/blog/2007/06/25/erlday3/ http://spawnlink.com/articles/an-introduction-to-releases-with-erlybank/ http://blog.poundbang.in/post/55528718/writing-and-deploying-non-trivial-erlang-apps http://spawnlink.com/articles/managing-application-configuration/ 
OTP apps: http://www.trapexit.org/OTP_Release_Handling_Tutorial http://streamhacker.com/2008/11/26/unit-testing-with-erlangs-common-test-framework/ http://www.erlang.org/doc/design_principles/release_structure.html#10.5 
gtani7, thanks for all the info. After I digest some of this, could I follow up with a few questions?
Use rebar, it's awesome. Here is a screencast: http://vimeo.com/8311407 Edit: a tutorial: http://www.alancastro.org/2010/05/01/erlang-application-management-with-rebar.html
ocourse! i forgot about rebar (thx alekseyiam), tbuild and erlware, lots of erl build systems in goog results http://www.erlware.org/erlware/index.html http://code.google.com/p/erlang-t-build/ 
Amazing, thanks alekseyiam
There's a couple more articles on streamhacker related to release handling &amp; upgrades: http://streamhacker.com/2009/07/02/how-to-create-an-erlang-first-target-system/ http://streamhacker.com/2009/07/15/erlang-release-handling-with-fab-and-reltools/
I wouldn't waste too much time reviewing all of the options. Just use rebar. It's simple, awesome, new, actively developed and built by the guys who recently brought us webmachine and riak.
Why are there so many? Wouldn't it be better for the noobs to have one "blessed" way to do this? 
I wrote the article on medevyoujane.com and my opinion now is that you should just use rebar. It's by far the best way.
anyone have much experience with riak?
It would be handier if they called it something like 'ertop' since there already exists an '[ntop](http://www.ntop.org/news.php)' application for monitoring networks.
Actually I renamed it to entop now because of that issue =), blog post about that [here](http://mazenharake.wordpress.com/2010/08/16/renaming-ntop-to-entop/)
It would be nice to have some detail on how this was done.
I'm trying to figure out how to extract the requesters IP address from the HTTP request. I am guessing I need to use a different packet type other than the stock "http_request". Suggestions? Here are my [tcp options for the listener socket](http://github.com/zpeters/itty/blob/d30cfcc879fe44f2887fc62209ce22c0d142d1a8/src/itty.erl#L4) and [here is where i'm receiving](http://github.com/zpeters/itty/blob/d30cfcc879fe44f2887fc62209ce22c0d142d1a8/src/itty.erl#L44) the http request. Also, any general "you're doing it wrong" recommendations are very welcome, though to keep things conceptually simple, I want to try to stay away from OTP for now. 
Why can't you get the IP address from the socket?
I think you are looking for this: inet:peername(Socket) -&gt; {ok, {Address, Port}} | {error, posix()} Full documentation: http://www.erlang.org/doc/man/inet.html
I'm thinking it's because i'm using the "http" packet type rather than "raw". When i do a gen_tcp:recv the response is {ok, {http_request, HttpMethod, HttpUri, HttpVersion}}. I perhaps there is something other than "http_request" i need to be looking for the get the fully http headers?
I will look this over thank you.
you don't receive the ip address on the socket. Listen to the advice already posted and use inet:peername(Socket). {ok,{IP,ClientPort}} = inet:peername(Socket) that will do the trick. Insert that line someplace after you've done gen_tcp:accept/1, assuming that Socket is bound to the socket that accept/1 has returned.
Thank you. This makes sense to me know. I wasn't sure where to place this
it worked perfectly, thank you
it worked, but it took some explaining from aliud_alius until it made sense.
no prob, glad it worked out.
When is Erlang going to hipe-by-default? Having native code compilation and having it be completely useless because stdlib isn't native and switching from interpreted to native is expensive seems really silly.
I'm the creator of efene, let me know what you think.
here is more information http://efene.tumblr.com/post/1145436694/more-on-efenes-structs
to not spam the erlang subreddit with post about efene I add a new blog post here: http://efene.tumblr.com/post/1146316926/a-little-more-object-oriented
I think it is usefull.
Is this implemented using proplists? I really like the syntax - I wish the Erlang crew would adopt something similar. Not a big fan of records.
yes, it uses proplists. the internal representation is the same as mochijson. right now the internal representation is really hidden from the user, you should be able to do anything you want without knowing about the internals of a struct. since structs should have a low number of fields using a hash table or similar is an overkill. I also like the fact that no transformation is required from and to JSON through mochijson.
file:consult("Filename"). look at how ejabberd.cfg works, you just parse config file as erlang terms 
Stackoverflow.com is probably a better place to ask how-to questions, and reddit for links to great web pages about erlang.
Just use app.config and application:get_env/1,2.
Also trapexit.org.
You should not worry about spamming erlang. This place doesn't get much traffic anyway. 
Read for the erlang, upvoted for the "ball ache"
Also if you prefer simpler configs like the good old .INI file you can check the CouchDB source. It's pretty nice. http://github.com/apache/couchdb/blob/trunk/src/couchdb/couch_config.erl http://github.com/apache/couchdb/blob/trunk/src/couchdb/couch_config_writer.erl
The problem with proplists is that you have O(n) complexity for lookups and as much for rewrites, while tuples allow O(1). There are other suggestions to replace records that are much better than proplists. See Richard O'Keefe's abstract patterns (http://www.erlang.org/cgi-bin/ezmlm-cgi/4/10060) or Joe Armstrong's structs (http://erlang.org/pipermail/erlang-questions/2003-January/006683.html)
I agree about proplist's performance weaknesses -- and I think you forgot to mention that aside from being O(n), it's a really painful "O" due to the tuple unpack and then atom match -- but structs usually have few values. I merely said I prefer using them to records. The fact that they can store erratic values that don't conform with the struct definition also makes them more useful to me in practice. As for Joe's structs and 'abstract patterns', it doesn't seem like the Erlang crew will ever implement them after all this time, so why even think about them?
&gt; "Amazing how you can write a compiler plugin..." - John Hughes. Macros, dude. 
Erlang has macros (in the C sense), and also parse transforms. Parse transforms are closer to macros in the lisp sense, where you use Erlang functions to modify an abstract tree rather than an extension of the language to do it. I guess he sees parse transforms as closer to a compiler plugin, especially given Erlang's compiler is written in Erlang or something
Yes, exactly. OCaml also has macros (meaning parse transforms) that are quite literally a compiler/REPL plugin. 
Being able to change the meaning of the code from the AST downward, before error checking, kind of is like a compiler plugin though when you think about it, maybe more so than say a lisp reader macro, but I guess it depends on how you think about it. Of course the man pages say "don't ever do this because you won't get support from anyone" with parse_transform, so I don't think it's genuinely useful for anything I'd want to put my name behind supporting. 
Nice to see link to my product here =)
Please make the webpage less atrocious!
Altough the headline is a little misleading (the talk is actually more about the roots of erlang and comparing its concurrency model with those of closure and haskell), it's a very interesting talk.
I don't know what the hell he is talking about in #6. It seems like pretty straight forward pattern matching. Edit: Actually, I think I understand. He thinks the #record should expand out to a full record just like everywhere else, even in the pattern matching section.
Very interesting talk.
Excellent.
Nice Article
Why does every single new Erlang framework choose to depend on parametrized modules?
I'm picking up Erlang and this was excellent. A couple of issues: * the tutorial jumps to the next step even when I have not tried all the suggestions of the current step. this is annoying because.. * there is no way to go 'back' to the previous step. I tried typing 'back.' and 'next.' - if they worked it would be awesome. 
For higher loads, the socket worker may not block, but accept other HTTP connections and spawn other workers to serve them. That was my thinking anyway, I'm still new to Erlang and can't say I 'think in Erlang'.
You would have one process that create new acceptors as the existing ones accept a connection. That way the connection process can delay as much as it wants without delaying any other activity. 
If you use a webserver like Mochiweb, each request is handled in its own process. That process should take care of the entire request for a single user, including rendering. Since it's one process per user, if another user comes in during some long running request, Mochiweb can simultaneously handle both users
AFAIK message passing is core to the Erlang concurrency model which is what Erlang is known for. I expect it's one of the most optimized message passing systems that exist.
You should probably be using OTP and the gen_server behaviour. Have you read this? http://www.trapexit.org/Building_a_Non-blocking_TCP_server_using_OTP_principles As you kick off a new process to handle the request, I'd suggest just passing around the socket as part of the state and sending output to it directly rather than "returning" a result. From an architectural point of view, Erlang doesn't really lend itself to that kind of paradigm (ie: make a function call or call to a subsystem and get a result). It favors just passing the current state to a subsystem, which then passes the result to the next subsystem, etc. Also check out google code, you can filter by file types. Check out mochiweb like others have suggested, or search for the primitive networking prefixes like gen_tcp:
You should shift your thinking from "one process per concurrent task" to "one process per concurrent activity". The O'Reilly book does an okay job of describing the difference. But basically, it's exactly what's being described here. Rendering your HTML and serving your request aren't concurrent activities, because one can't proceed without the other. However, serving multiple clients are concurrent activities. So, much like Mochiweb, Yaws, and every other Erlang HTTP server out there, you should be spawning a new process for every concurrent user.
Oddly enough, they found that it's cheaper to copy small data structures from one process heap to another than to use zero-copy messaging. Larger binary data is allocated in a node-global reference-counted heap, and processes just pass pointers to it. So, yeah, it's fast.
Cool, how does erlang decide what's big and what's small? Also, how does this work across processes on different computers?
erlang decides by comparing binary size to some number. if you pass message to process on another machine - message gets copied.
you are trying to solve the problem that you do not have yet. stop that, make a prototype, load-test it and then decide if the problem is message passing or something else. 99% chance it will be something else ;)
Ok that makes sense. If while building the HTML, I need to pull data from two different remote sources, should I spawn two processes for that so they can go in parallel?
Invaluable stuff, wish there was more of it. It also has a plugin providing a confluence macro.
This is really cool! :) Do you know something like this for ER diagrams?
http://code.google.com/p/clojure-textflow/ http://www.reddit.com/r/programming/comments/dvf2b/protocol_flow_visualization/ 
that's not easy to answer, because it depends how long the operations last, if one lasts long but the other does not and so forth. Build the solution that is easier to implement. Build a process agnostic API. Make it work. Profile. If unhappy, change the behaviour behind the scenes. Processes are really efficient in Erlang, but they are still overhead. Using unnecessary processes will slow your program down.
Same as the difference between a speedboat and a battleship.
I UPVOTE BECAUSE I FUCKING LOVE JQUERY
http://farm4.static.flickr.com/3152/2641516811_ae293e7576.jpg
Are you running through the old caltech projects (http://www.cs.caltech.edu/courses/cs11/material/erlang/)? I'm new to erlang too, and that's how I've been teaching myself, and this looks oddly familiar... For what it's worth I pretty much had the exact same code for this one, but I'm no expert.
Yup :). I asked around on #erlang too, the comments they had were: * indentation: better to move things after -&gt; into a new line * too deeply nested: move things in sieve into different functions 
Here's the most important thing I've learned after a few years of Erlang programming: although using "receive" is interesting for exploratory programming, most real projects end up using one of the gen- modules (usually gen_server) -- the reason being that they play nice with OTP supervisors. That combination of supervisors and gen- behaviors is too useful to give up in production code, even if it feels like you are putting in a bit too much boilerplate. You clearly have a decent handle on the basics of Erlang programming, so my main suggestion would be to learn a bit more about OTP by re-writing your code using gen_server and supervisors. Minor additional thoughts: It doesn't matter here, but in general I find "~p" a better default than "~w" in io:format strings. If you reverse the order of the two clauses in sieve_helper(), you can get rid of the "when is_number". Although it's not necessary, it might be good practice to rewrite your state tuple as a record. 
Steven, thank you for taking the time; this is exactly the type of comment I was looking for. &gt; If you reverse the order of the two clauses in sieve_helper(), you can get rid of the "when is_number". But then anything that isn't a {done,PID} type message would be handled by that case, and we could get a badarg when we do rem. Is that a good idea? (Genuine question, because I'm not really sure how defensive we're supposed to be when programming in Erlang and how 'let it fail' fits into all this'). &gt; It doesn't matter here, but in general I find "~p" a better default than "~w" in io:format strings. I didn't know about ~p. I should read the BIF docs more carefully. It does seem to be a better fit. &gt; Although it's not necessary, it might be good practice to rewrite your state tuple as a record. Is this for generateH? I'm already using a tuple for sieve_helper. Related, is there a naming convention for these helper functions? &gt; You clearly have a decent handle on the basics of Erlang programming, so my main suggestion would be to learn a bit more about OTP by re-writing your code using gen_server and supervisors. Do you have any recommendations for resources? Do you know if the recently released "Erlang and OTP in action" book is any good? Also, what about the Oreilly book? I'm currently learning Erlang via the Caltech course ( http://www.cs.caltech.edu/courses/cs11/material/erlang/ ), and my plan was to work through Armstrong's book after this, and then learn some OTP stuff. I hope you don't mind the zillions of questions. Thank you so much for your help.
&gt; But then anything that isn't a {done,PID} type message would be handled by that case, and we could get a badarg when we do rem. Is that a good idea? Meh, you get an exception either way. I wouldn't bother. Others might. &gt; I'm already using a tuple for sieve_helper I just mean that the tuple in sieve_helper could also be represented as a record. It's not obviously any better, but it's another technique to get practice at. &gt; Related, is there a naming convention for these helper functions? Not that I know of. But one interesting trick you could use is to give the same name, since functions with different arities are considered different. So you could have: sieve() -&gt; ... sieve(State) -&gt; ... You see this in some Erlang code. Sometimes it makes things clearer, sometimes more obscure. Use your judgment. I haven't read the new book yet, but the other two are both good. I think any of them would be a good resource for the basics of OTP supervisors. That, plus reading the supervisor and gen_server man pages carefully. Supervisor, in particular, usually requires a few tries to get right, since there are so many data structures and callbacks.
Thank you for your clarifications. 
my contribution about this https://github.com/germanlinux/Lemon-labs/blob/master/Erlang/prime.erl https://github.com/germanlinux/Lemon-labs/blob/master/Erlang/crible.erl my post about http://germanlinux.blogspot.com/2009/11/crible-d-eratosthene-en-erlang-nombres.html thanks
Instead of this: sieve() -&gt; receive N -&gt; sieve_helper({N, {undefined, undefined}}) end. and this: StartSievePID = spawn(sieve, sieve, []), StartSievePID ! 2, Just call `sieve_helper` directly with the appropriate args. Also keep in mind that this isn't the sieve of eratosthenes, it is much much slower. See (PDF): [The Genuine Sieve of Eratosthenes](http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CBcQFjAA&amp;url=http%3A%2F%2Fwww.cs.hmc.edu%2F~oneill%2Fpapers%2FSieve-JFP.pdf&amp;rct=j&amp;q=the%20real%20purely%20functional%20sieve%20of%20eratosthenes&amp;ei=KY4PTcOpEoP68Aafq6W6DA&amp;usg=AFQjCNGOOSToQwGoVyv3UneQ2oW6uGipvA&amp;cad=rja)
it's an interesting accomplishment, though one of questionable utility on current devices. does it use erjang?
No, I'm pretty sure they compiled it using the NDK, so it's running on the actual hardware, rather than the VM.
Here's the article: http://jlouisramblings.blogspot.com/2010/12/response-to-erlang-overhyped-or.html
woops, thanks for that.
... Where is it
resubmitted, now with the link.
resubmitted. now with the link.
my ereader loves you! many thanks!
[QR Code](http://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=http%3A//dl.dropbox.com/u/4663634/Learn%2520You%2520Some%2520Erlang%2520for%2520Great%2520Good%2521.epub&amp;chld=H|0)
interesting. i'll be watching this
You are correct. We did compile Erlang using the toolchain provided with Android. 
Erlang has the additional problem, in the U.S. at least, of having been born in Europe. You know, if it didn't come from Silicone Valley or Seattle, it's not worth a shit. I was really saddened by the lack of Erlang coverage at QCon SF. 
For the matter of erlangs scheduling, I'd also like to add that the erlang VM does a lot of other clever things when it comes to scheduling, like slowing a producer process that produces messages too fast down, if the receiver process can't keep up. This basically eleminates the need for manual flow-control mechanisms to prevent OOM problems.
A good article. I can also recommend Fred's online Erlang "book" http://learnyousomeerlang.com/ . It contains a lot of good stuff and it just keeps growing. And I am trying very hard to stay out of the Erlang syntax discussion.
Hard enough that you had to invent your own :V
A good article indeed. I found very interesting the "lack of types" part : coming from ML, I am often disappointed by Erlang. Does anyone have a good tutorial on success typing and automatic checking with Erlang related tools ? I once tried dialyzer but couldn't manage to check anything.
Didn't notice his user name until I saw your comment :) Thanks for LFE rvirding. LFE fulfills one of my long standing wishes. Having a lisp on erlang VM. 
Glad you like it, it is still being developed. And as erjang is coming along very nicely there is now another lisp on the JVM.
Of course, just to remove some the very tiny blemishes to vanilla syntax and add a decent macros facility. :-)
I'm not sure there are great tutorials out there. There's Francesco Cesarini and Simon Thompson's book that cover it, and then the user guide in the standard documentation. Then you have the typespec chapter linked in the article. Otherwise, it's pretty much try and learn as far as I know. The hardest part of Dialyzer is understanding the error messages that are sometimes pretty damn obscure.
I really want to like Erlang. I agree that the semantics and basic design of the system are the greatest thing since sliced bread. I've even written some non-trivial code in it. But the god awful syntax makes the language basically unusable. You seriously can't have a functional language without an "if" expression that allows arbitrary calls to user defined functions in conditions. And the punctuation thing is terrible too. Further, the failure to integrate hipe just isn't cool. The infrastructure exists to make every erlang program run an order of magnitude faster, and it just hasn't been hooked up so it can be used. I really hate to be "that guy". In any other discussion I'd be posting about how big an idiot anyone who's whining about language syntax or speed is. But, with Erlang, the syntax really is that bad.
It's a perspective thing really. I got used to the Erlang syntax in a couple of days and now I quite like it actually. Same as I did with the Objective-C syntax. The Smalltalk syntax took a bit getting used to but I learned to respect it. But for some reason I just can't stand using or even looking at the syntax of Python or Lisp dialects. I find Lisp especially hard to use and confusing to read. But some people really really love the syntax of those two and count it as those languages strengths.
I have to agree with you. Experienced erlang users seem to look down on people who complain about its syntax, saying things like "you'll get used to it" or some crap about semantics. The fact of the matter is they've just grown numb to it. Don't tell me that it's erlang needs 3 different line terminators and can't use user functions in ifs. And don't get me started on the ugly record syntax. Yes, I know it's just tuple sugar, but having the runtime understand the record type could have been done. Instead, they opted to implement them as compiler hackery. The reason people hate erlang's syntax is *not* because it's different. It's because there's a ton of unnecessary crufty parts of it.
I don't use erlang but I have the book. I just can't get myself to start using it. At this stage I don't think it's because of syntax but because I see myself having to rewrite a ton of stuff that I get "for free" when using ruby. Now if synax is a problem then maybe something like efene is the answer. Nice, clean, easy to understand syntax. The problem is that all the libs are in erlang so you'll need to at least learn how to read erlang if you want to get anything done. 
1. They're not line terminators, they're expression separators. The '.' period ends forms (function definition, module attribute). The ',' separates expressions and ';' shows an alternative branch in an expression or a form. See *[On Erlang's Syntax](http://ferd.ca/on-erlang-s-syntax.html)*. 2. 'if' is more of a misnomer than anything. The correct word would have been 'guard'. That's what they are, really: inline guards for when a 'case ... of' is too much work for nothing. Guards have specific rules and are a bit like a sublanguage within Erlang. What is needed is anpther construct, 'cond' (which a reserved but unused word in Erlang) to allow basically the equivalent of nested 'case ... of' with boolean expression. Similar to the Lisp cond, if you wish. 3. Damn right the record syntax is ugly. Nothing to say there.
&gt; I see myself having to rewrite a ton of stuff that I get "for free" when using ruby. Any examples here? Erlang's standard library is pretty big.
I am specifically thinking about the hundreds of gems and rails plugins that I use on a daily basis. You get a ton of very complex functionality by typing gem install blah. 
Always like new ways to look at things. But I have a question, why not just do a recursive loop that takes a list say ["post","title"] and get back "Destructuring JSON in Erlang Made Easy" ? That, if anything, is generic. Now you can ask for ["post"] and you get {struct, [{"title", "Destructuring JSON in Erlang Made Easy"}]} back. In the case of a list you could just have a notation like ["fruits", 4] and it would return the value of the 4th fruit OR ["fruits", 4, "price"] would return the "object" for the price of the 4th fruit. But I'm probably missing something.
I love javascript. I'm writing a little 2D game engine in JS and I'm super happy it hums along at 60fps rendering graphics to a webkit canvas on iOS with Phonegap. It feels just like a native app but I can write it with the speed of js. Haskell has always been a huge interest to me. I think Haskell is completely awesome, speaking from the little experience I have with it. Then I see this post. Why is something so simple so difficult in Haskell? And why does it require so much more typing (as in pressing keys, not "Types")? 
It does seem like an insanely complicated process to go through just to decode a JSON file. 
Considering the author wrote a reusable module for any JSON decoding, I think the code isn't that complicated. 
Compared to most other langauges it is very complicated.
I just came to work and obviously I won't be able to work on it from here. But I'll give you a few pointers on how to look at Erlang in general. * You are using pattern matching waaaaay to little. Try to use it much more. * Use lists:member("foo", ["foo","bar","baz"]). * If you are going to use lists:any then test evertyhing you want to test in one predicate E.g. the function checkBreaks sanity.erl line 21 * Name your functions lowercase_underscore_something instead more * Don't use {error, "Msg"} everywhere, this creates a lot of case clauses you have to handle everywhere. Just crash and catch at the top. * noodle.erl L46: use timer:now_diff/2 * "Erlang is pretty slow when dealing with strings (they're stored as lists of ints, ugh)," Nooo that is not true. YOU are slow when working with how Erlang works with strings ;) There are a lot of optimisations to do. There is a lot more I could comment on but you're off to a good start! I just quickly browsed through your code on the surface. Welcome to Erlang. You should however at some point rewrite the whole thing in proper OTP so that you get supervisors and the like in there because now it is not fault tolerant at all. When I break it by joining 10000+ channels each named strings of 93 characters long it will eventually break. Sorry to hear about your job application though.
All great points, the string comment was more so in reference to my sloppy implementation and a few things I had read, I think I've got a little more insight into how to work with strings since I wrote this. I've also just seen the light in reference to pattern matching, it just took a little prolog to open up my eyes :) I intentionally stayed away from OTP related things in building it, as one of the stipulations was "no preexisting frameworks" and I felt gen_server at the least might violate the spirit of the rule, if not the rule itself. Coming from a mostly JavaScript and Python background, I have to say, Erlang is an awesome language and now that I've somewhat grasped the concepts, it makes a lot of sense. I was amazed at how quickly I could take a concept and translate it into Erlang. Maybe it just hearkens back to my days of designing relay-based industrial control panels, but it seems like a much more logical and concise style of programming than JavaScript or Java. Thanks for the advice!
You might be interested to look at my chatserver on github, its fairly complete and well-tested, and allows for pluggable chat-protocols and transport layers et cetera: [click](https://github.com/whoppix/crumbled). When I get back home later today I shall look somewhat closer at your code and see if I can find anything that could break.
To be honest, you probably didn't get the job because they didn't know how to get it working. 
This isn't a decoding class. The JSON is decoded by mochiweb_json. This is a convenient querying tool for querying data in the resulted object in a JavaScript like manner. Some languages like Ruby, JavaScript have dictionary-like types so things like this is built into the base system while other like Erlang, C, Objective-C &amp; others don't have a dictionary so this get's more complicated. Also. Decoding JSON in other languages is not any nicer. You simply use other peoples code to do that so you don't know what is happening. Unless you are saying you always write your own Ruby JSON parser instead of just using JSON.parse()?
Missing commands/expressions in what has been covered IMO: * ctrl+G while in the shell * -include(...) and -include_lib(...) Nice list otherwise.
 a course I'd love to take, just have to apply to UPenn first: Programming Paradigms: Prolog, Erlang, Clojure, Haskell, Scala. http://www.cis.upenn.edu/~matuszek/cis554-2010/index.html
Beware that these "at a glance" courses tend to be so superficial that you really can't get your nails down under one of them. Rather, look for courses which delve for 8-15 weeks into Erlang, Haskell or Prolog. Those will teach you something worthwhile. In my book, Clojure and Scala will teach you less - but they are still good languages to pick up over time.
From the docs, the 'fail' case presented here is the expected behavior (OP says the opposite). This is because gen\_server is meant to be used in a supervision tree, and so the gen\_server traps the 'EXIT' message from it's parent and calls terminate to clean up. Whats unexpected is that the 'success' case works any different. A quick browse of gen, proc\_lib's start\_link functions makes it seem like the two cases should be identical. Regardless, I don't see much utility in using start then link, instead of just start\_link. If you don't want it to run inside a supervision tree, then just don't link the gen\_server at all to its parent, and it will run forever (unless you kill it by its pid or name). If you want notification of when the gen\_server's parent dies and don't want termination with the link, you could use a monitor instead.
Premature optimization is the root of all good use of time. /s
I've only used Erlang for maybe a year, but I really don't get what the "shocking" discovery is, here. Even looking at this from a high level, why would one expect that sending messages (message copying, process id lookup, delivery, notification, etc) is faster than linearly executed functional code within a process?
Indeed. That's a rather weird blog post to make. 
Luwak seems pretty interesting. Are there any benchmarks as to how quickly it can stream bytes to/from a small riak cluster anywhere? That would certainly give an idea on how well the idea really pans out versus something like DRBD or HDFS for distributed file stores.
this reminds me of [faxien](https://github.com/erlware/faxien) with more of a homebrew flavor. i look forward to seeing it develop
I personally found the whole erlware thing too complicated to start with, so I never really used it. I think I got stuck at Faxien part of it, python dependencies and such May be it wasn't that bad, but I wanted something really simple, and that's how agner was conceived when I got absolutely tired :) 
i actually think i ran into the same issue with python dependencies, but by the time i solved it, i didn't have the time to put into erlang anymore. 
Be sure to follow the 'next post' links :) It's not just an announcement! To the OP, thanks for posting this! :D
Thanks for these great articles. I have a question about non-blocking tcp server in part 5. I don't understand why we should use async accept in erlang. I usually pre-spawn "acceptors" process loops (which are -smp ready, right?) with a high backlog value. Acceptor loops that only spawn 'connection' loops (receive/send processes). What are the real benefits of async vs sync tcp server in an erlang specific context (not generally) ?
Passing a function without additional arguments: lists:map(math:sqrt/1, [1,2,3,4,5]). [1.0,1.4142135623730951,1.7320508075688772,2.0, 2.23606797749979] Passing a function with your additional arguments: lists:map(fun(X) -&gt; math:atan2(5,X) end, [1,2,3,4,5]). [1.373400766945016,1.1902899496825317,1.0303768265243125, 0.8960553845713439,0.7853981633974483] The 5 in the example can be replaced by your variable from the outer scope.
Thanks a lot for this
A nice example of what TDD looks like in Erlang. My own attempts always seem to go to a bad place. BTW, there are 5 articles in the series so far, each a good read.
This is something I wrote last night, mostly because I didn't care for mochijson2 and wanted a structure that fit javascript objects more closely. Do let me know if you find any bugs - I'm sure I'll find some as I continue to use the tool, but another set of eyes is always helpful.
Your first example is not quite right, it should be: lists:map(fun math:sqrt/1, [1,2,3,4,5]). You need the fun here as well as just writing math:sqrt/1 has no meaning in Erlang. Writing "fun math:sqrt/1" is a short hand for "fun(X) -&gt; math:sqrt(X) end". 
the video of this talk is extremely annoying - we don't get to see the slides!
There is already efene/ifene isn't this kind of like them?
As long as there are people who won't understand the true paradigms of Erlang, crap like this will be invented. My 2 cents.
I don't know erlang, I know a little bit about it. To the best of my knowledge efene/ifene is simply syntactic sugar on top of erlang. It makes no effort to change the way erlang works and does not try to introduce new concepts or paradigms into erlang. Kind of like LFE.
The problem is not if they change something underneath or not, it is what they try to make the user think that they are doing. To make the user think that there is some object oriented approach to Erlang is misleading and at best "cool" but in no way (in my humble opinion) useful. I feel exactly the same about the 'new' operator which is really clumsy that they put in there. Anyway as I said I do think it is cool that people experiment and it is an interesting approach but I wouldn't exactly use it in a "real" environment. The best part about these kind of things though is that it can give some really sweet ideas which Erlang can make use of in the "real" language like tuple index (e.g. T={1,2,3}, T[2] == 2) and list slicing (e.g. L=[1,2,3], L[:2] == [1]) without it having an affect which tries to imply OO. 
&gt;The problem is not if they change something underneath or not, it is what they try to make the user think that they are doing. To make the user think that there is some object oriented approach to Erlang is misleading and at best "cool" but in no way (in my humble opinion) useful. I feel exactly the same about the 'new' operator which is really clumsy that they put in there. Again to the best of my knowledge efene/ifene does not attempt to mimic object oriented paradigms in erlang. 
Sorry I think I wasn't clear enough. I should have been more specific even though I spoke in general terms. I am talking about this specific project. I haven't looked at Efene/Ifene enough to discuss them :) Sorry if this was unclear. My comment should have been: "**This** project serves no purpose other then confusing people trying to learn Erlang".
I think you're a bit too harsh. This is a fun hack. Anything or anyone who tinkers with Erlang is doing good :-)
I agree, it is a cool/fun hack (as I've already mentioned). I'm sure someone will enjoy it for a while :P
I've had a couple of people recently ask me about the exchange software about Smarkets so I wrote about one of the systems I still remember. I've poked the Smarkets team about writing more technical articles. I also just noticed that their web framework is now on github: https://github.com/skarab/smak
Great overview =) Nicely done.
Hello, I've been working on a little "template" for my erlang projects and wondering if anyone has suggestions for improving my layout or adding any other handy template files. One thing I'd like input on are methods for using Emakefile/Makefile/etc for building, running and testing. I've appreciated your thoughtful input in the past and look forward to any suggestions. Thank you
I'd say to add rebar support (just dropping the binary in there, perhaps?)
I think there's a typo in the README. To compile, it should be erlc -o, not just erl -o.
Typo fixed, thank you :-)
You are wrapping a statelss REST API, I don't see why you need a gen_server here to wrap httpc:request calls. Just call httpc:request from within lookup_account, outbound_call, etc (you'll have to pass AccountSid and AuthToken as arguments every time, though). And while at that, don't use httpc. Use ibrowse instead (https://github.com/cmullaparthi/ibrowse). Can't help you with your other questions right now (no time), but will be able to next friday-saturday. PM me if you'll still be needing advice by that time. 
For simple formatting: io_lib:format("http://example.com/~s/~s", [foo, "bar"]) The syntax is documented [here](http://www.erlang.org/doc/man/io.html#fwrite-1). If you want named arguments you can do something like this: format(Format, _Args) when is_binary(Format) or is_integer(Format) -&gt; Format; format(Format, Args) when is_list(Format) -&gt; lists:map(fun (Format2) -&gt; format(Format2, Args) end, Format); format(Format, Args) when is_atom(Format) -&gt; case proplists:get_value(Format, Args) of undefined -&gt; erlang:error(arg_undefined); Value -&gt; io_lib:format("~s", [Value]) end. It works like this: 18&gt; scratch:format(["http://example.com/", arg1, "/", arg2], [{arg1, foo}, {arg2, "bar"}]). ["http://example.com/",["foo"],"/",["bar"]] The return value there is an iolist (nested list of strings and binaries). Almost all the erlang IO functions accept iolists instead of strings. For optional args you can do something similar: call(Number, Callback, Opts) -&gt; Timeout = proplists:get_value(timeout, Opts, 1000) % default timeout is 1000ms etc ... call("1234", "http://webhook", []) % use default timeout call("1234", "http://webhook", [{timeout, 5000}]) % timeout is 5000ms Hope that helps.
Thanks for the advice. I guess I used gen_server because I didn't want to have to pass the AccountSid and AuthToken in every time. I guess the downside is that instead I have to call init() and start_link() which is probably equally annoying. It doesn't really surprise me there are better libraries with better HTTP support, but I think my use case is simple enough to put up with some of the seemingly missing basic features in httpc. I'm trying to minimize external dependencies because I'd like to eventually use this library for an ejabberd module for non-erlang developers to use. I don't know exactly how distribution and dependency management works in erlang, so I guess I'm just avoiding it.
another solution without regular expressions :) -module(scratch). -include_lib("eunit/include/eunit.hrl"). -export([replace/2]). replace(Template,Props) -&gt; {ok, Tokens, _} = erl_scan:string(Template, 0,[return]), %%io:format("Tokens:~p~n",[Tokens]), replace(Tokens, Props,""). replace(Tokens, Props,Res) -&gt; case Tokens of [] -&gt; Res; [{'{',_},{atom,_,Key},{'}',_} | T] -&gt; replace(T,Props, Res++proplists:get_value(Key, Props)); [{white_space,_,W} |T] -&gt; replace(T,Props,Res++W); [{integer,_,I} | T] -&gt; replace(T,Props,Res++integer_to_list(I)); [{float,_,F} | T] -&gt; replace(T,Props, Res++io_lib:format("~w", [F])); [{comment,_,C} | T] -&gt; replace(T,Props, Res++C); [{_,_,A} | T] -&gt; replace(T,Props,Res++atom_to_list(A)); [{RW,_} | T] -&gt; replace(T,Props, Res++atom_to_list(RW)) end. replace_test_() -&gt; [ ?_assertEqual("Hello adrenal8 !", replace("Hello {name} !",[{name,"adrenal8"}]) ), ?_assertEqual("foo, bar, foo", replace("{arg1}, {arg2}, {arg1}",[{arg1,"foo"}, {arg2, "bar"}])), ?_assertEqual("http://example.com/foo/bar", replace("http://example.com/{arg1}/{arg2}", [{arg1,"foo"}, {arg2, "bar"}])) ].
Welcome to erlang! I just started an erlang API last night for Spreedly. You may want to check it out as a guide. https://github.com/roder/spreerly/blob/master/src/spreedly.erl And some previous work: https://github.com/roder/chargify I agree with the previous points on using ibrowse and not using a gen_server. For XML look into xmerl and erlsom, for json I'm interested in github.com/davisp/jiffy. You should use rebar as well. 
You ... could just use io_lib:format and ~p, and eliminate all of those clauses *and* support all the types you forgot *and* support the new types that get added in the future.
Yes, I know. It was only an example to show how nice this erl_scan module is. For simple things like adrenal8 request it's a little bit over-engineered but when you need additional features like you have in a complex template engine this example is a nice start. 
saw this when it was starting and looked very promising, it seems to be progressing quite well, good job there! I'm currently busy with Haskell but this is a sure follow-up, I've always wanted to learn some Erlang (for great good!).
Thanks for posting this. I tried to do it myself but the submissions sank instantly (with no votes) and entirely disappeared so I had to delete it.
My pleasure. I'm really enjoying Erlang and am beginning to write my own tutorial series, though from a different angle than yours. The two should be complementary.
&gt; As per Moore's law, if transistor count increased as we would like, we would have had 2 cores in 2006 (Intel Core 2 Duo), 4 (physical) cores in 2008 (Core i7, Intel also) and 8 physical cores in 2010. Where is my 8 core laptop today? Transistor count != core count for a particular cost. &gt; "Should I concentrate on Node.js or Erlang for my needs?" Let me be clear: I think it is the wrong discussion How is that the wrong discussion for someone choosing a language to solve a problem? That's possibly the only sensible question! The problem is that people often ask which is better.
Let me know how it goes, I'm always interested in comparing approaches in teaching/training material!
I cannot imagine anyone voluntarily hitching their wagon to the Drupal name. That's like asking if you've invented the next Visual Basic, or Cue:CAT.
You would be astounded how many people think Drupal, Wordpress, and Joomla! are good examples of a CMS. :-( 
Apparently I would.
Apparently I would.
Just curious, but what are some examples of what you consider a good CMS?
I won't touch this with a 10ft pole. 
Very interesting. I wish they'd elucidated more about the different distributed databases that are available, in the section about building distributed systems. The way they sort of touched upon it, they just left it at: you have to design the servers to talk to each other or you have to use a database you know you can distribute. It would be interesting to know if they think it would be possible to use a distributable database for all situations (perhaps not an eventually consistent database, however).
Hello PHP &lt;5.3?
Hey cool, I've had a similar idea for a while. I don't think functions should have unique names, because all the good names will be taken up very quickly. But they should have a unique ID, and it should be possible to rename the function when importing it to your project to resolve conflicts. It's obviously heavily dependent on a good web-app for managing all these functions, but it could work.
And now we have R14B03!
&gt; Elixir provides a very simple Object Model based on prototype languages with most of its syntax inspired by Ruby. But... why? I mean... er... why?
The Erlang VM has so much to offer and I don't believe it should be limited to one language, one paradigm. For example, there are a bunch of languages on top of the Java VM, giving developers different options to tackle a problem, based on language features or even personal preference. If more developers are interested and using the Erlang VM at the end, I believe we will all benefit.
Honestly, I prefer using the right tool for the job. If erlang isn't suited then there are already a million other languages that could fit. Erlang is powerful because it avoids states, creating a OO language atop the erlang VM just seems to go against that paradigm and confuse everyone.
One of the reasons Erlang is powerful is because everything is immutable, which Elixir preserves, it is not related to states (records, tuples, lists can all represent a given state in Erlang itself). That said, you still get all the concurrency benefits in Elixir. You also get hot code swapping, behaviors, supervisors and so on.
Right. It's still making uncomfortable in someway because erlang and OOP don't sound like compatible in my mind. Maybe I should give it a try :)
Any success using this? I'm new to erlang and quite lost.
I'm a big fan of mustache so i'm excited to see where this goes.
This is so old, but do you think these are bad only because this is PHP, or are there actual good ones? I've done some RoR and haven't found one as nice or full featured (or, consequently full of noobs and bugs) as WordPress or Drupal (I hate joomla, so I avoid it like the plague). Django is nice, but while it is almost as full features as something like Drupal, it isn't 100% there yet. edit: currently stuck... at least professionally, with WP - it's a job and the boss loves it (I like Drupal a bit more perhaps, and would much, much rather be doing RoR or at the least regular old frameworks - clients don't want to learn this shit anyway)
Here is the "official" implementation, linked on mustache's homepage https://github.com/mojombo/mustache.erl
Read Michael Stonebraker's paper [End of an Architectural Era](http://nms.csail.mit.edu/~stavros/pubs/hstore.pdf) See [VoltDB](http://voltdb.com/), the relational db with one (single threaded) db engine (a 'site') per core, with different sites on their own cores communicating using message passing. The TPC numbers are impressive. Check out how much more understandable the code is, compared to a locking version. 
Actually, many RDMSes use MVCC (Multiversion Concurrency Control) which is lock-free. Lock-free schemes avoid deadlocks at the cost of memory. See the [wikipedia](http://en.wikipedia.org/wiki/Multiversion_concurrency_control) page for a list of databases using MVCC, e.g. MySQL when using InnoDB.
I seem to recall that Mnesia also uses MVCC, but I can't find a reference or where I read it. 
&gt; Are there cases in which using current technology, locking performs/scales better compared to message passing? I think it is a mistake to regard locks and MP to be orthogonal issues. Low-level concurrency primitives like locks give you moderately fine-grained control over communication between cores but this is an invasive form of message passing: you are copying data from one core to another via a cache miss. In particular, when you write low-level code in the pursuit of performance it is important to take the passing of messages between cores (via cache misses) into account because this is usually the dominant contribution to computational cost on a multicore. Consequently, I don't think it makes sense to try to compare the performance of a low-level implementation like locks with a high-level architectural concept like message passing. 
Just talking about the performance of locks without saying which kind is already an apples to oranges issue. Trying to compare them to message passing, while well-meaning, is honestly not a useful question. The short answer is "it depends on how they're implemented. There isn't a general rule, and they aren't for the same stuff anyway."
any question is more than welcome
No question, but thanks for it. It's been frustrating that erlang lacks a library like this. Will come in handy soon for my next project.
I wish i learned about this a long time back. Very useful little tool.
If I were going into grad school and wanted to work on advanced pragmatic tooling I would work for Kostis.
And here's the link to the original repo https://github.com/oscarh/vimerl
Yep, that´s the original, but my fork has these differences: * More stable and more features * More frequent updates * Constant integration of other people fixes in their forks * Minor code refactors and cleanups * Doc always updated * Try to follow KISS philosophy Basically I try to contribute keeping my fork of the plugin in the best posible shape. That's all.
I use this, and I love it.
Looks like Virding and Armstrong do not agree on several things. I get the impression that Armstrong doesn't much like alternative languages on one VM concept. I love the concept of Clojure and LFE even though I haven't used either in anger. A (lispy) macro package should in itself be worth the price of admission.
having used cowboy and added some functionality to it I have to say this is great news!
Can someone please give some pointers to how this compares to the rest of the pack? (yaws, webmachine etc?) 
It's more comparable to Mochiweb or Musultin, in the sense that all of those strive to be lightweight, barebone HTTP servers. What I like about Cowboy is the modular design. It's pretty easy to add a different protocol handler for handling for example ftp connections.
I've been looking for a simple, easy erlang server that can be packaged with rebar this week! I'd almost given up :) Looking forward to giving this a try. 
Monads would be quite confusing for the vast majority of maintenance programmers to come across, understand, and debug. While they can provide a better abstraction in some cases, the foregoing cost is too high.
"TCP and UDP: Bro-tocols." Wow. I never thought of it that way. 
Real world experience using monads in Haskell disagrees. The whole purpose of better abstractions is making problems easier to understand and debug. Unless this is a claim about average programmer inadequacies, in which case you can s/monads/coroutines/ or closures or templates or macros or inheritance, and get an identical argument.
I don't mean monads are hard to understand or a bad abstraction. Obviously, that's not the case. But, monads certainly do have to be learned. Monads are an unusual and unerlangy way of doing things, so erlang maintenance programmers, most of whom probably do not use monads regularly or ever, would have an extra hurdle to face in maintaining and collaborating with such code. In my view, monads:erlang::actor model libraries:haskell. I'm not saying anything new here, I'm sure everyone is familiar with this sort of argument, but I think it's a true shortcoming: You can't hack on cool built-in features from another language and get it to work well. Well, maybe you can, but it's long odds.
I've no idea what areas you are interested in but if I was attending the conf I reckon these would be my pick: * DTrace and Erlang: a new beginning * Erlang for a new era of Embedded Computing * Investigating Hashes/Frames/Structs as a new built-in datatype in Erlang * The "halfword" virtual machine * Tutorial: How to start using Dialyzer in your project
Wish I could go.
Okay, I'm back! It was a very exciting experience, I wish everyone with even the slightest interest in Erlang could have come! Fortunately, all talks were videotaped so I hope they will upload videos of the talks eventually.
Currently, none of the libraries on github have appups. 99% don't even have proper application versions. Rebar got people to properly package libraries as apps. The next step is clearly relup support, and there's obvious things to automate and simplify in that area. Let's get the ball rolling. Here's my suggested relup/version control procedure for arbitrary libraries.
Brilliant idea.
Where would i read about the halfworld vm ?
There are many examples for what you want around in erlang, one of them is this one I wrote quite a while ago https://github.com/Amadiro/crumbled (but its a full-blown chatserver and might be too complicated for what you want). Just look around, and you'll surely find good examples -- AFAIR joe armstrongs book also had an example on a chatserver.
Solid advice regarding Joe's book - you might also want to have a look at the Pragmatic Programmer's screencasts done by Kevin Smith called 'Erlang in Practice', where he takes the viewer through the development of a simplistic chat server with testing, REST integration. Well recommended. 
Here's a pretty good tutorial: &gt;Learn how to write Erlang programs by sitting next to an experienced Erlang programmer as he builds a full-featured application from the ground up! &gt;In these screencasts, Kevin Smith incrementally builds a distributed chat system using Erlang. You’ll learn first-hand how each aspect of the Erlang language fits together into a real-world application, starting with Erlang primitives and ending with an OTP application. http://pragprog.com/screencasts/v-kserl/erlang-in-practice $15 for the first three screencasts is all you need to get going...
If you're looking for Erlang tutorials, including some networking stuff, I recommend http://learnyousomeerlang.com/
This sounds like exactly what I need, thanks!
Cool! This is pretty awesome
If you look [here](https://github.com/rvirding/chat_demo) you can find an extremely simple chat server backend as an example to get you going. It is reasonably scalable.
&gt;Line number and filename information are now included in exception backtraces as a fourth element in the MFA tuple. The information will be pretty-printed by the shell and used by common_test to provide better indication of where a test case. [](/twibeam "Yes yes yes yes yes yes yes yes yes yes!.....yes.") Yes! That's an early Christmas gift for this relative newbie. I knew it was coming but the release took me by surprise.
Anyone used it on Windows x64? Is it stable enough for production?
I hope that change will help more people to the language! 
My guess is that it depends on what parts of the OTP system you use. Most of OTP proper is or tends to be rock solid. It is the interfacing stuff that may not be. That said, most "big" Erlang/OTP installations run on some Unix derivative, with development and control going on on other operating systems. OSX has some known limitations for instance that may hamper certain programs when they start to scale upwards.
and it's a nice addition for tool developers too.
Actually I'm wondering about RabbitMQ, which doesn't seem to use much beyond mnesia.
+1, this is really easy to understand
Probably a dumb question, but... I've always read how Erlang apps can be updated while they run. How do you update Erlang itself while running? Can you?
They certainly can, it's one of the great draws to erlang. I'm not best versed in it, but the following things should guide you on your way http://amtal.github.com/2011/11/07/adding-live-updates-to-your-erlang-library.html Generally search for appup, relup and hot code reloading too.
That's not what I meant. I know erlang apps can be live-updated, my question was if the VM itself could be, or what would be the standard method of doing so. 
I don't think it's possible to update the Erlang run-time while running, or at least not officially. 
AFAIK, not with a single node. You can't "yank" the current Erlang VM and replace it with a newer one in-place while it's running. You can, however, install a newer version of Erlang in parallel, fire up a separate node, and use "some sort of" process migration logic to, for instance, migrate a bunch of supervisor and worker processes to the new node, and then shut down the old one. My understanding is that there's nothing in OTP to really automate that sort of thing, because it's all rather application specific, and tricky with TCP ports, etc. Especially things that are open for longer periods of time. So for a while you'd be running separate nodes, even on the same physical machines.
I like to see people trying to learn, but trivial tasks teach very little. Wrapping them in cutesy catchphrases only obfuscates that fact. Challenge yourself, or you won't improve. Projects that are "toys" in Erlang: - speed-auctions - (trivial) stock exchange - live web statistics - playing with twitter firehose Some general patterns that you'll see come up again and again: - worker pools - distributed master-slave failover - parsers and serializers - interpreters (abuse that pattern matching!) Each of those is ~30 minutes to get running, and gives you experience you can re-use.
Fantastic article! CAP theorem described in the context of a zombie apocalypse. Plus the cookie monster! Lol
God damn it *no*. * Learn languages by writing code they excel at. * Once you know them, learn their limitations by writing code they're bad at. Know the role of a language: explore within it until you know what you're doing. Don't start applying screwdrivers to nails until you're familiar enough with the tools to start pushing the envelope. (Trying to push the envelope is very educational and should definitely be done eventually.) * Project Euler is for exploring math and algorithm design. * Erlang is for writing robust high-uptime systems. * Code katas are for exploring jargon you can spew in your resume and interviews to inflate your competence from tech-ignorant but buzzword-savvy management.
You are my hero mononcqc. 
Very cool!
Perhaps Erlang should also consider the size of the binary in the global "binary heap" when it makes the decision to GC a process or not?
On hackernews is an interesting discussion about this topic. http://news.ycombinator.com/item?id=3586438
it seems like the answer to this is to used fairly short lived processes, that way associated binaries will die
I was wondering the same, so I just asked this on their mailing list. I'll give an update here if I get an answer. UPDATE: Eric Merritt, creator of Joxa, wrote an insightful blog post about this: [http://ericbmerritt.posterous.com/differences-between-joxa-and-lfe](http://ericbmerritt.posterous.com/differences-between-joxa-and-lfe)
Heh. I've encountered that attitude about several languages. My current company has some of that, with Erlang. I like a LOT of things about Erlang, but it's been badly implemented here. And it really isn't suited to some jobs.
The problem I've run into is nobody else feels the same way as I do... so I ended with an "okay" face and go back to ruby/java/perl/php/whatever they've standardized on. /sigh
FWIW, I'm just coming to grips with Erlang but I am quickly coming to this conclusion as well. I just wish it had the convenience of Python that I'm used to.
I an unashamed fan-boy myself. Although I would even admit that it's not ideal for many applications. But for things it's good at, there is nothing better (I am starting to learn Haskell, and I like a lot about that too). I am lucky and I use Erlang at work. I always smile when I hear the java folks complain about something going wrong that "just works" with Erlang. Usually something about some mutex issue.
You'd think. I'm not really privy to the details of the development of that system, nor am I in a position to make changes to it. I just know it functions pretty badly and no-one wants to mess with it anymore. But, that's also true of several other systems which *aren't* written in Erlang. I'm not really criticizing the language (although, our misuse of it has made several of my co-workers think pretty poorly of it), just we've either used it for a task that isn't its strong point (and any language will be less than stellar when asking it to do something it's not supposed to), and/or we've done it badly (again, you can write bad, unmaintainable software with poor instrumentation and management tools in any language). My one possible gripe with Erlang in all this - it has the really cool feature that you can just kind of jump in to an instance and get information about it. Great for debugging, bad when developers mistake that ability for something admins can use to manage the program. You shouldn't have to know Erlang in order to run it. Just like you shouldn't have to know C in order to run and manage Apache.
I thought this was interesting not because I think that OTP is hard, rather that many newbies can produce poorly performing code. This could be a step in the right direction to make people write good Erlang from the start and ultimately have a bit of consistency in the language.
Is there are a community around this? I am new to Erlang/OTP and I think I would make a great test dummy for this project.
That's a really good analogy. I'ma use that. I remember a couple months ago, one of my sysadmin coworkers was dealing with something. He needed to find out how to do some fairly trivial task (reload the config for the 8 nodes in the Erlang cluster). We (I'm there for moral support) go talk to the dude who wrote it. We eventually get to him saying "you're going to have to use Erlang, you can't just do it from the bash console." I say something like "that's effing ridiculous" (yes, I do say "effing" in real life big whup want to fight about it?). He just kind of stares blankly at me and says "Why is that ridiculous?" Then my coworker and I just glance at each other and laugh our sad laugh.
I can see where you're coming from with that. I've had at least some experience with other functional languages before Erlang (a couple classes in Haskell, read through a good chunk of SICP). But yeah, if you try to shove procedural/imperative thinking into a functional language, you're going to end up with a mess.
Well, the Erlang guy should've knocked up an escript for you (can be called from bash). That's one of the things about erlang. It has so many features that few people know all of them. It truly is an awesome language. One of my former colleagues described erlang not like a VM, but like an operating system.
I personally found OTP simple, and easy to understand. But prior to me learning Erlang I worked at a company had a system based on a similar pattern (written in C) which made it easy for me. The trap most seem to fall in is not understanding what happens when you use OTP patterns. Create a gen_server for example. The fact that your beautiful application running on many cores suddenly becomes serialized and slow. Erlang provides ways to fix that, but they are not often documented. Having said that, the community is really good.
I would start by going to the erlang questions community. I'm sure people there will help.
Done, although the response I got was slightly abrasive.
MochiWeb is quite nice though if your looking for really providing a better HTTP interface you can pick WebMachine or Cowboy which provide REST logic and let you fill in a few callbacks to define the behavior you'd like.
I haven't used MochiWeb, but misultin is quite lightweight and works nicely for me.
cowboy for webserver and jiffy for encoding/decoding is the fastest/simplest you can get.
Wow this has been very illuminating. Upvotes and thanks for all.
Just for the record: [Misultin development has been discontinued.](https://github.com/ostinelli/misultin) Of course, that doesn't mean it isn't great any more.
Agreed. This combination is working well for me. I can also attest to Cowboy's WebSocket support working much better than a year ago.
I like mochiweb especially if cached content should be returned. Mochiweb is actively developed and used mochi media (I think this one worth some trust :) ). But for embedding web control panels I preffer standard httpd server (not so well documented, but quite feature reach). Unfortunately was not able to compile cowboy, going to do for sure. And thanks for jiffy, I am still using mochi_json2 :) going to compare results now :)
I wouldn't call this an alternative for OTP, so much as a wrapper for it.
And there is also an active Google Group too https://groups.google.com/group/sockjs where you can ask questions.
My problem is more like "pattern match all the things." Pattern matching makes a huge amount of code cleaner, and I keep trying to use it in other languages (read, java) before realizing it's not possible.
You really need to change the title to indicate that the link is to an 8mb PDF; until you do I am downvoting the story so that it doesn't catch others by surprise.
8mb!? that must take a whole minute to download!
Do people agree that syntax is the main barrier to adoption? I found the assertion that more eyes would lead to a better VM. Does anyone know of unexplored performance holes within the implementation?
FWIW, I think the point is valid. It's a big download, which can be nasty if you're browsing Reddit on 3G, for example.
I believe a JIT is currently being worked on, but of low priority.
Yes, and when your browser surprises you with a pop-up window that starts blasting sound at you, you can always close the window, so what's the big deal? My point is not that it is the end of the world when a link turns out to be an 8mb download, just that it is a nuisance that should be avoided.
I'm glad we agree the solution is client side!
Before I knew Erlang the syntax was awful, even more as I'm used to elegance of Haskell. It was a barrier, but when I started using it I noticed greater problems: it's not possible to write Erlang in a good functional style and static analysis is really lacking. Erlang gets work done, but you better bring some gloves. I think it's a turnoff for the functional crowd and imperative programmers just don't care enough about "silly egghead languages".
Armstrong is always an interesting guy to hear talk. Thanks for sharing the link.
You can pattern-match the #state{} record in the function headers to ensure you get a state record in as an argument. So stop/1 could be: stop(#state{socket=Socket}) -&gt; gen_udp:close(Socket). Also, look into sending an iolist to the socket on send, rather than concatenating the list in build_message/1. Lastly, as a matter of personal style, I would write send/2 as: send(State, MT) -&gt; send_message(State, build_message(MT)). Since the result of build_message/1 is only used once, and the line doesn't get excessively long, that's my general way of doing it.
I can wholeheartedly recommend this practice as well. Without using the OTP behaviours, doing hot code changes will be significantly harder and service reliability is much more difficult to achieve.
In may case I use cowboy to do this.
Project required nonstandard ports (not http) and had no web server, so tiny custom server suted better. At least I think so :)
Erlang solutions would be a good start: http://www.erlang-solutions.com/
I care... I care deeply....
Sweet!
Awesome. I will preorder it the first chance I get.
Thank you for updating it to use {active, false} socket parameter.
This is neat, but I find it fustrating that someone would write a post saying there is a more secure way to do things and not implement it.
Sorry that I have disappointed you :) I have used self signed certificate to test my code, so any advanced certificate verification would fail. That is why I described options, but have not used them.
Now that I've read the article properly I totally understand what you mean.
Some discussion on this topic on erlang-programming: http://groups.google.com/group/erlang-programming/browse_thread/thread/896f6269d874da10/07b09a0770d47491 tl;dr - NIFs are synchronous, blocking. Linked in drivers are asynchronous, can react to events (but more difficult to implement).
Does it really surprise anyone?
What do you mean by that? Could you clarify?
Really? They're using Erlang and Mnesia on their backend, but they still can't manage to do online patching?
I can think of two reasons why it could be hard. First, they could be using something else along these two. Second, they have to force players to update anyway.
I believe it's their chat server that's Erlang. The rest is a hodgepodge of C/C++, Python, and probably Java.
"Sell not virtue to purchase wealth, nor Liberty to purchase power." B.F.
So that five people don't sync up their busy schedules and then hang out on voice chat for 15 minutes waiting for someone to patch instead of playing the game. This is a well known problem with a well known technical solution, not fixing it shows serious disrespect for the players. 
Does that router run erlang? The queues have definitely shrunk down, now you don't have to register interest. You can now place orders for the pi directly.
Nice, I had no idea openwrt was that versatile. 
I thought about that, but with the in car router, when the power goes off, the garage door will close. So you just drive in, shut off the car and the door will auto close. It's the ultimate in laziness! If I made it respond to my phone, I'd have to shut the door myself. ;)
Hah, hadn't even thought of that. Maybe an override switch or a pressure sensitive contact where the car is parked? :)
So did you write all the code, like the C that does the FFT on the sound input? I'm working on a project to detect sound levels and then fire off json to an HTTP server based on the amplitude. You should git hub the code and share it with all of us even at this unpolished alpha state. Newbies like me would relish this chance to learn.
I notice lots of activity on github repo for the plugin. When will you cut a release so that IntelliJ autoupdates?
I would like to polish some new features, for example test Erlang SDK on Windows. After that I'll release new version of plugin. BTW, you can manually set up [the latest build](https://github.com/ignatov/intellij-erlang/raw/master/bin/Erlang.zip).
awesome ++, been trying to figure out how to use cowboy effectively without much luck. Will be neat to try this out.
So you are the creator of this plugin? If so I would like to say you are doing great. I'm sick of Eclipse and ErlIDE.
Yes, I'am. Thanks for your good words. Next build of Erlang plugin will be released soon. Stay tuned.
Today version 0.2 was released.
For BIFs and records autocompletion you need to install the Erlang SDK to your project. Plugin retrieves information from standard libraries. For further information see the small screencast: http://www.youtube.com/watch?v=b4UoqOOkqWA
I have it installed. But it doesn't work. Windows 7 64-bit, Erlang R15B1
Please, report an issue to https://github.com/ignatov/intellij-erlang/issues
Can you add sessions, authorization hooks (before_)? 
Wrong approach. Also note that your professor could easily be looking at this, so I wouldn't use anything you are publicly given, as it's happened before. I don't know Erlang at all, but I would think you'd be able to look up the reader and writer samples easily. As for the controller, look up the appropriate synchronization technology for Erlang, with semaphores or mutexes are likely choices. Good luck, and I hope this isn't due in a few hours.
He probably made a bet with his drinking buddies that he would get a raise out of Reddit crowd.
no its not due until thursday at midnight so i have some time. I wasnt going to pull a copy and paste. Just having a hard time wrapping my head around what i need to do and im getting stressed out about it.
Working through *Seven Languages in Seven Weeks*? Along with gtani's suggestion (really good resource), I was able to find discussions of your problem online from [journal articles (PDF)](http://cs.nyu.edu/~lerner/spring10/MCP-S10-Read04-ReadersWriters.pdf) going back 40 years. Since erlang has no direct analog to mutexes (though their mechanism isn't too hard to recreate), this really just provides some additional insight into the problem overall. I noticed a Stack Overflow question with the right time frame to be you, you really ought to tag it as homework if it is yours (no direct answer attached at the time of this writing). The pointers in that answer are what I might have written so I'll leave you with that.
2 weeks ago it was Io, so my guess is Clojure or Haskell for next week.
Definitely on my list. Also: help is always appreciated. :)
Are you able to describe what each of those roles (controller, reader, writer) should do? If you know what they should do, the rest follows directly.
the second paragraph after "here it is" is all the instruction for the problem that was given. I think its left open to me to do with it what i want.
clojure is next, but i know lisp fairly well so it shouldnt be a problem.
im comin down to the wire and i still just cant get anything going. PLEASE help!
could you help me do it please? im running out of time and i just cant seem to figure it out.
Paypaling $50 to the first person who gives me a working solution to this.
I love your teachers attitude. Apply the reader-writer problem to a share nothing concurrent actor model for the LOLs. Made more tricky by the fact that messages are processed sequentially. I would use an ETS table -- create one **process** for writing to it, create one **function** for reading from it (that you can spawn multiple times for concurrency) and you are done. The mailbox on the writer takes care of locking and stops all concurrency to writing, and the readers get insanely fast lookups. Should be about 40 lines of code (or less). 
Most erlang programmers earn over $100 an hour. Good luck with that.
No concurrency. Messages ares are handled sequentially from the mailbox. 
Kool erlang project. Any reason you aren't using ranch instead of cowboy?
Stackoverflow has shown that programmers derive value from helping people, even without compensation.
There's a difference between helping someone out with some quick info and doing their job for them.
Essen (the author of Cowboy and Ranch) has posted about it on the list -- https://groups.google.com/d/topic/erlang-programming/I466qH2W69I/discussion -- basically the split is happening on master soon. He mentioned on IRC he is working on docs. 
Fair enough. I agree that asking for a complete solution is too much.
That list is complete bullshit.
So, UML nets you an automatic 102k? Sounds legit...
Bullshit. I do Erlang and I am unemployed. :-)
It's both [(source)](http://en.wikipedia.org/wiki/Erlang_(programming_language\)#History)
Thanks. Somehow checking wikipedia did not occur to me... And ooh, he was Danish, didn't know that :)
It probably isn't but... it really doesn't tell you the whole story. Who are the people working with those technologies? Well, either leading edge technologists (e.g. Clojure, Erland) or technology holdouts (e.g. Silverlight, PowerBuilder). Those niches tend to get paid more than average because they're taking the risk of being invested in a skill set that's hard to find. And THAT should be the real point of the article. If you want to get paid more, you have to take on more risks. These specific niches will likely change within the year anyway, so anyone chasing a 6 figure salary based on this could be disappointed.
In part, I agree with you. But I think, it's not solely the capability to program erlang or clojure that earns you the money. A programming language is just a tool, like a very complicated hammer. Every decent programmer can be trained in a relatively short time to use said hammer. Nobody pays you sex figures for knowing how to use a hammer. People pay you six figures because you can build complex and robust things with that hammer. But that is a very different skill set that takes not only a lot of learning but also quite a lot of talent. And if you're really good, it doesn't really matter any more [what kind of hammer](http://www.codinghorror.com/blog/2012/06/the-php-singularity.html) you use.
Erlang is a really old language, unlike those hot shot young languages like Java or C++.
Does sending u paypal help?
Ranch .4 has been released.
Presentation: http://vimeo.com/44312354 Slides: http://www.erlang-factory.com/upload/presentations/558/efsf2012-whatsapp-scaling.pdf
This is so impressive it's almost silly. And really, what they only run on a single 24 core machine + 48GB of RAM?? For perspective, Linode has a 20GB *standard* plan you could scale to with the click of a few buttons (ignoring the risk that your VISA might self combusts ;). So, write your app on Boss, store to Riak, host on Linode/Rackspace, then you win.
The VM they are using was tuned with their own patches. Will those patches see the light of day in standard release of Erlang... That would be great to see :)
Well it sounds too similar to Cowboy, and was created by the same guy. So what is the difference here?
Thanks for donation.
Cowboy and Ranch are super cool but boy does their documentation suck. Not to mention Ranch/Cowboy share the same old roadmap.
Haha i know what you mean. Erlang needs a bigger community.
Good discussion, basically a rehash of other talks he has given. Not a whole lot new there IMO. 
Lol @ dializer. Fitting nick :) Big thanks to Stavros Aronis and Kostis Sagonas for patches. According to the release notes, there are 66 contributions from outside of Ericsson team.
Good presentation, but I don't agree about the syntax. Syntax is easy, just look it up in the manual. Semantics is much more difficult, as are use patterns.. You really have to understand what is going on then. If people get all worked up about the syntax what will they say when they get to the semantics?
Works perfectly so far for me, thanks for this nice plugin! Had much problems with the other, ErlGray. Would be nice if you could add support for the EDoc annotations like @spec. Especially in the structure view.
Unfortunately it is probably true. :-(
&gt; Nobody pays you sex figures Ain't that the truth.
https://github.com/Spawnfest2012
Pun intended? ;)
The writing is excellent.
&gt; Or take string concatenation. If you pop open the implementation of string concatenation in Perl, Ruby, or JavaScript, you are certain to find an if statement, a realloc, and a memcpy. That is, when you concatenate two strings, the first string is grown to make room for the second, and then the second is copied into the first. This approach has worked for decades and is the “obvious” thing to do. Yes. This is a great approach because it is *very* fast. Some architectures even have native instructions for handling strings this way, i386 among them. Copying memory is a comparatively quick operation. ---- &gt; Erlang's approach is non-obvious, and, I believe, correct. In the usual case, Erlang does not use a contiguous chunk of memory to represent a sequence of bytes. Instead, it something called an “I/O list” — a nested list of non-contiguous chunks of memory. I can't get a relevant hit on Google for this "I/O list." As far as I have been taught, Erlang lists are simple linked lists, and strings are just linked lists of integers. Linked lists mean veeeery bad locality, and they can't use any hardware instructions for handling strings. ---- &gt; The result is that concatenating two strings (I/O lists) takes O(1) time in Erlang, compared O(N) time in other languages. Concatenating two linked lists takes linear time with respect to the first list, because it needs to be traversed to get to the last element and hook it up with the first element in the second list. It's possible that the OTP keeps a reference to the last element of a list to make this constant time. ---- &gt; In Erlang, each function is passed all the information it needs, and you get a compiler warning if it was passed any information it doesn't need. Well, not really. Granted, the statement is very vague, but I would kind of expect to get a compiler warning if I tried to call `f("foo")` defined as `f(X) -&gt; X + 1.` ---- &gt; All data structures in Erlang are completely transparent. Knowing nothing about the library you are using, you can always inspect the contents of data structures at run-time. This feature greatly aids in debugging ...but you know jack shit about them compile-time, which greatly impedes debugging. ---- &gt; in Erlang, it usually doesn't matter, as the data structure is half the interface. Which could also be seen as a bad idea, because it means you only know half the interface until you actually run the code. ---- &gt; I have learned more in the course of developing Erlang libraries than I ever learned stitching together other people's Ruby or C code. Perfect if your intention is learning. Not so good if your intention is getting stuff done quickly. ---- Not to mention that you can't use user-defined functions in guards. A major drawback, in my opinion. ---- Misinterpret me the right way now. I love Erlang and every time I use it I wish I could use it more often, but the things I've brought up really detract me from using it.
IO Lists are just linked list trees that also include other "stringable" things like binaries. All the default output functions take these IO lists in addition to flat strings and will just walk them when printing thus preventing you from needing to do it in the middle of computation. It seems like you win this way if you've got a lot of template strings that you're just fitting in the details on. You can get "compiler" (static) warnings about type errors using Dialyzer if you want, but it's kind of a PITA. I generally agree with the sentiment you have about Erlang. I posted a comment of mine at HN on this article (I submitted it there myself).
A trouble with using arrays for strings is choosing the element size, especially with unicode. To be able to directly index unicode code points you need to make each element at least 3 bytes. If you don't then your unicode will have to be encoded which means that indexing is lost and you have scan the string to find "characters". If you have larger fixed size elements in your array then suddenly the difference in size becomes much less.
They are usually referred to as "IO lists", or "iolists". There is a [great explanation of IO lists](http://learnyousomeerlang.com/buckets-of-sockets) in Learn You Some Erlang, but in short — an IO list is functionally equivalent to a string builder, allowing you to accumulate individual strings (or binaries) in O(1) time. 
That wasn't as much a "how" explanation as it was a "why" explanation, unfortunately.
I take it they syntactically doesn't differ from common lists, and that Erlang really doesn't use linked lists, but rather IO lists for everything. How are they represented under the hood? "A nested list of non-contiguous chunks of memory" sounds to me exactly like a linked list, which isn't too cheap to flatten.
There appears to be a misunderstanding. Erlang uses linked lists. IO lists are a subset of all lists, defined to contain only characters, strings (lists of characters), binaries, or IO lists. [For example](http://prog21.dadgum.com/70.html): [10, 20, "hello", &lt;&lt;"hello",65&gt;&gt;, [&lt;&lt;1,2,3&gt;&gt;, 0, 255]] Low-level Erlang functions, such as `file:write_file`, understand IO lists natively, without the need for flattening. This means you can use IO lists to avoid wasting time and space by needlessly concatenating strings or binaries.
I still don't get it, then. IO lists do not technically differ from linked lists at all, they are merely linked lists only consisting of particular elements? How does the low-level functions then traverse them in faster-than-O(n) time?
Plain strings are just linked lists: "aoeu" == [$a,$o,$e,$u] IO Lists can look like this: ["Good morning, ", [&lt;&lt;"Dave"&gt;&gt;, "!"]] The IO List then is a heterogenous list, and potentially a tree. It doesn't need to be flattened to be utilized, instead it's just a tree traversal. It also makes it easier to construct/deconstruct programmatically. Take the above, instead of doing: morning(Name) -&gt; "Good morning, " ++ Name ++ "!". We can do: morning(Name) -&gt; ["Good morning, ", Name, "!"]. A much cheaper task (especially if it'll be done many times) than the two append operations in the first version. Of course that's a trivial example, but extend it to generating HTML where it can turn &lt;massive string 1&gt; ++ &lt;massive string 2&gt; into [&lt;massive string 1&gt;, &lt;massive string 2&gt;], reduces a O(n) op into O(1). As long as under the hood things aren't being copied it can yield massive efficiency gains.
Sure, but you'd ultimately, somewhere, need to flatten the strings to e.g. print them or search through them efficiently, and then the cost is incurred at that stage instead, is it not? I do, however, agree that IO lists seem a lot nicer for the programmer to work with rather than appending willy-nilly.
I guess what I'm curious about is the "slightly more complicated" bit. I don't see how it would be possible to flatten the linked list without concatenating each of its elements.
&gt; Assuming a cost/character for the printout O(N*M). I think this is where stuff starts to break in my mind. I'm fairly sure the kernel doesn't print things character by character, which would, indeed, make IO lists pretty much equivalent in performance. The problem with IO lists is that the instructions for printing strings cannot be called on the whole list, but must be called on each individual piece. As we know, processing data individually is very slow when it's possible to batch process it. It becomes even worse when you need to search the string, because of hits overlapping two elements of the IO list. I am sure IO lists are a lot cheaper than flattening normal linked lists when printing, but what I'm opposing is the idea that IO lists would be even close to competing with bytestrings anywhere, even though bytestrings could potentially be costly to concatenate.
Sure, IO lists might very well be the fastest alternative in Erlang, but how can you make sure that no part of the performance difference you spot is due to OTP being optimised for working with strings as IO lists? But I guess you're right, although it depends a lot on the particular application. If the application usually constructs and decomposes strings a lot according to static rules, but rarely does anything more dynamic to them, like searching, then it's very possible that IO lists are the fastest overall.
No. In order to output a list, you clearly need to visit every element of the list. The benefit comes from being able to keep items to output in a nested list. As I said, this allows you to accumulate individual strings (or binaries) in O(1) time, rather like a string builder.
Again, the elements of IO lists can be entire binaries, which is what Erlang calls bytestrings.
If you want to hook it up to your own phone number, then yes, Twilio charges $1/month for the number and 1¢ for receiving and sending SMS. However, you can try it out over cUrl or texting "PLAY" to +1 (415) 494-8454. This post was more about getting feedback on my usage of the gen_server/supervisor/rebar/etc. stuff though.
Cool. Web interface is at http://mjolnir.cs.ox.ac.uk/soter/
How long did it take you to figure out how to server index.html here https://github.com/twilio/chessms/blob/master/src/chessms_server.erl Took me couple hours cause Cowboy examples did not have a sample on just serving index.html for the root path :(
I used [this example](https://github.com/extend/cowboy/tree/master/examples/static) but it took me a bit of time to get the pattern matching right.
Oh yeah.
Maybe someone else can comment on this, but from what I recall, while this is a succinct specification of quicksort, the ++ operators make it very inefficient. So functionally, it performs a quicksort, but it's not actually quick
It looks like Xs would be scanned twice. Is that what you were thinking/referring to? That's my understanding of the code. I agree that it looks like it only needs to be scanned once. Then again, it's a constant amount of additional work and the algorithm* will still be n log n. *Looking at this implementation, it looks like it's a somewhat bad implementation. Fine for learning from but, it seems like you can construct inputs which would have n^2 running time. Picking the pivot at random from the list would have better expected runtime. (Then again, with a linked list, not array, it would take n time to randomly pick the pivot...).
That does get scanned twice, yes. It's written to be understandable, rather than to be efficient. If you want it to be efficient, { Left, Right } = lists:partition( ... )
Quicksort has an n^2 worst case in all implementations.
I think the `[X] ++ Bla` is compiled as `[X|Bla]`. So it's not very bad...
What I said was incorrect, and I need to learn to read. Withdrawn, with apologies. ~~Habitue is correct. Please don't guess about advice.~~ http://www.erlang.org/doc/efficiency_guide/myths.html#id60058
What's your point? The page you linked to shows `[X] ++ Bla` *is* compiled as `[X|Bla]`, just like I said.
No, you don't. First of all, r3m0t's point is valid. [X] ++ Bla is fast. What is not as fast is the qsort(...) ++ ... bit, since it will need to traverse the result of the qsort. However, the algorithm still runds in O(n log n) average case time. Each call to the function iterates over each element -at most- 4 times: in creating the first partition, in creating the last partition, and twice for prepending the result of the rest of the list. Since each step runs in O(n) time, we end up with just the ordinary quicksort complexity of O(n log n).
What I said was incorrect. I had missed that last sentence at the end of my own link. Withdrawn, with apologies. ~~Please actually read the manual page I linked before telling the guy he was right. `r3m0t`'s assertion is simply false, and the manual page is actually quite clear on the topic. It specifically discusses both strategies and that the one `r3m0t` guessed about is not, in fact, as efficient as the one `habitue` spoke for first.~~ ~~We do not want to create the behavioral pattern in this subreddit that people are emotionally rewarded for making false guesses in public, then when caught being wrong, getting nasty and pretending otherwise.~~ ~~Just because he said "the page you linked says I was right" doesn't mean you should assume he's correct.~~
I'm sorry, but the page you linked to /is/ really clear on the topic. &gt; (Or it would be more efficient if the the compiler did not automatically rewrite [H]++Acc to [H|Acc].) Sure, it's a double-negative, but there's not much ambiguity here.
Literally, all you had to do was finish reading that line. &gt; which is slightly more efficient because you don't build a list element only to directly copy it. (Or it would be more efficient if the the compiler did not automatically rewrite [H]++Acc to [H|Acc].)
It is a version of quicksort written to clear and understandable rather than efficient. Anyway if you want an efficient sort for a functional language you are better off basing it on a mergesort algorithm.
Please be more precise if you're asking. If it's a statement, then ok. :)
Emphasis is made on good DSLs and nicer type analysis system. At least for me. And thanks to some awesome libraries by Mr. Rashkovskii such as GenX and Xup, you can actually write very very expressive code. I'm not even afraid to be wrong by suggesting you to go and talk to Yurii or José about the other aspects they prioritize when making the Elixir, but from my pint of view, those listed are the main features that make Elixir that great.
They're lightweight processes, not green threads. What you heard is a Java programmer trying to cope. Threads share memory access. Processes don't.
Good point. Just to verify, I'm correct about the one kernel thread per processor core, right?
Depends on how the deployment is configured. You can have less or more.
I think that the fact that "VM kills itself when it runs out of RAM" is completely unsatisfactory. The unique feature of Erlang VM is that there are "units" that can be safely destroyed without affecting other parts of the system - Erlang processs. VM may crash because of a driver error or something of that nature, not because it runs out of memory.
This goes back to Erlang's roots. You CAN NOT have a reliable system on a single hardware node. In most cases, running out of memory is a serious and unrecoverable error that can lead to horrible edge cases (trying to use disk swap, causing ever increasing load and delay). Also, GC is done on a per-process basis in Erlang, so you don't have the giant wicked GC hits like you do in Java, nor the long delays and memory gaps leading up to it. This means that if Erlang runs out of memory ... it probably really ran out of memory unless you made one of the "big 4" Erlang mistakes. Most "modern" VM's approaches to handling out of memory issues are bug ridden, slow and hard to maintain, debug and correct... and damned near impossible to prove. Because Erlang is designed to be clustered and reliable, the most sane thing to do is to kill the VM (and if you want, let the heartbeat process restart it)... let it reconnect to the cluster and spin itself back up.
http://prog21.dadgum.com/43.html -- Goes into some detail on the big 4. 
To make it clear what normally happens. In an Erlang system you have a number of light-weight processes. These are not, as StoneCypher writes, "Green threads". They do not share memory space, nor stacks, and the stack grows from a very small one as is needed. When an Erlang system starts, it starts up a number of schedulers. Normally you run as many schedulers as you have physical CPUs. Each scheduler has its own run-queue onto which erlang LW processes are mapped and run preemptively. Every once in a while processes are migrated from busy schedulers to less busy schedulers. Also, if a sheduler suddenly runs out of work, it can do work-stealing from another scheduler. At any point in time, the number of active shedulers might be lower than the number of cores. This happens when there is not enough work left, so you can turn off a scheduler and save power. A hint is that Ericsson runs Erlang on solar powered GSM masts in Africa :) Besides the scheduler threads, you may add "asynchronous threads" trough the +A option to erlang. These are used for blocking I/O calls (on the disk) so a disk operation does not block a given scheduler. Network I/O is handled by one scheduler currently, which runs select(2) (or epoll, kevent or /dev/poll) to obtain sockets with changed state. This is done at regular intervals. Work is ongoing to split this over multiple schedulers.
Thanks! I appreciate you clearing all of that up. Do you work for Ericson or just use Erlang a lot? Anyway...thanks!
I just use it a lot. At work. But j no, I don't work for Ericsson.
This is just super-nice, thanks for sharing!
The book is [available](http://nostarch.com/erlang) for 40% off for one week. 
Thanks for posting this. I tried to post it, but it seems I'm blacklisted in this subreddit. Not sure why.
?
I posted the link to the same page (I'm the author) and while I can still [see the post privately](http://www.reddit.com/r/erlang/comments/16br0x/ann_learn_you_some_erlang_now_as_a_dead_tree_book/), it appears nowhere in this subreddit, even when going through the 'new' section.
My pleasure. Thank you for writing such an awesome book. On an somewhat unrelated note, I have read your [HN comment](http://news.ycombinator.com/item?id=5027165) on the submission about recent programming books and I fully agree with you. If I may say so, your book is _the_ book for learning Erlang.
I'm relatively new to Erlang, I love the language and "what it stands for" yet I've never had an excuse to try and write something I'd use in production. However, the idea came to me about trying to lock network accessible resources and I thought I'd try this crazy idea of mine..... Reference Golang client included.
This might be of interest: http://code.svn.wordpress.org/elockd/
wat
Easy solution is to use a combination of folding and updating the counter in a dictionary using dict:update_counter From there, the rest is trivial %% Givens you've provided {ok, Binary} = file:read_file("file.txt"), WordList = string:tokens(binary_to_list(Binary)," "), %% Fold over all words, an increment a counter for each word WordCounter = lists:foldl(fun(Word,CounterAcc) -&gt; dict:update_counter(Word, 1, CounterAcc) end,dict:new(),WordList), %% Convert dict to list and sort, comparing the counters for each word SortedList = lists:sort(fun({_,Counter1},{_,Counter2}) -&gt; Counter1 &gt; Counter2 end,dict:to_list(WordList)). SortedList will be a list of the words in the list along with their counters in the form: [ {"Word1", 6}, {"Word2", 4}, {"Word3", 3}, ... ] From there, you can do whatever you need with that list. Either extract just a list of the words: OnlyWords = [Word || {Word,_} &lt;- SortedList] And get just the first 20 words with their totals: {TopWords,_} = lists:split(20, SortedList)
I must be doing something wrong, he never responds to commands..
thank you for response, please wrote at github issues what are you doing step by step and I will fix it.
Sorry for the off-topic response, but I just thought I'd toss this in, because it was fun for me: The Haskell implementation of a function that converts a list of words into a list of (number-of-occurrences, words) pairs, sorted from greatest to least, is: hist = sortBy (flip compare) . map (length &amp;&amp;&amp; head) . group . sort A full program that uses the function might be: import Data.List import Control.Arrow hist = sortBy (flip compare) . map (length &amp;&amp;&amp; head) . group . sort main = do t &lt;- readFile "foo.txt" putStrLn $ unlines $ map show $ take 20 $ hist $ words t This by way of pointing out that Haskell is kinda cool. I like Erlang/OTP a lot, but my ideal world would have OTP-like libraries on top of a Haskell-like language. 
&gt; Surely you realize that every insert or modification into and read out from the dict is lg n, as compared to getting it in a single pass with a sort? So, n elements at lg n gives us n lg n, as opposed to sorting which is... :p 
yboot date &gt; foo it even writes to files! :)
Darn those kids, and their nasty shells too!
There's [Cloud Haskell](http://www.well-typed.com/blog/70). I've been researching [Akka](http://akka.io) + Scala for work recently and it's probably worth a look too.
Which doesn't really have much to do with my point (originally joke). I was pointing out you saying n repeated log n things was worse than a sort was silly because sorting is n log n (just to make sure we're on the same page here)
I try again today, now it responds.. not sure what changed.
Thank you all for your feedback. It's young project, and we fix all bugs which we and you can find. Now i fix that you can access to shell command &gt;, halt, &amp; and etc... Also we add campfire chat supporting. Development is gradually :) Thank you all.
I haven't used it yet, but it looks really cool. Thanks for all the hard work!
That sucks, your impact on Erlang is awesome.
Now, we released Ybot-0.2, xmpp and campfire support added, more new plugins, also Perl and elixir-Lang plugin supports.
Nice! I didn't know about this plugin before. On another vaguely related note, how did you get the background dark? That's awesome! I make the editor dark but then it's like staring at a black sheet of paper surrounded by a light bulb.
Thanks. Settings &gt; Appearance &gt; Theme. Please, select the Darcula theme there.
Oh nice, thanks!
I might be doing it wrong, in the little window down the bottom, the reults for my rules are showing doubled. ::error:{assertEqual_failed,[{module,rules_engine_rule_tests}, ::error:{assertEqual_failed,[{module,rules_engine_rule_tests}, {line,34}, {line,34}, {expression,"rules_engine_rule : has_fired ( )"}, {expression,"rules_engine_rule : has_fired ( )"}, {expected,false}, {expected,false}, {value,true}]} {value,true}]} in function rules_engine_rule_tests:'-simple_event_no_fire/0-fun-2-'/1 in function rules_engine_rule_tests:'-simple_event_no_fire/0-fun-2-'/1 Is it something I've done ?
Actually, i see it in the [screenshots too](http://ignatov.github.com/intellij-erlang/images/rebar_eunit.png )
Looks like an issue. Please, file it on https://github.com/ignatov/intellij-erlang/issues/new. Thanks.
Yeah, will do.. it looks good so far.
https://github.com/ignatov/intellij-erlang/issues/169 If I knew a bit more java, I would help out, but my java is weak.. 
Fixed.
404
Recently we released Ybot-0.3 version, now it supports GTalk, xmpp/irc via ssl, http, HipChat and etc... https://github.com/0xAX/Ybot/blob/master/Changelog.md#ybot-03----released
I love this guy's videos. Check out the rest of them too, they're brilliant.
I also like "Node.js is Bad Ass Rock Start Tech" http://www.youtube.com/watch?v=bzkRVzciAZg
perhaps a poor joke ?
One of my biggest gripes is this: You have a section of code, say a lists:map/2, in a file spread over several lines in a file. You think I want to test that code in the shell so you try to copy/paste. It works, but also dumps out hundreds of lines of crap in the shell.
tuples are practically equivalent to structs. Records are syntactic sugar over tuples that come in handy when you have tuples with a lot of members. sounds to me like you need a list of tuples?
Thanks ill give that a try ! I think my main problem is i just haven't gotten into the design mindset of it yet still trying to program in the way i'm used to ! Time will only help! thanks again 
erlang has a surprinsigly simple core. Just be careful not to make the mistake to dive into OTP *before* you reall understand it though. [This](http://learnyousomeerlang.com/) is a great resource.
wx fixes is a welcome addition
Just out of curiosity, what do you use wx for? I'm a huge Erlang fan, but I wouldn't use it for most GUI centric apps and if an Erlang application does need a GUI, using some html/js frontend seems like a more natural fit for most use cases.
debugger:start() and observer:start() not actually writing any apps with wx
It's beautiful and easy to use, uhm, just the way we like it!
I thought I would prefer it, but nope.
At the moment, this is a "proof of concept," which may be another way of saying, "just because something can be done does not mean it should be done." :)
Thanks!
I've just looked at it quickly, but why shouldn't it be done? I got real curious about porting it to Haskell...
My purpose in doing it was to make it more fun to start learning Erlang. "Let's use lists:foldl/3 to get the sum of these numbers" isn't as exciting as 'Let's use lists:foldl/3 to sum these numbers and use that result in this cool graphic." The problem is that Erlang was designed for making "massively scalable real-time systems with high availability" (as erlang.org states). This module is very far from Erlang's purpose. In terms of implementation, I'm passing an incredible number of messages and spawning processes at a furious rate, and that bothers me from a moral purity standpoint.
Wings3D is built in erlang (http://www.wings3d.com/) and that's pretty decent, so graphics isn't too far from what it's good for! &gt; In terms of implementation, I'm passing an incredible number of messages and spawning processes at a furious rate, and that bothers me from a moral purity standpoint. It's nice to have a language you get to do that and get away with it though :)
I had totally forgotten about Wings3D; I should look at it to see how they solved some of the problems.
I got to watch Joe Armstrong's reaction at the premiere, it was pretty great.
&gt; Did you know that EXPM is not only good for Elixir but for all other BEAM-based languages such as Erlang, Joxa and LFE? also, the [efene language](http://marianoguerra.com.ar/efene/). So, EXPM aims to be like to [OPAM](http://opam.ocamlpro.com/) (OCaml package manager) eventually?
Nice
I wish Joe could not only explain the how but also the why this flag was brought up. Edit: Fairplay, Joe got me :)
April fools. It's a joke on the financial sector.
Good job. I've been meaning to write a similar tutorial.
I am still happily reading the first book :)
Have you read "Learn You Some Erlang"? If so, could you tell me if it's still a good purchase? Does it add anything to the LYSE book?
Introductory blog post: http://blog.paralleluniverse.co/post/49445260575/quasar-pulsar
Ahh, makes me immediately jump up and yell "yes!" So many times have I gotten an error along the lines of 'Cocoa Error:-852' (example, and not verified here but there are a lot of error codes to be found) and could not find a definition of such an error. I'll type 'macerror -852' in the terminal and retrieve a script error because it bombed trying to retrieve the definition of an unknown error. That's a double whammy!
One thing I look for in interviews is empathy, yes, from developers as well. Do they have empathy for the users or even other developers who would use their code. Showing cryptic and scary messages to users shows a lack of empathy. I like Joe's idea of having 2 types of error messages. Well...actually there should be 3 error messages: 1) shown to the user 2) logged for the developers 3) what in the process of development or testing allowed for this error to happen
Is this the algorithm this is based on? http://www.cs.indiana.edu/pub/techreports/TR481.pdf
I'm using rebar as build tool and git/github as 'package manager'. Not sure why I need another central repository. But EXPM seems to be nice. I think I will try it with Elixir. My new playground in learning new programming languages. 
Shrug... I was looking around for one like PHP's composer. But I failed.
This is _very_ nice. Having all the latest info and links in one place is a great help.
* The syntax is pretty alien to a lot of people * being functional(ish) never does you any favours as far as popularity goes -- most functional languages in the modern sense are fairly niche, as a quick survey will show you. * relatively specialized in purpose. People have used it to make 3D editors and program robots, but it's not the common thing you see people do with it. * lack of libraries (which is, of course, to some degree a consequence of it not being as popular) * lack of viable alternative implementations -- until a short while ago, there was only really one available (which is, of course, to some degree a consequence of it not being as popular.) I don't know how far erjang and such have come along nowadays. * standard library that is 1) fairly geared towards a specific purpose, rather than trying to be very general, 2) kinda messy, TBH. There is a lot to be desired Erlang is a great language for a lot of server-side stuff, because it solves a lot of the icky problems for you right off the bat, but if people have substantial code-bases, they often prefer to use the same language on front- and back-end. That can be seen for instance by the popularity of node.js &amp; cohorts. It makes more sense to them to be able to transfer both pre-existing knowledge as well as pre-existing code to the server-side, rather than "heterogenizing" their stack and re-implementing their functionality that may already exist neatly encapsulated in javascript on the client-side. Even if that may happen at the cost of other things -- for many people, the productivity boost/speedup in development time trumps it all. Some of these issues are unique to erlang, but a lot of them affect many of the other non-mainstream languages. Some of these issues could be solved by the community, some could be solved by the developers, and some are not really "solvable" as such. Edit: looks like erjang is dead, AFAICS
If you run in the right circles, Erlang is a mainstream language. It's just not a mainstream language with the .... masses. It's taken me a long time to accept it, not wanting to be an elitist, but there are different kinds of people. Some people teach themselves and are eager to learn programming languages because they like computers, or they have problems they want to solve and they seek out the best solution. (This latter is how I came to erlang) I call these people hackers. Most people, though are not like this. Most people need to be trained and like a kid being made to do his homework they think of learning new things as work. They don't do it if they don't have to. So, they just use the tools they were made to learn in school (and these people tend to put a very high value on getting a computer science degree, because they would know nothing if they hadn't learned it in college, they tend to assume this is true of the hackers (who generally taught themselves in high school or before.)) So, when you see people say they aren't interested in erlang because the syntax is different, you see people who won't spend a trivial amount of time (a couple weeks) learning a new language that gives them great power. They don't care enough, they just will use whatever language they already know. Despite hanging out on the misnamed "Hacker News", most "hackers" are not really hackers. Software development, once the provenance of the autodidacts has become a profession with trained people, and the trained people outnumber the hackers by 10-1 or something like that. It's not a problem with erlang, it's a problem with the profession. 
Check out Elixir - http://elixir-lang.org - Armstrong even wrote about it recently: http://joearms.github.io/2013/05/31/a-week-with-elixir.html
I would say one reason is that Ericsson has never pushed the language in the same sense that Sun did with Java or Microsoft with its languages. One reason for this is that Ericsson is not in the software business, they do produce a lot of software but their main business is building and selling "boxes". This being said they definitely do support the language and the BEAM implementation and have made it all open source.