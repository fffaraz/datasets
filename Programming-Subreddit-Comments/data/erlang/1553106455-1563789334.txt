Someone liked Elixir, and things happened.
As someone who works in both (but started with Elixir) it will not confuse people. There are some quirks that sometimes become irritating (like lambda calling), but that is minor problem as, TBH I do not call lambdas that often. I use them all the time, but I do not call them in my application code. Also Elixir‚Äôs macros are on completely different level when you compare them to the Erlang‚Äôs meta programming. So while there are some minor issues, I would restrain myself from stating that this is CoffeeScript in the Erlang world, it is more like Groovy/Kotlin in the JVM universe. 
Not only what the other commenter said, but in my opinion, Elixir is easier to start and more expressive (thanks to macros). So from the business perspective it is almost pure win (easier to find/train developers and development can be faster). 
I watch elixir programmers get tripped up by that stuff every day, but okay 
I agree with you but: Macros are much more of a secret weapon of power users than a selling point to newcomers. The real kicker is that Ruby and Python people aren't quite so scared to pick up Elixir even though the underlying semantics are effectively the same. Yes, Elixir might wrap a stateful genserver and call it an "agent" but really they're just getting tricked into writing Erlang through a very well developed DSL.
&gt; elixir is to erlang what coffeescript was to javascript It is incredible how people continue to spout complete nonsense even after plenty of opposite evidence. Proper Unicode support, protocols, the with construct, GenStage are all improvements from the top of my head that Elixir bring beyond the syntax level. But of course, after decades of telling others that syntax does not matter, the first criticism of Erlang developers towards Elixir is about syntax.
How is Elixir mis-teaching strings when it is exactly the same data-types as Erlang, the difference being in syntax?
&gt; It is incredible how people continue to spout complete nonsense even after plenty of opposite evidence fun thing: i've spoken both languages for almost ten years, one for almost 20, and i don't see any of your plenty of "opposite evidence" yet . &gt; Proper Unicode support Would you be more specific, please? . &gt; protocols aren't really much different than behaviours, but also, elixir is still struggling to use the behaviours from the rest of the language . &gt; the with construct this is your idea of a language improvement? ***really*** ? . &gt; GenStage is much less powerful than the things from OTP that it's trying to replace . &gt; But of course, after decades of telling others that syntax does not matter i'm not sure why you believe people say this. you seem to be doing all the talking about syntax here . &gt; the first criticism of Erlang developers towards Elixir is about syntax. i didn't say anything about syntax. you're just trying to ignore what i really said by cramming me incorrectly into some stereotype
by using the same scalars (not datatypes) as erlang but swapping around their notations. it's not a complicated comment. i'm having a pleasant conversation with someone else. given the acid in your tone elsewhere, i'm disinclined to want your participation here. incoming: "they're linked lists, that's a datatype" and some eye-rolling
Probably because Elixir is shiny and new, Erlang is ugly and old. &amp;#x200B; It's getting reaaaally difficult to land a good job in Erlang if you're not willing to do at least some Elixir. Before Elixir, it felt like screaming in the desert. Now it feels like screaming in the desert with ruby hipsters looking at you funny.
&gt; Would you be more specific, please? The String module which allows you to perform Unicode based operations on binaries since 2012, around 5 years before Erlang reworked their string module to work similar to Elixir's. And still in 2019, if you want to use Unicode characters in Erlang, you need to add magic comments if you want to avoid errors under certain situations. &gt; aren't really much different than behaviours, but also, elixir is still struggling to use the behaviours from the rest of the language Protocols are different entities to behaviours, not only in Elixir, but also in literature, and they provide different expressive power. Plus "Elixir is still struggling to use the behaviours from the rest of the language" doesn't make any sense. &gt; this is your idea of a significant language improvement? I didn't say it is significant but it is a useful feature, yes. Both Elixir and Erlang run on the same VM, you aren't going to find major changes, but a bunch of small improvements can provide an overall better experience to many developers. &gt; is much less powerful than the things from OTP that it's trying to replace GenStage it is not trying to replace any OTP behaviour as there is no equivalent behaviour in OTP. &gt; i didn't say anything about syntax. You literally commented on it being a bunch of "minor, unimportant syntaxes differences" and mentioned that Elixir is equivalent to coffeescript, where coffeescript is by definition only a syntactical wrapper around javascript, while Elixir does provide a standard library, tooling, a package manager, etc. It is totally fine to dislike Elixir and to find Erlang a better language but you are clearly mischaracterizing Elixir, either on purpose or due to lack of understanding.
This is very helpful. I thank you!!
A ha. Thank you for sharing these thoughts!
TBH I have never used Elixir `Agent` outside of testing and mocking. And most other Elixir developers I know do not use `Agent`s either. So for me this is convenience module for rare usage (TBH I do not know why this is in core, but can be useful from time to time). 
&gt; refusing to let ruby go Come on, the only common point between Ruby and Elixir are the def/end keywords.
&gt; Elixir's first release is not even seven years old, oh for. "it's eight years old and you've used it for almost ten!?!?!??!" Elixir's first full release was in January of 2011. That's eight and a half years. one, yes, eight and a half years gets called almost ten by some people. two, i didn't look the date up. three, it was available on irc long before its official release. looking at my old SVN repos, I've actually been using it more than ten years. four, frankly, I'm having a hard time deciding whether to read the rest of this, because it's some redditor in "prove them wrong" mode fortunately you sent me a hilarious rage mail explaining that you were blocking me, and appealing to me to still read what you said, so... . &gt; the unicode problem i said was important in erlang isn't real anymore oh pro tip: it wasn't real before elixir existed, either. all elixir did was take a community module and integrate it. you know, kind of like how node people used express for ages before the http module . &gt; erlang magic comments in situations i work on erlang in unicode every day. no, you don't. . &gt; &gt; protocols aren't much different &gt; &gt; yeah huh and no specifics oh . &gt; &gt; &gt; &gt; there's few major differences &gt; &gt; &gt; &gt; &gt; &gt; with &gt; &gt; &gt; &gt; with seems major to you? &gt; &gt; I DID NOT USE THE PRECISE WORD MAJOR but yes it's nice oh. odd how everyone gives niceties when i ask for major differences . &gt; Both Elixir and Erlang run on the same VM, you aren't going to find major changes Gradle, Clojure, and Scala roun on the JVM LFE runs on the EVM My point was that elixir didn't add anything important. You seem to be trying to explain why I'm correct, but in tones of teaching, and using arguments that don't hold water . &gt; GenStage oddly, their own manual page sees this differently, but okay . &gt; You literally commented on it being a bunch of "minor, unimportant syntaxes differences" No. I said the blog post was a bunch of minor, unimportant syntax differences. Not Elixir. It'd be nice if you would read more carefully before yelling at people. . &gt; and mentioned that Elixir is equivalent to coffeescript I said that it was like it, not equivalent to it. In the way that a DeLorean is like a commodore 64, in that they were underpowered in their day, are wildly impractical today for dozens of reasons, but also people still hold a personal love for them, seek them out as collectors' items, and maintain them far past their useful life. I see that you're trying to escalate me into saying things that I didn't say, by replacing words. How's that going for you? Like doesn't mean equivalent to. Like means shares some uncommon qualities. In this case, what I was referring to was that I felt this was a language by ruby people who refused to give up ruby, and wanted to learn another language without learning another language. I stand by that. . &gt; It is totally fine to dislike Elixir I don't dislike Elixir. I'm glad you're giving me permission to have emotions, though. Thank you for your kindness, controller. . &gt; you are clearly mischaracterizing Elixir, Another possibility is that you're seeing things in what I said that aren't actually there. I didn't characterize Elixir at all, so I feel that I cannot have mischaracterized it. That you claim that I dislike the language, and that in private you insisted that it "triggered" me, suggest that you're arguing with someone that lives in your imagination.
I'm not sure I've ever seen you write Elixir code.
&gt; Elixir's first full release was in January of 2011. That's eight and a half years. That's a lie. After looking at the git repo, it is clear the first **commit** was in [January 2011](https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b). The releases page lists the first release back only in [May 2012](https://github.com/elixir-lang/elixir/releases?after=v0.7.0). &gt; looking at my old SVN repos, I've actually been using it more than ten years. I double checked with the maintainers on IRC and I was reassured that Elixir did not exist before January 2011, in any shape, nor public or private. So this is another blatant lie. &gt; all elixir did was take a community module and integrate it Another lie. At the time, the Unicode libraries would all load the data into ETS on boot which would be a pain during development and quite slow at runtime. Elixir's approach of dynamically generating the module was novel in that it was at least an order of magnitude faster. I remember that shortly after its release there were direct ports of the Elixir implementation to Erlang. But I know you are going to claim that you have a SVN repository that generated Erlang Unicode modules, possibly before Erlang was even created, or maybe insist that having an efficient Unicode implementation is "not important". &gt; My point was that elixir didn't add anything important. You seem to be trying to explain why I'm correct Quite the opposite, there are many important improvements, which is why some of them are making it back to Erlang. At the end of the day, they add up to something significant. Seriously, I don't understand why you insist on lying when there is plenty of evidence otherwise. I will stop here because this is a tiring exercise.
You've also never seen me write c, c++, php, prolog, css, sql, x86 assembly, 680x0 assembly, arm assembly, thumb assembly, formulaone, ml, ocaml, perl, or any of a host of other things. I put a sticker over the spy cam you placed on me as a teenager. That thing you've been watching the whole time is actually a [Famous Drinking Bird](https://www.amazon.com/Drinking-Bird-4975-The-Famous-x/dp/B000JSGLBK?th=1).
&gt; That's a lie. &gt; (fumbling around about how the first public commit isn't the first release) &gt; So this is another blatant lie. &gt; Another lie. &gt; Seriously, I don't understand why you insist on lying (checks fingernails.) Melodramatic much?
But you did lie. Elixir has not existed for as long as you claim.
If you google "when was Elixir originally released," the table at the top says 2011, and the post two things down says "in January." No, I didn't lie. I quickly googled it and believed the results I got, because like I had already said, I didn't care that much and wasn't checking. This guy is getting wildly bent out of shape over a detail that is entirely irrelevant to what I originally said, in the hope of creating a reason to be angry. 
You said: &gt; it was available on irc long before its official release. &gt; &gt; looking at my old SVN repos, I've actually been using it more than ten years. Elixir has not existed for that long.
&gt; Melodramatic much? It is not melodrama. The whole point is that it makes no sense to discuss with someone who is just spouting bullshit. &gt; So, I guess I feel like there's not much purpose in continuing. On the positive side, you are not doubling down on your lies anymore, so I would consider that a win.
&gt; it was available on irc long before its official release. I believe that it was. Maybe I'm mistaken? I don't really know, or care. This is irrelevant to my point. I could swear that I remember Jose being an #erlang regular that used to talk to rvirding about lfe. But maybe that was someone else. That was a long time ago. It's also completely irrelevant to the point that I was making. I don't understand why you are enmountaining this molehill. . &gt; [You said:] looking at my old SVN repos, I've actually been using it more than ten years. I also said: &gt; Looks like the .exs I found in SVN is actually some game script instead. My mistake. shrugs This is *also* irrelevant to the point that I was making. Yes, I see you guys doing your very best to prove me wrong at niche concerns that aren't related to my point, that I keep saying I could be wrong about. That's nice. Be sure to say "liar" a lot. 
(checks watch) That's nice.
There's publically visible examples of all of those except for the assemblies, but not elixir ;)
I write lots of stuff there's nothing published for 
&gt; how can I stop feeling queasy any time I have large numbers of (erlang/elixir) processes doing I/O on the same file descriptor? If you are opening files in`raw` mode, then I don‚Äôt think it is safe, see the Erlang docs: http://erlang.org/doc/man/file.html#open-2 &gt; raw Allows faster access to a file, as no Erlang process is needed to handle the file. However, a file opened in this way has the following limitations: Only the Erlang process that opened the file can use it. A remote Erlang file server cannot be used. The computer on which the Erlang node is running must have access to the file system (direct
Thank you for your response. I'm going to describe my understanding of the situation, and I would love to learn what I have wrong: &amp;#x200B; The elixir program gets compiled into an escript binary; when clone()/execve()ed, that binary inherits file descriptors opened by the shell (bash) that invoked it. escript "packages" (I'm sure there's a better term for this) the stdout into something that IO.puts/1 uses by default. I never open the file explicitly. I'm using poolboy ([https://github.com/devinus/poolboy](https://github.com/devinus/poolboy)) with many worker processes which each handle a directory, and queue encountered directories to be handled by further poolboy processes; to each poolboy process I've passed a function which the poolboy process calls invoking IO.puts/1 with the file name of each directory entry name encountered\[0\]. If IO.puts/1 were unable to access stdout, I would expect either a failure of each of my poolboy processes or no output at all, since I believe the poolboy processes get created after the open stdout descriptor is available from the very beginnin of execution. &amp;#x200B; \[0\] Apologies for posting elixir code to an erlang group, but the elixir has stayed the same, while an erlang update has changed the behavior. The future intent is that proc\_entry do something more elaborate(?) than print the file name, but before I get more ambitious: &amp;#x200B; `proc_entry = fn(name, _stat) -&gt;` `IO.puts("#{name}")` `true` `end` &amp;#x200B;
This is super cool! I really like how much thought you put into the type conversions. Some questions: 1. Can I call Erlang from the Lua script? 2. Can I pass functions from one language to another, return a Lua callable than can be called from Erlang? 3. Does it support co-recursion between Erlang and Lua? This is really cool, I'd really love to seem some examples.
Ah ok there‚Äôs special handling for stdout - all output goes via a group leader process. There‚Äôs some info [in the elixir docs](https://elixir-lang.org/getting-started/io-and-the-file-system.html#processes-and-group-leaders) and some more on [this Erlang users list post](http://erlang.org/pipermail/erlang-questions/2018-April/095179.html) 
I have in two projects which to my knowledge are still in production. If all you need is an ephemeral state store and ETS is overkill, Elixir agents actually are a shortcut to that.
[Just some unimportant guy that finds that Elixir improved some parts of Erlang and has ideas worth ‚Äúbackporting‚Äù](https://joearms.github.io/index.html#2013-05-31%20A%20week%20with%20Elixir). 
In summary: 1. Use the same string transclusions we've all been asking for since the 90s 1. The pipe operator 1. Fix the shell bug around functions 1. Tagged template literals 1. perl heredoc 1. The lisp macros that rvirding has wanted the whole time interestingly, you quoted the word backporting explicitly, which doesn't seem to be present in the article
PHP do not have pipe operator. Also PHP do not run on EVM, so I do not get that point at all. It seems that for some reason you despise Elixir in general, and you do not see, that it brought more popularity and developers to BEAM community. Heh, whatever. 
It's really boring watching elixir fans announce that I despise Elixir just because they can't say anything interesting about it 
Is there a youtube version, or some other version which can be watched at high speed?
Youtube URL: https://www.youtube.com/watch?v=xi-ixFPjNpc
https://www.reddit.com/r/erlang/comments/b5d350/video_and_slides_midair_airplane_repair/ejei9yp
Thanks!
I often can't connect from my ISP in Romania. When that happens I use a proxy in Frankfurt. Quite annoying 
There was a DNS issue, which should be resolved by now.
Still broken for me :/
Great talk: very informative and fun!
Is it still broken?
Nope works now
I've used agents in production applications cause I was lazy. Now you know one.
Just providing my experience. I did not pay enough attention to my work environment at first. It made things really hard. Learn rebar3. Apart from that, Erlang felt really simple, maybe poor. The language itself should not pose any major issue. 
Sigh, you again with false claims. And one last time: it is not about the individual things, but rather providing all of those as a feature set. That's the interesting part: choosing what is in the language (and what isn't). You are not required to find it interesting but there are plenty of people that do (including Joe). But sure, please continue projecting into everyone. 
Can you find something better to do, please, than resurrect five day old threads to be aggressive? Thanks.
I have never used it, but thought it would be fine to poke it with a stick. So .. I started a tftp daemon and passed the resulting pid to `tftp:info/`: &amp;#x200B; `1&gt; {ok, Daemon} = tftp:start([{port, 9999}]).` `{ok,&lt;0.85.0&gt;}` `2&gt; tftp:info(Daemon)` `2&gt; .` `{ok,[{type,daemon},` `{host,"127.0.0.1"},` `{port,9999},` `{local_port,9999},` `{port_policy,random},` `{udp,[{active,once},{reuseaddr,true},binary]},` `{use_tsize,false},` `{max_tsize,infinity},` `{max_conn,infinity},` `{rejected,[]},` `{timeout,undefined},` `{polite_ack,false},` `{debug,none},` `{parent_pid,&lt;0.81.0&gt;},` `{callback,[],` `{re_pattern,0,0,0,&lt;&lt;"ERCPG"...&gt;&gt;},` `tftp_file,[],undefined,undefined},` `{callback,[],` `{re_pattern,0,0,0,&lt;&lt;"ERCPG"...&gt;&gt;},` `tftp_binary,[],undefined,undefined},` `{n_conn,0}]}` Aha! There is the timeout param! Only ... NOPE. You can not reset that one. Anywhere. It gets rejected by the option parser as not a valid option. Ooooook. So a quick trip to RFC 2349 referenced in the tftp module docs and it seems that timeout is a tftp option. Oooh. And there is a tftp option mechanism in options, and \*that\* works: &amp;#x200B; `15&gt; tftp:change_config(Daemon, [{"timeout", "250"}]).` `ok` And looking in the tftp\_file implementation there is this: &amp;#x200B; `do_handle_options(Access, Filename, [{Key, Val} | T]) -&gt;` `case Key of` `"tsize" -&gt;` `case Access of` `read when Val =:= "0" -&gt;` `case file:read_file_info(Filename) of` `{ok, FI} -&gt;` `Tsize = integer_to_list(FI#file_info.size),` `[{Key, Tsize} | do_handle_options(Access, Filename, T)];` `{error, _} -&gt;` `do_handle_options(Access, Filename, T)` `end;` `_ -&gt;` `handle_integer(Access, Filename, Key, Val, T, 0, infinity)` `end;` `"blksize" -&gt;` `handle_integer(Access, Filename, Key, Val, T, 8, 65464);` `"timeout" -&gt;` `handle_integer(Access, Filename, Key, Val, T, 1, 255);` `_ -&gt;` `do_handle_options(Access, Filename, T)` `end;` &amp;#x200B; So it looks like it does handle this option there! I do not have a tftp client kicking around to test this, and I am now out of time to dig further, but maybe try this and see if it works? &amp;#x200B; And yes, the tftp docs are pretty sketchirific. :/
soooomething like this perhaps: &amp;#x200B; `Index = binary:longest_common_prefix([Id, Node]).` `IdByte = binary:at(Id, Index).` `NodeByte = binary:at(Node, Index).` `8*Index + (8 - trunc(math:log2(IdByte bxor NodeByte) + 1)).` longest\_common\_prefix gives the length of the common prefix. from there we can then get the next byte in each binary (if you do not know the sizes of the binaries, then you will want to do a size check first to make sure Index is not out of bournds...). then we get the first different bit between those bytes by binary xor'ing them and then asking for what log2 of that is and then add one for the ones-place in binary .. then minus that from the 8 bits in a byte ... then add the number of bits in the common prefix ... number of bits common! &amp;#x200B; not well tested (by which i mean: not tested at all! haha.. sorry :) ) but should hopefully be close. &amp;#x200B; really interested in seeing your kademlia implementation! do you have git repo link yet?
That's way nicer than my shitty solution, which involved converting everything to a lists and recursing through them. So thanks! No, sorry, no repo link yet, this is an academic work (bachelor thesis), so automatic plagiarism checks are a concern. But I'll make a note of your username and send you a link when that's no longer a concern (I'm thinking two months, probably). I'm planning to release it under GPL if it's decent enough to be a net positive for the world. The project itself is kind of like BitTorrent with an added layer of relational metadata, for use in distributed social media.
oh wow. Thank you very much. I now see what I did wrong, I was doing tftp:change_option(daemon, [{"timeout", "250"}])... So close! 
Nice project! Best of luck with it, and thanks in advance for droppong me a link :)
Why RPC at all? And what it has to do with Erlang?
Nice to see some Efene in the wild!
thanks :)
Does anyone know what happened? Just last month I watching him on a panel.
I am so fucking shocked
What a bummer. Great dude. Also - he looked as someone in good health.
RIP, Joe.
My name plaque on my cube at work has a quote from Joe: &gt;"You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.‚Äù -- Joe Armstrong :(
This is shocking not only because you think of your heroes as immortal, but he had this energy of a dude who'd live past 120.
Sad news indeed :( One last time, ["Hello, Joe."](https://www.youtube.com/watch?v=uKfKtXYLG78)
According to a commenter on /r/programming he'd been suffering from lung fibrosis for some time, in January his lung capacity was down to 50% and by the end of the course it'd gotten bad enough lectures had to be cancelled: https://www.reddit.com/r/programming/comments/bfchzb/joe_armstrong_the_creator_of_erlang_has_passed/eldqd5n/?context=42
Sad news. He was an inspiring teacher. I'm happy I had the good fortune to meet him.
This got me too, he always appeared to be full of life; seemed sharp and energetic, It was quite a shock to imagine otherwise.
F
Have you tried uninstalling and then passing the `--build-from-source` option to `brew install`?
That's good idea, but when do I need to edit the file (edlin.erl)? If I use `brew install erlang --build-from-source` it downloads new sources and starts to compile it.
Why?
Recursion is basically asking a function to call itself. Each iteration of calling itself is like an iteration in a loop. Tail recursion is like a for loop. Each iteration of the loop is neatly contained, and the iteration finishes neatly at the end. In particular, it means that the function ends with either a solid answer, or a single call to a single function.
tail recursion might be easier to understand with some examples. &amp;#x200B; the factorial function is tail-recursive because the last step is just one recursive call. in pseudocode: \`\`\` factorial 0 = 1 factorial n = n \* (factorial (n - 1)) \`\`\` in this case, the last thing that gets computed before returning is just a call to the same \`factorial\` function with the value of n - 1 as its argument. whereas other recursive functions, like for example, this function that returns the \*n\*th fibonacci number, are not tail recursive: \`\`\` fibonacci 0 = 1 fibonacci 1 = 1 fibonacci n = (fibonacci (n - 1)) + (fibonacci (n - 2)) \`\`\` because instead of the last step being to just call itself with some argument, it has to call itself twice, and then perform some additional operation on the result. because the last step of the computation is actually a \`+\` operation instead of a recursive call, it's not tail-recursive.
I went digging through some old Erlang exercises I was working on back when I was trying to make sense of tail recursion, let me know if this helps: The task was to write a function (or series of functions) to test if a string was a palindrome. % First attempt. This is not tail-recursive. % is_palindrome([], []) -&gt; true; % is_palindrome([H1|T1], [H2|T2]) -&gt; % case H1 =:= H2 of % true -&gt; % is_palindrome(T1, T2); % false -&gt; % false % end. % Second attempt, this is tail recursive is_palindrome([], []) -&gt; true; is_palindrome([H|T1], [H|T2]) -&gt; is_palindrome(T1, T2); is_palindrome([_H1|_T1], [_H2|_T2]) -&gt; false. In the first example, I had buried the recursive call to is_palindrome(T1, T2) inside a case statement, and had not used it as the final instruction in the function. Both methods will work, and return the same answer, but the second version, while it was trickier to write, is the one that takes advantage of erlang's optimizations for tail recursive functions.
Both functions are tail recursive here, and I believe that both functions have tail call optimisation. If you implement some server loop with a receive clause and some code to handle the values received, you can still loop forever.
Not sure if it can help but to understand tail recursion you can imagine this code : for (i = 0; i &lt; length; i++) { do_something(i); } And a tail recursion version in Erlang : for(I, I, _DoSomething) -&gt; ok; for(I, Max, DoSomething) -&gt; DoSomething(I), for(I + 1, Max, DoSomething). But this is not really great code. The full module: -module(for). -export([for/3]). for(I, I, _DoSomething) -&gt; ok; for(I, Max, DoSomething) -&gt; DoSomething(I), for(I + 1, Max, DoSomething). And then a shell session: $ erl Eshell V10.1 (abort with ^G) 1&gt; c(for). {ok,for} 2&gt; for:for(0, 10, fun(I) -&gt; io:format("~p~n", [I]) end). 0 1 2 3 4 5 6 7 8 9 ok
Hmm, I must have received some incorrect advice when I was first trying to figure this out. Thanks for the clarification!
https://www.reddit.com/r/erlang/comments/bjyb7o/could_someone_explain_recursion_please/?utm_medium=android_app&amp;utm_source=share
&gt; Both methods will work, and return the same answer, but the second version, while it was trickier to write, is the one that takes advantage of erlang's optimizations for tail recursive functions. Note that [tail recursion isn't always faster](http://erlang.org/doc/efficiency_guide/myths.html#myth--tail-recursive-functions-are-much-faster-----than-recursive-functions). The last line could have been written ```is_palindrome(_,_) -&gt; false.```, incidentally. No performance impact, just less noise.
Because its not usable for me
I‚Äôm just curious for your use-case (where it‚Äôs unable). The absolutely easiest to disable I can think of is `TERM=dumb` (although `^G` likely won‚Äôt work).
"Faster" isn't the only concern all the time though. I've written functions that worked very well, but blew up the stack and crashed if you tried calling them with a large enough input number. A TCO version wouldn't do that. I've often wondered what potential DoS vectors lay in some of the functions we write.
Hi, It is tipical tail recursion. The clause where N=0 is the termination condition that outputs the final result. You have to go from initial number N to number 0: hence you in every pass decrease the number by 1
Wow...thank you for clarifying makes sense now
You're welcome. Feel free ask again in case of any doubts. Nevertheless, I recommend to look at https://learnyousomeerlang.com/content . It's a perfect material
This is where I got the example from, just something I was hoping you could clarify for me with regards to pattern matching. Is _ like a placeholder value?
_ means any value _Anything with underscore - means match against, but do not bind. But beware, if you have in pattern matching two same variables names they have to be the same: (_A, _A) matches only the case, where the two values are the same. (_A, _B) matches any values (_, _) matches also any values
thank you very much :)
got to meet him at EUC 2016 - this is heartbreaking
OK. Let me see if I can help. I made two diagrams for you. One is kind of confusing since it mixes function evaluation with message passing, the other one just shows messages. TL;DR: Your understanding is pretty accurate. The only flaw I would spot is that when "someone sends a stop", the server doesn't "send the atom 'ok'", the function that the server process is evaluating *returns* `ok` and since that function was completely evaluated, that process is terminated. So, the diagrams: ![Everything](https://www.websequencediagrams.com/cgi-bin/cdraw?lz=dGl0bGUgRXZlcnl0aGluZyAoRnVuY3Rpb24gY2FsbHMgJiBNZXNzYWdlcykKCm5vdGUgcmlnaHQgb2YgWW91CiAgICB5b3UgYXNrIHRoZSBzaGVsbAARBXRvIGV2YWx1YXRlIGV4YW1wbGUvMAplbmQgbm90ZQpZb3UtPgApBToAFwcoKQBRDwAYBgBNBiBzcGF3bnMAXgZlcnZlcgoAZgUtPj4qUzoADAcAKhh0aGF0IHJldHVybnMgUywgYSBwaWQKUy0AeQggUwCBVAZvdmVyIFM6AFoLIGJsb2NrcyBvbiByZWNlaXZlCmFjdGl2YXRlAC0IAIEOIWNsaWVudACBJQpDOgAMByhTAIFrBwBzBQCCNQUsAHkGAIEkCwCBJwUAgT0FJ3MgaWdub3JlZApDAIExCkMAgw8GbGVmAIIiEgCBawgnb2snIHRvIHlvdQCCLwctPllvdTpvawAvDgCBEQkgc2VuZHMgJ2hpADMFAIJqB0MtPlM6e21zZywgImhpIn0KZGUAgX0QAIB_CACDCgkgcHJpbnQAgzIGbQCEQwYKUy0-Uzpmd3JpdGUoIlMgZ290OiBoaSIAggEMAIJVMACBOQkAhQwFAIE3DnN0b3AAgTsMICAgIGFuZCBkaWVzAIUGCgCBWAVzdG9wAINyGQArBQCBZg1kZXN0cm95AAEJeSBDCgo&amp;s=modern-blue). ![Just Messages](https://www.websequencediagrams.com/cgi-bin/cdraw?lz=dGl0bGUgSnVzdCBNZXNzYWdlcwoKbm90ZSByaWdodCBvZiBzaGVsbDoAAQYgc3Bhd25zIHRoZSBzZXJ2ZXIKABoFLT4-KlM6AAwHKCkAPAZvdmVyIFM6ACILIGJsb2NrcyBvbiByZWNlaXZlCmFjdGl2YXRlIFMAUCdjbGllbnQAbQpDOgAMByhTAHEHbGVmAIE0BQARCSBzZW5kcyAnaGknIHRvAIExCEMtPlM6e21zZywgImhpIn0KZGUAfRAAQggAgVIJIHByaW50AIF6Bm0AgioGClMtPlM6ZndyaXRlKCJTIGdvdDogaGkiAIFJPACBOQkKICAgAIE2D3N0b3AAgTsMICAgIGFuZCBkaWVzCmVuZCBub3RlAIFXBnN0b3AAgnIZACsFAIFmDWRlc3Ryb3kAAQl5IEMKCg&amp;s=modern-blue)
I thought ASDF was a Lisp build tool. I'm confused.
It is, and I am, too.
I thoroughly recommend this tool. I‚Äôve been using it for years, and it‚Äôs a great way to manage install versions across projects. I also use it inside alpine docker images for development. Works great with direnv too.
The first issue is that your helper method is generating 'improper lists' - if we expand out a call to `helperRepeat(3, 2)`, we get something like this: helperRepeat(3, 2) -&gt; [3|helperRepeat(3, 1)] --&gt; [3|[3|helperRepeat(3, 0)]] ---&gt; [3|[3|3]] If you look at the final representation, you'll see that the innermost value isn't a list with one element `3`, it's _just_ a 3. To fix this, we can change your `helperRepeat` method to this: helperRepeat(Val, 0) -&gt; [Val]; helperRepeat(Val, Repeat) -&gt; [Val|helperRepeat(Val,Repeat -1)]. Note that the final `Val` is now encapsulated in a list. When we re-run your repeat method, now we get this: 9&gt; foo:repeat([1, 2, 3], [0, 4, 1]). [[1],[2,2,2,2,2],[3,3]] So the lists are now proper. However, our output from `repeat` is still a list of lists. You can solve this by calling `lists:flatten` on the output: 10&gt; lists:flatten([[1],[2,2,2,2,2],[3,3]]). [1,2,2,2,2,2,3,3] or by using the `++` operator instead of the `|` operator, in which case [helperRepeat(X,Y)|repeat(Xt,Yt)]. becomes helperRepeat(X,Y) ++ repeat(Xt,Yt). Note that your call structure is such that you cannot benefit from tail call optimization - each recursive call in both `repeat` and `helperRepeat` will force the interpreter to push another stack frame, since your final operation is not a function call. There are some [excellent tutorials on this](https://learnyousomeerlang.com/recursion), and I would suggest you see what they have to say about it and the accumulator pattern, which is generally the way to solve this.
Excellent! Thank you for walking me through that! I got the result I was looking for. Thanks also for that resource, I was struggling to figure this out using the documentation.
Joe wrote a piece that can help you here https://joearms.github.io/published/2016-03-13-Calling-Elixir-From_Erlang.html I miss you Joe.
Think of Elixir as a superset of Erlang. You won‚Äôt loose out at all. I would say though that Erlang is more compact and has less magic than Elixir. It‚Äôs a good vehicle to get introduced to functional programming. I can‚Äôt recommend Armstrong‚Äôs book on Erlang more highly. OTOH Elixir has a fresher and more vibrant ecosystem. Learning Elixir means that you can use the Phoenix framework for instance. Why don‚Äôt you learn both? The languages are not very big and different under the covers.
Erlang (or my favourite Elixir) sounds like it could work well for your problem. It‚Äôs great for reliable network services. Getting top performance for CPU bound code is harder when you don‚Äôt have mutable data structures, but calling out to C (or rust / go) can be used to address hotspots. Most of the community is on the forum https://elixirforum.com or slack https://elixir-lang.slack.com/
Thanks for the input. So to address output I would need to run different programs, by example in C, on the fly. But I'm wondering about the performance of this action, because it will like to start many OS processes for each communication between ErlangVM and the C programs --- which are slower and heavyweigthed compare to the Erlang processes. Also, it may raise the problem of the hot code reloading, which in this case it's maybe not supported well.
Sounds like [port processes](http://erlang.org/doc/tutorial/c_port.html) could work for calling C plugin programs. Some [pooling](https://github.com/devinus/poolboy/blob/master/README.md) can be used to prevent spawning too many os processes.
Yes definitively port could work. How hot code replacement works for ports ? Is it possible or do I need to use port drivers ? Also, if a port is already open, does the Erlang process is smart and not open a new one by just sending him the message ?
This is a 40 minute talk from GOTO Chicago 2019 by author of 'Elixir In Action', Sa≈°a Juriƒá. I have pasted in the talk abstract below for a read before you dive into the talk: &amp;#x200B; Whether you're developing a small web site or a large-scale distributed system, Erlang and Elixir are great tools for building server-side systems. Both languages can help you start quickly and deal with highly complex problems at a large scale. This talk aims to explain what makes Erlang and Elixir suitable for such tasks. We'll look past the syntax and the ecosystem, focusing instead on the concurrency model of these languages. Combining a bit of high-level theory and a couple of demos, we'll examine some important properties of Erlang/Elixir concurrency, with a special emphasis on why these properties are very relevant when building highly available systems. The talk targets experienced backend developers, but no knowledge of Erlang or Elixir is required. You will walk away from the talk with a better understanding of what distinguishes Erlang and Elixir from the rest of the pack, and why these languages are very compelling choices to power your next software system.
The important concepts and semantics are all inherited by Elixir from relying on the Erlang virtual machine and ecosystem. But there are conceptual differences, or even just different ways of thinking about problem-solving in Elixir, otherwise it wouldn't have been worth creating a new language. The semantics of the VM and ecosystem are great and what gives Erlang it's concurrent/parallel/distributed processing power, but much of Erlang's actual *syntax* focuses on its sequential subset of the language, which is unfortunately very primitive. That superficial syntax is not as important as the rest of the underlying semantics, and so that's why there have been languages of various styles and paradigms put on top of the Erlang VM, such as Lisp-flavoured-Erlang (which brings Lisp homoiconicity), Gleam (which brings ML-like static typing), and of course Elixir which is inspired by Ruby yet very different. &amp;#x200B; Elixir's improvements mostly regard syntactic sugar and style, but also other concepts that won't contradict how the ecosystem fundamentally works. One example is protocols, which brings polymorphism to the ecosystem. In contrast, Erlang syntax had no way of supplying this, so that if different primitive types were involved, you would have to locally use "case", guards, or pattern matching to explicitly dispatch the intended code to run. And you would have to do this everywhere it is required, rather than defining this in one place. People mistakenly think OOP is required to have polymorphism, but that's not true. But Erlang's lack of it didn't help. Erlang also tends to rely on its "record" data structure for essential types, except records aren't real types at all! They don't even exist at run-time, they are just syntactic sugar that exists at compile-time. Erlang's rather inconsistent standard library and over-reliance on records can be frustrating. Elixir fixes all this by ditching records and instead relying on protocols and things that are usable at run-time, like maps and "structs" (which are another way Elixir helps with allowing user-defined types). &amp;#x200B; Elixir's pipe operator doesn't add new concepts, but it does bring the *concept* of functional programming and the *syntax* of functional programming closer together. Conceptually, a function takes input from the "top", transforms the data, then spits the result out the "bottom". So using multiple functions together is conceptually a chain of functions and should *look like a chain*. But the traditional historical syntax of calling functions forces the user to nest functions inside their parameters lists. So chaining looks more like nesting, which is confusing and hard to read. The pipe operator fixes that so there is no mental overhead translating visual nesting into semantic chaining. The *flow* of chaining functions looks like a chain. If a language is a functional language, then if functional programming (i.e. the most common thing you do) is made awkward, then the whole language will be awkward. Erlang tends to be awkward compared to Elixir in this respect. &amp;#x200B; There is even more to it than this, such as Elixir's more consistent standard library which includes a lot of patterns/solutions to common problems, and metaprogramming that uses code to generate code so that Elixir can be run at a higher level of abstraction than just functions and primitive types. Metaprogramming allows you to add your own syntactic sugar or new semantics. For example, this person added OOP on top of Elixir (mostly as a joke, so please don't use it since it's a bad idea!) [https://github.com/wojtekmach/oop](https://github.com/wojtekmach/oop)
Great video. I just discovered Erlang and it makes me appreciate it more thanks :)
in simplistic views, When hot swapping code, erlang actually have both versions in memory and runs the old version until your code calls a function with the full name (brain freeze here, what is it called) eg. MODULE:FUN(Args) at that time it calls the new code. so if the execution is in a fun of your old code it will continue to run until it changes the module
I'm general, when doing communication between processes, I would lean towards leveraging OTP. Process B should be a genserver (supervised) and process A should issue a gen_server:call to process B and get the result that way.
this. also in your second example \`Response\` would be \`action\` and non blocking as opposed to the first example.
If B is a genserver, two requests are coming concurrently, and if the first request calling B fails, the second will impacted? Or every call/cast are spawned process? In OTP, is there a system managed by the supervisor to replay when fails? (until X failures happens and send back error to the client)
If process B fails/crashes then any messages in it's mailbox will be lost. However, if you are using genserver:call you will receive a timeout error in the caller that did not receive a response (mag's that were still in mailbox). You can use this to determine if you should retry the call. Disclaimer: I am not an expert in OTP, just a fan. There may be more elegant ways to handle this. üòâ
Thanks very much :) not problem. I'm starting to be fan also. But i'm wondering why it's not more famous and educated....
Even for ports? Erlang is keeping two versions?
There is no good answer. What are you trying to achive, why do you need two processes ?
Example it's a server handle request from client each connection is handle through a new process or is it a general connection handler process witj handle through message
Most erlang web servers handle each connexion with a single process, sometimes more.
So imagine a process handling a connection which relays on a business process. Is this process must be already created and receive calls(business process still running), or just spawn a new business process and get response (the business process will be killed after)
That depends if you need state. &amp;#x200B; If your business process needs to keep some state, and change this state after handling requests, it's best to start it at the application startup and then communicate with it with messages. &amp;#x200B; If you do not need state, you do not even have to spawn a business process just to kill it afterwards. Just execute the code in your request process.
Great thank you :) But if my business code crashes, maybe it is better to use task or process to be able to supervise it, without crash the connection process and be able to retry few time
Well you can juste use try/catch for that.
But it is not opposite with the "let ot crash" philosophy?
This philosophy applies to processes and supervision trees. If you know how to handle an error, handle it. But if you don't, then it will crash and it is not a big deal since your whole program will not be impacted by this failure, or will be able to recover. It really depends on what you want to do. Here you give little details on that.
for ports programs use the dirty schedulers. I guess it is when the port program finishes that the change is. it is usually a good idea to implement port programs that finishes in a timely fashion. otherwise you should probably not have them running within the vm.
Yes true.. Thanks for the details :)
I don't know for sure what he's referring to but I know our team didn't use distributed features of elixir very much because of the potential for split brain problems. They wouldn't have been impossible to fix, but at our scale it was much more efficient to just rely on a single database for locking and being the single source of truth in the system.
He does not explain what his issues are, so it is hard to address those. It does not help the veracity of his claim that he just basically says, "It's broken, trust me." \*shrug\* He is promoting swarm (which is a pretty nice library, fwiw), so he isn't coming into that completely neutral. As an aside: his justification for swarm being a dependency being obviously the right place for distribution makes absolutely zero sense. But that said, there are a few undesirable things with distribution in Erlang, and he is right that most if not all are implementation issues (and therefore fixable) rather than fundamental to the design. Ones I am aware of: * by default distribution is handled by a separate process (epmd). This is actually not necessary anymore, and it is easy to replace epmd (and even alter how it works) with a simple module in your own app. * there is still only a fully-connected mesh topology offered. That presents scaling issues, which are resolvable with alternative topologies with some routing of messages included. There is work to address this, but it does not seem near to being folded into the official beam+OTP distribution yet. * security is limited. not an issue if you are using distribution on a private network behind front-facing systems. but the cookie and not having tls by default is all a bit 'meh' .. it's unecessary overhead in a 'sealed' private network, but if you want to run this anywhere publicly routable, you'll want that. * the use of binary\_to\_term/term\_to\_binary for formatting on-the-wire messages is insanely suboptimal for a lot of common data structures in modern applications (though more than fine for small messages) due to its serialization format (at least now it does the serialization reasonably quickly ... now it just makes HUUUGE buffers for the wire, and requires them to all fit in memory ..) &amp;#x200B; That said ... distribution still works rather nicely, and all the above can be fixed under the covers without changing the way network-transparent message passing works from the perspective of the application code written on top of the BEAM.
I'm not too knowledgeable on the topic of distribution but Christopher Meiklejohn has done some real fascinating work on alternative methods of distributed programming using Erlang. He has a project called Partisan that he's been working on as part of his thesis and this year at code beam he showed some improvements he's made to it and compared it to standard Erlang distribution. https://youtu.be/KrwhOkiifQ8 Hope it helps.
From u/sasajuric himself: https://www.reddit.com/r/elixir/comments/bronlx/discover_what_makes_beam_languages_such_as_erlang/eohwr3r/
If you are using `rebar3` as your build tool, you can include the [rebar3_mix](https://github.com/tsloughter/rebar_mix) plugin to build Elixir dependencies. I don't know if there is something similar for erlang make. To actually call an Elixir function, you will need to use the following syntax. `'Elixir.Module':function(Arg)`. As a full example, lets call elixirs `String.trim/1` function. `'Elixir.String':trim(Str)`. Note that I have never actually used the `rebar3_mix` plugin.
I have done something similar (generate Erlang gen_statem from XML). It entirely depends on your need and the type of state machine. I ended up writing a function to handle my transitons, e.g.: statemachine(State, Event) -&gt; NewState). If you have a moore machine, you can then perform some action depending on the new state: statemachine(NewState) -&gt; action(). If you have a mealy machine, you can first generate a transition, then peform an action for the transition, and finally calculate the new state. The code generation is quite simple with python. I ended up using f-strings most of the time.
Maybe http://howistart.org/posts/erlang/1/ ?
[There are other options besides state_machine_cat](https://stonecypher.github.io/jssm-viz-demo/graph_explorer.html)
Thanks, I will try f-strings or [jinja templation](https://blog.kangz.net/posts/2016/08/31/code-generation-the-easier-way/).
There indeed are. But state\_machine\_cat seemed to be the simplest with good coverage. I was originally looking for a js-based canvass for building (mealy) state machines, with a drag-and-drop from palette, that would generate a json (or some other standard). Found Rappid, but was expensive.
Hey guys, i just released v1.0.0. Since the port runs outside of erlangs safety net, every bit of help is especially appreciated to make it as rock solid as it can be. I have no plans to add features/complexity from now on and will be concentrating on fixes. Thanks for reading, have a great day!
Can you talk a bit about what makes your project different from something like [luerl](https://github.com/rvirding/luerl)? Obviously yours runs outside of Erlang while Luerl runs inside the VM. But what other types of choices did you make that lead to this project?
I suppose he is a master of the Tango as well...
He must have been really ‚Äòenthousiastic‚Äô about it.
Lol yea that is bothering me too. The website owners are dutch. Is that a common translation mistake or something? The spelling mistakes riddling this website and the insane claims from their developers have me worried about trusting it with my money...
Since this is a scammy cryptocurrency project, I wouldn't be surprised if all of these people were completely fake.
/r/iamverysmart
&gt; scammy cryptocurrency project Ya think? When I try to navigate away from the about page (say by entering something in the navigation bar), it reloads the about page. How odd.
I've heard Dutch is similar to English in a lot of ways, so maybe it was a spellchecker-dictionary conflict? Yeah, it seems strange to master Erlang in a week, but not proofread your bio page: one of the main pages that gets you an offer. They must at least have a friend of a friend who is fluent in English enough to take a read. I'm pretty sure there are external proofreaders if you really need one. The most confusing part for me was the last person who basically just had 'I know maths' in stark contrast to the rest of the group.
It's a naturally developed but multiple times completely rewritten project for the joy of it and to facilitate some multiplayer game ideas i have. Luaport makes it possible to use [lua c modules](https://github.com/asciibeats/lua-protobuf). It is faster and becomes more viable with complexity of script. A logical next step would be to use luajit over vanilla lua, if you really want that edge. And it shouldn't be that hard to do.
SO many crypto related jobs using Erlang.
I know this supposed to be about the Erlang part but holy shit this is dangerous. "Investing" in bitcoin is already bad but derivatives on them is crazy. This is a derivative exchange put on by people who don't know the difference between an American Option vs European Option. From their FAQ: &gt;Are Options European style? &gt; European Vanilla Style. Exercise is automatic if they expire in the money. Cash settlement in &gt; the equivalent of bitcoin. That isn't correct. European Options can only be excised the day they are set to expire while American Options can be excised at any given time. If they are truly European Options then you can buy one expecting to be able to excise but not being able to. It could lead to massive losses.
Yea... math expert who controls user interface design?! You don't hire plumbers to entertain at your kid's birthday party...
con-currency using concurrency?
Well, while I know nothing about the company, the person mentioned did manage to find a stack smashing bug in the VM and reported it [https://bugs.erlang.org/browse/ERL-944](https://bugs.erlang.org/browse/ERL-944), so there's that.
That's not all that strange. A lot of mathematicians work outside of actual math jobs. Software development and project management are common. Studying math doesn't just teach you, well, math, but also an abstract way of thinking that is rather unique to mathematicians.
Check out elixir nerves
If you have hard real time requirements, you shouldn't go for any garbage collected language. Or anything non-deterministic. For example malloc; you dont know how long will it take or even it is gonna succeed so you probably should allocate everything you need before entering main loop as long as possible. Imagine you are in remote operation, doctor is cutting you via robot hand aand hand is just freeze because garbage collector or out of memory. üòÇüòÇ But if you have soft real time requirements erlang will be just fine. It designed for highly concurrent, soft real time systems. It has per process gc so there is no big gc stop and also it guarantees context switch each bla bla instructions.
erlang would be good at orchestrating thousands of ev3-powered robots
i remember when it was time for coffeescript to die, they had all started explaining how to integrate with gradle
You think elixir is gonna die? Any reason for that?
True! Thanks
Looks interesting
A lot of us have been augmenting the beam with native code... just look at how many packages on hex.pm come with some. Rust brings some nice advantages over some other popular options and has really great support on the beam side thanks to libraries like rustler. This is absolutely no different to how much native code is used in libraries to accelerate python, btw.
Really hard to say anything without a link to code..
Things don't die for a reason. They die for lack of a reason. I didn't have a reason for it around dart, coffeescript, perl, php, kotlin, flex, groovy, etc either.
[https://github.com/ArtamonovAlex/BarOBeerChat](https://github.com/ArtamonovAlex/BarOBeerChat)
A link to a repo.. sorry, not going to dig through it :/ Here is how Elixir does it: https://github.com/elixir-lang/elixir/blob/v1.9.0/lib/elixir/lib/io/ansi.ex
Is it just me or does anyone else get "502 - Bad Gateway" from Medium?
cloudflare outage today
Ahhh üòä
Is it me or the whole point of the article was to claim that Elixir docs are better than Erlang docs? Low quality shitpost :) IIRC Joe's Erlang book goes very early on into the details about how operators behave.
Made a reddit account just to be able to upvote this. This is pun perfection!
Not sure about the future. Erlang &amp; Elixir popularity stats from StackOverflow [https://insights.stackoverflow.com/trends?tags=erlang%2Celixir%2Ctypescript%2Ckotlin](https://insights.stackoverflow.com/trends?tags=erlang%2Celixir%2Ctypescript%2Ckotlin)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [Manuel Rubio - PHP over Erlang: how and why? | Code BEAM STO 19](https://www.reddit.com/r/elixir/comments/cd1rq1/manuel_rubio_php_over_erlang_how_and_why_code/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Yeah.. no.
I‚Äôm calling the police
I would take Twig over EEX anyday, but not PHP directly ;) Funny experiment though.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Wish I could go, but it conflicts with Rosh Hashana
You can pattern match on a constant list prefix, but not a general pattern in the middle of the string. In your case I‚Äôd go for a [regex](http://erlang.org/doc/man/re.html#run-2)
You could also consume the list until you read the leading [, accumulate what characters exist until the terminating ]. That‚Äôs essentially what the re lib is doing for you, as an over-simplification on my part.
&gt;You can pattern match on a constant list prefix How?
You can‚Äôt, not with pattern matching alone. You probably want a regex. If the size of what is inside the brackets is always the same length though, you could do it though.
http://erlang.org/doc/reference_manual/expressions.html#string-prefix-in-patterns
then why not to do this: f(Str ++ "{fdsafds}" ++ Str2) -&gt; .. won't this work?
Try wrapping your `Terminator` options in a grouping: Terminator = (\n|\r\n|\r) I believe what's happening is when you combine the un-grouped version into your later compound clauses, the regex is getting misinterpreted.
Wow thanky you, this solve the issue a little bit, it allows 1 foo, but it returns an error for: *---\\nfoo\\nfoo\\n---* &amp;#x200B; `% src/standard_syntax_lexer.xrl` `Definitions.` `Terminator= (\n|\r\n|\r)` `MultilineStringDelimeter = (---)` `StringContent = (foo)` `MultilineStringContent = {StringContent}+{Terminator}` `MultilineString = {MultilineStringDelimeter}{Terminator}{MultilineStringContent}+{MultilineStringDelimeter}` `Rules.` `{MultilineString} : {token, {string, TokenChars}}.` `Erlang code.` &amp;#x200B; `'---\nfoo\n---'` `{:ok, [string: '---\nfoo\n---'], 3}` &amp;#x200B; `'---\nfoo\nfoo\n---'` `{:error, {1, :standard_syntax_lexer, {:illegal, '---\nfoo\nf'}}, 3}`
No. The beginning of the string must be a compile time constant. It‚Äôs helpful to see how Erlang strings are De-sugared to lists: the leading list elements must be known to match: [$p,$r,$e,$f,$i,$x | Str]
If you're moving on to the next step of trying to delete the delimiters, you can do that by running a function against TokenChars, but i believe you'll end up needing to redefine your matching patterns down in **Erlang code** to run a proper regex, which is a bummer. Instead, you might consider just using leex to do the tokenization part (as in, just use it to decide what delimiters and content look like), and then leave the interpretation of the ordering of those symbols up to yecc, the rules there can decide that content surrounded by delimiters is a multi-line string.
Hmm, I am really curios what is the best practice or 'industry standard' for a lexer: {multiline\_string, 'foo\\nbar'} or {delimeter, '---'}, {string, 'foo'}, {terminator, '\\n'}, {string, 'bar'}, {delimeter, '---'} &amp;#x200B; If I do it like the last, I can also add an escape character, so for input: '*''foo\\n\\'''\\bar'''* {delimeter, '---'}, {string, 'foo'}, {terminator, '\\n'},{escape\_character}, {delimeter, '---'},{string, 'bar'}, {delimeter, '---'} &amp;#x200B; And with yecc I can decide if the delimeter is part of the string, or not. &amp;#x200B; Would this be the proper approach?
Probably create a pool of ports and communicate with them through a GenServer that manages state. You could look at how Ecto adapters work and maybe something like [Piton](https://github.com/mendrugory/piton) that manages a pool of ports with backpressure.
I'm afraid I can't speak to industry standards, having just played around with the lexer/parser for comparatively trivial cases, but you might like to poke around the elixir source code for inspiration on how to handle "heredocs". As far as I can tell, they don't actually use leex for parsing, but they do use yeec for parsing. https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_tokenizer.erl#L937 https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_parser.yrl#L880
Thank you very much :) I will consider that.
Or is the unix socket is an alternative to communicate with port or through temporary files?
Please, if you want to post the same question on r/elixir as well as on r/erlang then use x-post feature, so the answerer can write answer in one place only.
Thanks I didn't know this feature