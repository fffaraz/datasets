1. The syntax is pretty alien to a lot of people 2. The syntax is pretty alien to a lot of people 3. The syntax is pretty alien to a lot of people Ruby offered little more than syntax over other scripting languages. It has become rather popular. If you want people to use it, rework it. PHP has been demonized for language peculiarities alone. You don't need to have a formal study performed to see the simple effect that syntax has in regards to adoption.
&gt; I think that if you are the type that avoids Erlang because of the syntax then what is going to happen when you get to semantics and usage? Wow. I really think that sheds light on the subject. Thank you for sharing your comment.
Very few people actually have to solve the problems that Erlang offers a solution for.
you implicitly assume that people who are as motivated as you * come to the same conclusion as to which language solves a problem best. But in fact, pretty much nobody ever agrees on this, ever. * care about the same kind of things you care about And you also assume that the people who disagree with you don't have very good reasons (however individual or specialized they may appear from your POV) for their opinions. For instance someone who says erlang is not a viable choice for him (instead of some other language x) because of the syntax, may very well have very good reasons, such as: * Already have a well-working IDE that supports x but not erlang * already have a good linting tool and static analysis toolchain for x but not erlang * already have said tools integrated with his CI or whatever, or the knowledge how to do it * have other processing tools, hooks et cetera which are geared towards the syntax of x but not erlangs * have a large team, deadlines and goals to worry about, meaning the syntax change is a big deal for them and will impact their productivity negatively * have other specialized needs that some (possibly weird language) x can fullfill but erlang can't. Maybe he has some major reason to use lisp because of homoiconicity? * Maybe the person has just started out programming, and learning a completely different syntax and paradigm is too much for them et cetera.
I think you are oversimplifying here, and conflating syntax with things that are more in the realm of semantics (as well as conflating "getting a lot of flak" and "not being popular"). PHP syntax is perfectly average, apart from a few "retard moments" here and there (like using "\" for namespaces, wrong associativity for the ternary operator and closures) I think it even compares favourable to perl, which I much prefer to PHP as a whole. I think the main reason it has gotten so much flak is because of its badly structured, ill-thought-out and buggy standard library, its badly put-together and buggy implementation, its lacking/incomplete/late support for a lot of important concepts (like OO, namespaces/modules, closures), and just the overall style of programming it encourages its users to exercise. But as we can clearly see, that didn't hurt its popularity a lot -- its still way above ruby in popularity, by any measure.
No, but some syntaxes are easier for people than other syntaxes. As I recall, old versions of Fortran don't reserve words and don't use spaces to delimit identifiers. No modern language does that, and for good reason. People dislike LISP not necessarily because it has a lot of parentheses, but because it can be a hassle to keep them balanced. Likewise, people might dislike Erlang because it's a hassle to keep , . and ; straight. Or, I don't necessarily want to use a language that punches me in the face every day. (Don't get me wrong, I like Erlang and don't mind the syntax... but I can understand disliking it based on its syntax).
+1 for pragmatism over idealism.
If you look at http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html , you'll notice that the most popular languages are the ones with the rather complex (difficult to learn and difficult to parse) syntaxes. C++ possibly optimizes this list, being on spot 4 with its incredibly complex syntax. C or lisp may minimize the list. C is much more complex, but it is on place 1.
Not sure if you're ignoring reality or trolling. C/C++ is taught at every known educational institution and most have a paired assembly class. The vast majority of developers START with those languages. This dichotomy is not about what people choose to adopt.
I have no clue what you are arguing, but if you need an example of a simple language that isn't popular, well, look at the myriad of lisp dialects out there or so. Syntax matters, but it's not the only important thing.
That is tantamount to saying you can't introduce new primitives or idioms because they won't be recognizable and people will be unwilling to learn them. Unfortunately the strengths of Erlang and other functional languages are the new primitives and idioms which **don't** have any mappings to the "standard" syntaxes which means you are going to get a new strange syntax. You can't have it both ways. The ironic part is that Erlang syntax is much simpler than the syntaxes which most people consider normal and easily understood.
More irony, , . and ; in Erlang behave as they do in non-programming languages so the solution is to not complicate things.
I dunno, I might say something like "get me a Coke or, if they don't have any, get me a Pepsi." I'm using commas, but an equivalent Erlang construct would want semicolons. I stick with my claim - that keeping , ; and . correct is a hassle, though I would further qualify that it's particularly hassleful as files change. Suppose I want to comment out the last clause in an case expression... I also have to mess with punctuation. It's not a deal-breaker, but it's a hassle. It's worth looking at other languages. C# initialization syntax permits trailing commas, while Javascript does not. Not a deal breaker, but the C# approach is nicer (especially since C# initialization syntax can be used in more places than Javascript's). Also compare Java to Scala - Java requires trailing semicolons, Scala makes them optional. Add enough of these little conveniences, and people will flock to a language, because the act of interacting with the code is simply more enjoyable. Erlang syntax could use some love, I think even Joe agrees; perhaps that's exactly what Elixir does.
Doesn't it also clean up the standard library a bit?
While I agree there are parts of Erlang syntax that are tedious to work with, I don't think that's the three biggest reasons Erlang hasn't enjoyed mainstream adoption... Semantics and idiomatics is probably a much larger obstactle for people coming from e.g. Java.
That was the only real problem listed. Others were just variations of the it's not popular problem. 
&gt; That is tantamount to saying you can't introduce new primitives or idioms You just made that up. I said it hurts adoption, which is demonstrably true.
&gt; Syntax matters, but it's not the only important thing. I'm not arguing. I'm stating an opinion that can be drawn from observation. Unfamiliar syntax is "why erlang never got the mainstream status".
Recently, yes, after it became apparent that we couldn't keep on scaling single processors. Erlang was designed to solve problems 99% of the world didn't even have at that time, as most developers were still struggling with single core or isolated systems.
It really organises the standard library a lot and makes it much nicer to work with (and remember what does what)
&gt; I stick with my claim - that keeping , ; and . correct is a hassle, See I am not sure if you are trolling or not. Maybe you are not. You are starting to dissect Robert's claim that Erlang's (a programming language) syntax is more similar to English by showing an exception to the rule in English (an evolved spoken language). Robert's point still stands, they do behave roughly like in English. Roughly comma means a sequence of things as in: X=1, Y=X+1 This is a sequence of statements that will execute one after another and will return the value of the last statement. Semicolon means an alternation of choices, similar to OR operator; f(0) -&gt; 1; f(N) -&gt; N * f(N-1). Here is a complete function that computes the factorial of a number N. Notice the semicolon. When f(2) is called, f(0)-&gt;1; is tried first, if that doesn't match, which it won't, f(N) will match and will execute. Lastly the period means "end", just like in an English sentence. In the previous example after all the alternative calling patterns for the functions have been written the function definition ends with an '.' You mention Javascript. Well there is the Wat video. And that grinds my gears. It is not the syntax, it is the broken _semantics_ that I don't like. Insane casts, the meaning of 'this', semicolon pitfalls, there are enough for me to hate it basically. C# I like, it is more consistent and pragmatic. It learned from Java so it improved. Going back to Robert's original point. Erlang might not have the usual syntax but it is just the syntax. I will tolerate even worse syntax if I can have all the fault tolerance, built in distribution, concurrency and pattern matching. It is just a tool for the job at the end of the day. So maybe it is not a tool for all the jobs, but for some jobs it is the only tool.
&gt; You get the same semantics in other languages Please provide an example of a language that has a completely concurrent garbage collector, pattern matching, separate / isolated memory allocation heaps, lightweight concurrent and parallel scheduled actors, a built consistent distributed real-time database (Mnesia), built in multi node (multi machine) distribution. &gt; You get the same semantics in other languages, The point is you don't. &gt; People have only so much willingness to develop and memorize new patterns. Adding the cognitive load of a strange syntax on top of that and you get people walking away. Well don't learn it then. It is a tool. It is a good tool that fits certain areas perfectly where every other tools feels like a cludge. Have you written watchdogs and supervisor trees in other languages? I have, it is no fun getting that right. Here it comes built in. Now you can say, ok, I don't need that. Well then don't learn Erlang. 
This may be a bit much, but how about a distributed system that can perform either MapReduce or streaming computations? From what I've seen so far, no product appears to provide both. Erlang would be great for this since it's architecture lends itself well to command &amp; control systems as well as distributed computing. While you could have the mappers/reducers/etc. done in Erlang, I think it would be very cool if you could instead leverage code in any language that can read/write data via STDIN and STDOUT. My thought here would be that instead of starting the process for each file the mapper runs against, for example, you open the process once and Erlang manages where the data comes from. Like I said, it's just a thought, but I think it would be very useful to have one system capable of both as you could reuse code in both MapReduce and streaming applications without having to support two different architectures.
Thank you , I will look more in to this is sounds very interesting 
Anything you can come up with would be greatly appreciated sybrandy's suggestion seems great but I have to look at if I will have time/ability to do it :D
Thank you I will look into this :D
I work on the [Scalaris project](https://code.google.com/p/scalaris/). It is open source and maybe it is possible to figure out a good way for you to contribute. let me know what you think. 
Maybe , I think I may have to do a stand alone project though ! I will let you know when i hear more ! Thanks 
I wasn't suggesting elixir to solve the problems, but because you expressed an interest in other languages on the BEAM VM, you idiot.
You're not actually addressing the point I was making. Most of your reasons are not, in fact, good reasons at all. They are asinine. I never said erlang was the best language in all situations, either.
I expressed nothing, this was my first post in here. The multiple implementations hinted at by Amadiro were implementations of Erlang, not of alternative BEAM languages, given Erjang was an Erlang reimplementation on the JVM instead of on the BEAM VM. Before calling me an idiot, please make sure you get the right context, as it would be much appreciated. No need to be disrespectful.
This seems off-topic to me.
i think the main reason is it isn't a c like syntax. 
A cease and desist letter from Apple in 1..2..3.. :-)
But Elixir literally solves none of the problems mentioned, except maybe syntax, again. I hang in the Elixir channel in IRC and like to discuss it, but your suggestion was irrelevant to the current discussion. The comments I brought did not lack civility or insult you directly. That I disagree with your recommendation doesn't mean I believe you are an idiot. I will leave it to you to judge who between you and I ended up being the least civil to the other.
"Sell not virtue to purchase wealth, nor Liberty to purchase power." B.F.
Tx.
Looks interesting. I have been meaning to give elixir a try. 
That makes Ericsson sound like a good guy
As long as I don't have any moral crises while *erlang ing*, it's all good
&gt;your suggestion was irrelevant to the current discussion. He mentioned erjang was dead, so I merely suggested another BEAM language. It is not irrelevant at all. You don't get to just make shit up and decide thats "the current discussion" and then rationalize being an asshole for it. The fact of the matter is, my response was to his comment and directly relevant. As I pointed out already, and as you have continued to ignore.... those are the facts, which makes you wrong, all of your comments here dishonest, and your continuing to tell these lies inexcusable. &gt;But Elixir literally solves none of the problems mentioned, This is both false, and irrelevant. Having been called out on your rudeness, like the a coward, you double doen and prop up this strawman yet again. I never said elixir solved any particular imagined problems, so your pretending like your rudeness is justified by your opinion on that issue is bullshit. Your dishonesty here reflects on your character in a very bad way. Your repeated lies, in the face of pointing out your dishonesty show your unwillingness to accept responsibility for your incivility. You demand civility of me, but refuse to give it, which means you don't actually want civility, you just want your ass kissed, or at least to be free to be an asshole without being called on it. You strike me as one of those people so entitled in his own status that he must distort all of the rest of reality to fit his fragile ego, and in doing so you render yourself an honorless, integrity free, piece of shit. It's sad, if you'd been willing to think long enough to comprehend what I was saying, or honest enough to recognize your error ,you might be a decent human being. But you aren't and that's why you're a worthless piece of shit. 
You mean +1 for being an asshole rather than honest. If one is pragmatic, erlang is quite a good language for many situations. Alas, too many people on reddit are conditioned not to think.
You're like those assholes who destroyed slashdot (and hacker news and reddit)... you are an asshole to somebody, then when called on it, you make up irrelevant stuff, to pretend like the person you were an asshole to is wrong to object to you being an asshole. This is called blaming the victim. Then you pretend like you're being civil while being an asshole and they are being disrespectful when calling you on it. The fact of the matter is, I made a suggestion, I didn't say anything wrong. But your ego is so fragile-- probably because you aren't too bright-- that you can't tolerate someone making a suggestion, without piling onto them to try and make yourself look smart. You're an "everyone else is a troll" troll. The bottom line is- there was nothing wrong with my suggestion, and you are an asshole for attacking me for making a suggestion that isn't relevant to your interests. 
Just wanted to say this a great talk by Joe Armstrong. Thanks for sharing the link! 
I'll offer an alternate theory: When I think of "mainstream applications" I think of transactional business applications. And for transactional business apps, it's hard to beat a frontend on top of a good SQL database. Robustness is achieved because all of the application code is executing in its own process (isolated like an erlang process); and a good SQL database is quite reliable on its own and offers rollback, transaction isolation, and declarative constraints. Sure, it won't get 9 nines of availability, but most mainstream applications are fine with 3 nines (even if they care very much about correctness). I like erlang, but what does erlang have to offer in that picture? Until erlang offers something akin to a good SQL database (not that SQL itself is a requirement, but in the same general class of DBMS), it will not be a major player for transactional business applications. And it's pretty hard to fit a consistent DBMS into the erlang philosophy that's on par with something like PostgreSQL or Oracle.
This is exactly what I needed! I'm getting started with Erlang and besides the LSYE book and the official docs, I was drawing a blank looking for more resources. Thanks for sharing!
Hope that it will be useful for you :)
Very helpful list. Although as far as I remember Misultin is deprecated in favour of Cowboy (awesome piece of erlang code, by the way)
Great list! You might want to add Zotonic as a web framework / CMS. Zotonic.com 100% Erlang
Cheers!
Yes, now you can submit your pull requests to the otp github repository.
It seems having and IDE helps with widespread acceptance. Why, because people are lazy and want everything done for them. With the exception of C and JavaScript (because devs are forced to use JS by browser vendors) which don't have full featured IDEs. It seems this comes down to a matter of taste not semantics.
&gt; Why, because people are lazy and want everything done for them. That's not the only reason. People aren't machines. A large enough project needs compiler/IDE checking or making changes becomes a very risky/pointless exercise due to multiplied side effects. That's not withstanding code smells. People have different skill levels, engagement levels, knowledge (erlang idioms have to be searched for), etc. It's expected to have supporting toolchains. Ericcson has no interest in promoting their specialized ones, but we have a few.
Anyone know where this can be viewed after the event? In my part of the world, it was shown around 3am.
A lot of it is because other languages are still playing catch up. I doubt many will ever get to the level of fault tolerance that Erlang has. Erlang has been around for so many year and most features that were wanted have made it in already. (Except for maps, which we expect in R17). One doesn't want a language and platform to get crazy changes in it when a minute of downtime costs upwards of $10k. Features will be more closely evaluated before added in. Also apart from maps I don't know what else they would want from Erlang. 
If you were registered, you can just click the link and watch the recorded webinar. :) (I don't know what about the unregistered users)
Maps will do that. R17 hopefully.
ckjchz
Where could we find the slide?
OSS lessons from someone who cannot spell Linus name right ? I'll pass. ;-) 
That Heckler is Kostis Sagonas, the guy who led efforts for the HiPE compiler for a long while, and also sits behind the Dialyzer type checker, and has done some analysis relative to having JIT in Erlang before. Kostis seems to be used to heckling/interruption in that manner, and some people more familiar with the Erlang conferences have come to expect it a bit whenever he's in the crowd and he has done work on a topic similar to yours -- it also happened with talks on Property-based testing, if I recall correctly. For a while Joe Armstrong himself would heckle you if you talked about the web and making it easier, and he felt you weren't actually solving any problem he thought were annoying for usability. To be fair though, the heckling Kostis has done during Lukas' talk (the one linked in this thread) is the most amount of heckling I've seen in an Erlang conference, and was truly destroying the speaker's flow. I agree with that.
http://www.erlang-factory.com/upload/presentations/516/SF-JIT-Pres.pdf taken from http://www.erlang-factory.com/conference/SFBay2012/speakers/LukasLarsson
Thanks Ferd!
The main reason I ask this is that I would like to incorporate a meta-package for emacs and an installation script for non-emacs dependencies/useful external tools so that jumping into erlang development has less friction associated with it, but I am not incredibly familiar with what all tools exist and are considered the best in class currently for erlang development, so additional information about those topics would be greatly appreciated. Thanks
my erlang installation is on kerl. and I am developing on emacs. but I do not use anything extra other than standard erlang-mode. https://raw.github.com/huseyinyilmaz/emacs-config/master/user-init-erlang-mode.el When I debug I log current state. But I would like to hear how people are debugging their code. 
Edts is a game changer. Biggest improvement to my work flow is automatic recompilation of your buffer. This is then reloaded into a project node for easy REPL-style experimentation. 
I use sync to reload code. But edts looks really great. I will definitely try this.
Since I'm assuming you're the plugin author: thank you very much for your hard work. I've been looking for a long time for an IDE with Erlang support (and the fact that it's powered by IntelliJ makes it all the more awesome).
Thanks a bunch. This is the kind of info I was looking for. I was looking at enterprise deployment but I will probably go with a more established framework. 
Despite it's age Erlang has only been open source for the past 10ish years. It was originally proprietary software for Ericsson Inc. So while it has been around for a while it hasn't been open for use by everyone. It would be more appropriate to be amazed at how quickly people are adopting it now given the chance. 
Buy/Sell with ABC Buildcon Pvt. Ltd.-9716030121,9716040121. Unitech Ivy Terraces offers 3/4BHK luxury independent floors in sector-70 near Sohna Road, Gurgaon. http://www.abcbuildcon.in/projects/unitech-ivy-terraces/ 
I spent few hours (just for laughs) and implemented ZMTP protocol (both v2 and v3) in pure Erlang using ranch as socket acceptor pool.. So far its only rudimentary and supports req/rep but I'm planning to add full support (maybe over the weekend ;)
https://github.com/jlouis/erl-lenses
 X = #{a =&gt; 1, b =&gt; 2, id =&gt; b}. #{id =&gt; ID, ID =&gt; Z} = X. 2 = Z. Wow. That is pretty cool pattern matching semantic.
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
This helped me a bit, https://github.com/psyeugenic/eep/blob/egil/maps/eeps/eep-0043.md
Good one! 
I think it was a joke: Linus Thor-Valls
Slides are here: http://yowconference.com.au/slides/yowlambdajam2013/Duggan-Erlang.pdf 
Thanks a lot for posting this - I've learned about quite a few pitfalls.
Glad you found it useful - I've given that same talk in a few places now. One of these days I'm going to have to come up with another talk to give (suggestions welcome :)).
Well, personally I'm a big fan of presentations that share insights and tidbits of wisdom that are not easily found by following a bunch of tutorials online. The last thing I want is a standard 'introduction to X', unless X is something that hasn't been covered by a plethora of tutorials and books. I'm not entirely sure I've got much insight into what the community would enjoy most for another presentation (I moved to Akka, and haven't kept up with Erlang), but anything that can help beginners/intermediate make the jump towards a more serious usage of Erlang would be more than welcome. 
How about a talk on your experience with Erlang in the cloud?
Great read!
Glad you enjoyed it!
If you like Eclipse for IDE, check out ErlIDE https://github.com/erlide/erlide too. Sergey, thank you for the plugin. I use it everyday.
Elixir seems ideal for sneaking the erlang VM into a ruby shop, where the biggest resistance is usually "that terrible erlang syntax".
Seems like it could be viable, but since you can call each from the other, I'm not sure what I'd use it for.
How about Elixer2Erlang so we can get back to 'real' programming instead of dicking about with syntax changes?
well it will have that too just as my given example has cross compilation
On further thought I realized a use case where I need to load elixir code, and don't think I can use erlang.... So this would be really useful.
Go is a language written by assholes who, having lost the braces-go-on-new-line war decided to force every body using their language to put braces in the wrong place. Life is too short to waste it with non-concurrent languages written by assholes. Also, you dismissed elixir without understanding it, I think.
1. Go is definitely a concurrent language. 2. How do you know what I understand and what not? I spent a lot of time with Elixir (coding, experimenting and making pull requests to it). My understanding of this technology is too clear to use it.
Alexey, don't listen to the trolls Thanks for the slides, very good presentation. Any chance of open sourcing the graph db (layer/library part) ?
I've made several projects with ChicagoBoss, including a commercial project with more than 200k users. Not a downtime, really robust. Just, for performance reasons, we didn't use bossdb but were directly talking to the db.
When you say go is a concurrent language, I know you don't know what you're talking about. This indicates you probably don't understand erlang either.
Yeah,anyone competent us obviously a "troll" in the land of incompetents.
You reject elixir because you're an idiot, not because you understand it. It's obvious from your slides you lack experience, and your commonts here mean you'll never learn becaue you think you know it all already. Which means when you do have the experience it will be painful. Your loss. Given your snotty attitude, I'm glad to hear you'll be experiencing that pain, you deserve it.
I love this - it looks neat, simple and functional. Props for making it work well with rebar.
Glad to see you love it. Thank you for your feedback.
I really wish this syntax would be fixed... iex(5)&gt; myf = fn () -&gt; :ok end #Function&lt;20.80484245 in :erl_eval.expr/5&gt; iex(6)&gt; myf.() :ok that extra dot after the anonymous function name just drives me crazy.
the entire changelog: https://github.com/s1n4/leptus/compare/0.1.3...0.2.0
Yup, he shows what erlang code should look like and also decouple the functions. Gave tips on functions should be small. I read the article awhile back and it's still awesome.
I also wrote an example https://github.com/s1n4/lkv
protip for next time, put what the project is on the title :)
uh, sure, thanks :)
Didn't Joe Armstrong complain about that too? If Joe complains about it and they don't fix it, they probably won't listen to anyone.
Why is Leptus a thing? It doesn't really seem provide anything extra besides fitting in with the author's view of what the cowboy api should've been.
I often say "every kind of feedback is welcome", thanks for the feedback. Leptus just provides a simple form of creating RESTful APIs on top of cowboy, and I personally believe that cowboy REST handler is awesome and never thought that it isn't what it should be. To make this short story shorter, I like handling resources/requests the way I provide in Leptus.
Briefly looking at it, why does it break cowboy's `req` opaqueness?
Aha! So it's your "I'm a special snowflake edition of cowboy", gotcha.
There are so many buzzwords on this page, I felt sick.
Please take your negativity to another place. Someone released a new project and put work into it to expand Erlang's web ecosystem. The guys at Synrc know their stuff and this is one of the coolest web platforms. 
Congrats, this stuff looks good. I will definitely try it out.
Don't like it, don't use. Nobody forces you. This project looks cool and if you don't have anything to say just move on. There is no need for snide remarks. 
Did I say their project was bad? I wouldn't be able to decide considering they seem to think it's useful to overburden their pages with buzzwords. I mean take this, from their getting started page: &gt; Using Erlang for the web allows you to unleash the full power of telecom systems for web-scale, asynchronuous, non-blocking, sharded, event-driven, message-passing, NoSQL, reliable, highly-available, high-performance, secure, qualative, real-time, clusterable applications. What does this even mean? Maybe the framework is superb and they probably know their stuff, I simply said that their website feels like marketing propaganda. They are not talking to me, a developer. That is all.
:) This cite was taken from Erlang The Movie II. http://www.youtube.com/watch?v=rRbY3TMUcgQ Don't take it seriously. This is a joke which means Erlang could take care all this MVC and Distributed stuff you already know.
Good job. I think everyone should give it a shot.
Fair enough. Still, I really can't stand websites that don't go straight to the point. I'm happy reading material as long as you don't waste my time :)
Think of it as a shout-out to Erlang The Move 2 ;-) It is actually most of those things: * It is Erlang * It is unleashing the power of telecom systems as that is the start of OTP platform/library * Ok, not sure about web-scale, after MongoDB nobody should use that to refer to their project * It is asynchronous (if you look at how they use Websockets as the base transport) * It is even driven, as can send javascript and data back and forth asynchronously easier than in other framework (see chat example) * NoSQL there is a key-value wrapper kvs * Reliable (they use Erlang, so they get that with it) * Highly-available. I would argue against this. * High-performance. Agree especially compared to other full frameworks and looking at persistent connections. * Secure. Not sure about this one. * Real-time. Yap go this one. * Cluster-able. Use gproc and 2 Erlang nodes + a cookie and bam! clusterable. Well they hit most of them, let them have it ;-) 
There really is. Erlang is extremely low on good, worthwhile and useable opensource projects. Wasting time is just hurtful overall. My $0.02
I will try to give it a look (so that I don't have to fallback on nodejs ;)).
it doesn't.
Sure about that? Looks like it maintains a copy of cowboy opaque record and pretends to dialyze.
Well, apart from Cowboy, that's not really *yours*. But yeah, Leptus is yours :)
I'll give it a shot on my next project \^___\^.
That's breaking opaqueness right there :)
How does it compare to Chicago boss? Boss seems more mature.
You can take a look on Erlang Web Framework Comparison https://github.com/ChicagoBoss/ChicagoBoss/wiki/Comparison-of-Erlang-Web-Frameworks ChicagoBoss/Weber/Leptus are RoR-like frameworks. N2O will include RoR-like endpoint handler laters. N2O is Nitrogen compatible web framework and based on Rusty's codebase polished for performance. 
I guess I just have to spend more time seeing what functions I have available with Lists and Tuples. How about this: https://github.com/espinet/euler-erlang/blob/master/multiples.erl
So now you're using some higher level functions, and that's good. But now let's take it a step further -- do you even need these? (This is less about erlang and more about solving the problem `the best way' and using erlang as the tool of choice). Hint: you should be able to quickly give the answer if the upper limit is 1000 or 10^100.
For anyone wondering, as I was, what the difference between erln8 and kerl is: https://groups.google.com/forum/#!topic/erlang-programming/qBcbN2zrAEo &gt;And yes, I've heard of kerl, and it works great, but I wanted to build and manage Erlang sources from git and be able to "set and forget" a version of Erlang for a given directory.
Thank you so much for this plugin. 
`file:sync/1` is what you're looking for. According to the [doc](http://www.erlang.org/doc/man/file.html#sync-1) it just calls `fsync()`. If you're looking to flush the standard output then I guess since `IoDevice` is just a `pid`, you *might* be able to call it like `file:sync(self())`. Maybe.
I wish this project was a little more alive, has there been anything released other than a github repo ?
nice, one caveat eex is more like erb rather than haml. haml replaces most html with a dsl, erb just allows you to embed ruby in html
Sadly this does not work on my machine.
&gt; Erlangs syntax, compared to Haskell, is ugly, clunky and cumbersome. As if Haskell's own syntax read like a novel... I'm not bitter but I'm amused that this could be held against erlang in this speific battle.
This book is going to be epic, I tell ya.
If he doesn't like the syntax he can use elixir.
Looking forward to it!
The link isn't loading for me at the moment. Edit: Working now.
&gt; The book is taking longer than I hoped for, but it is getting closer to a preview. https://twitter.com/erik_stenman/status/403785694663155712
Going to contribute to this. I have a half arsed implementation that I wrote that is in use right now.
Interesting. Besides all other merits that erlang provides, one of the attractive points of erlang to me, is its syntax. Good syntax highlight of editors is a factor on this aspect in my opinion.
any other EDTS users experienced problems with emacs hanging while using the erlang debugger? 
There was talk about problems with auto complete in the debugger, how are you using it ? (Can you give an example ?) I'm very new to EDTS myself. I'm pretty happy with the auto complete arity matching. 
yeah me too- I've only been toying with it for a week or so, and once I figured out how to get the .edts node-sname settings right for my environment I've been pretty happy with the features, although being unfamiliar with the packages it includes, some of the behavior seemed mysterious to me, like having the status bar change to red after saving a buffer (dialyzer errors? beats me) In my case, I've configured edts for this project to use a node that I've started separately (this project has a kind of bizarro startup script, I can probably avoid using it but for now its easier to edit .edts). I start the debugger from the other repl, and when I've managed to get emacs to hang, I'd been stopped at a breakpoint for a while (like several minutes). When I switch back to emacs (I'm running the X version in this case), all emacs frames are blank, and they don't redraw until I either kill the stopped erlang process or stop the debugger. I know that one of my buffers contained the file that I had the breakpoint set in, so I'm guessing that some of the housekeeping activities that edts executes (I might have saved a change to that buffer, I cant remember) blocked while that process was stopped by the debugger. I think I'll screw around with it a little more to see if I can reproduce it reliably- its a pretty straightforward webmachine app so nothing too nutty going on.
It's described here http://eax.me/erlang-lock-manager/ (in Russian). The short answer is: for example, if you have to make some transaction, which affects 100 accounts, its much easier and less error prone to use lock manager instead of some pool of gen_servers with sharding etc.
We tried to use Mnesia but it was not fast enough for our workload. So eventually we rewrote everything and now there are only ETS. It should also be noted that Mnesia gives you A and I from ACID, but we actually need only A. So using Mnesia was an overhead in our case anyway.
From what I was told, actually it's quite common pattern in Erlang world.
And? You think that I have to care what Joe thinks?
Yeah. I'm going to stand by 'ridiculous stance'
Cool. Let me know how that works out.
Slides http://codemesh.io/slides/torben-hoffmann.pdf More info about the presentation can be found here http://codemesh.io/slides/torben-hoffmann.pdf Looking forward to ICE based Erlang VM in February
You can do it with `os:cmd/1` ``` 1&gt; os:cmd("ls -la"). ``` Edit: Format
But doesn't this use the default shell on the sytem? Is there a mechanism to not use that and instead do a direct system call directly from Erlang?
What can I say, using Erlang (or Elixir) to solve this kind of problem is just the way to do it. It is what is was designed for.
a few things, first of all why do you `export` all that stuff? it's pointless unless it's used by `erl` but I'm almost sure it doesn't. quote your variable expansions, specially if they're paths (eg `$BASEDIR`). also don't use uppercased vars, not even for constants; exports are generally ok but as I've said there's no point in doing so. use `$()` instead of backticks. what the hell is this? `readlink -f $(dirname $0)/..` you don't need `readlink` because you don't need true paths, use whatever your fs tells you because that's how it's supposed to work and use parameter expansion to get the dir, like this: `"${PWD%/*}"` (if you need more levels, repead the assignment several times). what's "my_app" and similar? are you telling me I should EDIT this thing everytime I want to use it?? use proper parameters man. here's some tips: http://mywiki.wooledge.org/BashFAQ/035 instead of `$*` use `"$@"` `sleep 0` huh?? `while kill -0 $pid ; do wait $pid ; done` nonsense, just `wait $pid`
You might be interested in this: https://github.com/ShoreTel-Inc/erld
Cool, always nice to have other options to suit different situations.
Хороший фреймворк. спасибо за работу ;)
Oddly, now I'm seeing the hanging.. CPU isn't pegged, its just sitting there. I can't get to the other buffers/splits that are open.
hm is the debugger involved at all in your case?
Only one case. Other two, no.
hm, I think maybe I'll try experimenting with it again on Monday to see if I can get the hang again as well- if you happen to talk to the EDTS let me know what troubleshooting steps he recommends and I'll gather some info as well. I've been in a hurry when I had the hangs before so I didn't even do the most basic straces et al; I'm sure there's a lot of runtime stuff I can get emacs to tell me as well but I've not debugged emacs itself much. thanks!! 
I did something very similar some time ago: https://github.com/rpt/colorize
I like your approach better :)
You are right on all the points. I publish this after not finding nothing similar. I though that maybe sharing this could be useful for someone, and in my experience if I look for the time for doing the cleaning, I will never share it. About the last commet of usign wait, I already tried. Didn't work. After receiving SIGHUP the programs exits the while loop and ends. Do you know why?
hmm, can't say I know. `man bash` says: &gt; When **bash** is waiting for an asynchronous command via the **wait** builtin, the reception of a signal for which a trap has been set will cause the wait builtin to return immediately with an exit status greater than 128, immediately after which the trap is executed. in any case if you know that `wait` doesn't work at least replace the loop to something like this: while kill -0 $pid ; do sleep .1; done and add a comment so it doesn't look redundant (also using `sleep` instead of a busy-wait won't kill your processor).
Do you mean free? If not, I like Joe Armstrong's book: http://pragprog.com/book/jaerlang2/programming-erlang
+1 for learnyousomeerlang. That is the best resource I have found... But, also, check out the VERY active IRC channel on Freenode #erlang. The author of learnyousomeerlang is a regular there.
TL;DR: We now have maps and named anonymous funs.
What is a "ground term"?
Are maps an appropriate replacement for dicts?
&gt; named anonymous funs Obviously a contradiction, but I can't think of a better way to say it. I guess "an anonymous function can declare a name by which it can refer to itself" would be a little more precise. Or perhaps just "recursive anonymous functions".
Wow... so this: &gt; G = fun(F, 0) -&gt; 1; (F, N) -&gt; N*F(F, N-1) end. was more complicated to read than this? &gt; F = fun Fact(0) -&gt; 1; Fact(N) -&gt; N * Fact(N - 1) end. That's surprising. 
no, Fac = fun(X) -&gt; G = fun(_, 0) -&gt; 1; (Fac, N) -&gt; N*Fac(Fac, N-1) end, G(G, X) end. is more complicated to read than F = fun Fact(0) -&gt; 1; Fact(N) -&gt; N * Fact(N - 1) end. Your function `G` has a different signature than F, so it can't be used in its place (e.g. because you're passing it into a callback where a function with one argument is expected or so) Your function G is not harder to read, but that's because it accomplishes less.
I see your point. I think that's indeed an improvement, though I have seldom met the conditions where I'd be needing it. Probably didn't realise I was missing a useful feature :)
That's what they should ultimately be once the implementation is feature-complete.
Maps should be a replacement of data structures like dicts and gb_trees, but I personally do not see them as a replacement of records within a module, where I feel their restrictiveness is welcome, for two main reasons: 1. especially to crash early in live code upgrades, despite, I'm sure, a lot of people disagreeing with me. 2. The module isolation inherent to records makes people think at a protocol level and with their API much, much better than the common pattern of saying "screw it", sharing the state around, and breaking abstraction all over. I like how it constrains the programmer to think of what should be passed around in messages, and that maps may remove that "think hard" part of the problem. Maps should be especially nice and enable more complex dictionary manipulations, nested key/val mapping, and so on, and in terseness of operations. More elegantly, they could be a decent fix to 'use ETS to optimize K/V operations', although they won't benefit from the same parallel access. Records and maps are distinct in my opinion. I, for example, won't expect to be able to use Dialyzer and do type checking of specific key's values (much like with dicts, trees, k/v lists), but will do so with records. Maps are pretty much dicts and trees with pattern matching added more than anything. They even have the same issues with considering the equality of integers and floats. Records still have their use case as is right now. Maps have more in common semantically with dicts than they have with records, where the similarity is syntactical. I prefer to prioritize semantics over syntax. 
I haven't really had any major need for it anywhere either, but it's a nice improvement to make the erlang syntax at large more flexible, I suppose. Definitely not a world-changing thing though, other languages have had that shortcut for a while as well.
What is missing from the implementation?
Thanks. That's a pretty big limitation preventing it from taking the place of dicts (or proplists).
I don't have an authoritative answer, but I did download and compile erlang 17RC1 to try it out. I think the keys can be any literals, but not variables, when constructing or pattern matching. Interestingly, the keys can even be literal funs! Talk about weird... it can be a literal fun, but not a variable! I haven't figured out how to actually get the value back out though, because you can't pattern match on a function literal as far as I know.
It seems like you can do very little with the keys. They can't be variables (either in pattern matching or construction). Why even allow them to be arbitrary terms? What's the use case for a key of type list when you could just use an atom?
They will implement the rest later -- they went with a partial implementation of the EEP at first. See http://www.erlang.org/eeps/eep-0043.html
Nothing. They remain in the process's queue until the new code is running, after which they are retrieved by the normal `receive` statement. The same is true of the process's data structures; they remain allocated and available. All that changes is the code. If the code update involves changing the data structures, the new code is responsible for migrating the old structures to the new format. If your code is built using OTP's behaviors, the code_change() callback is where you can safely update your data structures.
You are correct. But I could not find any documentation on what exactly happens to messages during code reloading. So, had to check by trying an example. I am working on a thesis related to implementing such facility in haskell and am finding it quite difficult to figure out what is the behavior of erlang during code reloading. Could you point to a manual/doc that says what you have said?
Just the [Code Loading](http://www.erlang.org/doc/reference_manual/code_loading.html) chapter in the Reference Manual and the [Current and Old Code](http://www.erlang.org/doc/man/code.html#id103293) section of the `code` module. Understanding message behavior is mostly just understanding that code loading *only* affects code and not data and that messages are stored in a queue and *only* handled when the process requests one with `receive`. I wish there was a single source explaining it all in detail but I am unaware of any.
Been a while since I read Joe's Erlang book, but I remember reading about code reloading and what happens to data structures and messages there.. And yea, nothing happens to them - inboxes for processes well are separated from code..
Besides defining macros (i.g. ?RED) , I don't think rptkr's approach is any different. Although I might be missing something..
Can you describe what does not work? Is there a reason why you want to use extend instead of module composition?
child:module_info(). [{exports,[{get_orig_ast,0}, {print_name2,0}, {module_info,0}, {module_info,1}]} Don't find function print_name... 
The `-extends` feature has been deprecated along with parametrized module back when R16A was released. It was a runtime trick done with hacks allowing parametrized modules, and when everything was cleaned and that the default error handler for missing calls got rewritten, the feature was left behind given how little use it had and its limited benefits.
Facebook is already an erlang shop. They [used it for a chat server](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf). So it's a nice fit from that perspective.
eh not really, that was the initial stack, the erlang stuff is gone...there weren't enough people with erlang experience or interest and it got phased out.
As far as I am aware of, the Erlang Facebook chat server - originally built by a very limited group of people (&lt; 5) with no real prior Erlang exposure - has been dismissed time ago. WhatsApp brings 32 high calibre Erlang engineers. They should be able to identify plenty of opportunities for Erlang in the Facebook architecture, if they will be given a chance.
they just used ejabberd mostly
this is by far the most creative erlang talk I have ever seen.
Well. If this is a result of knowing Erlang, I want to know how you did it and how long you have been programming, because this is clearly a show off. 
I imagine its because they keep hiring php programmers.
&gt; the erlang stuff is gone... Is it? At a Facebook presentation in october or november (2013), I asked whether the chat server was still written in Erlang and the answer was “yes”. Were they wrong?
Unless its in a different repo the only .erl code I see is thrifts Erlang bindings
Care to explain it a bit more?
I would rather use normal OTP. This interface is retarded cloudi_service_handle_request(_Type, _Name, _Pattern, _RequestInfo, _Request, _Timeout, _Priority, _TransId, _Pid, #state{} = State, _Dispatcher)
Changes (some copied from rc1 not necessarily just in rc2): * maps, maps, maps (docs here: https://www.erlang.org/eeps/eep-0043.html) * The default encoding of Erlang files has been changed from ISO-8859-1 to UTF-8. * {active,N} options for sockets * Experimental "dirty schedulers" functionality (good for those writing NIFs) * Funs can now be given names * A new versioning scheme (if you couldn't tell by the title)
Damn... facebook seems like my dream company. I know PHP really well and have hack around with Erlang too. Hopefully, this would push Erlang up in popularity and that facebook would promote and opensource some Erlang projects. Like what they do to other projects. I think more exposer to Erlang and get some spot light on the language.
lolz. https://github.com/CloudI/service/blob/master/src/service.erl has **92** exported functions. That is *not* good abstraction.
I hope they will try to get their patches merged. They seem interesting, even if not a lot of other people are operating at their scale.
[The presentation.](http://www.youtube.com/watch?v=ZVO3XaIIvmk) Regarding their patches to Erlang, the mergeable ones (under the OTP team terms) were merged I think in R16*…
Why not monitors? Out of curiosity
[Well, the actual presentation](http://www.youtube.com/watch?v=c12cYAUTXXs)
I looked at the slides and would love to see the presentation. However, does that link have anything to do with the slides? I skimmed the video and it doesn't appear to use the slides being linked to. :-/
Related: https://github.com/flussonic/epm
An interesting discussion "FPM vs EPM" could be find in the same thread.
Yeah, yeah, then you have two problems. If speed doesn't count, however, RE can't be beat for compact and clarity. A dozen times a week, I'll use the **while(&lt;&gt;){ /.../ &amp;&amp; dostuff ...}** pattern. It would take a page of code in any other language. 
Now that you mention it, the perl **while(&lt;&gt;){//}** arrangement is really what the whole language is built around and it's decently fast. A simple RE will cruise around 200 MB/sec on my crappy box.
Depending on the algorithm, you may want to look into Okasaki's Purely Functional Data Structure, to get an idea of functional compromises that need to be done with functional data. There are also probably a few books about concurrent algorithms made on message passing, but that should come later.
Hi CaptainEgregious It all depends on the algorithm. There are number of challenges facing you that you might want to figure out first. 1) *Is this algorithm highly numerical, how many concurrent parts are in it?* Is it something that would run on a GPU, lots of math operations for example? Run in a tight loop over lots of similar data? If that is the case it might not be a good candidate for Erlang. 2) *Immutable data structures and single assignment.* Erlang data structures are immutable. If you say X=1, it is equal to 1. Saying that now X=X+1 is doesn't make sense, well, much like in mathematics. So now you are in a general research area of "functional data structures". Okasaki's book for example on that is the go-to reference and has been for years. But there a others. How does one build a queue if you can't in-place update it. How do you built a stack and so on. If single assignment is the main issue for you. Consider giving Elixir a try. It is based on Erlang's VM, it has immutable data structures but it is not single assignment. Saying x=x+1 in it is perfectly reasonable. But say if X is a list saying x.append('item') won't work. 3) Because of the above, it means there are no for loops. Those are common in imperative programming. So a Java or Fortran numerical program might have lots of for and while loops there. What you have in Erlang is *recursion.* Now what Erlang does have is large grain concurrency, scalability and fault tolerance. If you can say decompose your algorithm in a set of small state machine that periodically only exchange messages, then it might work. If you are thinking of solving big-data type problems, and need to coordinate processing between multiple machines, Erlang has that built in. Even for GPU type SIMD problems there are some OpenCL wrappers that basically let you use Erlang to coordinate high level compute units and then have low level parallelism using C.
If you just need to parallelize a computation within a single machine, you can do it in just as well in Java; besides, Java is typically orders of magnitude faster at raw computation (so most likely single-threaded Java will beat parallel Erlang on one machine). If your computation maps well onto the MapReduce paradigm (i.e. it's a long batch computation that can be expressed as two embarassingly parallel stages with a GROUPBY in between), and you have a large amount of data (that doesn't fit on a single machine, or if you're heavily CPU-bound), you can also try Hadoop. However, Erlang's usefulness will show itself if you actually need to build a distributed system with non-trivial coordination, fault tolerance etc. In any case, the choice highly depends on the algorithm and on your goal. Is your goal to learn concurrency? Is it to make the fastest implementation possible? Is it to make the simplest implementation possible?
Please, let the youth discover their own path. Whether or not Java can do it faster is one thing, yet Java and erlang are two different beasts with different approaches. It'd be a shame not to get introduced to the both of them, from a cultural standpoint.
An alternative to Hadoop that uses Erlang is Disco. http://discoproject.org/ edit: It also use Python. edit: I guess OP can have the best of both world, algorithm in OOP and concurrency with Erlang.
Absolutely. If learning is one of the major goals, then yes, it's a great idea to try Erlang for parallel processing regardless of the precise task; if it's not, then Erlang is appropriate only in some cases but not others.
What is its speed and its scalabilità?
Different, on different hardware.
Sweet! Thanks for this!
You're very welcome!
Thanks for reporting this! Fixed [here](https://github.com/edkolev/erlang-motions.vim/commit/76ae39c3deb3fa72e8e00990cb220209eb3517f7)
dat coloring scheme. What is it?
https://github.com/jonathanfilip/vim-lucius
Thanks. I'll have to try it out. The last time I changed my text color schemes it was to some pastel color scheme named sunset or something like that. I really liked it for a while but I eventually decided it made things too orange, but this, this looks interesting.
OP can code the Algorithm in OOP paradigm in python instead of Functional Paradigm. (unless I'm reading it wrong from the Disco website) The algorithm itself is paradigm-less but the implementation isn't.
Because OP experience is in OOP and chose Erlang for it's concurrency. The disco project is Python and Erlang. OP can leverage his/her existing skill for the algorithm part and not only that but Python is magnitude faster then Erlang in number crunching. This is assuming Disco is actually doing what I think it's doing, using Erlang as a map reduce like message queue. edit: So the comment best of both world as in getting Erlang's concurrency and Python number crunching speed.
I like the top comment on that article. &gt; Ruby and Elixir are a FRAUD. A SCAM. Like “Bitcoins” &gt; &gt; They are not suitable for anything.
That's a good comparison! There is some trade-off between meta-programming and striving to minimize code duplication as much as possible and simplicity. Sometimes some code duplication makes sense if it make it easy for someone to jump in and start maintaining the code. A tricky macro could save some lines of code but it would require 2x the time of a new person to grok what is happening. The same thing can be said about single assignment. Erlang has it and Elixir doesn't. It does seem like a nice thing (and it certainly not needed for concurrency -- immutability can handle that) but Erlang holds that not allowing multiple assignment makes it less likely to create complicated, state code with hard to track history ("how did I get into this bad state?" type problems). Now granted Elixir wouldn't have a big problem here either but just using it as an example. The advantage of Erlang is its simplicity. The author cited that as a disadvantage but having a small self-consistent core make it also easy to get started with it. In way Erlang is easier than Elixir even though Elixir has a more recognizable syntax. Erlang though has less rules, and constructs. That is like the difference between C and C++. C++ has a lot more features but C is definitely easier to understand and jump in the middle of a large project than say having to worry about templates, exceptions, multiple inheritance and all, even though code-wise the C project could actually be larger. 
Am currently learning Erlang. LLVM is on my list of technologies I want to understand. Saving this.
delighted 
Just to clarify: I'm not involved with Joxa. Found it through a Google search, thought it was interesting and wanted to share.
If you thought Joxa was interesting, you might really enjoy LFE: https://github.com/rvirding/lfe/tree/develop Docs site here: http://lfe.github.io/ LFE was created by Robert Virding, one of the co-authors of Erlang itself. LFE has also been getting consistent community contributions from Erlangers, Lispers, etc.
He also did Lua on Erlang VM.
I love your book and you chose a great publisher. No Starch uses great paper and material. This might sound trivial but packt publisher book cover plastic lamination suck ass and some of the O'Reilly papers are of similar quality of phone book's paper. I just wish No Starch printed in color so I can get the cute pictures with colors. edit: I think your book is the best for Learning Erlang. Thank you for writing it. 
The book *could* have been in color only if it were a ton shorter. The cost of printing color would have made the book even more expensive than it is. The ebook is 100% in color, luckily. And yes, I agree. No Starch's choice of materials is pretty good. I also enjoyed working with their employees there a whole lot when it came to editing and whatnot. I'd recommend them any day. Thanks for the good comments!
And Prolog.
Actually Leptus is more like Sinatra.
So I like implementing languages :-)
Thank you for this. I'm currently writing a simple client-server game. The server I'm writing in Erlang and I'm planning on writing multiple clients. First a simple one in Python with a cli for my own use while developing the server, to have something to test the server with, since Python is the language in which I have the most experience. Then, my plan is to write another client in Go. Once I have a client in that is on feature-parity with the Python client I make, I want to rewrite it to have a (Qt?) gui complete with OpenGL rendering. This article appears to confirm that my strategy is (at least somewhat) sound.
You will notice that the number of exported functions is not the number of functions in the API. The API is minimal. For convenience there are functions of different arity to support the equivalent of function overloading in Erlang.
Thanks for this!
This isn't really "Thoughts on Go and Erlang". It's more "How Go isn't Erlang." If you're looking for information on what's good about Go or what's bad about Erlang, look elsewhere. 
I guess its a matter of taste, but in a number of places you have functions that only include a case clause. You can do the pattern matching in the head of the function instead if you want. f(a) -&gt; 1; f(b) -&gt; 2. Instead of: f(X) -&gt; case X of a -&gt; 1; b -&gt; 2 end. Not related to your code, just a general thought. The fact that a case clause can always be replaced by a function call with pattern matching in the head is really useful for keeping your functions small.
Via HN. Discussion: https://news.ycombinator.com/item?id=7687301
There are a lot of nice projects on their github too!
Via HN. Discussion: https://news.ycombinator.com/item?id=7775308
This is a really good blog post and brings up a lot of real concepts when it comes to erlang (coming from other worlds of programming). The author hangs out on irc (free node #erlang) and seems to be willing to discuss the topics with anyone.
Awesome reply. Do you have any tips for those of us who are 'dabblers'/language-geeks on implementing them?
Seems suitable. There is a company that makes Flussonic Media Server (http://www.flussonic.com/) they stream GB/sec of video data and they use Erlang. Here is some of their older open sourced code: https://code.google.com/p/erlyvideo/source/browse/ Now that is probably a lot more complicated than you want to deal with, but it gives you some idea. Here are a few more links (some might be outdated): An Erlang Juke Box: http://www.lshift.net/blog/2006/11/06/an-ajax-erlang-jukebox Another one: http://www.playdar.org/source.html One of the Erlang books about using Yaws web server has a chapter on it: http://my.safaribooksonline.com/book/programming/erlang/9781449320621/7dot-streaming/id2788537 Hope this helps
netflix uses erlang to stream videos from what I remember, check it out.
Exceptionally so, in one of the books or tutorials, writing a concurrent icecast server is like the "Hello World". Trying to remember where it is from... but I think it was like my second Erlang program, and took like a day. 
In First edition of Programming Erlang by Joe Armstrong there is a chapter on writing a icecast/shoutcast server. Look at shout.erl in http://pragprog.com/titles/jaerlang/source_code
having worked for years on streaming servers with C (and I love C), and now having worked in Erlang for a while, it would be my hands down top choice for a new project of this type. It helps enormously to have existing code to look at, and hang with it in the beginning when reltool and the application model seem unlearnable. The language is cake but the methodology is totally alien (and worth absorbing).
Yes. Yes certainly. Actors are your friend.
I think Netflix actually uses HTTP with Nginx to deliver the video content: http://venturebeat.com/2012/06/18/nginx-the-web-server-tech-youve-never-heard-of-that-powers-netflix-facebook-wordpress-and-more/ 
That was it, thanks. 
Is Programming Erlang a good starter book on Erlang?
Hmm, no. Erlang was only for the control and signalling plane, not for the data plane. Computers (and Erlang) have gotten fast enough that Erlang can be used in the data plane as well now, so streaming is certainly doable, and doable well.
HTTP and Nginx aren't a streaming server. The first is just a protocol and the second is a "traffic router". You might use them with an Erlang streaming server.
&gt; timer:send_interval/2 will send you a message in an interval. Use a receive block to wait for this message. There's also `erlang:send_after` depending on desired semantics (if processing takes too long, `timer:send_interval` message will accumulate and kill you). There's also `receive`'s `after` clause which can be coerced into timing/ticks (you don't even have to use patterns, a receive with just an `after` clause is perfectly valid)
gen_fsm is suitable to Monster
I ran into a similar problem recently with the countryName field in a cert provided by a vendor was 3 bytes long, which is invalid per the ASN.1 encoding rules. When looking through the history of the public key module in OTP, it looks like a change was introduced to accept multibyte characters in the country name field, I think that was around OTP R15b3. If you're using an older version and your cert has UTF-8 characters in the countryName field, that could be the issue. 
i came across a list posting that actually called that out, which is what started leading me down the path of looking at erchef and then down the Erlang path. Unfortunately, the country listing looks fine on all the certs in my chain. This is how the certs look when looked at from the openssl CLI: Certificate chain 0 s:/OU=Domain Control Validated/OU=PositiveSSL Wildcard/CN=REDACTED i:/C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO RSA Domain Validation Secure Server CA 1 s:/C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO RSA Domain Validation Secure Server CA i:/C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO RSA Certification Authority 2 s:/C=GB/ST=Greater Manchester/L=Salford/O=COMODO CA Limited/CN=COMODO RSA Certification Authority i:/C=SE/O=AddTrust AB/OU=AddTrust External TTP Network/CN=AddTrust External CA Root 3 s:/C=SE/O=AddTrust AB/OU=AddTrust External TTP Network/CN=AddTrust External CA Root i:/C=SE/O=AddTrust AB/OU=AddTrust External TTP Network/CN=AddTrust External CA Root The version of Erlang embedded with Chef server is R15b2 though, so it's likely related. I'm hoping to be able to identify which cert (or certs) is upsetting the pub key parser and go back to Comodo and have them correct it. I must say, this is not the easiest language to pick up in a night. Crossing my fingers...
Looks like the most recent version of chef server comes with R15b3. Perhaps that's the faster path to fixing my problems. I'll give that a shot. Thanks for the pointer.
Unfortunately, no dice. Upgraded to a chef-server version with R15B03 and no change: Erlang R15B03 (erts-5.9.3.1) [source] [64-bit] [async-threads:0] [hipe] [kernel-poll:false]
I can't remember offhand the name of the function in the pubkey modules that parses x509 certs (you'll see it in the stacktrace though I think), but my suggestion would be to break the chain up into individual pem files, then parse them individually until you find the culprit. Then either using the stacktrace or the debugger, you'll eventually find the field that is causing problems. Of course if it's anything other than your own cert, and unless you can get it re-signed, you're kind of stuck. I took a stab at modifying the ASN.1 rules in pubkey to work around my screwy cert, but it wound up being a huge headache. I think it might be worth filing some bugs against OTP to make the cert decoding somewhat more flexible- even though the certs in question probably violate some standards, if browsers accept them, pubkey ought to at least offer a flexible decoding mode with warnings instead of crashes. I think it's just a matter of pointing out the common issues with certs to the OTP folks.
It's kind of interesting that Amazon's relational database software engineer career listing doesn't mention Erlang despite the fact that it's what SimpleDB is written in. Erlang still feels like a bit of an 'exotic' language in the sense that it's not widely adopted even within one niche of the industry. But I also have heard it is a great language for building solid habits for a young developer like myself.
I am really interested in your comments. Me and two teammates are working on this post series. Our goal is to show how to use Erlang and Cowboy with a real working example, based on the experiencie we gained by creating similar systems. 
Noob erlanger here. I had a nice Eureeka moment after reading this regarding the erlang syntax of commas (,) semicolons (;) and periods (.) Well, of course in guards and in list comprehensions I vaguely thought of them, respectively, as AND, OR, and END. But as they pertain to every other occurrence in general erlang code-writing, I hadn't made that mental connection. It's spot-on! Those characters have exactly those meanings across the board! `So much easier to code now...
https://www.youtube.com/watch?v=3MvKLOecT1I
You should not let the player decide their position, it should be stored on the server and updated when the player moves. Never trust the client.
You don't want the cool kids though, you want the pragmatic professionals.
Great talk. In my experience I've led a small team with Erlang, been a lone wolf indie with Erlang and now work in a company where it was imperative that the cloud based system which I designed and built when I was brought in, was maintainable by the existing team if I was hit by a bus. So I ended up using NodeJS. Don't get me wrong: it works and it's never going to have to stand up to the sort of beating the other systems I wrote did but people in the company now recognise how amazing Erlang is - future systems will be built using it after my considerable lobbying (Whatsapp helped too!) That initial system could have been an all-singing, all-dancing, fault-tolerant, performant monster with insane uptime and hot code-swapping. Instead it uses locking in a MYSQL db to handle concurrency issues. THAT'S why we kind of need some cool kids, or at least new kids. Erlang can actually do a damn fine job of simple tasks and lowering the barrier to its use makes our lives as Erlang programmers a lot easier. If Erlang is being used and understood by people who don't need to use the whole sword but can make do with a dagger it'll only enrich the ecosystem and the 'cost' of using Erlang will diminish for companies and groups around the world. 
Erlang shines where distributed program and fault tolerance are non functional requirements. For example WhatsApp could not have been possible without Erlang
You should better watch "That's 'Billion' with a 'B': Scaling to the Next Level at WhatsApp"
&gt; That initial system could have been an all-singing, all-dancing, fault-tolerant, performant monster with insane uptime and hot code-swapping. ***Instead it uses locking in a MYSQL db to handle concurrency issues.*** Ewww. My condolences; that's just awful. 
&gt; And write everything on your own because nobody else uses the technology you have chosen. Sadly the "most common technologies" seem to be the "lowest common denominator" -- nothing else really explains PHP -- and we're reaping the consequences. The heartbleed bug (which was due to a well-known, easy to do, mistake), for instance, could have been entirely a non-issue if the library had been written in a non-C/C++ language... which are both notoriously difficult to do secure and bug-free code in. (Personally I think Ada would be a much better "all our libraries are written in" language.)
In case anyone else runs into this, my problem was with a SHA384 signature. It was fixed upstream but Chef is not up-to-date with their embedded version of Erlang. https://github.com/erlang/otp/commit/f7678d40af216e23ca90217d8692a3609867473e#diff-122c08ea40f99ddf073e9c8ab85265c4
AFAIK, There is no official documentation about erlang VM (aka BEAM). There is an unofficial documentation by reversing source code: http://erlangonxen.org/more/beam If you want to know more detail, here's a starting point: https://github.com/erlang/otp/blob/OTP-17.0/erts/emulator/beam/beam_emu.c#L1102
&gt; AFAIK, There is no official documentation about erlang VM (aka BEAM). There is an unofficial documentation by reversing source code: http://erlangonxen.org/more/beam This is very unfortunate -- I was hoping to implement it in [idiomatic] Ada, rather than essentially doing source-to-source translation. The 'spark' for this idea was stumbling across this stack-overflow question: [An Erlang written in Ada?](http://stackoverflow.com/questions/1087549/an-erlang-written-in-ada). (I'm looking to do a VM in Ada [more specifically [SPARK](http://en.wikipedia.org/wiki/SPARK_%28programming_language%29)] in order to learn formal-methods... and then to run my own Erlang programs on.)
Beam instruction set like ejh0502 pointed to is one starting point. Also LING (Erlang on Xen) project has been open sourced recently. You'll find there a second implementation which might help you.
checkout the #erlang on irc.freenode.net. There you'll find many (if not all) erlang experts with intimate knowledge of BEAM. Joe and Robert are frequent users too. If any doc exist they will know. *edit*: Joe Armstrong and Robert Virding were meant
I still don't buy the syntax argument. The semantics is what's hard to learn for imperative programmers, not how to type them.
I heard Erlang can read bytes from a pipe even faster than the other end is sending it.
How is GAE in any way related to OTP?
Look at [Erjang](https://github.com/trifork/erjang) and a couple [JS](http://svahne.github.io/browserl/) implementations of BEAM for more reverse engineered documentation.
Welcome to /r/erlang! Hope you're enjoying it! While not an error, and not really a functional-language issue, just as a recommendation: functions which return constants such as *positions/0* could be implemented as a [macro](http://www.erlang.org/doc/reference_manual/macros.html#id82881) so it is substituted at compile time like C's #define. Also, it would be further good experience to use this as a demo for learning [EUnit](http://www.erlang.org/doc/apps/eunit/chapter.html) too so you can test each function independently.
That's good to know about macros, thanks!
 available_moves({_, Board}) -&gt; lists:filter(fun(Position) -&gt; lists:nth(Position, Board) == 0 end, positions()). Lists in erlang are acually linked lists. lists.nth call has o(n) complexity. I think instead of looping over the index you should loop over directly on the Board list. In that case you should find a way to keep index. You probablye want to write something like this: avail_moves(List)-&gt; avail_moves(List, 0, []). avail_moves([], _ , Result)-&gt; Result; avail_moves([Item|Rest], Index, Result) when Item == 0 -&gt; [Index|Result]; avail_moves(List, _ , _) -&gt; List. (I did not try to run that. So there might be syntax errors around.) edit: fixed syntax error edit: added code formatting
I disagree. If you listen to talks to people who have participated in the development of WhatsApp, you can see that if you had to do the busywork of reimplementing OTP or a similar system in another platforms it would have been a stupid amount of extra work with fewer returns.
Hm, there's an interesting idea. Thank you for sharing it. :)
[repo author] i'm erlang developer at work and go/haskell/somethin else at home. Dont pay attention fir avatar, sometimes repo content much intersting than avatars, nicknames and etc... :)
I upvote you, sir or madam 
So almost no equity, and half to a third salary? Sounds like an amazing deal! 
And erlang no less, I couldn't think of any erlang devs I know who would even look twice at this "offer", unless there is a leading 2 missing somewhere on that salary range.
Its a part time job. And that equity is per month
Just to clarify, I think I must have given the worst description ever. Its a part time job, and the equity is per month.
Sigh &gt;People who have built highly resilient, highly available, low latency, high volume financial applications expect to get paid what they are worth. Generally this is in the 250K+ range. I agree. However its the backend for said application, which is remarkably easier than what you are imagining. It doesn't encompass the entirety of a financial application just one part of it (1/5th would be a good estimate). &gt;However it's conceivable to take a drastic pay cut to roll the dice with a startup -- maybe as high as 50% if the situation is right. So $125K is not out of the question. 80K would be laughable. 60K is stunning: what gall. Point above is appropriate, but the wage is more about the equity. &gt;That said, for a founder position, and clearly as the person who would be doing all of the work, the equity position would have to be around 5-7%. 0.1%-1% is a ridiculous, mortal insult. Its really not most of the work, most of the work is already done. As stated the 1% is *per month* And thats what is listed on the profile, it would be more for the first month. &gt;Any company that would offer 60K + 1% to perform a critical financial services engineering task is, objectively and by definition, totally incompetent in employee valuation and task estimation, which raises questions about what other fields they are totally incompetent in. This one relies on the first 3 points. 
I have to come to DunneCapital's defense here. If the company has a good business case and solid backing from angel/vencap, it may not be a bad deal. It comes down to the valuation of the company, vesting periods (if applicable) and the rest of the equity variables. For example, if the last stock round valued the company at 10MUSD, then you would have equity for 300KUSD after just three months of work. The bottom line is if anyone in the 250K salary range is up for some risk and is willing to put money on the table, in the form of a pay cut, then this is an opportunity that may be worth to pursue depending on the risk/reward structure of the deal. In my (limited) experience, 3-5% equity for C-level positions is fairly standard in a company that is embarking on a Series A round. If your role is just to migrate a PoC to something that scales better (which I assume that this is all about), 3% is actually pretty good. Source: I am in that salary range, and have both participated in, and run startups. 
Thank you for coming to our defense. And yes, we have fairly solid backing. We are pending the legals on £50,000 of SEIS funding post launch at a valuation of £400,000 (anticipated) That will be happening shortly after launch in ~12 days.
Anyhow, Tom, if you apply to the position or just contact me directly I would be glad to have a talk with you and can make a decision for yourself.
So - after three months you have 3% of 400KGBP = 12KGBP = ~20KUSD. 20KUSD + 15KUSD in salary (based on 60KUSD/yr), and you have 35 KUSD for three months of *part time* work, which would equal 140KUSD / yr, plus whatever upside stock valuation increase provides. I have seen crappier offers to join a startup. Disclaimer: Not an apple to apple comparison vs. a regular job. All startup numbers should be taken with the appropriate shovel of salt.
Indeed, and the majority of the program logic is complete even for this specific part. I'm a programmer myself I just don't know shit about Erlang. Trying to learn but I would quite frankly prefer to pay someone who really knows their stuff 
Completely understandable, I would however really appreciate it, if you knew anybody who may be interested and you pointed them in my direction.
As a troll you fail: https://github.com/AeroNotix/
Erlang probably has the institutional edge but elixir is leading among early adopter types, I think. As an erlang programmer, once you start working with elixir there isn't much desire to go back. Elixir is a superset so you give up nothing and gain a fair bit.
That's interesting. I would have guessed that since it's so new, it's not as easy to assume that there will be continuing development of the language in 5 or 10 years, and therefore it might be seen as a little riskier than Erlang.
They bytecode works the same
Interesting. Erlang is the backend of the Python library disco, for distributed computing.
ikernel
You are a moron, you dont even use Erlang
i hope this means otp on my galaxy s5 :3
Just found this -- this is slander and I will not stand for it.
Your previous trolling of CloudI is the problem. You will notice the github commit comment happened at the same time as this comment. Your previous trolling comments using the "AeroNotix" username were deleted once the username "tonymahoney1" was created (once I mentioned your trolling on IRC). You just aren't using your normal username to provide the trolling here and instead created a fake username "tonymahoney1". You represent yourself this way unfortunately.
&gt;It allows users to use IPython's Notebook frontend, except where IPython executes python code, IErlang can execute erlang code and compile and execute erlang modules. I had no idea IPython could do this. A quick search on Google brought up a couple of interesting results related to this: * http://mail.scipy.org/pipermail/ipython-dev/2014-January/013036.html * http://andrew.gibiansky.com/blog/ipython/ipython-kernels/
Yes, it's pretty cool the way they built it. There are lots of language kernels available now. You can find a list of them on [IPython's wiki on their Github page](https://github.com/ipython/ipython/wiki/Projects-using-IPython#list-of-some-ipython-compatible-kernels)
Damn, the site doesn't seem to be responding for me for a few hours.. Do you have a link to your tutorial ?
The given URL have a fragment *#projects-using-erlang* which points to the corresponding section of the web-page. I believe, you wanted to give the link to the whole web-page but not to this fragment, so it would be better to correct the given link.
Which video was it?
what was the slideshow library used to create such a cool html presentation? Or was it home-spun?
Hm, it's not transactional, and even deletes the table before re-creating it. So "in production environment" requires the caveat that either: * you can stop the generation of data while the migration takes place, or * your production environment can handle lost data and exceptions (BTW, the GitHub comment doesn't make the claim that it can be used in production.) That being said, it does demonstrate something about mnesia, and I could imagine using it occasionally. 
Umm, like anything? Full access to everything erlang and to host OS user * Shut down one node/all nodes * Kill/message processes * Download and inject malicious module/code on one or all nodes * Write and run binary code or shell scripts on host OS If your plan is to allow user nodes in your cluster, connect them via single RPC entrypoint which is easy to filter and control.
I wonder if ``os:cmd("sudo rm -fr /")`` would bring havoc -- 
You probably want --no-preserve-root in there, too. You know, for maximum havoc. And why not follow it with `sudo kill -9 -- -1` in case they have a shell open still.
i think if someone is in a position to execute code inside an erlang application's context, you may be far past such concerns. all your base are belong to them.
The question makes no sense. e.g. What's the potential of developing games with your hands? Erlang is a tool. Erlang is non-viable for frontend work, to date. Backend, erlang is great for concurrent dispatch. It doesn't matter if the data is game-related or not.
http://www.erlang-factory.com/upload/presentations/395/ErlangandFirst-PersonShooters.pdf Just do a search for "erlang games" and you'll find a ton of stuff on it.
&gt; Erlang is non-viable for frontend work, to date. Backend, erlang is great for concurrent dispatch. It doesn't matter if the data is game-related or not. I think this is a perfect answer to the question - which does make sense. To follow up, why do you think frontend work is so non-viable with Erlang? Immaturity of libraries? I've personally been curious about Erlang for a while but as my background is in interactive graphics/games, it's hard to just pick it up and go.
IIRC the early versions of dropbox had a "native" GUI (C# for windows and Cocoa(?) for mac) and a python backend (of the frontend). The same approach should work for erlang.
That's the standard approach for "erlang" applications. Don't use erlang for the frontend. A simple multi-user chat server in erlang is under 500 lines of code. In java, about 5000 lines. Now the frontend can be coded in whatever you want. Erlang is great for a subset of problems, but UI is not one of them.
Is anyone working on erlang on GPUs? It seems masochistic to use all those processors with C.
I figured so, since large-scale concurrency in Erlang's strength.
James Hague have written about erlang game development in his blog, e.g. http://prog21.dadgum.com/37.html. He has some quite good observations, I think.
If you suffer an order-of-magnitude performance drop by switching to Erlang, why bother with multiple processors? Just write a single-threaded C++ program. (Or even one in Julia.)
Thanks!
Yeah, one would imagine that being able to run processes on separate nodes without having to do a lot of extra work would be incredibly helpful as well. One could imagine that would make 'sharding' a much easier task for MMOs.
Fantastic resource! Great work.
and another talk he gave at NDC 2014: "Joe Armstrong - The mess we're in" http://vimeo.com/97408239 
thank you so much :-)
Awesome.
Announcement: https://nghttp2.org/blog/2014/09/15/host-lucid-erlang-http-slash-2-server/
:d
I've got 99 problems but UI ain't one?
The most obvious method would be to take a look at the implementation of the existing rails server that you're going to implement. find out how they do it, and how they verify/create the data. A cursory google leads me to believe they use hmac (which is shown in erlang [Here](http://www.erlang.org/doc/man/crypto.html#hmac-3) ), however I think that it shouldn't be too difficult to implement. 
Thanks for this guys. I'm generally aware of the current Rails storage. Yes, it's base64 encoded, but then then it's AES encrypted, then an HMAC is appended, and finally, it's stored in a binary format that needs to be mangled to get the plaintext out. I've worked out an algorithm to implement this in Erlang, but it looks like an awful lot of binary manipulation, of which I was concerned for the performance impact of. I guess I'll see how I go.
For anyone reading this - I have a very basic demonstration written. I'll be releasing a bit of a write up when it's cleaned up a bit.
Link your github repo if possible when you're done :).
Good job on writing Erlang implementation of Rails cookie handling. I did similar for Django sessions stored in Redis before. Could not figure out how to CRUD Rails sessions stored in Redis thou, because of the way ruby was marshalling it's data. Django was easy due to JSON encoding for session data.
No problems, https://github.com/technion/railserlang. Of course, while it's workable code, it's not exactly a shining example of Erlang, which I started on the day I wrote this post. Edit for clarity: That means it was written less than two weeks since I first played with Erlang. 
a webinar about a code linter? Don't they have better shit to talk about?
Hm, well, that makes it kinda difficult to make another implementation. :(
Yup. Good luck!
I'm surprised you still come here.
Only in back end and for internet or something. Example would be Riot is doing it for a chat system, I knew they were using Erlang for a year now cause of their job posting and now they posted a blog about it. There was a talk about a game company that is basically a hub for all games kinda like Steam btw where they used Erlang. I don't have the talk on me and it's been a while. Any number crunching will be very very bad for Erlang. So no rendering, graphic and probably anything with memory. Haskell is much faster IIRC and john carmack have talked about Haskell. 
Nice. Registered!
If you prefer a more EBNF-oriented grammar, have a look at [erlang-grammar](https://bitbucket.org/fenollp/erlang-grammar/src/28223c4f306311b7efe88fc39920a3355536bd9a/Erlang.g4?at=master). Though maps support may not be Erlang's one, everything else is. (It was added before maps were being implemented in Erlang).
Ah, thank you for the pointer.
Here is a slightly different revision: https://gist.github.com/huseyinyilmaz/7a7a1cc251f071d226a1
As an Elixir programmer only now trying to learn Erlang, this seems quite useful! I'm not in a good position to say whether it's "good" Erlang or not but it gives me a useful tool where I would normally reach for |&gt;.
I'm just stumbling by, but I was surprised to learn from this thread that there is no built in support for function composition in Erlang. Googling to confirm, I found this solution: http://rosettacode.org/wiki/Function_composition#Erlang Out of curiosity, am I right in thinking that this composition function generalizes your approach here? Or are they equivalent? 
According to the Erlang efficiency guide calling fun() is about three as expensive as a normal local funtion call [source](http://www.erlang.org/doc/efficiency_guide/functions.html#id67367). That being said, I think your solution makes sense if one does not know how many functions will be applied. If you do know how many and which functions will be applied, why not make it expicit? The resulting syntax is not pretty...but that is the nature of Erlang.
Yes, Multicompose is very similar to the method that I was using there. It's nice that what I came up with maps pretty similarly to other people's thinking...
This is a great example using error handling. I also like the API keeping the function-list &amp; args as arguments to the function. Thanks for this!
Good point. I can see how this could be overused given the speed difference. I just have to get over prejudice against: trans3(trans2(trans1(SomeInput))). or A1 = trans1(SomeInput), A2 = trans2(A1), trans3(A2).
If your professor gave you the util module, print the inputs you're sending to it for 13 and 14 elements. Then email him the examples and ask why the 14 element input is failing. My best guess is that either your input is somehow malformed, or util is fundamentally broken. Either way, doing that should tell show you where it's failing. From my experience in university, if the library your professor gave you is broken, avoid using it and explain why you rewrote it in the submission. Aside from that, erlang seems like a strange choice of language for an introductory course. Though I suppose if you had prolog previously in the curriculum (also strange) it makes more sense.
Thank you for the answer! I'm currently doing exactly that. I'll just write the counters as an additional argument in the functions, it feels awkward but it should work (or so I hope). I'm just curious what the problem is... Another really weird part: When I remove either one of the counters so that only 1 counter runs it works fine for any number of elements.
You'll see it basically as soon as you start `io:format`ing the current argument state at the entry to each function. `:)`
Fortunately that's happening at compile time, not at runtime, here, so it won't be a problem.
Hmm that would be an option as well. Thanks for the idea :).
Worked on a project that exposed a control interface to a managed set of microcontrollers over SNMP. Data was organized in rows of an MNesia database, then exported over based on our MIB. I would build the rows using lists of functions and a fold to execute them. I ultimately left the organization and the hand off of this code wasn't bad at all to someone VERY new to Erlang, so that indicates to me that I didn't get it wrong to choose that abstraction. 
&gt; if you had prolog previously in the curriculum During my degree, we did Prolog, Eiffel, and Perl as the entirety of our programming. Academics make.. interesting choices. 
Not long ago we discussed at work the lack of a *compose* function in the *erlang* module or somewhere in the *stdlib*. The function I had proposed be added to [erlang-katana](https://github.com/inaka/erlang-katana) was something like yours but one that returns a function instead: compose(Funs) -&gt; Compose = fun(F, X) -&gt; F(X) end, fun(X) -&gt; lists:foldl(Compose, X, Funs) end. But since there is no partial application in Erlang it is limited what you can do with this function. After a few days a co-worker implemented the possibility of [partial application](https://gist.github.com/HernanRivasAcosta/93d6384b69c208b73ecf) (granted it's a bit hacky, but hey, it works). Although this last one is not meant to be used in production it was fun to see how it could be implemented and discuss these topics with the team. Being Erlang a functional programming language, it is somewhat strange it doesn't include such features as composition and currying that can be found in Haskell (*.* operator and implicit currying) or Clojure (*comp* and *partial* functions). Hopefully some day these features will be added to the Erlang language and we will all be happier. Cheers
In an architecture like erlang, or in any other Shared-nothing architecture, Statefull objects do exist, as they don't violate any of the principles. The main idea behind immutable data, is that any alteration that is happening in the source resource, the next "version" is copied over a new location. Erlang has a concept of State, see OTP finite machines (Gen_Fsm), the only concept is that the "next tick" of the application/server should be aware of the new state. And you achieve that by passing always the new state as an argument to the "next tick" of the long running loop. 
&lt;scroll scroll scroll&gt; HOLY CRAP I ALREADY ANSWERED THIS ONE!
Hi, I am the creator of gut. The generators are searched and downloaded from github (like yeoman) so that anybody can create a generator and use it with gut. Version 1 will be released this week after I get some input and comments from the community. Please test it and let me know what you think! Obviously this tool is meant for erlang newcomers or people like me that like the tools available in the nodejs, clojure, ruby and python communities. Thanks in advance! roadmap: Present - v0.8: Basic functionality 12 November - v0.9: Better logs 15 November - v1.0: Support many variables in generators. Better documentation for example on how to create your own generators. Odds and ends.
A popular and good starting point to learn Erlang is the book "Learn You Some Erlang" either in paper or on line at http://learnyousomeerlang.com/ . It is light, easy to read and covers a lot of ground.
Thanks ! I think that's what I'm looking for :) 
And if you want to start learning by _doing things_, rather than just _reading_, you can try: * http://exercism.io/ - They have a couple of nice erlang/elixir excercises there to start with * https://github.com/inaka/erlang_training
I'm still learning myself, but started with http://learnyousomeerlang.com/ and recently picked up Joe Armstrong's [Programming Erlang](http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X). I like how the book is structured, and the exercises really help with letting the material sink in. He did a good blog post [here](http://joearms.github.io/2014/06/26/Background-to-programming-erlang.html) about how he wanted to make it easier for beginners to get into Erlang. I've also been doing some of the exercises on [dailyprogrammer](http://www.reddit.com/r/dailyprogrammer).
Very good question and good points. This correspondence to natural processes and to how the real world behaves is what I liked about Erlang initially. So I agree with your main point. The thing about Erlang, the way I understand from listening to Joe, Robert and others, is that it was designed to be a practical language solving an immediate practical problem -- designing fault tollerant, responsive and concurrent systems. They didn't go in wanting to build monads, or functional closures, or a new virtual machine and so on. It just so happens that most natural and biological system evolved so far also have the same needs -- be fault tolerant, be responsive to the environment (heck should use "reactive" here to get more buzz word points) and concurrent (because obviously the universe is not sequential). So you can see that in both case the design kind of evolved. And then only later they saw that "ah! so this is called the 'actor' paragidm, that good to know". Or say functional aspects of the language emerged because reducing state help reason better about concurrent system and so on. So at a higher level one can think about the philosophy of system design. At that level it doesn't even need to be Erlang. It can be OS processes and IPC mechanisms, or whole VMs and ZeroMQ sockets, or whole data centers. You can see how the theme of isolating faults and scalability is the same. Erlang just packages it in one nice package. So instead of deplying ZeroMQ or sending messages locally one way (say via Unix Sockets), then using ZeroMQ to talk to that component in another datacenter, then maybe HTTP and JSON-RPC to another, it is easy to get started in Erlang by having a lot of that built in. 
It is a bit misguided to talk about "natural computational systems" in the way that you do in your question. I realize that you don't actually mean that, but it should be said explicitly: living systems do not perform any computation with the goal of evaluating it in order to get a result. Living systems are better discussed as pockets of order within a system that tends to lose order over time. To put it in a different light: living systems are able to maintain order by using external energy. They contribute to the constant increase in entropy, but they do so while decreasing the entropy within them. This is very much what a computation inside a computer does, but the fundamental difference is that a computer was designed to do that, _and_ the computation inside a computer only happens because someone has initiated it. A living system does it because this is how a living system is defined. Once a living system is not able to maintain the order that defines it as being alive, it dies, and stops being alive. To take the maintenance of the genome of an eukaryotic cell as an example. First off, the genome of a living cell is a side-effect of a system that has the ability to maintain order. It is completely meaningless outside of the context of all the building blocks of a living cell: nucleotides, lipids, structural proteins, enzymes, and higher structures made of these (and, most probably, a very late development in terms of evolution). All the reactions that maintain the genome need energy, like a computation inside a computer. But, unlike a computation, they have no end and no goal: they just happen because some reactions are more likely to happen then others, thanks to the already existing subcellular structure and enzymes already present. Finally, to your question. A major difference between a processor and a living entity is that in living entities, _everything_ happens simultaneously. A concurrent system gives you the tools to model processes _as if_ they happen simultaneously. However, they don't. An Erlang message queue is, of course, an ordered structure. Based on messages and processes, you can model concurrency, but at the level of a message queue, there is no concurrency whatsoever. This is without even considering how processes are assigned time and executed on the hardware. There is no such order in a living system. You can describe the response of a living system to an external signal as a step-wise process, and such models do have explanatory power. But the steps and their order are again a structure that we, the human observers, have created, in our attempt to understand. It follows from what we can see and sometimes quantify, not from any underlying fundamental property of the living system. If there would ever be an artificial, that is, human made system that emulates a living system faithfully, it would have to have proper concurrency, as in, every single atomic component of the system would at any given time interact with every other component. But this is not _necessary_ for a system that is able to maintain order. The real issues are elsewhere, namely: Where does the energy for the system come from? Can the system maintain its order using this energy without having any other goal but maintaining order? And how can a system like that be useful to us? We can only hope that such a system has a side effect that is somehow useful to humans.
&gt; but it's not actually doing anything useful. You make great points. This however heads the hammer on the nail. Because after all, the only reason why we see some living systems as useful (like a cow giving milk) is that they are alive, and happen to produce a side effect that is of use to us. In a way, the system you describe could be useful, if it happened to have even a waste product that is useful. Say, a sub-system that rebuilds a search index every time it restarts (to give a naive example).
The article mentions that "Erlang, C, C++, and the Go language produce more security errors than average, while projects written in Clojure and Typescript are less likely to have a security error." I can understand that C, and C++ have potentially more security errors than average; buffer overflows other pointer dereferences is often hard to take good care of. But how about Erlang? What is a typical security error? Is it because it is untyped or some other issue? How can we make these errors more aware?
If you actually look at [the source article](http://macbeth.cs.ucdavis.edu/lang_study.pdf), you can see that Erlang had an average number of defects. Some of that can probably be attributed to dynamic typing, as dynamically typed languages did fare worse on average. Erlang appears to have more concurrency, security, and failure errors than average.
Languages do not cause such errors; sloppy programmers do.
Java certainly had its fair share of security errors that would be no fault of the programmers writing it.
I didn't have time to read the full report, I will have to do that later, but what I could see example problems with deadlock, race conditions and synchronization. This I guess could be because many processes compete on the same locks, for example while updating the same entry in an ETS-table or something. Also as you said, failure and security errors is also a big group for Erlang. IMO a failure error is in line with the Erlang way, better crash than sorry. Finally: thanks for the link!
Well.. There could be sloppy programmers that develop languages, so you are kind of correct.
Article doesn't mention how many bugs where found in field, in QA or by observing code. It doesn't count how intensively code was used. The article authors probably understood that effect: http://xkcd.com/1312/ And made a pretty cautious claims. The journalist who made a catchy header didn't.
[Image](http://imgs.xkcd.com/comics/haskell.png) **Title:** Haskell **Title-text:** The problem with Haskell is that it's a language built on lazy evaluation and nobody's actually called for it. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1312#Explanation) **Stats:** This comic has been referenced 34 times, representing 0.0839% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cm27yf2)
Thanks for the link. That looks like an essential.
Is this more aimed at sysadmins tuning erlang vms or programmers, I can't tell.
Well he had a decent variety of [chapters listed on his blog](http://stenmans.org/happi_blog/?p=173) back in 2013. I think, if it hasn't changed too much, it would be good for programmers/sysadmins who want to fine-tune or language designers who want some background in distributed VMs. For the language guys, he did [his PhD](http://uu.diva-portal.org/smash/get/diva2:162047/FULLTEXT01.pdf) (PDF) on the HiPE system.
Is there a cowboy tutorial somewhere? I've been meaning to learn cowboy framework...
How is learn you some Erlang?
Very good. Probably the best place to start if you're new.
I think a combination of [Erlang's Getting Started](http://www.erlang.org/faq/getting_started.html) and the [index page](http://www.erlang.org/doc/) of Erlang's documentation should pretty much cover it. Here's a start if a mod wants to copy the below: Welcome to the Erlang Sub-reddit! Feel free to ask questions and trade hints, tips, and new libraries! **Online Tutorials** * [LearnYouSomeErlang.com](http://learnyousomeerlang.com/) * [Getting Started with Erlang](http://www.erlang.org/doc/getting_started/users_guide.html) user guide. * [Beginner Tutorial](http://www.erlang.org/course/course.html) at Erlang.org * [HowIStart.Org](http://www.howistart.org/posts/erlang) **Books** * "[Learn You Some Erlang for Great Good!](http://www.nostarch.com/erlang)" from nostarch. * "[Introducing Erlang](http://shop.oreilly.com/product/0636920025818.do)" from O'Reilly. * "[Erlang Programming](http://oreilly.com/catalog/9780596518189)" from O'Reilly. * "[Programming Erlang](http://www.pragprog.com/book/jaerlang2/programming-erlang)" from Pragmatic. * "[Erlang and OTP in Action](http://www.manning.com/logan)" from Manning. * "[Stuff Goes Bad: Erlang in Anger](http://www.erlang-in-anger.com/)" **Discuss** * IRC: #erlang at irc.freenode.net * [Mailing Lists or Forums](http://www.erlang.org/static/doc/mailinglist.html) **Contribute** * Source code can be found on [Github](https://github.com/erlang/otp). * [Let us know](https://github.com/erlang/otp/wiki/Bug-reports) if you find a bug, * Or [submit a patch](https://github.com/erlang/otp/wiki/submitting-patches)!
https://howistart.org/posts/erlang is another great resource for learning and, for references, https://github.com/inaka/spawnedshelter
I've been learning Erlang this week as my first functional language coming from a background of C/C++ and OOP concepts in Java and PHP and it's been pretty good so far! I figure I'm going to read all the way through it, and then start doing my typical hello world program (irc bot from scratch) that I do in most languages when I start.. And see where that takes me!
HowIStart is excellent. I've added it my post, I'm not sure what heading to use for spawnedshelter or even the [erlang-bookmarks](https://github.com/0xAX/erlang-bookmarks/wiki/Erlang-bookmarks) repo by 0xAX though. Although those are definitely worth linking to for more information.
One thing I'll say is, everyone uses rebar now, and it didn't seem to be a part of learn you some Erlang. That said, it's a very good resource - it actually manages to make up for the fact that there are so few other resources out there.
Thanks for your patience, i've used your template for now. I'm a relatively new mod. I'll likely update with other suggestions from this post later.
This was good, but I would recommend against the spammy clickbait headline next time. We get so little traffic in the erlang subreddit that you don't need to resort to those tactics.
Agreed. Reposted it under: http://www.reddit.com/r/erlang/comments/2nalrb/erlang_search_engine_demo_of_the_wand_max_score/
Is this the project https://github.com/wardbekker/search ?
Can you describe what it does?
Learn You Some Erlang was written with only the standard Erlang/OTP distribution in mind. I didn't want to tie it to the tools (whether rebar, erlang.mk, makefiles, some new kid on the block, relx, or whatever) that tend to change with the community, but the more standard stuff that'll always be there. 
the reason function call ends is because function reaches at the end of a function and returns the last expression. With this call you are starting call1 44&gt; multiproc:flush(). Because there is a message call1 consumes 1 message and calls itself again , which starts call2. At this point you have consumed one message from mailbox. But still have one more message. So call2 consumes one message starts call3. Since there is no message for call3, it returns ok. than value ok becomes value for call2 and call1 then your function returns the value OK and consumes all the messages as a side effect. I hope that answered at least some of your questions. 
I thought that when you run flush() on erlang shell, all mailbox messages are displayed like this (not one each time): self() ! self() ! msg. 1&gt; self() ! self() ! msg. 2&gt; flush(). Shell got msg Shell got msg ok 
But the multiproc:flush() function in your code has nothing to do with shell's flush() function whatsoever. Shell's flush() is not called anywhere in your example. If your function in multiproc module was called "abc()" instead of "flush()", the effect would be exactly the same. In your example, the messages from inbox are consumed because of "receive _" being executed, not because of the word "flush" being present in your code.
It update dependencies in multithread
&gt; why after 0 is a special case? `after 0` is not a special case. * For every clause (every pattern), the `receive` block goes through every message in the mailbox and tries to match the clause * a clause matches, remove the message from the mailbox and run the clause * no clause matches any of the message, if there is an `after` clause add a timer using the after's value * suspend until either a new message arrives or the timer triggers * if a message arrives, repeat from the top * if the timer triggers, run the `after` clause So what happens here is: * as long as there's a message in the queue, the clause will match (since it's a universal match), remove the message from the queue and loop (recursively call `flush`) * once the queue is empty, the clause does not match anymore (since it needs a message), the `receive` blocks adds a timer for "now" * the timer fires immediately and runs the `after` clause's body * there's nothing else to do, so the function exits 
Really clear answer. I think that my misunderstanding was in part due my poor knowledge about passing messages. I was thinking that the ONLY way to pass a message to a (spawned) process is through the `!` operator, like this: Pid = spawn(multiproc, flush, []). Pid ! some_msg. But, what I think the function is doing is to receive EVERY message on the shell queue, so, once the mailbox is empty, the function ends (by the `after 0` clause). If this is true, could a function be able to read the messages on the shell mailbox? 
The terminology was a bit loose, I really meant C functions as they could use an underlying API to send messages. I've never really dived into BEAM's C API.
So every erlang's process have a "mail box" or a queue. When you send messages to a process it goes into the process's mailbox. So basically after it goes through every single mails in mail box and is done with the mail, the `after` goes into effect. btw if IIRC the mailbox is time shared. So Erlang preemptively stop running one mail in the mailbox, put it back in the mailbox and grab another one to run and continue cycle until the mail is done. edit: fun fact, IIRC erlang's process are just threads lol (http://www.erlang.org/doc/getting_started/conc_prog.html). edit2: my ascii diagram sucks nm removed. edit 3: Oh you're confusing the repl's flush function with the erlang flush function.
&gt; It was fun to translate this Java DAAT implementation to a relative speedy Erlang implementation with immutable data structures. I can't imagine Erlang being speedy for this type of thing. It seems to require some matrix manipulation? Do you have any benchmark compare to Java? It's pretty neat and I don't mean to down play but I'm just really curious how well it fare in term of speed to other language such as Java? I also suck at reading research paper but I've done some self taught NLP (very noob). Don't you need to store the stems for searching? Or are you stemming in real time and then search? 
Erlang is certainly not the fasted language, but I believe the right algorithm in good Erlang code doesn't have to be slow. I'm now adding skip lists, after that I'm planning to post some benchmarks. Regarding stemming: I'm using Porter stemming, which are indeed stored. 
Yes.
Why did this get no comments? Great talk!
So... we have just concluded that our simulated universe is likely running on Erlang servers? ;)
I'm still waiting on a version 1.0 for erlang ChicagoBoss or Phoenix Elixir. In general I think there's potential but there isn't any killer framework in the webspace yet. OTP is great and it's a killer framework but not a lot of start up need to start at OTP from the get go. They need an app and most of the time it's a web app. My recent Erlang meetup everybody question why Erlang isn't adopted more. Ruby didn't really get popular until RoR started really. At least this is how I recall Ruby started to take off. And I believe elixir or erlang will take off if there's a good web framework.
This implies Erlang is a good fit for request/response type web applications. In my experience, it isn't. Erlang really *isn't* a general-purpose language. It's horrible to write twisted logic in it. There really aren't many language features that allow for good levels of abstraction so your code ends up being rather brittle rather quickly. However, it's extremely good for certain workloads, in my experience, simple web-applications are not it.
Me not advocating Erlang for general web applications *does not imply* I advocate Node.js. What the hell are you *thinking*?
Though I'm not a full time Erlang user, I find it really easy to write insanely complex logic using pattern matching (easier to understand logic due to the lack of state), and less brittle because so many errors are caught by looking at the function signature. But I don't have as much experience as you probably do. Can you explain more about what issues you had with logic, and how your code became brittle? 
Why not just switch to erlang.mk ? I recently switched and it feels like it dots a nice job of bringing together traditional make builds and otp.
I think the not hiding concepts in records and other advanced techniques showing up less in open source projects has more to do with the experience level of the programmers. Once you have been burned enough times by spaghetti code you avoid it like the plague. After many decades doing OOP development in c++ and Java (god, how depressing) I have learned that those formalisms pay off. These days I write thousands of lines of Erlang, using gen_server extensively, including web-apps using websockets, and find it a great language for those things. Including pattern matching. In Erlang, "if" statements considered harmful. :) 
I just woke up. But anyway, I'm not implying that. I'm giving an example of something that Erlang can do better than, which is Node.JS and that lots of people are using Node.JS to do simple web application. Perhaps while I agree with you that Erlang web framework might not be the best for simple web application but if it can bring the same hype as Node.JS then it would be good for Erlang. I know we're getting in deeper into the conversation and maybe diverging so we might lose the broader message of the original comment. But originally, I'm advocating for a killer framework. An example of it is RoR and how I believe has helped push Ruby as a language. You stated that you don't agree with Erlang ~~having a killer framework such as~~ web framework. At least that what I've read from you're comment. And to which I agree but gave a counter point to support the original comment which is Node.JS. There is no implication, at least it was not intentional, that you like Node.JS or are pushing for it.
Arguments from authority aren't going to cut it for me sorry. Having worked with a lot of erlang code and tonnes of open source I can definitely say there is room for improvement with the general quality of code out there.
Any chance there's a video of the talk that goes with these slides? Would help alot. Does N2O eliminate the need for a front end framework like ember etc? That's what nitrogen seemed to do.
Yes it can. You can render on the server side just like Nitrogen using plain Erlang. There is example in using React.js it seems. Can also of course use Ember/Anything on the front end if you write just a REST API for your backend, there is an example for that tool. BTW N2O comes with a free book: https://synrc.com/apps/n2o/doc/book.pdf 
I always had trouble trying to get this to work (trying periodically between 2005 and 2011) If I knew enough C to debug this, I would have already written my own erlang process wrapper. [Some assembly required](https://github.com/rtraschke/erlang-lua) is an understatement. I have an error. Is it rebar, is it erlang, is it lua, is it the C node, is it the platform? Where do you go for help on it? The mailing lists. They were never newbie friendly imho. I'll try this out and I applaud the effort because erlang and lua are powerful tools, but I expect to hit a gotcha that basically can only be solved by more C. That's normally how my erlang projects end.
This is a general solution for interfacing erlang to other languages/systems. If it is specifically Lua you are after then another solution is to use Luerl which is an implementation of Lua in erlang which I have done. Most interface problems disappear but it is not as fast as the external Lua.
&gt; Pattern matching is the antithesis of abstraction. Once you start reaching into the objects you want to use, you remove the opportunity to abstract components away. There's truth to that but this has been mostly solved in languages like Haskell without (apparently) any draw backs.You can abstract over patterns rather easily with view patterns and pattern synonyms. F# also has an interesting approach with active patterns.
This lsci library is written in LFE but can be used just as easily from Erlang. Looks pretty neat.
I got it YC at last
This looks exactly like my hottub library I made nearly 5 years ago, surprised you guys didn't find it. Its cool that you guys implemented the various strategies though. I tried a bunch for my given work flow and found just a gen_server with a queue as being fast enough. with consistent performance.
I love how they're all tools Kostis had his team of PhD students slave on.
Was anybody here able to try Tidier? I tried to access the [getting started page](http://tidier.softlab.ntua.gr:20000/tidier/getstarted) multiple times over the last year. It does not seem to be actively maintained anymore (judging from the page crashing). 
Last time when I saw Tindier working was ~2011. 
There is another such list: [The Spawned Shelter](https://github.com/inaka/spawnedshelter)
You're right, it's almost *the same thing* I'm not usually a fan of package managers and such... but this wouldn't have happened if we have had something like [hackage](https://hackage.haskell.org/) for erlang, right? As a reference for others: [this is hottub](https://github.com/bfrog/hottub).
Thanks for sharing. I am interested in learning erlang and these are the kinds of things that nobody explains because they assume you already know. Keep it up!
This project requires an cluster of Erlang nodes to be connected. If you are looking for discovery of not yet connected nodes, check out https://github.com/wooga/reconnaissance . 
This feature can allow some nice shorthand syntax. See [this tutorial for PropEr](http://proper.softlab.ntua.gr/Tutorials/PropEr_testing_of_generic_servers.html): command(S) -&gt; Users = (S#state.users =/= []), oneof([{call, ?SERVER, create_account, [name()]}, {call, ?SERVER, ask_for_popcorn, []}] ++ [{call, ?SERVER, delete_account, [password(S)]} || Users] ++ [{call, ?SERVER, rent_dvd, [password(S), movie()]} || Users] ++ [{call, ?SERVER, return_dvd, [password(S), movie()]} || Users]). Instead of using lengthy ifs or cases, simply append lists. 
You think that would be better than the following code? command(#state{users = []}) -&gt; oneof([{call, ?SERVER, create_account, [name()]}, {call, ?SERVER, ask_for_popcorn, []}]); command(S) -&gt; oneof([{call, ?SERVER, create_account, [name()]}, {call, ?SERVER, ask_for_popcorn, []}, {call, ?SERVER, delete_account, [password(S)]}, {call, ?SERVER, rent_dvd, [password(S), movie()]}, {call, ?SERVER, return_dvd, [password(S), movie()]}]). or even what about the following one? command(S) -&gt; OptionalCalls = case S#state.users of [] -&gt; []; _ -&gt; [ {call, ?SERVER, delete_account, [password(S)]}, {call, ?SERVER, rent_dvd, [password(S), movie()]}, {call, ?SERVER, return_dvd, [password(S), movie()]}] end, oneof([ {call, ?SERVER, create_account, [name()]}, {call, ?SERVER, ask_for_popcorn, []} | OptionalCalls]). I think your code is *brief* and maybe *smart*, but it will be a nightmare to edit if somebody other than you stumbles into it later ;)
You are right that your version is clearer (the tutorial had to explain the trick as well). But I still like the briefness of the example.
This LFE has a small but growing community consisting of language developers, hackers, and general enthusiasts with a wide variety of experience and backgrounds (Clojurists, Erlangers, Haskellers, Javaheads, Lispers, OCamlers, Pythonistas, Rubyists, Schemers, etc).
As a fan of Elixir and Lisp, this looks very interesting! I've been very limited on exploratory programming time lately but I'll definitely put this on my list of things to play with soon :)
Thank you for your feedback.
"Note if you put lager dep after ranch you will get an error when compiling, that's sad" this is because mariano defined a parse transform to be used during the compile phase, and since ranch would then be compiled before lager, the compiler doesn't know about the parse transform and throws an error.
"Eshell V6.3 (abort with ^G) 1&gt; application:start(eco). {error,{not_started,ranch}} 2&gt; application:start(ranch). ok 3&gt; application:start(eco). {error,{not_started,lager}} 4&gt; application:start(lager). {error,{not_started,goldrush}} 5&gt; application:start(goldrush). {error,{not_started,syntax_tools}} 6&gt; application:start(syntax_tools). ok 7&gt; application:start(goldrush). {error,{not_started,compiler}} 8&gt; application:start(compiler). ok 9&gt; application:start(goldrush). ok 10&gt; application:start(lager). ok 11&gt; 21:05:52.373 [info] Application lager started on node nonode@nohost 11&gt; application:start(eco). ok 21:06:09.335 [info] Application eco started on node nonode@nohost" so much easier than fumbling through the application error messages would be application:ensure_all_started(eco), which recursively attempts to start all required applications in the app's app.config. 
great! I asked about that on twitter, thanks! I will add a note on the post :) EDIT: post updated
Leading off a job request / comment with "I think a competent Erlang dev could fix it in a day maybe" is a sure fire way to get every competent developer to ignore you. Clients who try to pre-box work before the developer even gets to look at it tend to be ungodly nightmares. Just an FYI. Good luck. 
What are the problems you are having with the module? You could start with that.
I'm a developer. If the work were in a language I was familiar with it would take me around 2 - 3 hours. So I made my estimate based on that and added some leeway...
Really cool. Thanks! Some sort of README would be useful to explain what this is, its constraints, its limits, which erlang version it runs...
The article is a bit dated (5/2012). Cowboy has excellent documentation now. The code won't work with Cowboy 1.0, which has split up protocol handling between ranch and cowboy.
Slides: http://slides.sigma-star.com/view/ChicagErlangConference-Nitrogen
I think http://erldocs.com/ is slightly better at this.
anyone following along, you can get quite a lot of the examples here: https://github.com/ninenines/cowboy/tree/master/examples/websocket 
If I type "ets:", it doesn't auto complete or suggest anything… EDIT: It's also annoying to have a window pop-up. It should show results on the same page.
I figured out what was wrong. I was missing the dot at the end of my stuff. So I was typing help () which is wrong instead of help(). 
Or "built-in" one http://www.erlang.org/erldoc .
Hey, Imagine an abstract pub-sub scenario, where you have a producer, maybe some transformers un the middle, and a final consumer. So an example: [File reader Srteam]----&gt;[encryption Stream]---&gt;[TCP OUT Stream]---&gt;[TCP IN Stream]---&gt;[Decrypt Stream]---&gt;[Some Consumer] The main advantage is that, in case [TCP OUT Stream] is slower that the producer (or vice versa) TCP Out can propagate pause States, or Even Dropped (Close) events. By doing that so (Streaming), You are requiring a minimum memory, (size of stream's buffer) until the packages flow to the consumer, and not to have the whole payload (file) in memory. Any suggestions? 
hi bud, that's exactly what I'm using. Except I bought the book, without knowing that it was free. :/
It's probably nicer to read on paper ? Anyway, count it as a way to thank the author for its hard work :).
Seems like the exact parts of Erlang that made it so attractive to us, are the parts that don't seem to be working as advertised. Edit: Please don't start any religious war about languages on the post there. My hope was to get feedback here without causing a debate on the post in the Golang forum.
Erlang is really great for getting exposure to some nice theoretical concepts, and for some use cases it can be great, but I feel like there's nothing you get out of the box with Erlang that you couldn't roll yourself using other languages and technologies. Once you understand the Actor model and the concept of message passing, it's something you can easily simulate yourself using something like Zookeeper or Kafka. The supervisor hierarchies and restart policies are also nice, but (at least when I was learning Erlang) this forced you to use OTP, which, in my opinion, is absolutely horrendous and painful to work with. It just feels very archaic and ad-hoc. It mostly depends on a heartbeat technique, so if you understand CAP, it's nothing a simple registry and some scripts couldn't do for you. The one aspect that would be hard to replicate are hot releases/upgrades, but this also forces you into a lot of complexity with the various configs, upgraders, downgraders, etc. Again, I think something like Zookeeper with silos would be a sufficient replacement. I was never really able to get past the syntax of the language, the poor documentation, the complexity and lack of polish of their APIs, etc...the lack of tools and IDEs that I was accustomed to coming from Java, .NET, Python, Ruby, etc really made it annoying to code in. Maybe things have improved in the last few years, but I just never felt productive in Erlang and didn't enjoy the masochism of it all. I'm sure I was just "doing it wrong" but whatever...I've got products to ship...
Some of the tooling has (thankfully) greatly improved in the last few years but there isn't a crazy-cool IDE for Erlang. If IDEs more complex that say, vimerl are a must-have for you then Erlang isn't going to meet those needs. I will say that passing around MB sized messages is just horrific. It'd be like blaming your digestive system for being faulty if you refused to chew your food. Hot code reloading requires you to take a quite vanilla approach and to not spend a lot of time screwing around with or subverting OTP structure. OTP's there for a reason and if you follow the guidelines, yes you can (and I have) reload live code just fine - Whatsapp do it regularly. I actually love OTP and it's hard to argue with the results. There are Erlang applications which have run for literal decades. Erlang handles huge torrents of information on a daily basis. Obviously don't use it if it doesn't meet your needs but you'd be surprised how many 'problems' people have with it tend to derive from them just not using it correctly. The developer in the linked post is very upfront about his company's usage so this is definitely not a suggestion that he's some sort of 'noob' but to be honest, for their use case, if they genuinely need to do things the way they're doing them, they should consider either re-architecting areas of the product or going with a different solution. 
Have you looked at the Elixir language? Erlang turned me off syntactically until I played with Elixir and now I'm sold.
I was going to reply on this, but then I realized that I've been having the exact opposite experience in all the "failure" points you seem to encounter. We were able to pick up Erlang for production in a couple of months. Also, OTP is *not* something you can come up with a few "scripts glued with zookeeper".
Not sure why you are getting down-voted, these questions are what make sub-reddits more active, popular, and fun. We shouldn't be antagonistic towards this. I would however ask the OP to further explain what parts of the Erlang language they found attractive so we can provide more targeted explanations (if a non-biased review was truly what they were after), as currently we are forced to be anecdotal on all matters Erlang. I would be happy to go point by point but this has limited use for others looking for Erlang answers. It's hard to diagnose issues without more information, and in the case of the linked post, doubly so. They pointed out that they are passing extremely large messages (MB). This could easily be a garbage collection issue if they have coupled that with long-running processes (i.e. if they don't go to sleep or die there's no point at which to GC). But again there is no way of knowing without more information. 
When I work with erlang I have pretty much the opposite experience to what that guy is describing. Granted, I work with exactly what the language was designed for (large-scale telecom systems), I've never seen stuff that just "stops working" for no reason. Our systems survive hot code loading, zero-downtime upgrades, handovers from one node to another in case one dies, amongst other things. I wasn't around before we made the switch to erlang, but according to *everyone* I work with, they're infinitely more productive in Erlang than they ever were in C++, so about not being able to be productive in Erlang, that's pretty much BS. I think the syntax is not the prettiest thing around, but it's not ineffective and not clunky... at least not if you're "doing it right" the functional way. It's an initial hurdle you need to overcome, as it doesn't look like "all of those ALGOL-like languages", but after a couple of weeks you won't even think about it anymore. Go's syntax will be more familiar to you if you're used to working in python. But as I said, that's just a small hurdle. Give it a chance, I don't know what kind of project you're doing, it's definitely not ideal for all projects, but neither is any other language.
and now you've restarted the fire in me to continue learning erlang.
Sometimes it is easier to think about a tail call as a jump (or goto) and variable assignment. In this case, N = N-1, List = [Term|List], jump tail_duplicate.
It will add Term to the head of List. And then that combined list will be sent as the argument to the next iteration. That's what the | does. Pushes an element onto a list. Regarding tail recursion, it's just [recursion](http://en.wikipedia.org/wiki/Recursion) (assuming you understand that to begin with) with the call to recurse being the last statement in the function. This allows the compiler to do [tail call elimination/"optimization"](http://en.wikipedia.org/wiki/Tail_call), preventing the call stack from getting too deep. It basically converts the call to an assembly-level GOTO instead of pushing another call onto the call stack. Ugly, but effective. :) To be honest, I was always a little uneasy with this pattern, because it kind of requires you to understand a compiler implementation detail in order to not run out of stack space. There aren't too many high-level language features that basically require you to understand how the compiler will see it (even if it's not too difficult to fathom). Ideally, computer operating systems would just somehow manage nearly infinitely deep call stacks well... but that's not the situation we're currently dealing with.
&gt; As I have it understood is that this takes (N, Term) and puts them into (N, Term, []). It takes the data I give it and when it reaches 0 for N it will give List. The function takes (N, Term, List) and while it's greater than zero it will, take that information and subtract 1 from N, store the term in term, Good so far... &gt; and it will? This is the part I'm having trouble with. Does it take [Term|List] and toss it in again? Yes. `[Term|List]` (specifically, a new `List` with `Term` pushed onto the front of it) is passed into your tail-recursive function (along with `N-1` and your `Term`). &gt; How does it prevent list from being in each duplicate? Using a nifty feature called "tail-call optimization", which is why tail-recursion has historically been the preferred way of doing things performance-wise. You usually don't need to think about this unless you're doing something extreme like implementing your own Erlang VM. &gt; I don't understand this. The easy answer is that you don't need to; the Erlang VM takes care about that for you, since it's able to recognize that your function is tail-recursive and apply the necessary deduplication automatically. The slightly-less-easy answer is that tail-recursive functions are able to run without having to know the state of the previous invocation, which is why they're able to be automatically optimized by the interpreters/compilers/etc. of most recursion-capable programming languages (though this isn't guaranteed, as is the case with, say, Common Lisp). Since the entire state of the function has been passed to the next iteration, the VM is able to pretty much forget about the previous iteration(s), thus eliminating duplication. The above is a *very* simplified description, of course, so take it with a grain of salt. /u/kalmakka's answer is much more descriptive.
&gt; Tail recursion can be explained by imagining a general standing in front of a line of N soldiers and wants to know how many soldiers there are, so he asks the soldier to the left how many they are. &gt; &gt; The straight-forward way would be for the soldier to ask the soldier to the right to count himself and all the people to his right. That soldier will then ask the soldier to his right to count himself and all the soldiers to his right, etc. until the rightmost soldier reports that it is just him (1). The soldier to the left of him will then add 1 to this number to include himself and report to the soldier to the left of him again that they are 2 soldiers, etc. Eventually the soldier to the left will hear that there are N-1 soldiers to the right of him, so he will add 1 and report to the general that there are N soldiers. &gt; &gt; The tail-recursive way would be for the leftmost soldier to say "the general wants to know how many we are. We are 1 (just me) so far" to the soldier to his right. That soldier will then say "the general wants to know how many we are. We are 2 so far." etc. until the rightmost soldier hears "the general wants to know how many we are. We are N-1 so far." who will then report directly to the general that they are N people. Taking a note of this; probably the best non-code example of tail recursion I've seen so far. On another note... &gt; This code does the same thing, but it can not benefit from tail recursion (unless the compiler is clever, which it might be). [This is indeed the case for Erlang nowadays.](http://www.erlang.org/doc/efficiency_guide/myths.html#id59389) However, the described cases assume that you want to call `lists:reverse/1` on the output (since usually a tail recursive function will emit a list that's backwards relative to the non-tail recursive equivalent), so YMMV.
You could try to connect to the remote node with the -remsh option of the erlang shell (http://www.erlang.org/doc/man/shell.html)
Linux machines aren't capped at 65535 ports at all, a single *interface* is because, well, IP.
the first thing that comes to mind is a docker container. it's not zero-install, but it's very close!
You want to look at Vagrant [0]. Many people will already have Virtualbox installed and it is a simple install for those who don't, and Vagrant is pretty easy to install. Once that is done getting a VM up and running, including automatically installing whatever packages are needed, is just a single command. Another option would be a Virtualbox appliance [1], which would only require Virtualbox to be installed, which is basically trivial to install. You could pre-install Erlang and whatever else you need (even some sample code) into the appliance so it would be ready to go the moment they booted it up. [0] https://www.vagrantup.com/ [1] http://www.virtualbox.org/manual/ch01.html#ovf
If this is about playing with erlang you could, maybe, try a RPC server over TCP (or mod for http). This is the one built in 'Erlang and OTP in action': https://github.com/erlware/Erlang-and-OTP-in-Action-Source/tree/master/chapter_04/tcp_rpc Also https://github.com/killme2008/erlwsh and http://www.tryerlang.org/ may be worth looking at.
Have you thought about using those "virtual desktop" machines AWS and Rackspace (I think) have? They are probably pricey, but if you just need them for 8 hours or so (setup + presentation) the cost probably wouldn't be bad. If you used Windows, anyone with an RDP client could access and get a GUI, which might be preferable to SSH, depending on the crowd.
I wouldn't worry about that. They're going to run it for an hour, not full time day in day out.
Depending on how much time you have, why not sandbox a session inside the browser e.g. http://www.tryerlang.org/ or http://www.tutorialspoint.com/compile_erlang_online.php.
Hey, it was still helpful! The comment was more for those who follow me looking for a similar solution.
You can probably get away with deploying something like [tty.js](https://github.com/chjj/tty.js/) on your workstation, and then serving up the real erl repl with that. Granted, all that is is a pretty web terminal, so the experience with ssh would be similar, though a little bit more work than just hitting a url. You can also turn that 'syncSession' option on, which will spawn a single pty (rather than a shell process for each request), and do a 30-man pair programming session.
With Java by the jinterface
On reimplementing OTP in go or whatever your favourite language is. I found the book "Designing for Scalability with Erlang/OTP" makes a great case for why you wouldn't want to do that and pointing out the various cases that you need to consider to get your own implementation right. Personally I'd have confidence that OTP is correct, because it's been used for so long and the combined engineering effort that has been put into it.
ASCII tables? It's the 21st century...
Yes they are already being posted to youtube https://www.youtube.com/user/ErlangSolutions
I am not an Erlang developer, I can only speak as a Redditor. I am subscribed to this sub because I am learning Haskell. But my guess is two different crowds. At the end of the day, Reddit is mostly teenagers and stoners. People who go to comic cons, not industry cons.
There are a lot of us tech folk here. We just don't post as many pictures.
Check out #erlang / #erlounge on freenet IRC some discussion there. Twitter also has some back and forth, some positive, some complaints and bickering.
&gt; At the end of the day, Reddit is mostly teenagers and stoners. People who go to comic cons, not industry cons. So you're saying that /r/haskell is mostly teenagers and stoners?
I've wondered about this as well. Programming language communities and reddit seem to be hit and miss. This sub is a big miss unfortunately. Even /r/elixir is a much more active subreddit. /r/erlang is nowhere near an outlier when it comes to this phenemenon however, but it would be great to keep this place more alive.
&gt;There is now also support for variables as map keys. Yaaay! It may have been possible to work around, but it was a major pain in the ass. 
I just couldn't stand this talk enough to finish it. He's annoyingly critical of some things and hand waving about another.
&gt; [–]Categoria 1 point 7 hours ago &gt; This is spam and has nothing to do with erlang. &gt; permalinksavereportgive goldreply &gt; &gt; formatting helpreddiquette &gt; save &gt; Why did you say this is a spam? I try to find channel ejabberd but not found, I think it relate to erlang channel. If not please let me know where to post this question?
I wouldn't say teenagers, but definitely college students. Haskell being popular in universities probably helps make its subreddit very active. Erlang seems to attract an older crowd, to some extent.
Good read. Learning curve for PropEr/Quickcheck is a bitch, but it's totally worth it for more complicated software.
I have shipped two systems using Erlang. One integrated with Java, the other with C, C++, Haskell and Python. On the latter project we picked the best tool for each piece and wrote glue between them, and we were left with really well defined glue, and replaceable components that could have each been written in whatever language was worth moving something to, should the need arise. I had a Haskell simulator for a real control system stack written in C++, but I also had Haskell driving real devices in the production stack as well. The glue specified how communication between the pieces worked, and not it wasn't google protobuf or something else. We chose something rather bizarre, but that had other benefits. My experience with Erlang was mostly positive, and I still really like the language. I love writing a big function in a pattern-matching style, but the language is SO dynamic and late binding that you can successfully compile code that references functions in other modules with typos present and not know about it until it crashes during testing (YES YOU HAVE TO TEST CODE). I've gone from one end of the spectrum on strong typing to the other from time to time. Strong typing can make refactoring code a nightmare, but it provides nice, static checking for your code to eliminate classes of bugs. Erlang is not totally doomed here as the dialyzer does a lot of nice things for helping to verify code. Run it and trust it! No programming language I'm aware of completely saves you from having to worry about problems of distributed systems. Availability of resources in a networked environment is worse than a local system, but the problems are the same. What if your hard disk dies in a machine with a hot-swappable disk? You have to either shut everything down or provide limited services from that machine to increase "overall availability" until you can replace the drive from a backup. If your data source is over a network, you have to deal with not just the disk failures but the network going down, or just temporarily partitioning, thus failure rates are higher when networked. Erlang provides a model where you have message passing that's asynchronous on the send side. Go can do this with buffered channels, but a network is more like Erlang's model. You can send a message and never hear a response, or hear a response later than expected. You've basically got to come to terms with the fact that all distributed systems are in many ways a kind of "soft real-time" system. So, that said, it's always up to you to evaluate tools and choose wisely. Think about what it is YOU need to do for your app and then maybe ask the experts if it's a good fit. Don't worry too much about some other person's rant. Changing toolchains, libraries and languages always comes with a risk/reward profile, and you're going to have to decide what's best for you. I'd use it again for another project for sure. People are quite successful with it in making big distributed systems that work well, like Riak.
Hah, Alvaro. Used to work with him.
I spent some time with the ChicagoBoss framework (and eventually left and am writing OTP things directly on top of cowboy) -- so that (being an erlang web framework) may be a good place to get your feet wet in terms of web development. In relation to learning the language -- theres a lot of decent resources lately. Spend a weekend with 'learn you some erlang for great good' and you should have the basics down; then I suggest grabbing 'Erlang and OTP in action'; for me it was the best resource to get comfortable with OTP. I'd agree with your outlined comparisons; except for maybe the first -- nodejs = yawn/cowboy. 
I started with http://learnyousomeerlang.com/content and do most of my web stuff with cowboy and erlydtl. 
When I first started, I jumped straight into a web framework, thought I'd be able to hack it, and got overwhelmed. Make sure you run through learnyousomeerlang before you dive right in. It's worth it, and it's really well written. Also, it has funny pictures.
The way I usually approach it, although might not work for you: Start with what you want: "I want the sequence of numbers going from N to 0, noninclusive. Then, figure out when you *stop*, the base case. "If I get to zero, I'm done". f(0, Acc) -&gt; Acc; What do you do at each step? "Every time I have a number, I want add it to the front of my list..." f(N, Acc) -&gt; NewAcc = [N | Acc ], And how do we get the next? "...And then I want to do it for the next number smaller" f(N-1, NewAcc). Generally speaking, if you want to collect something, you're gonna want to pass in an accumulator, to keep track of where you are. These types of loop are also very much like C style for loops. Accumulator; for(InitialValue; NextValue != Base; NextValue) Body; func(Base, Accumulator) -&gt; Accumulator; func(InitialValue, Accumulator) -&gt; Body, func(NextValue, NewAcc). 
There is/was a MOOC over at coursera: Systematic Program Design. While working with racket (scheme), you should be able to gain deeper insights into various program design techniques and how to think about them.
s'pose it would
 counting_func(N)-&gt; counting_func_impl( N, []). counting_func_impl(N, Acc) when N &lt; 0 -&gt; Acc; counting_func_impl(N, Acc) -&gt; counting_func_impl( N-1, [Acc|N]). Where this takes the number given, stops when it reaches 5 and gives us the Acc. First we take the number and we match it to (N, []). Where the 1 will be our starting number, N is where we store the number while we are working on it, and [] is where we perform the work. Is this ok? I find it simpler to make it stop at 0, by letting it roll from the number until it hits zero. so it would be the same [4,3,2,1] if we do [Acc|N]. Or we could do [N|Acc] where it would do [1,2,3,4]. I'll give your method a whack, because I want to also learn it, and it can't hurt to know more than one method. so for a number where we want to count up to 5, it should stop when it reaches 5. That is our base case. Homework: count_up(N) -&gt; count_up_work(1, N, []). count_up_work(1, N, Acc) when N &gt; 5 -&gt; lists:reverse(Acc); count_up_work(1, N, Acc) -&gt; count_up_work(1, N+1, [N|Acc]). what this should do is take the Acc and reverse it using the BIF lists:reverse. 
Looks good to me. Seems like you get recursion now. `:)` It'll take some practice to get used to it.
Thank you for your help, enjoy the gold. :D 
Learn how one of your favorite file formats works (JPEG, git, `.pyc`) by writing a decoder.
Sorry for having to resubmit this (it was an hour ago). I've made a mistake in the title of the original post.
some lab of this course may be a good start [Distributed Systems in Erlang](http://people.kth.se/~johanmon/dse.html)
Thank you for sharing. I've signed up, see you on the 11th (-:
No, its about something else. Shared large binaries are placed on shared heap and ref counting is used to determine when they can be freed. Unfortunately, it tracks if processes that use this binary are alive, not if processes that referenced the binary still use it. So for large binary to get freed all processes that have touched it needs to die first. This way long living processes plus large binaries equals memory leak.
Indeed, and I am aware of that. I'm just not seeing those long living processes :) as soon as a task batch execution is over, all the workers, respective non-OTP task processes and master, which were set up just for that task batch, are terminated - only the caller will remain. Unless you're talking about those binaries not being freed as long as the task batch is in execution, but that's rather expected and shouldn't be an issue. The only issue I see that might pop up is some of the spawned non-OTP processes (for the workers) getting stuck or locked in some fishy condition, but that's easy enough to solve using an exit/kill on task timeout (and something I will fix.)
Care to explain the relationship to Erlang? 
This is a long-awaited rewrite of OTP.Net that has finally been opened yesterday. It brings Erlang OTP natively to CLR/net platform, supports Erlang types in CLR app, and allows one to interoperate bewteen Erlang and .NET nodes, i.e. you can host a OTP node in .NET and consume form Erlang and viceversa
This is for people who have much code developed in Erlang and much code developed in C#. The project grew out of practical need to interface with Erlang backends from C#/.NET frontends that already exist. Practically, we pumped 25,000 updates/sec from Erlang high freq trading backend into C# UI that showed 32 grids on 8 monitors
I'm well aware of that bridge. Maybe you've linked the wrong project. **Edit:** My mistake, I found the one reference. I suppose this is a lot more than just a bridge, which is why it doesn't mention the relationship to Erlang so clearly.
Edit: Do not enter an odd number or your computer will freeze. %%V2 bytwo(N)-&gt; bytwol(N, []). bytwol (0, Acc)-&gt; Acc; bytwol(N, Acc)when N&gt;= 0 -&gt; bytwol(N-2,[Acc|N]).
I would prefer to define the exit condition first: -module(bytwo). -export([bytwo/1]). bytwo(N)-&gt; lists:reverse(bytwol(N, [])). bytwol(N, Acc) when N =&lt; 0 -&gt; [0|Acc]; bytwol(N, Acc)-&gt; bytwol(N-2,[N|Acc]). Output: 17&gt; c("bytwo.erl"). {ok,bytwo} 18&gt; bytwo:bytwo(10). [10,8,6,4,2,0] 19&gt; bytwo:bytwo(9). [9,7,5,3,1,0]
unicode:characters_to_binary with encoding parameter
Rather than use a guard, I would just have an extra clause that is specific to the case N=1. As long as you start with N&gt;=0 then you know that you will either go through 1 (if N is odd) or you will go through zero (if N is even). -module(bytwo). -export([bytwo/1]). bytwo(N) -&gt; lists:reverse(bytwol(N, [])). bytwol(0, Acc) -&gt; Acc; bytwol(1, Acc) -&gt; [1|Acc]; bytwol(N, Acc) -&gt; bytwol(N-2, [N|Acc]).
The section about performance in the "It's not about syntax" is BS. Seeing Elixir compiles down to straight Erlang, not directly to the Erlang VM codes, expecting it to be faster is a little "over-enthusiastic". The case mentioned is just different algorithms.
lazy Q but where is a good source of info on bit torrent protocol ?
related to this, it may be useful for someone: https://github.com/marianoguerra/jwt-erl
Good post. Thanks. I also found this: https://github.com/kato-im/ejwt Haven't test or use any of them yet. Note that there is a vulnerability in some jwt implementations: https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/
A cursory search shows that, what are presumably shill accounts, seem to be posting these to a number of programming sub reddits.
A bunch of self-congratulatory twitterfappers, I really wouldn't take what they have to say as fact. For example, Rich Hickey as an influential Erlanger? Yeah k.
Rich Hickey is surely a talk of all the sub-reddits it seems. Anyways, he created clojure &amp; has influence (atleast on twitter community :-() in functional programming &amp; programming languages, so in top 10 in erlang too. The system dampens the celebrity factor after the 2M influencer graph is partitioned into ~40K deep interest areas, but top experts surely overlap in neighboring communities. We are taking all the feedback to see how we can improve the ranking process &amp; further customize page rank to dampen pseudo influence. Would you guys be willing to share a rough number (10%/60%/80%/ 90%) of the articles &amp; Influencers are relevant to erlang? 
Assuming that cowboy works on Erlang on Xen, then you could do this: http://ninenines.eu/docs/en/cowboy/1.0/guide/static_handlers/ 
I hate to channel OP's username, but if you really only want to serve a static website, you can [point your domain at an S3 bucket and you're done](http://docs.aws.amazon.com/AmazonS3/latest/dev/website-hosting-custom-domain-walkthrough.html) or [run nginx](http://nginx.com/resources/admin-guide/serving-static-content/). Even if only part of your site is static, you'll be able to do more with less if you serve that part of the site from a web server optimized for that purpose. In the unlikely event you are constrained to only using erlang on xen, /u/jake_morrison's suggestion is good.
&gt; λlready a member? Somehow, that hurts.
Quite a bit. One could assume that this symbol has more meaning to FP than its resemblance with a capital a.
Presume that if you learned something then there are other people out there who will find the blog post informative too. Maybe follow up with an article on "here are safe and secure alternatives."
http://www.erlang.org/doc/apps/ssl/ssl_distribution.html is an option.
What about [now](https://github.com/inaka/gold_fever#instructions)? :)
check [the hipchat room](https://www.hipchat.com/gpBpW3SsT) or open a github issue on the repo… maybe there are others that can help you in your quest, @DeepFreezZA ;)
Erlang MQTT Broker http://emqtt.io https://github.com/emqtt/emqttd
We just wrote a small bootstrapper for erlang and travis integration without the requirement of Rebar. You can easily write libraries in erlang with continous integration. For application Rebar is recommanded.
* This is interesting but `rebar` is preinstalled in the Travis CI environment * If I may here is how I do my tests with Travis and without rebar: [the .travis.yml](https://github.com/fenollp/hep_erlang/blob/master/.travis.yml) and the [Makefile](https://github.com/fenollp/hep_erlang/blob/master/Makefile) Is DernierCri doing Erlang stuff in France?
First : Yes : DernierCri do Erlang in Lille :) Next: Your solution is very nice. In fact we wrote this because we use travis for a little atomic library and we don't need Rebar (and App behaviour) in the library (who was already writted). Comparison between your solution and ours, we provide a very simple and atomic solution ;) Thanks for your feedback. 
Like a program where you calculate the price someone pays if they are getting shipping. I'm thinking I would have to spawn some processes
This post is kind of a mess... You really should clean it up and ask a specific question.
Fifty bucks, that's on the expensive side. Does someone know if it is worth it? What's the audience? I'm half-way through "Learn You Some Erlang", would I get something out of it?
I agree in principle, but in this site's case: http://howistart.org/static/posts.rss I found the feed by viewing the page info in Firefox and picking the Feeds tab.
Yea, I hate when sites do that too. And even worse, I hate it but I did it myself :(. I'll get the date put in the page somewhere. Sorry about that.
Na, Fred is the author, I just run howistart.org. He has a new chapter for 18.0 and the time changes that'll be published soon.
Here you go! http://learnyousomeerlang.com/time
&gt; A clock on a plane goes faster than a clock on the ground I'm pretty sure that's other way around. Assuming that you, as an observer, are standing on the ground.
Extremely well written. Thanks.
It's a mesh network, so the overhead of cross-VM communication is larger for all nodes for each node you add to the cluster. As far as I know, the limitation seems to be around 60-100 nodes or so. If your nodes don't need to communicate, then do you really need to cluster? Supposedly, new versions of Erlang will start to allow different non-mesh topologies, which should make this story a lot better.
Should start with a solving a more logical design problem: 1) do I need distribution? If so what do I get out of it? Are there other ways you can achieve those benefits? Maybe you share state for example. Maybe you don't need node-to-node conversation per se, but instead some explicit inter-application service and protocol. This may yield other benefits too such as enabling other applications to interop with your application. 2) if I do distribute, do I need all nodes to be aware of all others. Can I partition the problem? e.g. smaller clusters of nodes. Erlang clustering is a good approach but it is not the only tool in the toolbox, and it comes with usual caveats of "good engineering required - understand the risks".
What sort of information is being shared between VM's? If its very small messages, then it should be fine. Look at WhatsApp. But if its large pieces of data, then there will be issues.
By default Erlang cluster runs in all-connected-to-all manner, and adding new nodes soon blows up connection count and heartbeat traffic can exceed hundreds of megabits O(N²). There are fairly standard ways to limit this behaviour by starting hidden nodes, and working out messaging in semi-manual mode (by naming each node in each send message operation). This will bring idle traffic to a minimum. Then type of data you send matters, any sort of large blobs will have chance to clog the connection to such extent that heartbeat won't reach other side in time, and timeouts will occur, eventually marking nodes as offline. Solution: Don't send large data over Erlang distribution, raise second TCP connection to carry the data.
thx a million
Yours is a good question. Distributed Erlang was created when it was assumed that your system would run in a safe environment behind a firewall, scaling to a few dozen fully connected nodes. Nodes can be added and removed dynamically to the cluster, and communication among them can be completely transparent. There are two approaches to implementing your architecture using distributed Erlang. You either have a static cluster not provisioned to scale, or you have a dynamic cluster where nodes can added or removed during runtime. In both cases, your system needs to be implemented with transitive connections in mind, as nodes come and go in a controlled way in your dynamic system, and your network connectivity or the nodes themselves can fail (and restart) in either cluster type. Scalability of fully connected Erlang systems scales to about 50-100 nodes depending on your usage patterns, hardware and requirements. Upon adding a new node to the cluster, all visible (non hidden) nodes who share the secret cookie get told about it, connections are set up and monitoring kicks in. So with 100 nodes, you get 5050 TCP/IP connections (100+99+...+2+1) and heart beats, creating overhead in both the node and the network. Other single process bottlenecks such as rex, which handles RPC calls, or the net kernel, whose responsibility is to coordinate operations in distributed Erlang. How far you are able to scale your fully meshed distributed Erlang cluster will depend on the characteristics of your system. The issue is not with Erlang, but with the overheads and tradeoffs you are willing to accept to have a completely transparent and fully connected system. No other language not built on the Erlang VM has built in distribution offering this level of transparency. Beyond 50-100 nodes, you need to reduce the number of fully connected nodes using hidden nodes, sharding or through frameworks such as Riak Core and SD Erlang. Or go down the AMQP, ZeroMQ or other service bus. These are generic scalability patterns which apply to all programming languages, Erlang being no exception. The reason you hear people rave about Erlang and distributed systems is because of asynchronous message passing (Which is the only way to scale distibuted systems), built in distribution and dedicated (asynchronous) error channels across nodes, and location transparency of the processes. This means that scaling becomes much easier and flexible, as a program written for a single node can easily be distributed to a cluster or nodes. But going beyond that cluster, the patterns I spoke of are needed. I hope this helps. I have about 30 pages (and counting) on this in my upcoming book. I hope the chapter will soon be available as early access. 
Yes I think the same. 50euros for an ebook of 250pages is not worth it. 
Thanks, will do.
We have an extremely similar use-case. We've had a few iterations. Initially we used `cpg`, then `global` and now `pg2`. Most of our connections are extremely long-lived, they occasionally die, but are near-immediately replaced. We also have occasional influxes of huge reconnections when we bounce a node. `cpg` under load performs *extremely* poor if you want a single namespace. `Cpg` has a raging boner over the fact it uses a trie as it's mapping mechanism so you can do things like "/foo/bar/*" and get all the pids under bar. In practice we never, ever needed this and it was just pre-emptive optimizations. Cpg also seems to take *forever* to heal once this situation has triggered. Mailboxes would just grow and grow and grow, even once the load was reduced. I believe timeout messages were filling up the boxes. We replaced it before we could get to the bottom of it. I'd seriously avoid the use of `cpg` unless you need that weird trie shit. `global` was pretty good for a while, but we had similar problems under load and huge numbers of concurrent connections caused problems. It did recover better than `cpg`, though. We had registration attempts take 100s+ under load which is verifiably awful. `pg2` is where we are at now. Under load it performs incredibly well, since each registration name is essentially it's own process, so large volumes of connections don't overload it. You have to manage multiple registrations under the same name, but that's relatively easy to deal with.
Thank you for your input. What about process monitoring? In my tests, pg2 performed relatively badly in removing dead pids.
This is rarely a problem for us actually, we don't need the immediate cleanup of a process and if the process dies, a process representing the connection will be re-registered within 20s or so. When the connection is queried again, it will find multiple connections for that device id and then we remove the stale ones. `pg2:get_members/2` returns the list in oldest-&gt;newest, so you can easily clean up/ignore old connections without needing to wait for the internal machinery to do it for you.
Thank you. If by any chance you end up giving Syn a try let me know, even if it is to demolish it. ^^_
Try these http://www.erlang.org/course/exercises.html
already done most of those :)
Exercism.io ?
will check it out :)
thanks will check it out :D
rebar3 purposely ignores versions and does not care about semver. This because people don't follow semver properly or because majority of packages in hex aren't even 1.0.0 yet, so semver means nothing.
I agree about deployments.
Project Euler 
You can look for Akka assignments as well, I'm sure you can find one that you can implement in erlang.
Do you want to help us with any of the open issues in elvis (https://github.com/inaka/elvis/issues) or sumo_db (https://github.com/inaka/sumo_db/issues) or any of our open source projects (http://inaka.github.io)? Or you might want to play RPSLS (https://github.com/inaka/rpsls) or gold_fever (https://github.com/inaka/gold_fever)
create/register user, or uploading package or something. I can't even goto the address in any firefox or chrome. I mailed you a bugreport a couple a days ago, but guess you havn't seen it.
will do when I get better at erlang :)
seems intressting :) did some in C# and Java
Nice. Very informative.
Cowboy! Give it a go https://github.com/ninenines/cowboy
oke, are there any good tutorials how to make a web app with it. 
inets and ssl are started, and the same exact request works just fine in firefox http requester- using the url from IO.puts before making the httpc request. I'm sending the requests to external servers, but I got the idea that it was adding "/" because when I sent a request to google.com, I get a message saying The requested resource "/" could not be found instead of just a useless 404 error. 
Slides about the library are available at http://www.slideshare.net/cmmdevries/erlang-meetup-gascheduler.
How are you trying to access your site? 
You got similar comments in #erlang IRC last night. Your IP {0.0.0.0} is not valid Erlang syntax, use {0, 0, 0, 0} Check if it started with `netstat -lnp`
I do not see it on the output. I put all the output in a earlier respons
because you are not actually saving/outputting it anywhere? do as suggested, if you don't want to actually follow advice, why even bother asking the question? &gt; cowboy:start_http(my_http_listener, 100, [{ip,{0.0.0.0}},{port,8088}], &gt; [{env, [{dispatch, Dispatch}]}] &gt; ), that returns {ok, Pid} when it was started successfully, but you never check for it. {ok, _} = cowboy:start_http (if it was not obvious). it was also noted again that your ip is not valid, try changing it already. edit: you are also calling your application cowboy, which might/will clash...
I did changed everything to this : -module(cowboy_app). -behaviour(application). -export([start/2]). -export([stop/1]). start(_Type, _Args) -&gt; Dispatch = cowboy_router:compile([ {'_', [{"/", hello_handler, []}]} ]), cowboy:start_http(my_http_listener, 100, [{ip,{0,0,0,0}},{port,8088}], [{env, [{dispatch, Dispatch}]}] ), hello_erlang_sup:start_link() {ok, _} = cowboy:start_http. stop(_State) -&gt; ok. And I do not see any error message. and I do listen to advise. I output by this command : ./_rel/cowboy_release/bin/cowboy_release console IM trying to follow the getting started tutorial of cowboy on the github page Roelof 
oke, changed also the ip to 0.0.0.0 and still no error messages. I think we misunderstood each other on what schould be done. 
fwiw the {ip, {0,0,0,0}} form worked fine for me. Also it's the default. I think you are having other issues. Try reading more examples from the cowboy source.
I did not call my application cowboy. That name is given when I did make make -f erlang.mk bootstrap bootstrap-rel and the {ok,_} = cowboy:start_http is given by yourself
because I did not feel like typing out the full line? are you serious? you name the application cowboy because the folder you did those commands in is called cowboy, you could easily find that all out by yourself (check your app.src file). honestly, take a step back, learn erlang, then look at cowboy.
You could use the 'when' guard for is_integer, etc. see [link](http://elixir-lang.org/crash-course.html#identifying-functions) in the second erlang block. Edit: and [this](http://learnyousomeerlang.com/types-or-lack-thereof) (section "To Guard a Data Type") to the checks.
http://www.erlang.org/doc/man/erlang.html#is_integer-1 http://www.erlang.org/doc/man/erlang.html#is_float-1
&gt; Those three tenants are one of the primary reasons that Erlang can be a soft-real time system Or you could just use any of the real-time GCs out there. 
Real-time GC in parallel systems is not trivial, it is bad enough on single core. You do really want to avoid sharing data.
&gt; Real-time GC in parallel systems is not trivial Sure but it is a solved problem. &gt; it is bad enough on single core [Baker's Treadmill](http://www.memorymanagement.org/glossary/t.html#term-treadmill) is a very simple real-time GC for single core. &gt; You do really want to avoid sharing data. Depends what you're doing. Not sharing data on multicores is cache unfriendly and kills performance. If you're doing parallel programming for multicores then you often need shared mutable data. 
Ok first of all 'cat' is an atom and "cat" is a string (which is list of integers in erlang). So single quotes and double quotes has totally different meaning in erlang. In the first function what you are saying is if animal is string "cat" return string "meow" else if animal is atom 'dog' return string "bark" So there is a type inconsistency on that function you probably want to except Animal argument either as string or atom but not both. If you load your module on repl and paste the output here, we can tell you the specific problems. 
After I posted this last night, I figured out my discomfort with my approach. The thing that is messing up the smoothness here is that string:to_float/1 and string:to_integer/1 return a magic value, causing a piece of data to mean more than exactly one thing. Alternatively, one can look at it like we are trying to pattern match on NOT the magic value. The two functions return in our cases: {error, Reason} % error and reason {Number, Rest_of_String} % success! That's pretty difficult to handle as types in easy-to-read pattern matching. It would be better if the response was this: {error, Reason} % error and reason {ok, {Number, Rest_of_String}} % success and result So a somewhat less awkward solution would be to wrap functions around the two io conversion functions to return the prettier values, and then use of those new functions to simplify the pattern matching. Much nicer and without my hacky _String inclusion. Possibly more readable/logical. If I have time, I may even post that solution for personal redemption. 
I used a single case to help me convert the two negative/non-error situations into a more useful series of explicitly-described pattern situations. I also decided to use the {ok, Value} and {error, Reason, Args} form in order to allow a client of my code the same courtesy. I added Args to help with propagation since Reason is very likely to be a plain string. -module(checker). -export([ get_length_from_string/1, test_get_length_from_string/0 ]). error_check(Fun, Args) -&gt; case apply(Fun, Args) of {error, Reason} -&gt; {error, Reason, Args}; NonError -&gt; {ok, NonError} end. string_to_float(String) -&gt; error_check(fun string:to_float/1, [String]). string_to_integer(String) -&gt; error_check(fun string:to_integer/1, [String]). get_length_from_string({ok, {Number, _RestOfString}}) -&gt; {ok, Number}; get_length_from_string({error, no_float, [String]}) -&gt; get_length_from_string(string_to_integer(String)); get_length_from_string({error, Reason, [String]}) -&gt; {error, Reason, [String]}; get_length_from_string(String) -&gt; get_length_from_string(string_to_float(String)). test_get_length_from_string() -&gt; {ok, 3} = get_length_from_string("3\n"), {ok, 5.4} = get_length_from_string("5.4\n"), {error, _, _} = get_length_from_string("asd\n"), done_testing. Thank you for the practice. :)
Fascinating to know that some people are thinking about applying stronger typing to Erlang and BEAM-based languages. I've since discovered that someone has created a [Idris to Erlang compiler](https://github.com/lenary/idris-erlang). Neat stuff.
Little Schemer is the best place to learn recursion. The book itself uses Scheme, but the concepts are applicable in any functional programming language
just a random guess, if you built form source did you enable sasl? I seem to recall issues with sasl causing similar errors. 
There's also [dh_date](https://github.com/daleharvey/dh_date)
I use kerl to manage Erlang installations. Those kind of messages often mean that my paths are messed up. Check $ERL_LIBS and $PATH. I use Linux but this particular bug is probably not platform specific.
Good question. I'm curious as well.
For a larger reach, check https://erlangcentral.org/forums/
A few things I'll throw out here - how are you running this and checking the output? If it's a matter of hitting ctrl+c after a while, I'm wondering if it's dying without the print statements getting to execute. As a test, what if you added this: loop(Socket,1000) -&gt; ok; That will then return after 1000 packets, and which point should close the socket and exit. I'd be very interested in whether this improves things. 
Read learnyousomeerlang.com online
Thanks, what I miss there after a quick look are exercises so I can practice things myself. That why I look now at the programming book.
Try these two books read the book [Introducing Erlang](http://shop.oreilly.com/product/0636920025818.do) and do the exercises in [Études for Erlang](http://chimera.labs.oreilly.com/books/1234000000726)
Hello, You meanr with this two books Programming Erlang and Introducing Erlang or learnyousomeerlang and Introducing Erlang ? 
wierd, According to Armstrong book it schould do this : 1&gt; c(afile_server). {ok,afile_server} 2&gt; c(afile_client). {ok,afile_client} 3&gt; FileServer = afile_server:start("."). &lt;0.43.0&gt; 4&gt; afile_client:get_file(FileServer,"missing"). {error,enoent} 
Thanks, I think that was a stupid rookie error. 
To see if I understand things I added some functions. So my server code looks like this : -module(afile_server). -export([start/1, loop/1]). start(Dir) -&gt; spawn(afile_server, loop, [Dir]). loop(Dir) -&gt; receive {Client, list_dir} -&gt; Client ! { self(), file:list_dir(Dir)} ; {Client, {get_file, File}} -&gt; Full = filename:join(Dir, File), Client ! { self(), file:read_file(Full)} ; {Client, {put_file, File, Content}} -&gt; Full = filename:join(Dir, File), Client ! { self(), file:write_file(Full, Content)}; {Client, {search_file, File}} -&gt; Client ! { self(), file:path_eval(Dir, File)} end, loop(Dir). and my client looks like this: -module(afile_client). -export([ls/1, get_file/2, put_file/3, search_file/2]). ls(Server) -&gt; Server ! {self(), list_dir}, receive {Server, FileList} -&gt; FileList end. get_file(Server, File) -&gt; Server ! { self(), {get_file, File}}, receive {Server, Content} -&gt; Content end. % added as solution to exercise 4 of chapter 2 put_file(Server, File, Contents) -&gt; Server ! { self(), {put_file, File, Contents}}, receive {Server, Status} -&gt; Status end. % added as my own try so I can check if I understand things well search_file(Server, File) -&gt; Server ! { self(), {search_file, File}}, receive {Server, Status} -&gt; Status end. but when I do afile_client:search_file(FileServer,"test.txt" ). I see this output {error,badarg} Can anyone give me a hint where I going the wrong road. 
Since you just want a hint, I'll point out that just executing file:path_eval(".", "test.txt") also returns {error, badarg}.
If you read the documentation to file:path_eval/2, you'll see that the type of the first argument is supposed to be a list of strings (directories, in particular), not just a single string. Try file:path_eval(["."], "test.txt").
A few things that come to mind: Gather input recursively, and pass in the new value from x - y. Use a gen_server to handle state... maybe overkill. (http://learnyousomeerlang.com/clients-and-servers)
Thanks, Can you give me a example what you mean by the first comment (Gather input recursiverly) I tried it this way but that do not work: amount(withdraw, Amount, Total_amount) -&gt; io.write("The total amount was ~s", [Total Amount]), io.write("Withdraw ~s", [Amount] io. write("New total amount ~s, [Total_amount - Amount] 
There are many similarities in how Joe Armstrong teaches the basics.
I really want to learn more about docker, but I find myself always de-prioritizing it over just building more features and sticking with Heroku for my Elixir and Ruby applications. I've bookmarked this and will hopefully come back to it soon. Would there be any issues with installing things like ImageMagick on top of Alpine Linux? edit: I see there's a package for it here: https://pkgs.alpinelinux.org/package/main/x86/imagemagick
There are a number of libraries to handle JSON parsing, e.g. https://github.com/talentdeficit/jsx You can validate using a JSON Schema implementation like https://github.com/klarna/jesse
*\"* is a character escape sequence. Used to include quotation marks in strings, like: &gt; Advice = "You should learn to \"google\" more before just asking". More on that subject: http://stackoverflow.com/questions/13130681/what-is-the-difference-between-and-in-erlang
Can Jiffy also work without a OTP project , so in a sequantial programm. 
one day, eep 18 will be approved! http://www.erlang.org/eeps/
I'm a bit hungover and have not *really* understood the code, but.. you shouldn't raise errors or match all cases like in bf(_, _, _) -&gt; let Erlang crash, don't match a case if it is not part of the program's main flow. Also, I think you could match the case-clauses in cellValue and performAction directly in the function definition like performAction(CellNo, &lt;&lt;Left:CellNo/binary, P/integer, Right/binary&gt;&gt;, F) -&gt; Keep up the good work, always fun with more Erlang developers!
Such definition was the thing i tried to achieve, but the program did not build with a header like that. It's because CellNo wasn't bound. The note about letting Erlang crash is really interesting, I thought it's a good practice too handle errors. Could you say anything more about it? Is it connected with the there's-no-error-free-program erlang approach?
Now go write an Erlang interpreter in Brainfuck!
I'm successfully using jiffy:decode(Message, [return_maps]). Also I've recently started a "deeper" project for manipulating deep data structures in Erlang (https://github.com/trin-cz/deeper). 
I get that League of Legends is a big MMO with lots of players, but given that: * This only refers to the chat service (what about the actual gaming services?) * This is Erlang we're talking about.. I'm surprised to see that many servers thrown at the problem *in every region*. And these are bare metal, high end boxes. [This MongooseIM document](http://www.erlang-factory.com/upload/presentations/775/EFSanFrancisco2013-MongooseIM.pdf) refers to 400,000 simultaneous users on much more limited EC2 instances. Is LoL even bigger than I thought?
Well, you're article really got me hooked, whatever that's worth :)
that's worth a lot ... keeps me motivated. Thanks :)
\#3 is absolutely my experience too and the refusal to admit to it is why Elixir saw explosive growth. It's an Erlang where you're not an idiot for wanting to learn.
Ruby requires ruby to compile. That whole process is super ill documented. At least, Ruby developers, as in the developers of Ruby, kind of suck.
Quickly? It's a whole separate language. Jumping between scripting languages is trivial. Jumping back into Erlang after a few months, is a trial. At least, for myself and the few other developers I have personally paired with.
"Prototypical classing in Erlang"??? Say whaaa?? I think you have your paradigms and/or languages confused (are you thinking of JavaScript?), and I frankly don't think this is Erlang's fault.
Erlang does not have classes at all, so I'm not sure what you mean by "prototypical classing".
Nope, that's where I'm stuck. I was hoping OP or others would.
Can you show some code?
I tried also from a file with this code : -module(my_map). -export([from_json/1]). from_json(Filename) -&gt; Content = file:read_file(Filename). so I see this example output : {ok,&lt;&lt;"{\n \"first\": \"John\",\n \"last\": \"Doe\",\n \"age\": 39,\n \"sex\": \"M\",\n \"salary\": 70000,\n \"registered\": true\n};\n\n"&gt;&gt;} but no binary to map conversion bif :( Roelof
oke, then I think in this case I have to make a predicate where a key has a particular value. Wierd exercises on the map section of the programming erlang book. What is the reason to test if a key is smaller then its value 
My #2 and #3 were intentionally snarky. Honestly, I couldn't tell if the author was saying that "imperative" is synonymous with "popular" (I hope not), or if he was saying that popular languages tend to be imperative. Same with recursion. Sure, it's how you implement linear looping in Erlang, but as you point out, it's also used for nonlinear looping as well. Programmers use made up language all the time - every identifier in our programs, every design pattern, every technology acronym is a new term that we have to know and understand. I can understand that not everybody has been exposed to the words "imperative" and "functional". I'll even accept that they might not be the best choices ("effectful" and "pure" might be better). But I think the author does a disservice to his peers by suggesting that they can't keep "imperative" and "functional" straight.
I gave the full exercise in my initial question.
sorry, I read to quick :)
Thanks there is a lot of viewing in these i shall go through them now and let you know how i get on thanks again
Please do come back and tell us what you learned :)
&gt; now better alternative to Yaws He addresses that in the comments, claims Yaws is more standards compliant. Doesn't make any sense. 
OTP is the more powerful yet poorly documented part Thank you for posting this
well sombody downvoted it ! I guess this one is not up to the mark.
Not only it works. It is easy to hack it in anyway you want for your particular project.
https://github.com/talentdeficit/jsx just use jsx 
The descriptions for write_concurrency &amp; read_concurrency in the article aren't accurate. They are performance tuning options not behaviour altering options (ie. being unable to be read/write by multiple process). &gt; Note that this option [write_concurrency] does not change any guarantees about atomicy and isolation. The article states that you must enable it to have multiple writers. 
You are right. I have updated the post to reflect the same.
 count(List) -&gt; UpdateFun = fun (Item, Dict) -&gt; dict:update_counter(Item, 1, Dict) end, dict:to_list(lists:foldl(UpdateFun, dict:new(), List)). Output: 1&gt; t:count([1,2,1]). [{1,2},{2,1}] See [update_counter/3](http://www.erlang.org/doc/man/dict.html#update_counter-3) from `dict` module.
http://learnyousomeerlang.com/ just read that. 
Agreed. I also had the O'Reilly book but I read both anyway depending on what was most convenient for me.
the docs get updated with the changes, the blog post does not. Additionally erlang.mk is not (yet) stable, and the way you get it always pulls the latest version instead of a specific tag, hence the guide is useless if you don't even mention the version it works for.
Do you recommend rebar3 for a new project? What is your experience with it, comparing to rebar?
If you want to write a working real world networked server the best book is _Erlang and OTP in Action_. https://www.manning.com/books/erlang-and-otp-in-action
I certainly recommend it, disclaimer I am one of the developers :). For information on what makes it different from rebar: * http://www.rebar3.org/docs/from-rebar-2x-to-rebar3 * http://blog.erlware.org/rebar3-features-part-1-local-install-and-upgrade/ * http://blog.erlware.org/rebar3-features-part-2-dependency-tree/ * http://blog.erlware.org/rebar3-features-part-3-overrides/ * http://blog.erlware.org/rebar3-features-part-4-profiles/ * http://blog.erlware.org/rebar3-features-part-5-dependency-branch-handling/ * http://blog.erlware.org/rebar3-features-part-6-_checkouts-2/ * http://blog.erlware.org/rebar3-auto-comile-and-load-plugin/ * http://blog.erlware.org/rebar3-hex-plugin/ 
I haven't used rebar, and I've only used rebar3, but it works well for me. It seems a lot more polished than the Makefile. For example, [NIFs](http://erlang.mk/guide/ch08.html)?
Thanks for the links :)
I think it's great Erlang finally has a real bug tracker. But I would like to make some suggestions: 1. The bug tracker should be HTTPS, not HTTP. It needs to be SSL/TLS encrypted if people have to log in and enter passwords. 2. The Erlang homepage has sections for news, community, links, etc. but nowhere is there an obvious link to this bug tracker. If community support is encouraged, then the bug tracker needs a prominent section on the Erlang homepage itself. (I assume this was planned, but it's not there currently.)
One the benchmarks you are referring to, you tend to see Erlang also show up 10-100 times faster than Ruby, despite the fact many of the world's largest websites are successfully running Ruby on Rails. 
Go is terrible at concurrency, but i've been told can scale somewhat decently. Go would NOT, from my research so far, be a good solution given that it'd need to concurrently handle over a quarter million connections at one time without bottle-necking.
Also, I'd like to point out that you said "that is an ambitious project" instead of "that's too large for one person, you should get more help from people you know or move on". I can't tell you how many times I've been told that what I'm doing is "too large and complex for one person to do in a reliable amount of time", and yet I've already done the research enough to get about 80% of my questions answered/resolved. The last ~20% seems will be trial and error actually working on it :). Thanks!
You're welcome. I encourage big thinking and ambitious goals. Someone's got the make the big achievements, right? Might as well be you. The worst that will happen is that it won't work, but you'll still come out ahead with better knowledge. I hope you're successful, because lessons you learn and questions you ask are not only helpful to you, but possibly even the entire community. Besides, we're talking about *programming* here. The primary purpose of all computing is to *automate*. You don't require a dozen other people if you know how to automate effectively enough for your problem domain. Whenever I hear discouraging advice from other programmers, usually that's more a reflection of their psychological attitudes towards their own shortcomings, the shortcomings of their favorite tools (or the only ones they are willing to learn), or fears of obsolescence or loss of job security. I agree with you, I can't remember how many times I wanted to do something useful (but uncommon) and because someone else's favorite language sucks at solving the problem, their response is not "try this other tool or technique or paradigm", it's instead "well why would you want to do *that*?" Keep raising the bar. Don't let others force you to lower it to their comfort zone.
Try this: &lt;&lt;(bit_size(term_to_binary(Term))):4, (term_to_binary(Term))/binary&gt;&gt;.
&gt; &lt;&lt;(bit_size(term_to_binary(Term))):4, (term_to_binary(Term))/binary&gt;&gt;. that worked. Still I do not understand the ( error message. 
Another related problem. I have now convert the packet back. So I did this : packet_to_term(Packet) -&gt; &lt;&lt; _:4, Term/binary&gt;&gt; = Packet. but as soon as I do this : my_binary:packet_to_term(&lt;&lt;8,54,64,0,103,38,246,86,198.246,6:4&gt;&gt;). I see a bad argument error. 
Value:Size/TypeSpecifierList When constructing binaries, Value and Size can be any Erlang expression. However, for syntactical reasons, both Value and Size must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. http://erlang.org/doc/programming_examples/bit_syntax.html
Makes no sense. Do you mean "no match"? Oh I see... Whats with the dot? 198.246,6:4
Thanks all. Problem solved
Thanks, problem solved
Something like this: get_module_names(Tuples) -&gt; lists:foldl(fun({Name,_},Acc)-&gt; [Name|Acc] end,[],Tuples). %Same function but preserves the order get_module_names2(Tuples) -&gt; lists:foldl(fun({Name,_},Acc)-&gt; Acc ++ [Name] end,[],Tuples). %Same function but a fold from the right (also preserves the order) get_module_names3(Tuples) -&gt; lists:foldr(fun({Name,_},Acc)-&gt; [Name|Acc] end,[],Tuples).
Well, it may be done with fold, but fold is not the appropriate operation in your case. A fold is used to accumulate a value over a whole list, where you want to map a list of tuples to a list of values. You need to use `map`. TupleList = [{a, 9}, {b, 2}], lists:map(fun({A, _}) -&gt; A end, TupleList). You can think of `map` as a function, that takes a function and a list, and applies this function to all elements of the list. Where `fold` is a function, that takes a (binary) function, a default-value and a list, and applies the binary function to the elements in the list successiveley. When no element in the list are left, the last function call is applied with the default-value. For example, you have a list: [A, B, C], a function f(X,Y), and an initial accumulator-value: 0. foldl applies f to each elements of the list successiveley: 0. [A, B, C] 1. f(0, A), [B, C] 2. f(f(0, A), B), [C] 3. f(f(f(0, A), B), C), [] The most simple example is the sum: lists:foldl(fun(A, B) -&gt; A+B end, 0, [1,2,3,4,5,6,7]). Apply `A + B` to all elements successiveley, until the list is empty. 
You are on the right track. While the books discuss writing functions like this so you understand what's going on, in general, it's better to use the functions in the standard library like map and foldl instead of writing your own. It is less error prone and the intent is clearer to the reader. 
Yes, indeed, this is a possible usecase of `fold`. It is particularly strong in combination with `map`. All the modern key-value stores like riak, mongodb and couchdb work with this functionality, it is called map/reduce. You can think of the `reduce`-part as a fold-operation (it is slightly more complicated than this, but it catches the essence).
I like [list comprehensions](http://www.erlang.org/doc/programming_examples/list_comprehensions.html) for stuff like this: get_module_names(ModuleList) -&gt; [Name || {Name, _} &lt;- ModuleList].
Thanks all. I solved it this way : -module(my_module). -export([most_exported/0]). most_exported() -&gt; All_data = code:all_loaded(), ModuleList = lists:map(fun({Name, _}) -&gt; Name end, All_data), FunctionList = lists:map(fun (Name) -&gt; {Name, Name:module_info(exports)} end, ModuleList ), List_most = find_most(FunctionList, {test,0}), print_most_exported(List_most). find_most ([], Tuple) -&gt; Tuple; find_most([{Modulename,Item2} | Rest], Tuple) -&gt; if length(Item2) &gt; element(2, Tuple) -&gt; find_most(Rest, {Modulename, length(Item2)}); length(Item2) &lt; element(2, Tuple) -&gt; find_most(Rest, Tuple) end. print_most_exported(List_most) -&gt; io:format("The module ~p has the most exported functions nl ~p. ~n", [element(1,List_most), element(2, List_most)]). 
oke, I think the list comprehension looks better then the fold one. Im also looking if I can make one function of the find_most and most_function like I said in a earlier respons. 
I have this data-structure and I want to count the second entries Data-structure [ {modulename, [functions] } Can this be done with a fold or a list-comprehension. 
That's what the fun passed to foldl does: fun({Module, ExportedFunctions}, {CurrentModule, N}) when length(ExportedFunctions) &gt; N -&gt; {Module, length(ExportedFunctions)}; ({_Module, _ExportedFunctions}, Acc) -&gt; Acc end See http://www.erlang.org/doc/man/lists.html#foldl-3 If you just want to replace your find_most with a more compact version you could use matching or a case block. Matching version: find_most([], Acc) -&gt; Acc; find_most([{Module, Functions} | Tail], {_, N}) when length(Functions) &gt; N -&gt; find_most(Tail, {Module, length(Functions)}; find_most([_ | Tail], Acc) -&gt; find_most(Tail, Acc). Case version: find_most([], Acc) -&gt; Acc; find_most([{Module, Functions} | Tail], Acc = {_, N}) -&gt; NewAcc = case length(Functions) of M when M &gt; N -&gt; {Module, M}; _ -&gt; Acc end, find_most(Tail, NewAcc). 
You're not printing a message… just returning the atom **test_worked**. To print a message you need *io:format*. You're running the tests with *-noshell* (which is correct) but you're not stopping your VM (which you can get by adding *-s init stop* at the end of your command line).
eleven nines! The more the merrier. ;)
If you want to use make with Erlang, look at http://erlang.mk/ http://stratus3d.com/blog/2015/02/04/erlang-project-setup-with-erlang-dot-mk/ On the other hand, I have switched to using Elixir's mix build tool for a large complex Erlang project and it has made me very happy. http://featurebranch.com/using-mix-to-compile-your-erlang-projects/ http://kelly-mclaughlin.com/blog/2014/12/12/building-an-erlang-project-with-mix/ https://github.com/alco/mix-erlang-tasks 
I'm using erlang (and elixir) to manage single threaded C++ processes that do heavy computations. BEAM is used as a message passing interface that also manages the lifetime of the C++ processes. IPC is done through stdio (it's overhead is negligible in for purposes).
Christ... you might want to put the kool-aid down for a second.
Concurrency in C++ *really* isn't that hard. That deadlock scenario you're describing is trivial to accomplish in Erlang too. And sometimes, you actually do want shared memory as opposed to messaging. Personally, I have used Erlang professionally, shipped it, and have learned a lot from it, but found myself drifting away because it isn't general purpose enough.
Yeah..and the lack of mutexes and such in erlang isn't really an advantage, it means you have one less option for concurrency. Although it's nice to be forced to do it in a safe way (message passing), it's often possible to optimize by sharing data (mutexes) instead of copying it. 
Well, you do have the ETS, but it's not the same. Still, I think Erlang is great for what it tries to do, but it's not something where you can start doing low level optimisations, if that's a requirement, maybe take the lessons from Erlang and apply them to your C code, that's what NASA ends up doing and they make some of the best software in the world.
ETS returns a copy of the data when you fetch it, though. That's what you can avoid using mutexes (and other concurrency primitives).
I've been thinking of using a similar architecture for an algorithmic trading platform. Use erlang as the glue and use Rust for number crunching. Are you happy with using this kind of architecture? Any downsides to it? What message format do you use for IPC?
you can put them in a different module, sure. erlang doesn't know or care what the underlying filesystem was.
This looks interesting! Can't wait to check it out when I get to a computer. What sort of visual component is there to this? You should add a screenshot to the readme if there is one :)
Any chance of posting some pictures or a demo video? 
So I am starting an article series for getting properly started with erlang. This first part explains how to start from scratch, with rebar and erlang, how to set everything up and have a solid basis to continue creating an application with erlang. The series will continue with further information about using different parts of erlang libraries to make a full features web application.
I THINK there is a chapter in Joe Armstrongs Erlang book, can check it out tonight when I am home. BUT: check this out: http://stackoverflow.com/questions/1795628/erlang-compilation-erlang-as-stand-alone-executeable
no remotely easy way to do this i'm afraid.. distributing as an all-in-one package (for any platform) isn't hard though, use relx, or even better: "rebar3 release", and deploy the resulting _build/..../rel directory.
There are very old compilers that produce binaries, but they're long out of touch with the language. Generally we use something like `rebar3` or `erlang.mk` to produce an archive which contains start scripts, the VM, and the modules as binaries. This is probably my single biggest problem with the language. If you actually need this, the least painful available mechanism is to compile to Gambit Scheme, which can in turn be compiled or rendered to C.
Here we go, I found the chapter, and it was about escript (http://www.erlang.org/doc/man/escript.html). Maybe this is enough for your needs? Otherwise it would be easiest to include a simple .sh (linux) file or a .bat (windows) file that starts your application conveniently.
Yes, it have a lot of improvements. Also all active development happens there.
Yes. rebar3 is the successor to rebar. Because of how large the change set would be we went with a new name and repo but will eventually be 'rebar' again. rebar2 will continue to get bug fixes.
Thanks, will definitely give it a try
Thanks...i thought i should start with a presentation on erlang to the group, any recommendations on a presentation that covers the basics of the language?
It depends a lot on your target audience. I gave a presentation to the local functional programming users group, which is relatively academic and Haskell oriented. I looked around on the net for presentations, and ended up hacking something together myself. Here it is if it would be helpful:http://www.cogini.com/share/erlang-functional.pdf I mostly just talked to it, though. Here is one I found when preparing: http://cdn.oreillystatic.com/en/assets/1/event/27/Erlang%20for%20Five%20Nines_%20A%20non%20technical%20introduction%20to%20Erlang%20Presentation.pdf 
Yes, we hired some erlang consultants but eventually our team has to take over and/or supplement their code. Besides that I'm fascinated with the language and want to learn it myself. It's a good team building exercise, everyone is jazzed up about it....it's no often you get paid to learn a new skill.
You can start with the Erlang Master Classes from the University of Kent: http://www.cs.kent.ac.uk/ErlangMasterClasses/
Programme: http://www.erlang-factory.com/berlin2015/#speakers
I use json (UTF-8) as message format for maximum compatibility (easy (de)serialization in elixir). The only downside I experienced so far is maintaining different codebases, and the depencency version management that goes with it. So a good build system is a must. (Elixir's mix does a great job)
What we did was switch to Elixir, i.e. build our Erlang app with mix, which was worth it all by itself. http://featurebranch.com/using-mix-to-compile-your-erlang-projects/ http://kelly-mclaughlin.com/blog/2014/12/12/building-an-erlang-project-with-mix/ https://github.com/alco/mix-erlang-tasks After that, adding the Elixir web framework Phoenix is easy. 
what do you mean by secure? if you just expose an erlang server via cowboy/webmachine it should be secure, depending on what you mean by it.
there are many strategies to implement authentication from cookies, jwt, oauth to more custom ones, regarding authorization you have even more flexibility. All of them can be done on erlang so it shouldn't be a problem.
"secure" is a language-agnostic property of computing. Using erlang will not mean you're any more secure than using python. REST is language-agnostic. I've done REST backends in many languages and the frontends were done by people I'd never met and I have no idea what language they decided to use. The web services spat out formatted-text (in JSON, XML, or CSV) and the front-end ingested it. It doesn't matter what the languages are on either end, as long as they agree on what goes in and what comes out. 
Prepend takes constant time. Reverse takes linear time. Append takes linear time. Thus N prepends plus 1 reverse gives you O(N) a.k.a. linear time. N appends gives you O(N^2) a.k.a. quadratic time. When N is thousands or millions it makes a big difference.
Makes sense. Thank you.
Here's a good explanation: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
Just wanted to point out. Longer does **not** mean more verbose.
Less ways to shoot yourself in a foot, probably.
Depends on whether you like your syntax to be Prologish or Rubyish. If the former, you're better served by Erlang. If the latter, you're better served by Elixir. If you prefer your syntax to be Lispish, on the third hand, you should try Lisp-Flavored Erlang. Beyond this, there isn't *really* a significant advantage to using Erlang over Elixir (aside from not having to rely on both Erlang *and* Elixir as dependencies for your project, and aside from it having a more mature ecosystem). In fact, there are numerous disadvantages; Elixir has a lot more features (proper string handling, a pipeline operator, less restrictions on how same-arity multiple-dispatch functions are specified, etc.) that give Elixir a rather substantial edge. Plus, some of Erlang's surface advantages (like the more mature ecosystem, particularly of third-party libraries) are easily ported over to Elixir (and vice versa; with some finagling, the rapidly-growing collection of Hex packages are - for the most part - readily usable with Erlang), though not without some considerations (notably when it comes to string handling).
Based on the law of leaky abstractions, you will end up needing to learn Erlang anyway at some point, same as a Clojure programmer needs to know Java. Erlang syntax has its quirks, but it's not really complex. There are a lot of good books on Erlang, particularly when you get into big system deployment. A lot of the Erlang system tools work just as well with Elixir, but there are still some that do not, e.g. http://www.cs.kent.ac.uk/projects/wrangler/Wrangler/Home.html I think you are fine to get started with Elixir first, then at some point you can start reading the Erlang books. I find it really exciting how Elixir is defining high level abstractions for things like stream based processing, but the downside is that, and we can expect that there will be changes in the syntax of the language and in the libraries. Ericsson has millions of lines of Erlang in production, and backwards compatibility is a priority. On the other hand, Erlang is evolving too (e.g. maps), and there is a certain amount of churn there too. 
Simlper syntax. Immutable variables make code more explicit. VM and base VM ecosystem is Erlang-first. More learning resources available. Different syntax ( not a joke ) -- different syntax encourages a different mode of thinking, because at the end of the day it is not really "like ruby", so syntactic semblance is confusing.
It's hard to predict the trends of the job market. Learn something useful, that enables you to solve hard problems with less effort, and you will be fine. Erlang surely fits this category :)
&gt; Should i learn Erlang? Yes. At the very least, knowing at least basic Erlang will give you an appreciation for functional programming techniques, and will help with understanding more modern languages in Erlang's sphere of influence (like Elixir and LFE). &gt; Are People building new things with eralng nowadays ? (for real) I'm pretty sure Heroku and Github use quite a bit of Erlang, as just a couple of examples. I might be misremembering, however.
[`(lisp (flavoured (erlang)))`](http://lfe.io/)
http://lfe.io/
Joe Armstrong's thesis is a good read. Also, you could look into Elixer if you want a more Ruby-like syntax.
the initial cost of learning a language is not too significant &amp; by the time you've gotten the basics down, you should have an idea as to whether or not you want to pursue it further. for me, the answer to "should i learn this language" is always yes. 
Okay, I will be somewhat contrarian. You should not learn Erlang now, but you will get there eventually. Spend a weekend with a quick intro guide to ruby and a "Build your web site in 24 hours with Rails" book of some variety. Build the site in rails. Play with it for a week. Now burn the ruby and rails books and walk away. Go get Programming Elixir and Programming Phoenix and start learning Elixir. Rebuild the rails site using the Phoenix framework. Beneath it all you are using the same VM and eventually you will probably find yourself diving in and out of Erlang to do specific things. You could also go all-Erlang with something like ChicagoBoss, but Elixir has captured a lot of former Ruby devs who are banging out Phoenix/Plug modules like there is no tomorrow and I think at the moment the available docs and explanatory blog articles favors Elixir and makes the learning curve a bit easier. For your long-term career you should have a scripting language like Python or Ruby, .NET lang, a JVM lang (Clojure or Scala IMHO), Javascript or something that compiles to Javascript, and something interesting like the Erlang ecosystem or a step deeper into functional with something like Haskel, Lisp, or Scheme. Think of something you want to build or play with and then match it up to one of these groups to narrow down what particular coding muscle that project will stretch.
Just start with Elixir. No need to pollute the idioms beforehand. Especially if you are professionally doing C# in which case you'll understand the MVC model well enough to skip straight to Phoenix without a confusing Rails detour.
[removed]
What is "FreeVariable"? Did you add something to the hello.erl I posted? 
Can you elaborate on the environment in which you did this? What does the directory structure look like? If I run erl in the same directory as erlint.erl, and hello.erl is in the src directory under that one, I get the same failure as before: 1&gt; c(erlint). {ok,erlint} 2&gt; erlint:lint("src/hello.erl"). {error,[{"src/hello.erl", [{2,erl_lint,{undefined_function,{hello_world,0}}}]}], []}
 -module(hello). -export([hello_world/0]). hello_world() -&gt; FreeVariable = free, io:fwrite("hello, world~n"). 
It seems that there is something broken in your env. I [replicated](https://gist.github.com/anonymous/5f2fe684cdf94d86f2f4) whole thing in empty directory just fine. P.S. I'm running Erlang which was build without HiPE. Not really sure if it makes any difference.
Good to know I'm not the only one that's thought of that pun, hahaha.
I guess I need to figure out what's wrong with my environment, then?
Probably. I suggest using [kerl](https://github.com/yrashk/kerl) for building and installing Erlang.
figured it out. lack of a trailing newline in hello.erl is the culprit.
http://bugs.erlang.org/browse/ERL-60
Lookup term "One True Pairing" and fanfic "clash" genre. Additional "research": South Park episode "Tweek x Craig".
Actually no! Elixir does sit in top of Erlang as the Elixir compiler generates Erlang which is then compiled by the Erlang compiler. It also sits on top of OTP which is implemented in Erlang, even if Elixir has its own interface modules to many of the more commonly used parts. This is not a bad thing! It is in fact a good thing as OTP, together with Erlang, is one of the reasons why you come to the Erlang eco-system at all. Trying to separate the BEAM from Erlang is impossible as the BEAM was specifically designed to run Erlang, nothing else. The two are locked together. If you look at what the BEAM can do you will see that it does exactly what is needed for Erlang, no more no less.
Ah--learn something new every day. I always thought that Elixir generated BEAM bytecode. Didn't know that it actually generates Erlang code. Thanks for straightening me out on that point. 
Most facts are true. But this article also contains many implications and assessments, these should be trusted with caution. Note that Java and Erlang have different purposes. IMHO author abuses obvious statements with negative shade, like "the Erlang VM does not provide zero-copy messaging".
Well, for one thing, Erlang has maps now. Records are still there, but maps are replacing them more and more every day. And 'query' is no longer a reserved word.
Yes, obviously, the bits about Java are irrelevant and separate heaps are the major feature of Erlang, also I'm aware that HiPE was never more than just some enthusiast endeavor .. And the syntax is of course .. well .. syntax. But I meant other things like being incapable of scaling past 16 CPUs, the allocator/GC itself being lackluster/limited, Strings having some weird (and slow/wasteful?) implementation as lists, ETS/Mnesia being some crucial but "weird"(?) part, Ericsson being disinterested in the language,.. 
I'm new to Erlang, but not programming, and I feel like these types of articles are popular for every language.
The article is outdated. Ulf Wiger has mentioned that recent versions of the Erlang VM have no problem scaling past 30 to 40 cores or so. He cautions that real scalability depends on your problem and your design, because logically some things are inherently sequential (bottlenecks) depending on the problem. (But in that case, it's not an Erlang problem, because then it's impossible for any language to eliminate *inherent* sequential logic, so it can't be done better.) A lot of work on the relationship between schedulers and heaps and GC has been done in the past several years. Dirty schedulers were added. Clock/timer bottlenecks and correction issues were addressed. A gazillion small improvements were made that are too numerous to explain here. You'd have to look at release notes. Also, the article was obviously biased from experiences with other languages, such as the claim that immutability is unnecessary (revealing the author's preferred style of mutable-state programming such as OOP and the Java platform). He actually says immutability in Erlang isn't necessary for "Erlang-style concurrency". In Erlang. I think he has a confused idea of what "Erlang-style concurrency" means. There's more to practical fault-tolerant soft-realtime systems than just the Actor model, but he insists on that strawman so that Java/Azul can play in the same field. He also invokes another strawman by comparing HiPE to JIT, when HiPE was never meant to be JIT, it was always meant to be a native-compiler. The author basically doesn't know what he's talking about with a lot of points. He argues against separate heaps and points to "optimizations" possible with a shared heap (i.e. in other words, please make Erlang more like Azul and Java), and claims that GC is so fast with Azul. With Erlang, when you have many tiny processes and you're done with that process, you don't do traditional copying GC ("optimized" or otherwise), you simply free the memory. Nothing is possibly faster than that. If instead you are doing GC because you are NOT killing a process and so it's still running, analysis for GC is extremely simple due to immutability, which is a guarantee you can't have data in an older generation pointing to data in a younger generation. In any case, a tiny process with a small heap ensures quick GC because there's not much to look at. I suspect the author is griping because he doesn't know how to use Erlang properly: if he sticks to his Java habits, he's likely writing large monolithic processes rather than understanding how to take advantage of many small concurrent ones. If he does that, then Erlang's GC *is* going to be slow because it's not "optimized" to handle one big process rather than doing small and quick GC on many small processes. But that's his fault for writing Java in Erlang and then complaining that it doesn't act like an optimized Java VM. The only semi-valid points regarded maps and strings. Maps as a native type are now added in recent versions. Strings don't exist as a native type, and unfortunately OTP libraries still assume lists of integers. This is an API problem, not an Erlang VM problem. Languages built on top of the Erlang VM such as Elixir have standardized on Unicode binaries as strings, whereas this must be done explicitly with Erlang and its Unicode libraries. If you want anecdotal evidence, then look at WhatsApp and Pinterest. Pinterest moved away from Java towards Elixir (a new language built on the Erlang VM) and now only needs half the servers for the same job and one tenth the code. WhatsApp has at least 450 million users supported by only 32 engineers for their system written in Erlang. But that should be impossible right? Since it's not as "optimized" as Azul and Java...
&gt; I'm aware that HiPE was never more than just some enthusiast endeavor .. Why do you say that? [HiPE]( https://www.it.uu.se/research/group/hipe/) was a seven year long university research project with multiple people involved, papers published and industry sponsors, with Ericsson among others.
..which all boils down to it being an enthusiast project. It's not about how much effort went into it or of what quality the result is. It's about how viable it is for production use. The alternative to "enthusiast project" would be a product that's either officially supported (e.g. something like Oracles HotSpot JVM in the Java world) or at lease widely used across the community (e.g. something like Google's Dalvik VM in the Java world), of which HiPE is neither as far as I can tell. As it stands HiPE is a stale implementation of an outdated version of the language. Or am I wrong here?
Why is HiPE then not the default?
I don't understand all the record hatred. I like them a lot. I can change a field name and the compiler will tell me what code I have to update. Can maps give me that? I am fine with typing Record#rectype (manually specifying the record type) because this brings me the benefit of having the compiler spot my errors. What's so terrible about records?
It's down for me too, but it's up for [this checking tool](http://downforeveryoneorjustme.com/erlang.org).
Hmm. I'm pretty sure that OTP have been improved in this area since 2009. Also consider that different OS implementations, as the author writes, may have different results. I would like to see this experiment again with OTP R18 and Ubuntu 15, Windows Late and Mac Late. 
eight nines :(
Personally, I'd spawn a set of communication processes with the listen socket which then block on accept/1 (since that's where the client connection will end up, avoid bouncing it around all over the place and just have it there). There is a decent example of this pattern in LYSE: http://learnyousomeerlang.com/buckets-of-sockets#sockserv-revisited Also .. gen_server:call -&gt; I find that makes it just a lot harder to read the end code and exposes a lot of details. Instead, why not sth like this in server: start_game(ServerPid, CommunicationPid) -&gt; gen_server:call(ServerPid, { start_game, From }. then instead of: gen_server:call(Server, {start_game, From}); one writes: server:start_game(Server, From); This encapsulates the details of the message passed ({ start_game, PID }), making it easier to change in future if needed, and makes it pretty easy to find where in your code you are using this API (imagine you have another module which also takes a { start_game, Something } message!) Keeping all the games in a list in the main server state is unikely to scale nicely over time (think 100,000 games ..) If this is going to be a single player game (per game process) then why bother tracking them? Just spawn those processes! :) If one game will end up having multiple client connections, and those connections will be matched up with the game by that random string (invite/join type functionality) then you probably want something that can do that look up in constant time and not cause your server to fall over because it has a ton of games going causing it to run out of memory (which is limited per-process) .. perhaps an ETS table? In whch case you don't need to keep track of them in the main server anymore, and could move all that code into the game module itself ... one less process barrier to cross with a message! .. some things that leaped out at my as I read through the blog entry :) 
Wow, thanks a lot for your comment. You are right, abstracting away the function calls is clearer on the developer, and easier in the future. I will definitely make sure to change that in the next article. About the scalability with a lot of games, I have yet to decide whether I want to have one game for all players (as in one MMOG) or have multiple games. If the case would emerge, that I might end up with 100k+ games then, as stated in the article, I would get back to that code and see how to change that. But right now I assume not more than 10 games per server, so scaling should not be an issue for now. Just tried to stay easy and not optimize prematurely. But you are right, it is something to consider, and there are ways to improve my code. Thanks a lot for your feedback.
To me, the kickers are: - records are (at least) hard to copy&amp;paste to the console (much like macros) - sharing records between modules is hard (It shouldn't be needed, I grant you that) - Turning records into json is harder than turning maps into json - Printing out records requires trickery or you loose the field names - Not two versions of the same record can coexist (and sometimes I do want such a thing to happen)
Thanks a bunch! Yeah, I probably shouldn't be developing a server on Windows, but I don't have a VM set up and I'm using Unity3D, so it hasn't been super convenient to use a Linux distro. It'll probably come back to bite me later I'm sure &gt;_&lt;
I take it you've already read over the [relevant documentation](http://www.erlang.org/doc/man/odbc.html)?
How would I include one of these libraries in my application? I am trying -include, but even if it finds the file it tells me the functions are undefined. That is, ODBC is part of the package, but external libraries don't appear to be working for episcina or the mysql one I found, and I haven't been able to find any information on what my issue may be. Edit: I was hoping to use this: https://erlangcentral.org/wiki/index.php?title=MySQL_client_(driver) if it's any good, it looked simple enough to use.
chicken and egg I guess, people don't use it because people don't use it. But I think the trend is changing with elixir since elixir adopters tend to be early adopters they don't care who is using it, then you create a small group of outspoken people that use it and serve as a justification for why you can use it too "X, Y and Z are using it". Time will tell if elixir adoption will "spill" to Erlang the language or just will mean erlang the platform adoption via elixir.
Could it be, that elixir will be replace erlang?
Microservices is a buzzword. When one is obsessed by making their project use microservices it's so easy to create an unmanageable mess. One can't really design a good microservice architecture without first being bitten by a monolith of the same app - then comes understanding what goes into each service. And when it comes to implementation, Erlang is a nice tool that is able to do it. Elixir is a nice variation of the same tool. Like a hammer with slightly different head shape and handle color. Both can smash. Pick one.
I think it depends on programmer. The documentation is really important and how microservices communicate with each other.
One more question, it is possible in erlang to communicate with other language. For example, google creates grpc that I can make remote function call from Golang to Java. Now I want to exchange data between a Golang and Erlang application, it this possible? 
Hm, I know that ErlPort works for Erlang and Python/Ruby.
yes, there are many ways to do it, I'm working on a erlang &lt;-&gt; rust bridge, still in it's infancy since I'm learning rust but it already communicates in both ways: https://github.com/marianoguerra/erl_interface.rs
I don't thing so, but given it's current adoption trend it may be a big player in the platform.
new binary syntax, should be same length as erlang, see IPv4 packet pattern matching here: https://github.com/efene/efene/blob/master/examples/all.fn#L109 PS: yes, your comment motivated the syntax change :)
Well, another big advantage is that you can do massively concurrent processing in erlang. For a server that means you can model a request/session as a process and the parallel execution is managed by the VM. I think this is a big advantage.
Thanks again for your feedback, I have written a followup article about your points, and would love your opinion on it: http://joekinley.org/adventures-in-erlang-code-conventions/
I assume one can not do that without elixir.
Probably fit the reason this has been at the top of my reddit feed for 2 weeks... Not enough people care about erlang
Wow. I was like, "no one would ever make this joke." But you did.
Can you post the actual code? This doesn't really make any sense...
On my mobile so I will do as soon as I get to my laptop
Have it up there now thanks
When I scanned my reddit feed, at first glance I thought this was about star wars :-)
ha ha what type of logic are those first order guys using anyway
Any theorem that can be input, here is an example solution by hand http://imgur.com/nnAaXrb I'm at the stage where i have my clauses now its the resolution tree, so i take in 2 clauses into produce clauses this should return an empty list if all literals cancel or a combined list of literals that don't cancel, exactly like the diagram my produce_clauses is nearly working the only thing that is missing is if I enter in [{a,b}],[!a,!b] it returns [!a,a] this wont be too hard to fix but then after this i have to apply the resolution tree, I am stuck here! _________________________________________________________________ I have been told for example if you have 3 lists of clauses say [a],[b],[c] these contain any amount of literals of {prop,X} or {negate,{prop,X}}, I run produce_clauses on all combinations and append to the end of the list so i after first run through I will have: [a],[b],[c],[a+b],[a+c],[b+c] minus the opposite literals __________________________________________________________________ second run through: [a],[b],[c],[a+b],[a+c],[b+c],[a+a+b],[a+a+c],[a+b+c],[b+a+c],[b+b+c],[c+a+b],[c+a+c]. If at anytime during this i get an empty list its a contradiction and my theorem is good, if it runs forever its not a valid argument, this however I find difficult to believe is the solution 
&gt; has at least a dozen frameworks that enable it That's part of a problem and why I dislike Java so much. Too many choices. When it's fully integrated and part of the platform I get a better feeling about using it.
Well, any (or most) web severs can be used for REST APIs - so long as the server responds to HTTP requests, you can design a RESTful API that uses it. There's not really a best - just pick one. Apache and Nginx are the most popular, if you care about that, but other than that, I'd just pick one. It's a bit like choosing a language to learn.
[Cowboy](http://ninenines.eu/docs/en/cowboy/1.0/guide/) and, in particular [cowboy_rest](http://ninenines.eu/docs/en/cowboy/1.0/guide/rest_flowcharts/), is what we use the most at [Inaka](http://inaka.net) and we're happy with it. You might want to take a look at [sumo_rest](https://github.com/inaka/sumo_rest) as well, if you're looking for something a little bit more advanced than just a RESTful API.
it's probably wrong to hijack this.. but i would love a very brief overview of contemporary building alternatives/best practises.. really a million mile high overview.. as a newb I'm a bit confused
Which redirects back to https://www.erlang-solutions.com/blog/how-to-analyse-a-beam-core-dump.html?utm_source=Reddit&amp;utm_medium=redditeerlang&amp;utm_campaign=BlogBeamCore. I'm more than happy to see companies share their work and experiences with the broader community. So long as that isn't overt sales and marketing. This I think is overt sales and marketing as there is no reason to not share the direct link to the article instead of redirecting through a tracker.
That was me (Andra, marketing person at Erlang Solutions) Pardot is our marketing automation system, I use it to track where hits are coming from to the blog. It doesn't reveal any info about who clicks on the links, but it shows me how the blog is performing. It indirectly justifies my efforts in spreading the blog and gives us hints about the quality of the blog - if it's high, we let the authors know they should keep 'em coming :) 
See this: http://ninenines.eu/docs/en/cowboy/HEAD/guide/ws_handlers/ and this: http://ninenines.eu/docs/en/cowboy/1.0/manual/cowboy_websocket_handler/
Don't use them. I believe support has been dropped for them as a first class language feature, although it's supported by a parse transform. I rarely, if ever, see them being used. Edit: reference for the parse transform, and removal. https://github.com/erlang/pmod_transform
Tuple modules are officially supported. Here's the [official OTP Technical Board announcement about removing parameterized modules](http://webcache.googleusercontent.com/search?q=cache:rRx2BRNMQTUJ:www.erlang.org/news/35+&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=us), and it mentions on-going tuple module support (note this is a link to a cached copy, as it appears someone unfortunately broke the original link). See specifically issue 4 in the text.
Although they're still supported, I would not use tuple modules. You don't really see them used anywhere, which in itself damages readability, and it makes it more difficult to read the code in general. It reduces transparency as to what the code is doing. You don't want to be one of the few people using a feature. That you're consistently having such difficulty finding if there is official support or not should indicate that regardless, the community support just isn't there. What's the problem you're trying to solve that you feel these would be the solution to?
Thanks! This is exactly what I was looking for.
&gt; You don't want to be one of the few people using a feature. Totally agree. &gt; That you're consistently having such difficulty finding if there is official support or not should indicate that regardless, the community support just isn't there. This sounds reasonable. Community support is essential in such situations. &gt; What's the problem you're trying to solve that you feel these would be the solution to? Actually... none. I've spotted this feature in [this article](http://jonathanmh.com/accessing-structs-in-elixir/) and was trying to decrypt error message about module `:ok` being unavailable.
I still don't understand why you need a separate process and socket for each user when you already have a connection opened and handled for you by cowboy. You can receive any action the user sends over the websocket. But, in general, yes, it is better to associate the user with the pid of the process managing the user's state.
Meh. Pick your tool based on your problem, bit the other way around.
Related, also by an Erlang programmer: http://prog21.dadgum.com/156.html
OO sucks because you're not using Smalltalk. Functional also sucks if the only "functional" code you've ever seen is some PHP.
I intuitively think you are right about Smalltalk. Could you please answer the points identified in the article and explain how they are irrelevant in Smalltalk?
See platform_define in rebar.config for add erlang compile options or pre_hooks for run export USE_JSX=true
We want to use automated testing and continuous integration. As long as I can use those clients in an eunit, I'll give them a look. Thanks. 
IMO, ct(Common Test)-based integration tests fits better in your case.
That's what my research is suggesting too. EUnit is the default erlang testing framework for IntelliJ Idea so I was hoping there was a way. Thanks!
without also sandboxing the dependencies this is a lot less useful.
Thought kerl had already solved this... 
I've been using erln8 with joy: http://metadave.github.io/erln8/
^this
I asked Fred Hebert about them 'tuple calls' some time ago, basically why does this work: D = dict:store( one, 1, dict:new() ). D:to_list(). ...and he replied: &gt; This is entirely a remainder of parametrized modules, which required that 'tuple calls' were to be kept in the language when they were deprecated and moved to a parse transform. See http://www.erlang.org/news/35 for details. They should most likely be avoided. 
I'd be interested to see an up-to-date version of this, rather than something from 2012.
This and its follow-ons are a good introduction: https://www.youtube.com/watch?v=gKRyAb7d8lo Kent is in the process fo doing an Erlang MOOC; if you liked the above, you'll probably like that as well.
There's an "update" paragraph at the end that clarifies some things that were overlooked in the original article (like Erlang process isolation and the use of OTP). Not sure when that update was added.
IIRC they added preemption to long running go routines, though can't remember where I read that.
Those are kind of huge things to neglect to mention in a discussion about Erlang At least he mentioned it in an update.
- Erlang [philosophy](https://www.youtube.com/watch?v=ed7A7r6DBsM) by one of the creators of the language - Oldie but goldie: Erlang the Movie [part 1](https://www.youtube.com/watch?v=xrIjfIjssLE), [part 2](https://www.youtube.com/watch?v=rRbY3TMUcgQ) - free video [intro class](https://www.cs.kent.ac.uk/ErlangMasterClasses/#class1) from an IRL university. There are three of these (scroll up a tiny bit to "Master Class" 2 &amp; 3). - Not a video, but very easy to follow [primer](http://www.erlang.org/course). Useful as a second explanation if you can't understand a specific concept in the above courses. Good luck! EDIT: forgot about this [interactive intro](http://www.tryerlang.org/)
Found the source, this was changed [in Go 1.2](https://golang.org/doc/go1.2#preemption) &gt; The scheduler is invoked occasionally upon entry to a function. Checking the changelog overviews of later releases, the only chances to scheduling were in 1.5 and irrelevant to the yielding of tasks (GOMAXPROCS defaults to the number of cores on the system, and the scheduling order of queued tasks changed)
They appear to be legitimately available at http://www.bestechvideos.com/tag/erlang-in-practice
Interestingly, prolog (which erlang was inflicted by) has red and green cuts to indicate interruptions in the unification tree search.
I always recommend those to people if they can find them. Probably one of the best set of screencasts/tutorials ever. 
Cast as in throw and forget, no reply is expected
As in "cast away" (I always assumed) WILSOOOOOOON! 
[removed]
If you need it to be human readable, I'm not sure you can without writing the transformation yourself. If you don't need it to be human readable you could: base64:encode_to_string(term_to_binary(Term)). If you wanted it as an ascii binary instead of a list/"string" use encode/1 instead.
What's your implementation? 
I mean, I know it can be done using a list. I'm just curious as to whether there are performance reasons for using one or the other.
You have not said why python is not a good choice any more. Go and Erlang are far _far_ inferior choices for the applications you have in mind. If you must move away from Python , have you considered Julia (julialang.org) ? It has native compilation, typing, economy of expression, distributed computing etc. 
You are right, python is good for almost everything, but, I think it is not a good choice for me because it is not built-in concurrency as go and erlang. On the other, why are erlang and go far far inferior? do you know a performance benchmark?
Dialyzer and type specs haven't always existed, so you'll see older code make heavier use of guards.
As in "He cast the ring into the fires of Mordor". You just sort of throw them at each other in an asycn way. Like email
Blog is dead. Code is here https://github.com/erszcz/docsh
Type specs are informational- they aren't used by the compiler or the runtime. Guards are a common idiom for actually enforcing type at runtime and the cost is negligible.
One bit I found out after some digging: The AXD 301 used multiple CPU's, one of which was a RISC UltraSPARC 2i (or it was at least the target platform for some builds), which should have had about the same computing performance as a Cortex A7.
With a little tail recursion, I would think.
we are using it for a mobile push notification system (like APNS or GCM), scalability and fault tolerance are very important.
See also [the full list of 150+ available API docsets](https://kapeli.com/dash#docsets), courtesy of [Dash for OS X](https://kapeli.com/dash).
Yes! Sounds like a good next step. Thanks
That was surprisingly easy to do. Thanks again
:D excellent!
Go with mnesia. It gives you small time to market right now. And if you are using it only to manage logins - you will not have any scaling problems. You might though encounter a trouble with dets (used to store stuff on disk by mnesia). dets is very fragile and has long recovery time. If you want to use some other DB - go with PostgreSQL. IMHO best FLOSS DB available. 
I would recommend you to take a look at [sumo_db](http://github.com/inaka/sumo_db). It has a backend for mnesia that lets you abstract all the db management logic so that you can easily switch to an external db later on in your development cycles.
Slightly off topic, but I would recommend giving HanoiDB (https://github.com/krestenkrab/hanoidb) a go. Back on topic, little bit more context (any error message) would help us deduce the problem and answer your question.
If it doesn't have to be LevelDB (which is really not that great) you're probably better off with Facebook's [RocksDB](http://rocksdb.org/) via [erocksdb](https://github.com/leo-project/erocksdb). It has much better performance and compaction, not to mention transactions. 
Thanks, I'm taking a look. Might you know something similar or another binding where one can use `term()` as keys instead of `binary()` ? (Even if it has lower performance).
Great! that really helps me, I wonder why the standard encoding do not work like that, anyway, thanks!
The reason I did need to store directly terms instead of binaries is because I'd need to keep the same ordering as they had as term. But user @gleberp just comment me there's a library to serialize while keeping the same order, [sext]( https://github.com/uwiger/sext); so now I don't need it no more :) .
Brilliant collection
Chandru is a great guy. Worked with him back at One2One. We were building with Erlang then :-)
How is HanoiDB these days? Anyone put it into prod yet?
Can you please add a Changelog of some sort?
X-Post referenced from /r/meetups by /u/InakaESI [Last Year Meetups at Inaka](https://www.reddit.com/r/Meetups/comments/4aozgu/last_year_meetups_at_inaka/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
You may want that because it ties game handling logic crashes with handling the connection. Before you get your Let It Crash kool-aid out, go stand in the corner. You *may* want to isolate your connection process from handling anything directly and allow yourself to continue serving processes while any other code is ran elsewhere, without contorting your connection process code with handling numerous error conditions. Anyway, there's a million and one ways to do it but I can definitely see the draw to have some separation between your connection process and other stuff.
Depending on load you can use pg2 to register connection processes and then use this grouping as the game lobby and easily send messages to all pids registered in this "game lobby" group.
Oh oh let me guess, some sockets and child spawning involved?
Any idea on roughly how long it takes for a registration to propagate to every node, or any rules of thumb that you use? I have a couple use cases in mind for this, but there is a possibility of two registration requests triggered in somewhat quick succession.
I don't think "change" is the right way to put it. The interop is near seamless so if you're comfortable with one, there's not a whole lot of reason to switch to the other. It seems like nowadays it's a good idea to know both because there's many libraries coming out written in one or the other. Personally, I started off learning Erlang and then once I got the hang of it I learned some Elixir. I tend to stick to Elixir because I like the more modern syntax, but I could fall back to pure Erlang. There's now also [LFE](https://github.com/rvirding/lfe) in the fray of BEAM languages, if you want to go the lispy route. 
I thought Phoenix would have me moving, but I found it too complex. I prefer simple solution of few hand crafted lines of erlang to full stack frameworks. However, I would rather go Elixir instead of Scala, Node, JS, Clojure or any other regular more-or-less-hype langage/framework. 
We switched a big Erlang application to build with mix. rebar3 might be better now, but mix was and is great. For pure HTTP apps, cowboy is ok, but just having Plug is nice because it defines a standard mechanism of dealing with requests. I think that Elixir gives benefits over Erlang. It has all the power of Erlang, but with cleaner syntax and nice things like macros and protocols. We are switching all our general web development to Phoenix, from Python and Rails. 
I started with Elixir. After I was comfortable with Elixir I started with Erlang because it seems valuable to better understand the whole system. I continue to use Elixir for my own projects, but I find knowing Erlang to be useful.
No, I dont see any benefit, except a cleaner syntax. Once you learn erlang, switching to elixir is not really needed I think. Alas, if you don't know erlang or the beam-vm, you should consider learning elixir, especially if you have a ruby background.
And if no any ruby background? I find syntax from elixir is much cleaner then erlang.
I read an earlier edition of Programming Erlang before LYSEFGG existed, and I thought it was pretty good. The advantage of LYSEFGG is that you can read it online for free. You could start reading, see how you like it, and maybe buy a physical copy if it works for you.
They're both great books. I got most of my learnings from LYSE though. I bought a deadtree copy to have around, but all the info in it (and more, actually) is on the website. Nice way to get started for free and it's a gentle intro to the language and functional programming in general. 
I recommend this one, _very_ easy to consume overview of OTP which also covers the finer details: https://www.manning.com/books/erlang-and-otp-in-action LYSEFGG is also a great place to start.
Mainly because I like Common Lisp. I don't like Elixir, it's a matter of syntax; while I enjoy Erlang, I don't really like ruby style. What part of Erlang syntax do you consider horrible? I too consider Ruby/Perl syntax horrible, so I guess it's a matter of personal preference.
My route so far, which I recommend: I started out with the OTP in Action book (by the way, the "in action" books are _GREAT_ and I highly recommend them all) but found that I got rather quickly overwhelmed with the content after a certain point; So I'm currently working my way through Joe Armstrong's "Programming Erlang" 2nd ed. The pace is good, and it's definitely challenging, but I highly recommend it. I did look at LYSEFGG but it's a tad dated now (with little coverage of maps, rebar, etc) and while it covers the core language well, the two books above take you into actually making some applications you can play with. For instance, I'm implementing a fileserver at the moment which I'm actually using :}
Not all of the in action books are great imo. I bought about $1000+ of manning books mostly on scala and data science stuff. OTP is pretty advance imo to be a book to start learning Erlang. I think LYSEFGG is much better. OTP is more of the next book you should read. 
What happens if you run it from cmd instead of cygwin ?
Nope. Closest you can get is a behaviour. 
"Programming Erlang, 2nd ed". After gently rubbing in, apply "Designing for Scalability with Erlang/OTP" (which is, in my opinion, the very best intermediate&amp;advanced level book on the market as of today.) There's also "Erlang and OTP in Action" somewhere in between the two. You might also substitute "Programming Erlang" with "Erlang Programming" by Cesarini&amp;Thompson or LYSE. If all of the three are too complicated (I doubt), you may lay some foundation with "Introducing Erlang". So: * "Introducing Erlang" with accompanying exercises "Etudes for Erlang" * "Programming Erlang, 2nd ed" / "Erlang Programming" / LYSE * "Erlang and OTP in Action" * "Designing for Scalability with Erlang/OTP"
So, cast has very little to do with the type of result you want. Rather, cast and call have to do with a type of request your gen_server will receive and whether it should reply back. So you have to look at it a bit like this - when someone calls the API for my gen_server to do this functionality, does it have to be done right now or as we have time? Do I need to reply once I'm done? Based on that, you choose call, cast, or info. 
so if my session sends a gen_server:call to all players it waits on reply and a gen_server:cast will continue on with its work
More or less. In this case, the session server would call a function that would call gen_server:call for the player server. The player server would execute the function and send a reply when done. The session server would wait until the reply is received and handle that however. For a cast, the player server would get to it in order of messages received, while the session server would move on to the next thing. Is that what you meant or the other way around? Also, have you considered a finite state machine? It sounds like that might be a better fit. 
Oh, no, it's the way I described it then. If the session wants to make a request for the player and then update its records based on the response, then it needs to call some function in the API of the player server. That function then calls gen _server:call for the player server since the player is handling the request. The session server will just wait for the response from the API function - it doesn't know anything about call/cast/info. Since you want to record some info based on the players' response, I'd recommend using call in the interior of your API function. While FSMs can be a bit complicated, games can be well suited to them since there are a finite number of states and a limited number of actios that move you from one state to the next. 
Oh, let's back up. The session is a gen_server right? And so is each player? 
Right, ok, so for your player module, you should create an API that the other modules can use so they don't have to handle any of the specific aspects of a gen_server. That API will include a function that actually calls gen_server:call. Have you read Learn You Some Erlang? He has a good explanation of why you structure it this way. 
Pretty much, a simple list comprehension should do the trick. 
Actually, all the components for a "bigger" app are already in there. Things like ErlyDTL, WebSocket for example. Checkout LELA project under my repo for a RESTful server. I'll update the client codes using VueJS once I'm done. Thanks. 
I'd guess cowboy and or plug is what you need although I just read about them. Hope others can help more. 
Unfortunately I can't really help. With the fear of being down voted. What I would do is pick up elixir and Phoenix. It runs on erlang vm, has ruby like syntax and mix does help a ton on getting started. It's all compatible with erlang so you can get your feet wet and maybe even mix and match the two. 
My advice for you is to use Erlang as backend, what it's s good for, as a rest server, and use VueJS or EmberJS as the front end. I have posted my rest backend server on github under mhishami/lela Do have a look. 
hi i've added you on skype
&gt; This time, the new line crashes. In other words, due to implicit matching in Erlang, we not only need to worry about all the code after introducing a variable, but we also need to be mindful of all the code before introducing it, as any previous code can cause future variables to become implicit matches Wait, isn't that better? He's randomly throwing variable assignments/matching/rebinding into the code (let's sprinkle some assignments here, some there etc). Wouldn't loud runtime crashes be an an obvious benefit there. Hmm, maybe I am missing something but I don't get the "have to worry about the code before and after"... after they just randomly added a new variable. Yes, you'd have to inspect the local context and make sure the change makes sense, I couldn't call it "worry about it" like it is a bad thing. 
It is man.. very weird. I'm pretty sure that this is not your fault. Sadly I don't have a windows machine or I'd give it a test.
This feels like the most ideal combination of languages for their respective roles ever.
Large collection of everything Erlang: http://spawnedshelter.com/
I have to try build erlang using msys2+mingw. $git clone https://github.com/erlang/otp.git $cd otp $otp_build autoconf =&gt; ok $otp_build configure --prefix=c:/erlang --enable-hipe --enable-threads --enable-smp-support --without-javac --without-ssl --srcdir=c:/Z/RnD/otp//erts/ --includedir=c:/Z/RnD/otp/erts/emulator/sys/win32/ =&gt; ok $otp_build boot -a MAKE depend make[1]: Entering directory '/c/Z/RnD/otp/erts/emulator' MAKE generate make[2]: Entering directory '/c/Z/RnD/otp/erts/emulator' GEN i686-pc-msys/gen_git_version.mk CC obj/i686-pc-msys/opt/plain/hipe_mkliterals.o In file included from hipe/hipe_mkliterals.c:30:0: beam/sys.h:76:27: fatal error: erl_win_sys.h: No such file or directory\n compilation terminated. $find . -name "erl_win_sys.h" =&gt;./erts/emulator/sys/win32/erl_win_sys.h Regards!
There is a library called http://erlang.mk which does all the build stuff you could want. You don't have to write your own make files. I don't know the difference between make and emake. 
Does it (or will it) work nicely with [trails](https://github.com/inaka/cowboy-trails) and [swagger](https://github.com/inaka/cowboy-swagger)?
I'll check it out, thank you very much!
I use recon_trace from recon package: http://ferd.github.io/recon/recon_trace.html It offers rate limiting in case I end up tracing too much and lock up the node before a chance to stop it.
 Section 4.3 of Joe Armstrong's PhD dissertation may have the answer you are looking for. http://ftp.nsysu.edu.tw/FreeBSD/ports/distfiles/erlang/armstrong_thesis_2003.pdf
Some benchmarks are available here: http://www.ostinelli.net/an-evaluation-of-erlang-global-process-registries-meet-syn/
Excellent! I will check it out first thing tomorrow. &lt;3 ddg.gg
Ah okay cool. I'll change the title to reflect that! Cheers
Its main target is elixir, but you get an erlang layer for free with nerves-project.org
The BEAM can run on embedded Linux devices, like Raspberry Pi, Beagle Bone Black etc. But not microcontrollers like arduino. Microcontrollers are a different class of processor.
I'd seen nerves and it looks awesome.
osV looks awesome - thanks. 
I want even thinking of bare metal erlang - just compiling erlang in the same way you develop for the arduino.
What the hell is C# turning into anyways? It's like they are trying to cram every feature they can find. 
It just keeps getting better. Also, C# 6.0 didn't add too much. Mostly just some nice syntax.
You mean every language will eventually start reimplementing (or maybe we should skip the 're' part of that) [Algol 68](https://en.wikipedia.org/wiki/ALGOL_68#struct.2C_union_.26_.5B:.5D:_Structures.2C_unions_and_arrays) ;)
The phrase appears the top comment, seemingly by random.
I hadn't heard that before. Thanks.
LilyPad Arduino USB - ATmega32U4 Board http://sfe.io/p12049 It has a watchdog timer! 
BEAM is definitely not going to run on that. I've heard 100Mhz as a bare minimum, before. That's 16Mhz with 32KB of flash. Definitely in the microcontroller space.
i'm really trying but i'm struggling to see the difference
We have the largest IoT home-automation deployment in Latin America all built on Erlang. Servers in the cloud and devices in people's homes. ozom.com Best decision we've made and it's paying off big time. Gateways are running MIPS processors with OpenWRT and Erlang stack. 
I'm not suggesting beam - I wanted to know if anyone has build an Erlang compiler that targets hardware where the only process management is a watchdog timer. A better question would have been do any microcontrollers have libraries that allow them to send and/or receive messages from/to Erlang processes? (because Erlang without beam isn't really Erlang ) S 
This maybe? https://lumenosys.com/
What were you using a few years ago that didn't have the MMU? Do you have any controller you'd recommend to run Erlang on? I was thinking about using the rpi but I was hoping for something a bit more minimal.
yes it is
Interesting slides. Is there a video recording available of the talk they were used for?
Not that I know of; it's be really useful to understand those slides with screenshots of code and nothing else on them. If you find the link, post it here, I'd be interested too!
Check out the Erlang Master Classes https://www.cs.kent.ac.uk/ErlangMasterClasses/
Haha, these are great :-)
This should probably have linked to http://inaka.net/blog/2016/05/31/seven-development-heuristics/
The picture for the Bad Business Logic slide is priceless...
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/elixir] [Chocolatey Gallery | Rebar3 3.1.1 • x-Post From \/r\/erlang](https://np.reddit.com/r/elixir/comments/4m7bq4/chocolatey_gallery_rebar3_311_xpost_from_rerlang/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Hello all, Wrote about how I use markov chains to generate text. This covers generating the necessary data to start storing it in a database. I don't cover generating sentences. However, if you use the [this commmit](https://github.com/rnikoopour/Markov-lang/tree/6b3846768f5f8dbc309813e4ac17881ece12f563) it is an OTP compliant app that requires you to have a postgres db connection. If you use [this commit](https://github.com/rnikoopour/Markov-lang/tree/e9462c5c95787c4b078108a81191cc69509d02e0) you're able to just play around with it in the REPL and can use the generate sentence feature. My next blog post will cover the database portion. Please let me know what you think!
Riak Core? http://marianoguerra.github.io/little-riak-core-book/
Very useful! Thank you. Do you have more of that kind of books/articles? Building up a project while you go? Amazing.
Take a look at consul's need to know page. It introduces the concept of consensus - a cornerstone in distributed computing. https://www.consul.io/docs/internals/consensus.html For more info on the raft consensus algorithm check out this animated presentation. http://thesecretlivesofdata.com/raft/ Finally, the zeromq guide is a great intro to distributed computing issues. http://zguide.zeromq.org/page:all
Designing for Scalability with Erlang/OTP: http://shop.oreilly.com/product/0636920024149.do I bought it but haven't read it, yet, but I am looking forward to it. It's from two of my favorite authors. 
We use a pool. We found the connection to be very reliable, since it's on a local machine, but we added the pool to make sure that the connection is re-established in case of problems. We are using episcina as the queue. Here is some example code. We are setting up the pool manually in our app due to some other weirdness in our startup, but you could do it with a static config. Here is an example: % app config: % {redis,["localhost",6379,0]}, % {episcina_pools, % [{example, % [{size,10}, % {timeout,10000}, % {connect_provider, % {epgsql,connect, % ["localhost","example","sekrit", % [{database,"example"}]]}}, % {close_provider,{epgsql,close,[]}}]} {ok, [RedisHost, RedisPort, RedisDB]} = application:get_env(example, redis), epna_sup:start_pool(redis, erlang:system_info(schedulers_online), 5000, fun() -&gt; erlang:apply(eredis, start_link, [RedisHost, RedisPort, RedisDB]) end, fun(Connection) -&gt; erlang:apply(eredis, stop, [Connection]) end), {ok, Pools} = application:get_env(example, episcina_pools), episcina:start_pools(Pools); And here is how to use it: {ok, RedisClient} = episcina:get_connection(redis, 5000), Key = &lt;&lt; "campaign-", Campaign/binary, "-ip-", IP/binary&gt;&gt;, Count = case eredis:q(RedisClient, ["GET", Key]) of {ok, undefined} -&gt; 1; {ok, CurrentCount} -&gt; list_to_integer(binary_to_list(CurrentCount)) + 1 end, lager:info("Campaign ~s IP ~s count ~p (key ~s)", [Campaign, IP, Count, Key]), {ok, &lt;&lt;"OK"&gt;&gt;} = eredis:q(RedisClient, ["SET", Key, Count]), {ok, Expiry} = application:get_env(example, campaign_ip_expiry), {ok, _} = eredis:q(RedisClient, ["EXPIRE", Key, Expiry]), ok = episcina:return_connection(redis, RedisClient), 
Not techno but I'll let it pass. Its pretty dank
Would anyone like to port this plugin to rebar3?
Skall du tåla det där /u/plux?
&gt; Skall du tåla det där ja
VPNs are said to have performance issues because of "TCP over TCP".
&gt; Yes, normally you'd run your cluster within an adequately protected private network, for security as well as for latency. Measuring is king, but I would bet on encryption providing better latency than VPN.
What about my inter-code noms? What do people snack on while writing Erlang code?
Am I missing the obvious or does this have nothing to do with Erlang?..
I was at least hoping one of the free stickers was Erlang
The author stops just short of actually explaining the problem. As I understand it, the problem is that this: is_integer(X) and X &gt; 0 gets parsed as: (is_integer(X) and X) &gt; 0 because of the [rules of operator precedence](http://erlang.org/doc/reference_manual/expressions.html#id85024). Notice that `and` has relatively high precedence, whereas `andalso` has relatively low. So I suspect that the real problem is a type error, but that gets masked by the "no clause matching" error.
Wouldn't you typically use the comma operator for *and*?
I just use some hooks https://github.com/tsloughter/rebar3_run/blob/rust/rebar.config#L4-L5 Probably could use improvement to define all the hooks that are best to use, but not sure if a full plugin is necessary.
I made a similar switch recently, but since most of my tasks were small utility scripts in Python my transition was to .exs files. I had been working through various exercises to feel more comfortable with the language. http://adventofcode.com was the most useful. Suddenly things clicked and I felt confident that whenever I needed to write a script I could be as effective in Elixir as in Python. However, since Elixir handles asynchronous tasks much better, it has proven to be a better tool overall. 
I know that's the way C building is approached because a portable and general C plugin isn't practical, but it is for Rust. Rust does have some Erlang and platform specific issues that can't be solved with hooks so I think a plugin to deal with them is worthwhile. Someone has recently taken a swing at such a [plugin](https://github.com/sdwolf/rebar3_rust). And for those considering dabbling, please read [this](https://github.com/goertzenator/rust.mk/issues/3) first.
The over reliance on ORMs in the Python community really rubs me the wrong way, too.
Quite a trivial answer, but a google search gave me this link: http://stackoverflow.com/questions/32294367/erlang-process-vs-java-thread This does not specifically explain why Java could not do it, but give some hints. I am sure somebody here could give its own better answer.
I definitely might be missing something, but that page doesn't seem to answer my question. The main thing everybody on that page talks about is the fact that Java allows shared state between threads and Erlang doesn't. I get that, but I don't see why that would prevent Java VMs from implementing really-cheap-threads like Erlang has. 
The real trade-off for green threads is that you avoid OS scheduling costs (in Linux, threads are effectively processes with shared address space with their parent), but can stall your whole application if any single green thread blocks. Unless you're running on an embedded platform, the memory cost for your stack is probably tiny to your data/heap. As you mentioned above, erlang processes aren't quite the same as green threads in other languages. As most of your i/o is performed through sending messages, those provide natural yield points to schedule some other erlang process. The erlang scheduler is designed around managing the typical workloads under this model. Java used to have green threads by default (back in 1.1), but OS threads tend to be cheap with less annoying gotchas (blocking i/o). Also, Java has a number of different concurrency primatives ([futures](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html), [fork/join](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html), [event queues](https://lmax-exchange.github.io/disruptor/), [continuations](http://commons.apache.org/sandbox/commons-javaflow/)) which may match your workload more precisely than green threads. What sort of workload do you have in mind where you'd want to use green threads? Btw, thought I was in r/java...
I also found [this StackOverflow page](http://stackoverflow.com/questions/2708033/technically-why-are-processes-in-erlang-more-efficient-than-os-threads), which has lots of good stuff, but *still* doesn't really explain why Java couldn't (or wouldn't want to) do what Erlang does. (There's a little bit of vague hand-waving about OS processes being better for CPU-bound processing, but it didn't really sound hugely compelling to me.) 
About my own motivations in asking the question: there's a [discussion](https://www.reddit.com/r/Clojure/comments/4rp3ei/ring_160beta2_released_with_support_for_async/) on /r/Clojure (Clojure is a dialect of Lisp that runs on the JVM) where I was confused about why Clojure's built-in Promises don't support registering callbacks. (You can say "block the current thread until the value of this promise is available," but you can't say, "here's a callback, run it when the value of this promise is available.") Someone [rightly pointed out](https://www.reddit.com/r/Clojure/comments/4rp3ei/ring_160beta2_released_with_support_for_async/d53i77o) that registering a callback would also require specifying which thread the callback should be run on. Which is a totally valid point on the Java VM, but still it bugs me, because the obvious next thought is, "Why *can't* I just always create a whole new thread to run the callback? Erlang has really cheap threads, so why doesn't the JVM?" You say that OS threads tend to be cheap, but (again, please excuse my being naive) they're still not nearly cheap enough for us to just say, "Go ahead and start a new thread to run each callback function," are they? And as for how it's possible to stall your whole application if any single green thread blocks... is that a problem in Erlang? 
What I currently understand is: 1) Java choosed to rely on OS thread system. 2) The OS thread system cannot allocate small chunk of memory for threads Boths those 2 points have their own reasons, but looks like the root cause is point 1). This yet-another-stackoverflow gives some more information: http://programmers.stackexchange.com/a/176741 Looks like there is no technical limitation but rather a design/trade-off choice at some point. They could adopt Erlang-like thread system in JVM but did not probably because of complexity and/or legacy.
The main cost of OS threads, as opposed to green threads/Erlang processes, is not the stack space; the OS can easily assign just a page (normally 4KiB) of memory to a thread, and then grow it by adding more pages to the MMU tables on demand. The extra cost for OS threads is due to what happens during a context switch. The MMU tables need to be switched to the new thread etc. This is rather costly compared to a switch between two contexts within a single thread; that basically only requires saving and loading CPU registers (similar to a longjmp in C). However, nowadays the cost of OS threads is not as prohibitive as it used to be. You can easily have tens, or hundreds, of threads running in one process. You'll probably never get close to 100,000, though; this is feasible with Erlang processes.
Check out my project, [Kilim](http://kilim.malhar.net) for super lightweight threads in Java. You can read my PhD dissertation for details. The project is used commercially as well, so it is reasonably hardened. Finally, the [Erjang](https://github.com/trifork/erjang) project is an Erlang VM in Java that builds on Kilim.
Thank you for this in dept response. I understand it is all about trade-offs. Could you please give examples where the design of JVM make it more powerfull than Erlang? You gave a first example with for-loops. Is there other "features" for which JVM is better suited than Erlang?
I don't like to use the word "power" because PG has coopted it to mean [something very specific](http://www.paulgraham.com/avg.html) and I think there are other things that are more important. I start with this theory: it is important that a program be correct, fast, written quickly, and small. Optimising for these things is good for individual productivity, but I appreciate that it is important to optimise for other things as well, such as group productivity. Java is not a language where it is *easiest* for a skilled programmer to get correct, fast(est), and small(est) code written quickly(est). It is very verbose, and does a lot of work "under the covers" that might not need to be done, but that enables less skilled programmers to contribute, and that means it might have a high group productivity level when you have a skilled software architect trying to do a lot of different things, and needs more hands to solve the problems they are trying to solve. Erlang is a language where it is sometimes easiest for a skilled programmer to write the fastest, smallest code correctly, in the shortest (quick) amount of time. It does not have a high group productivity level -- higher than some other languages like lisp, but certainly not as high as Java. Not by a long shot. That may not be what you're looking for, so I'll also talk about the fact that *no* language is best at all of these things all of the time (for all tasks). I gave the example of for-loops because they are something that (as a Java programmer) you see often, and if you have a passing familiarity with Erlang you will understand why you don't use them (or need them), but you can still appreciate that Java's for-loops are faster, smaller, and often easier to write quickly than Erlang's alternative. Compare the following: int f(int n){int i,s=1;for(i=0;i&lt;n;++i)s*=i+1;return s;} versus: f(0,A)-&gt;A;f(X,A)-&gt;f(X-1,A*X). f(X)-&gt;f(X,1). Believe it or not, these have the same number of "words", but the Java one is much faster, and it was easier for me to write the Java version. It would have been easier to say: f(0)-&gt;1;f(X)-&gt;X*f(X-1). but that version uses `O(N)` memory, so I don't think it is "correct". In this way, I think it's an important "feature" of Java that it is easier to write these kinds of algorithms quickly in such a way that they will run fast and be small, however you will appreciate that not all problems are factorial. In languages where *they are*, then perhaps we can do better: f←{×/⍳⍵} That's a language called APL. There are no loops, and it is even easier to write. You may be surprised that it will run faster than Java in general, but when you do some research you may find the syntax very difficult to penetrate, and the lack of online examples will make self-study difficult. And yet when problems are factorial (or mathematic generally) you'll find an experienced APL programmer very difficult to beat in Java (or C or Erlang for that matter).
He said he was very naive about threading so I figured instead of a dissertation on what's been done with threading models he could start by learning the basic terminology. Don't let that stop you from giving as self serving an answer as you possibly can. 
As i can only reliably comment on Elixir/Phoenix implementation, have you activated gzip compression in Cowboy? Also, what's the pool size of the Ecto Repo?
 config :brew_chat, BrewChat.Repo, adapter: Ecto.Adapters.Postgres, pool_size: 10 For the Erlang app I used epgsql and I create a new connection per request: -module(db). -export([connect/0, query/1]). connect() -&gt; {ok, C} = epgsql:connect("localhost", "brew_chat_app", "", [ {database, "brew_chat"}, {timeout, 4000} ]), {ok, C}. query(Q) -&gt; {ok, C} = connect(), {ok, Cols, Results} = epgsql:squery(C, Q), ok = close(C), {ok, Cols, Results}. close(C) -&gt; ok = epgsql:close(C). Also, I have not activated gzip compression in Cowboy. At least not that I'm aware
(for Erlang part) That's a rather simple implementation. Ideally one would use a connection pool implemented using somthing like poolboy working in a fifo manner.