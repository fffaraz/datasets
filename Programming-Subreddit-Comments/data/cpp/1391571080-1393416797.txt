emplace_back(args) is more efficient
For in place construction, obviously. I was making the point about cases where a move on `push_back` happens without an explicit `std::move`
&gt;The virtual methods add 4 bytes to the class for the virtual function pointer table I beg to differ üòâ
I'm fairly certain that was dropped due to the extremely poor performance.
I'm having a hard time seeing the utility in this. It seems like a feature that has a syntax cost for no new benefit over using a pre-written function or basic operations. Can someone shed some light on what this would be useful for in a modern C++ application? 
You'd have to pay for the overhead of shared, thread-safe reference counting even when the objects are exclusively owned by the vector. The interface is also more direct, getting an element returns a T&amp; directly rather than a T* or shared_ptr&lt;T&gt;.
Check out the following for some general comments: http://www.stroustrup.com/C++11FAQ.html#lambda 
&gt; Lambda's should have been mutable by default I disagree. Id much rather have const default everywhere - mutability is a feature, you should opt-in for features you are going to use. These is legacy though which does otherwise (rest of language), so im pretty sure committee didn't take the decision to make lambdas const by default lightly (inconsistencies suck). Id rather have copies non-const in mutable lambdas as Scott prefers though (this shouldn't even break a lot of code if they went ahead and 'fixed' that in next std).
Have you actually used XCode or KDevelop's implementation on a very large project? The articles I've read have not elaborated on what kind of stress testing was done. Creator has always had problems with very large projects, never tested XCode or KDevelop...
I'm talking about word for word though. Usually when I actually read someone's standards I go through, get the main gist, and if I think I need to understand better I read the deeper justification and examples. Is it unreasonable to have all that take two hours if I read everything in the whole document?
&gt; Got some people balking about it taking more than 10 minutes to read. A few hours of self-study on the matter is a bit much... for most languages. C++ is a difficult beast, with a ton of dark corners. A lengthy style guide is a natural consequence of this situation, and without rules prohibiting undefined, ambiguous, error-prone, or otherwise unclear code, code-reviews can take forever. It may be easier for everyone to digest if the guide is reviewed as a group activity. I was on a team where we did that in pieces - 15 minutes worth a day - until we were through. This also provides ample opportunity to tune the guide based on opinion. And a word about Google's guide: it's regressive, and disregards the fact that the coders involved may in fact understand C++ very well. However, it's a solid guide if you have programmers that *don't* know C++, or expect it to work like "Java with pointers." It does this by prohibiting the more powerful C++ features and idioms (read: less expressive code), but it also makes it hard to screw up and easier to review for the less-experienced set. Personally, I *hate it with a passion*, but it has kept me from making stupid moves every now and then. Also, I have yet to see a solid guide that covers templates, such that it embraces things like concepts (metaprogramming) for robust argument validation. As a result, templates tend to wind up a forbidden feature, or used sparingly. IMO, the space is definitely left wanting for a more thorough guide to cover all that.
Yeah, I don't like the google guide I was just noting it for its length. This one does cover templates though, and rules like using tag dispatching and overloading instead of enable_if. Also stuff about not specializing functions but instead providing overloads. I went into depth in those cases because it does seem to need it...but of course it's a complex issue. Eh. This is in danger of just turning into a bitch fest on my part. I'm just surprised that people are upset about it. When I join a team I've always wanted there to be as much information about what they want from me as possible so I could follow it. I've found most standards and style guides to be next to useless due to lack of real content.
I would think that a few hours might be ok but only if it's because there's a lot of interesting justification and not simply because there's 10,000 different specifics on brace positioning listed one after another.
If it includes justifications and explanations for all of the guidelines then a few hours sounds quite reasonable. There are a *lot* of different subsets of C++ that people use, and there isn't really a quick and easy way to describe which one a project uses (and getting everyone using at least close to the same one is pretty important). If you're looking at it from the perspective of writing a guide, I'd say it should take no more than 10 minutes to read if you skip all of the justifications and such (and it should be formatted in a way to make that easy).
The project I'm working on now in Xcode has a touch under 500k lines of code spread over 3500 files. Xcode handles the (generated) 75k line file pretty badly, but otherwise everything runs fine. Facebook claims to have gone past what Xcode scales to, so maybe once you're in the millions of lines it starts to break down.
&gt; [I]t should be formatted in a way to make [it easy to skip the justification]. Maybe I need to focus on this and see what I can do to make that better.
&gt; I would get together with my other coworkers and demand they be fired. So. You're one of those guys. 
I actually like the Google one, or at least the parts of it that I remember. There's a lot of really good practices in there, like using explicit for single argument constructors or using pointer syntex instead of reference syntax for output variables (makes reading function calls easier). Most of the time the rules don't really get followed though. It's usually up to a code reviewer to pick up on those things so ideally if you're trying to enforce code guidelines, people doing code reviews should be aware of them. For the most part though, following the code style on the page is enough.
EmperorOfCanada's Mob: We have been united against you and have just requested that you be laid off. Coworker: Why? EoC's Mob: For insisting we read and follow Pike and Kernighan's idiomatic approach. Coworker: Ah. So I take it that now is a bad time to ask that you leave a comment as to why you've included an obscure library?
IMHO it depends on the how many programmers there are and what the average experience level is. The hiring process also comes into play. If you hire the right people and you don't have a lot of programmers, my experience is that "write good code" is all you need because they've already read all the same books you have, and have worked with just as much code as you have. They implicitly understand most of the things listed in the google style guide. When you're google, you need to be precise and explicit about every little thing. That said, if your coworkers can't be bothered to engage you in a reasonable discussion about the length of your document and are just "PFFT TL;DR" at you, then that seems like a bad sign.
Asking to read, no problem. But I have worked with dogmatic "coding standards" people before. What happens is that the office has an agreed upon standard that one person hates. So they somehow usurp the standards process so that their pet standard somehow becomes the standard. So suddenly they are arguing that if you don't follow their standard that you aren't a team player. But even worse is that nobody follows their standard and they then convince upper management that all the ultra productive programmers are, in fact, a bunch of out of control liabilities. Add in a standards (say ISO 9001) driven company and suddenly they can turn 50,000 lines of near flawless, productive code into a liability to the company, a liability that they will save the day by fixing by changing all that code to meet the company standard (thereby introducing bugs and making everyone who wrote it angry). The next thing you know the person no longer is a programmer (because this type of person focuses on the wrong crap and sucks as a programmer) and suddenly the chief programming standards officer. BTW the above is a true story as is the he goes or we go part. But at first the company didn't fire him as they were worried more about the code being the massive liability that he portrayed. But only after 2 people from the 8 that threatened did quit did they say that he would be a programmer again. But no guns were stuck to and it was fire him or lose us. Their thinking was that they had two holes to fill and they needed him as a programmer but this bozo had literally tried to fire people over not following his standard so there was no going back. Oh and add into the above story their own demand for IDE, their own demand for documentation style, and their later demand that programmers don't need two monitors. Since then when a programmer tells me that there is a right way and a wrong way that doesn't change the software that is being built just how it is built then I tell them "prove it, not opinion it, prove it, not logic it, prove it" Unit testing has solid proof behind it. Brace styles don't. Comment styles don't. Two monitors do have proof for example; solid unrelentingly solid proof. Certain arguments make some sense but that is not enough for one person's argument to become a bible. 
I've seen big standards, and little standards, but even the smallest effective ones I've seen -- which aggressively punt secondary issues out of the standard -- still take an hour or two of study and discussion for new folks to get comfortable with all the rules and the reasoning behind them. I'd expect that projects using C++11 (or newer) are going to have some extra bonus paragraphs guiding how the team is going to navigate around the trickier consequences of some of the newer language features. One hopes that when faced with quite a lot of real issues where simple rules might improve software quality and performance, at long last, Software Coding Standards can spend less time hammering away at indentation sizes, tab widths, where you shall or shall not insert horizontal and/or vertical whitespace, exactly how wide your block comments shall be and how you shall delimit them with a complete border drawn like this ... [greybeard wanders off, mumbling, clearly having flashbacks to the great code formatting wars of the past] 
Additionally, brace styles and whitespace rules can be fixed automatically by fine tools ... arguments over options used for that tool don't belong in the same document that mandates that unit tests shall pass before a commit to the main branch, or rules of that level of importantce. 
It's quite easy, but should be fun to anyone new to this kind of thing. Nothing beats a good game of "spot the bug". :)
For text style purely, less than 10 minutes look at the code is more than enough. For the rest, it's best not to have anything too long and have a team where newcomers are expected to ask questions and get answers *fast*.
Where I work we follow the Google style guide to the letter, and I would say that literally nobody has ever bothered reading the whole thing. We look at the code around us, and we use that for most of the style. Any ambiguity is a quick ctrl+f through the style guide, and that's about it. Anyway style guides even for the simplest of languages will take far more than 10 minutes to read, because there's so much to cover.
I must admit I didn't use any of these IDEs in a big project, but anyway as far as I know Qt Creator also has problems with big projects with its own code model but Clang integrated version of Qt Creator has problems even with a small project. Can anyone add more information about that?
I stopped at 12 GB. Didn't even try opening it! Does it ever actually stop?
It's not my first time doing security exercises, but it was my first starting from C++ code. Very tricky. It's slightly annoying that I had to look up Windows API calls to make sure the parameters for VeryCapitalizedSystemCalls were correct.
The problem starts with me not having a clue about the windows-API. What I can of course say for sure, is that I would not accept this code in any project if I had to decide it. (Useless inheritance, not using RAII, blank pointers where not needed, new (!)¬π where not needed, an empty base-class (=equivalent to void), printf, ‚Ä¶). My first thought on this code was that it was C, until I looked again at the namespace-keyword. ¬π I consider new to be as bad as goto: It may on rare occasions safe the day, but you should try REALLY hard to avoid it outside of the deep internals of a library.
I'm confused (and upset that I don't see the problem, as it's damaging to my pride). I caught the dreadful use of a byte-from-file as the memory type parameter to `VirtualAlloc()`. success = ::ReadFile(h, &amp;m_imageData-&gt;memoryType, 1, &amp;numBytesRead, nullptr); // ... m_imageData-&gt;rawData = (unsigned char*)::VirtualAlloc(0, m_imageData-&gt;rawDataSize, MEM_COMMIT|MEM_RESERVE, m_imageData-&gt;memoryType); But I don't understand how this gets exploited. Can anyone enlighten me? I get that it's meant to be through the bad casts in `main()` ImageFactory::Image* image = ImageFactory::LoadFromDisk("Background.dat"); // ... ImageFactory::DebugPrintDimensions((ImageFactory::CustomImage*)image); But I don't see why, in this case, this is a problem. `LoadFromDisk` returns a pointer-to-`CustomImage`, which is implicitly downcast to a pointer-to-`Image`. That's then unconditionally upcast back to pointer-to-`CustomImage`. All very naughty, but why would that be exploitable? It might as well be a `void*` for all the difference it makes, and, while there is no check that it _can_ be upcast, the fact is that the pointer is a `CustomImage`, and no amount of bad casting changes that. What am I missing? 
The problem is that there are two different C-style casts involved. * **ImageFactory::DebugPrintDimensions((ImageFactory::CustomImage*)image);** on line 37 is a reinterpret_cast since the compiler *doesn't* have the class definition at that point. * **return new (std::nothrow) CustomImage(imageName);** on line 132 is a static_cast since the compiler *does* have the class definition. They have unfortunately very different behavior since **CustomImage** has a vtable while its base class **Image** doesn't. Easiest way to explain is to check the (implementation specific) memory layout of **CustomImage**: - Pointer to vtable for **CustomImage**. - **Image** (empty in this case) - **std::unique_ptr&lt;InternalImageData&gt; m_imageData** So essentially: * **new CustomImage()** == 1 * **static_cast&lt;Image*&gt;(new CustomImage())** == 2 * **reinterpret_cast&lt;CustomImage*&gt;(static_cast&lt;Image*&gt;(new CustomImage()))** == 2 * **reinterpret_cast&lt;CustomImage*&gt;(static_cast&lt;Image*&gt;(new CustomImage()))-&gt;vtable** == 2 A pointer to 2 is the same as a pointer to 3 since **Image** is empty. Accessing the vtable of CustomImage is therefore equivalent to accessing **m_imageData**... and everything explodes. :)
http://www.stroustrup.com/JSF-AV-rules.pdf is 141 pages. If you aren't prepared to read that much, carefully, you probably shouldn't be writing embedded software for aircraft. But most of us aren't, and don't need quite that level of detail written down as a strict standard. 10 minutes can give you "here's the list of arbitrary major style choices we've agreed here for consistency". For some places, that's enough. Some places don't bother even with that much.
Ah yes; thank you for the explanation. The problem then is that `Image`, a non-virtual base class, is being used as a base class for a class with a vtable; and hence the pointers to Image and CustomImage are incompatible. Learned something. Thank you.
yeah, I think he forgot how it was written in the Google Coding Style. They say to pass by const&amp; for input and non-const&amp; for output.
Have your tools enforce it as much as possible. Don't worry about minor formatting issues: Use clang-format or one of the many other tools to take care of that before check in. Use switches in compilers to throw warnings on bad practices. Use a static analyzer that supports many of your coding standards (there are some that can flag MISRA violations). Automate as much of your coding standard as possible.
Funny enough the article calls it "main.c" and it really feels like a C program in C++. The bug appears to be referring to C-style casting messing with C++ Polymorphism anyways, so if anything this is just a showcase of "Don't write C in C++"
Well, the actual rules are 50 (small) pages (definitely smaller than DIN A4, the standard-format for such documents in Germany). 
I'm so glad that C++ finally has std::tuple to easily allow for returning multiple values.
Getting ANY team of programmers to follow any standard is like herding cats.
Just an observation: pthreads under C++ uses the same pattern to implement pthread_cancel(). With pthreads, a "special" exception type is used to unwind the stack once a "cancellation point" is reached (usually some I/O function). The caveat here is that any attempt to trap said obscure exception is verboten; using "catch(...)" must issue a "throw;" in order to behave correctly. The actual name of said exception escapes me at the moment. try { /* ... */ } catch(...) { throw; // re-throw in case it's "special" } Honestly, while it all sounds like kind of a hack, I'd say you're on the right track with this. Any yield() implementation can be thought of as a co-routine, which is really just a flavor of threading. So, naturally, all the same gotchas would apply. Edit: Placing a catch(...) somewhere in the first frame on your yield stack could be used to trap any and all exceptions that are leaving main(). I think you want to apply this pattern everywhere you are catching ImmediateStop. There you could use std::current_exception and keep an exception_ptr around, as you mention, for use outside the Generator.
This will definitely be the way to go, esp. as the clang tools move forward. It seems a shame it has to come to his however, given that in any development team, everybody is smarter than everybody else.
Wrong, the length does not matter at all. It can be very extensive just because it is explaining the rationale behind each rule, explaining with examples why is better to follow a certain style and not other. Also it could be short and filled of annoying useless rules. The better ones teach why an style is better than other. The awful ones just dictate rules that must be followed without thinking.
‚ÄúPolitics and prostitution have to be the only jobs where inexperience is considered a virtue. In what other profession would you brag about not knowing stuff? ‚ÄúI‚Äôm not one of those fancy Harvard heart surgeons. I‚Äôm just an unlicensed plumber with a dream and I‚Äôd like to cut your chest open.‚Äù The crowd cheers.‚Äù -- [Tina Fey, *Bossy Pants*](http://www.goodreads.com/work/quotes/14302659-bossypants) That and, apparently, C++. So many people who think they know C++ think they know why it sucks and then try to go about turing it into that something they wish it was instead of what it is. I've worked as a professional programmer for nearly 15 years now and most of that time has been spent writing C++ "in anger". It's never been my favorite programming language, really, but rather just the one which has paid the bills. My favorite programming language has been (and probably will continue to be) Lisp. From the first time I encountered it in my "Intro to AI" course at university, I actually loved the parentheses, but then I mostly forgot about it since none of the job offers were looking for Lisp. In fact, my first programming job out of college was for writing good old fashioned C code. I'd never even used C++ before that; it was never used in any of my college classes because the first taste of OO was given to us via Java. So my first introduction to C++ was Stroustrup's [*The C++ Programming Language*](http://www.stroustrup.com/4th.html) and then soon after that I started devouring [Scott Meyers books](http://www.aristeia.com/books.html). Ironically, it was Scott Meyers who reminded me of my long forgotten love of Lisp. In his *More Effective C++*, Item 31, "Making functions virtual with respect to more than one object", there was a almost throw away bit: "One possibility [to do multiple dispatch] is to scrap the use of C++ and chose another programming language. You could turn to CLOS, for example, the Common Lisp Object System. CLOS support what is possibility the more general object-oriented function-invocation mechanism one can imagine: multi-methods." And I thought, "Huh? We did Lisp in college and nobody ever mentioned CLOS. What's that all about?" And that was probably my first real experience of understanding that one doesn't actually learn shit in an undergraduate course. I mean, I'd encountered it before, sure ‚Ä¶ But this was such an eye opener for me. What we got in that college course was the FUD introduction to Lisp that only ever mentioned lists, everything was best done via recursion, etc. There was no such thing as data types, arrays, CLOS, conditions and restarts, macros, etc. No disrespect meant to the professor of that course, though; it was just an intro and the intro was just meant to be an intro, nothing more. But ... the same kind of shitty introduction that I got to Lisp is, I think, very equivalent to what most people get with C++, if they ever even get on at all. Why? Well ‚Ä¶ because Java was/is a "better C++", right? At least that was the justification for using Java in my first courses on OO, if I recall correctly. And I've heard it from someone I know who teaches AP computer science and was the reason he gave, if I recall correctly, for supporting the use of Java for the standard AP computer science courses. Regardless of the reasons behind the decision, one finds that the [AP Computer Science Course Description](http://apcentral.collegeboard.com/apc/public/repository/ap-computer-science-course-description.pdf) will only be Java: &gt; Current offerings of the AP Computer Science A Exam require the use &gt; of Java. Those sections of the exam that require the reading or &gt; writing of actual programs will use Java. The exam will not include &gt; all the features of Java; it will be consistent with the AP Java &gt; subset (see Appendix A). The AP Java subset can be found in the &gt; Computer Science section of AP Central &gt; (apcentral.collegeboard.com). Students who study a language other &gt; than Java during an AP Computer Science A course will need to be &gt; prepared to use standard Java, as specified in the AP Java subset, &gt; on the AP Computer Science A Exam. And I'm not the only one who has thought that. [Alan Kay](http://en.wikiquote.org/wiki/Alan_Kay) &gt; I fear ‚Äîas far as I can tell‚Äî that most undergraduate degrees in &gt; computer science these days are basically Java vocational &gt; training. I‚Äôve heard complaints from even mighty Stanford University &gt; with its illustrious faculty that basically the undergraduate &gt; computer science program is little more than Java certification. -- ACM Queue A Conversation with Alan Kay Vol. 2, No. 9 - Dec/Jan 2004-2005 Now, nearly a decade has passed since that interview. I don't think that Java has quite the marketing campaign behind it like it did back when it started. By now C# is the "better Java" or whatnot. But it isn't just Java, for example. Think about UML, for example. It can be used to model many things about C++, too; they have parameterized classes notation, etc. But how would one go about trying to model a CLOS (defgeneric ...) in the &lt;cough&gt; Unified &lt;/cough&gt; Modeling Language? Or the [unbounded dynamic polymorphism](http://stackoverflow.com/questions/9295814/what-is-unbounded-dynamic-polymorphism-in-smalltalk) of Smalltalk? You can't, I'm sure. So what got promoted was this kind of least common denominator view of what object oriented programming could be, which had this kind of after affect of it being seen as what object oriented programming *should* be, which is so limiting, and is something so many of the "better Javas" are carrying forward, I think. And so when I write Java, I really mean any language promoting the same least common denominator view of what OO "should" be. Now, the problem with this poor or none existeant exposure to C++, in my opinion, isn't so much that there is anything inherently wrong with Java. And it would just great if those people who were weened on Java actually started writing code in Java. But I don't think that Java lived up to its promise. And so we have this era of folk educated in Java, who then often take the Java view of OO as The Right Way to do OO. And this point of view would be fine for a novice programmer hired to write C++ with the idea that, "I don't care if they know how to write C++, I just want them to be able to solve problems," *if* that Javaesque view of OO was a view shared by C++. But this is not true at all. &gt; Stroustrup: In which sense do C, C++, and Java constitute a family &gt; of languages? C and C++ has a large common subset, and over the &gt; years serious efforts have been made to minimize the inevitable &gt; tendency of the two languages to drift apart because they are &gt; controlled by separate standards bodies. Java, however, provides no &gt; real compatibility, and similar syntactic constructs have semantics &gt; different from the C and C++ versions. Clearly, Java borrows from C &gt; and C++, but under the skin, the similarities to Modula-3 seem &gt; greater. [http://www.gotw.ca/publications/c_family_interview.htm] I think that many of the C++ programmers out there are basically Some Other Language Than C++ programmers trying to write SOLTC++ code to stuff into a C++ compiler. It would be like my fresh from college self writing a Lisp coding standard requiring everything to be done via tail recursion (which might well work for Scheme but Common Lisp ain't Scheme). And the coding standard is the tool to try and achieve that goal by disallowing anything which isn't a subset of C++ which can easily map to something into SOLTC++. And that would be fine, I suppose, if C++ was anything like SOLTC++. But it isn't. It is a nasty, ugly, snarling little beast of a language with its own very peculiar way of doing things. And it gets used a lot. Why? Because all of those nastly, ugly, snarling little bits of what got into C++ got there not because Stroustrup was trying to desgin a pretty language but rather one that could actually be used. And I think the user base of the language is a testament to his having done a pretty good job at it. But ... nobody really likes it. I don't. But it pays the bills. And I've seen it over and over again, a program is started by somehow who either does not know or genuinely dislikes C++. And they don't care, either, because "a customer doesn't care what language, or which subset of a language is allowed to be used, they only care about features." And sometimes these are really really smart people, even. Way smarter than I am, to be sure. And this goes on for some time until ... the damn thing starts crashing. Repeatedly. About the head. Anyway ... IMNSHO, unless you're working in a very specific environemnt, e.g. some embedded RTOS system controlling something which might explode if there is a bug in the code, just start with [*C++ Coding Standard*](http://www.gotw.ca/publications/c++cs.htm) if you're in the position of starting the coding standard and expect to deal with a lot of FUD if you're not. This is kind of a template for a C++ Coding standard by people who've actually be involved in C++, e.g. members of the standard committe, and give advice which works great for C++ as it actually is instead of what somebody wishes it might be. And they're not advocating using fancy pants template metaprogramming flippity dippity switch stance gee whizzers. I've worked at quite a few places where I would have been happy if everyone knew how to "Take parameters appropriately by value, (smart) pointer, or reference." 
Personally, I measure C++ Coding Standard length (and content) against: - [C++ Coding Standards][1] -- *Herb Sutter &amp; Andrei Alexandrescu* - [High Integrity C++][2] And honestly most of the homebrew ones I have seen cared more about style than anything else. As if Hungarian notation could save us from a memory leak... [1]: http://www.amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586 [2]: http://www.codingstandard.com/section/index/
Is that... a problem? As long as it is the only files you need?
Yeah, the null check is definitely annoying/bad and a clear argument for using refs... that said, refs can can be created from null pointers as well, but I suppose that's the responsibility of the caller to not let that happen. The crash will occur when you actually try to use the reference though (ie. your function). Despite this, after reading through code that follows the pointers-as-output as opposed to refs-as-output, I find it a lot faster to clearer to read. You don't have to check the function signature each time and count the position of the arguments. My argument for doing this is exclusively for faster readability. Seeing something like this: DoSomething( a, b, c, d, e, &amp;f, &amp;g); reads easier and faster than DoSomething( a, b, c, d, e, f, g ); I work in the AAA games field, so our problem domain is finite. Maybe things are a lot different in other industries where the problem domain is basically infinite.
No I didn't forget, because that's not what they said. They say to use const refs for inputs, and pointers for input/output.
&gt; Still, in places where you know the input is valid you can skip the null check. I've seen this assumption made way more often than that it was valid. The legibility of out parameters is so problematic anyway that rather than try to fix them I think they should be highly discouraged. Most uses I see are unnecessary premature optimization attempts.
First off, "elif" and "esif" are not valid keywords in c++. I assume you meant: else if (...) Secondly, naming your variable "tax" and your function "tax" may lead to some confusing error messages.
You need to post your entire code (at least more of it). This is also not C++. First of all *elif* is not a keyword, the equivalent is *else if*. ~~Secondly there is no *and* keyword, the equivalent is *&amp;&amp;*~~. Thirdly, the whole statement must be inside a parenthesis. Where are you learning from? I think you should get a proper resource, there are great recommendations in at the right sidebar, and learn the language from that. EDIT: Ok, so *and* is a keyword apparently. 
Well, the first immediate problem I see is that C++ doesn't have an "elif" keyword. Beyond that I think more information is needed to help you.
wtf, I have never seen that before, is that site for real I can‚Äòt be bothered to get the compiler out to check?!
Yes? You can just check if your text editor highlights `and` as a keyword?
My experience in c++ has been pretty much exclusive to games. A big problem with games is that pushing 60 fps is hard when you're trying to stuff as much "cool shit" into the game as you can. Luckily, you can precompute a lot of information (the data pipeline). In there you can ensure that data is properly validated, lessening the burden on the runtime. In many other applications, you probably can't make these types of assumptions. The other problem in games is that you're often dealing with huge pipelines of data in the run time system. Take animation for example. You have to decompress a lot of data each frame, blend the poses together, etc. There's no other option here but to either pass by reference or by pointer. Passing by value here would be suicide.
&gt; Passing by value here would be suicide. I take it you haven't tried so you could measure it then.
&gt;I take it you haven't tried so you could measure it then. This is a very bizarre statement. In gaming, performance is critical. Do you really think we just write code randomly and hope it runs quickly? 
*Not a spoiler*: You don't need to know anything about the Windows API to see this bug. I know this, because I have no clue about the Windows API *:-)* , and there is a pretty obvious bug in there. I say 'obvious', but perhaps I was just lucky to have considered this. My point is, once this bug is pointed out, it is very easy to prove that it *is* a bug. It does not require a complex analysis of how the various parts of the program fit together. (Exploiting the bug, in a reliable manner, might be less obvious.)
It's kind of neat how abstract this is... but I gotta ask... what is this actually good for? I'm guessing the "church" refers to Alonzo Church, the lambda calculus guy?
&gt; template metaprogramming flippity dippity switch stance gee whizzers I hear these are almost fully supported in clang
I usually don't read the guidelines, i'll just format code like the code thats already there and if im doing something odd, i'll consult the guidelines then.
Ultra-nitpick: `and` is an "alternative token" (N3797 2.6 [lex.digraph]) and an "alternative representation" (2.12 [lex.key]/2), not a "keyword" (2.12 [lex.key]/1). No, I don't know why the Standard bothers with this distinction. Bonus points: `final` and `override`, which normal people call "context-sensitive keywords", are instead "identifiers with special meaning" (2.11 [lex.name]/2).
Wow... I could have sworn that, in an inheritance scenario where base doesn't have a viable but derived does, msvc (or was it Borland?) used to place the vtable *at end* of the base members, then lay out derived members. Anyhow, good catch! (C casts are bad. Mix of C and C++ casts is worse) Edit: actually... base image class has no members, in which case, no idea how anything is laid out in any implementation.
&gt; refs can can be created from null pointers as well, but I suppose that's the responsibility of the caller to not let that happen Obviously, yes, but there's more: what you're saying here is "you can screw it with references", which is true, but IMO, with pointers, situation is *worse*, simply because NULL is legal and generally easier to slip in. &gt;Despite this, after reading through code that follows the pointers-as-output as opposed to refs-as-output, I find it a lot faster to clearer to read. What about const-correctness? Pointer is the normal way of saying "this receives x as input, but x is optional". That is, in C and C++, best "modelled" as e.g. void f(const x* p). (Edit: and when you're passing an actual pointer as your parameter, you see nothing again). Perhaps I should have been explicit: I understand that you like "&amp;" being clearly visible. Still think advantage/disadvantage ratio is way on the "disadvantage" end of the scale. C# does that tidbit sweetly (with "out" and "ref" keywords).
&gt; It seems like a feature that has a syntax cost for no new benefit over using a pre-written function or basic operations. You use it when you don‚Äôt have a pre-written function. Often you just want to express a very simple operation that‚Äôs applied to some elements. Writing a function or function object for that is possible but requires *more* syntax and leaks names (the functions) out of the local scope. Lambdas are particularly useful with closures. Compare template &lt;typename C, typename T&gt; T const&amp; find_smaller(C const&amp; a, T const&amp; v) { return *find_if(begin(a), end(a), [&amp;](auto x) { return x &lt; v; }); } with template &lt;typename T&gt; struct less_than { T const&amp; v; template &lt;typename U&gt; T const&amp; operator ()(U const&amp; x) const { return x &lt; v; } }; template &lt;typename C, typename T&gt; T const&amp; find_smaller(C const&amp; a, T const&amp; v) { return *find_if(begin(a), end(a), less_than{v}); } We capture the local variable `v` in both cases, but using lambdas helps us avoid writing *a lot* of boilerplate code.
Too bad there is no testing code linked for *Optimizing Big Number Arithmetic Without SSE*, I would like to see how would my [double_integer](http://mx-3.cz/tringi/www/int128) template compare.
Not sure if "N3863 - Private Extension Methods" really matters that much. In the few times I get around to use C++, I have started declaring such methods as private data (static/nameless namespaces) on the implementation file. On my use cases, the time the inheritance tree is not relevant and the necessary data can be given as parameter.
I think so too. Still, with Modules maybe such changes could come to the language after C++1y.
Setting a null reference is undefined behaviour by the standard. That doesn't mean it's not something the compiler doesn't have to deal with. Consider a case like this: class Test { public: Test(int *i) : CrashWhenReading(*i) {} int AddReturn() { return CrashWhenReading; //return 0; } private: int&amp; CrashWhenReading; }; void main() { int* i = 0; Test t(i); std::cout &lt;&lt; t.AddReturn(); } In VS, the crash will occur when AddReturn tries to read the value of CrashWhenReading. It's a fabricated example i know, but I had to fix a bug very similar to this before when I encountered it in a large system. We had a factory class that upon creation of the object, would hook up a bunch of pointers/references inside the class. The references were seated to a dereferenced pointer which wasn't null checked beforehand. The result was an weird random access violation crash that would happen sometime in the future (possibly many frames later) when that object would try to read that reference. Seating the reference to NULL doesn't result in a crash because the runtime isn't reading the nulled reference when it's set. So yes, you're correct that it's undefined behaviour, but the crash far away from the problematic line. The whole problem stems from the fact that references are just pointers under the hood, but C++ gives them gives them special properties. Note: This was just in VS. Clang or GCC might behave totally differently. The VS compiler does let me down a lot of times by not catching things you'd think it should. 
The important thing is, that dereferencing NULL is always UB and that UB may crash at any time (later), not at all or may do really sinister things. Any code that is in context of UB becomes meaningless, so arguing about it is quite useless, unless you are discussing how to exploit a resulting security-vulnerability.
In general, you're correct that any code in the context of UB is meaningless. However, when you're working on one compiler in a known and finite problem domain, and on constant unchanging hardware (game consoles), UB actually becomes defined behaviour. The compiler has to do *something* in those cases. UB basically just means it's up to the the compiler implementation but the standard makes no promises on what happens. In this specific case of causing UB through null references, the resulting effect is that the game crashes when it needs to access something it thinks the (null) reference is pointing to. Since the references are just treated as pointers in VS, it's effectively identical to dereferencing and using a null pointer.
And then you update your compiler and BAAAM!
Presumably because the point is to prevent the enum members from potentially clashing with names in the outer namespace. In your latter version, the Bar and Car names could be ambiguous.
So why not use a traditional enum then?
I think the main reason for enum classes is actually to make Bar and Car of the type Foo preventing it from being treat like an integer value without explicit casting and vice versa. E.g. you cannot pass an integer value to a function that takes a Foo enum value (handy to prevent bugs like having somebody add a new value in the middle of enum but not change code that passes by integer literal). That said, I'm a fan of explicit code so I do agree that it's sensible that this should be the default behaviour. I guess a neat compromise would be if you could "using namespace &lt;enum class&gt;".
With these new enum classes, can you go enum class Bitmasks : unsigned char { Bar = 64, //0100 0000 Baz = 128 //1000 0000 } char incomingControl = 0xC0; //1100 0000 bool thisShouldBeTrue = incomingControl &amp; (Bitmask::Bar | Bitmask::Baz); It's been awhile and C++ seems to have changed since I last looked.
I don't think there is a technical reason. Java behaves exactly the way you described, and it works fine.
If we pre-define the operators it may be possible to create values that are not represented within the enum class, and instead are values of the underlying type. I thought one of the purposes of enum classes were that, because they're not implicitly convertible, they create a closed set of sorts. 
&gt; If we pre-define the operators it may be possible to create values that are not represented within the enum class, and instead are values of the underlying type. Sure but that‚Äôs entirely normal for an enum. To make it type safe, there could be an `is_flag` metafunction that users can specialise for enum classes, as shown in [this answer on Stack Overflow](http://stackoverflow.com/a/18803980/1968): enum class a_flag { bar = 1, baz = 2 }; template &lt;&gt; struct is_flag&lt;a_flag&gt; : std::true_type { }; Read the comments for a discussion about this could/should have been part of the standard.
I know that that's normal for a regular enum, and I still don't think that it's a good idea for enum classes to behave this way. I personally think that if you would like to extend the concept of OR'ing the items together that you define the operator manually, as some enum classes are not designed to be combined. I see enum classes as introducing a new type into the program, like struct does, whereas traditional enums are basically integral values with convenient names.
Programming really is an art- you get better at it the more you do it, and you can't help but develop your own style, even while conforming to all the style and practice guidelines. If you have the time, challenge yourself to write code all the time with personal projects and ideas, or do what I do and just constantly read and reread the code you write, looking for ways to improve or new ideas to try. I can't say I recall feeling exactly that way, but I will say that I'm always looking back at the code I wrote a year ago and asking "How did I write that? There are much better ways to do that." Being critical of your own work is pretty much universal, and I think it's a good thing. Use that feeling to drive yourself to learn better programming techniques.
You will always find a better way to write a program the second time around. With that being said, if you want to be a good hire out of college knowing the following concepts will put you ahead: - debugging quickly with a debugger (you'd be surprised how many debugging printf's you'll find) - sockets - threads - how to identify race conditions and make them not happen (the real key to multithreading) - identifying memory leaks (and not creating them yourself) - knowing how to build a static lib, dll, exe and the differences between them. I think those concepts are the ones that tend to slip through the cracks on programming classes.
I always say that a good programmer will look at their code from 6 months ago and think of several better ways they would do it now. 
Yes, yes, and no. Having said that, one of the advantages of joining a software company (rather than a company with a few software jobs) is that you're more likely to find someone else you can learn programming from. Having a good mentor who can review code you've written and point out better, more idiomatic ways of doing the same thing can be invaluable early on.
&gt; as some enum classes are not designed to be combined Sure. So don‚Äôt specialise `is_flag` for those, and you won‚Äôt be able to use bitwise operations on them.
I guess that's not so bad.
I think the best case for modules was made by Doug Gregor: add a module system that the C standards committee will accept, then piggy-back onto it.
Thank you for the detailed answer! &gt; EDIT: I was informed by someone else about the existence of std::exception_ptr. I may be able to implement exceptions using this, we'll have to see. I mainly asked because AFAIK in C++11 there are mechanisms to transport exceptions between threads as well as mechanisms to "attach" one exception to another (there is a tutorial by Jon Kalb about exception safety that covers this). There is also a review process going on for Boost.Fiber. It implements fibers with the same interface as std::thread/Boost.Threads. For that to work it must be able to solve this exact problem (i.e. dealing with a fiber throwing an exception).
Note that traditional unscoped enums prevent integer =&gt; enum conversions, although they allow enum =&gt; integer.
Advice (applies to whatever language you are interested in): * Work on projects that you are interested in (i.e. make a calendar, to-do app, 2d or 3d game). The key is to just keep doing more small projects every day. * Try to incorporate standard libraries into those projects, in C++: STL, in Java, java.util, in Javascript: JQuery. * If you can't find a job, apply for an unpaid internship at a startup, work your ass off during that 3-4 month period, then they will most likely hire you after that period is over.
Find something you want to build and build it. If you find something is hard or feels complicated or roundabout, always ask the question: "What, if it existed, would make this task easier?" Answer that question in great detail if possible. Is it a library? A function? An abstraction? A programming language? A debugging tool? Once you've pinned it down, do it. Then after you finish, decide whether your initial assessment was accurate or not. Introspection is the key to improvement and is shared among all the greats.
If you're the kind of guy who likes to overcomplicate stuff, then brush up on your C, not your C++11. Force yourself to get better at writing great code in a simpler language. Learning to use C++ lambdas and all the other new jazz is just going to make your code harder to read IMHO, and not make you a better programmer per se.
Terrible advice. I learnt C++ as C++11 after I learnt C. If your C looks "simpler" than your C++ you are writing one or both of those languages wrong.
Take on some team projects and FINISH them.
Yes, but on other platforms it is your responsibility to obtain aligned memory via memalign (now deprecated) or posix_memalign. On Macs, all memory obtained via malloc is already so aligned.
On Mac, alloca doesn't return an 8-byte aligned pointer even on x64, so you have to watch for that. 
Hell, as a fairly recent graduate who got into a darn good career using lots of C++ at work, I totally agree and want to piggyback to expand on your points. &gt;You will always find a better way to write a program the second time around. You'll write some code, go to lunch, sit back down and rewrite it again more optimally. That is laudable, not bad. Your brain will work on the problem in the background and abstract or incorporate lessons learned in the past that weren't immediately apparent when you first wrote some functionality. Having the drive to write elegant and comprehensible code is a huge asset, you'll find many programmers who just "get the desired result" and then move on. They are bad. &gt; - debugging quickly with a debugger (you'd be surprised how many debugging printf's you'll find) Competence with a debugger is hugely valuable. If you can trace an issue in 30 minutes using a debugger instead of fumbling around writing your own tracing code for 2 days that is worth its weight in gold. Nothing is more annoying than a codebase with a bunch of orphaned debugging printfs checked in which obfuscate meaningful output on stderr/stdout. This is a big problem, and in 99% of cases a terrible way to debug. &gt; - threads - how to identify race conditions and make them not happen (the real key to multithreading) Yes! Even get familiar using higher level threading libraries or language features (Boost, QtConcurrent/QThread, stdlib, etc) to get exposure to multithreading. Have an awareness of the sort of problems that thread well, the overheads of threading, and more importantly where a thread is not worth it. We have a big problem with developers adding threads wherever they can which increases code complexity and interface demands needlessly. &gt; - identifying memory leaks (and not creating them yourself) Adding to this: use tools before you check in code to make sure you aren't leaking memory, and whenever possible do not use naked pointers. I spend probably 2 days per year fixing other people's memory leaks and sloppy pointer errors that could have been avoided. When I first started doing this the number of leaks in the codebase was daunting and took over a week to fix. &gt; - knowing how to build a static lib, dll, exe and the differences between them. This is critical. Going further, having the ability to manage toolchains on multiple platforms is extremely valuable. Maybe you're linking against ffmpeg with msvc but you need to manage a GCC toolchain to modify the library and cross compile for windows. Being able to do this in hours instead of days sets you apart. Additionally understand licensing; what you can and can't use in production code and where to look for compatible libraries. Avoid the not-invented-here mindset and pull in libs where appropriate. You don't need to worry about perfect code, nobody ever writes it. Just strive to write solid comprehensible code, always check your work, and have a fundamental understanding of secondary and tertiary programming concepts and you'll be a desirable employee. You're going to learn a lot on the job, and that's a normal/great thing. 
The most useful skill as a programmer I have seen for someone just out of college is not fearing code and more importantly a large code base. If you go to work for anyone who is not a brand new start up you will not be put onto a new project so learning to read code is extremely important. Which means your skills are valuable, just build on what you have, and you will learn more in your first couple months of work than all of college.
&gt;I guess you could say at this point I am a better reader than writer of source code I don't know how you've come to this conclusion, as you're largely comparing apples to oranges. That said, in my experience, people seriously underestimate the difficulty of reading others code. The reason is quite obvious: code is a result of a thought process unknown to the reader.
I had the privilege to participate to the program last year, and it was an incredible experience. If you are interested in advanced C++ and Boost, this is a great opportunity to meet some of the best library developers around and to learn from them.
&gt; Having the drive to write elegant and comprehensible code is a huge asset, you'll find many programmers who just "get the desired result" and then move on. They are bad. The most valuable programmer is the one who can properly contextualize the problem. There is no single property that makes someone a good programmer. Maintainability, modularity, time to implement, run-time performance, memory efficiency, readability, are goals that need to be weighed and understood in any task. Don't get caught up in prettifying code as a goal. I work in games. We don't ship code, we ship games. I think programmers should endeavor to become craftsmen and women. Just don't go up your own ass with regards to one single aspect of programming.
Programming is a skill. To get better at almost any skill, you have to practice, practice, practice. So, as many others have said, write more code. Find something you enjoy writing and do that. Also, find a mentor that can help you by looking at your code and ask pointed questions that will lead you in the right direction. And read lots. Your learning career isn't almost over, it's just beginning. 
If you're not allowed to use the STL, you may as well just use malloc, free and realloc, where realloc solves your shrinking/extending problem.
Thanks, but I'm not allowed to use malloc/free/realloc either. :)
It really looks like you should get out of that course asap.
i dont see why this course is crappy. this problem pretty much drives home the issue about pointers. its amazing how many people don't understand the concept of pointers.
It looks very interesting. How much C++ experience do you really have to have for it to be worthwhile, though?
If you are not allowed to use a vector, write you're own vector. If you're not allowed to do that drop out because who ever is teaching shouldn't be.
This would be my dream job but I don't have enough experience so I'm sharing with all of you. For future reference, what would a realistic salary be for this job? My understanding is that programmers make less in Japan than in the US, but it's a big company in Tokyo, so I don't know what to think. Maybe $60K (6 mil yen)?
I used to do C dev in Tokyo. That's a little more than what I made in salary (closer to $50k), but I also didn't have much experience at the time and they also covered a furnished apartment (around $2,500/mo. value) for me as well. From what I understood, the company covering your housing is rather common. They also gave me about 3000 yen per day in for per diem expenses. Also, Tokyo is expensive as _FUCK_, but totally worth it in every way. Good luck :)
What are your interests?
Thanks for the info!
A few years ago i found a vm written in c# which i thought was interesting so i ported it to c++ and then made an assembler for it. Anyway, my point is, find something interesting in another language and port it to c++, you'll have a reference implementation, learn a new language and learn a ton about c++. 
Interesting what VM? 
These jobs (Â§ñË≥áÁ≥ª) pay more than normal jobs in Japan, so I would expect the range to be $80K-$110K. That would included your 2 times a year bonus as well.
I agree with ErictheAlm, this does belong over at /r/cpp_questions. That being said: &gt; Once the array is full with 10 items, how do I dynamically add more space for additional objects? In fact, I'm thinking the array should probably have a size of 0 before the first item is added; how do I do that? You would want to create a new array of Person pointers that is larger than the old one, copy the old one over to the new one, delete the old one, and replace the pointer to the old one with the pointer to the new one. &gt; Similarly, when I delete an item (like when I delete people[1], above), how do I shrink the array down to a minimum size? Like, how do I make the object at people[2] move to the position of people[1]? Well, the simplest solution would be to keep track of the next location in the array where you will add an element, and when you delete an element, copy the elements from right to left over the deleted one and shift the next location back one. By keeping track of the next location in your array to add an element, you don't have to create a new array and copy all the elements from the old one every time you remove an element. You could also just delete the element, set it to NULL, and scan the array from bottom to top checking for NULL before adding an element to the end. This isn't efficient, but it gets the job done.
I would LOVE a C++/SFML version of [LibGDX's](http://libgdx.badlogicgames.com/) scene2D API! There is already tons of example code of how to do it, you just have to do it. The SFML community is growing pretty quickly and would really love this. [http://www.sfml-dev.org/](http://www.sfml-dev.org/) [http://en.sfml-dev.org/forums/index.php?board=10.0](http://en.sfml-dev.org/forums/index.php?board=10.0 ) you can see other people's awesome contributions!
Hi, I'm Bryce (I'm the chief organizer of the volunteer program). If you are an experienced coder, but you haven't worked with C++ extensively, you should still think about applying. If you're reading /r/cpp, you're probably qualified.
Awesome! Didn't know about that forum. I just built and tmx loader and clearly didn't have to. Ah well. Thanks for the link 
If it only was in Europe (preferably not in the UK)‚Ä¶
We accept international applicants :)
If you want to reach 'expert' level, you should look into template metaprogramming. It is very handy for libraries.
Why do you want to program? Is there some field you are interested in writing software for or did CS just sound like money? (Hint: for most people the pay is low to average) In my experience if you are motivated by interest in the field, you'll tend to seek out starter projcts naturally.
Take an existing C++ library and modernize it to C++11/14. This will hammer home idioms such as rvalue references/move semantics, using smart pointers for intelligent ownership, etc. Try your best to include as many new features as you can (where they make sense.) Try to toss in `noexcept` if you can prove the strong guarantee on functions, for example.
A text based game is a good start. If you want to do something with graphics, [Cinder](http://libcinder.org/) would be a good library to use. Try to plot equations, making charts like a virtual graphic calculator. This is a /r/cpp, but I encourage you to look at other languages as well, like C# (which also comes in a VS express edition) or Java. 
If you are using C++ professionally, then you likely understand the basics. If you want to "reach expert level", you need to master the tools that make C++ so widely used for libraries. DSLs written using templates allow you to write fast, efficient code by having the library do the work at compile time. If you are mathematically inclined, something to try out is to write a DSL for linear algebra. Something similar to [blaze](https://code.google.com/p/blaze-lib/), or [eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page). For example, in the following, when creating `a`, a number of temporaries are created that reduce the efficiency of the calculation. But by using templates, you can do the calculation all at once, reducing poor memory usage: Vector b,c,d,e; //... Vector a = b + c + d + e; In reality, just doing this exercise generally (for any number of vectors being added, and any operation between them, and making it efficient! check your assembly output), should really improve your understanding of templates and metaprogramming. It isn't very useful otherwise though (the libraries are better at it, and there are just too many details that are important to performant code like this). Also, this isn't the only thing that you might want to master, but it is a favorite exercise of mine, purely because of its technical requirements.
C++ is a required course for my math major and as I continue farther into the course I am learning to enjoy it much more. I had previously started with java using bluejay at another school with no background in programming and found it very difficult. With my interests in programming and game design and also an upcoming internship with a company in NY for their IT department I found that it would be a good idea to double major and pick up CS along with my math major. 
I work in the graphics field, and I find that sort of the cool and fun part of programming. I am sure I could give you some pointers if that interests you. 
I think what I am most curious or concerned about is, for someone who has never had any background in programming but always had an interest in computers, games, and the ways they all come together, where should I go from where I am now. I have built a PC before, I have just started learning C++, and I have a great opportunity to learn some new things at an upcoming internship. What should be my next step? Computer graphics and graphics design has always sounded very interesting but also came across as an "art heavy" (if that makes any sense) sort of field. Am I wrong or is it a field that can be entered even without a lot of skill in art?
I actually have had s light interaction with autocad while taking a mechanical/ technical drawing class. What are the job possibilities with that kind of program?
I find the work prospects for people doing scientific and engineering based OpenGL visualization work are quite comfortable. I work as an independent contractor (mercenary!) because I like working for myself and don't enjoy working on long boring projects for other people. But I constantly come across people trying to hire me, or someone like me. Especially if you have any interest in working on mobiles devices and/or driver development for computer graphics hardware. 
(I maintain VC's STL.) If your courses allow you to, you should use VC 2013 Express. It supports more C++11 features (some of which you'll notice even as a beginner) and has fewer bugs (although as a beginner you are unlikely to notice the bugs in VC 2012). I taught myself C++ by implementing data compression algorithms, which have the advantage of being small and achievable by beginners (pure computation outside of file I/O, no big APIs to learn), but the disadvantage of being incredibly austere (essentially no UI, all work is invisible). I've given up on trying to introduce others to C++ via such programs. A few years ago, I took some free time and implemented a [Nurikabe](http://en.wikipedia.org/wiki/Nurikabe_\(puzzle\)) solver, which was quite educational and also less austere, although I don't know how good writing puzzle solvers would be as a beginner.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Nurikabe (puzzle)**](http://en.wikipedia.org/wiki/Nurikabe%20(puzzle\)): --- &gt; &gt;**Nurikabe** ([hiragana](http://en.wikipedia.org/wiki/Hiragana): „Å¨„Çä„Åã„Åπ) is a binary [determination puzzle](http://en.wikipedia.org/wiki/Determination_puzzle) named for an invisible wall in [Japanese folklore](http://en.wikipedia.org/wiki/Japanese_folklore) that blocks roads and delays foot travel. Nurikabe was apparently invented and named by [Nikoli](http://en.wikipedia.org/wiki/Nikoli); other names (and attempts at localization) for the puzzle include Cell Structure and Islands in the Stream. &gt;==== &gt;[**Image**](http://i.imgur.com/y1jV8vY.png) [^(i)](http://commons.wikimedia.org/wiki/File:Nurikabe_example1.png) - *Example of a moderately difficult 10x9 Nurikabe puzzle* --- ^Interesting: [^Puzzle ^Series](http://en.wikipedia.org/wiki/Puzzle_Series) ^| [^List ^of ^puzzle ^topics](http://en.wikipedia.org/wiki/List_of_puzzle_topics) ^| [^Puzzle](http://en.wikipedia.org/wiki/Puzzle) ^| [^Brain ^Buster ^Puzzle ^Pak](http://en.wikipedia.org/wiki/Brain_Buster_Puzzle_Pak) *^\/u/STL ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 51011:%0Ahttp://www.reddit.com/r/cpp/comments/1xhjwo/new_c_student_using_visual_studio_express_2012/cfbhsrj)
Of course, you will benefit most from technical talks if you know C++ quite well. However, talks vary in technical depth and some talks last year were not specific to C++. I don't know you, but do not forget that the program is aimed at students, not C++ gurus.
Just make sure once you reach expert level, that you at work don't take _every_ chance you have to whip out the most intricate but correct solution you can find to a problem. We have a guy that does this, and everyone gets annoyed when they have to read his code. Sometimes it might just be better to take the long drive for the sake of readability for mortal c++ programmers.
That's true, but remember that a true expert knows when *not* to use a tool. Templates can be a bit fragile and prone to giving huge incomprehensible error messages. The easiest workaround - don't write them unless you're sure you need them. Of course learning exercises don't count in that - being familiar with all the tools and how to use them is a good thing. But even then, that doesn't mean memorizing everything. 
The amount of work needed to maintain these libraries seems enormous and it doesn't look like it'll be getting any easier. Is the STL team big enough?
Does it have to be an array? If you're not allowed to use vector maybe you could implement a linked list. Otherwise to "grow" your array allocate a new bigger one, memset it to nullptr (just to be sure), memcpy the pointers from the first one into the new one, deallocate the old one and finally change "people" to point to the new array. As you don't change the location of the contents in your scenario all existing pointers to members of the original array will be still valid.
+1 for VC 2013 Express. I'm currently using and I'm pleasantly surprised by its C++11 support. As for a non-austere application, it can be hard without a library and without knowledge how things work (too much stuff to learn at the same time). I'm currently doing a file manager with boost (fs, asio, thread) and will integrate Qt later. He could do something like that maybe, like a shell. Something to navigate his hard drive.
You know what, I had a great time coding sokoban, reversi, draughts, chess (I mean, no UI, just std::cout, std::cin.. in this way you'll capture the logic of the game) I think you can do any board game/[turn based/non-realtime] videogame or, if you want to try network/socket, http client/downloader? Or a commandline telnet/irc client, but you'll probably find out you'll need 2threads (or select()) if you take the advises of the gfx libs, may i suggest you to have a look at [Lsystems](http://en.wikipedia.org/wiki/L-system)?
..I don't know why I'm surprised to find you are a redditor. I know it's not the part you're working on, but I'm hoping that user defined literals and member constexpr get into VC's compiler soon, I've been using them with a g++ project but want to port it. Keep up the good work though! A Nurikabe solver sounds like a good project if someone is into puzzle solving, but if not a program that lets someone manually solve one might be good - co-ordinates for marking tiles and an ASCII representation should keep it nice and simple :)
Well, I wish VC would support inherited constructor (using), it would improve readability when you inherit multiple times and have to write empty constructor. 
I remember seeing your videos about this solver. I linked them below for anyone that might be interested. Links to the videos : http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-4-of-n http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-5-of-n Link to code: https://skydrive.live.com/?cid=e66e02dc83efb165&amp;id=E66E02DC83EFB165!120
Even better. Code a mobile friendly version of that webpage...
Have a look at: http://www.cppgm.org/
SFINAE ftw.
If you want to get really good, then try to get a library into boost (boost.org). If you manage to pass the review then you can consider yourself an expert. If you need an idea for a project, you can a) look into the sandbox and search for an abandoned project that would be interesting to you b) help other, already existing projects to get through the review (there are quite some that have not or just conditionally been accepted into boost) c) look into "google summer of code"-projects at boost e) just think of something that you think is missing in boost If you don't want to commit to a project, there are very good ways to improve yourself by eg. e) providing patches for open tickets f) helping to "update" code for c++11/14 You can apply the last two points to any other project written by an expert, other posts already mentioned a lot of libs.
Just a stupid question if you don't mind. I've got a recent M.Sc. in CS, but no job experience. I think I have about 90% of the required skills for that position. Also, I'm a German, living in Germany and I have no idea how to write an application for such a position (I have some general ideas, but my resume is really not that impressive). Should I even bother to send an application? Or am I just wasting everyones time?
Ditch GCC for CLANG and get real error messages.
As someone who's worked with C++ for about 10 years, this is my project for the year: work on CLANG's refactoring tools.
Always send an application ! Especially if you are really motivated =) Either way, you'll might get a valuable answer on what didn't work out or what they really want. Write down every question they might ask, every library/techno, and work on it to the point you can have a decent conversation with the technical lead that you could reach.
That will hardly make him a better C++ developer.
GCC and Clang aren't the only compilers. That said, I'm aware that Clang gives better messages, but I haven't used it much. I've spent more time using the LLVM library than using Clang. I do wonder to what extent that's better messages when you're using standard library templates (which isn't really avoidable anyway) as opposed to writing your own templates. The consensus last time I checked was that error reporting for templates can't be particularly good in the absence of concepts - which I believe are expected to happen (in their new lightweight form) some time after C++14. One of the issues with C++ templates is the SFINAE rule - in a way, errors aren't errors. Combined with the fact that templates are Turing complete, and with no concepts to keep them under control, error reporting for templates is a very tough job to do well. Of course with standard template libraries, the compiler can know the intent of those (not just the implementation) so can do a lot better, which is the reason for the "I do wonder". 
I probably shouldn't comment on staffing.
Inheriting constructors [have been implemented](http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx) for the next major version. I want UDLs and member constexpr too, because the STL needs them! :-&gt;
I would hesitate to call that person an expert, then. Usually the most "correct" C++ solutions tend to be the cleanest looking.
No. It just annoyed me.
And Meeting C++ will have a student program of its own this year... :)
Looks nice, if it turns out to be as good as intelliJ supposedly is(from what I hear, no first hand), this could be really cool to use.
Yes, but from the video it doesn't look IDE isn't setting up the CMake text file to drive that, so it's not going to know that "abc.cpp depends on xyz.h and qrt.h". 
If you want to have a play at making 3D graphics, you'd probably want to start with a toolkit to get some instat gratification before you bury yourself in low-level stuff. I use OpenSceneGraph heavily, and it's a really cool way to throw graphics onscreen without having to re-invert every wheel.
OK. So you regularly commit suicide. My bad.
It's just a shame there are no plans to make this an IntelliJ plugin By reading the comments it also seems appcode isn't going to be a plugin of either So if you want to do everything but objective-c/c++ you but IntelliJ If you want objective-c you buy appcode If you want c++ you buy this new IDE Now i might just be cynical, but it really looks like that are starting to nickel and dime developers //edit Don't get me wrong I am not saying separate IDEs are a bad thing, but since appcode is objective-c, then it should (or cpp, of appcode) be a plugin of the cppide Also when I said reading the comments I was referring to jet brains comments, not some random fools
Your post is incredibly moronic. AAA games are all about performance. There is a measured cost to all of these actions. A lot of performance hits from things like cache misses, branch misses, LHS, unnecessary data copying, etc, all have measured costs. Understanding the hardware, you understand where stalls occur, what causes them, and techniques to reduce or eliminate them. To know in advance that something will be a huge performance hit comes a bit from experience - something that you either clearly lack or you're in the fortunate position of not needing to care about code performance, which if that's the case, why are you even programming in C++?
&gt; Your post is incredibly moronic. Either that or you're just a completely humorless ass.
Ah, the old "I was just joking, guys!" save when you say something incredibly foolish. Nice.
Actually, seems to me it was pretty obvious from the beginning...but whatever. I'm fine with you being a dick about it.
I'd like to get more information on how well it performs - specifically wrt indexing/code completion when dealing with large projects, that have dependencies. eg: 100ksloc codebase + boost + eigen + ipp + mkl + Qt. 
Ha! You're right, I am a humorless ass then. Good one
ho well... I guess [it isn't working as I thought](https://stackoverflow.com/questions/21687119/c11-inherited-constructor-using-and-move) \^\^; edit: well, it seems like a bug, how can I report it?
Integrated debugger I guess.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Huffman coding**](http://en.wikipedia.org/wiki/Huffman%20coding): --- &gt;In [computer science](http://en.wikipedia.org/wiki/Computer_science) and [information theory](http://en.wikipedia.org/wiki/Information_theory), **Huffman coding** is an [entropy encoding](http://en.wikipedia.org/wiki/Entropy_encoding) [algorithm](http://en.wikipedia.org/wiki/Algorithm) used for [lossless data compression](http://en.wikipedia.org/wiki/Lossless_data_compression). The term refers to the use of a [variable-length code](http://en.wikipedia.org/wiki/Variable-length_code) table for encoding a source symbol (such as a character in a file) where the variable-length code table has been derived in a particular way based on the estimated probability of occurrence for each possible value of the source symbol. It was developed by [David A. Huffman](http://en.wikipedia.org/wiki/David_A._Huffman) while he was a [Ph.D.](http://en.wikipedia.org/wiki/Doctor_of_Philosophy) student at [MIT](http://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology), and published in the 1952 paper "A Method for the Construction of Minimum-Redundancy Codes". &gt;==== &gt;[**Image**](http://i.imgur.com/W6N1jlu.png) [^(i)](http://commons.wikimedia.org/wiki/File:Huffman_tree_2.svg) - *Huffman tree generated from the exact frequencies of the text "this is an example of a huffman tree". The frequencies and codes of each character are below. Encoding the sentence with this code requires 135 bits, as opposed to 288 bits if 36 characters of 8 bits were used. \(This assumes that the code tree structure is known to the decoder and thus does not need to be counted as part of the transmitted information.\)* --- ^Interesting: [^Adaptive ^Huffman ^coding](http://en.wikipedia.org/wiki/Adaptive_Huffman_coding) ^| [^Modified ^Huffman ^coding](http://en.wikipedia.org/wiki/Modified_Huffman_coding) ^| [^Canonical ^Huffman ^code](http://en.wikipedia.org/wiki/Canonical_Huffman_code) ^| [^Arithmetic ^coding](http://en.wikipedia.org/wiki/Arithmetic_coding) *^\/u/c3261d3b8d1565dda639 ^can [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfbz1il)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 51812:%0Ahttp://www.reddit.com/r/cpp/comments/1xhjwo/new_c_student_using_visual_studio_express_2012/cfbz18m)
The better answer is to use both, their union is much better than either one of them.
If it's like AppCode, it'll be too slow to be usable even on small projects.
Could be. To my knowledge, visual studio pro or whatever its called gives you C++,C#,VB,F# etc..
Yes but that doesn't work on osx, xcode doesn't support Java
That's a good point - I don't recall seeing any debugging action going on there. Any idea what it's going to be like/modeled on?
I worked in Tokyo as a developer for 4 years - regular programming gigs would be around 8MM, banking-related programming salaries were between 10-15MM (closer to the 10 generally.) Of course this depends on the level you'd be entering. I don't know what junior programmers would make. edit: I also got other benefits such as bonuses (I got one a year) and tax-free housing costs (company pays your rent from your salary tax-free). 
&gt; implementing Huffman coding would actually be a good toy project. Yes! I found this to be incredibly educational. It's simple enough that both the forward and reverse transformations can be worked out on paper and understood by a beginner, yet it involves nontrivial coding, and does something useful. It also has a natural unit test (compress/decompress == no-op).
The CTP is an alpha, not meant (or licensed) for production use. It is definitely not an Update, which are offered automatically.
The best way to report bugs is through Microsoft Connect: http://connect.microsoft.com/VisualStudio If you provide a valid repro, Connect's front-line responders will confirm it and send it along to the product team (i.e. actual VC devs). You'll get E-mails when the bug is updated - you may not hear from us for a while, since we work through our bugs in priority order and there's always lots of stuff to do, but it will be assigned to some dev and remain on their plate until it's dealt with. I am currently working through my backlog of bugs (whose number I would prefer not to say); I feel bad that I am unable to provide timely progress reports to each user, but I would rather actually fix as many bugs as possible and then deliver the good news. Feel free to ping me (stl@microsoft.com) if you're curious about what's going on with a bug (I need the Connect ID which I can look up in our internal database). I do have the ability to directly file compiler bugs in our internal database, but (1) you won't get E-mail updates and (2) that is very much a donation of my time and I prefer not to give too much of it away. :-&gt;
If it is incomprehensible, you've done it wrong.
This is more of an issue with your hardware then the program, and you can always turn off indexing to improve it's speed. I've had no issues on my 4 year old laptop or my recently built desktop. Although this was with PyCharm and IntelliJ IDEA, not AppCode, as I don't have a mac.
thanks, I'll file a bug report (that's why I asked, I didn't want to burden you even more :p). edit: [Connect doesn't like HTTPS Everywhere](http://i.imgur.com/EuslH6D.jpg), but I was able to fill the bug report by disabling it. /inception
According to [cppreference.com](http://en.cppreference.com/w/cpp/atomic/atomic_init) it's provided for C compatibility. Yet another reason to drop C compatibility... Just use the non-default constructors and you're good.
&gt; drop C compatibility Then you're left with a whale of a language which doesn't even have the thing that makes the gross syntax sort of worth it. Also, most commercial codebases I've worked on have grown out of C projects.
I'm actually a student, but a non-traditional student. I've recently decided to go back to school to complete a second degree in computer science. I'm doing so online, at the University of Illinois - Springfield. The core language is Java (blargh!); however, this semester we're learning some C++ in our Computer Organization class. This experience with C++ (about one month's worth) added on to two C++ courses ten years ago are my experience with the language. I've always been interested in learning more C++, for several reasons. And I have been following /r/cpp for a little while now. I think I may very well apply!
That's the thing about C++ - it might have been a good idea once to drop C compatibility (or it might not have), but it's far, far too late to do it now.
It's weakness is it's strength. I would probably have never taken off if it didn't have the support. As I said, most of the C++ code bases I've ever worked on were old C code bases.
Learn from scratch. I'd recommend CppDroid app - new C/C++ IDE on Android. It has a lot of included C/C++ examples and tutorials. Blog: http://cppdroid.blogspot.com, Google Play: https://play.google.com/store/apps/details?id=name.antonsmirnov.android.cppdroid
Bloomberg seem to have published their c++ coding standards [here](https://github.com/bloomberg/bde/wiki/bdestds.pdf). They would take more than 10 minutes to read.
Me too! I've already had to implement one of these myself in my own project, it would be great if we could just use a standard one. Hopefully this won't take too long to get added.
Just a few tips, not C++ specific: * learn version control: git, subversion, mercurial. If you learn subversion, also learn one of the other two because they work differently (dvcs) * start side projects or try to get involved in open source. Real world projects will prepare you more than anything else, especially those where you'll have to collaborate with others with a dvcs * learn how to write unit tests. Automate them as hooks to VCS commits. * make sure your compilation is as easy as make install. You should not have to type more than one or two lines to compile and test your project. Those apply to any programming language and environment. Edit: also, please don't write code with 20 levels of indentation of embedded if conditions, don't write 200 line god functions, write sensible comments, and use good variable names. No one knows what "int myVar" is. Follow standard conventions and coding styles, but most importantly use the style they use unless you created the project.
The few pieces of advice you'll read in here already are good. Here's one big one they haven't really covered (though d4rch0n touched it a bit): Learn to work with other people's code. Working with your own code is easy(er) than working with other people's code, but being able to inject the idea of someone else's work into your own head is an absolutely critical skill in software development. Learn to do it while working with them. Learn to do it while working alone. Don't get hung up on bad design in existing code. Not every project can have great design. Just understand it.
Look at the underlying tool: http://cppcheck.sourceforge.net for more info
&gt; supposed to be pretty talented, and are absolute ding bats in the work place The former doesn't really mean anything relative to the latter. You can be a very talented *computer scientist* yet be awful as a *software engineer*. Degrees != job experience. So if you want the latter, you won't get it from the former, instead participate in foss projects and do internships or contract work to get your feet wet.
&gt; I'll be graduating this year myself and I feel I can give quite a bit of advice in this area. The former literally disqualifies you from the latter. In fact, let me give you advice instead: You still don't really know anything. The first 6 months of real work experience will teach you more than you learned over the course of your degree. The best thing you can do is save this post (yours), take it easy for a while, get a good job, and come back to it in a year. You'll hopefully realize that the vast majority of what you've said is naivet√© and hubris. e: You didn't have to delete your post man.
Does clang or gcc have compiler warnings for raw ptr usage?
Check out r/opengl. The top tutorial link on the sidebar is great. For general graphics, opengl, sdl, and sfml are great places to start. For GUI programming (as in, application dev), QT has come a long way and is very well documented too.
The seniors blame the new guys? Does that sound alright? Shouldn't have hired him with a single HR interview then. 
This thread is all wrong. There's one simple answer. **Don't know things you don't know.** This is what we all hate about college dingbats. They get themselves and others into trouble pretending to understand shit they dont. Don't worry about getting a job, some fortune 500 will be eager to hire you before you realize the honor of being a small cog in a very large machine isn't worth 60 hour weeks.
Any library will do provided that 1. You are interested in it, and 2. It is written in a pre-standardized, or C++98 style. I don't really have any off the top of my head. Sorry.
&gt;* learn how to write unit tests. Automate them as hooks to VCS commits. Hi, as sometime trying to write unit tests in a personal project for the first time right now, what do you mean by a 'hook' to VCS commits? The way I'm doing it is just calls to unit test functions in the main() function. 
One thing you can do with VCS commits is set up scripts that run at certain points in time, at pre-defined "hooks". You can write a pre-commit hook which will run on the current snapshot of the source before you even type a commit message, and a post-commit hook which will run after the whole commit. [Git hooks here](http://git-scm.com/book/en/Customizing-Git-Git-Hooks) Imagine a client-side pre-commit hook that ran a whole testing suite on the current state of your source, and failed the commit early if something failed. This can help reduce committed bugs, but it's also impractical if compiling and testing takes a long time. It might just slow down development. You can also create server-side hooks which reject commits that break certain tests. There's all sorts of methods to this madness. You might want to read up on [continuous integration](http://en.wikipedia.org/wiki/Continuous_integration), and look at this example, [Jenkins, an open-source CI server](http://jenkins-ci.org/). If you don't have a pretty good understanding of DVCS, you might want to read up more on git, one of the most popular DVCSs, and try it out before digging into hooks and CI. I think this really shows what you learn in the workplace and not in college, bringing it back to the original question. There's so much automation and methodology to collaborating on source code, and until you start resolving merge conflicts and breaking unit tests, you won't know what you're getting into. It's fun, it really is, but there's so much to coding in the real world that isn't taught in college (but should be, in my opinion!).
I would also add: * read code. Like, a lot of code. Almost any job you step into as a fresh graduate will have some component of maintenance, so get used to looking at unfamiliar, obtuse, and quite possibly messy (tabs AND spaces? shoot me now) code. Go surf github if you have spare time and just try to figure out what little bits of code do and how they interact. This is not really language agnostic, but as a skill it doesn't matter what language you're looking at. It's been over 10 years since I dabbled in Java (and it was nothing more than dabbling) but I can pull up almost any Java program and at least get a general idea of what it does.
First, I'd recommend checking out the side bar at http://www.reddit.com/r/gamedev If you want to jump in to gamedev right now you're probably best off using something like Unity/UDK/Source to get an idea of how a well structured engine is designed. That said, I like writing things from the bottom up so I'd recommend the following! * SDL2 for windowing/opengl context creation/input handling -http://www.libsdl.org/ * glLoadGen for interfacing with OpenGL - https://bitbucket.org/alfonse/glloadgen/wiki/Home * glm as a maths library, made to work like the functionality in opengl's shader language - http://glm.g-truc.net/0.9.5/index.html * LodePNG for loading images (libpng is distilled nightmares and other image loading libs like soil/devil are pretty bloated) - http://lodev.org/lodepng/ As for learning how to gamedev. The first major hurdle is graphics. If you take the OpenGL route I'm recommending then you'll want to do a few tutorials to get a rough idea of what is required to get started (http://open.gl/ and http://www.arcsynthesis.org/gltut/ are two of the better tutorials, at least as of 6-12 months ago). After that you'll want to pick up the opengl specification for reference (http://www.opengl.org/registry/) and jump in to trying to solve whatever rendering problems float your boat! Or if you just want to do more research rendering techniques then i'd recommend realtime rendering (http://www.realtimerendering.com/). Other than that you'll probably want to looking in to spatial partitioning techniques for detecting collisions (be it checking if the players click hit a UI element or a ray casted from the player in to 3d space, to checking if a platformer sprite hits the floor or a wall, to simulating cloth across 3d geometry). For that I'd recommend Realtime collision detection (http://realtimecollisiondetection.net/). Another thing you'll want to read about is Linear Algebra and Geometry. There are plenty of books on the subject, some specifically orientated around gamedev, but texts for generalized mathematics are often just as useful if not more so. From there you'll want to look in to whatever area that interests you. Game development is a real rabbit hole when it comes to specialist areas, you can quite easily work professionally solely on Graphics, Physics, AI/Pathfinding, Networking, Gameplay, UI, Audio, etc. So it's really up to you where you take it from there. That said having at least some fundamental experience in rendering techniques is useful for working with all those (a lot of the tools you would develop for Physics for example are somewhat dependant on graphical feedback to show you that they are working as intended)
As a highschool tard learning to program Im curious as to finding a resource on how to follow naming conventions.
The best rule is simply: follow the conventions laid out in the code you're working on. Even if it directly contradicts the coding standards laid out for the rest of the project. Coherent source files are better than slapdash application of differing standards.
That concept of learning to work with other peoples' code regardless of design is useful for any programming language and application domain.
Totally depends on the language, environment but most importantly, workplace (follow the team's rules, open-source too). It depends on the language because the entire grammar might allow different characters in identifiers, like question marks and exclamation marks, as in Ruby. You'll see something like foo.sorted? or foo.sort! to show it's either returning a boolean or modifying the object, instead of plain foo.sort which will probably just return a sorted foo without modifying it. Some languages allow hyphens, usually those are just subtraction or part of an operator like -&gt;, -- or -= Other langs have instances likeThis, most have classes named LikeThis, some have snake_case, some are incredibly short like in C, some Java class might LookLikeThisFactoryBufferedStreamReaderFactory. Globals or macros USUALLY_LOOK_LIKE_THIS. I see a lot of Python code in camelCase from people who came from other backgrounds, but I try to follow [PEP 8](http://www.python.org/dev/peps/pep-0008/), which I always recommend for Python. No one wants to see tabs in Python source. A few standards: * [GNU](http://www.gnu.org/prep/standards/standards.html#Names) * [Google C++ style guide](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml) * [Mozilla Coding Style](https://developer.mozilla.org/en-US/docs/Developer_Guide/Coding_Style#Naming_and_Formatting_code) * [PEP 8, again](http://www.python.org/dev/peps/pep-0008/) * [Github ruby guide](https://github.com/styleguide/ruby) * [some ruby guide](http://www.caliban.org/ruby/rubyguide.shtml#naming) * [Oracle Java](http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-135099.html#367) As someone else mentioned: read code. In this respect, read good, well maintained, mature code, that's been looked at and cleaned up by many people. Study the patterns and read any style guide they posted.
Other answers in here are pretty good, so let me just throw some advice in there.. eventually you **will** get bored of setting up your own code for creating a window, setting up vertex buffers, input, etc... When you get to this point, pick up a free copy of [Unity3D](http://unity3d.com/unity/download). You can do some really fast iterations and experimentation with Unity and it's pretty damn powerful. It's also a great environment to start learning shaders in (though you should know the difference between vert/frag shaders and Unity's proprietary *Surface* shaders). I'm the graphics programmer for a small Ubisoft-run gamedev studio. I'd be happy to answer any questions you might have about Unity or graphics programming in general.
humility, and being humble. If you can manage that, plus a willingness to learn and work everyone will love you. Its those "I know everything" people (who really don't) that piss everyone off and mess things up.
* Learn how to debug. * Learn C and start assembly. * Learn some RFCs, anything from TCP/IP or URI. This is what the internet is built on top of. * http://tools.ietf.org/rfc/index * http://www.ietf.org/rfc/rfc793.txt * http://tools.ietf.org/html/rfc3986 
I can't completely agree with this point. The overwhelming majority of coders and their code is just plain awful - aka utter crap. This is the case regardless of language, education, experience or other credentials. Like any creative field the garbage will tend to outweigh the gems by orders of magnitude. Take spoken word in literature as an example - most people are incapable of stringing together a bunch of words that result in something meaningful and deep but that also posses some form of viable pentameter. The advice perhaps could be reworded to something like: Find excellent pieces of code, and to study them thoroughly. It doesn't matter what language they are in, well thought out solutions are always interesting and completely comprehending them in the long term will always be rewarding - just like reading a really good book. Another interesting thing I've noticed over the years is that really well designed code tends to also be really well presented code. By this I mean everything from trivial things like code layout and formatting to variable, class, function, method naming and everything in between is extremely meticulous and an indicator of attention to detail by the author(s) 
This is not really about conventions, per se, but I find a good catch-all rule is that someone looking at your code for the first time should be able to identify the use of each variable based only on its name. Don't go overboard, but the days of having to condense variable names for space consideration are over. Also, there's a good chance you have autocomplete in your editor: don't be afraid of having descriptive variable names. That is: avoid variables named total, count, number, answer, or often x and y.
hahaha bubble sort.
Woah I hope I'm not working 60 hours a week when I'm a full time programmer. One of the things I liked was thinking this is a regular 9 to 5.
Considering the number of idiots incapable of that, it's at least a start.
&gt; try to get involved in open source Could you elaborate? This is something I've been interested in for a while, but I don't know what's the best way to start.
That is the type of thing I hear often, but is almost assuredly easy to google and seems to not really be worth learning just to know. If the problem domain requires a lot of sorting, then of course you should know this, but I have gotten by reasonably well never having used that (Not saying I am an expert or anything). I know roughly what bubble sort is, but not how it works, and I honestly don't really care. From my experience is school, that came after self teaching and a little work experience, that seems like one of those education trivia things that aren't extremely practical or foundational, even theory wise.
Experience counts. There are people who never wrote a line of code before their first college semester. And then only do so when they have to for projects or homework. If you haven't been programming long before you started your CS studies in college you pretty much are guaranteed to suck in the real world. Because a master in CS doesn't make you a good (or even usable) programmer. It only provides you with the theoretical background behind your (ideally already existing) programming skills. So the best thing you can do is to start side projects in your free time or work on open source, etc.
The easiest way is: Go to github, browse the projects there, find some that appeal to you (based on interests, programming language, activity, whatever) and start fixing the open issues - or add new features. Then send out pull requests. 
An `atomic&lt;foo&gt;` is supposed to behave as much as possible like a `foo`, so a default-initialized `atomic&lt;foo&gt;` has the same value as a default-initialized `foo`. The behavior is consistent. If you want your `atomic&lt;foo&gt;` to have non-default initialization, then you initialize it just like you would any other type. Ok, so "just like you would any other type" is a bit of a misnomer. `atomic&lt;foo&gt; bar = baz;` is ill-formed, since it works by converting the value of `baz` to an `atomic&lt;foo&gt;` and then trying to copy/move construct `bar` from it which isn't possible for an `atomic`. You need to use direct-initialization or copy-list-initialization forms: atomic&lt;foo&gt; bar{baz}; atomic&lt;foo&gt; bar(baz); atomic&lt;foo&gt; bar = {baz}; 
&gt; don't write 200 line god functions God functions are typically over 6000 lines by the time they grow to their full potential. Just keep in mind, most classes in your OO project should be &lt;200 lines total, or you're not doing OO but object-encapsulated procedural programming. &gt; write sensible comments 1. This is so very hard. Nearly all comments I see are worthless. 2. When you finally learn how to write proper comments, you start to see that all places you put comments you could/should've written the code such that whatever the comment is saying is visible from the code instead. &gt; and use good variable names Wow, is that hard. Seriously. The longest discussions the past months at work were about variable and class names. The design is pretty trivial to convince people - heck, you can show things to be wrong with it - but names, dear lord.
&gt; (tabs AND spaces? shoot me now) How about a C++ project that includes PL/M and Perl files? So to maintain it you need to read PL/M? Or how about a build python script that invokes CMake which invokes regular Make which invokes Perl which invokes a handwritten compiler to recompile to new source to put back into the build script, all scripted together with a few shell scripts? That nearly always gives proper incremental build results, except for a few common corner cases that are near impossible to fix.
In school, you create new code. At work, you have big chances to do maintenance programming on legacy code. So if you want to prepare for this, get involved in some open source project and learn how to debug some shit code while following the original programmers philosophy.
Reminds me of when I was in college and a classmate of mine (also a CS major) was confused about how computers stored numbers in RAM (are they stored in decimal or hex?). I explained how they are actually stored as electrical charges which represent binary values. He did not believe me.
i don't see how one of the lowest possible levels of abstraction (electrical signals) will be of use to a programmer (CS major).
If you need to google a bubble sort during a JOB INTERVIEW, you're going get shown the door. And if you can't explain why a bubble sort works the way it does, and why it doesn't scale, well then... Anybody can google for the answer for hard and tricky stuff; it's the trivial shit like this that people coming out of college should understand, but based on recent interviews, apparently don't.
Indeed. If you can't read other people's code, and it seems mysterious to you, then that's probably how they feel when they read your code! I've been coding for 15 years, and sometimes I'm mystified when I try to read code I wrote last year. Reading other's code, whether it is good or bad, will be useful, even if only to get a sense of what things to avoid.
Of course nowadays it serves no practical purpose when Google is right there but I see it as a simple example of problem solving ability. Admittedly I may have some bias: Some time back in mid 90's when I discovered QuickBASIC and poured in all the free time I could playing around, I ran into a problem of trying to sort an array I couldn't find anything in the help file to do what I wanted so I had to 'invent' my own and came up with what I later learnt to be called bubblesort. The obvious performance issues plagued me for a while and after a couple of modifications I ended up with what a later learnt to be called the cocktail sort.
I'm rather of the opposite opinion; if you think some piece of code is bad, it's probably in 75% of the cases because you - haven't looked at it closely enough ("it looks ugly, so it must be bad", "it uses prefixes for everything, so it must be bad", "it uses camelcase (or whatever other/old/outdated conventions you hate) style, so it must be bad", "it has deep inheritance chains, so it must be bad") - you haven't understood it properly ("this seems totally unnecessary") - you haven't thought about the problem enough and/or haven't tried to solve the problem yourself ("obviously this approach is stupid, this other approach that I've never actually tried in practice is clearly superior") I only ever commit to saying that some piece of code is bad, if I have actually solved the same problem in the same language before, and I'm sure that the code does it badly/has bugs/is insecure (and possibly can back that up with numbers, e.g. benchmarks).
This. So much this. When I was at University, the lecturers would constantly be talking about a life time of learning. They weren't going to be giving students everything they'll ever need to be able to work in industry. After all, a standard CompSci course needs to cover too many subjects in the broadest sense, just to give the students a flavour of what _*MIGHT*_ be needed. As an example, the CompSci degree I took focussed on the C family of languages and Prolog for the main taught modules. But students were actively encouraged to pick up smatterings other languages, in the hopes of understanding different algorithms and techniques in the different languages and paradigms. I'm 2 years into my career as a developer (graduated in '08, was unable to find developer work until '11, but worked on many projects in my own time), and I'll still be learning things in 5-10 years time. I'm expecting frequency at which I learn new things to drop within the next few months. Then again, the boss could decide that we need to switch over to a completely new language of paradigm.
&gt; or atomic&lt;foo&gt; bar = {baz};. That is copy-list-initialization.
&gt; You can be a very talented *computer scientist* yet be awful as a *software engineer*. Heh, I can immediately think of a vivid and extreme example of this -- a 3D editing application for mesh and point cloud data called MeshLab. It's immediately obvious that the people writing it are geniuses and highly skilled subject matter experts on mesh manipulation algorithms, but are utterly clueless about writing an effective and stable software application with an intuitive user interface.
Your link goes to "Page not found."
&gt; Just keep in mind, most classes in your OO project should be &lt;200 lines total, or you're not doing OO but object-encapsulated procedural programming. Which is a perfectly fine methodology for certain things. I know this is controversial, but I'm a big believer in "make functions/classes as long as they need to be". If you're doing the same thing in multiple functions, obviously that thing needs to be pulled into a common function and called from both sites. But if you're looking at your code and it seems reasonably laid out and straightforward and you start cutting it up just to make each piece shorter, stop. Our brains are a lot better at dealing with one linear piece than dealing with emergent behavior distributed among 30 little fragments. If you have one function with a decent name, navigating the code is easier, understanding the call chain is easier, and seeing the big picture of the architecture is easier. Give those benefits up when you have to in order to have a logically coherent structure. Don't do so for no reason. That said, a logically coherent structure will generally involve more short functions than long ones, but my point is let the sensibility of the design guide the choice of how to break things into smaller pieces; don't let your design be dictated by the need for smaller pieces.
The general rule of thumb I give people about this is: don't kill yourself if you don't have a vested interest in the company. So if you're a part owner of a startup, or have stock, consider putting in additional sweat where you'll know that it will fatten the bottom line, and give your options a boost in the process. If you're working for some soulless bodyshop, slaving away on federal contracts, don't work overtime unless it will cost you your job. In either case, sometimes you have to make up for lost time, or salvage a project, which will have you working longer weeks on occasion; software is a fickle business. Edit: As a programmer, you have the ability (unlike many other disciplines) to build a company around your skill-set, over a weekend or two, with almost no resources. Your free time should be viewed as an opportunity to increase your earning potential, one way or another, should you be encouraged to spend it writing software. Burning that extra time under a salary, with no additional compensation of any kind, is an opportunity lost. Edit x2: The exception to this is if you somehow land a job where the expected degree of dedication is at a higher level than your typical job, with pay commensurate to the added responsibility. Positions like this typically involve being "on-call" to fix stuff in the field, or to be available at a moment's notice when horrible bugs manifest. Such positions *should* command a salary far above average to compensate for the ridiculous hours and personal demands; i.e., you're being paid for your "free" time. But that's not always the case. If the responsibility to pay ratio isn't your cup of tea, take the job if nothing better presents itself, but consider moving on as soon as possible.
Clearly you're significantly less jaded than some of us... ;)
I haven't experienced that. The people I've had issues with know *nothing*.
There's [PythonQt](http://pythonqt.sourceforge.net/) if you're willing to use Qt and its reflection. Also, [updated for Qt5](https://github.com/caetanus/PythonQt/tree/add-qt5-support).
Fixed, thanks.
Dunno, I've been programming (as a hobby and professionally at times) for almost 20 years now, and I've read a lot of code... and some code that I thought looked the worst turned out to be of the highest quality. At any rate, before you claim some code to be bad, consider that that's a very strong accusation (and usually ends up hurting someones feelings, which seldomly makes you friends) -- you need to consider in what context the code was written for, on what kind of deadline, with what kind of constraints, ...
What he said. Do your best to not work outside the office if you don't have to. My last job was crazy busy, 60+ hour weeks, never having a day off. After about 6 months, you're just dead. After around that time, I'd mostly just show up and sit and stare off, completely unable to get any real work done. I recently switched to a new company with much closer to 9-5 hours, and I do &lt;5 hours overtime a week. I'm so, so much less stressed out. But good luck /u/HerpesAunt, you may have to do your time in a crazy environment for a year or two.
&gt; I'm expecting frequency at which I learn new things to drop within the next few months. You probably won't. I'm still constantly impressed with how shitty my 6 month old code looks. No matter how good I get, no matter how much experience I accumulate, 6 month old code always looks like utter garbage to me. When it doesn't? I usually decide it's time to start looking for a new opportunity.. Always learn, always better your skills.
Reading your comment just made me go open some code I wrote last year. ... I wish that I hadn't now.
The most sensible alternative is to keep your C++ and your Python in different processes. Now that everything in C++ is threaded, integration with thread-hostile libraries like Python is problematic.
It seems inevitable that any time you mention a dislike for your programming job on the internet, someone will come by and tell you to quit and find a new job because there are opportunities out there. I hate when people do this, but now I guess it's my turn. I started in a position that encouraged overstressed programmers. It was a startup atmosphere with pool/ping-pong/liberal alcohol policy/etc. "We play hard so we can work hard". Which really means "we expect you to work plenty of overtime and don't use any of those fun amenities around the office other than during lunch time or your manager will come talk to you". If you find yourself in a position where there's a strong expectation to put in lots of overtime, please do yourself a favor and consider what you're doing. Even if you feel like you enjoy it... just take a step back and think about it.
I thought the point IS to read terrible code though. For something nice though, dig into boost.
&gt; You can be a very talented *~~computer scientist~~ software engineer* yet be awful as a *software engineer.* FTFY. Talented at something doesn't mean good at it. The dingbats are the ones who prove this without realizing it. 
Cython! Cython totally rocks and works for C and C++. There's a bit of a learning curve, but it works exceptionally well - plus, it won't just interface to your C++, it'll compile your Python into C code if you ask it to...!
If you do have conflicting finals (even a lot of them), you will probably be able to convince your school to reschedule them if you're accepted. We can help you figure out how to make that happen. About half of the program organizers (including myself) are students, and we have experience dealing with issues like that.
When I was closer to your experience level I actually had a problem with this, as I'd look at old (personal, not on the job) code, declare it crap, and refactor it. Then look at the next chunk, which is now 6 months old, refactor it. 5 months later I realized I'd rewritten the whole damn thing, and the first block, that was now ~6 months old? Crap! You just have to accept that it'll happen, and move on to other code. (Obviously sometimes you should refactor, just be smart about it.)
always use single letters for function and variable names. This makes your code smaller and faster! if you run out of letters you can add numbers a1 a2 a3 or aa aaa etc. 
Thanks for the info, but I am unable to reproduce the problem. Is it still a problem on your end?
&gt; I thought the point IS to read terrible code though. Exactly! As for recommendation for good code to read I found the clang code pretty neat as well. They don't try to be too clever so what you see there might translate pretty well to other code bases. Why not write a new static analyzer or fix (wishlist) bugs in clang-format? Might even get you a job ... Boost on the other hand has in a lot of places Deep Template Magic or workarounds with Boost-specific macros and might (hopefully?) be smarter than the average code base most of us might have to realistically deal with.
It should be http://stevewedig.com/2014/02/03/software-developers-reading-list/
Just wanted to let you know the old saying "in theory there is no difference between theory and practice, in practice there is". College will teach you the theory which is huge and a critical big part of it. In the real world 99% of the code is absolute shit and doesn't follow any of the well established rules you learn in school. It's brutal and heart-wrenching but you have to deal with it. You also have to get good at implementing solutions in less than ideal situations. Getting a job and working 40+ hours per week actually churning out code is an amazing thing. You will grow immensely as a programmer. After I finished my CS courses I felt like I knew a lot about programming and I was right. But that's the starting point. up until then you just needed to do a few assignments a week at most. I learned more about coding and getting shit done in the first year of working than I did from my degree. BUT without the degree you will never learn the most important aspects of software engineering through work alone. A degree is like getting through the tutorial in a video game that has tons of really crazy complex controls. Sure it's an accomplishment but actually playing the game is where you get good at it. 
If you're not using an IDE or editor that automatically converts tabs and space for you, you really should. 
Try [PyCXX](http://sourceforge.net/projects/cxx/). The main site was't updated since 2011, but library is constantly getting updates. Its relatively small and doesn't contain huge amount of "template magic" - like boost.python does. Still its a good choice when you want to interact with python and don't want to bother about constantly creating wrappers around Python C API.
As a Computer Engineer, they're pretty important for me. You don't have to understand how to design these circuits, but understanding that they're electrical signals can help you comprehend things like one signal on a bus at a time, or why you need CRCs on RS485 runs, or a myriad of other specific circumstances that can arise out of layer 1 issues. Understanding the whole system can help you understand why certain behaviors arise.
I was mostly joking. There are far greater horrors than mixed indentation. ^^Like ^^Whitesmiths ^^style.
&gt; This is so very hard. Nearly all comments I see are worthless. I'm usually inclined to agree. There are two reasons why comments are worthless: 1. They are of the "assign y to x" variety. 2. They are never updated with the code. If at all possible, writing clear and concise code is far preferable to requiring a comment to describe what the code is doing. A "good" comment to me describes the reason for the existence of an otherwise redundant or extraneous piece of code. // This is a fix for TICKET-123. Without this line the Moon will explode due to... x = y; &gt; Wow, is that hard. Seriously. Absolutely. But I think it is easy to agree that variable names like 'aa' and 'i' (outside the context of very concise loops) should all go away. One of the most difficult to understand bits of code I've ever read was a mathematics solver written in C++ by a physicist. I (more or less) understood what the goal of the code was, but _every single variable_ was simply two letters mashed together, FORTRAN style.
I use a mix of boost.python and the c api, I have to ask what do you need from the api that boost.python doesn't supply? (I'm just interested)
You can still use multiple parallel threads when integrating C++ and Python. You need to make sure that C++ calls into Python invoke Python's GIL. But Python calls into C++ can be executed in parallel without any lock.
I just used Boost.Python in a new C++11 project. I had absolutely no problems. Just because it hasn't been updated doesn't mean it's worse than the alternatives. Personally, I can only say good things about it. Furthermore you possibly already have boost as a dependency, and if it's not you now have a good reason to add it with all the other great things it brings (Filesystem, ASIO, Spirit, Containers....)
I switched from Python to Lua (Lua as scripting in C++ apps). Much better!
tracking header dependencies shouldn't be part of the cmakelists.txt anyway. That would require re-running cmake for every single incremental build where anything has changed. Instead, tracking header dependencies should be done in the underlying build system, and the cmake generator should simply do whatever is necessary to configure the build system to track header dependencies. (And if the underlying build system has no capability to track header dependencies then it is simply not adequate for C or C++.) For example Ninja uses dependency files, so the Cmake ninja generator creates ninja build files that create and use dependency files (using the gcc flag -M or the cl.exe flag /showincludes). So Cmake generated ninja build scripts correctly track header dependencies without unnecessary re-runs of cmake, and incremental builds remain fast.
libperl++ is quite nice. :P https://github.com/Leont/libperl--
Are the Python headers macro free? Macro namespace clashes is one of the big reasons I've found to insist on proper C++ wrappers for various C APIs. Sometimes things can even silently be screwed up.
Did your project use setuptools? If so were you able to integrate the build of the C++ module with setuptools, so that setuptools could automatically locate any external libraries required for the build?
That doesn't contradict what arvarin said, you can have python run in a different process, and still use it to script/control behaviour of your application. GIMP does it that way, and it works very well.
They probably aren't, thought I can't be certain since I haven't actually read the headers (their docs are fine). Macro free seems like a pretty strict restriction on an API to me.
For the same reason that any other type of overloaded operators can modify global state -- because someone might need that. There is no actual definition of what "pure" means at the language standard level, and constexpr functions would be too restrictive.
Well I don't really mean zero macros. It's just that with things like these old C VMs I've seen dozens of short name macros that run a real risk of clashing. I've even seen lower case strings like "eof", "open", "close", and "type" redefined as macros for portability purposes. Stuff can build fine but then mysteriously not work until you figure out what #undef is needed.
I find it odd that nobody has mentioned SWIG yet.
C++ doesn't have any way to enforce purity (though it's been suggested and I think it would be a good idea), and C++ also doesn't generally just disallow things for minor improvements in safety. If a `pure` annotation were added then it probably would be good practice to use it for UDLs most of the time but I don't think there's any strong motivation for the language to require UDLs to be pure.
&gt; An atomic&lt;foo&gt; is supposed to behave as much as possible like a foo, so a default-initialized atomic&lt;foo&gt; has the same value as a default-initialized foo. Actually a default-initialized `atomic&lt;foo&gt;`: &gt; leaves the atomic object in an uninitialized state. _&amp;mdash; C++11 29.6.5 [atomics.types.operations.req] /4_ So a default initialized `atomic&lt;foo&gt;` does not have the same value as a default initialized foo.
How would you implement a UDL for a `std::string` that doesn't mutate global state and always returns the same object for the same input?
If you are just calling C++ from Python then you may want to take a look at [CFFI](https://cffi.readthedocs.org/en/latest/). Armin Ronacher has a good blog post about how to make it work: [Beautiful Native Libraries](http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/). A nice plus to this approach is that your C++ library would be easy to use from PyPy, as well many other languages.
I agree. Sometimes you should break the rules. They are really just smart guidelines that work most of the time. Goto isn't always harmful, and sometimes globals are ok, etc. It's just that it takes experience and mastery (which I don't claim to have) to know when you shouldn't follow best practice.
It's even better to create one global int array and just store each value into its indices to save variable names!
It depends! Some start-ups can have grind sessions where everyone puts in tons of hours in a few weeks, but slows down vastly later (or maybe not). Some big businesses, you could come in at 9:10 and leave at 4:59, and be paid generously. Also, you could get a ton of experience and become a consultant, and put in 20 hours per week and get decent money if you don't mind knowing you're getting a lot less than you could if you put in a full 40. You find the right workplace and you'll work however suits you best.
Lua environments are also surprisingly cheap to create, so doing things like running user-supplied scripts in their own sandboxes can work fine even with hundreds of scripts loaded at once. It sort of makes me sad that being a well-behaved library makes Lua stand out. The idea that a library should store all of its "globals" in a context struct that's passed to each function is not an even vaguely new or radical idea, yet so many commonly-used libraries don't manage to do it...
Rules like "never make a function longer than X lines" are best viewed as a learning exercise. A code base with no functions longer than 10 lines is going to be an utter nightmare to read and understand, but a month coding in that style will give you as much practice with finding good ways to factor logic into understandable chunks as a year of coding normally. You simply can't build up a good understanding of when to break the rules without spending some time following the rules and seeing in which circumstances they actually cause problems. Similarly, while I'm not particularly a fan of test-first TDD outside of very limited situations, I still think everyone should do it for a while, as it forces you to learn how to write testable code.
The next time you're annoyed by a bug in a piece of software you use (that's open source), try to fix it. There's a pretty good chance it'll take you a week just to get to the point where you can build the program and start investigating what causes the bug, and you'll probably be completely lost with no idea where to start looking, but that's okay. Learning how to dive into an existing project is half the point of this. If you do manage to fix the bug, find out how to contribute the fix to the project. If they're on github this is usually easy; if not you probably either need to post the patch on the bug tracker or mailing list. You will probably need to revise the patch several times. Do not get frustrated if they want to change a bunch of seemingly trivial details or do things in what seems like a stupid way to you; project maintainers frequently want an entire code base looking like they wrote it, and emulating another developer's style is another skill that takes practice (but is very important, since it's pretty much the same skill as *understanding* another developer's code).
It depends a lot on why you're looking at the code. If I'm adding a new feature to a module that's been chugging along in production with no bug reports for the last five years and my initial reaction is that its completely insane, then I'm going to assume that there's good reasons for all of the weird bits that I simply don't understand yet. If it's a half-working mess that I need to fix a giant pile of bugs in, then I'm much more willing to simply assume that the author was incompetent. There's the occasional cases where it was a competent developer who had no choice but to write a nightmare (due to it just being a very difficult problem to solve, or external constraints, etc.), but those are usually clearly documented as such by the comments in which the author attempts to relieve their shame.
I'm going to guess you haven't used SWIG much. ;-)
This is a killer reply. Enjoy your reddit gold!
Would be great to have it also in VS2010
The people developing the Rust language (which is somewhat like C++ but with extra compiler enforced safety) tried to implement the concept of purity but [failed](https://mail.mozilla.org/pipermail/rust-dev/2013-January/002903.html) due to the fact that actually defining purity turns out to be quite difficult.
This is an error in the text of the specification, see [LWG active issue 2334](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2334). Implementations with which I am familiar ([g++](http://coliru.stacked-crooked.com/a/fb670db753498927), [clang](http://coliru.stacked-crooked.com/a/7d1730ed16973364), [VS2013](http://rextester.com/NWOYST44016)) all correctly run default constructors. In any case, I suppose I stand corrected: the default constructor is currently broken in C++11. EDIT: [LWG 2165](http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2165) is related as well.
That was my feeling too. Although I guess consistency becomes more and more important the larger the number of developers you have, and they have a lot.
Well, that makes sense. Not being able to allocate memory makes things much more difficult.
Nope. I've had Python header clash it was a massive pain.
Operator overloading, almost never. (Unless I'm writing new types that really really... really are suitable for operator overloading) -- EDIT for clarity: for mathematical operators lilke / or * or the comma operator. Very little preprocessor macros. Other than that, I use everything under the sun to get the job done.
I never use most features of C++. That's not saying much, because it's a huge language. Try reading the standard and figure out how much of the language you use. Probably not much.
(Not a guru here, just a guy who types in C++ code). * exceptions - yes (can't use half of the standard library without them anyhow, many language features like operator overloading don't work without them) * operator overloading - sparsely; dont write that kind of code, so... I do use conversion operators, that come in handly when interfacing with C code * run-time polymorphism - often. It's IMO the normal way of using C++ in app-level code (which is what i mostly do) * RTTI - virtually not using it; notable exception: when reporting an error for "tech support", I use it to spill exact exception class name to error output * templates - not often, but yes; love to be their user, some template-based code is sweeeeet ;-) * big fan of RAII/ScopeGuard here As for C++ as C with classes - there's little point. Too constrained to me. Further, I consider C to be too dumb-a-language, something that belongs to vestiges of history, so the mere idea of "C with classes" puts me off big time. Having said that, "C with classes (but no runtime poly)" is most certainly interesting for parts of the OS kernel (not that it'll happen anytime soon in a major kernel, just sayin'...)
I agree with you, but I've worked with too many seasoned professionals who still cling to the rules as some sort of laws of software physics.
This is one of the nicer things about c++. You never wrote your own iterator for a custom data structure? Your own custom pointer? Your own array type? You never override operator=? Equality comparisons? Less than, greater than? Never overrode operator() to make a functor type? Honestly, if there was a feature you *should* use, it's operator overloading. It's not obscure, hard to use, or uncommon. On the contrary, it's useful, idiomatic, and often makes for good interfaces.
I avoid leftover cruft from C where possible. I don't use NULL, new, delete. C with classes is the wrong way to go about learning it. Use the STL. Use smart pointers. Use auto/decltype. Use templates. Use move semantics (rule of 5).
Love these, keep them coming. Also, I've written N3829 (apply) on my own plenty of times. Would love to see it in the standard.
CONCEPTS!!!!!!!!! Please for the love of the great programming gods. I would be all on board helping to implement this. I think this feature would revolutionize the language (again).
Okay, I seldomly write "tainted" operators (tainted in that they typically have a very specific notion, from mathematics or operations on stl datastructurs). I surely write operator(), operator== and operator= and conversion operators regularly. I dislike overloadings of / and weird subscript semantics, which I get to fight with on a regular basis as some people in my codebase love to overload operators when a method call would have been a more expressive choice.
Well, that's very different haha. Yes mathematical operators only make sense for mathematical entities. For example, a vector class, I think is very reasonable to overload operator* or operator/ for scalar multiplication and division and operator+/0 for vector addition and subtraction. The mathematical operators often make sense for iterators and pointer types too though. Usually, you want ++ to mean traversing the spine of a structure or something. The + and - operators would need to be overloaded accordingly. The comma operator is definitely the odd one out of the bunch, and with variadic templates and initializer_list, I see very little reason for it to exist now.
The hardware I use most regularly has no exception support, so I don't use those. constexpr: This hasn't been implemented yet on the compilers I use. Inheritance: I often find myself using templates instead. I think this is one of those things often used unnecessarily, tbh. On my larger projects I've used this properly and extensively.
What about `op&lt;&lt;` for streams?
&gt;Further, I consider C to be too dumb-a-language I don't even
I never liked the operator&lt;&lt; for some reason, it's freaking verbose to write something out to a stream. But then again, I don't write to streams all that much, so I usually don't need to overload that one all that often.
&gt; (If we were sure that vec_ is of type vector&lt;Entry&gt; we could use emplace_back instead ‚Äî for performance.) Time to be pedantic. There is no performance benefit to using `emplace_back` in your use case all it does is obfuscate the code. 'emplace_back' is for inplace construction, such as, v.emplace_back(arg1, arg2, arg3); Not really for inserting an r-value reference (as is returned by `make_unique`), as `push_back` has an R-value overload for exactly that case. You may however get cleaner error message from push_back because it's overloaded rather than a variadic template (say if you wanted to `push_back` a type which doesn't publicly derive from your base or whatever.
I don't use the following: a) C features: * malloc/free. * pointer arithmetic. * NULL. * C arrays. * structs. * the C preprocessor. b) C++ features: * new/delete. 
It's a shit load less verbose then printf'ing everything. Typically I write `op&lt;&lt;` because that also means I can then write a 3 line `to_string(v)` free function, get to use `boost::lexical_cast`, use the std streams including io, file and string streams and is generally regard idiomatic.
&gt; Use move semantics (rule of 5). In general, no. Use rule of zero: http://flamingdangerzone.com/cxx11/2012/08/15/rule-of-zero.html _Only_ use rule of 5 if you are writing a class that manages a resource (e.g. a smart pointer, mutex,...). In that case, rule of 5 is almost the _only_ thing that class should implement.
I completely agree. Much better to use a string formatting library and C++11 variadic templates to get type safety.
Interesting! I think I'm going to use this today!
These are my experiences for my personal ISO-C++-projects. I am currently in a team to develop something with Qt, where many of these things do not apply because the framework forces us to do them. (It really makes me hate Qt.) * Inheritance: Rarely for something other than template-metaprograming. If I needed to do something like that, I would prefer type-erasure (which is internally implemented via inheritance but works very different). * new, delete. The only cases where I use new is in the implementation of make_unique or if it is a placement-new. delete is most often a sign that you fucked up somewhere, so I don't use it. Exception: pimpl doesn't work that great with unique_ptr, so I once used a blank pointer with manual delete in the dtor for it. * Templates: I really like both using and writing them. * Operator overloading: Whenever an operator should be overloaded, I do so: Very often for operator= (mostly with =default), often for comparison, rarely for arithmetics ‚Ä¶ Note: I consider it a terrible bug in the language-design that we do not have a concatenation operator for things like std::string forcing us to abuse operator+ * RTTI: Rarely ever. Mostly useful for debugging * free functions: often * template-metaprograming: whenever it solves a problem well, which is kinda often * blank arrays: Never except for argv. I had to ask for the order of the sizes in multidimensional ones a short while ago. With std::vector and std::array it just isn't worth it. * blank pointers: Rarely ever: I tend to use them to implement my own smart-pointers that say with their type ‚ÄûI am not null and I am not owning‚Äú. * Exceptions: I throw one, when there is no obvious other resolution to a problem * try/catch: rarely. I don't mind letting an exception fall through everything most of the time. I know I should catch them in main, but most of the time the actual exception is more usefull to me. * multiple-inheritance: I think I have never used it because I never came across something that really was two things. * virtual inheritance: Never because I never used multiple-inheritance * RAII: everywhere * smart-pointers: Since I rarely use runtime-polymorphism, I rarely have use for them. If I need one I prefer unqiue_ptr. * Stuff inherited from C: Rarely since most of it is ugly and obsolete. * stdlib: Whenever possible 
Is it because you allocate everything statically that you don't use new/delete? Even with smart pointers you have at least use new.
I have. I mean sure, it's a little rough around the edges, but it's been around forever and it's multi-language. Really thought more people would be using it.
thouth, structs are fine for types that just hold data. sometimes one just needs that and not more.
With C++11 the need for `new[]`, `delete[]` and `delete` is pretty much gone. And even `new` is not needed anymore for shared_ptr at least since there is `make_shared`. With C++14 on the way we also get a `make_unique` that directly gives you a unique_ptr instance. And then, the top-level user code hardly needs `new` anymore. Of course, low level library stuff is another story. `make_unique` has to use `new` somehow and other things like allocators probably still use `new`, too.
The overhead of the bindings from a scripting language is already high. In many cases I don't think dealing with IPC on top of that is feasible.
It would save a move constructor and destuctor of an empty `unique_ptr` but I agree that this is negligible. The problem I have with `emplace_back` in this case is that I don't think it would compile. `emplace_back` accepts parameters to the constructor and not to an arbitrary `make_unique` helper function. One could use `emplace_back` with `new` I suppose ~~but then we would lose the exception safety (we would have a leak in case of exception in `Entry`'s constructor)~~. Scratch that, by using `new` with `emplace_back` the program will be exception safe IMO. 
Oh I didn't know make_shared constructed the object. I thought it just took a pointer to the object. Cool!
The fix is good, provided the number of elements is relatively small. Otherwise it may just break the code, if there is not enough memory to hold two vectors of entries at the same time. All that said, a very informative read. As always.
&gt; Scratch that, by using new with emplace_back the program will be exception safe IMO. Nope, it's a leak. You say new X, call emplace_back(), but if the vector has to reallocate and it throws, the X will leak because a unique_ptr hasn't been constructed yet. 
How about std::rel_ops?
 &gt;I am new to c++ and the feature list is fairly daunting to me. So my question is, do you gurus use most or all of these features, First let me say my C++ is extremely rusty as the little bit of programming I've done lately has been in Python, Objective C or MS Access (shudder üòø). However given the little bit that I have done, it would seem to be extremely difficult to use every feature of C++ rationally in a program. So it might be easier to state what a person has used. In that regard the standard library is a big deal as such make as much use of the containers, streams and file handling as is possible. Use RAII! &gt;or do you mostly use c++ as c with classes (I am tempted to just use it that way ;))? If you are tempted to use it that way don't expect to get many professional assignments, certainly not from companies with any sort of standards. C++ is a vastly different language than C, to use it as simply C with classes would be missing out on a lot of functionality. However as mentioned above I'm not sure it is possible to use every single feature of C++ rationally within one program. You fit the features you need to the task at hand. 
&gt; b) C++ features: &gt; * new/delete Sounds like you don't use Qt.
I think it goes back to showing why defining purity is surprisingly slippery. In this case, it shows that including value objects along with simple values is troublesome, rather than as innocuous as it first seems. Functional purity arose in functional contexts rather than OO contexts, and the fit is imperfect.
If I need to use Qt, then I use new/delete.
I create the custom allocator and then allocate memory as the allocator interface requires. 
Maybe, but I don't like the class/struct dichotomy, so I always use class.
I am using std::make_shared for allocations. 
This is somewhat my picture too, nicely exposed :)
motivation against function-try-blocks?
but how do you do it without new and delete? 
Thanks for pointing out that issue. I note that its status is new rather than ready or something else indicating that the proposed resolution has been accepted. Hopefully it does make it in. libstdc++ and VC++'s implementation do seem to perform the default construction, however libc++ [does not](http://rextester.com/WKS42818), at least in that version (I'm not sure if this has changed in newer versions). So it seems one has to be careful about relying on this even in actual implementations.
The rule of five has that embedded. If you don't need to write a destructor, don't do it. Also, if you are using a smart pointer, you shouldn't need a destructor. And what do you mean rule of 5 is the *only* thing that class should implement?
The last time I tested, [Herb Sutter's implementation of pimpl](http://herbsutter.com/gotw/_101/) worked perfectly with `std::unique_ptr` for me.
How do you use run-time polymorphism without RTTI?
Forgot that one - yep, I never use it.
They're not evil, I just never need to respond to base/member ctors throwing.
Very cool indeed.
I like having them around normal functions as well, like those converting from exceptions to error codes, i.e. main.
There was a eclipse plugin, i think it was called "Qt C++ Integrator" or something like that , but they stop working on it as far as i know. I personally had bad experience with eclipse and c++, so i switch to vim :D *best decision ever*.
SRP: Single Responsibility Principle. If your class is about managing a resource and thus requires writing exotic stuff like copy constructor/move constructor/... then you are better off making the management of this resource *its only role*. If you need two roles (technical and functional), split it: - one class for the technical: just the 5 special members &amp; a get/clear/reset if appropriate - one class for the functional, using the prior class under the hood. This way each class focuses on *one* thing at a time, and the "hard" class can be tested independently (and thoroughly).
Eh, to each his own. I think it depends on the complexity of the resource being managed. I know and practice SRP but calling copy/move exotic is a bit over the top to me. I'd have tons of classes with single line destructors and single line moves if this were the case. Also, more often than not, I'm simply forbidding copy assignment.
Easiest way is to create something like make-files for your project. For example, try to use CMake, it supports Qt 4&amp;5 and will create a proper make file for you, also CMake supports Eclipse project generator, so you will have an eclipse project file. I do not know exactly about other build systems but I'm sure there are many of them, which can help you. It is easy, no doubt.
everyone needs to find his ide, but basically you can get every feature eclipse offers for vim too, (like Error highlighting, Refactoring, code format, jump to declartion ...). Besides there are cases working with eclipse isn't possible, like over ssh on a remote server. I don't want to "convert" you\^^ ,so one quick word of advice in the case you have to use qt creator use cmake for your project. This will save you some trouble :D
If you're not using dyamic_cast, typeid or type_info (and probably some other lesser known functions) you're not using RTTI. So as long as you rely on the vtable to call the appropriate virtual functions and use a virtual destructor you can make use of run-time polymorphism without RTTI. If you need to recover the original type it becomes more difficult to do without RTTI. You can always add a type member variable and check it then use static_cast to recover the original type though.
C doesn't have structs/classes like C++ though, the key point that most people think of as 'with classes' being the ability to attach methods to them (Though I guess inheritance and virtual dispatch are close behind them. These are of course possible in C but more awkward).
Right, my bad. My initial thought was if `Entry`'s ctor threw we would leak but then I realized it wouldn't. I didn't consider the reallocation.
I don't understand why he is so against using delete? Memory leaks are important, but cmon... it's not hard to write leak free code using pointers. Didn't he learn that in his first or second programming course? Maybe I am missing something..
`emplace_back` can use placement new in order to construct the element directly on the vector. If you use `push_back` then you have a temporary that is moved into the vector and nulled out (by the move ctor) then the temporary is destroyed.
&gt; a function for correcting indentation/code format Qt Creator also has this (CTRL+I to format selection, Tools|Options|C++ to configure it). I honestly think QtC is fantastic but I'm not going to try to convert you!
&gt; If I see a `delete` used in the code, then we have a memory leak. So code with `new` everywhere and no `delete`s is always leak-free. Got it. /s But seriously, not everyone can (yet) live in a C++11/14 utopia where memory management is a thing of the past. I've worked with code written (quite possibly) before I was born. I definitely now work with code that was written before I entered high school. The pretentiousness of this sentence is cranked up to 11.
Did you look at my testcase? That is not the behaviour that it describes. Both are move constructed in place. Notice how "default" is only printed twice, there are no temporaries being created. Any you provide a standard reference for what you are saying?
vec_ is not declared - bug found!
well, boost has had for a while good smart pointers, so also C++03 use this. Ofc. you then have no nice unique_ptr with move-semantics.
&gt; If you want to get really good, then try to get a library into boost (boost.org) Please don't just pile more crap into it just to get a name for yourself though. Boost has quite enough kitchen sink additions that were contributed and never maintained.
True. I'm not disagreeing with his underlying point: writing perfect leak- and error-free code with `new` and `delete` is hard. I just think he's saying it in a very poor way.
std::uncaught_exception std::set_new_handler And probably quite a few more things from stdlib. From core language, idk ... register?
I avoid iheritance as a rule. Use most of the other features, at least those I'm aware of. Best thing IMO is templates, very powerful tool/feature/paradigm. New features like basic GC are also nice to use. 
&gt; In C++, a `class` is identical to a `struct` in every way, except for a minor detail about the default privacy settings on data members. C already has structs, and therefore C is already "C with classes". I think the difference is the way methods are handled. Really it's more like `structs` in C++ are like `class`es in that you just define methods in them and go on, along with inheritance etc. If you were to take a technically valid `struct` in C++ and try to compile it as C, it could and probably would result in a compiler error, or if it did (for whatever reason, *extremely* nonstandard compiler?), you would still most likely need to pass a pointer to the caller of that method, and inheritance would be an absolute mess etc.
So you don't use #include?
Unless you specify a custom deleter, then you can't use make_shared. 
std::allocate_shared
So wheres the proof of this leak? I don't see any
As I wrote further down, I hate it. It just isn't compatible with modern C++ at all. I get why some of the things they do appeared as good ideas a long time ago but today they are just terrible. 
The whole thing is very inside baseball.
&gt; I avoid iheritance as a rule. Why? How do you do dynamic dispatch? 
&gt; digraphs, trigraphs, and "alternative tokens". That would be my pick for the most obscure and unused part of C++. I can't remember ever seeing them used in anger, has anyone seen them in released code?
Not the first time Tibra has been caught in this kind of situation. Whats funny is that most of these cases involve someone stealing a C++ codebase. You never seem to hear about someone walking off with a Java or C# codebase. Though the russian from the GS/Teza fiasco a few years back was accused of stealing an Erlang codebase, his to his own. 
The Goldman one was Slang/SecDB, no? 
http://en.wikipedia.org/wiki/Sergey_Aleynikov http://blogs.marketwatch.com/thetell/2013/10/22/russian-programmer-fights-goldman-sachs-and-wins-one-round/
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Sergey Aleynikov**](http://en.wikipedia.org/wiki/Sergey%20Aleynikov): [](#sfw) --- &gt; &gt;**Sergey Aleynikov** is a former [Goldman Sachs](http://en.wikipedia.org/wiki/Goldman_Sachs) computer programmer. He emigrated from Russia to the US in 1990. In December 2010 he was wrongfully convicted of two counts of theft of trade secrets and sentenced to 97 months in prison. In February 2012 his conviction was overturned by the [United States Court of Appeals for the Second Circuit](http://en.wikipedia.org/wiki/United_States_Court_of_Appeals_for_the_Second_Circuit) that entered a judgement of acquittal, reversing the decision of the District court. &gt; --- ^Interesting: [^Goldman ^Sachs](http://en.wikipedia.org/wiki/Goldman_Sachs) ^| [^Dzmitry ^Likhtarovich](http://en.wikipedia.org/wiki/Dzmitry_Likhtarovich) ^| [^Computer ^Fraud ^and ^Abuse ^Act](http://en.wikipedia.org/wiki/Computer_Fraud_and_Abuse_Act) ^| [^Denise ^Cote](http://en.wikipedia.org/wiki/Denise_Cote) *^\/u/CPPOldie ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfey8pn) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfey8pn)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 56363:%0Ahttp://www.reddit.com/r/cpp/comments/1xukmb/getco_hf_algorithmic_trading_system_c_source_code/cfey8l6)
Well, I personally use `and`, `or` and `not` in my C++ code instead of `&amp;&amp;`, `||` and `!`. The reasons? My eyesight is slowly deteriorating and I find the text keywords easier to read. Also, I do a lot of Python and I found myself doing it by accident. I only started doing it in the last 12 months after over two decades' C/C++ coding, so this is new to me. We'll see if it lasts...
&gt; smart-pointers: Since I rarely use runtime-polymorphism, I rarely have use for them. What?! I don't use runtime polymorphism that often - but I use smart pointers everywhere. Do you instantiate everything on the stack? If you have, say, a vector of pointers, how do you manage the memory without smart pointers?
&gt; The hardware I use most regularly has no exception support AFAIK, C++'s exceptions don't use hardware exceptions. Exceptions do increase the code size substantially in some cases, so for small/embedded systems you might not want to allow them...
Not true. Citadel, about 3 or 4 years ago sued an employee for stealing source. Technically, he was sued roughly 4 hours before he was fired. Criminal charges were filed roughly 6 weeks later. He attempted to ditch hard drives in the Chicago river. They sent diving teams in and recovered them. How the disclosure occured? He emailed it to hisself. Result was all personal email access became logged, among other things. Disclosure: I worked as a dev at the time this occurred. 
Not making any claims, but the last sentence could/might/probably will be taken out of context. http://lists.boost.org/Archives/boost/2013/02/201219.php 
&gt; I think it depends on the complexity of the resource being managed. Not really; unless you are into copy-paste programming. Writing the copy-constructor or move-constructor by hand is always a maintenance drag, you've got to make really sure than the next attribute added is also added to those methods. Certainly, it's easier to come up *once* with a resource-manager that does what you need and then *reuse it* anytime you need that resource managed.
Biggest example I can give you is a wrapper for a C style resource/API. Your class is just a shim for the underlying resource but you won't be adding attributes and stuff often. Your dtor won't change if you add elements because those get deallocated automatically assuming STL usage or primitives. Not too much overhead.
Visual Basic?
Oh shit lol no i meant visual studio! Good catch. 
Will the code even compile? I mean both the original and the fixed version. Because I thought std::unique_ptr is not copyable, so you would have to do a move assignment in the original and push_back() will never work, because you can't convince it to move instead of copy internally. Instead you have to do what people here suggested: emplace_back(). Am I wrong? EDIT: turns out I'm wrong, thanks mw_ewg. Also push_back() has [a variant](http://en.cppreference.com/w/cpp/container/vector/push_back) that takes a universal reference.
Heh, we use them where I work. Not in actual code, but our internal chat client turns anything in curly braces into links. So people started using &lt;% and %&gt;.
Your test case used `emplace_back` with a temporary, what's the point in that? `emplace_back` is supposed to be used with the parameters to the constructor. There is no advantage of using `emplace_back` over `push_back` if the constructor you're aiming for is the copy constructor. Check out the modified example here: http://ideone.com/ir4ObF 
&gt; Also, if you are using a smart pointer, you shouldn't need a destructor. Depends on the smart pointer and the resource it holds (if it's a complete type or not). http://stackoverflow.com/questions/6012157/is-stdunique-ptrt-required-to-know-the-full-definition-of-t
You can use normal try blocks for that. Only ctors need function-try-blocks.
Why would I have a vector of (owning) pointers if the contained objects weren't polymorphic?So: Yes, I try to get as much on the stack as reasonably possible. My experience so far: * 90%-95% of the time stack-allocation is sufficient * Of the reminder 90% - 95% of the time a unique_ptr is sufficient * Of the reminder 90% - 95% of the time a shared_ptr is sufficient
Funny that you refer to it as ECMAScript.
You said: &gt; It would save a move constructor and destuctor of an empty unique_ptr but I agree that this is negligible. Which I at least believed was a critqiue on my point that if you are build the object itself it's clearer to use push_back. And as STL has already confirmed passing in new isn't safe. 
It's because the author is being both archaic and pedantic about English: https://en.wikipedia.org/wiki/Diaeresis_(diacritic)#English https://en.wiktionary.org/wiki/no%C3%B6ne
It will compile. make_unique&lt;Entry&gt;(names[i]) returns a rvalue reference so it does call the move constructor or move assignment instead of copying.
I don't see this as the fault of the library authors, but blame the whole philosophy behind the (old) library-acceptance-and-maintenance-strategy. I agree with you that there are too many libs that are not in a state that fits to "...one of the most highly regarded and expertly designed C++ library projects in the world" (anymore). Assuming that the author of a library will be there to maintain it forever-on has been the wrong decision in the first place... I do hope that this will change in the future, the first step is the "community maintenance". To get back on topic: Trying/helping to get a (useful) lib into boost will definitely help you to improve yourself. The rest is another topic that regards boost-internal politics.
I do, because i have to. Once modules are in, i will no longer use includes.
Std::make_shared.
I didn't know that these even existed until right now. (That is the great thing about C++: There is always more that you can learn!) But I should say that I think it really looks like something nice to use with main() instead of nesting one level deeper. 
Yeah, I was being a little simplistic. The hardware can, in fact, do exceptions but they're very slow and those developing APIs for it don't allow exceptions. This is then enforced by the compiler at their request.
so where are it ? your profile: http://d.pr/i/DCrO is being very visited :D
You have got to be kidding me.
&gt; I don‚Äôt really differentiate the two too much - maybe it‚Äôs because I don‚Äôt know enough C++. But I use C++ as the easier version of C, which will let me do C stuff, just a bit faster and easier‚Ä¶ It might be his love, but I am pretty certain his code might be god awful!
I guess the auto return type will be most useful for complicated templated functions and I agree with the author that they should not be overused. It's also worth noting that both GCC and Clang support this feature so you can have a play around with this today.
The WG21 committee maintains a [github repo](https://github.com/cplusplus/draft) of the Latex source of the drafts. I would imagine that it's just a matter of finding the right tools / options to generate HTML instead of PDF. 
I try to avoid as much C legacy as possible: - No NULL - No #ifdef scattered all over the place - No pre-processor macros - Only use pointer arithmetic when really required - Null terminated strings only for API calls expecting them - No plain C vectors - No pointers for output parameters - No C streams Always compiling with warnings as errors, and have a static analyzer breaking the build if issues are found.
Function-try-blocks are like `finally` would be if C++ had it: if you ever actively *need* it to be exception-safe, then you're doing something wrong, since cleanup should be done via RAII types, not code in `catch` clauses. There's nothing inherently wrong about using them where they aren't required but do make the code cleaner. The only real argument against that I can think of is that there's a good chance a future reader of the code won't be familiar with them and it's not something that's easy to google if you don't already know what they're called.
"Don't need a destructor" can generally be considered shorthand for "Don't need a non-empty user-specified destructor".
&gt; [[carries_dependency]] Heh... even C++ guru's are hard-pressed to give a coherent definition of what this is, much less how to use it appropriately. This, like 'export', is a feature that _maybe_ one compiler on earth will bother to implement.
I've used pandoc for this purpose. http://johnmacfarlane.net/pandoc/
I often have them around `main` to minimally log any uncaught exceptions.
[That‚Äôs what it‚Äôs called](http://en.cppreference.com/w/cpp/regex/syntax_option_type).
Curiously, this has got an amazing number of downvotes for something that should be utterly uncontroversial.
`boost::variant`. It excels at providing many types of dynamic dispatch on value objects (inheritance, by contrast, often forces you to handle pointers).
Also, Sergei Aleynikov at GS. 
thx. For now, I'm done :)
The destructor won't change, but what of the move-constructor ? Instead you can easily use `std::unique_ptr&lt;WhateverResource, special_free_func&gt;` in the wrapper class and you're done as far as destruction/move goes; and your wrapper class automatically deletes its default copy constructor and copy assignment operator; easy and idiot-proof, what more do you need ?
It is extremely hard to get it right in the presence of exceptions.
Personally, I am in favor of this for a very simple, but convincing, example: template &lt;typename T, typename U&gt; auto add(T const&amp; t, U const&amp; u) -&gt; decltype(t + u) { return t + u; } When the entire function body is *just* the entire `decltype` content, you know something is wrong :x
The shared-everything anti-pattern is terribad. I hate that defaulting to shared pointer is being recommended by anyone. There's actually few cases where it's desired and you should definitely be preferring unique_ptr over it in almost all cases...and you should be reducing the number of pointers in your system as a whole.
Sorry for the late reply. To answer your question, you can try the ride share board if that's what you're looking for: http://cppnow.org/ride-share
Shared pointers in the case of management of pointers which you don't know the lifespan of isn't an anti-pattern, it's making it work. * Make it work * Make it right * Make it fast Using shared pointers too often is simply covered by step 1. Step 2 would involve removing them.
You've actually swayed me a bit with your last point. I use custom deleters for sure but I was thinking about resources that weren't pointers like GLuints or other such primitives. But I think wrapping those is actually a decent approach.
What do you do when you need to give access to a resource contained in a class? As I understand it, you can't return a unique pointer (because it imply transfering the ownership). Do you have some sort of "dumb smart pointer" like what's proposed for the standard? Or return a (const) reference?
Non owning const raw pointers or const references are still fine, if you can control the lifetime of the resource properly. Also you should think if you should give full access to members contained in a class.
So instead of something like `Fruit* f = new Apple; f-&gt;rot();` you do `boost::variant&lt;Apple, Orange, Banana&gt;` and write a visitor for every possible function?
you use std::list ? esp now with singly linked version in cpp11...
new / delete esp [] versions , same for malloc /free unions raw for loops - yeah theoretically you may need to do i+=j*8&lt;&lt;k; but I never did pointers, except when interfacing with some crappy C api. and even then I use .data, not &amp; :P RVR, VT, TMP - to stupid, not sure if it would be useful anyway for user code std::list noexcept relaxed atomics :D nondefault allocators plus what STL said minus rand() 
Ew. I have never used forward_list, except for testing algorithms where it is a very good source of forward-only iterators. But I have used list a couple of times. 
Well you can certainly transfer ownership of a `unique_ptr` with `std::move` if that's what the situation calls for.
My team cut over to C++11 just over a year ago. We've definitely been abusing shared pointers. I've been trying to come up with something better and basically came up with the same rules you have here. The only down side is they only work if everyone on your team agrees to them. I really hope the community comes to some sort of best practice with regards to smart pointers. Until then, I'm stuck using shared_ptr for everything, because that's what my team agrees to. On the up side, it's way better than using new/delete.
Nowadays I only code in C++ for side projects, having moved to other languages on the day job. What I remember from my C++ enterprise days, is that manual memory management and conventions only work in teams with less than 10 top developers working on site with low attrition. In the projects where that wasn't the case, it did not went that well over the project lifetime. So I always advocate full automatic memory management, unless the profiler tells otherwise.
In every language, everything boils down to assembly code and machine code in the end. So those implementation details don't really matter. C++ allows a `vector&lt;list&lt;deque&lt;int&gt; &gt; &gt;` to be passed around, by value, just as easily as an `int`. The developer need never be aware that the heap is involved, or that there is anything complex under-the-hood. Everything just works. And you can use `&amp;` references when you don't want the value semantics.
care to elaBjarnerate(as you surely know Bjarne made a famous blank slide presentation about list and vector) what use case you use lists for? Im not saying you are wrong, just that I dont even consider lists when coding, so I may need too learn when to use them.
It's indeed some form of selection, but I'm failing to see how the observer applies here. 
The C preprocessor is a must for adding all kinds of things you only want in debug mode. Using macros to guarantee in-line functions. If your function is in a different file the compiler won't inline it, unless you explicitly enable link time code generation. I could go on.
Yes I would absolutely recommend learning from a book. I think C++ is definitely one of those languages you should not pick up from looking at what other people have written and trying to copy it. It requires a deep understanding of what is going on at every level and knowing not so much *how* as *why* certain idioms are used. Obviously programming is something you need to practice to get good at as well. Again I would steer away from working with older codebases initially. C++11/14 is such a different language to C++98 which was again vastly different to what came before. A lot of the way things used to be done would be considered bad practice now as well as an awful lot of codebases being what I would politely call 'C with classes'.
One (of many many) sharp edges of C++ is that compiling is non-trivial, but not widely addressed. Understanding that cpp files need to compile to independent object files is one step. Then understand that they have external symbols (variables and functions) that need to be found before they can be made into an executable. Those external symbols should be coming from the .h files. Then comes templates, in which the compiler actually needs the source code, so templates in .h files (usually actually .hpp or no extension at all) have the full source of the functions and classes. I would start with C++11 directly, it is the current modern standard and makes some things so much easier that you won't want to look back. Get a grasp of some of the STL data structures, especially vector&lt;&gt;. Then understand unique_ptr and move semantics and you will be set.
&gt; implement every single data structure in C++ on your own Sorry for the question, but would you mind clarifying what you mean by this? Do you mean to say that I should code projects on my own? Otherwise, very helpful and insightful response! 
Thanks! For someone, like myself, who programmed in Python but knows extremely little of C++, would Koenig's Accelerated C++ (or any other C++ books you have read) be helpful? You also mentioned about "older codebases". Where did you find these codebases that indicate how old they are? 
Obviously C++11 is going to be more used from here on than C++03 will. But there are certain aspects of C++11 that make the strongly-typed nature somewhat mysterious. class Point; // ... stuff std::vector&lt;Point&gt; myShape; // ... stuff for(auto x&amp;: myShape) { // What can I do with "x" here? } that "auto" makes it less clear what you're doing than if you have to write out for(std::vector&lt;Point&gt;::iterator x=myShape.begin(), end=myShape.end(); x != end; ++x) { or for(std::vector&lt;Point&gt;::const_iterator x=myShape.begin(), end=myShape.end(); x != end; ++x) { // there are many times where you don't want to modify the elements... Though you can clearly see just why that shorter notation is introduced. The latter shows you directly that "x" is an iterator for a std::vector&lt;Point&gt;, and based on that you know there is an operator-&gt;() that you can use to dereference it, as though x were a Point* [it of course is not, but the iterator is a thin wrapper over an actual Point* assuming you use the default allocator]. Lastly, you can use the new keyword "decltype" to declare a type based on the type of something else, or so I understand it. The danger here is that if you're not completely sure of the type then using a "decltype" declaration to make it compile does not help your understanding of the code whatsoever. The correct solution would still be to write out the type by hand rather than allow the compiler to deduce the type based on the type of some expression. For a beginner this is far far more important than getting the code to compile through some sort of "decltype" magic.
&gt; I thought the chapter on Pointers was sparse C++ pointers are basically the same as Java references with added pointer arithmetic.
Oh I see. Yes, indeed, a Marker get destroyed when it's Entity get destroyed. However, as an effort to keep things separate, a Marker is only a POD. The actual UI marker is stored in my UI class, which stores a map&lt;Marker*, UIMarker&gt;. std::list might be a good choice, since I only have a small amount of markers (under 10). 
I can't know exactly what PZ-01 meant, but I would guess that he was encouraging you to write your own vector, list, unordered_map, etc. classes. I would further guess that PZ-01 did not mean that you should use the classes that you create as the container classes in other projects. Yours will not be better than the classes in the std namespace. Writing your own classes will help you understand why that is true and that is useful knowledge. I'm not certain that I completely with this advice. I do see some value in it. In deed, the Koenig and Moo book that you mentioned (Accelerated C++) takes you through an implementation of vector and you'll learn a great deal following that discussion. But to have you write your own deque or Red-Black Tree class is probably not the best use of your time. I happen to think that Accelerated C++ is an excellent book. The one strike against it is that it will teach you (very good) C++03, not C++11. (My assumption is that Barbara is revising it as you read this, but that isn't much help to you today.) It would still be worthwhile (Did I mention that it is an excellent book?), but I'd suggest that a better use of your time would be Barbara's other (latest) book, The C++ Primer. (Verify that it is the 5th Edition and has her name on it--there is similarly named book.) [http://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113/] This book is very well written, goes to much greater depth than Accelerated C++, and covers C++11 rather than C++03.
Ideally, you would start with a book that has been updated for C++11, but I'm not sure many of those exist right now. C++11 solves a lot of problems for programmers that C++03 does not and it would save you a lot time and confusion if you were taught it from the beginning. Start with a nice IDE (e.g. MS Visual Studio), using your book and cppreference.com, go to a site like projecteuler.net and start writing little "int main()" programs in the most C++-ish way you can. If nothing else, that will help you get used to the syntax and learn how to build the basic skeleton of a C++ program. Be willing to explore and experiment -- C++ often provides multiple ways of doing the same thing. Writing/compiling even a simple C++ program requires a fair amount of background knowledge. It will take you a while to get your head wrapped around all of those details but a good IDE will hold your hand through a lot of that. Good luck!
that is not to say memory_order _consume is not needed. I guess some smart people that do stuff like Intel TBB/MS PPL said we need this for a very good reason... 
http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list we should put this in the sidebar.
I haven't read Accelerated C++, it seems to be well reviewed but I would personally recommend C++ Primer 5th Edition for you. If you are coming from Python then there is going to be a lot of new stuff that you've never had to deal with before (stack vs. heap allocation, the type system etc.) and so you will want something which is as comprehensive and easy to follow as I believe that book to be. I've worked a lot on codebases which have a history which begins in the 80s and includes everything in between, from Fortran to C and through every version of C++. They stick around because it is not commercially viable to rewrite them and if you ever want to work in this field you will have to deal with them. However if you approach them with an understanding of modern techniques first then you will understand why you no longer want to always do things the way they may have been done in the past. An example of this I have seen is a codebase that was written in C and was 'upgraded' to C++ by putting everything in classes. However the non-static member functions all still took a pointer of the class type which always had a pointer to itself or the `this` pointer passed in...
My oooooonly beef with c++ primer was a lack of problem answers. There is an official answer guide for an older edition however, which I mistakenly purchased and eventually used for practice problems. So read the fifth edition and use the third for problems and answers. Also MIT has some homework assignments for their cs50 course that are explained thoroughly 
If you're interested in knowing more about why things are the way they are, try Stroustrup's (the language creator's) book The C++ Programming Language. The latest edition covers C++11, too.
working for a large company means several things: Better benefits, you can 9-5, you'll probably have access to world-class experts. working for a small company: You'll have a larger impact, you can be the local expert.
And it will vary company to company. That said the best is usually to start at a small company that becomes a big one :)
I also suggest you to watch the [STL videos on MSDN](http://channel9.msdn.com/Tags/stephan-t-lavavej?sort=viewed) if you get tired of reading. Those are more advanced and also cover a lot of stuff that you will not find in most books. 
I've never had a literal 9-5 job, regardless of company size. Do some places pay you for lunch?
Your guess is right. I was talking about typical containers such as LinkedLists, Stacks, Tree's, Heaps, Maps, etc. Tree's teach you recursivity, LinkedLists are great for pointer practice, Maps are good for hashing algorithms and so on. These are very common interview questions for Amazon, Microsoft and the Google's of this world. I agree with you on C++11. The book won't mention Lambda's, the range based loop and most importantly discouraging you from using bald pointers.
I've found Herb Sutter's blog (http://herbsutter.com/) particularly the "Guru of the week" series really helpful for getting a better understanding of C++ best practices
Cool, send me your email address and I will put you to the developers list. Also I will explain the state of the project and where it is going.
dont wanna bother you too much, but do you have that code and could you share that snippet. like I said I would really like to be able to recognize when to use list, and this could be helpful. also maybe your problem could have been solved with a vector but instead of iterators you use indexes, and deletion doesnt really remove element, it just puts its idx in empty list(another vector) so after deletions next inserts will overwrite that data. 
My current company is a really laid-back 9-5ish company. Sometimes I'm in early, sometimes I'm in late, sometimes I'm out early, sometimes I'm out late. On average, I work less than 7 hours a day (8 hours with lunch). They're also very accommodating with working from home (unexpectedly &amp; unexpectedly). If we need a meeting, and people are working from home, we video conference. The benefits are good, but not great. My last job (where I was at for over 9 years) expected 60 hours minimum a week, excluding breaks. They also provided 3 meals a day. (Although, dinner was usually leftovers from lunch).
This is the case I was thinking of with Citadel : http://www.businessweek.com/news/2011-10-13/former-citadel-employee-charged-with-trade-secret-theft.html If you google "Citadel employee lawsuit theft", you'll see it's not an isolated incident for Citadel, either.
I think you'll find it difficult to find people to build on this. The standard way to implement a neural network for many years has been to keep everything in matrices and push as much computation as possible into a BLAS. The reason people do this is speed, and it makes a _huge_ difference, especially if you can push the BLAS operations onto a GPU. Your implementation is very abstract, and I suspect your performance suffers dramatically because of this.
There is one small detail. This implementation allows somebody to define his own (type of internal variable) like in example is float, but you can put in some class with an array inside you just need to implement some math functions and operators which could work with that type. struct MyVar{ float values[10]; }; then declare your perceptron as: typedef Perceptron&lt; NeuralLayer&lt; Neuron&lt; SigmoidFunction&lt;MyVar&gt; &gt; &gt; &gt; Perceptron; I am not sure how we could put the execution to cpu or if it is what you mean. Therefore I am asking for help btw :).
I guess from now on I will use this nice -std=c++1y-option on all my personal projects.
It was in my data compressor, really old code. With indices, you have to do pointer arithmetic, whereas a pointer is a direct hop.
1) Post some code. Use pastebin or similar, or absolutely make sure you prepend all lines with 4 spaces to get reddit to preserve it as monospace. 2) Whatever is in the if() parens, print it out before the if block to see what value it has. 3) Fire up your debugger. gdb, or whatever your IDE gives you (MSVC++, Eclipse, etc). Set a breakpoint before the if, and investigate the variables available.
Work for a company. The freelance route is *great* once you have a dozen reliable companies. It just takes 5 years to get there, involves a crazy amount of your time for overhead, and leaves you starving for the first 2 years. That's assuming you're a kick-ass self promoter.
Do you use include guards or pragma once? I have been using the latter, and it's a real time saver.
I occasionally write Java, and IntelliJ is miles ahead of Eclipse. 
Wherever you go after the large company. You'll have a name people recognize on your resume, experience with the internals of large companies, and some useful contacts. If you want to go small later, large companies could be your customer. Same goes for freelancing later. If you're starting out, large software companies (not just a software group in a non-software company) will have more skill and career development for you than the small shop (on average).
Please leave comments: names of projects that we can check.
Pragma once isn't standard. So if you want ot write portable code, you need to use both anyway. It is really a pity that C++ did not provide a module system from the begining, but this wasn't possible if compatibility with C tooling was to be retained. Currently I only use C++ for hobby projects, as on my line of work most projects have moved to other languages, which do support modules. Thankfully I would say, as I remember having *make all* that would take a couple of hours.
I don't really target any platforms that don't support pragma once, all the major compilers support it, and worst case, I can write a python script to add automatic include guards.
The code is completely invisible without javascript.
cocos2d-x (2.x and 3.0)
My point here is that move semantics is something that _I don't use_ (rather than something i actively use) since I get it for free by using the right types. Anyhow, these rules are recommendations, i.e. they don't state that you _must_ implement anything, but that you should rather consider implementing those things.
&gt; note that explicit can not be used on non constructors This is wrong, it can also be used on conversion operator overloads. 
I believe clang is using c++1y to refer to C++14 and c++1z to refer to C++17.
Ahh, ok. c++1z makes sense. As long as GCC is doing the same (and I guess they are/will) there shouldn't be a problem.
Yeah, disabling things seems to be pretty much it; see also: http://www.codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/
&gt; I must admit I had not thought about protection against temporaries using = delete. It can give a false sense of security imo, it will break down as soon as you add an intermediate function/constructor between the temporary and the code that uses the "delete &amp;&amp;" trick. So vigilance (or static analyzer) is still very much needed. Well, unless you add "delete &amp;&amp;" everywhere perhaps, but that is not always possible and would get pretty ugly. 
nice catch I will fix it.
Indeed that is the "trick", it will catch both const std::string foo(); and as well std::string foo(); I will emphasize it.
Will the version after C++17 be C++2x? or are we looking at C++1w?
There are no firm plans yet for anything beyond C++17, but as an International Standard has to go at least through a Committee Draft and a Draft International Standard (see http://isocpp.org/std/iso-iec-jtc1-procedures), it's unlikely to see another revision before 2020. Personally, I'd expect to continue having 3 or 4 years between releases.
They've hinted that they want to start going for a 6 or so year main cycle with a smaller release half-way between (big-11, small-14, big-17) which suggests a smaller release in 2020 but at the moment it's all conjecture.
For better or worse, the web has largely moved to a point where javascript is mandatory.
I roll with NoScript add-on and it's not that bad. Most sites are usable without js. What annoys me most is when I simply get blank page with no content at all - this is a nice red flag though, as it tells me the page creators are incompetent and I probably don't want to run their code in my browser anyway.
Yeah, I know, you probably should test without JS and you probably should degrade gracefully. Just don't equate "I don't want to bother catering to NoScript users" with incompetence.
I call incompetent only people who show me a blank page, it's just too lame. I'm not angry at page owner if layout is slightly broken, visual effects are lacking, some non essential parts are missing etc. I don't ask for too much, if I just want to see the page content.
Inability to display text and images without javascript is incompetence, there's no way around it. I get it, I won't see the awesome falling snow, or watch a video. I can even understand the lack of dropdown menus, even though they're doable without js, but text and images? I'm not going to leave myself [vulnerable to another vector of attack](http://securityaffairs.co/wordpress/16924/cyber-crime/firefox-zero-day-exploited-against-tor-anonymity.html) without a reason and this definitely isn't one.
&gt; The second key to understanding the error will be realizing that const_iterator and iterator are 2 fundamentally different types, different than T* versus T const*. Actually, T * and const T * are also different types (related by a conversion), and they will trigger the same kind of mismatch during template argument deduction. (As an aside, vector iterators are allowed to be pointers, although in VC they never are.)
&gt; for(auto x&amp;: myShape) { &gt; &gt;that "auto" makes it less clear what you're doing than if you have to write out &gt; for(std::vector&lt;Point&gt;::iterator x=myShape.begin(), end=myShape.end(); x != end; ++x) { Are you on crack? You really think the hand written for loop is more clear than the range for loop. The range for loop is simple, it's semantic is "for every element". If you don't like the use of auto (I do) then just type the type and it's qualifiers out. I would go further, even in C++03 writing out iterator loops like that in anything but &lt;algorithm&gt; style generic functions is a pretty strong code smell. It looks bad, it is bad. I strong recommend the book Effective STL by Meyers. 
&gt; I've spent the last 6 hours looking into how Unicode works with C++ and the short answer seems to be that it doesn't. [...] They can be used to store data with various UTF encodings but lots of their member functions will silently work incorrectly if you do. Ogonek [1] is a C++11 library for Unicode which focus on "Validity and correctness first", among others. &gt; All streams and file functions are useless since they are not aware of Unicode. [...] All I'm trying to do is scan a directory for a list of filenames :( Boost.Filesystem [2] can help with your "scan a directory for a list of filenames" problem (there is a filesystem technical specification [3] on the way that is based on it). Boost.Regex or Boost.Xpressive can probably help you with your regex problems. [1] http://flamingdangerzone.com/ogonek/ [2] http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm [3] http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3803.pdf &gt; They can be used to store data with various UTF encodings but lots of their member functions will silently work incorrectly if you do. [...] And if that is the case, why are the standard solutions still used in C++ 11 books since they seem utterly unsuitable for programming in 2014? Getting unicode right is hard. Even for basic definitions of "right", such as "correct", Java and C# libraries IMO fail (utf16 for everything is not unicode). A standard C++ solution to such a problem has to be not only correct, but extremely efficient, generic (work with all current and future encodings), and well proven in practice. Given that it is a very hard unsolved problem, it is totally understandable that you need to resort to third party libraries to solve it (and this will probably remain true for many years to come).
I don't know about `std::regex` but [Boost.Regex](http://www.boost.org/doc/libs/1_55_0/libs/regex/doc/html/boost_regex/unicode.html) does support Unicode. I admit doesn't answer your question, but it is a possible workaround. That might be a lot to try and get working though if you're just 4 weeks into learning C++.
I've checked out the boost::filesystem and it does seem the best way of doing things (although I'm getting baffled by some bits of boost needing to be compiled and others not, and how to do that...) I think most my confusion comes from not being able to do something as simple as opening a file with standard C++. I probably just need to get used to the "batteries not included" nature of things :)
Thanks, I'll have a look at that. It seems all roads lead to Boost in C++!
I agree that its complicated, but isn't it better to include it in the standard if C++ is to be though of as a "modern" language. As it is I've just wasted time learning all about the "standard" ways of doing things from a book written by the creator of C++ himself (which works correctly on my English version of Windows on my work laptop, but just fail on my home PC) and now I have to throw all that time away and learn something different. Even worse is that if I learn the Boost way, I may then come across someone else's code that uses Qt so I'll have to learn that too, and the same for any other library people choose (and then there are licensing issues, and platform support etc.) I'm know reading far too much into it since I'm only trying to learn C++ as a hobby project but I am interested to know why things are as they are in C++.
Unicode is hard. No-one has come up with a good enough solution to unicode. And by the definition of good enough in "standarese", no one has done this in any programming language, i.e. extremely generic (work with all current and future encodings), extremely efficient, easy to use, and well proven in practice. Qt and Boost are _good enough_ for a lot of people (you can use them and improve them). However, a standard solution needs to be good _for everyone_, _for ever_. Once you get something into the standard, it stays there. For all these reasons, the standard committee hasn't standardized any half-baked solutions [*]. _This is a good thing_. [*] AFAIK no-one has even made a proposal about it. Please correct me if I'm wrong.
C++ certainly does not ignore unicode. It is perfectly fine and basically intended to store utf-8 in a std::string and work with the stuff listed here: http://en.cppreference.com/w/cpp/locale Now, I agree that there is still some air to a perfect solution, but it is imperative that you understand this: QString, Java, C# all don't really support unicode either. What they are doing is just storing the data as utf-16, just like std::u16string does. Unicode is far more complicated than that. Let's look at some very basic operations: Getting the n'th character of a string and comparing two strings for equality: * Both utf-8 (std::string) and utf-16 (all the others listed above) are variable-length-encodings, which means that you have to look at all characters before them inside a string to find out which is actually the n'th codepoint (~basic unicode-symbol). * Even using utf-32, a fixed-width-encoding, wouldn't help here since not all symbols consist of only one codepoint. Basix stuff like the German ‚Äû√§‚Äú can be represented by two codepoints (‚Äûa‚Äú and a combining character that puts points over another symbol) * ‚Äû√§‚Äú **can** be represented by this, but it can also be represented via a single codepoint. Unicode requires that both representations are considered equal. ‚Üí Two long strings can differ in every single byte and have to compare identical nontheless * utf-16 is basically the union of the disadvantages of utf-8 and utf-32: It is variable-length but wastes much space most of the time So: I am not happy with the situation in C++ but I clearly prefer it to what Java and friends do, because it is more likely that programmers are at least aware of it. My personal approach is to never expect a certain encoding and just concatenating and splitting at known characters. This works perfectly fine for streams and files too. Edit: Some example-code for how it works: https://gist.github.com/Florianjw/9043197 
Yes, because C++ is go-to language of PL enthusiasts and academics.
What's the problem with: #include &lt;fstream&gt; int main() { std::ofstream file{u8"f√§ncy_file.txt"}; file &lt;&lt; u8"f√§ncy text\n"; } ?
That is true, but most uses will want to be space conservative using the VL 1-2-3-4 byte length encoding forms. Furthermore, the encoding requires a bom, which really isn't how algorithms in the standard library like to deal with iterator ranges. 
Both Java and C#'s string classes are aware of what encoding they are using though. So doing something like str.charAt(10) will return what I expect (the 10th character in the sequence). This seems like a *much* better solution than just returning the data at the array index (which is what I believe C++ does). Calling str.length() on a std::string formatted with any UTF encoding will still work, but return a result I would not be expecting. This doesn't even go into the fact that that all of the Java/.net file and stream functions also know what encoding the strings are using and can seamlessly work with them.
I don't think you have clearly expressed what demand that these abilities solve. I personally think the example should show an actual build problem, and how these features solve it. For example some common problems that CMake doesn't address are: automatic unity builds, pre-compiled headers, code generators that output an arbitrary number of files without a common prefix or suffix. 
&gt; Both Java and C#'s string classes are aware of what encoding they are using though. So doing something like str.charAt(10) will return what I expect (the 10th character in the sequence). No, it won't. It won't even return the 10th *code point*, let alone the 10th *character*. Both C# and Java use UTF-16 as their internal string representation (and a 'char' is a 16-bit value). A single Unicode code point can be composed of multiple UTF-16 encoded 16-bit values (due to surrogate pairs). A single Unicode glyph can be composed of multiple codepoints (due to combining characters). So it's not that the language is deficient - it's that your understanding of Unicode is. If you want to emulate Java or C#'s string types you can feel free to use std::wstring (on platforms where sizeof(wchar_t) == 2) or use std::u16string. Because Java and C# strings work the same way as std::u16string - they are arrays of *16-bit values* and not arrays of *characters*. If you do str.charAt(10) (in Java) or str[10] (in C# or C++) you'll get the same thing - the 10th 16-bit value in the array. If it's part of a surrogate pair, what you get back is half a codepoint. And even if not, that codepoint may well be one of a hundred codepoints defining a single Unicode glyph.
How about you post a segment of code that does not work that you think should work? At least then your complaints will have some concrete basis. My guess is that you are misunderstanding what it means to "support Unicode"...
Yep. I was purposefully vague in how UTF16 handles the "rest" of the Unicode chars that it can't fit, as well as purposefully avoiding the concept of diacritics (i.e. a "linguistic character" made up of more than one "unicode character"). It does suck. They are all reasonably-suited to *outputting* data (as a webpage, to console, etc), but internal storage standards are still a clusterfuck due to the stuff /u/F-J-W talks about [here](http://www.reddit.com/r/cpp/comments/1y3n33/why_does_c_seem_to_pretend_unicode_doesnt_exist/cfh3pkw).
That wouldn't be surprising given that most of C++11 was just "copy Boost".
`u8"f√§ncy_file.txt"` ensures that the content of that string literal is encoded in UTF8. It is still, however, just a string of characters like every other string of characters. When I compile and run this program (Mingw-w64 4.8.2 on Windows 7) my standard library assumes the file name is encoded in the local code page and I get a file named "f√É¬§ncy_file.txt". The ability to change the encoding of narrow string literals is fairly useless without a way to communicate that encoding or somehow associate it with the string's type (i.e., `char8_t` would be nice.)
On Linux, filenames are just binary blobs. These days, most people that don't live in Japan put UTF-8 strings in these blobs, but if you really want to you can put things that are not UTF-8 in them. On OS X, filenames are fully decomposed UTF-8. This is occasionally a pain when communicating with other systems (since a Linux system could have two files whose names are identical after decomposing both, which would make copying both of them to a HFS+ filesystem difficult), but is otherwise absolutely wonderful. Windows stores filenames as UTF-16, and the functions which take narrow characters convert to UTF-16 using the system codepage. UTF-8 is not a valid system codepage, since the Windows multibyte stuff only supports 1 or 2 bytes per codepoint, while UTF-8 requires up to 4. mingw could easily provide versions of all of the C standard library functions which expect UTF-8 input rather than local codepage input, but does not because that would be far too helpful.
Please post this in /r/cpp_questions.
Thanks
&gt; The C preprocessor is a must for adding all kinds of things you only want in debug mode. Sure, but beyond that you shouldn't use anything else from the preprocessor. &gt; Using macros to guarantee in-line functions. You shouldn't do that, for various reasons. 
Even IF you are programming on Windows, don't use Cstrings. You maybe asked to port some or all of the code to other platforms. Ever more likely for desktop applications with the rise of OSX, and for server &amp; compute systems; why anyone would want to run that on Windows in the first place baffles me. Better cross platform solutions include, but are not limited to: UCI, utfcpp &amp; QString.
Which wasn't surprising given that most of Boost was just "implement stuff that should be in the standard libraries and get real usage of these interfaces before they become standard".
Part of the problem is legacy. The first Unicode standard was published in 1991, but C++ dates back to 1979, and C back to 1972. There are a lot of mechanisms for working with Unicode in C/C++, but there's a lot of legacy libraries and applications out there that pre-date Unicode even existing, or that need to ignore it for other reasons. Having said all of that - if you work internally in UTF-8 then *most* string manipulation functions will work just fine. UTF-8 guarantees that there will never be a Nul byte as part of a string, so all of the C/C++ functions that work on Nul terminated strings will be fine. Where it falls down is when you need to work on Characters and not Bytes, because you can have multiple Bytes needed to represent a single Character. If you really need that level of detail, something like ICU is what you want to investigate. The question becomes then - how often do you actually care about the individual Characters as opposed to the individual Bytes? From your examples * std::regex - Yes, you will have problems here. This is a case of working on a per-character level though * std::algorithm - It depends on what you are trying to do. Odds are though that yes, you are trying to work on a per-character level again, but not always * String classes ** std::string - This can be used to safely store UTF-8 Strings ** std::wstring - This has always been dangerous to use, since the size of a wchar_t is different on different platforms(!!) ** std::u16string - This can be used to safely store UTF-16 Strings ** std::u32string - This can be used to safely store UTF-32 Strings, which has some important benefits. Namely, all of a sudden all of your Character level mechanisms will start to work, because UTF-32 can represent all Unicode characters - not counting some of the weird cases like combining characters - as a single code point. However, it is a lot more memory expensive for a lot of strings, because you are always using 32 bits where many characters can be represented in 8 bits. * Steams and File Functions - Why do you care about the Characters here? Surely you are working purely at the byte level, in which case they should all just work fine. And as far as Unicode in filenames - that's not a C++ problem but an Operating System problem. I know some Linux file systems support it just fine - I don't know about all of them. I don't know if NTFS or FAT does, but I'd not be surprised to find that FAT at least doesn't...
&gt; Boost is a library that was started as playground for stuff to be included in the standard later I don't really think that is true. There is a loads of stuff in Boost that will never go into and was never intended for inclusion into the standard (Spirit, MPL and even domain specific yet not particularly complex stuff like Boost.Graph and GIL). The reason the stuff in boost get included, at least in my opinion, is that is written very idiomatically; even down to the formatting and naming conventions. Whereas other libraries like Qt and POCO just don't fit as well.
Actually c++ takes the correct approach of not integrating unicode encodings into the language. The STL library provides the mechanisms for managing different encodings in different ways, and external libraries can use that to make encodings available. It's the same reason the STL doesn't provide GUI, networking, and a host of other features commonly found in 'higher level' programming languages. 
&gt; 1. Not everyone cares about portability. Come back to me when you're asked to port. Secondly, portability improves code. It allows you to test on more compilers. &gt; 2. You actually think CString and MFC/ATL (of which it is a component) is good? You think this is clean? CString cs(_T("meow")); std::wcout &lt;&lt; (const std::wchar_t*) cs &lt;&lt; std::endl; I sure don't.
Okay, basically the only reason I commented was because I think the word *playground* just seems a bit dismissive. As though it's juvenile or not really fit for use until it get standardised. Like testing drugs in a lab, you shouldn't use those until their officially approved. When actually the inverse is true of boost. If boost has functionality that I want, then I tend to use without blinking because it's going to be better than anything me or my colleagues are going to write in a given time frame.
&gt; but lots of their member functions will silently work incorrectly No - they will correctly do exactly what you tell them to do. However, what you tell them to do involves the low-level representation, not the characters. Then again, that's true in Java etc anyway. What most languages call "unicode" is really the UTF-16 encoding. A UTF-16 word is not equivalent to a character. Even a unicode codepoint isn't equivalent to a character, as some characters have multiple representations and some are formed from multiple codepoints. Admittedly it's easier to ignore the wrongness when pretending that a UTF-16 word is a unicode character, but you can do that with `std::u16string` anyway. Basically, working with Unicode is more hassle than it should be in any language if you care about fully supporting unicode and doing it correctly, but hardly anyone supports unicode fully and correctly anyway. I still think you're right to say C++ is particularly painful, but mainly because it's more explicit that you're working with the encoding rather than the encoded text - and of course C++ is more justified in dealing with the encoding rather than the text because it's *meant* to keep the low level details accessible. 
It is if you use the windows API. Plus you can use it basically interchangeably with LPCTSTR. 
&gt; Unicode isn't variable length. Some encodings of it are variable length. It depends what you mean by "variable length". Some characters are composed from multiple unicode codepoints - e.g. using modifier codepoints (appols. if that's not the official word) to add accents/diacritics. So yes, Unicode itself is a variable-length code if you really care about characters rather than codepoints - and since codepoints are just implementation detail of how Unicode works, why would anyone really care about those? 
The Windows API is something I also advise people not to use instead preferring where possibly (not always possible admittedly) higher lever libraries. For example perfer Boost.Filesystem (to become standardised shortly) over WinAPI for dealing with files and so on. Not only because it's portable (which you've made clear you don't care about) but also because the interface is actively quite good in comparison to the WinAPI actively bad (from a C++ context) C interface.
I never said I didn't care about cross platform comparability. I've written cross platform programs, I've also ported apps between different operating systems. Just it's not a requirement for every project you write. 
Ok so the 8 words in the second set of brackets might not apply. But the rest of what I said stands.
&gt; I agree that its complicated, but isn't it better to include it in the standard if C++ is to be though of as a "modern" language. Neither Unicode nor C++ is a fixed target. If you tie a particular version of C++ to a particular version of Unicode, that could be a problem for people who want to use a different version of one but not the other. It doesn't bother me in the least that wxWidgets isn't part of the C++ standard - it's still a C++ library that I can use on any platform I want. And BTW, I tend to let wxWidgets deal with Unicode for me (again, ignoring whatever wrongness there is - I assume about the same as Java) as I find the needs for Unicode and a GUI often go together. Personally, I think a big part of the issue is because one persons almost-correct is another persons pointlessly-and-awkwardly-pedantic, so all we have anywhere is what people are getting by with. 
If a program runs into an error that hasn't been accounted for in the code, by far the best thing the program can do is crash as loudly as possible. This is one of the best things about exceptions - they *don't* allow the program to keep on running in a corrupted state.
I would imagine you would store children nodes with a `typedef boost::variant&lt;a, b, c, ...&gt; child_node;`. Then, if you need to add more node types, you simply expand the list in the typedef.
Agreed. What do you think of the following? 1. C has `struct`. 2. C++ allows you to write non-`virtual` methods in your `struct`, but this is really just a bit of syntactic sugar. 3. C++ also allows you to mark some things as `private`. Then, only methods (and `friend` functions) can access them. 4. C++ introduces the `class` keyword, which is just a synonym for `struct`, but with a different policy on the default private of members. Thus far, this is just good old-style programming with abstract data types and other 'clean' ideas. It's compatible with pretty much every language ever. 5. C++ has `virtual` dispatch. (It's just *single dispatch*, FWIW). Is that last step, the `virtual` dispatch, what people mean when people say "object oriented"? If so, then "object orientation" is an *optional* paradigm in C++ that a lot of developers simply don't use very often.
Yes but if the debugger can't show you where the error occurred, you are in for a world of pain, especially with a large code base. Worst still it might not be immediately obvious a method is throwing an exception from it's definition, or if its in a lib some place. have a read of http://stackoverflow.com/questions/2443135/how-do-i-find-where-an-exception-was-thrown-in-c It's enough to make me never want to use them, especially after wasting several days attempting to fix other peoples code.
Sorry "Who name must not be spoke" ;).
Sure one reason is lack of manpower, but another is the one I mentioned. C++ being a system's language makes stuffing it with libraries a bad choice. 
No, it really doesn‚Äôt. The website you link actually says as much. Both `boost::regex` and `std::regex` handle Unicode code points which fit into the container‚Äôs character type. This isn‚Äôt *at all* the same as ‚Äúsupport[ing] Unicode‚Äù. If `boost::regex` supported Unicode, then there would be a way, without having to convert the string, of searching in UTF-8. There would be a way of using Unicode character classes. And so on. [Unicode actually defines very well what regex support means](http://www.unicode.org/reports/tr18/), and neither `boost::regex` nor `std::regex` support it ‚Äì by design. If you want [regex with] Unicode support in C++ you need to use a library such as [ICU](http://userguide.icu-project.org/strings/regexp).
Seems even C++ 11 has some way to go yet if we want both efficient and simple/natural/straightforward code.
Good advice but [your remark about Boost.Regex is wrong](http://www.reddit.com/r/cpp/comments/1y3n33/why_does_c_seem_to_pretend_unicode_doesnt_exist/cfhftgb). It doesn‚Äôt even try to implement Unicode. As far as I‚Äôm aware it offers exactly as little as `std::regex` does in terms of Unicode support. You need a library such as ICU for that. My hope is that Ogonek gets regex support rather sooner than later, although its author probably doesn‚Äôt have the time to implement this alone. I‚Äôm sorely disappointed that `std::regex`‚Äô user interface is designed in such a way that it cannot be adapted by Ogonek. This, in my opinion, is a fatal failing.
The alternative is no exceptions and just return false to say the method failed, or NULL to say the handle is invalid.
C++ works fine with unicode. C++ tends to be low level. For files, this means you want to pass in the encoding that your OS is using. For Linux, you put UTF-8 in a char* string. For Windows, you can either put UTF-16 in wchar_t strings or your local system encoding in char* strings. If you want to use the unicode version of things, try sticking a "w" in front of the names. E.g. std::wregex, std::wstring, std::wfilebuf, etc. and use wchar_t instead of char. You put a capital letter L in front of string literals to make them wchar_t strings. 
&gt; UTF32, while likely wasting space, can represent every character in the entire Unicode character set in the same amount of space. No, it represents every _codepoint_ in the same amount of space. However some _characters_ use multiple codepoints even if you normalize the data into one of the composed forms. In fact Unicode is fundamentally variable length no matter what encoding is used.
AFAIK UTF-8 doesn't guarantee no NUL---Java's variant of CESU-8 uses an overlong encoding to avoid it, but that's not quite valid in normal UTF-8.
Such solution (string views, ranges and iterator adaptors) is available even on C++98 ;-), assuming you have a string view implemetation (C++11 stdlib doesn't offer one yet, just as C++98 stdlib) and you can get regex, ranges and iterator adaptors from boost.
How are those easier to check for than an exception? If you forget to check for an exception, the program crashes noisily and you find out about it. If you forget to check for a return code, the program will simply continue on in a corrupt state. That can be completely disastrous. If there has been an error, you don't want to just continue on as if nothing happened. If you *do* want to do that, then it shouldn't be an error in the first place.
I don't know if it's part of the design rationale, but NUL's code is &lt;128 and would therefore normally be encoded as a single-byte 0x00. [According to this](http://en.wikipedia.org/wiki/Utf-8#Overlong_encodings) overlong-encoding a NUL is only permitted in modified UTF-8. Multibyte sequences don't use zero bytes, but that's a different beastie.
If you're scanning a directory for a list of file names, why wouldn't you use something that makes it easy like Python?
If a c++ function is wrapped in a lib, and you can't see inside that lib you can't even tell if it will throw an exception, or what type. A return type is part of the function definition.
Exactly. NUL is not multibyte, and it is therefore encoded as 00.
No: it was that a zero byte is only ever a null character, not that it cannot occur.
Overlong forms are prohibited in general, not just in the case of null. This has led to security bugs due to buggy decoders before (say you filter U+003C LESS-THAN SIGN ("&lt;") as \x3C (the byte can only occur when representing U+003C, and is the only representation of U+003C) but later the byte-stream is decoded into UTF-8 and \xC0\xBC (a two-byte overlong representation of U+003C) is decoded into U+003C, therefore leading XSS bugs being possible, etc.).
Right, but that‚Äôs what‚Äôs meant in the context of /u/sazzer‚Äôs text: C string functions that use NUL as zero termination continue to work with UTF-8 sequences, because the only situation where a null byte is encountered it actually represents NUL.
True, but to qualify as simple these tools should probably be in standard library at the very least. Then the next step would be to make programmers aware of their existence and use cases. Or you can just redirect novices to Python and keep C++ for advanced users with more specific requirements. Whatever works :-) 
That's cool, of course let's not miss boost::tokenizer, maybe there's a simple approach for using it with regexes for providing the same behavior as the one in the article.
I was actually refering to the integration of ICU with Boost.Regex are the page describes: &gt; If you have the ICU library, then Boost.Regex can be configured to make use of it, and provide a distinct regular expression type (boost::u32regex), that supports both Unicode specific character properties, and the searching of text that is encoded in either UTF-8, UTF-16, or UTF-32. See: ICU string class support. But are you saying that this is not the same thing? My knowledge of Unicode is **very** limited.
Please accept my apologies, you appear to be right.
I might sound mad, but writing a regex engine is only as hard as you want it to be. Technically speaking a regex will build down to an FSM, and you can write an FSM in C++ in... well my one is 60 lines of code, and it supports character ranges and backtracking. I won't claim it's as fully featured as pearl regexes (because of how it isn't), but it can match and reject any regular grammar :) PM or harass me somehow if you'd like the source - it's one file, relying on vector, map and pair
No worries, like I said I was just linking something I'd read. I don't actually have experience with ICU.
Ask in /r/cpp_questions, since this clearly falls under ‚ÄûC++ questions, answers, help and advice‚Äú, as noted in the sidebar.
Are you using: this.abc or one of: this-&gt;abc (*this).abc I don't know why, but I like to do: #define self (*this) self.abc()
[this](http://en.cppreference.com/w/cpp/language/this) Also, questions like this are better in /r/learnprogramming.
With these posts I intend to prod the Ranges study group back to life. Whether the ideas pan out or not, the conversation needs to happen if we're ever to get ranges in the standard.
In C++ you usually don't use an explicit "this" at all. You can simply access a member as 'foo' and call your methods as 'method(args)' inside your code. Only when you need to distinguish between a member variable and another variable with the same name (e.g., in a setter or in the constructor) you would write something like 'this-&gt;foo = foo'. This is different from python where you *have* to prefix everything member with 'self', i.e., 'self.foo' and 'self.method(args)'.
Lol, are you serious?
I believe UTF8 was designed such that 8 '0's in a row will never happen unless a real 'null' is specified.
There are a lot of reasons why this code doesn't work. But I won't go in the details as to why. Debugging and understanding what the compiler is telling you is a skill you need to master. Try removing parts of your program that are not working. When you got something that works. Add them back one by one to isolate the issue. You might want to get a book or two on c++ while you are there. See this thread: http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
Yes, the problem is that this isn't even remotely close to being valid code. You need to read a good basic level tutorial at least. Also, you need to input some code just to see if it compiles, don't even bother to make something that works until you can express to the compiler what you want. In addition, leave classes out of the scene for now, unless you actually have a good idea of what problems they are supposed to solve.
If I understand this right, "variable length" refers, for example to: &gt; UTF-8 uses one byte for any ASCII characters, all of which have the same code values in both UTF-8 and ASCII encoding, and *up to* four bytes for other characters. You don't need a lot of SC to understand that this is a problematic behavior. the main reason UTF-8 is usually used is because it maximizes compatibility with ASCII this way.
Haha, sorry. I do wish it were in C++ by default though.
It seems like an obvious solution to some of these problems is to drop the requirement that the start and end iterator be of the same type. Rather than a sentinel value, you could have a sentinel type, and the check for if it's at the end would be just `bool operator==(iterator it, sentinel_iterator) { return *it == 0; }`. Breaking out of a loop early could be done using a custom sentinel type in combination with the normal begin iterator. Is there something I'm missing that'd make this a terrible idea?
The optimization issue covered in the article could be resolved if the standard were more relaxed on iterator begin() returning a different type than end(). One instance of this can be seen if you look at the range-based 'for' loop's syntactical equivalence, where both the begin() and end() iterators are forced under the same 'auto' declaration. Instead, if they were allowed to differ, end() could return a sentinel iterator type that the "real" iterator type could efficiently compare against. Of course, this doesn't stop you from returning different types for begin() and end() today to avoid the comparison and branching overhead, but I don't know how pervasive the assumption for same-type iterators is within the STL, and what else may break because of it.
No really, undef that at the end of the file. Its unbounded lowercase macros like that which produce very cryptic error messages when they cross the file boundary and start replacing things they were not suppose to. When you inspect the location where the error happens you don't seen anything wrong because macro substitution has not yet happened. Two rules good macro use (I stick by them at least): * UPPER CAPS ALL THE TIME * undef as soon as humanly possible
When you use a screwdriver, do you tape a hammer head to it?
Can't really say I use a screwdriver all that much, so I don't know.
https://github.com/maidsafe/MaidSafe Build instructions https://github.com/maidsafe/MaidSafe/wiki/Build-Instructions
Well, its a little unfair how you write the function with two pairs since you are removing optimization from the compiler(most algorithms are inlined and thus optimized further). So the range_strlen(), should be written as this: int range_strlen(char const *sz) { const auto r = c_string_range(sz); auto begin = r.begin(); auto end = r.end(); int i = 0; for(; begin != end; ++begin) ++i; return i; } Then it will produce this assembly: xorl %eax, %eax testq %rdi, %rdi jne .LBB1_1 jmp .LBB1_3 .align 16, 0x90 .LBB1_2: incq %rax .LBB1_1: cmpb $0, (%rdi,%rax) jne .LBB1_2 .LBB1_3: ret Which is closer to the original assembly but still has more branching. However, if we want sentinels we should let the compiler know by using const member variables: struct c_string_range { private: char const *str_; public: using const_iterator = struct iterator : boost::iterator_facade&lt; iterator , char const , std::forward_iterator_tag &gt; { private: friend class boost::iterator_core_access; friend struct c_string_range; char const * str_; const bool sentinel_; iterator(char const * str) : str_(str), sentinel_(false) {} bool equal(iterator that) const { if (this-&gt;sentinel_ == true) return *that.str_ == 0; else if (that.sentinel_ == true) return *this-&gt;str_ == 0; else return this-&gt;str_ == that.str_; } void increment() { assert(str_ &amp;&amp; *str_); ++str_; } char const&amp; dereference() const { assert(str_ &amp;&amp; *str_); return *str_; } public: iterator() : str_(nullptr), sentinel_(true) {} }; c_string_range(char const * str) : str_(str) { assert(str_); } iterator begin() const { return iterator{str_}; } iterator end() const { return iterator{}; } explicit operator bool() const { return !!*str_; } }; Now the `range_strlen` will produce the same assembly as `c_strlen`: xorl %eax, %eax cmpb $0, (%rdi) je .LBB1_3 xorl %eax, %eax .align 16, 0x90 .LBB1_2: cmpb $0, 1(%rdi,%rax) leaq 1(%rax), %rax jne .LBB1_2 .LBB1_3: ret Assembly was produced with `clang++ -S -O3 -DNDEBUG -std=c++11` with clang 3.4.
I have sometimes used taus88 instead of mt19937 as the random number generator because it is much faster, but have now switched to my own implementation of George Marsaglia's MWC (see [here](http://www.cse.yorku.ca/~oz/marsaglia-rng.html)) which is about 5 times faster and random enough for my usecase.
Comparing two end iterators via your `c_string_range::equal` results in dereferencing a `nullptr`.
I say as much in my blog post: &gt; in practice, the compiler can often generate better code for range_strlen. If the compiler can infer statically that end is in fact a sentinel, and if the definition of range_strlen is available for inlining, then the compiler will generate better code. Near-optimal, in fact. But those are some big ‚ÄúIf‚Äùs. Trouble is, you're leaving a lot to chance. An innocuous-seeming code refactorization could easily flummox the optimizer and if you do, you fall off a performance cliff. EDIT: Your code will access-violate when comparing two sentinels. See? It's not so easy to get this right. :-)
&gt; Sadly, that assumption is very pervasive. With today's STL, everything breaks if the types of begin and end differ. Could you give a specific example? I guess you're talking about some case where template argument deduction would fail? Could you have `begin()` and `end()` returning different types, but where the latter type converts to the former type if requested?
I recently transitioned from Java to C++, but I know some Python as well. What worked best for me was reading Bjarne Stroustrup's "The C++ Programming Language", and then just going straight into making a game. I basically just told myself that I have to make a game in C++ and then put everything together from there.
Specific examples abound. Pick any algorithm. `std::find`'s prototype looks like this: template&lt;class It, class V&gt; It find(It begin, It end, const V&amp; v); If you try to call it with two iterators that have different types, there's no way to deduce the type `It`. A conversion doesn't help you because it won't resolve the ambiguity, and also because turning a sentinel into an iterator would be O(N) (it would have to walk from the beginning).
A range shouldn't be seen as a "pair of iterators". It's a single iterator that happens to know when it is finished. I forget the details, but that's the basic idea I got from a presentation on how the D programming language uses range. There are input ranges, and output ranges. (And some ranges could satisfy both the requirements of input ranges and output ranges) For some input ranges, such as that over a `vector`, it is natural to reread the same value multiple times before moving on. But that doesn't work so well when reading a stream from stdin. This distinction is clearly for an output range - you can write repeatedly to the same cell in a `vector`, but you cannot undo a write to a terminal. Some ranges, such as a (non-`const`) `vector`, can be both input- and output- ranges. Efficiency is important too. If you're going to read each item in an rvalue vector at most once, then it is faster to `move` from them. The range should make all these optimizations automatically when safe to do so. Here is a list of capabilities that would be relevant. These capabilities are additive. I've only just handle simple "forward-only" operations, but I think these ideas are useful. To some extent, they can be mixed and matched arbitrarily, but there is some dependence. The item type is `T`. 1. BasicRange: Has a method `bool empty()`. The exact meaning of the return value depends on the type of range. For an input range, it tells us whether the range has reached its end. 1. BasicInputRange: (requires BasicRange) Has a method `popFront()` that discards the current value and moves on. 1. ReadAtLeastOnce: (requires BasicInputRange). Has a method `T pull();` that will read the current item, returning a copy, and advance. Repeated calls to `pull()` might not return the same value - remember, it is advancing through the vector/stream/whatever. (This could be very efficient in the case of range over a container that is an r-value - the implementation of `pull()` could `move` from each cell of the container as it knows that cell will not be read again.) 1. RepeatableRead: (requires ReadAtLeastOnce). Has a method `T front()` that will read the current member. Repeated calls will return the same value. This makes sense when ranging over a `vector`, for example. But this isn't always sensible for all ranges. At this point, it's worth noticing that `pull()` could be implemented via a combination of `front()` and `popFront()`. So, if you can implement the latter two for your custom range type, then the `pull()` could be (and should be) automatically generated for you. Similarly, given a ReadAtLeastOnce range, it would be possible to create a RepeatableRead range that implements `front()` by storing a copy of the current value. This would require a little extra memory, and might slow things down. Also, this would not be possible for member types that cannot be copied (`unique_ptr&lt;&gt;`), therefore it is not always possible or desirable to synthesize this `front()` method. Further capabilities are about the ability to write to a range: 1. WriteAtLeastOnceRange: has a method `void push(T)` that will write the value and move on. A good example of this is output to a terminal - once you write a character, you cannot 'unwrite' it or 'overwrite' it. 1. WriteRepeatedly: (requires WriteAtLeastOnceRange) Has a method `void setFront(T)` to assign the current position. Does *not* advance. Repeated calls to `setFront(T)` will affect the same position. Suitable for containers. A range over a non-`const` `vector` could be both an input and output range, and will have all the methods mentions defined above. For any given position you can read and write to it. In fact, if a range has WriteRepeatedly and RepeatableRead, then we could tweak the signature of `front` from `T front()` to `T&amp; front()` 1. RandomAccessInputRange (requires BasicInputRange). Has a method `void advance(int)` that can (quickly) advance forwards or backwards an arbitrary number of steps. There is further work to be done. For example, you might have a 'RandomAccessForward' capability, with a method `advanceForward(size_t)` that can only advance forward. This would be inserted in between BasicInputRange and RandomAccessInputRange Finally, a note on syntatic sugar. For me, the following operator overloads make sense: 1. `r++ ` is equivalent to `r.popFront()` 1. `r &gt;&gt; x` is equivalent to `x = r.pull()` 1. `x = *r` is equivalent to `x = x.front()` 1. `r &lt;&lt; x` is equivalent to `x.push(x)` 1. `*r = x` is equivalent to `r.setFront(x)` It shouldn't be possible to do `*r = ... ` on a range `r` unless it satisfies WriteRepeatedly. For example, I don't approve of the fact we can currently do `*it = ...` on output iterators. To me `*` simply dereferences a pointer (or iterator or range), it should not also (silently) advance the pointer. (Apologies for typos, and for lack of response! I'm tired and am going to bed now!)
LOL, you are really newfag. 
Oops, that was a mistake, the comparison should be something more like this: if (this-&gt;sentinel_ == that.sentinel_) return this-&gt;str_ == that.str_; else if (this-&gt;sentinel_ == true) return *that.str_ == 0; else return *this-&gt;str_ == 0; 
Yes, of course, the assignment operator: iterator&amp; operator=(const iterator&amp; rhs) { if (this != &amp;rhs) { this-&gt;~iterator(); new (this) iterator(rhs); } return *this; } 
&gt; This what the compiler will do **for the limited example I presented**. Fixed that for you. ;-) &gt; I can see how passing a pair of those iterators through a `virtual` function or `std::function` can break this optimization Yup. Or suddenly exceeding your compiler's inline depth. Or moving some code into a separate translation unit. Or moving to a different compiler. Or... 
I don't think your optimization is correct in general, because different iterators shouldn't be considered equal just because they point to equal values: auto x = c_string_range("foof").begin(), auto y = x; ++y; ++y; ++y; assert(x != y);
Thanks for the info! I wasn't sure about Boost.Regex/Xpressive, but thought that if anything within boost could help with regex, any of those should be it (i don't know why i had integration with ICU in mind). &gt;My hope is that Ogonek gets regex support rather sooner than later I don't know if this is even within the purpose of ogonek. Still a different library can build on ogonek to implement regex for unicode strings.
&gt; It denies the existence of "position" as a representable entity That is certainly what they say, but not what they do. They use integers to denote positions as in the n-th element of the range, e.g. partialSort(r,n), take(r, n), drop(r,n), .... &gt; Which range should that return. Boost.Range lets you choose which range it returns. I've always found this to be extremely nice.
Two things: 1. I was wrong about Boost.Regex and ICU integration (it does apparently exist!) 2. Word of god (i.e. the maintainer) has stated that he‚Äôd love to integrate regex support in Ogonek but doesn‚Äôt have the time. Personally, I also think that you fundamentally *need* it for a text library to be useful. Regex and Unicode go hand in hand. Without regex, text processing becomes absolutely dreary.
Yes, that's what ArashPartow apparently meant (e.g "replace the code point with another code point that might consume more or less memory than the original") and what cybermind objected to. That's the *other* problem in ArashPartows comment which cybermind did not correct. Even so, searching and replacing codepoints means what you're doing is specified in terms of Unicodes implementation details. You're not working with the level of abstraction that typical users are interested in. Though admittedly it doesn't mean you're necessarily doing the wrong thing. Actually, as a further criticism of ArashPartows comment, the only thing you can't easily do with a UTF encoding is in-place modification. Algorithmic complexity is *usually* the same when you have to produce the result as a modified copy. Obviously that has a cost - a huge one if you just want to replace one character in a multi-gigabyte document (though I hope you wouldn't represent that as a simple string in memory) - but as pure functional programming advocates will point out, it also has advantages. 
&gt; but maybe it is just better to just use an iterator to the mid element &gt; rotate(range, mid). Yup.
Good points. I vaguely remember that discussion, and that I wasn't too impressed with the D approach. &gt; You simply cannot get away from Position as a fundamental concept. Yes. Let's start with that, and I'll try to rethink and improve my suggestions. There should be a basic Position concept, but it can also be called Iterator. We have it already in C++, and I don't propose to weaken or deprecate it in any way. (As I said above, I don't like the assumption that all iterators should be dereferencable as `*it`. I would say that one or more of the following should be possible: `*it =x` or `x = *it` or `it &lt;&lt; x` or `it &gt;&gt; x`. But that's slightly beyond the scope of this comment.) Anyway, some iterators are more powerful and flexible than others. Some can be read from, some written to, some both. Some output iterators allow multiple writes to the same location, whereas some (such as output to the terminal) do not allow more than one write. Some allow random access. Some allow differences to be calculated between them. Now that we accept that not all iterators are equal, allow me to suggest another optional feature for iterators. I suggest that we extend the iterator concepts to include the fact that some iterators "know when they are empty". Some iterators will have an `empty()` method. The obvious example is an iterator over the characters in a string, they know when they are finished. Also, an infinite source of data knows that it will never be empty. So, I'm not arguing that Ranges replace Iterators as the recommended mechanism for new C++ code. What I like about C++ is the ability for new and old ideas to play together nicely. I merely suggest that some iterators should know their end. Such an iterator could be called a Range, but perhaps another name would be appropriate to avoid confusion with the entire D philosophy. Some (but maybe not all) standard library functions (such as `find`) could be extended to support accepting one of these "end-aware iterators". `find` would still return an iterator. Where possible, and without compromising efficiency, it would return an "end-aware iterator", but that is just optional extra information that the caller doesn't need to use. It would still be possible to take the original beginning and the return value from `find` and combine them, these two values do not lose any of their Iterator properties, and we are not required to use the extra `empty()` method if we don't want to. Some functions (but maybe not all) do *not* need to be aware of the "end-awareness mechanism". i.e. the "end-aware iterator" might be implemented by pairing the (primary) iterator with another hidden iterator whose only purpose is to be compared inside the `bool empty()` method. Which STL functions really need to know two Positions? My guess is that many functions simply need one Position and some way to perform a boolean test as to whether they are at the end. Functions shouldn't insist on being given more information than they need.
Do you know about [ICU](http://site.icu-project.org/)?
OK, I think I've fixed `find`. (*8 hours later: Actually, I haven't really. I've made some code compile, that previously didn't, but I'm no closer to solving the main problem*) The original problematic code is: template&lt;class It, class V&gt; It my_find(It begin, It end, const V&amp; v); struct B { }; struct E { operator B () { return B{}; } }; int main() { B b; E e; my_find (b, e, 3); // This fails to deduce } It fails because `b` and `e` are of different types, which `my_find` expects the first two parameters to be of the same type. This is frustrating because I've included a conversion operator from `E` to `B`, and I wish the compiler noticed. A solution is to disable deduction on the second argument. Add this `wrap` template: template&lt;typename T&gt; struct wrap { typedef T type; }; and change the signature of `my_find`: template&lt;class It, class V&gt; It my_find(It begin, typename wrap&lt;It&gt;::type end, const V&amp; v); The compiler knows that it can't deduce the argument of the second parameter, because its a more complex form `wrap&lt;It&gt;::type` Therefore, it simply uses the first and third parameters to deduce `It` and `V`. Then, it tries to take the second argument as an `It`, and uses the conversion. Any problems with this? I don't think this signature change would break any existing code. And I guess it's not aesthetically pleasing that I have made the second parameter special - why didn't I apply this idea to the first parameter? But it does allow `find` to, where possible, accept a different type for the `end` parameter.
MS is indeed slower than gcc with new standardd features, but if you are just on-and-off, you are likely just fine. As for other compilers (clang/gcc) and corresponding toolchains (gmake), sure, you can do that, but they wil not tell you much about the language. If you want to use makefiles, you can do that with toolchain of MS. I see not much point, frankly. If you want to try language features in particular, you can merely go to a random online compiler and try there (haven't done that since some time, but I seem to remember that comeau, the one I used, is gone).
&gt; I see not much point, frankly. If OP only wants to learn, you are right. However, if there was some requirement to develop multi platform lib, using makefiles with MS toolchain might actually be a good way to pull it off.
Get [mingw](http://www.mingw.org/) or [cygwin](http://www.cygwin.com/) and include the development stuff. Next, create a file, helloworld.c, then make helloworld or alternatively gcc helloworld.c -o helloworld.exe Make is smart enough to make an executable from a source file without needing a makefile, or you can invoke gcc directly.
[GCC](http://gcc.gnu.org/) is the Gnu Compiler Collection, a group of compilers and back-ends that support numerous languages, including C++. For windows, you would want [MingW](http://www.mingw.org/), a subset of UNIX that runs on windows and supports basic command line builds. [CLang](http://clang.llvm.org/) is a C/C++/Objective-C front-end to the LLVM compiler toolkit. It is mainly been developed for Linux and the Mac and is used and developed in part by Apple. Windows support has been lacking, but the toolchain has been moved and is now under active development. It lags behind GCC a little, but is a popular alternative due to it's permissive license and strong support. Both GCC and CLang support the latest standard C++, called C++11. This introduces features like lambda expressions (first-class functions), type inference and range-based loops, among others. They are also actively implementing new features proposed for the next standard. VC++, even with 2013, doesn't support the full standard, although it does support many of the features. There are a number of IDEs that support GCC and Clang, including [Qt Creator](https://qt-project.org/wiki/Category:Tools::QtCreator), [Code Lite](http://codelite.org/), [Eclipse](https://www.eclipse.org/cdt/) and [Netbeans](https://netbeans.org/features/cpp/). All of them require some setup and configuring, unlike VS which C++ is plug-and-play. 
First off, good for you. It is extremely important and your life will be much easier. You should consider working from the terminal + a light weight text editor for a while. 
The point is to have two different types of iterators within `find`. Making it so that the end iterator can be implicitly converted to the begin iterator's type doesn't really gain you anything.
Great idea. I ditched IDE's and Windows in general a while back; and don't regret it for a second. Quick question. Would you be willing to give Linux a go? It really is vastly different (IMO superior) development experience to Windows, but more FOSS/DYI friendly? If so I would recommend full immersion into the wonderful world of writing code with a decent text editor (I'll let you pick your own side; but give both vim and emacs a go). Learn to write your own makefiles and learn the basic compiler flags. I won't lie, that's a quite a steep learning curve, but not as steep as learning C++ in the first place! And you will be a better dev for knowing it.
I agree, once you do, you won't go back either.
&gt; sure, you can do that, but they wil not tell you much about the language You see here is where I disagree. Coding C++ is more than just pressing "build and run" in your compiler. Despite what MSVC would like you think. C++ was designed to optimise well, compiler flags are important, you benefit knowing if there are any gain for your code using O3 or Os or lto. You learn how code is compiled in translation units, and why that template heavy super file with 1000 includes takes forever and a day to compile and what you can do to speed it up. You learn why templates need to go in headers and not in source files.
I don't understand why there is always a subset saying "You need to know your compiler flags" and hating on Visual Studio. The compiler options are turned on using command line flags, and if you dont want to memorize a bunch of flags you can just think "Full Optimization" instead of "/Ox" or Optimize for Speed "/O2" I still need to know what the optimizations do and which I want. I need to know about translation units, and why these two functions are colliding with each other and wont compile. I need to know why to put templates in headers and that including extra headers is going to greatly increase compile time. I'm not saying MSVC is better but they are all really commiserate. When anyone distributes a CMake file for a lib you want to use, do you throw it away and make your own "Because I need to know how to push all the buttons and switches" or do you just type make, and use the output. Personally I'm more then happy to use someone else's work until I find a need to extend or alter it.
I agree. Programming with makefiles and just a text editor on Linux will broaden your horizons. It's not that it's necessarily better (although I think it is), but it's good to learn different ways of doing it. I go back and forth between vim on Linux and Visual Studio on Windows all the time at work. It's good to know both.
Honestly, IMHO, unless you have some deep seated desire to use makefiles and the like or a need for them, there's no reason to go down that path. Maybe I'm on the outside, but I've never understood why Linux is so great, despite using it for several years of my undergraduate and occasionally in my professional career. It only ever served to make things take more typing and rarely ever simplified any process. However, the whole process is interesting and I would recommend everyone get a taste of it if they are so inclined. EDIT: Really bad grammar.
You can develop in MSVC without knowing how code is actually compiled. You can't get past 2 TU's and not know from the shell.
&gt; It's not that it's necessarily better (although I think it is) Precisely. Find me the guy know used it for any prolonged period of time and then went back.
Why not? People are also *good* in learning and following recipes, not having first idea of whys and how's... methinks you're overdoing it.
Sure, but I wouldn't employ a chef who only knew how to follow recipes. OP already knows C++, he is asking how to above and beyond it, learning the details as to how higher level tools are built up is definitely one way of doing so. Furthermore, most people who do learn the iron age tools (editor + shell...) way of doing things don't go back, and for good reason.
&gt; If you want to try language features in particular, you can merely go to a random online compiler and try there (haven't done that since some time, but I seem to remember that comeau, the one I used, is gone). That doesn't allow you to make use of those features in anything other than trivial test cases.
Someone is just downvoting anyone suggesting the use of a shell. Ignore them.
Ah, I understand better now. I'll be looking into all of those links, thanks!
Can't you duel boot or VM in the mean time? You'll find that most Linux distros are considerably lighter and faster than windows, and so don't require as much space (storage or ram). If you can spare 5-10gigs on you HDD then that's all it needs really. PS: linux is the ideal tool for learning on the cheap, not only is it free, it's tools are free and it's libraries are free. And that's free in many sense. Want to learn from an existing program, no problem, and and look at it's source code (something I've learnt to do a lot of)!
There is no way a VM is going to damage your actual machine, they are sandboxes for you to play in :). All I would say, is that the only really effective way I've seen for people to embrace the shell and linux as a whole is to full immerse you're self in it. But I'll leave that for you to find out. If you want any input or help in getting started feel free to drop me a PM.
&gt; Programming with makefiles and just a text editor on Linux will broaden your horizons. I enjoy programming with vim (+cgdb) on Linux, but makefiles are definitely not the enjoyable part of the experience.
After you're fairly familiar with using C++ in practice (including being generally familiar with the content of books like _Effective C++_, _Effective STL_, _Exceptional C++_, and maybe even _Modern C++ Design_) the next step for really getting to know the language is to become familiar with the ISO C++ standard, the document which defines C++. The spec is difficult to just dive into so one gentle method of introduction is to read C++ answers on stackoverflow.com which reference the standard and to try to follow along in your own copy of the standard. --- Makefiles are essentially build scripts used by the build tool 'make', like Visual Studio solution and project files are to Visual Studio. Microsoft's NMake tool is similar to 'make'. Clang and gcc, in this context, are simply other C++ compilers, like Microsoft's cl.exe which is used behind the scenes in Visual Studio. --- Becoming familiar with multiple compilers is another important step in getting to know C++. C++ is complex and not all implementations behave the same all of the time. In many cases they're not even required to behave the same by the specification. Learning about the different permitted behaviors and gaining experience working around compiler bugs can be very helpful. Different compilers also offer different features you may want to try out. Clang and GCC tend to move faster than Microsoft's compiler and, in my experience clang has been moving fastest (though it's much newer and so it took a while to catch up; it didn't even support C++ well until 2010, but currently seems to be at the forefront of implementing the latest standards), provides the best diagnostics and is generally the strictest w.r.t. standards conformance. Unfortunately clang's C++ support on Windows is very immature and not ready for real C++ projects yet. It's been improving more recently and you can at least use it to play with most language features and some library features on Windows, but some basic functionality is still missing which prevents one from using, for example, iostreams. --- If you don't want to try to build clang or other compilers on Windows and don't have another setup to try them on, there are a number of places that let you compile C++ code online on a number of different compilers. http://isocpp.org/get-started has a list. I usually use http://coliru.stacked-crooked.com/ as it lets you run a variety of commands and different tools, and also seems to have the most up to date version of clang. One drawback is that it doesn't seem to offer the option of using libc++ instead of libstdc++.
Can you give an example where it is better to use inheritance over composition? 
Wow, thanks for the informative post! I have Effective (and More Effective) C++, although I plan to go through them again. I had not heard of the other books so I'll be sure to check them out. Those online sites look pretty great too. It looks like gcc will be what I start with for really digging in. 
Well done! A couple of style points - indent source code snippets and make sure they don't get impinged on by graphics and require horizontal scroll bars (like in Pt 2) - reference also Stroustrup "A Tour of" book - note if there are features covered for which you need VS 2013 vs 2012 (and the "C++11 conformance" bar chart should also cover 2013, altho a simple % of C++11 features covered statistic is, as discussed in other threads, not that meaningful
Oh yeah :-) I was so obsessed with making it compile, that I forgot about the ultimate goal! Why not just change the signature like this: template&lt;class It1, class It2, class V&gt; It1 my_find(It1 begin, It2 end, const V&amp; v); I think it wouldn't break, or change the meaning of, any existing code. (But I'm no expert on template deduction). Once that change is in place, we could suggest that `.begin()` and `.end()` could return different types. This should, I think, play well with the STL, but it might change code that has been written by others outside the STL. Mmm, but yeah, I can see this is hard after all.
&gt; Why not just change the signature like this: &lt;snip&gt; Why not, indeed? &gt; but yeah, I can see this is hard after all Yeah, ranges are surprisingly slippery.
thanks for the comment. I've tried to change first part a bit, but sill need to upgrade formatting.
Well, it was a really interesting read; and I've certainly suffered from the issue of delimited ranges a couple times so I'm definitely interested in a better solution that the current state of the art. Thanks for looking into this!
please expand on your first edit as to what type / kind of companies can be built around your skill-set in a weekend or two
I see no reason why a `Position` should be an `Iterator`, and I see a couple of efficiency reasons for why it would be a bad idea. For example, imagine a `filter` operation that takes a range as input and produces a proxy that only allows access to elements of the range matching the predicate. The `Iterator` there is fairly complicated: - it has to know the predicate logic - it has to know the end of the range (to avoid going over) However a `Position` is just that! Maybe just a pointer to the given element.
I don't think it would break any existing code specifically because of the problem you found a solution for (i.e. passing two different types of iterators results in a deduction failure rather than an implicit conversion, so obviously no existing code is relying on an implicit conversion that would go away). I'd still be completely unsurprised if part 2 of the series was a giant wall of reasons why this idea wouldn't work. The concept of ranges is used for a whole bunch of different things (and there's a bunch more that'd be nice to be expressible as ranges that aren't with the STL model), and the more I dig into it the more I understand why no one has come up with an entirely satisfying solution.
Mostly fair points, despite the slight smugness. I appreciate the pointers. I'm glad to hear that there's been progress since my last sincere attempt. I certainly don't fault vim for not having those things by default. That would basically go against the main premise of the program. I'll definitely look into those whenever I inevitably end up back in linux for a while. This is maybe off-topic now, but since you're in the mood to help, there another question you might be able to help with. Given a large project with thousands of files and deep filesystem hierarchies, how do you quickly open a specific file. I like that in VS I can ctrl-, and just type a symbol or filename and it will show me a list of matches immediately. I rarely need to actually care about or maintain the list of files that are included in the build or where they are on disk. What's a good way to do this in your style?
Well, obviously, it wouldn't be anything big, but it really is possible. Things within reach of a weekend warrior would be on the scale of a small web service, a lightweight phone app, or a branch of existing software spun out as a service of some sort. The tech-demo route is another alternative if shopping rapidly built, buggy, alpha-quality software around doesn't turn you off. Finally, there's the bounty route: there's lots of low-hanging fruit out there that can be done in a few days work for cash (granted, you'll be doing it more for your CV than the money, but it's out there). All those are in the single-proprietor ballpark. If you assemble a team, you can do even more provided you stay coordinated. Things become even more interesting if you eschew the idea of writing things from scratch, and integrate existing technologies instead. The point is that once you understand how to write and maintain software, it's possible to turn an idea into something people will pay for, with just some sweat and solid direction. Assuming one has a decent computer, has paid their electric bill, and can pay for basic web services for promotion and hosting (which run as low as dollars a month), *there are no resource constraints other than time.*
msvc isn't that slow. I'm currently using it and it even has support for std::make_unique (which is c++14). Overall, it's good enough if you don't need everything from c++14, and it supports most features from c++11.
&gt; the more I dig into it the more I understand why no one has come up with an entirely satisfying solution. Boy, can I relate!
Thanks for your critique. your absolutely right in calling this overengineered. CMake was not made for this. However my reasoning behind making a c++ package manager with cmake ist that CMake can generate project files for every c++ IDE. It is also easily possible to write a small cmake facade for all other building tools like scons and make. Also for the project I am actually working on using cmake is a prerequisite... I know of cmakes modules but I want a more "nuget like " approach if that makes any sense. for pure project dependency management there is already a great package manager by James Hughes (https://github.com/iauns/cpm) which I want to extend by a commandline tool and an online package repository for cmake. He has solved the problem of dependencies and depending on multiple versions of a static library Contributing to cmake's c++ code may be an idea for the future :) 
&gt; Maybe just a pointer to the given element. Sometimes you cannot take a pointer to the element because it does not exist as such in memory, e.g. the elements of a zipped range, containers using proxies such as vector&lt;bool&gt;, ... 
matthieum is not alone in wanting to decouple the representation of position with the intricacies of element access. If you Google "cursors and property maps" you can read all about it. A cursor deals exclusively with traversal, and the property maps, which you can think of as free-standing getters and setters, handle reading and writing to the value at the element referred to by a cursor. It has some advantages, but I'm not sold on the idea. At least not yet. It adds some complexity, and I'm not sure the gains are worthwhile.
How about actually producing something and getting paid? I don't have a problem with Linux, but the tools are lacking. Great, I can compile to C++11. Now lets debug it using GDB that might as well be from 1995. I'll take a large subset of C++ features with a great visual debugger any day of the week. 
I"m more than competent with Linux and, if after 4 years of undergraduate, I wasn't, then it's a tool I don't consider worth my time. I am a developer by profession; if I can't take a reasonable amount of time to turn a tool into a productive piece of my environment, then I will chuck it out the window in favor of something else. I am of the generation that feels shit should just work out of the box and that it should be easy to use/configure beyond such a point. Sadly, however, I feel the Linux community left usability at the door decades ago.
I wish I could have read this a year ago. Reads very well, nice work!
your depth of knowledge of c++ is platform independent. i use all three. gcc has great performance, clang has lots of potential in tooling and VS the best debugger. All three will catch different bugs. use the one you're most comfortable and productive with. concerning c++11 vs was lacking a year ago but is fine now.
&gt; I am a developer by profession As am I &gt; I am of the generation I am intrigued as to what generation that is. I am in my twenties. &gt; am of the generation that feels shit should just work out of the box and that it should be easy to use/configure beyond such a poin And you believe what? That windows is that right tool for the job. An OS which no long has a start menu in favour of opening a whole screen menu. Yes, that's a good work flow.
&gt; How about actually producing something and getting paid? I get paid to write code for all platforms including Linux. &gt; Great, I can compile to C++11. Now lets debug it using GDB that might as well be from 1995 GDB is easy &gt; I'll take a large subset of C++ features with a great visual debugger any day of the week. Or have both. There are no shortage of visual debuggers for Linux. QtCreator and Eclipse come to mind. But actually like most tools, once you've got over the learning curve with GDB it is actually a very fast way to debug.
&gt; I'd really like to try using them but any tutorials I've found make it difficult to understand. [Reference](http://en.cppreference.com/w/cpp/language/lambda). The simplest form of a lambda is: [] (args) { body; } It defines a function that takes those arguments and returns whatever the body returns. Something like: auto abs = [] (int x) { if (x &lt; 0) return -x; else return x; }; int y = abs(-4); // y == 4 Sometimes, you'll want to let the lambda refer to variables that are in the scope it's created in. For that, you'll need to capture variables. int x = 3; auto is_greater_than_x_was = [x] (int y) { return (y &gt; x); }; auto is_greater_than_x_is = [&amp;x] (int y) { return (y &gt; x); }; x = 5; bool b1 = is_greater_than_x_was(4); // b1 == true bool b2 = is_greater_than_x_is(4); // b2 == false There are two ways of capturing a value: by reference or by value. It works the same way that it does with function parameters, except the value capture is captured at the time the function is created, not when it's called. Beware of dangling references, so make sure that the lambda function is not able to live longer than anything it captures by reference. Sometimes, you'll need to be specific about what type the lambda returns. The syntax for that uses a trailing return type, like this: auto truncate = [] (float n) -&gt; long long { return n; }; float x = truncate(3.14158); // x == 3.0 In case you're wondering, the reason I'm using `auto` everywhere is because the type of a lambda expression is a compiler-generated name that you can't ever count on knowing, so you can only ever assign it to a type-deduced variable (`auto` or templates) or a type-erasing (`std::function`) one.
&gt; Please note that C++11 is fully compatible with the old standard, so it should not break your existing code. That's definitely not true. Just look at `diff.cpp03`. Sweeping statements and C++ don't mix. (usually, lest someone proves me wrong) Overall, a nice read, everything is explained in layman's terms, even old concepts that were added to the standard library in C++11.
It's not about it being easy or not, it's a case of quality. I dev in linux (vi) because of all the reasons you listed earlier. However, if I have a serious bug I'm into VS because the debugger is way too good. Yeah sure, if I have a simple bug to fix then I can use GDB+frontend. The people who write off linux annoy me, but likewise the people who write off VS are just as ignorant. Yeah sure the compiler is behind in terms of C++11 features, but it produces fast executables and the debugger is pure silk.
&gt; UTF32, while likely wasting space, can represent every character in the entire Unicode character set in the same amount of space. No, it cannot represent one grapheme with combining diacritics in the same amount of space as without the combining diacritic. The word "character" is undefined for unicode.
There are feature-limited express editions of Visual Studio available for free, the full "professional" version are not free. The primary limitations (as far as I know) of the express edition are: * no plugins * you need different versions of the express edition to handle different solution types So generally, the express edition should be just fine. You can download it [here](http://www.visualstudio.com/en-US/products/visual-studio-express-vs)
Thank you. You helped make my day go a bit easier. 
Thank you. You helped my day, go a bit easier. 
Visual studio express, but if you are a college student you can get visual studio professional for free @ https://www.dreamspark.com/Student/Default.aspx
I have another question: I am trying to get a c++ project going by going to New Project but I do not see any option for C++. Do I need to download something elsE?
you are barking up the wrong tree, most people that think this way are so delusional that they will confide them self to the hell that is windows development forever. i guess its because its /r/cpp that you are being downvoted, and its probably a bunch of sophmore's in college who think visual studio is amazing, but everything you said is spot on and the most logical response ive seen so far.
Yea, I guess it is a little fragile. It seems like a new concept for iterators such as a MonoIterator, which wouldn't require an end iterator to know the end. An end iterator would only needed to be provided for backwards compatibility, for those algorithms that haven't converted over to range-based.
if you don't see why simple things like the shell being fuck tons better on linux distros (or even osx) is advantageous, then we are wasting your time. &gt; I am of the generation that feels shit should just work out of the box and that it should be easy to use/configure beyond such a point. Sadly, however, I feel the Linux community left usability at the door decades ago. I am probably younger than you, and i have nothing but sadness and despair for people who try to convince me why an IDE is so awesome (and yes I've worked from quite a few). There are verrry few circumstance where its required or more practical to use an IDE, but 99% of programming workflow can be managed much better from a good terminal/console, hence linux's popularity among programmers. **you're argument is literally this: "training wheels make riding a bike easier, therefore it's better". try mountain biking with training wheels**
nope you wont, my favorite analogy is VS is like a bike with training wheels. If you want to start mountain biking, you gotta pop those training wheels off. Some people are scared to do this, and i suspect thats why you are being downvoted.
You're right about a lot of the tools as long as they don't have to make a graphical user interface. The aversion to a good GUI is pretty astounding really. In most respects Linux has the most tallented, forward thinking people but it's hard to name a single non-trivial application with a polished commercial-quality UI. 
i know i've commented on like 3 of your posts, but you are a wise man. saved me a lot of typing.
I'm pretty sure if you open your project in vi, there are plugins that will recursively search through all subfolders. Also another neat thing is that these (if i recall correctly) can match on patterns, symbols or even the first letter of each word. for example: you have a file "Random code diagnostic toolkit boobs" you could hit search and type: "rcdt" or probably less and it would match the file. Not aware if this is avail in VS or not, but just know that pretty much any little quirk or customization you want, there is probably a plugin for it.
People who make these analogies are the hipsters of computers. Your predecessors who invented Unix also invented the GUI for a reason. It is a better way to display and work with more information. It's a shame that the current generation would rather pride themselves on arcane workflows rather than innovate.
RValue references and Move semantics missing. The good part is that even one does not know anything about them just compiling ones existing C++ code with C++11 compiler will make generated binary more performance efficient. IMO they are important part of C++11 and should be included in the tutorial probably part four. :) Well done overall.
why the fuck would I waste my personal and professional time if it weren't more effiient that way. They invented the GUI for users that don't have a technical or coding background, not programmers. If you want a bunch of pretty buttons just so you can be spoonfed through your programming tasks, go for it. 
Exactly! I've ran through the gauntlet and can code in vim pretty well, but damnit I love that I can examine a running state of a program so easily with MSVC. Everytime I try using gdb I've forgotten the commands already.
I'm open to the fact that I may be wrong and that what I've done on the commandline (mostly in Linux, some FreeBSD, even Amiga/AROS and BeOS/Haiku) in the past may have left a bad impression. Can you give me some concrete examples of what makes it more efficient than an IDE for you? 
Right! How could I miss that! I had this in my notes - and it is listed in Second part, but somehow it did not appear in the final articles. Will definitely upgrade the content. 
That was my initial idea. The articles are at more beginner level, so I've decided not to describe move/rvalues. They are only mentioned in the third part and the end. If you know the basics of C++11 then you could go deeper - I wanted to provide the basics. Thanks for the great comment!
that was the reason I wrote "so it *should* not break..." :) But it is probably more complicated and depend on a projects specifics. Thank you for comment!
I think position is sometimes useful, but I don't think any of your examples demonstrate it. &gt; I know how you're likely to reply: that `find` should return the range from the found item to the end. OK, that's one option. But maybe you want to operate next on the range `[begin,found)`. Then you should have used [`until`](http://dlang.org/phobos/std_algorithm.html#until) instead of `find`, no? &gt; Or maybe you're calling `reverse_find`. Which range should *that* return. Instead of providing `reverse_find`, provide [`findSplit`](http://dlang.org/phobos/std_algorithm.html#findSplit). Or do `range.retro().find(n).retro()` if you're strictly interested in `[begin,found)`. The STL still doesn't even provide `reverse_find`; you must use a reverse iterator in the same way. &gt; And what should `rotate` return? Lots of ranges to choose from there. STL's `rotate` didn't return anything until C++11. D's version of it is called [`bringToFront`](http://dlang.org/phobos/std_algorithm.html#bringToFront). For a lazy version, use [`chain`](http://dlang.org/phobos/std_range.html#chain) composed with whatever partitioning method you like. /u/andralex [wrote about D's ranges](http://www.informit.com/articles/printerfriendly/1407357) a while ago and [admits to these limitations](http://www.informit.com/articles/article.aspx?p=1407357&amp;seqNum=12), but *usually* it seems like you can work around them with minimal fuss.
The GUI was never meant for programmers, it was allow officer workers to write docs without a comp sci degree. And I assure you, IDE's are not a more efficient workflow once you've got over the learning curve. 
&gt; they are all really commiserate Grammar time! [define commiserate](https://www.google.com/#q=define+commiserate) versus [define commensurate](https://www.google.com/#q=define+commensurate).
Please read my comment I made elsewhere but basically it boils down to: 1. Once learnt vim keybinds (and any good text editor) are insanely efficient, (run vimtutor at your shell, oh wait you run windows, never mind). 2. On editor or all languages. The lst few projects I've worked on have required me to edit: C++, C, Fortran, Bash, Python, LaTeX 3. I've had many programming jobs now, some have made me program on Linux, some OSX and I suspect I'll regrettably have to do some windows work soon. But it doesn't matter vim will work anywhere and most of the command line tools work more or less the same where ever you are. This includes over ssh sessions, which again, you might not need now but who knows what you are doing 10 years down the line. 4. Choice, I can use an compiler I see fit, typically on Linux I compile against GCC, Clang and ICPC, all of which pick up different things. 5. The open source world moves faster, how is your shitty C++11 support treating you? 6. PACKAGE MANAGERS. Oh my goodness, they save so much time it's unreal. If I want boost, oh wait never mind it's already on my system and if it's not or I want to update it's a single line. Same for an other library. Same the for the source code for any program or library, I can just retrieve that and read it! 7. VS might be easier to build program for windows. But once I've crafted a makefile it's a LOT easier to port that from Linux to OSX to BSD... and even to windows than it is to compile a VS project on anything other than windows. Add that to the fact the command line methodology also has tools like CMAKE and Ninja for a much higher level automated approach. I really could go on for a while. But if you're going to write that off as "hipsters of computers" then I am not going to put any more time in. Just because you tried it and could grasp it don't assume that it does do wonders for others workflows.
I don't write off VS at all. It has a great visual debugger, although much of my code would even compile with CL.exe because it's not even close to C++11 completion yet. But in the context of the OP's comment/question, ditching VS would be very good way to get "past Visual Studio" (his own words). 
Why isn't `enum class CarType` declared inside `class Car`?
I didn't knew about bringToFront, thanks for pointing it out!
The only reason I could think of is if you wish to forward declare the `enum class` without providing the definition of the parent class. Granted, I believe making it a nested class is usually better in general although I'd rename it `Type` so it would have the scoped name `Car::Type`.
There's not much point in using them these days. As I understand it, they're a throwback to when you couldn't easily type those characters - either because the keyboards didn't support them or because they weren't safe to include in the files or network links...
I am not sure where you live but yes there are C++ jobs out there; and actually it's a very good reason to learn C++ as they are generally more lucrative than working with managed languages. That said, having just look for a job recently, it seems that a lot of the gets localised to specific places. Like certain cities just have more of it, and also at lest in the UK, smaller towns and villages have this niche work. 
yeah fair one. I thought you were trying to make the case that GDB+frontend (eclipse etc) was even close to VS in terms of visual debugging. I wish it was though! I write portable performance sensitive code so I write such that it can compile on a platform's native compiler. I am limited in terms of C++ features by what compiles in VS, which is a tad annoying. VS2013 seems to have a lot more features but I haven't upgraded yet because of the need to rebuild all my dependencies. sigh ;(
If you write performance sensitve code why aren't you using Intel's ICPC on windows it has a much better codegen especially for numerics? ICPC is also native in the same manner CL.exe is; no emulation, native ABI. Or if performance is a concern why are you using Windows at all (I know they might not be your decisions).
The users of the software are biologists so Win is the primary platform. Remember these are people who are known for storing BLAST data in word documents. The rest mostly use mac and a tiny fraction linux. You're right about intelcc. It's partially down to the fact I like VS for debugging so I have a motivation to keep the build up to date there and also because of the upfront cost. When I get this work published I'll convince somebody higher up to get me an icc license because I heard there's up to 40% perf increase with icc. It does trouble me a little though because I hate intel with a passion for their antitrust behaviour. To be honest they are worse than MS in that regard. But the best tool for the job in the end I suppose..
I am pretty sure you can get VS to compile with ICC and debug. In fact I think intel tout that as a feature. I don't know about 40%, but I do know the MS have basically left the HPC game altogether now and really care about that kind of performance any more. &gt; It does trouble me a little though because I hate intel with a passion for their antitrust behaviour Your using Intel CPUs right, and if not Intel architectures? Also I don't know if you can make use of it, but if you are doing LA then you are highly unlikely to outperform the Intel MKL library which comes with the Intel Suite.
Do you have any thoughts about how to _cleanly_ mix eager and lazy evaluation? The best thing I can come up with is: - if you omit the output range to an algorithm it will be lazy _if it can_ (e.g. sort can't be lazy), - otherwise it will be strict. This way, "function-calls" and "adaptors" are equivalent (i.e. they just provide a different syntax) and if you want to force eager evaluation to an output range you can call e.g. copy. However, i'm not satisfied at all since the following statements are not equivalent: zip(ranges...) | transform(f1) | sort(cmp) | transform(f2) | copy(vec); // Ex. 1 zip(ranges...) | transform(f1) | copy(zip(ranges...)) | sort(cmp) | transform(f2) | copy(vec); // Ex. 2 In Ex. 1 the sort is performed on a lazy transformed range (but this transformation is never "applied") while in Ex. 2 the first copy applies this transformation to the range, and then the sorting is applied. I have mixed feelings about this approach since I think it is both nice and dangerous. Furthermore, identifying how many loops will be generated is hard. One needs to know which algorithms are eager and which ones are lazy, which I think might be misleading/error prone. P.S. the "pipe" version of `sort` acts in place if no output range is provided, and assumes the input range to be writable: `input_output_range | sort(cmp)`. If one can write to a transformed_range or not, that's another matter.
Well this project is performance sensitive but not HPC per-say. Though I have put in MPI for HPC support as it's a bit of an embarassingly parallel problem (Stochastic Simulations). But I assume it will be used by biologists on their own machines (probably a laptop) and I'm trying to squeeze all I can out of those with OpenMP and optimisations. No LA involved at the moment, but I'll look into using MKL when I move onto my next project which will involve lots of LA. Yeah the target are Intel architectures, but for instance I have 3 AMD machines and 3 Intel machines but intel's compiler has deliberately hobbled performance for the AMD CPUs which I find reprehensible. I would disagree that MS don't care about performance anymore. I think the performance of the executables produced by CL are pretty good. Thanks for the tip about icc/VS i'll look into it.
&gt; intel's compiler has deliberately hobbled performance for the AMD CPUs which I find reprehensible I here that a lot, and I really don't know how true it is. yes it's code does run slow on AMD processors, but then again hz for hz AMD processors are slower. Furthermore my understanding is Intel makes use of instruction sets that AMD just don't support yet, like AVX2.0, and when these are present they just use a basic instruction in it's place. Furthermore, assumptions about cache sizes will obviously focus on Intel CPUs; that doesn't mean they're deliberately crippling AMD. Finally, in my findings, the intel compiler was still the fastest for AMD too. BTW: Even if you don't use MKL, use an LAPACK library of some form, wring you own LA lib is dumb. 
In what way did that rant persuade anyone that there are technical merits to your workflow and not just a religious platform zealotry? I like Linux. I ran it full time at home for several years and even acted as maintainer for a fairly well-known Linux distribution at one time. So far the only thing semi-relevant is that you prefer vim. I could use edlin or LibreOffice Writer with an IDE for all that matters. Try to separate your hate for Windows from the pros and cons of an IDE or commandline workflow. 
It really depends on where you live, and what industry interests you. C++ is great for some things like games or embedded, but a shitty choice if you want to do web dev, and it takes a lot of work to become good at it. How about checking out job postings and finding some companies you want to work for eventually, and then decide what language to choose based on that?
In my library, all the algorithms (including `sort`) are eager, and all the views are lazy. I tried unifying them but it made a hash of everything. Any heuristic you might pick (e.g. maybe if I don't specify an output range...) runs into trouble like this pretty quickly. It does lead to some nice insights (hey, `copy_if` is the eager version of `view::filter`!) but there are troubles (dang, `reverse` is an in-place algorithm). By keeping views and algorithms separate, there's no confusion about what happens eagerly, what lazily, and how many loops execute.
I don't understand your point. I never said it would *always* be a pointer, like any iterator the position would more likely be a nested type of the container and thus *adapted to the container*. I thought it was obvious and just gave the pointer example because it's the simplest representation... ... though for a vector you might use an index instead.
Yep obv would use a LA lib of some description :) icc definitely uses an non-optimised code path for cpu that don't have the "GenuineIntel" CPUID string
&gt; Then you should have used until instead of find, no? That depends on what concept is modeled by Until and what I want to do with the resulting range. I'm guessing Until is input or forward, even if it's adapting a bidirectional or random-access range. There's probably a way to force eager evaluation and turn Until into a random-access range if the underlying range supports that, right? If not, there should be! That would be pretty useful. &gt; Instead of providing reverse_find, provide findSplit. BTW, I should have said `find_end` -- apologies. `findSplit` returns 3 ranges, probably &gt;= sizeof(void\*)\*3, when just one iterator will do. But apart from that, I have a deeper issue with it, and I grant it aesthetic. For many algorithm, the sole purpose in life is to find a position in a sequence of elements. And I don't think that's just my STL bias speaking, I think that's really what they do. You're saying, no no, they're identifying subranges. When I ask which, you refer me either to a collection of differently-named algorithms that all do the same thing but differ only in which range they return, or else to an algorithm like `findSplit` that gives up and returns *all* the subranges it thinks you might possibly be interested in. All this to shield the user from the notion of position. Am I right in guessing that under the covers, many of D's ranges are implemented in terms of positions? Then why the Herculean effort to hide them? P.S. You sound an awful lot like andralex. ;-)
Different languages and technologies tend to be used in different domains, and some domains have a lot more jobs than others. Pay more attention to jobs in the domains you actually want to work in; It doesn't really matter how many jobs there are for C# developers writing, e.g. line of business applications or web applications if that's not what you want to do.
In the US you shouldn't have to hard of a time finding a job where your focus is C++. Library developers, driver developers, and game developers are probably the most common but there are also a few areas which absolutely require high performance like banking and trading applications. You can also find quite a few positions with a mix of C++, HTML/JS, and .NET/Java since many products aren't a single piece but a large combination of parts. Personally the C++ code I've written professionally have been high performance or memory limited versions of something you've seen in .NET/Java. The only downside I've had so far is that most C++ positions have legacy targets where you can't write C++11 because compiler X hasn't been updated in 6 years.
I've tried to update and add lambdas! 
Awesome, thanks. VS does have that behaviour too, and it's good to know I won't lose it. EDIT: it will search substrings, but not acronyms very well. You could search "tool random" and it would find it.
I actually don't have any degree but I got lucky and was taken in on a small project that didn't have a large budget (60% C#, 20% Python, and 20% C++). From there it took me about two years to earn on par with colleges who have degrees. I've switched jobs a few times since then and now work 95% in C++. I would not recommend it though. I spent years trying to find a way to get my foot in the door even with a decent portfolio of contributions to open source projects and half completed personal projects all in C++. Only the good hiring managers who were likely a dev at one time even glance at the projects you've worked on. There is still a huge number of companies that look at your education and/or job history and ignore everything else.
Yeah, fair enough. I suppose I never actually figured I'd work as a C++ programmer. That having been said, I have had a lot of fun learning it the past few years. What are some of the skills you had to learn in order to be on par with college graduates?
Algorithms, Data structures, and BigO notation. Everything else is easy and you will learn even casually programming but man interviewers sure do love to ask you which data structure/algorithm is better, how its implemented, and what the complexity is. &lt;rant&gt;Honestly it is stupid because you'll never spend the time writing your own linked-list or red-black tree in any language. You are going to grab a well known library and use that. &lt;/rant&gt;
Agreed. I took a data structures course so I'm familiar with BigO and Algorithms. They made us write several structures then introduced us to the STL. Of course, your comment about employers only checking for a degree/experience is probably why I've never really pursued programming as a career choice.
&gt; PACKAGE MANAGERS. Oh my goodness, they save so much time it's unreal. If I want boost, oh wait never mind it's already on my system and if it's not or I want to update it's a single line. Same for an other library. Same the for the source code for any program or library, I can just retrieve that and read it! http://chocolatey.org/ if you ever have to go to windows. It is not up there yet with linux' package managers, but it is a good first step. Hey and it even starts from the command line by default;)
Unless someone proves that it can be done cleanly I completely agree with you here. Keeping them separate seems the cleanest approach. I really hope someone finds a clean way of mixing eager algorithms with lazy views in pipes tho. Reading what is happening from left to right is so much cleaner than the in and out function call syntax or hybrids that appear when one mixes the two syntax together. 
Oh, I didn't mean to imply that eager algorithms have no place in range pipelines. In my lib, you can say: vec | sort(pred) | view::transform(f1) | for_each(fun); That takes a vector, sorts it in-place, passed a reference to the sorted vector on to the transform view (which lazily transforms it), and that gets sent to the `for_each` algorithm that iterates over it. If it says "view" it's lazy; otherwise, it's not. I *think* this works out.
Ah pointers. I'm glad I learned that in college. I could see how that would be tough for someone to teach themselves.
I suspect the writer misinterpreted the intent behind in this code: // Here be atomic { old_value = *value; if(old_value == expected) *value = new_value; } The comment is meant to indicate that the code present there *represents* the atomic CAS, not actually implements it (though this means it's not useful for testing the issue in practice). The issue specifically raised is due to the expected value being passed in being aliased by the new value being entered (which then becomes visible to other threads and may be modified between the CAS and the check for success). This would work find if the function as a whole was atomic but breaks because it is not. The issue can be worked around by making local copies as required.
(I just realised I mixed up `compare_exchange` with `compare_and_swap`. I see now they are two different things. However, I still don't know what either of them is!) Stupid question: what is the point of all this? What is this function even meant to do? : bool compare_and_swap(_T *value, _T&amp; expected, _T new_value) *Try* to set `*value = new_value`. If the old value equals `expected`, then return `true`. *BUT* if the old_value is *not* equal to expected, then *undo* the assignment (and don't let any other thread see the assignment, even temporarily), and return `false`. Is this the intention? And, there is a worry over the role of the `&amp;` in the interface? It would be simpler to understand if the expected value was simply passed by value?
Yeah I could see how a self-taught programmer who learned C# or Java first would really struggle with pointers. Personally I had no trouble with them as I learned C/C++ by mostly reading DirectX books and reading gamedev articles which are mostly C.
It's probably more a sampling bias. Those who fail to grasp pointers don't get a degree. In my university, those who didn't grasp pointers quickly changed majors. I think pointers resulted in more Civil Engineers than any other factor. You can fail to grasp pointers and still do a decent job in most languages, enough to get a job.
&gt; Is this the intention? Yes. &gt; It would be simpler to understand if the expected value was simply passed by value? Only after copying the value (that's what passing by value means) the original could be changed by some other thread without you knowing it.
Because that's a string literal and they are built into the language. The same as you don't have to #include &lt;number&gt; to run this line: std::cout &lt;&lt; 3 &lt;&lt; std::endl; The &lt;string&gt; header defines a C++ class for handling strings in a better way but you don't need it just to write a string literal.
&gt; Only after copying the value (that's what passing by value means) the original could be changed by some other thread without you knowing it. I can certainly see how it would not make sense to pass `value` by value. It is passed by pointer, and that make sense. Sorry if I seem repetitive, but why not pass `expected` by value? (*Further:* Actually, why isn't `expected` pass by `const &amp;`?)
Impressive job! openGL in server side :D Does anyone have experience with Wt?
&gt; it's not hard to write leak free code using pointers It is one of (maybe *the*) most common bugs in C and C++ code bases. Even modern programs often leak memory and other resources. Firefox‚Äô code base was notorious for leaking memory, which was the main reason for its memory inefficiency. I have no idea whether this is fully fixed now (I haven‚Äôt looked at their code base in ages) but this one class of bugs cost them millions.
I guess it will help on the future modules system for C++?
Alpha releases of KDE frameworks are largely targeted toward developers, and KDE is written in C++.
The fs module? Nah it's something else. The vfs is virtual (no need for a real file system ). And the one for c++14 is from boost. 
I think Wolfspaw is referring to the not-yet-scheduled ["module" feature](http://clang.llvm.org/docs/Modules.html), not a filesystem module.
yes /u/nomad42184 is right, I was referencing the "module"/symbolic-import feature that one day will replace C++ textual inclusion header system.
yes, you're right! I was referencing the "module"/symbolic-import feature that one day will replace C++ textual inclusion header system.
&gt; I think this works out. Yes, I think so too. There are some cases like vec | view::filter(f) | sort(pred) | for_each(fun); that can't work without an intermediate step or a buffer since e.g. `view::filter` is typically a const range and since it alters the size of the range. Using e.g. `push_back` to a preallocated `buffer` works vec | view::filter(f) | push_back_to(buffer) | sort(pred) | for_each(fun); but forcing eager evaluation via a copy to the vector before sort would not work since the number of elements differs. The same problem appears with unique and other views that alter the size of the range in a non-contiguous way.
It's a large collection of C++ libraries for application development.
Makes sense. If C/C++'s world view is "all my resources are on the filesystem" (e.g: #include), then one way to get ahead of that is to virtualize file access. The alternative would be to re-write/copy files into a temporary file space somewhere, and simply virtualize file name *mappings* instead. But then you've just compounded file system access in the worst case. Cramming all this stuff into memory makes a lot more sense from a performance standpoint. I suppose the only reason why C compilers don't do this already is pure legacy: the ratio of average source file size to system memory 30 years ago, could be considered comical by today's standards.
What an elegant and gracious burn from Herb
Clearly after rethinking my comment, id like to take it back haha. I have little to no experience working on large projects (definitely nothing like a web browser) and made some assumptions. 
I don't see a problem with sorting a view that only contains some of the elements of the base range. The real problem with sorting a filtered view is that a filtered view is at best a bidirectional range, whereas sort needs random-access. The following, however, works just fine: vec | view::stride(2) | sort; That makes a view of vec containing every other element and sorts it in-place.
A recursive lambda is overcomplicating it. The simpler lambda approach is: const double x = ([] -&gt; double { double x; do { x = drand48(); } while (!((x*1000) % 2 == 0)); return x; })(); I don't have any strong opinions on whether or not this is worth it. It's a good technique to keep in mind, though (an immediately invoked lambda is basically just gcc's statement expression extension, except standard).
Now with a slight rewrite you can even make the `x` `const` by moving its declaration inside the loop, thus removing all non-`const` objects from the code. For what it‚Äôs worth I *do* think this is worth it.
You can use lambda function to execute arbitrary logic to initialize your const variable: #include &lt;iostream&gt; int glob = 0; int getRandom(){ return ++glob; } int main(){ int const val = [](){ int ret; do{ ret = getRandom(); }while((ret % 1000) != 0); return ret; }(); std::cout &lt;&lt; val &lt;&lt; std::endl; } 
there is this thing called a function...
Thinking about how this could interact with the optimiser makes me cringe horribly.
Then the people killing them are not knowledgeable C programmers. 
Nor have they seen much kernel code.
My point precisely. Many widely used, well-coded, and mature codebases in C use "goto" quite a lot. Meanwhile, the same people think nothing is complicated about a code base that is chock-a-block with exception handling code. 
Uhm. How could it interact with the optimiser, actually? It looks well-defined to me.
I feel ill and my head is spinning and I think I'm going to vomit. Do not do that in actual code.
Why would it? The const keyword is unnecessary in the first place since compilers can already find constants themselves.
My gut feeling is that this is formally undefined behavior as you are overwriting a variable without its lifetime having ended (and especially a `const` one). However since the variable is a built-in, there might be an exception but a cursory look at the Standard did not help point in either direction. Still, were I to see that in a commit, you would have to watch your back ;)
&gt; a duration with enough resolution and capable of representing up to 292 years I find this claim to be unreasonable, and am testing. Will post results here in 292 years.
To expand upon /u/abigailbuccaneer Doing this with a goto will cause the compiler to not perform many optimizations it otherwise could since you can have unexpected scope jumps (very bad for deconstructors, to name one). Any technique which directly changes a constant may also prevent the compiler from making assumptions that the value won't change, thus preventing additional optimizations from that as well.
There are a lot of spec-illegal things you can do. A fun one is: #define private public #include &lt;some header.h&gt; #undef private Fun times!
As I've written above, this was my first thought too, but after thinking about it, I came to the conclusion that this is not the case, because goto closes the scope and executes all the dtors. AFAIK this behaves somewhat like this: while(true){ const int x = rand_int(); if(!is_nice(x)) { continue; } use(x); break; } Which is at least somewhat nicer than OP's version. 
It's not overwriting a variable, it's entering (and leaving, via the `goto`) the scope of that variable. The code is well formed, just very ugly and weird.
I am not quite sure that `goto` closes the scope. If `goto` were to get you *out of a block* then the block scope would be closed, but in the absence of block....
Well, I disagree on the scope. When you write: int main() { // some code int a; // [1] // some code return 0; } // [2] The scope of `a` is from `[1]` to `[2]` inclusive. So I am afraid that the lack of *block*, creates an issue because the lifetime of the variable never ended. AFAIK the only special rule regarding destructor is when `goto` exists a scope: std::string a = "Hello, World!"; { std::string b; goto hello; } // b destroyed upon leaving block hello: std::cout &lt;&lt; a &lt;&lt; "\n"; // a not destroyed by goto, so this is kosher And there is no such rule for execution "rewinding".
In other comments here, the agreement seems to be this is perfectly legal. A `goto` ends the lifetime of the variable, calling any destructors. Consider a `const` inside a `while` loop. We don't worry that, each time the loop restarts, the `const` variable is born again.
&gt; lol, that's stupid. lol, that's a useless fucking comment
 for (;;) { const double x = drand48(); if ((x * 1000) % 2 == 0) break; } BTW the compiler isn't going to like applying the `%` operator to a `double`.
As commented by others, refactor to use a "stateless" function/lambda returning the value is a better idea. Now, there are also other options (just FYI, I don't think it's a good idea): * const_cast * If type has a destructor (not your case): ``` value.~Type(); new(&amp;value) Type(); ```
 A() try : B(), foo(1), bar(2) { // constructor body } catch (...) { // exception from the initializer list are caught here // but also rethrown after this block (unless the program is aborted) } I have never in my life see any code like that in use, and would have thought it wasn't legit code at first.
That's pretty much what I say every time I look at Perl
const_cast would result in undefined behaviour: It only exists to deal with shitty APIs that promise to never change their argument in the documentation but fail to write const in their code. Changing a const value via const_cast is highly illegal. Concerning the second method: AFAIK the dtor is not a const-method, so calling it explicitly should result in a compiler-error. (I admid that I didn't test it.) const is const for a reason. If you want to change the value just once, it still is a mutable variable and must therefore not be const.
Yeah, there are a few such things in store like that, will post them as soon as I write the parts :) Very weird indeed, and I think it should be restricted to constructors and destructors, because the semantics for functions is very unintuitive. With constructors and destructors it does have place I think. Logging failures is very useful in any case.
well, it's kinda pointless with RAII. It completely kills the fact to throw in the constructor if there's a problem... I guess that's why no one uses it (except maybe if you use new/delete and you're low on memory and expect an exception in your constructor)
I think you've been beat up enough for using goto to bypass the limitations of const. What bugs me is that you're using a loop with an indeterminate number of iterations when you probably don't need a loop at all. double GetSpecialRandom( void ) { double x = drand48(); if( ((int)( x*1000 )) % 2 ) x -= 0.001; return x; } const double x = GetSpecialRandom(); Feel free to tweak it to suit whatever purpose this random number generating is serving.
C++11 20.11.2 [time.syn] includes: &gt; // convenience typedefs &gt; typedef duration&lt;signed integer type of at least 64 bits , nano&gt; nanoseconds; &gt; typedef duration&lt;signed integer type of at least 55 bits , micro&gt; microseconds; &gt; typedef duration&lt;signed integer type of at least 45 bits , milli&gt; milliseconds; &gt; typedef duration&lt;signed integer type of at least 35 bits &gt; seconds; &gt; typedef duration&lt;signed integer type of at least 29 bits , ratio&lt; 60&gt;&gt; minutes; &gt; typedef duration&lt;signed integer type of at least 23 bits , ratio&lt;3600&gt;&gt; hours; - 2^63 - 1 nanoseconds is about 292.3 years. - 2^54 - 1 microseconds is about 570.9 years. - 2^44 - 1 milliseconds is about 557.5 years. - 2^34 - 1 seconds is about 544.4 years. - 2^28 - 1 minutes is about 510.4 years. - 2^22 - 1 hours is about 478.5 years.
&gt; useless and totally wrong It works well, and is well-defined. It just uses `goto`. I'm quite happy for somebody to have a 100% no-exceptions aversion to `goto`. But don't engage in blatant lying, pretending that my example is 'wrong' or 'incorrect' in any way. I await your apology. 
Every time I come across a situation where I want to do something like, the types are different, the initializing function is different, and the constraint it different. So I'm looking for a general solution to const T v = random_foo(); ... but subject to the constraint that bar(v) is true Others have pointed out a solution I'm happy with. Put the loop inside a lambda and return from that. Thanks.
`x` isn't available outside the loop in that. What about this: for (;;) { const double x = drand48(); if ( !((x * 1000) % 2 == 0) ) continue; ... the rest of the program logic here ... } Note I've used `continue` instead of `break` there.
yeah, just explaining why it isn't used...
I'm not sure if it's well defined. Compiler might somehow optimize away your const (okay, in this case probably not, because you're using function call as initializer). I have nothing to goto statement. I've never used it(only when learning programming), but I know some applications to it for ex. breaking from nested loop, and when I discover that goto is more readable or optimal I will use it. Just your problem is imaginary. You're obsessed about const-correctness to such an extent, that you're violating const-correctness from other side - you're signing variable const, but this variable isn't const. Why would I apologize you? I've blamed your solution, without personal insulting. Btw. if lack of const is that problem, you can use cast. You said that you're using your solution by years. So you know language from far longer period. You should know it better than I, as C++ is my first language, and I know it only from two years(and not whole language).
Your first comment started with: &gt; lol, that's stupid. I've spent many years gaining points for C++ on StackOverflow. We are quite civilized over there. We don't start our answers with "lol, that's stupid". I know there's no point expecting civility on the internet, it's all fun to troll each other, but I think /r/cpp should be a little better.
"that's stupid". This was adressed to solution, not to you.
If the constructor itself allocates some resources, but if one of the objects which it trys to construct throws the destructor is not run. If at this point your class doesn't clean up any resources allocated prior the one that has thrown they WILL leak.
On the off chance this is a poor attempt at sarcasm and you're not actually serious, C++11 actually does include a signed 64-bit (or more) type, [long long int](http://en.wikipedia.org/wiki/C++11#Type_long_long_int).
Or (as I prefer) [int64_t](http://en.cppreference.com/w/cpp/types/integer) . (fixed the capitalization, remarked by /u/bob1000bob =p, fix2: I reversed by mental failure.)
If you're creating instances of the class in a dozen places and always want to log errors that occur when creating them, it seems obvious to want to do the logging in one place rather than every place instances are created.
No, not when I'm creating them (that's point-of-use, which is exactly the problem with the try in the constructor imho), but rather, where the class body itself. For example, instead of using a try in a constructor to log the error like this: A() try : B(), foo(1), bar(2) { mumble = 1; } catch (...) { LOG("something threw in B, foo, or bar, or some other member object I didn't list here"); } Wouldn't it make a lot more sense to have something like this for B and similar code for foo and bar: B() { if (whoopsie==253) { LOG("Got a whoopsie in B"); throw(985); } } And then just don't screw with a catch that we can't do a whole lot about in A? That way wherever I use B (derived or not) and it fails like this I can get log message from B about B's problems.
I'm currently on Chp 2 on Acc. C++ and I'm lost mid way through the chapter. It introduced 4 or 5 things in a span of 3 pages. I know how to use all the functions but I can't follow what the fuck is happening in the book. 
If by replace you mean, pile onto.
Perhaps, but you might not always be able to modify all your base classes and data member classes. Could be 3rd party code for example. 
&gt; exceptions from the initializer list are caught here &gt; but also rethrown after this block (unless the program is aborted) An exception of the same type need not exit from the constructor or destructor that caused triggered the entry into the catch section of the function-try-block. Some exception must be thrown, but it can be a different exception. If no exception is explicitly thrown by the user, then the original exception will be rethrown. So function try blocks are also good for translating exceptions. EDIT: I rephrased the first sentence to try to make my comment more clear.
You need to use this construct in order to write thread-safe constructors. If you're copying an object, then in your function try block you lock that object's mutex and do the copy. If an exception is thrown then in the catch block you unlock the mutex.
if you plan to use RAII, you most likely use smart pointers aswell. They will automatically deallocate those ressources, that's the point.
That's naive. You can't use an std::lock_guard in an initializer list for a copy constructor. struct X { std::vector&lt;int&gt; v; mutable std::mutex m; X(const X&amp; other) try : v((other.m.lock(), other.v)) { other.m.unlock(); } catch(...) { other.m.unlock(); } }; These features, like function try blocks, exist for a reason. They are required to handle very rare edge cases when performance is critical and no other mechanism in the language will suffice. You can not write a thread-safe and exception-safe copy constructor or other constructors without the use of function try blocks unless you're willing to sacrifice performance.
Exactly, for classes that you don't control, this is the only way to kind of centrally log their construction failures. 
I think you misunderstood my statement. The standard does not require that the same exception that caused entry into the constructor or destructor function-try-block be the same exception that exits the constructor or destructor. It's possible for a different exception type to be thrown. This makes it possible to translate exceptions. n3376 (draft standard); Section 15.3.15 states: &gt; The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor. So if a user exits the function early by throwing a different exception, that is OK. Herb Sutter even touches on this in [Guru of the Week #66](http://www.gotw.ca/gotw/066.htm#7). (Search for 'translate' in the page.)
Indeed I misunderstood it, thanks for explaining. (I did probably because it felt natural for me; I will think of a way to clarify the wording in the post about this).
You can also translate the exception. For example, you can take a library-specific non-std::exception-derived exception (say an int^*) and translate it into a std::exception-derived exception (like std::runtime_error). \* Yes, I've really seen ints thrown in library code. (I still shudder when I think about it.)
&gt; filtered view is at best a bidirectional range, whereas sort needs random-access. Indeed.
I was always really puzzled why c++ had forgotten exception handling in constructors and destructors. I haven't seen this feature anywhere being used, and I thought it did not exist. 
I see, thanks.
Dropping C compatibility means dropping C++ compatibility. We don't want to find that valid C++11 code (including, for example, a C program!) suddenly stops working under C++17. If you are specific of which C features should be deprecated, then you'll see that C++ has already made a lot of progress. For example, with modern C++ it is very easy to program with ever having to see a raw pointer. Also, there is nothing stopping the next C++ deciding to define a default initialization for all types. This wouldn't break any existing code. But it could slow some things down, which is why it won't happen. Can you give an example of a piece of C++-like code you would *like* to write, but which you can't write because of the C compatibility?
But why you need to do this copy in the initializer list and not in the constructor body ? In anyway your performances will be bad because you will lock a mutex and allocate a new chunk of dynamic memory.
I believe tom_k_cook is referring to how using `goto` will stomp over any hopes of optimizing the function.
no. std::int64_t. A standardised typedef for a 64 bit signed int. `__int64` is not at all standard although if present almostly certainly boils down to the same thing, double leading underscores are reserved for compiler/stdlib/environment specific internals. 
Oh, maybe. It's still possible to see control flow but I don't know how the compiler treats it.
It's not the capitalisation, the "64" allows the "int", `int64_t` rather than `64int_t` :)
Is this a well-defined usecase, or is it a compiler extension ? I could not find a single quote about this in the Standard... which may say more about my Standard-fu than about the usecase at hand but I am wary of saying "it works" just because one compiler appears to support in some limited test-case.
It's guaranteed that when `goto` causes the flow of control to leave the scope of a variable, that triggers destruction of that variable. This behaviour then follows in a fairly straightforward way from the definition of scope. There also seems to be some verbiage in the standard: see http://stackoverflow.com/questions/8522055/why-destructor-is-called-when-going-backward-via-goto.
Unless you really need to use visual studio, I would recommend going back to mac write your code in xcode, then when you get parts that are windows only Boot up windows, start codeblocks and the mingw-clang package, and finish in that You will be able to use c++11 (afaik could be wrong (VS14 is the first to support c++11))
What are you including exactly? You need to include some sort of header file from the C++ standard library. Secondly, an int in C++ has a maximum value. If it is a 32 bit integer, it has a value of 2^31 - 1 as its maximum value. Putting in a larger number would cause an overflow.
"The program freaks out." How? What does it do? Does it give an error message? Crash? Run forever? Give the wrong answer? (I'm suspecting that last one.) If you want people to help you, you need to give us more information to work with. It's good that you posted your code, but a good description of your problem is important too. Also, you're more likely to get help with questions like this in /r/learnprogramming.
&gt; I know it's a little weird but if you try to add massive numbers like 1283912983 and 123781273818 then the program freaks out. That's the result of overflow. `int` is usually 32 bit, which means it can't handle numbers outside the range ~ -2 billion .. 2 billion. You can use `long long int` which is at least 64 bits and may be even larger, and thus can deal with larger numbers. Overflow on signed integral types actually produces undefined behavior, btw, so your program could crash or do anything it wants. My compiler offers a flag `-fsanitize=undefined` and if I use that flag then your program outputs: main.cpp:18:29: runtime error: signed integer overflow: 1283912983 + 1283912983 cannot be represented in type 'int' 
What you have is an [integer overflow](http://en.wikipedia.org/wiki/Integer_overflow), because an int (probably) isn't large enough to represent numbers that large.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Integer overflow**](http://en.wikipedia.org/wiki/Integer%20overflow): [](#sfw) --- &gt;In [computer programming](http://en.wikipedia.org/wiki/Computer_programming), an **integer overflow** occurs when an [arithmetic](http://en.wikipedia.org/wiki/Arithmetic) operation attempts to create a numeric value that is too large to be represented within the available storage space. For instance, adding 1 to the largest value that can be represented constitutes an integer overflow. The most common result in these cases is for the least significant representable bits of the result to be stored (the result is said to wrap). On some processors like [GPUs](http://en.wikipedia.org/wiki/Graphics_processing_unit) and [DSPs](http://en.wikipedia.org/wiki/Digital_signal_processor), the result [saturates](http://en.wikipedia.org/wiki/Saturation_arithmetic); that is, once the maximum value is reached, attempts to make it larger simply return the maximum result. &gt;==== &gt;[**Image**](http://i.imgur.com/xX8wYmv.jpg) [^(i)](http://commons.wikimedia.org/wiki/File:Odometer_rollover.jpg) - *Odometer rollover, a mechanical form of integer overflow. All digits are set to the maximum 9, and adding 1 causes a cascade of carry-over additions setting all digits to 0 but there is no higher digit to change to a 1, so the counter resets to zero.* --- ^Interesting: [^Stack ^buffer ^overflow](http://en.wikipedia.org/wiki/Stack_buffer_overflow) ^| [^Arithmetic ^overflow](http://en.wikipedia.org/wiki/Arithmetic_overflow) ^| [^Kill ^screen](http://en.wikipedia.org/wiki/Kill_screen) ^| [^Year ^2038 ^problem](http://en.wikipedia.org/wiki/Year_2038_problem) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfl8i1z) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfl8i1z)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 65899:%0Ahttp://www.reddit.com/r/cpp/comments/1yk60w/why_does_this_happen_simple_program/cfl8hgq)
Thanks that worked. 
Woops, sorry I was on mobile and I didn't see the iostream part, since its not even there. There is a way to "increase" the maximum, and thats by using a different type: C++ has the long and long long types for larger integers; a long is at least 32 bits long, a long long is at least 64 bits long. If you're only working with positive integers and you're sure you're not going to add two numbers that are going to go over the limit, you can use `unsigned long long`. If you don't mind using floating point numbers, a `double` should do the trick.
All right, I think I can explain what's going on here. First, an `int` in C++ can (usually) only hold up to 31 bits (plus 1 for whether or not it's positive), which means that any number bigger than 2^(31)-1 or smaller than -2^(31) is impossible to store in an integer. When you try to do `cin &gt;&gt; secondNumber;` after you enter a number that is too big, the input operation fails, since you can't store 123781273818 in an `int`. Now that the input stream `cin` is in a "fail" state, it will no longer try to do any input until you explicitly reset it by using the [ignore](http://en.cppreference.com/w/cpp/io/basic_istream/ignore) function to remove the bad input from the stream and the [clear](http://en.cppreference.com/w/cpp/io/basic_ios/clear) function to tell it that it's OK to try again.
you're completely right, it slipped my mind. thanks.
I do like xCode but I built a new computer and I started using it for everything. My old MacTop lags way too much, even when coding. Hopefully I can clear it out soon and it will be better. 
I think we should stop calling them Ranges and start calling them RangeIterators. They are not *different* from iterators, any more than a RandomAccessIterator is different from a ForwardIterator. Some iterators are more powerful than others. A RangeIterator is just an Iterator that happens to have an extra method `.empty()`, that tells us whether the current value of the iterator has gone beyond its limit. This is the philosophy that works for me. Once you decide that a RangeIterator is still just the same as a (single) Iterator, it's clear that RangeIterators can still do everything that Iterators can do. A RangeIterator doesn't have to "represent" the entire range of possible positions, any more than a RandomAccessIterator has to represent the entire range. For any given value of an Iterator (or RangeIterator) there is *one* location that is accessible via dereferencing. TLDR: A RangeIterator shouldn't be seen as a pair of iterators. It's a single iterator.
Did you read the article? The abstraction I'm talking about is called Iterable, not Range. And I'm sure if you spent time trying to port the STL to the abstraction you're talking about, you'll find yourself duplicating lots of code. You want to be able to write code once and have it work with pairs of iterators (of which there are *lots*), in addition to what you're calling a RangeIterator. That is why I defined the Iterable concept the way I did. Range refines it. Algorithms only need to be defined in terms of Iterables, and then all range-like things Just Work. It's a very important point.
&gt; Did you read the article? Yes, I've read all three parts. What made you think otherwise? It's called "Range Concepts ...", so I won't apologize for talking about ranges, especially with your sarcastic question. For `find`, the bare minimum it needs is one ForwardIterator, and a binary test as to whether that iterator is finished yet. That binary test is fulfilled by your sentinel value/type and the `==`. Nothing wrong with that. So, to make Iterable even more general, why not simply go for the full `function&lt;bool(Iterator)&gt;`, allowing people to pass in any test they wish? (This is very very similar to the sentinel type idea, where my boolean test is basically the same as your `==` operator.) This would allow a single implementation of `find` to cover all possibilities (just like yours does). Then, a simple overload of `find` could be presented to allow people to pass just one iterator-with-`empty` along with the value to search. This overload would simply forward its arguments to the 'real' `find`. Ultimately, I think we all want a version of `find` that doesn't require three arguments. template&lt;class InputIterator, class EndTester, class Value&gt; InputIterator find(InputIterator first, EndTester end_tester, Value const &amp; value) { for (; !end_tester(first); ++first) if (*first == value) break; return first; } and the simple interface for those who have an iterator that has an `.empty()` builtin: template&lt;class InputIterator, class Value&gt; InputIterator find(InputIterator first, Value const &amp; value) { return find(first, [](InputIterator it){ return it.empty(); }, value) } 
Omg, you're right. Fixed!
Because doing it in a setter and getter mean you can do validation on it. You're also not exposing inner workings which mean you're free to change how the data is stored without affecting the interface.
haha, I am still pedantic enough to strongly recommend using `std::` 
Actually, a lot of us feel that having getters and setters all over the place is not a good thing. So don't worry too much about it. If you blindly follow 'the rules', you just end up writing lots of boilerplate and not actually improving your software. If you are only going to call `set` once during the lifetime of the object, then you could consider initializing it in the constructor. Then you could make the data member `const`. In fact, with a `const` data member, you could safely get rid of the getter and just make it public. Take a step back and ask why you are making the class. If your class is just getters and setters, and nothing else, you're probably doing something wrong. Most of my classes don't have any setters, and many of them don't even have any plain getters! Some people will tell you that public data *members* are awful, because it means you can't change the implementation of the class later. But in the real world, even the *interface* isn't static. Everything is changing about your class as you're developing it and as you get a feel for what's a good interface. If you change the meaning of any member function or data member, you might consider renaming it in order to force you to consider each call site in turn and update it. We refactor interfaces all the time, yet we still make them `public` :) And sometimes you realize the class was based on a flawed philosophy entirely, so you just delete it and start again with a different program structure. So don't worry about a nice design until after the class has survived in your program for a while. There's no point wasting time on all the boilerplate on a class you then abandon because you suddenly realize you should have made two different classes as part of a different, better, design. (Edited for typos and stuff. I should proofread more)
Using setters and getters means that you can change from a simple variable to something more complex - say, for example, a database lookup, or a calculation of some type, without breaking the interface! That's important! You might also later want to know when someone is accessing or changing a variable, and perform some sort of action as another example. And as someone else said, you can do validation. 
Before I look at the guts of the library, I wanted to see if I could find a decent solution for infinite iterables. Whether or not an iterable is infinite is a property of the end iterator ([0, 10) and [0, ‚àû) should be representable with the same start iterator). For an actually infinite range (as opposed to an arbitrarily long range such as data read from a network socket), we only actually need one end iterator: `std::infinite_end_iterator`, whose `operator==` returns false for all types other than itself. Given that, it's trivial to add a `static_assert` to `distance` and friends that the end iterator type isn't `std::infinite_end_iterator`. Arbitrarily long iterables are more interesting. We could do something similar and forbid passing them to `distance` altogether by adding a new iterator tag type (taking advantage of that different types for the iterators also means potentially different traits), but that's sort of unsatisfactory. OTOH, when would you ever want just the size (and not the data) from an arbitrarily long stream? I guess one obvious answer is to throw an exception if it would overflow the return size rather than just having undefined results. 
Take a look at the "Classes Should Enforce Invariants" part from "The C++ Style Sweet Spot - A Conversation with Bjarne Stroustrup, Part I": http://www.artima.com/intv/goldilocks3.html Short, sweet, and to the point -- and, perhaps most importantly, very pragmatic: "If every data can have any value, then it doesn't make much sense to have a class." // Come to think of it, "[Object-Orientaphilia](http://www.artima.com/intv/goldilocks2.html)" is worth reading, too. So is "[Designing Simple Interfaces](http://www.artima.com/intv/goldilocks4.html)". Hey, just read the entire thing, it's short anyway! ;-) For more, see: "C++ FAQs" by Marshall P. Cline, Greg Lomow, Mike Girou // you may be able to read it on-line (no guarantees) via the preview feature at http://books.google.com/books?id=Z-G-sZy-1T8C&amp;pg=PT249 In particular: &gt; 10.7 What is a class invariant? &gt; &gt; 10.8 Why should the invariant be captured explicitly? &gt; &gt; 10.9 When should the testInvariant() member function be called? &gt; &gt; - Rule 1: Every public: constructor must establish the invariant. &gt; - Rule 2: Every public: member function must maintain the invariant. See also: http://en.wikipedia.org/wiki/Class_invariant // On a side note, http://isocpp.org/wiki/faq/ctors#init-lists
A few other comments that I haven't seen yet: * You never update w in your while loop, so once you're in you're stuck forever. I'm not sure what your intention was, but I changed the loop to make it possible to escape. * Your variables should have as narrow of a scope as necessary. Some would try to argue that pulling them out of the loop is more efficient, but be aware that compilers will optimize far better than you could ever hope to in cases like this and when performance doesn't matter (like this), prefer correctness and clarity over performance. * Your last block (the one with the accidental assignment) prints out a message saying to press enter to continue, but doesn't actually wait for an input... possibly because cin doesn't input anything when you press enter, so you probably couldn't get it working. I removed it from my example below. * The last if statement is unnecessary and actually introduces what would probably appear to be a bug. What if I entered -2? It would have skipped the while loop, but never shown me the message. * I HIGHLY discourage global using statements. They're in every book (mostly to save space), but can cause pain in real programs. At most use using to alias long nested namespace names to more convenient ones. * The return 0 is completely unnecessary -- C++ will return 0, by definition, if you don't specify it. (minor point) Another point on scope: Narrower scope along with better APIs also allows you to use const, which would have found your assignment bug. Consider this code: #include &lt;iostream&gt; #include &lt;string&gt; namespace { template&lt; typename T &gt; T get_input( const char * const msg ) { std::cout &lt;&lt; msg &lt;&lt; std::flush; T input_value; std::cin &gt;&gt; input_value; return input_value; } } int main() { typedef int data_type_t; std::cout &lt;&lt; "Welcome to the Addition Calculator\n"; std::cout &lt;&lt; "**********************************\n"; while(true) { const auto c = get_input&lt;std::string&gt;("\nWould you like to continue? [y/N]: "); if( c.empty() || toupper(c[0]) != 'Y' ) break; const auto firstNumber = get_input&lt;data_type_t&gt;("\n\nEnter first number: "); const auto secondNumber = get_input&lt;data_type_t&gt;("Enter second number: "); std::cout &lt;&lt; " =========\n"; const auto total = firstNumber + secondNumber; std::cout &lt;&lt; "Your total is: " &lt;&lt; total &lt;&lt; std::endl; } std::cout &lt;&lt; "Done..." &lt;&lt; std::endl; } Note that this code uses C++11 (auto) and a template... both of which are unnecessary, just exposing you to some more advanced techniques. I also used a typedef to allow you to change the datatype without going and finding every variable of the type. edit: a few minor formatting improvements, improved method of asking if they want to continue.
Yes. That would actually be a trivial change to the standard.
I'm sorry if my question sounded sarcastic. It wasn't meant to be. I was legitimately wondering, since you made no reference to the ideas there and since you said, "stop calling it Range," when I'm calling it "Iterable." Given that the STL version of `find` that takes 2 iterators is not going away, that version would need to be provided in addition to your version that takes an iterator and a stop predicate. So you're advocating this: template&lt;class InputIterator, class EndTester, class Value&gt; InputIterator find(InputIterator first, EndTester end_tester, Value const &amp; value) { for (; !end_tester(first); ++first) if (*first == value) break; return first; } template&lt;class InputIterator, class Value&gt; InputIterator find(InputIterator first, InputIterator end, Value const &amp; value) { return find(first, [=](InputIterator it) { return first == it; }, value); } template&lt;class InputIterator, class Value&gt; InputIterator find(InputIterator first, Value const &amp; value) { return find(first, [](InputIterator it){ return it.empty(); }, value) } whereas I'm suggesting this: template&lt;class InputIterator, class Sentinel, class Value&gt; InputIterator find(InputIterator first, Sentinel end, Value const &amp; value) { for (; first != end; ++first) if (*first == value) break; return first; } This is much simpler and will generate code that's every bit as good as what you're suggesting. Why do you prefer your interface? 
http://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions They're part of the C++11 standard. Try compiling with -std=c++11, e.g. http://coliru.stacked-crooked.com/a/0a4b8809f7e08ff9
What you want is a [break statement](http://en.cppreference.com/w/cpp/language/break).
Generally: your indentation could use improvement, indentation improves readability ten-fold. I also tend to use vertical spacing a lot, but that's just preference. But yeah, indentation. I looked at the code and I wasn't sure where the while would end for example. With indentation I would've been able to tell immediately.
I didn't read the paste-bin, I just assumed your code was like that. I've seen worse. It was just a pointer, you didn't offend me or anything so you have nothing to apologise for.
Is there a concrete proposal for getting some of these changes into C++14 or beyond?
Not yet. The discussion has to happen first. That's what this is. :-) 
You don't even need to make the break. while((heroHealth &gt; 0) &amp;&amp; (ogreHealth &gt; 0)) { // do player attack stuff if(ogreHealth&gt;0) { // do ogre attack stuff } }
Additionally, when possible you should scope your iteration variables to your for-loops. If you had said `for (int i = 0; i &lt; ProgramNum; ++i)` without defining `i` within `main()`, then the compiler would have complained, after you accidentally closed the loop with a semicolon, that `i` below hadn't been defined. That said, the C-like style that you've been taught (defining all variables at the start of `main()`, which is avoided in C++) is not entirely to blame. Your instructors should have warned about where semicolons go in C++. Additionally, C++'s heritage from C is also at fault - permitting loops without braces is wrong and bad and wrong. It is annoying that cosmetic deficiencies like this make it harder to learn C++, which is actually an elegant and powerful language once you know how to program it properly.
&gt; Function-try [Quick link to a Dr Dobb's article on function try blocks](http://www.drdobbs.com/introduction-to-function-try-blocks/184401297), for those like me who weren't even aware they existed.
Making classes that way isn't wrong. It has tradeoffs. You get less complexity, in exchange for less control. If you don't need the control, don't pay for the complexity.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**State diagram**](http://en.wikipedia.org/wiki/State%20diagram): [](#sfw) --- &gt; &gt;A **state diagram** is a type of [diagram](http://en.wikipedia.org/wiki/Diagram) used in [computer science](http://en.wikipedia.org/wiki/Computer_science) and related fields to describe the behavior of systems. State diagrams require that the system described is composed of a finite number of [states](http://en.wikipedia.org/wiki/State_(computer_science\)); sometimes, this is indeed the case, while at other times this is a reasonable [abstraction](http://en.wikipedia.org/wiki/Abstraction_(computer_science\)). Many forms of state diagrams exist, which differ slightly and have different semantics. &gt;==== &gt;[**Image**](http://i.imgur.com/LfsXMym.png) [^(i)](http://commons.wikimedia.org/wiki/File:Finite_state_machine_example_with_comments.svg) - *A state diagram for a door that can only be opened and closed* --- ^Interesting: [^UML ^state ^machine](http://en.wikipedia.org/wiki/UML_state_machine) ^| [^State ^diagram ^\(UML)](http://en.wikipedia.org/wiki/State_diagram_\(UML\)) ^| [^State ^transition ^table](http://en.wikipedia.org/wiki/State_transition_table) ^| [^Finite-state ^machine](http://en.wikipedia.org/wiki/Finite-state_machine) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cflqiwp) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cflqiwp)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 66614:%0Ahttp://www.reddit.com/r/cpp/comments/1yl81k/question_about_a_program_im_working_on/cflqiur)
I did try `-std=c++11` on g++ 4.8.2, it gave that error message. But perhaps later g++ versions support it. Thanks!
See also my comment here: http://www.reddit.com/r/cpp_questions/comments/1tcg9v/every_member_is_accessible_through_getset_is_it/ce6oe7t 
`&lt;chrono_io&gt;` would be nice: http://home.roadrunner.com/~hinnant/bloomington/chrono_io.html
I think I see your point now. Yes, given that we already have one three-arg `find` in the standard, we shouldn't be adding any more three-arg `find` overloads to the standard unless it improves the situation. And your proposal to extend the interface works well because it is compatible with the current `find`. The only remaining question is whether there should be a two-arg `find` (iterator+value). I would argue yes. And perhaps you already agree! I guess this point is independent of the question over the interface to the three-arg `find`. I've eventually realized that I can write the two-arg `find` just as easily to wrap around your interface as mine, so therefore I'm happy to defer to your interface for the three-arg version. Here's some rough-and-ready code that shows how any iterator type that has an `empty()` can be used to make a simple two-arg `find`. This is far from perfect, it's just a sample to show how that it's relatively easy. Now, all our containers (and other iterable-over things) can just return one object (call it what you like!) and it can be passed directly to algorithms. My initial interest in the broad topic of ranges was the ability to avoid the really awkward unpacking of pairs of iterators into two different arguments for functions such as `find`. struct SentinelForEmpty { }; template&lt;typename Iterator&gt; bool operator != (Iterator first, SentinelForEmpty) { return !first.empty(); } template&lt;class RangeInputIterator, class Value&gt; RangeInputIterator find(RangeInputIterator first, Value const &amp; value) { return find(first, SentinelForEmpty{} , value); } Now, of course, the 'single object' that describes the range-or-whatever-you-call-it does not need to be a `std::pair&lt; ... , ... &gt;`. The implementation details don't matter. For a C-style string, it can just be the same size as a `char *`, the sentinal type is essentially empty.
Basically, in my own code (and many others it would seem) I make a differentiation between a class and a value object. The latter I generally denote by using a struct (even though they are essentially the same thing). A class is an object which encapsulate some sort of semantics. IE It has inner goings on, member function that operate on state. In these case all variables should encapsulated either getters and setters or some similar mechanism. However I stress that good design dictates that the amount of state any one class holds should be relatively small (see Separation of concerns and limiting invariance). A value object on the other hand is just a class used to group together a load of data. It doesn't have any function other than to group that data. In that case there is utterly no point having getters and setters (unless perhaps you want some validation - although at that point it becomes a class as it's performing a function). An example from the standard of this is `std::pair` with is public member variables `first` and `second`. Also while I am here. I generally consider this (and the setter version): myClass mo; mo.name = "bob barker"; cout &lt;&lt; bo.name; To be a code smell. The state should be initialised in the ctor. Going back to my previous point, if that would make the ctor interface to clumsy then your class probably could do with splitting up.
This is exactly what I was looking for, thanks!
getters and setters are an abomination.
Somehow this came to my mind: for(auto it = make_iterator(begin,end);it;++it) doIt(*it);
View source
Because the class members (v and m) would already have been copied when the constructor body is entered. So that would be too late to lock. 
Well, to a string is not that important, IMO. But the lack of a stream operations is utterly crazy. That said, I am totally in favour of extending to `std::to_string` from primitive types to be more general purpose. Ie. something like this: template&lt;typename T&gt; std::string to_string(const T&amp; val) { std::ostringstream oss; oss &lt;&lt; val; return oss.str(); } With specialisation for types that could benefit from them (ie primitives). It's just so useful. Which if chrono types has op&lt;&lt; then tehy would automatically get a `to_string`.
Best of the series so far.
Could you provide some more information? It would be helpful to know how much experience you have with C++, graphics programming, and game development in general.
SDL is popular, but I personally prefer SFML, it's object oriented and more in the style of C++. It's a library that handles graphics, input, sound, window stuff, and events. Though if you're new to programming in general, I recommend starting with a text adventure.
I would suggest you start off with Python and Pygame if you're new to programming. Once you get familiar with programming concepts, you can apply them to your C++ development. At least that's what I did. C++ scared the crap out of me, and Python was a breeze.
IMHO, having the crap scared out of you is healthy. I really hate C++, but I wouldn't trade it being the first language I learned for the the world. Being aware of memory management even if you don't have to get your hands dirty with it is a good thing. That said, if your goal is more about being productive and less about learning to program, yes, there are better choices than C++.
**Edited: I misjudged the poster for a complete newbie, sorry and ignore my post** Well, since you're a complete newbie I wouldn't recommend making a game with C++ (yet). In fact, I think you're on the wrong reddit for your question (judging by the "what programs would I use" v.s something akin to 'What libraries and tutorials'). This reddit is for C++ topics. That said I'll try to give you a hand. You must first learn to program, before you can make a 2D RPG. Alternatively, you can use something like [RPG Maker](http://www.rpgmakerweb.com/) which allows you to make RPGs with very little programming. The disadvantage of RPG Maker is that all games made with it look alike (mechanics wise) since they use the same "blocks". If you want to follow the programming route [you can start doing very simple games with Python] (http://inventwithpython.com/pygame/chapters/) I find [this blog article](http://www.gamefromscratch.com/post/2011/08/04/I-want-to-be-a-game-developer.aspx) to have some good gamedev recommendations. Even though I think he's too hard on C++. In the end, programming a (bad or not) 2D RPG needs a lot of dedication...
Your original post asked about using which programs to write a game in C++, it's a typical question on /r/gamedev from people who are just starting out.
Yes, I'm sorry then. I misjudged you to be a newbie (when I read there was only "What programs would I use"). 
[I wouldn't call getters and setters 'proper'.](http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html) In fact it seems to me the version with getters and setters is _worse_ than your other version, simply because there's more pointless code. One problem with choosing a correct way to write this program is that there are requirements whose only point is to increase complexity. Even in most toy examples of object oriented programming the features are actually put to use, even if OO isn't really the best way for such simple programs. There's simply not enough to this program for structure or abstraction to mean anything.
Type-safe generic format strings are what language nerds *really* want ;). The sad thing about iostreams is that they're both slow *and* provide a pretty terrible API. The error handling with an `fstream` also barely gives you anything to work with. This is why countless projects like LLVM reinvent I/O handling.
IMHO, there are some serious wrongnesses to his article. For example, here's the ABI for his sort: void QuickSort (void* __restrict elems, int64_t elem_count, size_t elem_size, QuickCompareFunc cf); First, pushing everything through void* is a seriously bad idea for sorting - it means that the text of comparison function is NOT available to sorting code, which prevents the optimizer from operating at maximal effectiveness. If the writer were required to communicate with C, having a C-style sort function would be understandable - but apparently, the reason he's doing this is: &gt; The reasons are for compile/link speed and to be able to keep a clean binary interface between modules. Compile/link speed - prioritized over speed of the generated code! But you compile once, and run the result many times... not a good trade-off. Later on, he also mentions "code bloat" - which is nearly always not an issue with something like sort, which doesn't generate a huge amount of code. Now, today in 2014 you do want to be keeping code sizes down in order to make your caches run as effectively as possible, but for a sort, where you load a fairly small routine in once and then call it a great many times, it's hard to imagine that code bloat is really an issue. Without a benchmark to prove it, I'd have to believe it's just not an effective choice. (I don't quite understand why "having a clean binary interface between modules" is desirable - what's not "clean" about a template? - and I can't see a link to the other article he says explains it.) There's a secondary issue, which is that QuickSort is an inferior sorting mechanism. It isn't stable; it isn't actually guaranteed to be `O(n log(n))` in every case; and even when the previous two conditions aren't important, it tends to be slower than other sorts like mergesort. And all those `void*`s everywhere! Why bother using a typed language at all if you flee from types every time you get the opportunity? So, I'm unimpressed. Counterarguments solicited, of course.
Yup, that‚Äôs quite simply terrible code, and the reasons given are questionable at best and plain wrong at worst. However, as an aside, you‚Äôre wrong about quicksort. True, it‚Äôs not stable and its worst-case runtime is O(n¬≤). But the *expected* runtime is usually superior to mergesort. There are situations where mergesort wins out, but quicksort seems to be more generally applicable when stability isn‚Äôt required (and it often isn‚Äôt). The performance of quicksort depends crucially on some implementation details, however. For instance, a naive choice of the pivot can be terrible for runtime, and generally a non-randomised pivot choice leads to an algorithm which is exploitable for DOS attacks (when run on a server). Another potential flaw is that worst-case quicksort may overflow the stack. This is conventionally fixed by modifying it slightly to limit recursion depth. This is known as [introsort](https://en.wikipedia.org/wiki/Introsort) and is the *standard* (non-stable) sort algorithm in modern C++ standard library implementations.
 I think you missed the point. The point is to give a way to interact with a c style API with a c++ closures. Who cares why they are using a c style API or that they are using quicksort, that isn't the interesting thing here.
Except that this technique doesn‚Äôt work in general with a C-style API ‚Äì it only works with an API which is specifically designed to pass a payload on to the callback. Standard `qsort` for instance cannot be called using this technique. That severely restricts the usefulness of this approach. And /u/TomSwirly is correctly criticising the underlying reasons for creating such APIs in the first place.
Well it's, for the most part, a pretty useless feature. 
If you control the API on both sides, though, why go to all the trouble? Why not just make the API you actually want to make, instead of all this runaround with void*?
you're branching on essentially each byte. bad news bears in terms of performance
&gt; Except that this technique doesn‚Äôt work in general with a C-style API ‚Äì it only works with an API which is specifically designed to pass a payload on to the callback. I.E. all well designed C APIs? Userdata parameters to functions taking a callback function pointer are hardly rare.
sorry about that. how do i place it in a pastebin?
http://pastebin.com/ Use this site, paste the formatted code in the text box and submit it with syntax highlighting for C++, public visibility. Then, copy the link it gives back.
you're using uninitialized variables. try. float sumx() { float sumx = 0; for (i=0;i&lt;n;i++) { sumx=x[i]+sumx; } return sumx; } Modify the remaining functions accordingly.
You can *still* do that: just use a compiler firewall (‚Äúpimpl idiom‚Äù). In fact, the author even provides a wrapper function template for his invocation. We‚Äôre back to square one.
He should get acquainted with `extern template`.
This is pretty overkill if all you need is to guard against re-building your codebase.
I don't see how you could apply the pimpl idiom to the case given in the post, which is a function that works with generic types through the use of a callback. And the wrapper function template is not part of the module being called, so it doesn't matter that it's a template. The actual API always remains a plain C API that takes `void *`, no matter whether you use a convenience template on the client side or not. 
This was it thank you.
You ‚Äì and the OP ‚Äì merely shift the goalpost of what to call ‚Äúmodule‚Äù but in reality it doesn‚Äôt matter whether you call the function template part of the module or not ‚Äì it‚Äôs de facto the interface which the client needs to know about, and which hides the actual implementation. Whether that‚Äôs through (type unsafe) type erasure via `void*` or a conventional pimpl is irrelevant.
Mr Niebler, you said in your article that the idead of `begin` and `end` iterators to have distinct types has been floating around for a while. Well, so has `boost::range`. The discussion about standardization of ranges has been going on for what, years? How come nobody has made the connection before you? In hindsight, that seems relatively obvious, wouldn't you agree? I'm really looking forward to part 4 of your series. It's been a very good read. Let's keep our fingers crossed for ranges in '17.
Maybe you were thinking about dtors?
Actually, there's no reason why std::string wouldn't be as fast as a char*. I believe Stroustrup mentioned that in some keynote on C++11.
The blog post and the accompanying reddit submission is obviously click-bait. Andrew Marlow probably wants to people to peruse his site most likely to also have a quick peek at his CV and all that might involve/entail. Don't fall for this kind of crap. this reddit should be removed. 
In addition to the other two comments, KDE also has an IDE for C++ (and other language) development called KDevelop, which actually has an initial port to the Frameworks described in the OP's link.
Thanks so much for all the work you guys have been doing -- building cross-platform code in C++ is _almost_ trivial. For fun I converted my websocket server from unix-only to cross-platform in only 50 loc which is awesome: https://github.com/matthewaveryusa/averyws/blob/master/libs/cpp11_polyfill.hpp granted defining thread_local as static is a little iffy, but it's good enough for what I'm doing.
Sound great. Can't wait to upgrade from 2008... In ten years or so... 
It uses LLVM-specific `raw_ostream`, `raw_string_ostream` and `raw_fd_ostream` types with `iostream` forbidden. The design differs a fair bit from the C++ standard library. For example, the string stream constructor takes a reference to a `std::string` and simply wraps it which avoids a *lot* of copying. http://llvm.org/docs/doxygen/html/raw__ostream_8h_source.html
You could always get the free version too.
Quite a few as far as I can see :) I found ~30 that migrated unchanged from VS2012 to VS2013. That's before even looking at the C++11 features which first appeared in VS2013.
In the times of BSD licensed clang - why should I spend one dime on Microsoft's subpar offering? Especially when MS doesn't have C++11 implemented yet (and that will be a paid upgrade too). 
wait a minute... are you the anti rand pirate from going native?
No superhuman powers, I read your post :) I tried submitting bugs before - not going to do it again. The people who responded to my reports appeared to be less than competent, and Connect itself is pretty horrible. I really can't afford to spend my time fighting Microsoft's systems. It's no fault of yours of course - I know you do tons of work, respond on Connect etc. 
Why don't they fix it in VS2012?
Why not? Company policy? 
&gt;why should I spend one dime on Microsoft's subpar offering? Why do you think someone should try to convince you to change your opinion? 
There's still serious bugs from 2003 and 2005, that they still have to fix. Excuses like: "It got lost in the great bug tracking system conversion of 2008" are the norm.
For MS to call themselves a compiler vendor, and not even entertain the idea of using a comprehensive test suite like Plum Hall. Well you know the rest. 
Are you allowed to develop commercial software with the free version? 
Thanks for your answer. "Obvious" wasn't meant to imply triviality or belittle your idea. I was just curious as to the thought process. Yes, ranges *are* subtle, and I'm glad Boost ranges aren't standardized because they're not quite perfect. Again, looking forward to reading the next part.
Because then you have no reason to upgrade ..
- clang does not work on Windows, yet - Windows commercial libraries only provide support for Visual C++, with partial support for C++ Builder, Intel, Portland Compilers - clang lacks the whole IDE experience from Visual Studio and respective debugging tools
You are seeing it in a different perspective, going native is still going on, but Microsoft extensions like C++/CX take priority over the standard, as the old COM and ATL extensions did in the old days.
The IDE, notably for autocompletion and debugging which are really really good. We also use it for C#. It's also difficult to get builds of closed-source libraries for anything but VS when working on Windows.
[Commercial use of Visual Studio Express](http://www.visualstudio.com/en-us/products/visual-studio-express-vs) Visual Studio Express products are available at no charge and may be used for commercial, production usage subject to the license terms provided with each product. For example, you can use Express for Windows to create apps that you can then submit for sale in the Windows Store. Another reference: http://social.msdn.microsoft.com/Forums/en-US/1aaf1efc-04df-40b9-9289-f3db0420c206/visual-studio-2012-express?forum=Vsexpressinstall
&gt; Surely you can see even with your one eye And right there you switched from sounding reasonable to coming across as a horrible human being.
&gt; enough to warrant 10K $ ? I dont know. Not to come across as an MS apologist, but they have mentioned in the past that *selling* Visual Studio in that sense has never really been their business model. Most customers of Visual Studio don't pay for updates to a new version, either their company has a MSDN subscription, or they get it for free anyway because they use the express editions. Also students and educators get it for free too.
For the STL, see "Q5: What about the bugfixes? Can we get those in an Update?" in [my VCBlog post](http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx).
&gt; No superhuman powers, I read your post :) Heh heh. I would appreciate being cited. :-&gt; &gt; I tried submitting bugs before - not going to do it again. For STL bugs, you can mail self-contained repros directly to me at stl@microsoft.com . All you need to provide is: * complete source code (almost all STL bugs can be reproduced in less than a page of code) * the exact command line (cl /EHsc /nologo /W4 /MTd meow.cpp is basic; vary as needed) * the major version you're using (ideally 2013) * the exact output you're seeing (compiler error, runtime output, etc.). I'll take care of the rest. For compiler bugs, I'll donate my time towards filing them if they're silent bad codegen (valid code, compiles without error, misbehaves at runtime), like the bug where temporaries in initializer lists are destroyed too early.
Arr matey, that be me.
Yes, you are indeed, see here: http://www.visualstudio.com/products/visual-studio-express-vs and scroll down to additional information / commercial use. 
Yeah, I couldn't survive the day without VisualAssist. 
Do you want a clang mono-culture? 
How can you compare a compiler with an IDE? I never programmed on Windows but I imagine that a decent IDE would be available or that one could exchange the used compiler.
Si VS2013 is nothing but a bug fix version of VS2012?
I think it seems "obvious" because when it's presented, you end up saying... "Oh, duh." I think that's a good thing -- it should be an obvious and easy concept for users to grasp. But the path from point A to point B is rarely a straight line. We'll know more about success of the idea as it scales up and sees usage. But of the candidates I've seen, I have the highest hopes for this one.
awesome presentation, hopefully you'll make more!
Um, the person I replied to has *already* formed a strong negative opinion of the product as being 'subpar'. This is what happens at the **end** of a discussion. I don't see a conducive environment for free exchange of ideas in this case.. 
Sure, I added a link to your post. That's great, thanks for the email address. It'll be nice to sidestep Connect. 
This is very interesting. I wonder if having different end types can help improve performance with other types of ranges, such as joining two ranges together, or flattening a range of ranges. Have you thought about what would be needed to support these type of ranges efficiently?
`make_unique` isn't part of c++11.
I know, and that's why it's ridiculous to say MSVC doesn't have C++11 implemented. Clearly donvito didn't test it. MSVC supports C++11 and even have some C++14 features (make_unique). [blog post](http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx).
&gt; such as joining two ranges together My range lib has such a join range view. Right now it only works with Ranges, not Iterables, but it's on my to-do list. Anything that speeds up begin/end equality comparisons will make the join range faster. &gt; flattening a range of ranges This is something that is best addressed with segmented iterators, which have been discussed for many years. The trouble is that algorithms need to be implemented to handle them specially. Consider what `for_each` could do if passed, say, a join range (which is a very simple range of ranges). It could `for_each` on the first range and then `for_each` on the second. This sort of thing is arguably easier to do with range-based interfaces, as opposed to iterator-based ones. You just need a way to ask a range (a) if it's segmented, and (b) what its internal segments are. You run into problems with an algorithm like `find` that must return a position. It's not enough to simply return an iterator into some internal segment. Rather, it must be an iterator that knows what segment it's in and how to hop to the next segment so it can iterate to the end. This is very hard, so nobody does it. I'm not trying to solve that problem.
The logic you're using here is: MSVC has a C++14 feature, therefore it must have C++11 implemented. Surely you can recognize that is a nonsense statement? Here is a list of C++11 feature support, and MSVC is missing a number of features still: http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport
C++0x ? MSVC 11.0 ?! I'm pretty sure this list is outdated...
So I'm curious then - how do things like the VS2012 &lt;ratio&gt; library, or the bugs in concurrency libraries get past all that? Is it just that you don't have the resources to fix these things, is it a matter of priorities, or something else? 
If I understand correctly, with your proposal, we wouldn't be able to reverse a delimited range, since it is only Iterable, and `reverse` would require a range(ie that the iterators are the same). Is that correct? Or are you proposing something else so delimited ranges can be reversed? I guess maybe that would be for the last part of your blog?
It's rarely a good idea to add in extra complexity just because maybe someday it will become useful. If you ever actually do try to make use of whatever it is, often it turns out to be inadequate for your actual needs, then the original work turns out to have been a waste of time or worse. Once one has a lot of experience built up around certain problems then maybe people get better about predicting future needs and preparing for them. But just starting out? No, keep it simple, straightforward, and functional. --- Also, that article mentions the difference between getters/setters and something that genuinely belongs in a public interface. Not every member function that returns things is necessarily a getter.
That's fair. Just keep in mind that the more limited your constraint is, the more iterations the loop will likely have to churn through before it lands on a valid random number. When possible, it's better to find a function to map from the random number generator to the set of values you're looking for that doesn't have any invalid values.
But would that work for SinglePassRanges?
See my post [C++11/14 Core Language Features in VS 2013 and the Nov 2013 CTP](http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx) for an accurate list.
Time limitations for both dev and test. SDETs need to update our suites and analyze failures as we implement new features, and then devs need time to fix bugs before RTM lockdown. I don't believe I was aware of ratio problems during 2012's development at all, for example. When I saw their extent during 2013's development, that's when I overhauled the entire header (and I wouldn't have had time to do that in 2012 anyways). Also, you don't see the many bugs that we do manage to fix during development - e.g. I fix bugs during code review that never get checked in.
There's a list of games you should go about making in the language of your choice for practice. I've lost it but it usually goes something like: * Text Based Adventure * Pong * Breakout * Sootemup like Galaga * Labrynth/Dig Dug (Maze puzzler) * Mario
I've been looking to start on something from this list: http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list/ Hth!
If you can get a c++ textbook, there are a ton of small projects, and if you get stuck, there are the topics to solve the problems. This will also give you a good idea of how much you know.
Because an IDE that provides a **good** developer experience requires a symbiotic relationship with the supported compilers, otherwise is always an half-baked solution. This is why most so called IDEs outside Windows suck so much, because they are just frontends that call command line tools, instead of having the said integration with the compilers. It was required Apple improvements to LLVM for XCode integration, to show UNIX folks how IDEs are supposed to be.
Looks like you mispelled celsius. Also 9/5 = 1.
Try this: double celsius; cout &lt;&lt; Enter the temperature in Celsius: "; cin &gt;&gt; celsius; double fahrenheit = celsius * 9.0/5.0 + 32.0; cout &lt;&lt; "Fahrenheit value is: " &lt;&lt; fahrenheit &lt;&lt; endl; getchar(); return 0; Some notes: 1. You mis-spelled celsius (as another has noted). 2. Your conversion would all be done in integer maths and the result is somewhat unpredictable, depending on your compiler settings. Suppose you put 20 in as the celsius temperature. It MIGHT multiple 9 by 20, getting 180, then divide by 5, getting 36, then add 32, getting 68. But it MIGHT also figure out at compile time that 9/5 = 1 (rounded down to the nearest integer) and so you will get 20 * 1 + 32 = 52. 3. You don't have to declare a variable and set its value on separate lines - in fact it's good practice to declare a variable and set its value on the same line where you can. Some compilers will warn when you fail to do this. 4. You can feed cout several different things to output in one line, as I have shown above. 
Should have mentioned that 9/5 != 9.0/5.0. 9/5 will be done in integer arithmetic while 9.0/5.0 tells the compiler that it is dividing double-precision numbers and so it will do the division in double-precision maths.
o yeah my bad, still learning, thanks guys all fixed! 
The idea behind some of the "make a game" (clone this game) advice is that the design is 100% done and it is easy to copy thus leading to correctness and performance tests (oh shit this isn't mario at all). Games make you work with lots of different things and the process of trying to bring them all together is a good challenge. In the end it's whatever floats your boat.
my brain started melting at 10min still, passing a const by value seems stupid...
I rarely see success stories about a single guy rewriting everything in a code-base so hats to you haha. It must have felt great when you first ran it with hundreds of pictures versus 20 using the regular UICollectionView as you mentioned. 
Thanks for the updated list! It is important for our code to be portable between MSVC, clang and GCC.
&gt; still, passing a const by value seems stupid... Wasn't that his point? If you pass an object by value then don't use const as that prevents using move semantics inside the function. 
1. the subreddit you're looking for is /r/cpp_questions; you're likely to get downvoted here 2. don't use C style strings when you have C++ `std::strings` 3. so try this - replace `char c[128];` with `string c;` and `cin &gt;&gt; c[128];` with `cin &gt;&gt; c;`. 4. come back if you encounter more problems 5. pisi imena promenljivih na engleskom, mojne da si neozbiljan 6. "ne znam" se pise odvojeno
well, i'll try shed some light on this topic using my superior deduction skills. 1. the language OP is using is a variant of serbo-croatian, however the 'dialect' he's using is found in montenegro, bosnia, and croatia 2. since he's using the word 'spoj' instead of 'veza', i'm fairly certain he's from either bosnia or croatia 3. OP's name is tomislav, which is currently not a popular serbian name, so he's likely not from the serbian part of bosnia - this makes OP a likely croat 4. the program is used to calculate the total resistance of a serial/parallel circuit, so i'm - since this is a relatively simple problem, i'm guessing OP is a high schooler. conclusion: OP is being taught C++ in a croatian high school, likely a technical one.
Down voted for puncturing the fan boy balloon, here have an up-vote.
.png is not an [appropriate format for source code](http://stackoverflow.com/questions/5508110/why-is-this-program-erroneously-rejected-by-three-c-compilers/5509143).
v and m would already be default initialize if you leave your initialization list empty (or specify to do so). Then you do a lock_guard and initiate the copy of other.v. You may occurs an small overhead on the default constructor, if you are using an old stl implementation, but most of them deactivate them through the std::vector&lt;T&gt;(std::size s) constructor.
I think /u/jokoon is not really that interested in the `const`. It's the lack of `&amp;` that is of interest.
&gt; but it still makes me uneasy. I love it! I think/hope everyone will have to get used to it. It's easier to read and to reason about and to teach. And it can be as fast, or even a little faster, as the alternatives. I make heavy use of it in a simple matrix arithmetic library I wrote that wraps around GSL. Given that we are all reasonably happy with *returning* by value, we shouldn't be surprised if value parameters become more common.
Most C++ build-systems have a big problem and cmake is no exception: If the configuration needs a turing-complete language, something, somewhere went terribly wrong. Basically I would really wish for a build-system that just looked at my source and figured everything out on it's own (include-dependencies, library-dependencies, sub-projects, ‚Ä¶). And no, this is not impossible: I have a usable program that creates makefiles for basic projects¬π and one in development that should in the end be able to figure out everything I listed above for all reasonably complex projects. ¬π https://github.com/Florianjw/Makefilecreator/ (The codebase is two years old (since then I learned quite a lot about C++), so I know myself that there is room for improvement. No need for pointing that out to me)
&gt; Most C++ build-systems have a big problem and cmake is no exception: If the configuration needs a turing-complete language, something, somewhere went terribly wrong. Maybe, but if we already go there, then the turing-complete language should, preferably, be designed as such from grounds up. Seeing CMake extended to such lengths is just painful. Almost as painful as looking at complex Make based systems ...
Heads up, this is just an upload to youtube of Scott Meyers' talk from Going Native 2013. Original on channel9: https://channel9.msdn.com/Events/GoingNative/2013/An-Effective-Cpp11-14-Sampler
When your build system becomes object orientated/Turing complete, you're probably doing it wrong...
The latest official Boost 1.55 release still doesn't support Visual Studio 2013. You'd think that MS would actually care about supporting the most commonly used C++ library (which requires submitting patches to boost).
an rvalue reference passed in itself is an lvalue. In that case you won't get desired result.
I concur. CMake should have been a "real" language from the start (they are working on a lua implementation for cmake) There are a couple of reasons for using Cmake and not some other kind of buildsystem: * small * extensible * and especially: it generates for almost all platform/ide/compiler/build configuration combinations as a result I had to use cmake and because it was lacking I implemented object oriented programming. 
Agree. The problem of CMake is not it's not OOP but its syntax really sucks. 
I am of course aware that there may be situations in which you really need a more powerfull build-system (and be it just a collection of shell-scripts). I admit that I only hinted that in my post. However: Build-systems for such complex projects should really be different ones than those for trivial and middle-complexity projects. For those I would prefer to write less then five lines of configuration. Let's say this is the project structure: src/ test/ testfoo.cpp testbar.cpp blub/ foo.hpp foo.cpp bar.hpp bar.cpp app1/ main.cpp app2/ bla.cpp (contains main) build.conf * lib should become a library (can be detected by the non-existence of main()) named libblub.so/libblub.a * app1 and app2 should both result in executables (that are linked against blub if required) * test should also result in an executable. Assume that there is no main() in either of these files because we want to use the one provided by the framework With this setup, build.conf should look something like this: project="projectname" compiler-options="-std=c++1y" # overrides the detected target type for the specified sub-projects: create_executable="test" External libraries should be detected from the includes in the source-files. The required compiler-options for them should then be read from a big global configuration, that may look something like this: header "foobar/baz.hpp" -&gt; foobar library foobar { link="foobar" options="-fdo-fancy-stuff" defines="NDEBUG" } 
I don't agree either. If all you have is c++ sources and headers, that'd be one thing. But many projects require more logic to build. Generating source from some binary format specifier, use of lexical analyzers, importing configs from a remote source, etc.
I can tell you how it's implemented, but I must warn you, this is the subatomic level of detail necessary for a Standard Library maintainer to know. The Standardese is [N3797](http://isocpp.org/files/papers/N3797.pdf) 20.2.4 [forward]/2-3: `template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept;` `template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp;&amp; t) noexcept;` Returns: `static_cast&lt;T&amp;&amp;&gt;(t)`. Remark: If the second form is instantiated with an lvalue reference type, the program is ill-formed. Let's look at the first form, which is what everyone calls: template &lt;class T&gt; constexpr T&amp;&amp; forward(remove_reference_t&lt;T&gt;&amp; t) noexcept { return static_cast&lt;T&amp;&amp;&gt;(t); } First, this requires explicit template arguments. That's because `remove_reference_t&lt;T&gt;` is an alias for `typename remove_reference&lt;T&gt;::type`, and template argument deduction can't see through to the left of a double-colon (the Standard-speak is that this is a "non-deduced context"). This is good, because forward's whole purpose in life is to restore the value category (lvalueness/rvalueness) of an expression. That information is encoded in the template argument and cannot be deduced from the expression. Now, consider what happens if we're in a perfect forwarder `template &lt;typename A&gt; outer(A&amp;&amp; a)` and we call `forward&lt;A&gt;(a)`, and `outer()` has been called with an rvalue, say `string("meow") + "purr"`. Template argument deduction finds `A` to be `string`, so the call is `forward&lt;string&gt;(a)`. `a` has a name, so it's an lvalue, and we would like this expression to be an rvalue, restoring the original value category. The first form strips any references from `string` (there are none) then takes `string&amp; t`, and that's cool because we're giving it the `a` lvalue. Then it says `static_cast&lt;string&amp;&amp;&gt;(t)` and returns that as `string&amp;&amp;`. This converts an lvalue to an rvalue and returns it. (The cast is necessary, because `t` has a name.) We're done! What if `outer()` is called with a named `string str`, as in `outer(str)`? The template argument deduction tweak activates, and `A` is `string&amp;`, so the call is `forward&lt;string&amp;&gt;(a)`. We are starting with an lvalue `a`, and we want to get an lvalue back, because `str` had a name. Now `remove_reference_t&lt;T&gt;` strips the lvalue reference, but then the first form adds it back, so `forward` takes `string&amp;` and that's good because we called it with `a`. Then `forward` says `static_cast&lt;T&amp;&amp;&gt;(t)`. Reference collapsing activates, so this is `static_cast&lt;string&amp;&gt;(t)`, which is a no-op. And that's returned as a `string&amp;`, which is an lvalue. The second form was added during C++0x's evolution. This is called if you say `forward&lt;T&gt;(some rvalue expression)` (and I don't know why you'd say that). Note that it is not a perfect forwarder, due to the `remove_reference_t`. It behaves exactly the same as the first form, except that it prohibits saying `forward&lt;X&amp;&gt;(some rvalue expression)`, i.e. attempting to convert an rvalue into an lvalue which is extremely dangerous. The Standardese requires a `static_assert` to fire here (this is the "ill-formed" language).
I really, really like this idea. I think as we start more greenfield projects, people are starting to ask questions about how can we add the tooling that we really want to our build system from the start. In order to do that, you need to be able to describe in detail how that tooling is going to be invoked, and you need to be able to provide an interface to your users to make it as easy as possible to get the advantages of the tooling in your build process whenever new targets are added. Solving that problem means being able to write implementation details in a maintainable and testable ways - one of the problems [which I've also been trying to solve myself](http://github.com/polysquare/cmake-unit). While there are drawbacks to over-object-orientation, it certainly has its advantages in producing maintainable software. That being said, if there's one thing I really wish CMake would gain in the future is the ability to call a function specified variable, so that different implementations can be provided for operations on specific data sets. I can see that oo-cmake works around that somewhat by using the filesystem, but I really hope there will be a better way to do it in the future.
Isn't this what BJam is trying to do?
Not to mention that aside from toy projects, you'll almost always acquire cases where you want to include fileA on 1 platform &amp; fileB on another. Having files picked up implicitly is typically an error-prone approach. I think the point that's being made is that the line between when you need the complexity &amp; when you don't is much closer to low-complexity projects than you might think; if you've built your entire project on this inflexible build system you now have two medium projects you have to maintain. If you start with an existing flexible build system (I like cmake, but it's not perfect), then you're leaving yourself room to grow. By the way, it sounds like you're basically just re-inventing pkg-config. clang is also doing something similar with modules just in a smarter fashion.
Check out [waf](https://code.google.com/p/waf/).
Indeed. I still don't understand how cmake got so popular. I am forced to use it at my University for things that I can (and do) write my own 5 line makefile for. If you need to use a more complex system, then why cmake when there is Premake which is more powerful _and_ actually readable?
VERY SHOUTY SYNTAX
IMO, Premake is too new and not as well supported (in packages on the Unices) to be a proper replacement just yet
Just make it a static method of the class. Header: static Widget* create(); Source: static WidgetManager __widgetManager; Widget* Widget::create() { return new Widget(__widgetManager); } This pattern can be used for all common operations: creating widgets, finding them by name or index, grouping, etc. You can even remove the `WidgetManager` entirely and just use a static `std::set&lt;Widget*&gt;` for example. The downsides are that you can only inspect the `Widget` collection in the source of `Widget` and that the constructor must be private.
This is not a really good solution. Who and when will free the memory allocated in create? Also, violates the double underscore rule (not an error, but the code is not future-proof this way.) 