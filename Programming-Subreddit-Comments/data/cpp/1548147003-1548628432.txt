Seems kind of moot given `&amp;Person::age` works fine.
kdev doesn't look good, but it gets the job done. If you are on Linux\*, emacs is a beast but requires a lot of configuration/hacking before getting it working. It also has lots of different themes to make it look like how you want it. I find navigation both in text and in buffers in emacs superior to any modern IDE. &amp;#x200B; \*: not sure how well supported emacs in Windows or in other OSes.
TIL someone expected that vector is pulling string as a dependency
I may need an image processing library in future for a planned project. You say other libraries are lacking. Lacking what exactly?
notepad. 
I thought this was going to be about aliasing memory and how that breaks under optimisations, not about typedefs of pointer types. Interesting though.
Projections are fine, concise enough and readable. But they will only work where they are expected (i.e. only in ranges functions).
Create a source file filled with explicit instantiations :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/gamedev] [Simple Property\/Reflection System for games](https://www.reddit.com/r/gamedev/comments/aila23/simple_propertyreflection_system_for_games/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
The developers don't expect it - but people tend to treat includes as "something you add when your code doesn't compile", so if you use std::string and it compiles - you never even think to check if its in your includes or not.
Hungarian notation to the rescue! ;) using uMyClassPtr = std::unique_ptr&lt;MyClass&gt;; using sMyClassPtr = std::shared_ptr&lt;MyClass&gt;;
glamour? [SpaceVim](https://spacevim.org/) | [spacemacs](http://spacemacs.org/) | [Builder](https://wiki.gnome.org/Apps/Builder)
The '&amp;Person::age' can get quite verbose as soon as 'Person' becomes a template
I had my period where I aliased every template I used (smart pointers, functions, etc...). But after that, I spent more time running after looking at what was the real type than actually writing code. IMHO type aliasing isn't bad, but IDE tools must improve a lot to display the real type wherever it encounters an alias.
Main problem I see is that you rely on inheritance. What happens if you want to add properties to both a base\_object, and a derived\_object that inherits base\_object? Consider either a free function with template execution or come up with an inheritance tree? Second issue is the usage of macros - they're error prone and inelegant - use constexpr functions with variadics instead.
&gt;for ( auto&amp; person : persons) std::cout &lt;&lt; person.age &lt;&lt; '\\n' ; Is shorter and clearer. But c++ being c++ you may get what you wish at some point.
the biggest problem of range is performance, both compile time and run time
This is why everyone is so quick to hate c++. Instead of giving people a tried and obvious way to do things c++ solution is always giant ball of template magic that is both odd to write and even more odd to implement. /u/sephirostoy gave a proper solution. 
this shouldn't compile, n.age is a private field in the example. 
Well: std::ranges::sort( persons, std::ranges::less, (n) =&gt; n.get_age() ) ; &amp;#x200B;
I am an experienced modern (C++11 - 17) C++ developer, 7+ years professionally, 10+ years total. On top of that, I've worked on a number of side projects to expand my skill-set and to keep learning about new libraries and technologies. I'm based in Berlin, Germany and looking for something remote. &amp;#x200B; Github: [Gendron5000](https://github.com/Gendron5000) &amp;#x200B; Main areas of experience: \-Algorithm design/maintenance, performance testing, accuracy analysis, retrospective performance comparisons; mainly in the area of text-matching \-Porting code from Windows to Mac; previously responsible for our team's official Mac release builds \-Network and database security; user authentication, network/database encryption, application registration keys \-Familiar with researching and integrating 3rd party libraries, experience working with a number of libraries; Qt, WxWidgets, OpenCV, mlpack, TBB, Datalogics PDF library \-Cross-platform development, comfortable with many IDEs (Visual Studio, Xcode, Unity, IntelliJ IDEA, Qt Creator) and proficient with the command line \-Entire software development cycle; creating design and technical specification documents, creating/analyzing/fixing bugs, participating in sprint meetings to plan out tasks, designing/implementing new features, meeting ISO process guidelines \-Experience with Arduino/RaspberryPi and proficient in designing/creating/soldering circuits &amp;#x200B; &amp;#x200B; Side Projects: \-Comparison between Modified A\* search algorithm and a neural network algorithm to play Super Mario Bros for NES through a modified fceux emulator \-Created sample library to use a genetic algorithm to build a recurrent neural network using mlpack \-Designed and built a solar/electric boat to completion; electric motor + solar panel + batteries = no petrol! \-Using OpenCV and GnuBG; created a backgammon training application app which uses a camera to detect moves and dice roles and uses GnuBG's back-end to analyze players' moves \-Created a 3D multiplayer pinball game using a hybrid server-client 'host' to ensure each players' local pinball physics calculations are done locally for optimum performance; made using Unity and Blender. &amp;#x200B; PM me for more information/CV.
cheers to code that works :) same error is in the original post. 
this is not correct. you can look at the intel architecture manual, this is guaranteed. I know many firms using this for 10+ years in production clock_gettime is over 100 times slower and can spike to much more, it is unreliable to be used as timer
Out of curiosity, would it be possible for CL to pull all known headers into a shared memory RAMDrive-esque space to reduce IO? As in, having a space that's shared between the 40 or so instances of CL.
I'm out of the loop here. What have he proposed?
No. And I have zero idea how that is connected to anything I said. Imagine talking about the economic underpinnings of the french revolution. Then someone asking about a point (wheat prices, say), then you clarifying it. They then say "like the CERN deal where France uses excess nuclear power in the winter as part of its contribution; and a bunch of stuff about global warming and carbon neutrality". I really don't know where to go at that point. I mean your response is about function signatures, but then you go on about internal map iterator implementation features and restrictions. I surrender.
**Company**: [**Summitto**](https://summitto.com/) **Type**: Full time **Description**: Summitto is an award-winning startup building the largest invoice registration network of the world. The purpose? Helping EU tax authorities to **eliminate 50 billion EUR in annual invoicing fraud**. If you‚Äôre excited to build and design **open-source** software which will be used by **millions of companies**, we are looking for you! We're hiring junior √°nd senior developers at the moment. Experience with cryptography is a plus, but not required! **Here‚Äôs a little taste of your challenge, you will help build:** * a distributed systems consensus algorithm * blockchain data structures * fraud identification algorithms * secure interfaces and integrations **Location**: Amsterdam **Remote**: No **Visa Sponsorship**: yes **Technologies**: C++17, python. **Contact**: [**careers@summitto.com**](mailto:careers@summitto.com) questions are always welcome!
Tbh this wouldn't be too complicated to implement imho
When it comes to your aliasing, I always advocating against it with respect towards pointers. The lifetime and ownership of an instance shouldn't be tied to its type. They're different concepts.
You can write for (auto age : persons | view::transform(&amp;Person::age)) Which seems better since there are lots of things you might want to pipe through (most notably, `filter`)
The "proper solution" is still using a projection, so I'm not sure what exactly you're complaining about. Lambda verbosity? 
&gt; I surrender. Ditto. &amp;#x200B; I don't see how " C++ lacks the ability to say "parameter that satisfies all of these view contracts" " has something to do with the fact that "find"/"lower\_bound" exists only as class member of std::map.
Probably, if there would one.
See [this](https://www.reddit.com/r/cpp/comments/aikkrp/projection_a_powerful_feature_in_c20_ranges/eeogwez/) comment.
[Direct link](https://github.com/hosseinmoein/Q) I have nothing to say about the actual content, but you really should've just pasted in the text itself, rather than a picture of the link. It makes it much more likely that people will look at it.
&gt; and the smoothest debugger I've seen people praise the MSVC debugger as _the_ debugger of choice for C++ but my experience has always been that it's quite mediocre, not sure why. I remember weird breakpoint semantics at times and the type/object/data introspection wasn't _that_ great either. gdb (on Linux) seems to be superior to me. Granted, it's somewhat harder to use, but once I figure out the command I need I typically get better results out of it. 
That lambda is also a projection, so not an alternative
Isn't that what OS disk cache already do automatically? Never have seen compilation to be really disk dependent (though maybe 128 GB RAM help a bit with that).
Thank you. I didn't realize that was the case. I corrected it
i almost believed you, since while i have no such issues others may, but then i read the last sentence. lol.
I fail to see your point. I use both so I'm able to compare them.
Of course if anew OS version changes its behavior/API you have to adapt your code. TIB is documented in the MSDN (== the official MS documentation for developers) - why then documenting only a part of TIB? Of course this would fool the developers because they do not know that parts are not documented ... It's still MS fault!
It doesn't surprise me at all. Someone includes &lt;vector&gt; then uses strings later because they auto complete and compile. &lt;vector&gt; including &lt;string&gt; sounds like something that should never have happened in the first place. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ain9gu/book_review_mastering_the_c17_stl/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is more confusing than simply using the original types :-P
Thank you very much for your kind feedback. The system is intended for the base class of a particular system to inherit the property::base as well. This can be done using multiple inheritance. The concept is that you may be operating only with the base classes of the system and yet you want to be able to extract all the object properties, for that you need a virtual function at its base (as far as I know). constexpr function would be great! However, I am not too sure how to do it in such a way that would keep the usage of the system as elegant as it is now. I have another version which uses more metaprogramming but ended up looking worse, and more complex. But I do agree with your sentiment, just not sure how to go about it. Thanks again. &amp;#x200B;
https://www.gnu.org/fun/jokes/ed-msg.html When I log into my Xenix system with my 110 baud teletype, both vi and Emacs are just too damn slow. They print useless messages like, ‚ÄòC-h for help‚Äô and ‚Äò‚Äúfoo‚Äù File is read only‚Äô. So I use the editor that doesn't waste my VALUABLE time. Ed, man! !man ed ED(1) Unix Programmer's Manual ED(1) NAME ed - text editor SYNOPSIS ed [ - ] [ -x ] [ name ] DESCRIPTION Ed is the standard text editor. --- Computer Scientists love ed, not just because it comes first alphabetically, but because it's the standard. Everyone else loves ed because it's ED! ‚ÄúEd is the standard text editor.‚Äù And ed doesn't waste space on my Timex Sinclair. Just look: -rwxr-xr-x 1 root 24 Oct 29 1929 /bin/ed -rwxr-xr-t 4 root 1310720 Jan 1 1970 /usr/ucb/vi -rwxr-xr-x 1 root 5.89824e37 Oct 22 1990 /usr/bin/emacs Of course, on the system I administrate, vi is symlinked to ed. Emacs has been replaced by a shell script which 1) Generates a syslog message at level LOG_EMERG; 2) reduces the user's disk quota by 100K; and 3) RUNS ED!!!!!! ‚ÄúEd is the standard text editor.‚Äù Let's look at a typical novice's session with the mighty ed: golem$ ed ? help ? ? ? quit ? exit ? bye ? hello? ? eat flaming death ? ^C ? ^C ? ^D ? --- Note the consistent user interface and error reportage. Ed is generous enough to flag errors, yet prudent enough not to overwhelm the novice with verbosity. ‚ÄúEd is the standard text editor.‚Äù Ed, the greatest WYGIWYG editor of all. ED IS THE TRUE PATH TO NIRVANA! ED HAS BEEN THE CHOICE OF EDUCATED AND IGNORANT ALIKE FOR CENTURIES! ED WILL NOT CORRUPT YOUR PRECIOUS BODILY FLUIDS!! ED IS THE STANDARD TEXT EDITOR! ED MAKES THE SUN SHINE AND THE BIRDS SING AND THE GRASS GREEN!! When I use an editor, I don't want eight extra KILOBYTES of worthless help screens and cursor positioning code! I just want an EDitor!! Not a ‚Äúviitor‚Äù. Not a ‚Äúemacsitor‚Äù. Those aren't even WORDS!!!! ED! ED! ED IS THE STANDARD!!! TEXT EDITOR. When IBM, in its ever-present omnipotence, needed to base their ‚Äúedlin‚Äù on a Unix standard, did they mimic vi? No. Emacs? Surely you jest. They chose the most karmic editor of all. The standard. Ed is for those who can remember what they are working on. If you are an idiot, you should use Emacs. If you are an Emacs, you should not be vi. If you use ED, you are on THE PATH TO REDEMPTION. THE SO-CALLED ‚ÄúVISUAL‚Äù EDITORS HAVE BEEN PLACED HERE BY ED TO TEMPT THE FAITHLESS. DO NOT GIVE IN!!! THE MIGHTY ED HAS SPOKEN!!! ?
I'm going to go with CLion as far as looks *and* function. Sometimes I'll still have to fire up vs for certain cases.
i didn't downvote you previously (you were at zero). I did now. the lol is that "No issue at all with a CLion however". hahahaha, almost spilled my coffee. the same clion who doesn't know about templates. but sure, whatever makes you happy. 
/uj I think I'll do an one month challenge of using just ed as my text editor.
No need for /uj this is /r/cpp here.
Oh, so it seems. 
Man, a stone cold classic, this. "eat flaming death" is still my go to phrase when I'm frustrated and just have to type something in. Also, search and replace for that before committing...
Very cool to try to implement this or any other proposal, kudos :D I was wondering (not sure if it's you who should answer) for the environment part: how does it compare to Boost.Process's facilities to work with environement? Notably \`boost::this\_process::environment()\`
This is very interesting. I would expect performance overhead to be really, really minimal (especially if I don't call these functions)... but have you tried to test that? I think most of my curiosity is really about the paper more than your implementation. Though I do want to say - you might consider using named algorithms (with either iterators you've already implemented or with ranges formed from them) instead of old-fashioned loops. For example, env_find could easily be implemented in terms of std::find_if Restricting access to arguments may have been an accidentally good design - separation of concerns. Right now if a library is annoying enough to want access to argv &amp; argc I can declare my own variables that are different from my real arguments and pass those, which I've done on a couple of occasions. It's really the application owner - the implementer of main - who owns the arguments and is allowed to decide what objects of what types get created from them and which are visible to what parts of the code. If I declare main with no arguments, I suspect the implementation of my toolchain (generally speaking) is allowed to get away with not even dealing with this stuff. But this approach breaks with that, right? Because you can't easily verify I never access std::arguments. I wonder if this might behave strangely with runtime-loaded libraries (think dlopen). I guess if you're writing code to be used in such a way you already have to be super careful about depending on stuff from the standard library or making sure it's exactly the same standard library the executable uses... so I suppose that's not really a new concern. Is allowing setenv really a good idea?
huh? Person is a struct. age is very much public.
&gt; private How? Person is a struct with no visibility specifiers, so all the members are public
The declare the overloaded | operator yourself. #include &lt;vector&gt; #include &lt;range/v3/view/transform.hpp&gt; #include &lt;iostream&gt; struct Person { std::string name ; std::string address ; int age ; int hegiht ; int weight ; }; template&lt;class aggregate_t,class member_t&gt; auto operator|( std::vector&lt;aggregate_t&gt; const&amp; lhs, member_t aggregate_t::* rhs ) { return lhs | ranges::view::transform( [rhs](auto&amp;el){return el.*rhs;} ); } int main() { std::vector&lt;Person&gt; persons = { {"Joe", "123 Main", 9, 876 /* what unit is hegiht measured in? */, 240} }; for ( auto age : persons | &amp;Person::age ) { std::cout &lt;&lt; "age=" &lt;&lt; age &lt;&lt; '\n'; } } 
&gt; the biggest problem of range is performance, both compile time and run time [citation needed]? Yes, compile times are slower because the compiler is doing a lot more checking, but I've yet to see any effect on runtime performance of algorithms compared to the vanilla STL. 
I see a lot of undocumented `-PogoXXX` options. I wish Microsoft documents their behavior, because PGO becomes less and less useful in latest versions of the compiler. For me, if PGO is enabled and application execution is trained, it tends to compile a whole lot of 0,01% functions "for speed" and the rest of functions "for size", which effectively turns off optimization for a whole binary. For example, I'm very interested in optimizing application startup performance, where a lot of initialization takes place, and this code will almost always be "cold" in PGO opinion. For code compiled "for size", inlining is basically turned off to the point where you may see a call to `std::move` and other similar functions not inlined at all.
I personally setted-up a blog with [gitlab pages](https://docs.gitlab.com/ee/user/project/pages/), and using the hugo generator. It was really simple to do it (I was honestly amazed to what I was able to do in an afternoon). It's definitively worth a try. And unlike most blog hosting platform, you have full control on what you do (it would be the same with the github equivalent).
FYI You don't need the lambda. Just `lhs | view::transform(rhs)` works. 
only in the first half. a few lines down you find: class Person { int age ; public : there's also things like `std::ranages::less`. i understand how these mistakes happen and make them a lot myself, but it still bothers me when example code was never run. 
I wish this proposal went further toward actually parsing the command line arguments like TCLAP does. http://tclap.sourceforge.net/
Haven't heard of it, so I can't say
Haven't heard of it, so I can't say
And unfortunately they don't support OMP. If we take care about performance then many many projects use OMP. Currently parallel stl starts to be popular, but still OMP is used in so many projects and libraries.
get\_age() comes after the public. The ranages isnt part of a program that could be run.
I disagree, if you look at other languages they all have a way of retrieving just the argument text, IMO that's what the languages needs first of all I'm not against the idea, I just think that's a different job.
I‚Äôve been wondering whether it would make more sense for C++ compilers to be multi-threaded and to compile across units in threads, rather than separate instances. It might help with issues such as this, and template instantiation (I‚Äôm imagining there being some kind of global pool of instantiations that threads could check, rather than every unit making their own and them being pruned at the end). Before anyone downvotes this to oblivion, I freely admit to not really knowing what I am talking about, and that I know this is pretty much a heretical idea to begin with. I‚Äôm interested to know why though.
Agreed. I want both of these things in the standard library, but separated/layered.
Interesting. I tried github pages with Jekyll, but gave up because it turns out I hated Jekyll. I'll give it a look. 
Thanks; fixed.
`std::ranges::sort( persons, std::ranges::less, []( auto &amp;&amp; n ) { return n.age ; } ) ;` I'm guessing that `std::ranges::less` is the default parameter for the predicate, similarly to the comparator in `std::sort`, am I right? I would expect most invocations of `sort` to be of the above form - requiring a custom projection function but not a custom comparator. This is based solely on my own experience. But if my experience is representative, it seems more convenient to have the projection function come before the predicate in the parameter list. to make such invocations terser.
Lacking usability, type-safety, good interfaces, "lightweightness", my trust, or functionality, depending on what you compare it to. See [here](https://github.com/kmhofmann/selene/blob/master/docs/rationale.md) for more details.
Kind of an orthogonal topic, but anyone know what the status is of [`std::observer_ptr`](https://en.cppreference.com/w/cpp/experimental/observer_ptr)? Or whatever the name is/will be? Any sort of explicitly annotated non-owning stored pointer seems useful to a reader, if not a compiler.
vector needs to throw out_of_range, which derived from logic_error, which has a const string&amp; constructor in its interface.
You can write your own.
Something like Boost.Program_options could be standarized.
I can agree with that. Seems like a better way to break it down.
I like CodeBlock's minimalism. Maybe that's just me. Never cared for VS too much.
Forget the why, we have a new how in constexpr if. \`if constexpr\` lets you write this sort of type switching via 'ordinary' recursion. * familiar imperative code * should compile faster without the template partial specialization instantiations * looses the declarative nature of template matching More succinct, uthinkt? [https://godbolt.org/z/3mMP5O](https://godbolt.org/z/3mMP5O) &amp;#x200B;
Then how can vector not include string? 
&amp;#x200B; * I can't really use std::find\_if because I would need to know where 'end' of 'environ' is. I don't think there's a way to find out other then walking pointer by pointer looking for the null. * I don't get your point, this is meant so you DON'T have to capture those variables and pass them around from main. It's a convenience. &gt;"...if a library is annoying enough to want access to argv &amp; argc..." Like... command line parser libraries? * There are other ways to get the arguments, they're just non-portable. In windows for example you can get the command line for the current process at any time by calling "GetCommandLineW" * also don't ask me how that weird "gnu::section" thing works, that was already there when I started working on it :P * why would using setenv be a bad idea in this case?
I think the models you describe are still "too" nice (aka not low level enough). The medium model uses near pointers for data, and far-fat pointers for code (segment+offset are both transparently embedded into the pointer type). The large model only has far-fat pointers. IMO the real weirdness is handling a single program that has both near and far pointers for data. That means that some data pointers are near, and some data pointers are far, and you need to be able to take a far pointer and split it into a near one + offset, and also take a near pointer and an offset and make a far pointer out of that.
Always remember: When seeing something new, programmers tend to demand it be verbose. ‚ÄúWTF is this? You should really spell this out if you are going to do something like this!‚Äù But, after they grok it and see it a few times they start complaining ‚ÄúWhy is this so verbose? It‚Äôs so simple and it‚Äôs friggin everywhere!‚Äù
There are some C single file libraries that do the same thing - they might be worth looking at so you can adsorb their power and learn their secrets. 
Complaining about mental tax.
... of which part?
I think the idea will be to use more than one perceptron. 
Two workarounds: 1. Forward declare string and add constructors users can‚Äôt name in order to avoid needing to make a string. 2. Call a separately compiled function which does the actual throw. (2) was already done for us (for presumably code size reasons?) long before my time but the stdexcept header hadn‚Äôt been removed.
&gt; I would need to know where 'end' of 'environ' is Well you need to implement `end` and `cend` anyhow. Right now you've implemented those on O(N) complexity. You could (maybe should) consider caching the size. Even if you don't - you can easily create a range without knowing where the end is. &gt; so you DON'T have to capture those variables and pass them around Yes, exactly. I don't want a library touching my command line parameters in a way I can't easily control without modifying their code (which I might not have access to). If I'm an executable that does one thing today, and a small plugin module in an executable that does 30 things tomorrow, I want that library to be able to maintain the same functionality. If I have to fake up argv &amp; argc for that library I can do so. &gt; There are other ways to get the arguments Indeed, without such you wouldn't be able to implement this as a library independent of the toolchain. I take issue with them for the same reason, though they're less likely to be used than something in `std::`. &gt; why would using setenv be a bad idea in this case? Not really "this case", I was actually objecting generally to the idea of standardizing setenv since other threads could be accessing that data. But the more I think about it the more I wonder how it's supposed to work. Specifically, is this true for yours: &gt; However, the underlying iterator‚Äôs environment will still iterate on the unmodified version of the environment. 
Well, sure. That's rather about convention/interface. And it could turn out that I just didn't know about existent one.
`identity` can be inlined easily by any sane compiler. Pointer to members, not as much. This is similar to the function pointer problem - when the algorithm is complex enough that it isn't inlined, the compiler generates an out-of-line body for `sort&lt;SomeRange, SomeComparator, T U::*&gt;`, and in there you don't know the value of the pointer to member. It's pretty easy to work around though by embedding the pointer to member value into the type of the projection.
`std::ranges::less` is a type. You can't pass that as a function argument. You want `std::ranges::less{}`, `std::ranges::less()`, or just `{}`.
[https://www.reddit.com/r/cpp/comments/airalq/variant\_visitation\_v2/](https://www.reddit.com/r/cpp/comments/airalq/variant_visitation_v2/)
This is a book review. It‚Äôs not asking for help, it is providing interesting information. This automoderator needs tweaking.
Damn, what a shame I'm stuck with c++11 at my current place:(
Good idea! I'll take a scan, any that come to mind?
Well, as someone who has been struggling a bit with files right now while planning and working with data loggers, I can't wait to go to my computer and test this. Thank you sir!
Boost.Mp11 has a nice little function `mp_with_index` for generating switch statements like this. I get that you probably don't want dependencies for this though.
For conciseness, part of the problem IMO is that `unique_ptr` and `shared_ptr` are just mouthfuls. Some (possibly _too_ concise) names inspired by Rust can be added with some "good" pointer template aliasing: template &lt;typename T&gt; using box = std::unique_ptr&lt;T&gt;; template &lt;typename T&gt; using rc = std::shared_ptr&lt;T&gt;; What I don't like about that is that "constructor" functions aka `make_box` and `make_rc` are still unpleasant.
Nice. mp11 is awesome.
I'll have a closer look, thanks a lot! Unfortunately the documentation seems broken, it looks very weird and results in some "Page not found" errors, e.g. https://trilinos.github.io/about/cxx11/linear_solver.html.
Yep I think that's totally true so you certainly can't blame them for choosing Armadillo ;-) I'd probably have done the same ;-) Just saying for me as a user, Eigen (or matrix-library-agnosticity) would be highly preferred, for multiple reasons.
Ok thanks a lot! Is there by any chance a simple example of how the implicit conversion operator of std::string to string_view looks like? And that must incur the cost of creating a string_view (i.e. initialising a pointer and stack-allocating the size variable) too, right? (It's probably negligible though but only because string_view is such a lightweight type with only two member variables?).
&gt;Well you need to implement \`end\` and \`cend\` anyhow. Right now you've implemented those on O(N) complexity. You could (maybe should) consider caching the size. From C++17 you can have end/cend different type comparable with begin/cbegin, so it's O(1), iterating/searching will be then O(n).
Well I do absolutely confirm that the few issues I've listed with QtCreator do not exist with Clion, at least, and I don't *believe* I've had issues with templates either. In any case, I think both are using clangd now (or can use it) as provider, so any difference in behavior is the code using it - I doubt clangd has issues with templates and such.
clion was very adamant and proud that they wrote their oen C++ parser. which gave me quite the lol. qtcreator and kdevelop are using clang for quite a while now and none of the issues you've reported show up on my system. so ... whatever.
I'll never say Clion's parser in the early versions was perfect - I was just comparing the latest versions as of today. 
how does it hold up when scaled over multiple variants?
I haven't gotten around to writing runtime perf benchmarks for those yet. I'll report back with measurements later üôÇ
That is roughly what ZapCC does.
Is English fast?
What does rc mean (i.e., what does it de-acronymize to)? &amp;#x200B;
I noticed this problem and have started using: sptr to mean std::shared\_ptr uptr = std::unique\_ptr optr = optional wptr = weak pointer lptr = local\_shared\_pointer (boost) H/T to /u/nikbackm who posted something similar first.
Me personally, what I'd *really* like is https://pypi.org/project/ConfigArgParse/ for C++ shipped in the standard library. That would be very cool.
Reference counted?
Documentation in Trilinos is definitely a problem as usually the developers are preoccupied on implementing things to meet near-term deliverable demands and documentation is often not a paid-effort. Trilinos is a huge collection of 60+ packages, while ROL is just one package. The slides at the bottom walk through one example https://trilinos.org/wordpress/wp-content/uploads/2017/11/ROL.pdf Some of the simpler examples: https://github.com/trilinos/Trilinos/tree/master/packages/rol/example/rosenbrock https://github.com/trilinos/Trilinos/tree/master/packages/rol/example/zakharov https://github.com/trilinos/Trilinos/tree/master/packages/rol/example/simple-eq-constr Here is the interface for Eigen: https://github.com/trilinos/Trilinos/blob/master/packages/rol/adapters/eigen/src/vector/ROL_EigenVector.hpp
I believe our implementation uses switches in 15.9; it certainly does in VS2019.
&gt;alignas(long long) unsigned char space[sizeof(long long)]; IMO it should be `union { long long space; };` and get out of the faking it game.
Yep! so I heard üôÇ
Can anyone else corroborate this? I recently spent two days setting up PGO training runs on a cmake based project and I was disappointed by the results vs a normal release build. I assumed I was doing a poor job providing training runs and gave up.... now I‚Äôm not so sure.
Yes it violates the standard, but what I mean is I don't have two variables that the compiler would think are not aliased but do alias and cause problems because of it. 
Wow. Great summary/ review. You‚Äôve definitely set a high bar for anyone else thinking of posting book reviews...
That's nice. Yes. `{}` is the best.
fixed. it can simply be `{}`
I thought so, too. Shameless self-promotion hoping to share some wisdom if others care about this: https://github.com/ProgramMax/max/blob/master/Docs/max/v0/Compiling/AliasingOptimizations.md
I see. I wish the C++ compiler will be improved in C++20 time so we don't need to write boilerplate lambda expression for the sake of performance.
I would like to see this go in. I use similar things from Qt frequently. 
You can make a new constructor that will have a shorter name if you want.
First, kudos for spending time on implementing this. I only had a quick look at the Windows implementation because that's what I'm familiar with the most. I have a few questions and comments. Is this thread-safe? It looks like `windows.cxx` uses a (sneaky) global object `environ_`, but I'm not seeing any synchronization. Calls to `_putenv()` and `_getenv()` (and friends) also need to be synchronized, as they're not thread-safe themselves. You don't seem to be very exception-safe. `initialize_args()`, for example, can throw in `to_utf8()`, which would leak `wargv`. In `environ_table`'s constructor, `to_utf8()` can again throw, which would leak `m_env`'s pointers since the destructor won't be called. I'm seeing _a lot_ of manual memory management in the private member functions of `environ_table` with a leak in at least `varline_from_os()` if `to_utf16()` fails. You're using `auto` as a return type in many functions, but not all. I don't understand your convention. On a personal note, I dislike using `auto` for simple return types, because I then have to study the function to figure out what it returns. YMMV. You have other consistency issues, like `to_utf8(wchar_t const* wstr)` and `to_utf16(const char* nstr)` for example, and you also have inconsistent file names (`.cxx` and `.cpp`) You're not checking many of the Windows API calls for failure, like `CommandLineToArgvW()`, which can lead to undefined behaviour since you don't initialize `argc`. You also don't check `_wputenv()` and friends for failure, but the paper seems under-specified on error reporting. You're mixing "safe" and "unsafe" versions of API calls, like `_wputenv()` and `_wputenv_s()`. The functions in namespace `impl` at the bottom are all marked `noexcept`, but most of them can throw. Your tests are very basic. They're hand rolled with a couple of `cout`s, and they don't test things like encoding conversion failures. You should at least be using a test framework. That's all that comes to mind right now. Again, nice work.
No lambda writing needed for member function pointers. Just something like `fn&lt;&amp;Person::name&gt;` where `fn` is `template &lt;auto F&gt; constexpr fn = [](auto&amp;&amp;... args) -&gt; decltype(auto) { return std::invoke(F, fwd(args)...); };`
Using `endl` forces a buffer flush as well as the newline character. Now, terminal output (via stdout/cout) is usually line buffered, so that was going to happen anyway, but files are usually buffered in much larger blocks for performance reasons. Using `endl` everywhere defeats that.
Reading a file until you encounter [an empty line](https://github.com/rec/tfile/blob/master/include/tfile/tfile.h#L76) is not exactly what you need most of the time. `fclose` can return an error you don't check. `readLine` won't work with "Mac" text files (see `man unix2mac`). Move operations should be `noexcept` in you case.
I can't think of how a classic near/far pointer model could work without distinct pointer classes, due to different pointer sizes and the requirements in the standard for round-tripping. If you generalize to multiple address spaces and allow for the different pointer classes to have the same size, it's a different story. Examples of platform quirks that could then apply while still supporting the standard language include: minicomputers with different pointer encodings for byte and word types, platforms with separate memory spaces for code+constants and data, and platforms with segment descriptors that can allocate multi-segment objects with interleaved segments (80286). I was under the impression that these were included in the platforms responsible for C and C++'s more esoteric pointer restrictions. 
For startup performance, you may *want* Os, though it depends on the size of the binary. You could add a flag "loop 100,000 times over initialization code" which is set for profiling.
You should probably add the contents of your post here to the repo as a README. :-]
This is why I always memory map files.
Stuff like std::vector&lt;bool&gt; out ; std::ranges::transform( persons, back_inserter( out ) , []( auto age ) { return age &lt; 40 ; } , &amp;Person::age ) ; It already is snowballing to borders of 'crazy'. Add some sfinae too, maybe declare interface twice (pimpl).. I am not even talking about code readability, but that is a lost cause long ago despite that we read code way more than we write. This kind of stuff spawns "orthodox c++" and the like.
&gt; Of course if anew OS version changes its behavior/API you have to adapt your code. No, this is not a given. Properly written programs stay within the stable public API and don't break when non-public internal structures are updated. If the OS doesn't provide enough public facilities to safely manually allocate thread stacks, it means _the OS does not support manually allocating thread stacks_.
I haven't read the book, but I can't think of any good reason to use mt19937, other than everybody else uses it. It has many known problems, it's difficult to initialize correctly, requires lots of memory, and is relatively slow. See [PractRand's description](http://pracrand.sourceforge.net/RNG_engines.txt). There are much better rngs available, though bit in the standard. I personally always use `sfc64` which is extremely fast, produces better randomness, and is easy to initialize. I have my implementation [here](https://github.com/martinus/map_benchmark/blob/master/src/app/sfc64.h), and the original implementation and analysis is part of [PractRand](http://pracrand.sourceforge.net/). Another good alternative is [PCG](http://www.pcg-random.org/) or [xoshiro256**](http://xoshiro.di.unimi.it/) (but not the unfortunately relatively widely used [xorshift128+](https://lemire.me/blog/2017/09/08/the-xorshift128-random-number-generator-fails-bigcrush/)) 
True, but this problem is also handled quite well with the auto keyword in modern C++. I now tend to spell out everything in the places that matter- function parameters, member declarations and such, also for special cases where i want to make clear which type is being used. verywhere else i use auto now. It is a bit weird in the beginning, but now im quite happy with this approach, as i can focus on the important parts of the code!
According to https://groups.google.com/a/isocpp.org/d/msgid/sg14/a1f4d104-339f-4a15-a7c4-f0226eb75d9d%40isocpp.org?utm_medium=email&amp;utm_source=footer That is some Google Group "feature". Maybe std-proposals should switch as well.
https://en.cppreference.com/w/cpp/string/basic_string/operator_basic_string_view
Are these results cached? Are they allowed to change during the execution of the program?
I don't think that sort of facility should go in the standard library; there are lots of different ways to do it that are better explored as separate projects.
This list: https://github.com/nothings/single_file_libs#files--filenames
My builds are routinely IO bound if project is located on HDD. Moving source files and location for outputs to SSD helps immensely and turns build bottleneck to CPU. 
&gt; Properly written programs stay within the stable public API and don't break when non-public internal structures are updated Bit TIB is not part a non-public internal API/structure ... it is officially documented in MSDN, unforutnately MS decided only to document a part of TIB, not the full structure. If you take a look at MSDN you get examples written by MS that show how you access TIB.
This flag doesn't work for me. I'm using 2017 version 15.9.5, but I get "fatal error C1007: unrecognized flag '-reportTime' in 'c1xx'". Any idea why, anyone?
Maybe on the first build after reboot it could be IO bound, but after first build everything is usually in the cache. All sources are rarely larger that 1 GB, they should fit in the RAM easily. Though some compilers (like gcc) like to use a lot of RAM for compiling, possibly spoiling the cache. Anyway, having a lot of RAM fixes everything).
You would write the above code rather like this: `for (const Person&amp; p : persons) if (p.age &lt; 40) out.push_back(p);` unless you want to toy with projections and ranges. Nothing prevents you to write clear code in C++. Actually, obfuscating code is a discipline that [C programmers are better at](https://www.ioccc.org/), even if their language is a lot simpler.
&gt; I can't think of how a classic near/far pointer model could work without distinct pointer classes, In compilers with the `near`, `far`, and `huge` keywords, these pointers were indeed distinct - but as mentioned, these are all compiler extensions. I've never seen fully compliant compiler that is able to somehow offer users support for handling these different types of pointers in a compliant way.
`read` function open file two times: first to determine file size in `size` function, second to actually read file content in `Reader`. Between this two actions file can be modified / replaced / updated. For details see [this comment by 14ned from other post](https://www.reddit.com/r/cpp/comments/ai861h/stdfilesystemfile_size_advantages_and_differences/eem5v1e/)
I also implemented a proposed C++ paper - it was the multidimensional `array_view` :( (The sad face is because `array_view` became `span` - which is only single-dimensional. But I still actually need a multi-dimensional array view, so...)
OOF, reddit does support markdown, are you using the redesign? That might explain it, the redesign is a POS that changes a lot of things. Also, if you want to use whatever another compiler uses, you have to either choose to do it their way, or roll your own. In theory, you can do getopt https://www.gnu.org/software/libc/manual/html_node/Getopt.htmland have that parse everything for you.... but that doesn't work everywhere unless you roll getopt with your thing.
Yeah you have to click a button to switch to markdown editor :-D
Wow. That‚Äôs a pretty ridiculous situation. I sure hope there‚Äôs a better explanation than the one that‚Äôs been provided by google groups support.
The regulars on there have been enduring this problem for some weeks now. Essentially Google have decided to, without announcement, no longer support Google Groups on large groups such as std-proposals. Instead of a simple statement of no support, they instead have it failing randomly. Which is so very super helpful of them. Last night we got a decision from the isocpp leadership that Google Groups will be replaced with MailMan. Migration is expected to take some weeks, but in the meantime, we are trialling making people administrators to see if they are also spam banned. The test subject is my good self, if it works with me, it may be a viable temporary stopgap for the well known frequent participants there until the MailMan migration is completed. We'll see how it goes. If you can't get a message through to std-proposals, try emailing it to me at nialldouglas14@gmail.com, and I'll try using my admin powers on it. Sorry for the disruption.
I feel like that little box on the right should have been the first paragraph of the article - I was very confused at first what on earth the article was talking about. "Is this talking about some new language feature? A proposal? Nonsense? Not a clue."
Oh..... &amp;#x200B; Thank you!
You should add a license to you project, otherwise it's not clear under which conditions your code can be reused.
[Docopt](http://docopt.org) is a standardized form of cmd line which works in a reverse format to what you asked for. Instead of generating a help output based on how you configure the parser, it uses a provided help output to configure the parser. Now I don't know if it supports some of that multiline stuff you mentioned, but it's worth a look.
Check out Clara [https://github.com/catchorg/Clara](https://github.com/catchorg/Clara) its awsome! If generated code size matters then checkout "The Lean Mean C++ Option parser": [https://sourceforge.net/projects/optionparser/](https://sourceforge.net/projects/optionparser/)
Or: std::vector&lt;bool&gt; out = persons | view::transform(&amp;Person::age) | view::transform([](auto age) { return age &lt; 40; }) | to&lt;std::vector&gt;; Or really just one: std::vector&lt;bool&gt; out = persons | view::transform([](auto&amp; p) { return p.age &lt; 40; }) | to&lt;std::vector&gt;;
No no you can totally do your timing entirely with C++ libraries (At least since std::chrono came around) if you want! And if you don't run it each time you build and compare the results against previous runs, how do you know if your changes are making performance better or worse?
Thanks for the feedback! Error handling does need work, but I'm not sure what to do in case of failure. environ_ gets initialized on program start-up. If one of the APIs fail for lack of memory, is it even worth handling and continue? I used _wputenv() in setvar() because I have a string in the stack that I know is in the correct format, so I save a conversion.
What results?
it seems like your lock free Q does not have any synchronization at all? this is straight undefined behavior. take a look at `&lt;atomic&gt;`
Yeah, I have been running it on Intel processors which are sequentially consistent. It runs fine there. But good observation. I will add memory barriers later. &amp;#x200B;
Constructors don't violate the rule of zero. Regardless, I still find the first snippet the most readable.
RemindMe! 4 Months
I will be messaging you on [**2019-05-23 15:00:48 UTC**](http://www.wolframalpha.com/input/?i=2019-05-23 15:00:48 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/aidyq4/whats_the_best_looking_ide/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/aidyq4/whats_the_best_looking_ide/]%0A%0ARemindMe! 4 Months) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
IIRC, intel (and i asume you mean intel x86) is not sequential consistent. it just uses acquire and release semantics. nevertheless, the compiler is the one emitting the machine code from your source and it may reorder your instructions too.
This is ridiculous. There are 1100 people on that list, hardly huge, and I imagine there's very little turnover on it. Surely it'd be less work to leave it alone than to figure out a way to break it so people would go away! (And how passive aggressive is that? "Let's secretly break these groups so people will get confused and leave. After all, their time and their emails are basically valueless!")
&gt; which is now possible in an implementation file Is it a proposed feature that I missed? With all compilers I tried I am getting something like non-static data member declared with placeholder 'auto'
Ah, thanks for the critical eye! I don't discard line endings, so an empty line has at least one character in it. "Empty string" has to mean "end of file" - "`fread` got zero characters. (I'm going to write tests for these cases, though, to make sure my claims are true.) I developed this on a Mac, so it got at least some Mac testing! You are correct that it won't work on pre-OS/X Macs... I'll also test this more aggressively. I am aware of the error from `fclose`, but I'm not quite sure what to do with it. Most of the time this would happen in the destructor, and even if you are using exceptions, you shouldn't be throwing in the destructor. I can't "print" the error, because "print" it where? I'll return a value from `close()` so if you want to close something and get an error, that will be useful. And I'll add the `noexcept`s. /me slaps self in head, I knew that from Scott Meyers. Thanks again!
Yes, that's my bad. auto would only be possible to use for inline variables, not class members.
Ah, hmm, very interesting point! You are definitely right. This is really designed for "95% of uses" and I'm not sure that "handling the case where multiple processes or threads are reading a file at once" is in that case. I'm thinking I'll put comments warning about this behavior rather than changing the code. What do you think?
&gt; However, when we're inside a header file, we should not be utilising `using namespace` if it can at all be avoided. But remember _why_ that rule exists: avoiding ambiguities. In this regard, `literal` namespaces are special ‚Äì they are guaranteed to only contain symbols that are themselves guaranteed to only be \[legally\] defined by the standard library, due to not beginning with an underscore. Consequently you can `using` these particular namespaces guilt-free without the potential of running afoul of the reason behind this rule. TL;DR: `using namespace std::string_literals;` in a header is just fine.
Do you have any plans to add a similar implementation to libc++ as well?
But readers may be confused if `"str"s` works, but only when a seemingly unrelated header is included.
Hi Sohan, I would be interested to learn more about your experience. I have an opening in Toronto and think you might be a fit. Check more here - [https://stackraft.com/job/Savormetrics/Full-Stack-Software-Developer-Toronto-Canada-34](https://stackraft.com/job/Savormetrics/Full-Stack-Software-Developer-Toronto-Canada-34) Let me know if interested.
Have you considered using iifes? inline auto name = [] { using namespace std::literals; return "IAmGroot"s; }(); inline auto x = [] { using namespace std::chrono; return 962ns; }(); 
I was thinking about introducing namespace specifier to expressions: auto lit = std::"hello"sv; auto dur = std::(5min + 14s); What do you think?
Which seems to be the main stated reason behind [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file),
Agreed that `std::literals` is a special case namespace, as would any user-created namespace that behaved in a similar manner for a given codebase be. But - how do we enforce that in static analysis? It feels fragile.
Yes, that is exactly the plan. libstdc++ too if they're willing but I'm less certain about that.
Iifes are certainly the flavour of the year, and would work. But the line lengths do seem overly long, and the type info sufficiently hidden, that I'm not a fan for this use case.
It'd certainly address the issue. I hadn't considered that angle.
Why at the front and not closer to the name `"hello"std::sv`? 
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/aj1cs5/hiring_full_stack_c_dev_canada/eeryirq/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
But size() would still be O(N) every time. Seems like that should not be the case for a 'mostly immutable' object.
I don't think I understand your objection to inline auto name = std::string{"IAmGroot"}; Why are suffixes so important for this use case?
Err .. typically, your OS will not load the entire executable in memory directly when you start it. I can imagine that optimization for size can help in certain cases, but often the far suboptimal code you get in return for it is definitely not worth it 
I think it's well known that std::vector is cache friendly. But what about other STL containers? Are their implementations done in contiguous memory as well? For example, does a std::map&lt;A,B&gt; store data in a contiguous region of A,B pairs?
Thank you for the feedback. I tried building on what the paper already described, but I guess I should make an introductory post.
That would make sense.
No, the requirements of the STL mean that this doesn't happen, although there are data structures that will make sure they only use contiguous memory. 
Which requirements do you mean?
I have to agree. Declaring stuff in headers in the global namespace ought to be vanishingly rare. If you're inside your own namespace, then you can bind in namespace literals to enable ADL literal discovery without ill consequence. So I don't find the above an issue in the real world. I might add also that one ought to avoid ADL whenever possible in header files. It has non linear effects on build times, which is bad. The first example in the OP's question is hash table lookup, so constant time. Much better on build times. Better choice all round methinks.
"Reference-Counted"
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/aj2alv/best_resources_to_learn_cpp_coming_from_python/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
you are looking for boost::flat_map or one of the various implementations of the same concept. `std::map` can't be contiguous because random insertion is mandated to be in `O(log n)` (which means that the data structure behind has to be more-or-less a tree).
I was thinking about that, but it looks odd. And doesn‚Äôt allow the std::(expr) case. Also having context specifier in front of parenthesis will allow things like specifiing which binary operator you want to use.
How often do you need to know a number of environmental variabled?
Yeah, I just can't think of ones that I like. `box` almost works since it's also a verb, but C++ doesn't play well with that. Anything for `rc` I can think of feels too disconnected from the type name. The situation that "feels" better to me just doesn't work with aliases because you need new static methods, e.g. `box&lt;T&gt;::make&lt;Args...&gt;(...)` or the like.
Also std::42hour looks more natural than 42std::hour.
I disagree with you there. It's `hour` that needs qualifying, but it looks like we're qualifying `42hour` instead (nit: it's really just `h`). But then "natural" is always going to be subjective. 
&gt; All Associative Containers: The insert and emplace members shall not affect the validity of iterators and references to the container [26.2.6/9] This requirement means they have to have some sort of non-contiguous bucket structure. With a vector, if you try to insert past capacity the vector reallocates and all iterators are invalidated. With maps, it you try to insert past capacity it simply allocates more data *somewhere* instead of reallocating the whole structure. This ensures all iterators remain valid. [Stack Overflow source](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules)
Ah, they're not, I should have mentioned that maybe. This is why I demonstrated how to implement a map in a cache friendly way on top of vector. 
If some code uses that feature, it should just include those headers and using declarations itself. It shouldn't depend on them being in another header. 
Just a heads up, your link to tinyrefl is broken. 
The multi-dimensional version is mdspan[1], which also has a reference implementation[2]. It looks like mdspan is intended to be part of Library Fundamentals TS v3[3], so I'm not sure how soon it might become part of the official standard. [1] http://wg21.link/p0009 [2] https://github.com/ORNL/cpp-proposals-pub/tree/master/P0009/reference-implementation [3] https://issues.isocpp.org/show_bug.cgi?id=80
Even if it may look unfamiliar at first sight, I certainly like this syntax to qualify names in an expression. Go for it!
Why the name "exception"? Exception is an existing concept, and it doesn't seem to me that this proposed change has anything in common with it.
I tried to skim through the slides, and it seems your set/map is similar to Loki's AssocVector? I do like AssocVector, it's the best at in-order iteration, however is has some complexity/cache issues: 1. The layout is actually adversarial for search, because `binary_search` will jump all over the memory. Consider using an Eytzinger layout instead (breadth-first order) for better cache behavior.^1 2. Insertion and Deletion now take O(N); only O(log N) comparisons, but in average N/2 elements have to be shuffled. Note that Eytzinger layout also suffers from this; while it can regularly get away with O(log N) moves during insertion/deletion, if you have to rebalance the whole tree, it's O(N) moves. ^1 *Or you can deep dive into [Array Layouts for Comparison Based Searching (PDF)](https://arxiv.org/ftp/arxiv/papers/1509/1509.05053.pdf).*
Thanks, I get it now.
How about a `using` declaration for each udl you want to pull into scope: #include &lt;string&gt; using std::string_literals::operator "" s; auto hi = "hello"s; [https://godbolt.org/z/2grFcZ](https://godbolt.org/z/2grFcZ) It works (not sure how exactly, as the udl name names an overload set). It's more precise / explicit than a blanket `using namespace std::whatever;` so is more acceptable in a header - the udl name appears so it is searchable too. In the case of string / string\_view there's only a single literal suffix. For libs like std::chrono which have more literals, a using declaration lets you pick and choose. &amp;#x200B;
Yes, I agree, I just didn't know what else to call it. I also think the idea behind exceptions is typically that you can recover from them at the calling side, which isn't the case for what I propose here. The only thing in common (the way I thought of it) is that they can be written in a \`catch\`-like way.
&gt; For the purposes of AAA, and/or to avoid needless temporaries, AAA is a means to an end (ie readability? write-ability?), not an end itself. Personally, I question its value - basically it often improves writeability at the cost of readability. So let's throw AAA under the bus in this case. Now, tell me about these temporaries...? Basically, what's wrong with your first version: inline int value{42}; inline std::chrono::nanoseconds time_since_start{ 962ULL }; inline std::string name{ "IAmGroot" }; 
Done. Thanks. Vladimir.
Yes, there are certainly some optimizations that could be done.
How about a compile-time errno? ;)
Actually, that would be pretty sweet as well ;) But then we also need to actually check the errno after every function call, and we all know how that usually goes...
&gt; Error handling does need work, but I'm not sure what to do in case of failure. That's why I said it's under-specified. Most of the functions seem to be specified as `noexcept`, except for `arguments::at()` (sure), `variable::operator=`, `variable::split()` and some overloads of `environment::operator[]` (why?). I'd expect `variable::operator=` to throw on failure, or at least provide an alternative `set()` that returns a `bool`, or whatever. Also, remember that this isn't just about error handling. Your library will currently terminate the program any time it's given a string with an incorrect encoding, which is not exactly fun. &gt; environ_ gets initialized on program start-up. If one of the APIs fail for lack of memory, is it even worth handling and continue? Sure. The calls could fail for any reason, not just memory. If I don't actually use these classes in my code, I don't want my program to crash because they can't initialize. In fact, they should initialize on first use and behave predictably if they failed to do so, which is pretty easy to do if you're already throwing on failure to set a variable, you just have to behave as if the environment was empty. &gt; I used _wputenv() in setvar() because I have a string in the stack that I know is in the correct format, so I save a conversion. I would not consider the `_s` versions to be "alternatives" that can be mixed with the regular API, depending on the behaviour you need. I'd say pick one or the other, but I may be incorrect in my assessment. &gt; Edit: It's not thread safe, no. But you were to manipulate other containers in multiple threads you would also need to sync it your self. Making containers thread-safe is typically at the wrong granularity because you usually need _several_ operations to be done while holding a lock (find/modify/add, etc.). I also find that the vast majority of my uses of containers do not require synchronization and I'd be pretty unhappy if they assumed otherwise. The main problem with your implementation not being thread-safe is that _it's hidden_. The interface feels thread-safe, as you're creating an `environment` object on the stack, but all objects are actually sharing a back-end that's _not_ thread-safe. This, to me, would be unacceptable in any library. If `environment` is expected to be on the stack, per-thread instances should be safe (shared, cross-thread instances don't have to be). If you intend for the user to create one global `environment` and use it everywhere, then these functions should be `static`, free, in a namespace, or whatever. 
&gt; it's in the STL That's the only reason, but pretty big one. Standard library needs a better algorithm, and there was some talk about inclusion of a modern algorithm, but it was dismissed citing "lack of experience" and "not time-proven" as reasons, IIRC. 
Fair point, I suppose. And O(N) might not be horrible given a realistic N. 
lol leaking
&gt; Yes, exactly. I don't want a library touching my command line parameters in a way I can't easily control without modifying their code if you're worried that a library is going to fall back to mutate the system arguments w/o giving the user a way override that behavior, then that's a **shit** library and you should stop using it. &gt; Indeed, without such you wouldn't be able to implement this as a library independent of the toolchain. I take issue with them for the same reason, though they're less likely to be used than something in std what?! Then what's the point of a standard library? We should not care about the implementation as long as the interface and behavior are consistent.
Regarding cxxopts I recently filed an issue to address #1 (and I believe #3). Maintainer seemed receptive, see here: https://github.com/jarro2783/cxxopts/issues/158
I also have my own command line parsing library which I think meets your criteria. Curious if you have any feedback. https://github.com/Qartar/qflags
&gt; Then what's the point of a standard library? To standardize an interface to good, useful features that people should be using.
Question. You say: &gt; We still cannot use it exactly the way we want, since the message of a static\_assert must be a string literal, so we can‚Äôt dynamically display the types that are being passed as U and T. But looking at the compiler explorer output: &lt;source&gt;:11:7: error: static_assert failed due to requirement 'std::is_base_of&lt;Bottom, Middle&gt;::value' "It's not Derived!" static_assert(std::is_base_of&lt;T, U&gt;::value, "It's not Derived!"); However, this does give the types. Perhaps not in the static\_assert's error message itself, but it does in the compiler's error message. &gt; It still gives us two error messages ([see this implementation on Compiler Explorer](https://godbolt.org/z/1GzJ-8)): first the one about the pointer, which is triggered by the heldPtr initialization, and then the static\_assert message. While I agree this is mildly irritating, I am not sure this is a real problem though. It could be solved by allowing the compiler to ignore attempting to compile the rest of that code block is all the static\_asserts fail. Though this might get dangerous if there is an actual compile error in the code that has nothing to do with the static\_asserts. Note: I do agree the pages of errors for most template errors is annoying and needs to be fixed, I just do not agree that having two error messages for the same error is more than a mild issue.
Depends. Small executables benefit - wrappers and such. The OS *does* have to map and read any data being executed. Smaller code loads faster, and also is nicer on the icache
Okay I meant how the conversion operator looks like - not how to actually use it (which is trivial). My question was basically whether that conversion operator costs a pointer initialisation and stack-allocation of the size variable, but my guess would be the answer is yes, everywhere where there is a string_view used, it needs to be constructed, which means creating an instance of the class string_view which assigns the pointer and stack-allocates the size variable.
&gt; The concept is that you may be operating only with the base classes of the system and yet you want to be able to extract all the object properties, for that you need a virtual function at its base (as far as I know). You can do this purely opt-in. Especially as you shouldn't even be dealing with "base classes" in many cases. I've always used interfaces with free functions, e.g. `get_type_info(T&amp;&amp; obj)`. You can have that call a virtual function if `T` has it (using SFINAE overloads or `if constexpr` or the like) and just forward to a `get_type_info&lt;T&gt;()` otherwise which returns the static type info for a type. You then get full reflection capabilities for any type that needs it (even if it can't inherit anything, e.g. math types, STL types, built-ins, etc.) and can gracefully opt-in to virtual type info for the cases where you need it (which should be relatively rare if you're not building your game code like it's the 90s).
compile\_error? compile\_info? compile\_message? 
Thanks for the links! Not sure why I ended up browsing Trilinos, I guess that's part of the problem of the bad presentation and documentation. Documentation *is* a paid effort, it pays off and back multiple times for every user and contributor to the library, including internally in the lab. If I was a new PhD student or postdoc starting in that lab, I would probably look at that library and say "no thanks", and if they made me use it, it would take me weeks and months to get started with it. That's all lost time and money for the whole lab and all its resources. I had a look at [this](https://github.com/trilinos/Trilinos/blob/master/packages/rol/example/simple-eq-constr/example_01.cpp). Oh my... I am sticking to Ceres, no thanks to that. :-)
&gt; If writing regular, non-library code, it‚Äôs likely you never need to write std::move. Instead, as long as your types have move constructors, the compiler will find the best places to attempt moves. That's not really true. If you have a constuctor that initialized a string member from a parameter (pretty common) you probably want to take it by value and move it into the member Foo(std::string name) : m_name(std::move(name)) { ... } Also you may want to move into the last use of a variable Foo a; f(a); g(a); h(a); // might have wanted h(std::move(a)); return; ----- R-value references aren't that scary. In broad strokes: * an r-value reference `T&amp;&amp;` is like a normal reference, but it indicates that its referent is made available for moving from (ie. feel free to destructively modify it) * to make an operand available for moving from, you use `std::move(x)`. `f(std::move(x))` makes `x` available for moving from to `f` if `f` wants it. Temporaries are automatically available for moving from, you don't need to `std::move` them. * to consume an r-value reference, you take a `T&amp;&amp;` parameter. If you don't give any other overload, this forces the caller to make their argument available from moving from. If there are other overloads, this one will be preferred if the caller did make the argument available for moving from. * in the body of a function that took a parameter `T&amp;&amp; x`, the name `x` is _not_ an r-value reference. If you want it to be available for moving from to another function, you need to `std::move` it again. This is why forwarding references have to exist.
Thanks for pointing out
Is the reason the constructor takes the string by value instead of an rvalue reference because this way it supports both cases? If the caller calls std::move it will be moved, otherwise, it is copied and the *copy* is "moved from" as part of the constructor?
This is the best description of rvalue references I've ever read. Thanks!
I find myself writing these types of aliases when I want value semantics + polymorphism. Recently I discovered Boost Dyno (and a bunch of similar libraries) which seems to be a much better way of doing that kind of thing. https://github.com/ldionne/dyno
Yes. You could write a `Foo(std::string&amp;&amp; name)` and a `Foo(std::string const&amp; name)` to get the same effect and even save a move construction in the process, but you'd have to write double the code. And as soon as you have multiple arguments that might be moved or copied you'd end up in a complete mess. Taking objects by value reduces the code, works with both move and copy and works nicely when multiple arguments are involved. 
I'm all for better compile time errors but if it means sacrificing compile times just for a better error then I might end up stabbing someone. Sacrificing compile times to catch an error at compile time vs runtime... that's more of a gray area. Sometimes I'm ok with it, sometimes you make another build that the test server will run so you don't pay the time cost on every incremental change.
**1** works fine, my README for argagg does say explicitly &gt; Short options can be provided arguments with or without whitespace delimiters &gt; &gt; -I /usr/local/include and -I/usr/local/include are equally valid **2** as you want it (obtaining an `std::vector&lt;std::string&gt;` from an option's results) is not directly supported, but you can access all of the results for an option as an `std::vector&lt;argagg::option_result&gt;` which can be quickly converted to an `std::vector&lt;std::string&gt;`: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L73-L77 - https://vietjtnguyen.github.io/argagg/latest/structargagg_1_1option__results.html#a5371fd527139e2a0c9036c8230f4dc9c **3** works fine in my testing: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L6-L21 - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L38-L39 - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L79-L83 **6** is mostly manual by design unfortunately, but there is something for printing the options in a fairly standard format: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L68-L70 **7** is also by design unfortunately. I don't want to make assumptions on how help is handled and how the program exits. Hopefully this example covers your bases: https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp
**1** works fine, my README for argagg does say explicitly &gt; Short options can be provided arguments with or without whitespace delimiters &gt; &gt; -I /usr/local/include and -I/usr/local/include are equally valid **2** as you want it (obtaining an `std::vector&lt;std::string&gt;` from an option's results) is not directly supported, but you can access all of the results for an option as an `std::vector&lt;argagg::option_result&gt;` which can be quickly converted to an `std::vector&lt;std::string&gt;`: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L73-L77 - https://vietjtnguyen.github.io/argagg/latest/structargagg_1_1option__results.html#a5371fd527139e2a0c9036c8230f4dc9c **3** works fine in my testing: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L6-L21 - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L38-L39 - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L79-L83 **6** is mostly manual by design unfortunately, but there is something for printing the options in a fairly standard format: - https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp#L68-L70 **7** is also by design unfortunately. I don't want to make assumptions on how help is handled and how the program exits. Hopefully this example covers your bases: https://github.com/vietjtnguyen/argagg/blob/dev-gcc-like-example/examples/gcc_like.cpp
where can I download it?
:(
I'll go with it!
The only trouble I've run into is a class that can either allocate on the heap or be passed a pointer to a stack array buffer. As long as the stack array buffer objects aren't allowed to leave scope...
&gt; Okay I meant how the conversion operator looks like It's right at the top of the page ‚Äì `operator std::basic_string_view&lt;CharT, Traits&gt;() const noexcept;`
&gt;Also global scope operator+ how to allow the compiler to choose an rvalue argument? A common thing I've seen in cases like this is to implement `operator+=` and then use that: std::string&amp; operator+=(std::string&amp;, const std::string); std::string operator+(const std::string&amp; l, const std::string&amp; r) { std::string copy = l; l += r; return copy; } std::string operator+(std::string&amp;&amp; l, const std::string&amp; r) { l += r; return l; } Or, you can save yourself the code duplication: // note that l is now passed by value, not by reference std::string operator+(std::string l, const std::string&amp; r) { l += r; return l; }
On debian/ubuntu and derivatives do `apt-get install ed`.
I've written [CLP](https://gitlab.com/FJW/clp), which should provide most of what you want except for 3) which only works with the long-form of arguments. I consider it's API to be very modern, but I should point out that it works better with fewer options as the intended way to use it is `auto [arg0, arg1, ...] = parser.parse(argc, argv);` which may become inconvenient if there are too many options.
Should could conceivably write it as `template&lt;class T&gt; Foo(T&amp;&amp; name)` and forward it to the member variable: `m_name(std::forward&lt;T&gt;(name))`.
std::string isn't a good example for pass by value. Commonly most string are short and then this can be slower. In that case move and copy are as expansive and passing by value will in many cases cause two moves or a move and a copy. Whereas passing by reference will just be one copy: Passing by value: rvalue: creating in place and **move** by callee moved lvalue: **move** by caller and **move** by callee lvalue : **copy** by caller and **move** by callee Passed by reference: in all cases: copy by callee BTW: Core Guidelines never recommends to use pass by value for cheap to move types: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-conventional](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-conventional) &amp;#x200B;
You don't need to write `std::ranges::less`. Since it's in the default template argument, you can simply use `{}` ``` sort( files, {}, &amp;file_t::name ) ; ```
&gt; Eytzinger I was going to say "huh, I never heard it called that before", and then I realized you were citing precedent from *1590* You can ameliorate the complexity back to O(log N) by storing a list of extra entries and then only re-sorting after that list gets too big (or, likely, if you perform too many lookups).
In `std::string operator+(std::string&amp;&amp; l, const std::string&amp; r)`, your `return l;` doesn't get an automatic move. N4800 10.9.5 [class.copy.elision]/3.1: "If the expression in a return statement (8.6.3) is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression". This means that local/parameter objects are automatically moved from, but not reference parameters.
By the time you properly constrain `T` so that this does not take precedence over the copy/move c'tors for non-const lvalues, anything resembling succinctness is long gone.
maps/sets in the std lib are tree based and allocated on the heap as individual nodes. Since, I think c++ 17, you can use this property to extract/insert a node from one container to another tree based container without a new allocation.
&gt; Medium uses browser cookies to give you the best possible experience. To make Medium work, we log user data and share it with processors. To use Medium, you must agree to our Privacy Policy, including cookie policy. No.
You can also use a pooling allocator to keep the nodes close together in memory ‚Äì `std::pmr::map` and `&lt;memory_resource&gt;` make this quite easy.
Clang says [about the &amp;&amp;-case]: warning : local variable 'l' will be copied despite being returned by name [-Wreturn-std-move] Clang says nothing if `return std::move ( l );`
[removed]
In debug mode I have implemented a "cxout" that i can &lt;&lt; into, then on execution all types I have &lt;&lt; into cxout during compile is printed inside Visual Studio. In release builds the code disappear- it is often handy during development, I write a class and below I type: &amp;#x200B; TEST() { cxout &lt;&lt; std::conditional\_t&lt;true,int,float&gt;; }; &amp;#x200B; Then everytime I save changes the code inside TEST() will automatic execute, compile errors will be shown, static asserts fail- and if I run the program int will be printed. In the "scratchboard" I write code that test the feature I am currently implementing, so I get instant feedback on every save. The code will then become static asserts to "unit test feature freese" my code. Very handy when debugging compile time recursion :)
If that's the case, why are the literals in a namespace in the first place?
&gt; random insertion is mandated to be in O(log n) (which means that the data structure behind has to be more-or-less a tree). Welll... If you have to be strict about not allowing an "amortised" or an "expected" in the analysis, you could still have a hash map with tree-chaining, "incrementally" amortising resizes by building the next-biggest map "alongside" the real one...
&gt; Foo(std::string name) : m_name(std::move(name)) { ... } I don't really know r-values, so this might be a stupid question. But doesn't this mean that the string is always copied into the argument of the constructor, even when it is a temporary and could be moved? For example, when calling ```Foo(std::to_string(5))```, would it not first create a temporary string from the result of ```to_string()```, then copy this into the argument of ```Foo()```? Or is it moved even in this case?
Thanks :) I have to say that replacing `less` with `{}` looks really strange to me. It is shorter, but it communicates the meaning even `{}` than (a geeky pun?) spelling `less` out in the call. I guess it is a matter of getting used to, but this is one of the things I'm not sure I want to get used to unless this becomes the idiomatic way of passing in default arguments outside of `std::ranges`.
`std::exchange` already established it as an idiom, IMO, even if only in a way that most people probably won't notice.
&gt; Also you may want to move into the last use of a variable But try to find a way of restricting its scope. I've been bitten more than once by reusing a moved object past its "last" use.
I think it makes sense to put them in precompiled header in case of frequent usage. If there are ambiguities between frequently used literals it may get messy of course.
There was a discussion https://www.reddit.com/r/cpp/comments/8zlbmb/why_namespace_the_std_literals/?st=jrab441v&amp;sh=ff0525d9 And it seems to be not entirely obvious
I've made this comment before but I'll bet this resonates with many of you. Often times, when I get one of those pages-and-pages template errors, I won't even try to read the runes. I'll just look for the offending line number and then stare at it intensely until whatever sin I committed becomes clear :). 
This would still result in a temporary even in a move-move case, right? Or are compilers allowed to optimise that out (seems dangerous at a glance)?
So proofs are programs, even C++ ones! kudos. Nice proof of concept. 
Ah, good to know, thanks!
Ok you convinced me. I have added op-in as for your request. Loved your comment about the 90s... however, I disagree with it. There are many ways to do ECS, and virtual functions are pretty cheap these days too. But since you have a strong opinion about it... do you have any reference for an engine that you think is doing it right? Thanks again for your input, I appreciate your feedback. Let me know if you have any other ideas. Cheers. &amp;#x200B;
One question I‚Äôve had for a long time: Is `std::move`, and indeed are ‚Äúmove-semantics‚Äù, badly names? My understanding of the benefits of move-semantics are precisely that the actual bytes that represent your object do not get moved around in memory, and hence you see performance gains because the compiler is not issuing a lot of unnecessary load/store commands. Have I got this wrong? I can see the argument that conceptually you are ‚Äúmoving‚Äù an object from one variable name to another, but I find it unhelpful when trying to reason about what the program is doing.
Even the C++ Standard wording is doing it. I think it will become a norm in the future.
"Precompiled headers are no longer generated by default for C++ console and desktop apps" Intrigued as to the reasoning behind this change...
&gt; scary jargon &gt; memcpy What?
Do you have any goals to add functionality above and beyond dumping the sections? I always want to compare two objects with different build options and see changes in size etc.
Stupid question from someone who has not really used move semantics: Say I have an existing (not small) project where I do not have any move constructors or anything related to moves. What is the easiest way to find which objects benefit the most from move semantics? I mean obviously objects which get copied and could be moved but off hand I cannot remember/say where such things happen. Can I somehow see or profile where are my copy constructors invoked?
Has anyone actually had any success using the CMake integration? I tried it out again today in the new preview and it deadlocked the IDE three times in the space of about 15 minutes. Had to kill it in task manager. Ignoring stability, I still don't see what it adds compared to just running the Visual Studio generator out of process.
Author here :) I thought I'd removed this paragraph before publishing, clearly not! I've updated it now, and also linked to this comment further down. Thanks for the clarification
&gt; he vcpkg toolchain is automatically detected and enabled for CMake projects that are opened in the IDE once vcpkg integrate install has been run. This behavior can be turned off by specifying an empty toolchain file in CMakeSettings. Hallelujah
It's been working really stable for me at least. Though I do generate the initial cmake project out of process (so only updates to the CMake files are dealt with by VS). It's been working so well that I now default to cmake for VS projects.
Yes, I think a combination of those would be great. It was also brought to my attention that there was a related paper that suggests constexpr\_assert and constexpr\_trace: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0596r0.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0596r0.html) They don't cover exactly the same cases I write about, but it just shows that this topic is alive in the community!
&gt;std::exchange `std::exchange` is different, because the type of `{}` is of the same type as the first argument: `std::string to_process{"abcde"}; process(std::exchange(to_process, {}));` There is nothing in the call to `sort` that says what `{}` is. If someone believes that the default is `std::ranges::less_equal`, there'll be some time and some bugs before he realizes otherwise.
Fair points! Could you give an example of the dangerous behavior you expect? If the actual specific error is "caught" and then converted into a context specific message, wouldn't that still allow for other errors?
Sounds good, can you share a link to your class?
[https://imgur.com/a/SI3b5KZ](https://imgur.com/a/SI3b5KZ) looks like this, no VS plugin- just c++ code
Yes, important point. I had an interesting [discussion on Twitter, where it was pointed out to me that probably catching errors in the way I suggest would mean hooking into the AST during compilation](https://twitter.com/TartanLlama/status/1088171112217935874). I'm pretty sure this will not decrease compile times ;)
Either that, or ask the developers for help :)
my guess is that those templates are only really used by people learning the language and it just adds unnecessary complexity.
Because most people were deleting the stdafx.h and cpp that made up the precompiled header. On tiny toy projects it doesn't have a benefit, and on larger ones you have to only include in the PCH things which are used by a sizeable majority of cpp files, or it actually results in a _slower_ compile. Better just to leave it out by default for a cleaner start.
In a good business relationship you do not need the contract at all. In a bad one, you really do. In a large group you will have many good and bad actors. For the good actors it really does not matter and they won't change anything about how they act. For the bad actors, it's either a clear stick to keep them within line, or a written declaration they're unambiguously out of line &amp; deserve to be taken out of the group. You *need* a CoC.
it isnt really encapsulated to a single file- but i tried collecting the needed stuff, you may need to rem something out and include windows.h in namespace windows. &amp;#x200B; [https://pastebin.com/6isW4SKw](https://pastebin.com/6isW4SKw)
oh -and insert this macro before main: &amp;#x200B; CXOUT\_ int \_main( int argc, char\* argv\[\] ) { &amp;#x200B; everything is quite hackish- just for personal usage- but I have considered making static asserts that shows what was evaluated on assert fail, if it gets good I will share :)
\&gt; Also (at least for me) the increased verbosity they bring actually serves a purpose ‚Äì it better communicates what the code does. &amp;#x200B; That's the least convincing part of a good article. `projected_fn` is not a good name, because the function itself isn't projected at all, it's just applied to a projected argument, meaning it actually is a composed function. And `composed_fn` is obviously misleading when it describes the case of `f (a, g(b))` (even if you could argue that it is a `f(a)(g(b))` composition, but it is a special case). Besides, you don't really need this awkward `compose_fn` because the standard library already has a `std::transform_reduce` that handles the two steps separately (unless you really need to perform the accumulation in order, which is not the case with `std::reduce` and its declinations).
stumbled on your comment. i stared at your codesample but i dont get the following: why does the placement new (in the second example) end the lifetime of vec? why does it reuse the storage of s to begin with? i thought aligned storage is kinda implemented (or can be implemented) like the unsigned char array under the hood. can you give me some hints?
oh, forgot my anytype &amp;#x200B; struct anytype { constexpr anytype( ... ) noexcept {} template&lt; typename T &gt; constexpr operator T() const noexcept { struct faker final: public T { constexpr faker() noexcept : T(*this) {} }; return faker {}; } }; It also enables bypassing the "you cannot construct a lambda" thing. Just do a decltype on a lambda- and when construction it then give it an anytype{} in the constructor- now you can create lambdas from the type alone :)
Yes, the names can be improved. I'm open to suggestions. With unary functions, both `composed_fn` and `projected_fn` are implementations of function composition. With n-ary functions, they are not (though you guessed the reason why I named `composed_fn` like that). As for `transform_reduce`, it is a replacement for this particular example, `composed_fn` is a generally useful thing to have. P.S. If you want in-order `transform_reduce`, check out the most badly named algorithm of all -- `inner_product` -- zip + transform + accumulate in one :)
It works, but I don‚Äôt get autocompletion, even when exporting compile commands. I would have to generate a vcproj to be able to get that. So although it‚Äôs usable, not so ergonomic. 
Wow, thanks!
&gt;`inner_product` That doesn't sound like a bad name at all. A zip + transform + accumulate is exactly what an inner product in maths does!
IMO std::move should have been named rvalue_cast or so because it doesn't move anything
Almost daily, it's amazing. Added benefit of not littering the CMake files with instructions to add files to specific VS virtual folders, and the CMake Settings is much easier to use for user-specific settings / paths to libs, etc.
Not a multi-layered but i tried stacking up independently trained perceptrons [https://github.com/flouthoc/PerceptRon/blob/master/xor\_gate\_multiple\_perceptron.cpp](https://github.com/flouthoc/PerceptRon/blob/master/xor_gate_multiple_perceptron.cpp)
It's a bit different. As dodheim points out, compilers will not have trouble to disambiguate. It's only problematic for readers who are not familar with UDLs.
I guess for console apps I can see the reasoning but for "desktop apps" then surely that means including windows headers which I believe(d) PCH are beneficial?
Depends on how much of your app is UI - if the UI is mostly handled by a handful of files then it might not be.
As for names, I would keep `composed_fn` but use it for the first case: the first thing that comes to mind when talking about function composition is `f . g`, which accurately describes what `projected_fn` actually does. For the second case, I would suggest `multivariate_compose`: auto result = std::accumulate(first, last, init, multivariate_compose&lt;1&gt;(plus, &amp;file::size)); The template argument indicates which argument should be transformed before function application. With some nasty meta-programming, you should be able to make it variadic and therefore general: int three_sum(int a, int b, int c); auto fn = multivariate_compose&lt;1, 2&gt;(three_sum, square, cube); assert(fn(10, 10, 10) == 1110); `multivariate_compose&lt;N&gt;` is ugly and beginner-hostile but it's a corner-case (is it really "a generally useful thing to have" when you can simply write a lambda: auto result = std::accumulate(first, last, 0, [](auto init, const auto&amp; file) { return init + file.size; }); )?
All objects that internall allocate something on the heap (i.e. use new) *can* benefit from move semantics. Since if you know that something is moved, you do not have to allocate anymore, which is always faster. Typical example was the string example in the blog, but also reference counted objects, or classes using the pimpl idiom. The object that is being moved afterwards should be in /some/ defined state, so that you can e.g. assign another value to it. There are other blogs / discussions that explain this better than me, e.g.: https://stackoverflow.com/questions/3106110/what-are-move-semantics
I don't think so because what's important when invoking std::move is the notion that the object you applied it on will be "changed". rvalue_cast doesn't look like an operation that will change the variable, std::move does (it moved out of your variable it's content)
&gt;We've added basic support for OpenMP SIMD vectorization. This can be enabled with the new CL switch -openmp:experimental. This allows loops annotated with ‚Äú#pragma omp simd‚Äù to potentially be vectorized. Probably the most exciting part. I was lamenting the state of OpenMP in MSVC just a couple of days ago, but it looks like we might be getting proper OpenMP after all.
I you are getting this error: clang++: warning: unable to find a Visual Studio installation; try running Clang from a developer command prompt [-Wmsvc-not-found] u.cpp:1:10: fatal error: 'Windows.h' file not found #include &lt;Windows.h&gt; Copy your "C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\VC\Auxiliary\Build\Microsoft.VCToolsVersion.v142.default.txt" to "C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\VC\Auxiliary\Build\Microsoft.VCToolsVersion.default.txt". 
How big was the project you tried using it on? I haven't personally had any issues with lockups on small/medium projects, but it might be different with bigger projects. Or if you are writing really pathological CMakeLists.txt's. I haven't had issues with missing autocompletion either like another commenter mentioned.
I use it daily (vs 2017). Works great. There have been issues over the past year, but no more than I ran into with qt creator (windows and Mac) I use it with qt 5.12. Most of my issues revolve around trying to get static build of qt to link and run... now that is a pain in the ass.
Awesome list of improvements for cmake integration. I‚Äôll need to give it a try. When I open a vs 2017 cmakesettings.json with vs2019 preview 2 should I expect it to migrate over automatically? Or should I delete it and then open the cmakelists.tx to have vs generate a default one and then apply my customizations manually? For example I currently specify a tool chain file via cmake arguments.
sanitizers please...?
To avoid calculating the length of the string literal.
Does anyone know of a user voice issue we should all upvote?
you could diff the output of bloaty: [https://github.com/google/bloaty](https://github.com/google/bloaty)
I don't understand what this is demonstrating. Can you provide some kind of explanation? For instance, when I look at this declaration: /* Theorem compile_correct : forall e, progDenote (compile e) nil = Some (expDenote e :: nil). Abort. */ template &lt;typename e&gt; auto compile_correct(decltype(progDenote(compile(e())))) -&gt; Some&lt; stack&lt; expDenote(e()) &gt; &gt;; // Forward declared It's never instantiated, so I don't understand how it represents a theorem. 
The important point isn't that "You don't need to write `std::ranges::less`" - the important point is that `less` is a _type_, not an object. So you need to at least write `less{}` or `less()`.
Is this version stable for use?
I just checked - for my g++ 7.2.0 the exact same assembly is generated. But if you're concerned about that being guaranteed, consider the fact that the type of a string literal encodes the length of the array (including the nul terminator), so you could have a templated constructor for string_view that fixes that. template&lt;unsigned size&gt; void foo( char const (&amp;s)[size] ) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\n'; } int main() { foo( "Me!" ); Produces: void foo(const char (&amp;)[size]) [with unsigned int size = 4] 
I agree the paper is a bit optimistic about noexcept ATM, the tricky thing is that the paper is waiting on SG16 work. If we get unicode support in the standard we could get at least some of them to hold.
Yep that's what I meant :-) Okay, so each time a string_view is used/constructed, implicitly or explicitly, it does incur stack allocation of two of its member variables (data pointer and size_t (or whichever) for size). So it's basically not "free" yet probably negligible. Thanks!
Wow, hallelujah indeed o/ :-) Awesome! That means now it's really just click and open, no configuration needed whatsoever! (For the basic use case / regular usage at least).
Does that correspond to any particular OpenMP version? Or is it still basically OpenMP 2.0 (I believe it was?) plus SIMD now?
string_literals... a solution to a problem that never existed.
&gt; The CMake Settings Editor provides an alternative to CMakeSettings.json and provides some parity with CMakeGUI. &gt; Visual Studio can now open existing CMake caches generated by external tools, such as CMakeGUI, or customized meta-build systems. Wow, awesome stuff people!
user defined literals... a solution to a problem that never existed
How about implementing the C++17 standard already?
CMake improvements sounds awesome! Especially parts about interop with Linux development \(^-^)/
Works great except in situations where I change between Linux and Windows target. Then I lose intelisense and often an ability to build project on both platforms :p Maybe it is connected somehow to the way cmake is called. When I do it quickly enough I see mixed cmake parsing output from both targets at the same time.
As far as I can tell it is just "#pragma omp simd" on it's own. But I'm hoping that it's the start of better OpenMP support in the future.
It has supported C++17 for a while now... https://en.cppreference.com/w/cpp/compiler_support
Dangerous is probably not the right word. template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) : heldPtr(other.get()) { static_assert(std::is_base_of&lt;T, U&gt;::value, "It's not Derived!"); shred_ptr&lt;int&gt; a = make_shared&lt;int&gt;(2); } In the above, if the static assert fails and the compiler does not attempt to compile the rest of the function, it will ignore the misspelling of shared\_ptr. On the first compile, this would not get marked and so may force multiple compiles.
I think I would have gone with `std::steal`. Similar to borrow in Rust but more emotive!
Yes, gcc / clang are probably smart enough to optimise that specific case; I'd still expect a difference with msvc though. There's a problem with the templated ctor - it doesn't work. Just add a `const char*` overload (we do want to support C strings, don't we?). And even if we solve that with a darker template magic, there's one more problem: we don't want to include the null terminator, right? But not a big deal, perhaps we can just do `size - 1` and move on? Problem solved! Soon, however, we will inevitably discover that there are cases like `char buffer[256] = "123";` and `char buffer[] = {'1', '2', '3'};`, indistinguishable from string litrerals, and our simple optimisation gave birth to funny runtime bugs all over the codebase... Hmm, probably those string literals were invented for a reason after all.
The backend improvements look good! 1. \#pragma omp simd will fail with warning if it can't vectorize, so we can finally have guaranteed auto vectorization(assuming by warning they mean standard compiler warning)! 2. ob3 nice, I've seen MSVC fail at inlining quite often so that will be useful 3. Added SVMl which implements trig functions 4. Probably my favorite: Constant-folding and arithmetic simplifications for expressions using SIMD (vector) intrinsics, for both float and integer form. I wonder if it can translate mul/add combos into FMA now.
&gt; you have to only include in the PCH things which are used by a sizeable majority of cpp files, or it actually results in a slower compile. Hm... I would have thought you put in the PCH those things that very rarely change (e.g. the standard library headers, external libraries, and project headers that almost never change), so that they don't have to be parsed again. Does the compilation time increase so much w.r.t. the size of the PCH? i.e. so much that it is better to avoid putting things that are not that commonly used, even if they never change? (like 3rd-party library headers or some of the less popular std headers).
Yeah - it doesn't take _zero_ time to load, so if your PCH is massive it can actually be slower than not having a PCH.
You can check the value of the last char in a constexpr context. If someone wants to initialize a string_view from a char const [N] whose last element is zero and they want that byte included they can use either an array or the constructor that allows you to specify a size. 
```C++ string api_wrapper() { char buffer[256]; api_call(buffer, sizeof(buffer)); // say, it fills the first 4 bytes with "123\0" return buffer; // oops } ```
You don't want that, you want Clang++ to find lld-link.exe.
Of course it isn't zero :) I asked in case you (or somebody else) can give some insight on how it scaled. In other words, how it compares the extra time loading an extra typical header in the PCH (per TU) vs. the time parsing it. For instance, if the parsing is very slow compared to the extra loading time, it may be almost always worth to add the header in the PCH, even if you have a lot of TUs and only actually use the header once.
Two main thoughts I guess. The first is that returning a string by value in readline is pretty inefficient as it makes a heap allocation each time it returns it. Not very zero cost abstraction IMHO. A better interface would be to provide begin and end and hold a string buffer internally that's reused, so that you could iterate over all the lines in the file without a new heap allocation each time. The second is that it seems like the design could be cleaner. There's a couple of smells, namely use of protected data and the asymmetric design of the reader and writer functionality, and the slightly convoluted inheritance hierarchy. Maybe I'm missing something but I think that OpenerBase (and OpenerTraits) could be eliminated entirely, and reader and writer could both be implemented as mixins. enum class Mode { ... }; template &lt;Mode m, template &lt;typename&gt; class ... Mixins&gt; class Opener : public Mixins&lt;Opener&gt;... { /* stuff */ }; template &lt;class Derived&gt; class WriterMixin { ... }; template &lt;class Derived&gt; class ReaderMixin { ... }; using Reader = Opener&lt;Mode::read, ReaderMixin&gt;; using ReaderWriter = Opener&lt;Mode::readWrite, ReaderMixin, WriterMixin&gt;; Etc.
Good no nonsense report which gave me a sense of being there. Nice job.
Good point, But that still is very dependent on the order of node creation and depending on the size of the tree may not be effective. I guess if you created a new tree and inserted the new nodes in an optimal order(maybe order of iteration if the first was ordered by key) it could be better even
&gt; do you have any reference for an engine that you think is doing it right? In production with available source? No, sorry - the engines I've worked on are mostly all proprietary in-house things, and I don't pay much attention to open source engines as they're not really used in any shipping games I'd consider significant (and an engine with no real games is an unproven engine, no matter how great it looks on paper).
Yes, it can build vector FMA, use /fp:fast /arch:AVX2, the default is still assumed to be SSE2. There are a lot of other improvements in the optimizer, but we had to keep the release notes short... There will be a blog post closer to final release with a complete list of improvements, and likely another post focusing on these new vector expression optimizations. Thanks, Gratian, MSVC optimizer team
You're not touching the Objects. You're copying a pointer around and saying the old pointer is invalid. Its a shallow copy vs deep copy. You could do this already with a copy constructor but this could go wrong really easy. And whats a copy with leaving only some leftovers at its source? Imo a move.
It's a pain to only include it in some of your files though, because it #defines a massive amount of symbols... It's hard not to get some of your own symbols caught up in its renaming frenzy, but of course that means you need to include it everywhere for consistency.
Or you can use `size` from GNU or `llvm-size` from LLVM.
In our team's experience, for medium to large project, the benefits for managing a PCH file that correctly includes rarely-changed headers quickly outweigh any of the potential challenges in maintaining such a file. So if you're creating projects that are long-lived, we do recommend that you flip the default in the Windows Desktop Wizard and still create a PCH. I believe the scenario /u/TheThiefMaster is describing is when you end up with a header included in your PCH that you always end up changing. In that case, incremental builds will pay the price (time and I/O) of always regenerating the PCH. This is really an anti-pattern of PCH usage though. The reason for the recent project template change in VS is as /u/kelthalas hinted - we noticed a lot of usage for this template from folks that want to learn some language constructs or quickly want to experiment with a code snippet. These are not long-lived projects. So for those cases, PCH adds unnecessary complexity. &amp;#x200B;
Catching heisenbugs, great!
Hey /u/qartar, did it hang every time or it always came back after a while? Can you "Report a problem" in VS (Help &gt; Send Feedback &gt; Report a Problem) and then send me the link to the issue you created? My team would really like to investigate your issue. 
It shouldn't be necessary to generate the compile commands json. IntelliSense is expected to work as long as CMake successfully creates a cache. Can you file a DevCommunity ticket via Help &gt; Sned Feedback &gt; Report a problem for this issue?
I couldn't find one, so you should create a new one. Btw, we're taking suggestion at [https://developercommunity.visualstudio.com/spaces/62/c.html?type=idea](https://developercommunity.visualstudio.com/spaces/62/c.html?type=idea) rather than UserVoice now
That's great to hear. Thank you! And with Preview 2, editing CMake settings gets even easier: [https://blogs.msdn.microsoft.com/vcblog/2019/01/24/introducing-the-new-cmake-project-settings-ui/](https://blogs.msdn.microsoft.com/vcblog/2019/01/24/introducing-the-new-cmake-project-settings-ui/) 
&gt;When I open a vs 2017 cmakesettings.json with vs2019 preview 2 should I expect it to migrate over automatically? Or should I delete it and then open the cmakelists.tx to have vs generate a default one and then apply my customizations manually? For example I currently specify a tool chain file via cmake argument The CMakeSettings.json file is backward compatible so there is no need to delete it and there is no migration needed either. You should be able to just open a CMake project in VS 2019 and continue working on it. &amp;#x200B;
Cool! I hadn't thought of that angle. Thanks!
The issue comes from a particular std::string literal we generate in our sources. It's over 64Kbytes long. At that scale, the difference between the compiler evaluating the strlen portion of the std::string( char const* ) constructor, and calling the std::string( char const*, size_t ) with the size carried through from the char const[N] initial type, is measurable. Sure, it's a corner case, and it's probably fair to say that the correct solution to that issue is to wait for std::embed to make it's way into reality. I will also admit that the post is somewhat of a growl upon the theme of "this works 99% of the time, but for some reason breaks when we hit some new feature" (in this case inline variables).
I was a bit surprised that `*(bs-&gt;begin())` is a different type with a different value than `bs[0]`. I think I get why, but it raises a possible issue with big bitsets: https://en.cppreference.com/w/cpp/utility/bitset/to_ullong &gt; std::overflow_error if the value can not be represented in unsigned long long. There's no guarantees that `size_t` can represent the values being returned by your iterator. 
&gt; ‚ÄúThe Windows 8.1 SDK is no longer available -&gt; why??? It's quite an old version of the SDK. The only reason it shipped in VS 2017 is because it was the default SDK used by VS 2015 so it had a large customer base. Nowadays very few people still use it. Windows 10 SDK is backcompat with WinSDK 8.1 and can be used to target Windows 8.1 as well as Windows 7: [https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk). Do you have a specific scenario in which WinSDK 10 won't do for you? 
Yes, that's my experience. As soon as you include some windows headers in the project you are better off fully opting in to PCH. 
+1. Just use lld. `$ clang++ -fuse-ld=lld-link`
This is still a Preview for VS 2019, with a GA release ("general availability") coming later this year. If you run into any stability problems, lets us know and we will work on fixing them, ideally before the final release date. 
A great way to see a benefit from move semantics is by simply using std containers since they already implement their own move constructors and assignment operators. With vector for instance, whenever you see a constructor or assignment with a temporary vector on the right hand side, the move operation will fire automatically (unless the compiler can do it even faster through some other magic). You don‚Äôt have to implement move constructors or call std::move. You just get it for free. Another great case for applying the Rule of Zero. 
&gt; Added a new C++ exception handler __CxxFrameHandler4 that reduces exception handling metadata overhead by 66%. This provides up to a 15% total binary size improvement on binaries that use large amounts of C++ exception handling. Currently default off, try it out by passing ‚Äú/d2FH4‚Äù when compiling with cl.exe. Note that /d2FH4 is otherwise undocumented and unsupported long term. This is not currently supported on UWP apps as the UWP runtime does not have this feature yet. That's a fairly sizable gain oO
This is very wrong. C++ is a serious language. If you don't want to spend time studying this concept maybe you'll enjoy more some other language. There are plenty of languages that are not much slower but will take less of your time.
You're totally right on the chosen type, ShhTinyBanjoPurr! Thanks for the feedback!! I'll definitely enrich my implementation to cover cases where N exceeds an std::size_t max value. Regarding the type mismatch between *(bs-&gt;begin()) and bs[0], it must be said that bitset per-se is a convenience type to represent a set of unique... indices? bits? booleans?? ... it is a subject of opinions what the type of the elements should be. Probable each with its own justification. I chose to be an ordinal representing the bit number being set on (hence in my example with all odd bits on and all even off, dereferencing the iterator returns 1, 3, 5, ... Another implementation could have returned 0x02, 0x04, 0x08, 0x0B, 0x0F... (the powers of 2 being turned on). Another implementation, perhaps the most useless could have returned the values: false, true, false, true, ... (odd for the "set" part of "bitset" that it contains repeated values!) I chose ordinals, which can be easily mapped into powers of two with f(x) = 0x01 &lt;&lt; x I believe that possibly that trichotomy regarding how to implement a bitset iterator was the driver to provide neither üòÄ
I could have sworn I read somewhere that the 8.1 SDK was required to target windows 7. I had problems doing static builds of qt 5.12 and getting it to run on Windows 7 / 8.1. This might have had more to do with the configuration of my static build of qt 5.12 however switching to the 8.1 SDK when building qt resolved my issues
It is great to hear that Microsoft has not yet given up on OpenMP (I had already lost all hope) :-) OpenMP is still the easiest way to parallelize C/C++ programs and is the de facto standard in HPC. I would love to see more MSVC OpenMP improvements in the future! Supporting OpenMP 3.0 would already be a great improvement as OpenMP 3.0 adds task based parallelism and allows using unsigned variables in parallel for loops.
Stability's been an issue for me (issues filed for things that repro), and I think there's some further work to do on the UI (even with Preview 2.0, which is a _huge_ step in the right direction), but the CMake integration has been great from my PoV. Avoiding the VS generators does have benefits. For one, Ninja builds are just faster. For two, they're more consistent with how builds work on other platforms in Ninja or Make, and CMake config for complex projects requires less hacks and work-arounds for VS solutions that creep into projects using those. For three, it forces people to actually update the CMakeLists to alter the build, rather than mistakenly editing configuration or files in the generated solution. For four, it integrates smoothly with doing cross-platform builds and debugging inside Visual Studio. There's still some rough edges, though 2019 Preview 2 makes some large improvements. Mostly I just wish that there was a way to categorize and filter targets more easily. e.g. the Start dropdown shows every target in the project, even though only two of them in my case are actual executables that you can start. Little usability things like that; not showstoppers.
It's a Preview release. Consider it like any other product's Beta releases. It's stable enough for hobby/experimentation/testing, but you'd be unwise to rely on it for series or production work.
Vey nice QoL improvements, good job
The remaining features are: * Preprocessor overhaul (available but opt-in via a switch) * &lt;charconv&gt; to_chars() hexfloat shortest and precision, newly available in VS 2019 16.0 (I believe Preview 2, haven't confirmed) * &lt;charconv&gt; to_chars() decimal precision, i.e. the thing that behaves like printf() but way faster; I'm working on this now.
Is the indication that we will be getting OpenMP 4.X/5.X support in MSVC soon? 
Yes, but inner product is a narrow specific use-case of zip-map-reduce. When you see `inner_product` in your code, you don't really expect it to (one possible use case) check in how many places an array is not sorted. This is something I repeatedly see as a problem among my students at Uni and participants of workshops (and the latter are mostly experienced C++ devs). The name `transform_reduce` is much more generic and fitting for a powerful algorithm like this (`inner_product` could have been called `transform_accumulate` or something similar). And all this became even more weird since `inner_product` and `accumulate` got moved to `&lt;numeric&gt;`. But this is a rant for another time :)
std::move doesn't move anything. It makes the variable available to move but doesn't actually move. A better name would be std::move\_cast.
I have just completed a highly complex project setup using the CMake integration, we are producing code for 3 hardware platforms (think different generations of microcontrollers and boards) and PC (a Simulator and unittests) using a CMake structure and now the Visual Studio integration of CMake. Aside from two or three problems with getting Intellisense to work (our fault) I think the only real issues we have encountered so far are: &amp;#x200B; \- The build menu on the toolbar disappears if you edit the Cmake file in the tree and saves even though the Startup Item remains selected which of course disables just pressing F7 and the like to build/debug. If you click the Startup Item and reselect it, then it starts working again and the build menu reappears. &amp;#x200B; \- Sometimes Startup items appear in your tree that are verifyably not in the CMake build (as if we built all command line they are not generated) &amp;#x200B; Visual Studio 2017 has so far been stable in terms of staying up and we are starting to get all the variants of debugging to work as well with a bit of plugin help and an external piece of software. So for my part I can see it an improvement over the alternatives and at least at the level of QtCreator for crossplatform work if not quite there yet for any sort of baremetal work but then we are used to getting that to work on our own.
But `projected_fn` does not do composition for n-ary functions. `g(f(a), f(b), f(c))` is not really function composition. But I guess it is the more sane option for _extending_ function composition to functions with multiple arguments than the second one. &gt; when you can simply write a lambda With the same reasoning, projections are not useful because you can easily replace them with a simple lambda. The only-last-argument-is-projected composition can be useful when you have functions that have context and a value - where only the value is projected. A context can be as simple as a pointer to `this` in a member function. For example, for a member function like `file_t::set_owner(/* this, */ uid_t uid)`, we can easily create a variant of `set_owner` that takes a `user_t` by saying `o_l_a_i_p_compose(&amp;file_t::set_owner, &amp;user_t::id)`. 
To playing with coq is intellectual masturbation!
Oh sorry, my bad, guess I've looked on outdated sources.
You could easily implement each and have a range view type with an appropriate name. Then the loop would call out what you're iterating over for ( auto appropriately_sized_integer : set_bits_indices(my_bitset) ) You could also use the `|` syntax that other range views allow. And none of that would require opening up namespace std (which I believe is technically UB even if realistically it will work fine). But if you want to stick to the one... maybe a proxy type that gives access to both the bool and the index (size_t _WILL_ fit the index even if it doesn't fit `1&lt;&lt;index`). You might even get away with providing that value_type with conversion operators to bool and size_t? Not sure about that - that might lead to ambiguous calls. But anyhow if you had this value type it would be very easy to adapt it to the one you already have using existing range views: my_bitset | filter([](auto i){return i.bit;}) | transform([](auto i){return 1&lt;&lt;i.index;}); 
if you categorize your targets in your scripts, the "CMake Targets View" in Solution Explorer will honor that: [https://i.imgur.com/aOPhLMt.png](https://i.imgur.com/aOPhLMt.png) (more on targets view here: [https://blogs.msdn.microsoft.com/vcblog/2018/04/09/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/](https://blogs.msdn.microsoft.com/vcblog/2018/04/09/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/)). Is that what you're looking for or did I misunderstand?
Is writing a logging library a rite of passage?
Will revise the implementation to make room to all your suggestions. Thanks!!
&gt;We've added initial support for the C++20 operator &lt;=&gt; ("spaceship") for three-way comparison. Glad to see C++20 features starting to get implemented. Any hints on what other C++20 features that are in the works?
If you are going to do this, i.m.o. it is better to SFINAE fail - that way the compiler won't even generate the constructor if U and T aren't derived from each other. template&lt;typename U, class E = std::enable_if&lt;std::is_base_of&lt;T, U&gt;::value&gt; &gt; SmartPtr(const SmartPtr&lt;U&gt; &amp;other) ... That said, the original code works for any T and U such that T* is convertible to U*. This is less strict than U derives from T, so having the compiler complain about derivation overlooks implicit conversion of some types (T* to const T* for example).
I‚Äôm on mobile so that was more effort than I would have liked, but I really do want the feature... https://developercommunity.visualstudio.com/idea/435735/add-sanitizers-ub-address-thread-etc.html
To get better performance than STL you need to carefully assess what can be sacrificed. Unfortunately that means ad-hoc solutions will beat general purpose solutions most of the time. 
What about this isn't trivial?
I think your comment was supposed to be a reply to the article. The comment you replied to was a comment on a problem with stopping compilation if static\_asserts fail. 
What types of microcontrollers? Do you mean embedded Linux style targets with MMU or more like M4 cores?
Yikes, that should work. Can you file a DevCommunity ticket via Help &gt; Sned Feedback &gt; Report a problem for this issue? &amp;#x200B;
Not that I can to go into too much detail but yeah a few Cortex-M series processors and some other things.
Yeah I get similar issues.
&gt;Commonly most string are short and then this can be slower &amp;#x200B; Relatively - yes, it can be slower. However, in absolute values it will be something like 2 nanoseconds vs 3 nanoseconds, so this should hardly stop anyone from passing strings by value.
Casey checked in `remove_cvref` a few months ago for VS 2019 16.0. Our intern Paolo just checked in `contains()` for the ordered and unordered associative containers, for VS 2019 16.1. He's just about to check in `list/forward_list` `remove()/remove_if()/unique()` returning `size_type`. Feature-test macros are fully supported in VS 2019 16.0 (including `__has_cpp_attribute`, completed by Phil). The compiler has also added support for [P1008R1](https://wg21.link/P1008R1) prohibiting aggregates with user-declared constructors in VS 2019 16.0, implemented by Andrew.
I've had no issues with autocompletion. It just works for me, but I'm only working on small hobby projects. I've had my fair share of issues, but they've been pretty minor.
Hmm, I see your point. Having said that, I think the best solution is to follow Haskell and have separate functions for zip, map, and accumulate and make it easy to compose them in whichever order you like. Overloading the pipe operator like you said is the way to do that.
* Encapsulation * Information hiding. * Minimising the opportunity to inherit. * Stopping the abuse of the API * faster and smaller code, no vfptr, etc...
Thanks a lot for the answer! Then it is as I figured: it pays out to add most headers that never change, even if they end up being used by a single or few TUs. As for the last part, I find it is faster to go to godbolt.org to test the compiler instead of creating a project and setting it up (unless you actually need to run the code, of course).
Are you saying it compiles faster? This is not runtime code this is compile-time code, made exclusively to generate types at compile time.
Any news or schedule about integrating clang's analyzers?
You can use Clang Power Tools addons to do this ; though it seems to not be compatible yet with VS2019. 
I quickly tested the performance and was unable to get any gain from preview 1 (which itself was 5% better than 2017.9). I am still interested in the other features though. One really nice thing that nobody talks about are improvements in conformance, namely in the template 2 phase lookup (it behaves more like clang now, refusing to parse more code that is nonconformat compared to 2017.9 /permissive-)
I didn't know the solution viewed honored those, but I was talking about things like the target drop-down in the debug bar (e.g., the green arrow with the target name used to start debugging in the toolbar). I don't have the relevant project on hand right now for a screenshot; the drop-down I see is relatively massive with every target in my project rather than the ones I actually can run. (I might be misremembering and it might have been that it was showing a ton of CTest executables from sub-projects that I'd never care to run/debug, not non-executables?)
More detailed release notes for the backend work are out: [https://blogs.msdn.microsoft.com/vcblog/2019/01/24/msvc-backend-updates-in-visual-studio-2019-preview-2/](https://blogs.msdn.microsoft.com/vcblog/2019/01/24/msvc-backend-updates-in-visual-studio-2019-preview-2/)
I'd probably call it `std::discard`, because I'm telling the compiler, that I'm not using the variable anymore and it can do, what it wants to increase performance.
Hi /u/marian_l, I filed a handful of issues today: * [Visual Studio deadlocks when opening CMake project ](https://developercommunity.visualstudio.com/content/problem/435886/visual-studio-deadlocks-when-opening-cmake-project.html) * [CMake default compiler flags not overridden in CMake project ](https://developercommunity.visualstudio.com/content/problem/435857/cmake-default-compiler-flags-not-overridden-in-cma.html) * [Build.Compile command (Ctrl-F7) no longer works on CMakeLists.txt ](https://developercommunity.visualstudio.com/content/problem/435858/buildcompile-command-ctrl-f7-no-longer-works-on-cm.html)
Sigh... I'm still getting many lifetime false positives, basically all the lifetime violations are bad (including things referencing the hidden bits required to make range-fors work). &amp;#x200B; It'll of course take me all night to distill the repros down and file the bugs again - since that's what the outsourced vendor team running their feedback team demands... in hopes that their team will finally understand that c++, and their compiler's weak-ass introspection support, makes their tooling basically useless at this point in time.
Tangentially related question, how do you get the CMake Targets View show header files?
There's also platforms like AVR which are Harvard architectures, and thus have different address spaces. Address *n* may mean different things depending on context.
I downloaded the WinDbg preview, and while the tool works with my executable TTD disabled, it immediately crashes when TTD is enabled. That's a bummer but I'm sure if I was more familiar with WinDbg I'd be alright. Very cool concept though
Yes, of course, but I meant integrating them so that Microsoft supports it and it is streamlined, the same way they are integrating many other things (clang compiler, CMake support, tests from other providers, etc.). Ideally it could even be enabled in the background analysis mode.
&gt; I was talking about things like the target drop-down in the debug bar (e.g., the green arrow with the target name used to start debugging in the toolbar). Ah I see. It's true that we are listing test targets in that dropdown. Yes, thanks for the feedback. We should consider improving the usability if the debug target dropdown gets too cluttered by too many CMake targets. If you ever get close to that codebase, it would be great if you can send me some screenshots with color commentary (at mluparu at microsoft dotcom). As an alternative to the debug target, you can also control the startup item directly from Solution Explorer by right-clicking on an executable target and selecting "Set as Startup Item". &amp;#x200B; &amp;#x200B;
It's a very small change yet makes using CMake so much easier.
Headers need to be explicitly added to your CMake target definition inside the CMakeLists.txt to show up in Targets View. But even when you don't have that luxury, there are tons of other code navigation aids in VS to go to headers that your C++ files include. Most efficient way imo is **Go To (Ctrl+,)** that will find headers for you in your include graph even if they're not explicitly part of your project. Other ones may be **"Toggle Header/Code File"** (context menu in the editor) and the recently added (VS2019 Preview 2) **Go To Definition (F12) on #include statements**. 
Thank you very much! And I've just routed them internally to the right team. 
&gt;Headers need to be explicitly added to your CMake target definition inside the CMakeLists.txt to show up in Targets View. Not sure I understand, do you mean headers need to be included in the `add_library`/`add_executable` commands? That's already the case. &gt;Most efficient way imo is Go To (Ctrl+,) that will find headers for you in your include graph even if they're not explicitly part of your project. I really hate "Go to All". Results are always way too cluttered. Probably just a bug but seems to be taking about 2-3 seconds to actually go the file once I hit enter too :/
...and exception prevents loading of UE4 project.
Thanks. This looks great, especially the line by line size with debug.
I‚Äôve been looking for something exactly like this! I‚Äôve implemented the monadic interfaces proposal, but I‚Äôve been struggling on how to implement do notation (not part of the proposal, but super ice), and I really like your approach!
&gt; There is nothing in the call to `sort` that says what `{}` is. The declaration of `sort` is more than sufficient.
It seems to me that that is always going to somewhat be the side effect of over-use of overly elaborate layers of templates. How could the compiler ever really figure out what the actual intent was and give you a coherent answer? I say just use template less. Is it neat some of the stuff that STL can do? Yeh. Is it necessary or even ultimately more productive than something less complex? I'd argue that a lot of the time probably not, if you spend 30 minutes trying to decipher an error message or figure out some obscure rule of template resolution that is causing your thingie not to work. Do I really need to use 25 interlocking templates with lots of purposeful failures of template resolution to select this or that at compile time, in order to add 1 to every int in a list or add them up? No, not at all. I'm perfectly capable of writing the trivial for loop to do that, which is completely debuggable, which gives meaningful errors, which is completely understandable by any programmer even if they never have heard of the STL or coming from another language, and which probably generates a 15K less code. &amp;#x200B;
Yup! In general it is a good idea to use precompiled headers in your codebase, because you probably will reference headers you don't modify much (if at all). &amp;#x200B; The question for us on the Visual Studio team was whether PCHs on should be the *default* behavior for these basic new project templates, which are often used for testing or experimental purposes (or for new users to write "Hello World" and play around in the IDE for a bit). We've had a lot of internal debate on the subject for a while, but we finally made the call that we would rather have an opt-in experience for PCHs than have users go through a potentially confusing process to opt out. After all you can't just delete the file and be done with it, since the properties of the project are impacted by the existence of PCHs. We have some more ideas about how we could make PCHs easier to use, but that's a plan for another time. &amp;#x200B; Anyway, you can still create a console or desktop app with PCH on. Just choose the "Windows Desktop Wizard" template, which includes a wizard for configuring the project that has a PCH checkbox. &amp;#x200B; If anyone has some feedback on PCHs in general and what you'd like to see going forward, we are open to hearing it. You can suggest features on the Developer Community website now, which is much nicer than our old UserVoice UI :)... [https://developercommunity.visualstudio.com/spaces/8/index.html](https://developercommunity.visualstudio.com/spaces/8/index.html)
By the way, you can absolutely have multiple VS installations running side-by-side on the same machine. So one option is to keep using VS 2017 v15.9 for your core work, but play around with the new stuff in VS 2019 to see how the experience compares. 
Don't use such a piece of shit operating system then.
&gt; The only real alternative is C, actually. Not Rust. Rust has no GUI libraries and last time I looked, very very immature GPU acceleration libraries as well.
Logging, string formatting, serialization. &amp;#x200B; Writing a library of any sort is a good way to learn. It may be tiresome for programmers who've been around a long time to see people keep reinventing the wheel, but there will always be people new to programming who haven't been truly exposed to existing libraries.
I wouldn't hold my breath. They explicitly say it's only because ML libs use omp simd heavily.
I agree - this becomes much saner with ranges.
Code coverage when ?
It's not clear what the inner and outer loops are intended to do... you want to ask the user for input, handle it (using a loop), and then do that over again? Here's a simple version: #include &lt;iostream&gt; int main() { unsigned int input {}; while (std::cin &gt;&gt; input) { // read until input fails for (unsigned int counter = 0; counter &lt; input; ++counter) { std::cout &lt;&lt; "Hello, World\n"; } } }
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ajme4z/simple_for_loop_question/eewq5ga/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's a part of the C++ initiation. Before, you had to write your own string class. Now you need to create a logging library.
Is the windows SDK now compatible with the overhauled preprocessor?
Windows CDB, when ? 
Reasonable speed while using templates and not burning my computer up driving fans at a million RPM's when? All I want is good fast code completion and light weight for medium sized projects... not even talking big here.
I don‚Äôt know that status. I‚Äôll ask.
Thanks a lot: We have a somewhat larger piece of macro macro machinery that could be cut into half, but it is used in translation units that also includes some Windows headers.
Link time improvements are really great, on our project linking time decreased from 1m35s to 55s! 
kudos to tony for his tables
Seems to be all about apps. In an article about "The state of C++ on Windows", from a Microsoft engineer, I expected to see some info about UTF-8 support, for example, in VS debugger and VS Test Explorer, to name two. Or, that Microsoft is finally going to support standard `main`, and the `and`, `or` and `not` keywords, by default. Yes? It's only 20 years since the standardization! 
Does the article ever explain why it's explicitly specifying `void` as the return type for `enable_if`? I didn't read thoroughly, but saw the word "succinct" come up a few times, and I certainly don't see how redundancy helps things...
That would be /u/tvaneerd to most here. ;-]
Yeah, not much is new. I want see "examples, examples, examples".
An iterator pair is conventionally named `first, last` in the standard. E.g. in the standard `std::distance` is declared as ([\[iterator.operations\]](https://wg21.link/iterator.operations#itemdecl:2)): template&lt;class InputIterator&gt; constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type distance(InputIterator first, InputIterator last); and the range constructor of `std::vector` is declared as ([\[vector.cons\]](https://wg21.link/vector.cons#itemdecl:4)): template&lt;class InputIterator&gt; vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator()); But I guess it's extra tricky for `std::span` since `span` has member functions named `last`....
Maybe "The state of C++ in Windows" would have been a better name, since this post is not about C++ tools related to the platform, as you describe them, it's about C++ in OS APIs. 
It may be stringly encouraged to use C++/WinRT over C++/CX but since it requires a minimum version of `10.0.14393.0` this is no good to anyone who needs to support older, still officially supported, versions of Windows. This is a constant source of annoyance. Everyone wants you to use new versions of SDKs etc to avoid bugs and so on but you need to support older Windows. By the time support for `10.0.14393.0` is dropped by Microsoft I expect C++/WinRT will increase the minimum target again and the cycles repeats.
std::initializer\_list, end of story std::tuple, if they aren't same type
The strange part is that it said `begin` and `end` in the function signatures, and then explained what parameters `firstElem` and `lastElem` are -- and there were no parameters named like that in the rest of the page. I've edited the page -- it is now what you'd expect.
Also, why doesn't std::span have front() and back() member functionsike the other standard sequence containers?
&gt; Or, that Microsoft is finally going to support standard main, and the and, or and not keywords, by default. Yes? This. One thing that continuously annoys me is when a perfectly standard-conformant code that compiles with `-Wall -Wextra -Wpedantic` on GCC just can't make it through MSVC because it has some standard conformance issues that just looks like "won't fix"s or triggers misleading warnings like "xyz is deprecated, use our non-portable xyz_s"
Thanks!
I found this paper for additional features on span: [P1024R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1024r0.pdf).
It's good practice if you are using enable_if to define the return type or a parameter type of a function - it's generally left out when used as an additional template arg: template&lt;typename T&gt; enable_if_t&lt;some_trait_v&lt;T&gt;, void&gt; func1(); template&lt;typename T, enable_if_t&lt;some_trait_v&lt;T&gt;&gt; void func1();
I didn't realized that it was an historical reason for pair of iterators in the `std`. Thanks.
Based on the discussion [here](https://www.reddit.com/r/cpp/comments/8prqzm/2018_rapperswil_iso_c_committee_trip_report/) it looks like the committee had issues with some parts of that paper but front() and back() were OK and will be resubmitted. Hopefully it makes it in before c++20
Use `/permissive-` if you want your code to be portable. Among other things, it also enables support for the alternative token representations.
Standard \`main\` is supported, and has been for many years. I seem to remember I had to do something to enable it, but I cannot for the life of me remember what it was now...
&gt; Or, that Microsoft is finally going to support standard main, and the and, or and not keywords, by default. They already do! I was glad, because I love the `and or not` representation after working with Python. Much more clear to read, much easier to spot (with highlighting of keywords) and easier to type.
&gt; An iterator pair is conventionally named `first, last` in the standard. But isn't last I've always found this very weird, because `last` does not mean the last element, but "one after the last element".
Oh, didn't know boost.hana included compile time type name introspection! Now I will definitely stop trying to maintain ctti.
Yes, your name is cited inside boost/hana/experimental/type\_name.hpp. As for today, boost.hana only works on clang. I proposed a PR ([https://github.com/boostorg/hana/pull/432](https://github.com/boostorg/hana/pull/432)) which adds supports for MSVC (compile time) and GCC (runtime only, although some work on gcc at compile time is underway)
Great, I will try this again this weekend. Thanks a lot for the detailed response!
The problem here is having a variadic number of arguments, not passing a single type that takes a variable number of arguments. Each case has its own rationale.
tl;dr: C++/WinRT is shit for writing GUI apps.
For what reason? The result is you want a function with various number of params, so it's variadic or not - why should you care? Example?
Here is the same from Pacific++ 2018 https://www.youtube.com/watch?v=BVslyei0804
I was thinking about cases where you want to do some currying, so you want to wrap your function with a portion of the arguments. If your function takes a tuple I find it more bothersome to combine all your arguments in the end, compared to ‚Äúplain‚Äù variadic templates.
Also std::initializer_list cannot be moved from.
From what? [http://cpp.sh/2g6xx](http://cpp.sh/2g6xx)
What name do you suggest? :)
None, I suck at naming things.
Well yeah, but you can't move *from* it. It only hands out const pointers (have a look at begin/end)
From the article: ‚ÄúAdded a new inlining command line switch: -Ob3. -Ob3 is a more aggressive version of -Ob2. -O2 (optimize the binary for speed) still implies -Ob2 by default, but this may change in the future. If you find the compiler is under-inlining, consider passing -O2 -Ob3.‚Äù Did you try that? I‚Äôm curious how it turns out for you.
I didn't, because we already __forceinline waaaay too much ;-) our manual forceinline makes the code about 10% faster. When I try Ob3 later, I will not be expecting speedup, but I will try removing forceinline to see if we can remove this cognitive load from our programmers without taking 10% hit
Another observation is that clang 9 is currently 15% faster then msvc 2017.9 and 10% faster than 2019
We need https://wg21.link/P0237 sooner rather than later
&gt; More clear to read/parse IMO, it's really !
Apparently it changed since you posted this comment... it no longer does.
When people say you can't move from an `initializer_list`, they don't mean that literally `T x = move(y);` doesn't compile for the underlying elements. They mean that it compiles but invokes the copy constructor of `T`, not its move constructor.
That's debatable, I used Clion but I'm currently testing VScode which seems to work much better for me (big C++ project)
What's the problem? You just use va\_list. \*ducks away\*
Correct me if I'm wrong -- but doesn't the Windows 10 SDK target Windows versions all the way back to Windows 7 SP1 for Win32 apps? Granted, I don't think you could use something like UWP on those platforms, but I thought you could still use WinRT. Here's a source for why I was under this impression: https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk Under the heading "Supported Operating Systems".
Something based on "after" or "post" would seem to make sense from a conceptual standpoint. 
On two projects (out of 30) in multi-project solutions compiling with `-Ob3` resulted in ICE. Others compiled successfully. Compiling those two with `-Ob2` succeeds, so this is a regression in `-Ob3` mode in preview 2. What's the best way to report such kind of ICE? ICE occurs in `-LTCG` mode after "Generating Code" is displayed and seems to be in a random place.
Im using Clion now more than 2 years after many years with different IDE and text editor (Ive given up on IDEs after Visual Studio 2008 and its 100%CPU intellisense, which didnt work in my heavily templated code anyway), and after many years with Emacs CLion was the first C++ IDE which actually works as I expect from IDE (even on Windows). I could imagine someone being happy with VSCode, but I fail to see how it could work "much better" than CLion. Care to provide some life changing examples?
To be fair I miss it. To be more precise as I understand: ``` f(T&amp;&amp; src) { // we create universal reference here to not let src converts into lvalue if it would be rvalue // if we still decide to use src then it converts into lvalue but instead of that we are calling std::forward&lt;T&gt;(src) // which take src by lvalue because src now would be always lvalue and regenerate its original type by using type collapse so in case of rvalue we would have cast here T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp; otherwise just T&amp; } ```
&gt; Please ignore it for now and know that parameters are implicitly auto&amp;&amp; Plain `auto` behaving as a forwarding thing? If this is accepted before abbreviated lambda/function definition, I quit!
Definitely not soon. But it's at least some step in this direction. Before that it was completely deprecated. With enough push maybe that'll be the next thing VS would tackle after finishing up their conformance catch up work.
Oh shit, thanks for pointing this out, I was under the impression you needed the XP development kit instead for doing Windows 7 development with C++...
 template&lt;typename... Ts&gt; void f(Ts const&amp;... xs) { static_assert(std::conjunction&lt;std::is_convertible&lt;Ts, std::string&gt;...&gt;::value, "Not all arguments of f are convertible to strings"); } I prefer static asserts over SFINAE where possible - especially for free functions there is no drawback (I think) and they produce much clearer error messages and are lighter on the compile times. On top of that there is a whole sentence written why something fails to compile so you don't even need to the AllStrings helper to make that clear.
I got it now, he mean from its content - that's right.
I'm so disappointed that there is still no language level solution for it. Aisde from current workarounds being unnecessary verbose and/or inefficient (in run-time and/or compile time, there is also a difference in semantics between specifying a particular tzpe for the parameter and asserting/SFINAEing or otherwise checking if a passed argumnent has a particular type. Both approaches can lead to different overload sets. 
It worked fine for me for a couple of small project and reasonably well for LLVM. But it definitely was not the smoothest of the rides. Test on early VS 2017, not sure if/how it improved in VS 2019.
1) In CLion since we switched from CMake+Makefile to CMake+ninja file navigation didn't work well, but VSCode seems to work OK 2) Our project use several independant CMakeList, so when I open a file not in the "correct" window CLion basically loose all smart whereas I can tell VSCode to open the root of my repository (even though it's quite big) and I have every file in the same window.
There is a draw back void f0(std::array&lt;int,3&gt;,std::array&lt;int,3&gt;,std::array&lt;int,3&gt;) { } template&lt;typename... Ts&gt; void f1(Ts const&amp;... xs) { static_assert(std::conjunction&lt;std::is_convertible&lt;Ts, std::array&lt;int,3&gt;&gt;...&gt;::value, "Not all arguments of f are convertible to strings"); } int main() { f0({0,0,0},{0,0,0},{0,0,0});//OK f1(std::array&lt;int,3&gt;{0,0,0},std::array&lt;int,3&gt;{0,0,0},std::array&lt;int,3&gt;{0,0,0});//OK f1({0,0,0},{0,0,0},{0,0,0});//Error: no matching function } 
There is a draw back void f0(std::array&lt;int,3&gt;,std::array&lt;int,3&gt;,std::array&lt;int,3&gt;) { } template&lt;typename... Ts&gt; void f1(Ts const&amp;... xs) { static_assert(std::conjunction&lt;std::is_convertible&lt;Ts, std::array&lt;int,3&gt;&gt;...&gt;::value, "Not all arguments of f are convertible to strings"); } int main() { f0({0,0,0},{0,0,0},{0,0,0});//OK f1(std::array&lt;int,3&gt;{0,0,0},std::array&lt;int,3&gt;{0,0,0},std::array&lt;int,3&gt;{0,0,0});//OK f1({0,0,0},{0,0,0},{0,0,0});//Error: no matching function } 
VC IDE team here. Thank you very much! We're looking into this.
Well, that's because somebody [30 minutes before you](https://en.cppreference.com/mwiki/index.php?title=cpp/container/span/span&amp;diff=108693&amp;oldid=100485) decided to change it half-way. I copy-pasta'd the names straight from the paper, IIRC.
[Revision 1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1024r1.pdf) of that paper (without `at()` or the non-member subview operations) was accepted by LEWG in San Diego and passed to LWG for working review. I submitted R2 with tweaked wording based on that feedback, and I'm hopeful it will pass LWG in Kona.
Standard ```main``` works in Windows, but if you want to create a GUI app without the default console window then you have to let the linker know that and do some additional configuration. WinMain is a convenience function for writing GUI apps but it's not at all necessary.
Is there any reason not to just have the function accept a std::initializer_list&lt;T&gt; ?
Moving a container implies moving the elements. In this case though moving does **not** happen. It's still copying.
Even before you install any plugins, I would recommend you set up the syntax colorization properly. For example, you can set up VS to colorize local, global and class variables differently, though I think that is disabled in the default theme. Also, set up VS to be your diffmerge tool in your source control configuration. That way, you get full syntax highlighting, code completion, etc while doing diffmerge. As for plugins, most important is the Color Theme Editor ! :) I also use Productivity Powertools, Editor Guidelines (set at 120 column), Viasfora(for rainbow braces), HgSccPackage(for mercurial support) and a ton of extensions by Mads Kristensen(File Icons, Add New File, Trailing Whitespace Visualizer, etc etc). 
Why is it good practice when ```void``` is already the default? If it's good practice then why is ```void``` the default? Seems like if the intention was to be explicit about it then it would require the user to explicitly provide a type. At any rate, I think it was a minor oversight by the author as the article has been updated to remove the ```void```.
Tabs Studio (https://tabsstudio.com/) Visual Assist (https://www.wholetomato.com/)
 template&lt;typename... Ts&gt; auto b(Ts const &amp;... ts) -&gt; decltype((((void)std::string(ts)), ...)) {}
Vsvim I can‚Äôt function without my vim plugin, and as a bonus, no one else can mess with my code if I ever forget to lock my screen. 
I remember the time I used VStudio (it was a Windows-only project), what a bloated piece of crap...
Here is another way to do it using a wrapper function around the main implementation: &amp;#x200B; #include &lt;string&gt; template&lt;typename T, typename U&gt; using to_type_t = U; template&lt;typename... T&gt; void myFunctionImp(const T&amp;... t){ } template&lt;typename... T&gt; auto myFunction(T&amp;&amp;... t){ return myFunctionImp&lt;to_type_t&lt;T,std::string&gt;...&gt;(std::forward&lt;T&gt;(t)...); } int main(){ std::string s = "Hello"; myFunction(s," world"); } [https://gcc.godbolt.org/z/UA06lc](https://gcc.godbolt.org/z/UA06lc) &amp;#x200B; &amp;#x200B; &amp;#x200B;
Yes, that's what I meant, but you're right. It looks like the targets view filters out headers. I've open a ticket for that since I was able to repro it too: [https://developercommunity.visualstudio.com/content/problem/436785/cmake-targets-view-does-not-show-header-files.html](https://developercommunity.visualstudio.com/content/problem/436785/cmake-targets-view-does-not-show-header-files.html) For "Go to all" if you type "f " it will filter results only to file names rather than symbols. If that doesn't address the clutter, I'd really like to understand this problem better and then figure out with our team how to address it. RE the 2-3 seconds delay, can you check that "Use preview tab" is disabled (after Ctrl+, go to the wheel to show the settings, uncheck "Use preview tab") and see if you still see the delay? Either way, can you file a DevCommunity ticket 
This post on VCBlog has several suggestions too including ImageWatch, PDBProject, WhackWhack Terminal and more: [https://blogs.msdn.microsoft.com/vcblog/2017/08/29/visual-studio-extensions-for-c-developers-in-visual-studio-2017/](https://blogs.msdn.microsoft.com/vcblog/2017/08/29/visual-studio-extensions-for-c-developers-in-visual-studio-2017/)
I'm using: - vscoloroutput (colorizes warnings and errors in the output window) - text macros for visual studio (lets you record and replay keyboard macros) - customize visual studio window title (lets you change the title so it shows the full path to your project, useful if you have multiple copies checked out)
Sure thing, I'll definitely be poking around with it this weekend (and playing more with the Preview2 improvements!). RemindMe! 1day "email marian_l"
I will be messaging you on [**2019-01-26 18:16:06 UTC**](http://www.wolframalpha.com/input/?i=2019-01-26 18:16:06 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/aja97c/visual_studio_2019_preview_2_c_productivity_code/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/aja97c/visual_studio_2019_preview_2_c_productivity_code/]%0A%0ARemindMe! 1day ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! eey5tcn) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
FWIW plain `auto` here is supposed to be a concept. Concepts don't exist in Clang yet so I didn't play with that much.
Really, the important state is the state of jobs in C++ on Windows. Sometimes I feel like I picked the worst two horses. Not because either horse is bad, I like them both. But, as a team, they are fallen on hard times. There's so few C++ jobs on Windows these days it seems. If you want to do C++ you sort of have to be a Linux/Unix guy almost. And if you want to do Windows, you have to kind of bail out to the .Net world. And Microsoft is clearly really wanting to get rid of straight C++ and the Win32/64 API and make us all write managed applications, at which point there's probably even less reason to use C++ and not just move on to C#. Hopefully I'll be dead before they manage to pull that off, given their large installed base of Win32 stuff. Though, life seems determined to make them wait as short a time as possible. &amp;#x200B;
&gt; stringly encouraged std::string("great job!");
Does it still use the same cl compiler as 2017?
From some quick tests, the lifetime checker seems to be able to recognize more violations than it did back in [June](https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/lifetime%20checker%20observations%20-%20Jun%202018.md) (when it already caught a lot of them). But it also seems to have added some false positives that weren't there in June. For example: #include &lt;iostream&gt; #include &lt;string&gt; void foo(const std::string&amp; str1) { std::cout &lt;&lt; str1 &lt;&lt; std::endl; } int main(int argc, char* argv[]) { auto str_shptr = std::make_shared&lt;std::string&gt;("hello"); foo(*str_shptr); str_shptr = nullptr; // (new) false positive (warning C26489) return 0; } Aside from these bugs, the lifetime checker is unavoidably going to have [intrinsic false positives](https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/implications%20of%20the%20lifetime%20checker%20restrictions.md)(/restrictions) like the Rust language does. Safely working around those is going to require [flexible](https://github.com/duneroadrunner/SaferCPlusPlus#reference-counting-pointers) [non-owning smart pointers](https://github.com/duneroadrunner/SaferCPlusPlus#norad-pointers) with run-time checking, and versions of the standard dynamic containers that can be "[structure locked](https://github.com/duneroadrunner/SaferCPlusPlus#make_xscope_vector_size_change_lock_guard)" at run-time, I think. But anyway, I think the progress is encouraging.
Thanks for being interested in filing a report! :) For \*any\* issue with the compiler, please don't hesitate to file an issue on [http://developercommunity.visualstudio.com](http://developercommunity.visualstudio.com) (DevCom). That's our one-stop-shop for all our bug reports, and allows people to upvote/comment to make sure we're prioritizing these reports as best as possible. Do note that we need a stand-alone repro (i.e., we need to be able to run the compiler end-to-end) to likely be able to make any progress on these kind of reports. If it only manifests with LTCG, we'd need a what's called a "link repro". Thanks for trying out not only the preview, but also the new optimizer flags! It's very motivating :).
Clang Power Tools is really awesome in leveraging Clang-format and Clang-tidy. 
Every time I run the lifetime profile I have to think either I haven't understood C++ at all or the profile has lots of false positives.
I‚Äôd argue that `std::bitset&lt;N&gt;1st is conflicted about whether it represents a sequence of bits (I.e. a packed `std::array&lt;bool, N&gt;`) or a sorted set of integers (I.e. an array-backed `std::set&lt;int&gt;` or a packed `boost::flat_set&lt;int&gt;`). I‚Äôve made a new `bit_set&lt;N&gt;` that does the latter: https://github.com/rhalbersma/bit_set It has bidirectional proxy integrators that call intrinsic routines to find the next/prev 1-bit.
I've reported compiler bugs in the past. As I described, in a 30-projects solution only 2 projects fail in seemingly random places. Both errors are reported in boost, in different places, but in very simple code, like: ``` template&lt;class Iterator&gt; iterator_range(Iterator first, Iterator last) : base_type(first, last) // reported on this line { } ``` ``` C:\MyProjects\test\packages\boost.1.68.0.0\lib\native\include\boost\range\iterator_range_core.hpp(484): fatal error C1001: An internal error has occurred in the compiler. 9&gt;(compiler file 'd:\agent\_work\1\s\src\vctools\Compiler\Utc\src\p2\main.c', line 160) ``` Therefore, I'm almost sure I will not be able to minimize it to "stand-alone repro". Will try to make a "link repro". 
They have a new version with improvements that posted about a couplle days ago. https://blogs.msdn.microsoft.com/vcblog/2019/01/24/msvc-backend-updates-in-visual-studio-2019-preview-2/
Never really thought it was bloated. But I'm also not elitist about the tools I use. 
That has nothing to do with the static assert though... the same will happen if you use SFINAE in that case.
oh ye, you are right.
Ok
Spell checking. Google test runner (if you use them) Maybe Resharper. It's a paid product and it is HEAAVVVYYY. But might have the exact feature that you need. &amp;#x200B;
I'm wondering whether `CMAKE_CXX_EXTENSIONS ON` sets `/permissive-`. I think that would make sense, wouldn't it? Anyone know anything about the status of that?
&gt; Also, set up VS to be your diffmerge tool in your source control configuration. That way, you get full syntax highlighting, code completion, etc while doing diffmerge. Wow that's a cool idea. Any guide on how to set up git so that it uses VS as diffmerge tool? How does it look, does it have a nice GUI for 3-way merges? (3 windows at the top, one on the bottom)
They will do anything except make it 64 bits :(
That blog post is quite light on actual information.
Ah, great, thanks. I completely understand that it's infeasible to get a min-repro when Boost is involved. I hope the link-repro generation goes easily for you. Thanks again!
Why would you need it to be 64 bits?
But `[first, afterLast)` looks weird :/
It runs out of memory constantly when you debug a big project, e.g. Unreal 4. Sometimes even without debugging if you have some fancy plugins, which you also need because intellisense sucks. Note the change: For C++ applications running on Windows, PDB now load in a separate 64-bit process. This change addresses a range of crashes caused by the debugger running out of memory when debugging applications that contain a large number of modules and PDBs. This is basically a hacked up workaround to the issue, rather than making the app 64bit...
windows bad
What you want to achieve is PIMPL. For that you don't have the full type of your impls in the header, so including code cannot know which function to call of the impl. And those function need to be defined somewhere. Same as with static members: You need a cpp file where you place those functions in voiding all your saved syntax.
I'm not an elitist, I'm just expressing the fact that I don't like an IDE that occupies 5GB after installing...
I think some people from MS said a few years ago already that they've done some initial tests with 64-bit but found that the IDE got slower and there wasn't really any upside to it. Basically it causes all pointers to become from 32 bit to 64 bit, i.e. double in size. Anyway I completely agree we're in the world of 64-bit apps now. Aren't there like compiler optimizations &amp; stuff that are even only active on 64-bit compilation? AVX for a starter I think.
heheh
- [PureDevTabs](https://marketplace.visualstudio.com/items?itemName=PureDevSoftware.PureDevTabs-18906): always opens .cpp on the left tab group and .h in the right. - [Hide Suggestions And Outlining Margins](https://marketplace.visualstudio.com/items?itemName=MussiKara.HideSuggestionAndOutliningMargins): removes whitespace at the beginning of lines, near the line numbers. - [Editor Guidelines](https://marketplace.visualstudio.com/items?itemName=PaulHarrington.EditorGuidelines): adds a vertical line at a given column, I have it at 80. This allows me to comfortably have the project explorer on the left, two editor panes and the test explorer on the right. - [Time Stamp Margin](https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.TimeStampMargin): adds timestamps in the output window. - [March Margin](https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.MatchMargin): shows matches for the word under the caret in the editor (like when selecting a word in Notepad++) and in the scrollbar. - [Trailing Whitespace Visualizer](https://marketplace.visualstudio.com/items?itemName=MadsKristensen.TrailingWhitespaceVisualizer): shows whitespace at end of lines, can be configured to right trim all lines when saving. - My own extension, which renames all editor tabs to "project:dir/file.ext" instead of just "file.ext". Useful for figuring out which file is which when they have the same name. Some of them are not compatible with 2019, but most are open-source (except for PureDevTabs), so they're easy to fix.
C++/WinRT is a "language projection" (basically bindings in non-Microsoft speak) for UWP apps on Windows 10. https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt 
Yeah while there may be some truth to that, I think it is offset by other benefits, for example NOT CRASHING when developing with one of the most popular game engines on earth. x64 does allow you to make more assumptions about SSE instructions and allow for some optimizations for 64 bit types too. In general, they have tried to make all kinds of ridiculous excuses to not get this done. One of their devs posted an article saying if you ever run out of memory it is your fault for using buggy plugins. I found that incredibly insulting, IMO they just have a deep technical issue running the code in x64 that they can't/won't fix and are making excuses for it. 
PIMPL isn't the only reason for forwarding, it's just one. The other is just straight encapsulation with forwarding. In those cases, the forwarded to class is completely visible, and it's just an inline forward to some member. Even when PIMPL is desired, it could just not inline the calls but place them in the same cpp file as the implementation class (which it knows from the forward declaration in the public class and the pointer to it. In either case, the method to call is the one with the exact same method signature of the forwarding one. If not found, that's a failure.
If you don't want your tools/ide to take up 5 Gb, that's fine. But an ide being 5Gb does not, inherently, make it bloated. 
I'm not arguing that. However, the standard decided to use the "one past the last element" idea which doesn't seem to map well to the desired syntax. Conceptually, what you posted makes sense to me. It says include everything starting at the beginning and don't include the thing after the end. If the standard was inclusive for "last" this wouldn't be a problem but it went the exclusive route(which may have more merit for all i know) and therefore either is stuck with inaccurate naming or unidiomatic phrasing. 
Reason being that adding anything to the language has costs, so the gains of that feature had better be worth that cost. Saving you from writing a couple of one-line function bodies is very probably not deemed worth the cost by anyone in the standards committee.
Likely both. It does still have some unintended false positives, but it also prohibits a lot of code that would have traditionally been considered valid. Rust programmers (famously) struggle with similar sorts of restrictions. Mostly it just takes some adjusting to, but as I referred to in another comment, this [link](https://github.com/duneroadrunner/misc/blob/master/201/8/Jul/implications%20of%20the%20lifetime%20checker%20restrictions.md) attempts to explain the nature of the lifetime checker's rules and gives a couple of examples of legitimate code that can't be cleanly made to conform to the new restrictions (without additional "helper" elements).
It is even worse on Android and Apple platforms.
But a good bit of the time forwarding schemes are anything but a couple of methods. Sometimes they are quite extensive amounts of code, any of which could contain a mistake in the forwarding, initially or during maintenance. Given how many people these days are going around claiming that inheritance is evil and encapsulation is the new good, you'd think they be clamoring for this since they will be using LOTS of forwarding methods most likely. But, even for those of us who think inheritance makes perfect sense, we still will end up doing a fair bit of forwarding, either for PIMPL reasons or for other reasons, since as providing alternate versions of an interface around an internal object that does the actual work. &amp;#x200B;
Re: the GCC issue. This may have changed recently, but gcc's __PRETTY_FUNCTION__ is (was?) treated as a constexpr local char array (i.e. not a static) so to extract the string you have to copy it out to something like std::array&lt;char,N&gt; (rather than returning const char*). Also, GCC implements &lt;experimental/source_location&gt; with function_name() which looks like it provides a static const char* (but... the source_location proposal is in flight, has just changed API and does not standardize the output format any more than the pretty function preprocessor extensions). 
This is probably better asked on r/cpp_questions.
Thanks! will post there &amp;#x200B;
Was it slower? or just no improvement? I tried PGO many years ago and actually saw regression in performance--haven't tried it since.
I fail to see the benefit of this. To me it seems like useless syntactic sugar to avoid writing one line of code and it also makes it far less clear what is actually being called. I'm pretty sure you could implement something like this with the preprocessor if you really wanted to... 
I would begin by not even thinking about it as an array of pointers but rather as a pointer to a pointer. You can not pass arrays as arguments to functions, they decay into pointers.
All three links are already posted... https://old.reddit.com/r/cpp/comments/aja97c/visual_studio_2019_preview_2_c_productivity_code/ https://old.reddit.com/r/cpp/comments/ajfblm/msvc_backend_updates_in_visual_studio_2019/ https://old.reddit.com/r/cpp/comments/ajf0bc/lifetime_profile_update_in_visual_studio_2019/ 
r/cpp_questions
But what if it's thousands of one lines of code, some of which may be a lot more than one line of code of course, depending on the complexity of the parameters? That may be the case in something like a gaming system, where they often tend to use encapsulation heavily instead of inheritance. And, sure, you might be able to do something with the preprocessor, and loss most of the benefits of it (which is a compile time checked forwarding mechanism), and with all of the other shortcomings of the pre-processor.
Two scenarios, either your automagical forwarding mechanism is... 1. ... trivial, in which case it's really no better than just doing that bit of wiring yourself; Hard sell to standardisation committee. 2. ... nontrivial, in which case an automagic solution is invariably going to run into tons of cornercases that are hard to sell to the standardisation committee.
But it's NOT trivial if it happens many thousands of times in a large code base. I think it's fairly 'trivial' as such things go, but non-trivial in terms of work saved, without any loss of compile time safety. That's about as good as it gets, IMO. &amp;#x200B;
Yes, if you look at the boost.hana [PR#432](https://github.com/boostorg/hana/pull/432), you will see that a user proposed a [gist](https://gist.github.com/xqms/6fd2a9bd776075df2b285be3321235cd) that resembles your idea. I did not have time yet to review my PR following his suggestion. A [commit](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66639) was added onto gcc in order to address this, but this commit will not probably end up in gcc 7, but in gcc 8.
5GB is a humongus size for an IDE! It also installs lots of stuff yo don't need/want and you cannot disable them... But OK, I guess Windows users are used to waisting disk/memory. 
Qt, dear ImGui, WxWindows
&gt;Really, the important state is the state of jobs in C++ on Windows. I've been encouraging people to not neglect developing some closed source code. I've been working on that and starting a company for years now. It's not been an easy road, but I think it's better than waiting for someone else to do it. &amp;#x200B; &gt;Hopefully I'll be dead Don't wish your life away. &amp;#x200B;
i just stick to my favorite editor, writing the code for a gui isn't too complicated. 
My mind tells me 'last' should be a pointer to the last object in the collection and 'end' should be a pointer to the "terminator": last (adj) must refer to an object end (noun) doesn't refer to an object as it is an object itself
We need a FAQ. https://www.reddit.com/r/cpp/comments/9njw5n/is_there_an_easytouse_gui_library/ https://www.reddit.com/r/cpp/comments/6enpdi/looking_for_a_good_gui_library/ https://www.reddit.com/r/cpp/comments/46jnyy/can_someone_reccomend_a_gui_framework/ https://www.reddit.com/r/cpp/comments/3q816w/c_programs_and_guis/
I wrote my own GUI framework on top of OpenGL to use for personal projects. I do not recommend this approach :D 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ajtze0/need_help_with_code_not_understanding_dword_ptr/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Christ! Thank you!
Can you point me to a tutorial to learn this? I have no idea where to start!
I saw QT. Is it free to use non-commercially?
Yes. Even commercially through their LGPL (license), you‚Äôd have to provide your object files along with the Qt dynamic libraries. 
E-book only :( The title should mention that imho.
&gt; or example NOT CRASHING when developing with one of the most popular game engines on earth Didn't you just say that they solved this with the out of proc debugger?
So if i'm not mistaken you're describing higher-order functions that evaluate to unevaluated expressions. The metaprogramming possibilities this would open up would be amazing...
Resharper comes with a Gtest runner though, does Google test runner have any benefit over it?
You think it's hard BEFORE you start the company. Wait until after you do :-) The great thing about starting your own software startup (without a VC sugar daddy) is that you get to work ten times harder for ten times less. I've been thinking about posting a rant about open source code and how it's not exactly what it's cracked up to be. But I'm guessing I'd probably be dragged outside and shot by an angry mob. &amp;#x200B; &amp;#x200B;
What are you talking about? You only have to install the components you want to install... The IDE+the minimum set of components required for C++ development (compilers, CRT, STL etc.) is about 1GB.
Perhaps Microsoft should implement x32. Won't help out of memory issues, but will help performance.
Are you using the 64-bit backend?
My initial though is how to differentiate between returning an expanded versus an unexpanded parameter pack. like `some_template_fn&lt;expanded()&gt;()` versus `other_template_fn&lt;some_template_fn&lt;unexpanded()&gt;()...&gt;()`. Because sometimes we need to expand packs in a fold expression possibly using multiple packs.
At the time I used it (2 years or so) 4/5 GB was the minimal install. I'm taking about VS 2015. Anyway, use whatever tools you prefer, I just don't like Windows' ecosystem, at all.
How does it compare in codegen to g++ and Clang? MSVC tends to fall behind in Godbolt... Sometimes embarrassingly so.
 I definitely think `std::expected` is something that would be really helpful to have. I started using my own implementation of `std::optional` back in 2014 and I think ‚Äúexpected‚Äù will bring a similar needed upgrade to my codebase. That said I‚Äôm a little weary of the that new proposal for C++20 (but I‚Äôm also a little hazy on Concepts and probably just new features in general, so there‚Äôs also that.) However, I really like his ‚Äúwith‚Äù solution (or at least the `operator |` he uses a few minutes after introducing ‚Äúwith.‚Äù) I‚Äôd really like to try this along with an implementation of `std::expected` and see how it fares.
https://developer.gnome.org/index.html.en
I would like to suggest libui, It's a C GUI library, but I find it very easy to use, there's also some C++ bindings for it. The main advantage over Qt is that is not as intrusive as Qt. 
There is also [nana](https://github.com/cnjinhao/nana). It does not come all batteries included like Qt but for simple projects it should be enough.
I haven't noticed that the software I work on (scientific simulation software) is slower on Windows than Linux, so I'm not sure it has bad code generation for real projects. It is worth noting that reading assembly can be misleading in terms of performance and what you see in tiny examples may not translate to full applications.
A *basic* GCC install is around 100 MiB, without any support libraries, debuggers, utilities, IDEs, and so forth. CL, msvcrt, and LINK are probably similar.
Viasfora!!! also dark mode + change the highlight color of parentheses to something that stands out. Disable intellisence + turn off all the annoying reformatting. 
And you can get it smaller than that, too. They should really enable NTFS compression by default on the MSVC directories, and they should use symlinks to avoid duplication of objects.
 const auto result = func(); (void)result; 
I think it depends a lot on the specific project, too. MSVC at least used to not be able to inline away a trivial `std::accumulate` over constants (is that /u/STL's job or an optimizer dev? I'm guessing the latter since it couldn't optimize away a specialized function, either), whereas g++ and Clang handled it fine. Stuff like that can have real impacts. My cell simulator (bytecode-driven evolving life simulator), which is designed to be embarrassingly parallel and as fast as possible (it can take billions of ticks to see anything emerge that is interesting), is pretty sensitive to compiler flags (the lack of control CL gives over optimization hints hurts there a lot), and gives pretty different performance under all compilers. Still consumes about 90% of my CPU time on 8 cores, though.
I can honestly barely live without Resharper C++. Highly recommend it. It costs a bit though...
Cool, first time I hear about x32 and realize it's its "own", new architecture - not to be confused with x86. For everybody else that didn't know: https://stackoverflow.com/questions/7635013/difference-between-x86-x32-and-x64-architectures Thanks!
I've never found such discrete syntax coloring that useful. I mainly use it to help distinguish scopes, expressions, and symbols. Maybe my brain just isn't wired correctly for it. You could exchange all the colors, and it wouldn't impact me. Except comments. They have to be green.
`compile_printf`? ^^^`co_printf`
If you don't mind having to implement relatively simple Windows/POSIX implementations, I would *strongly* recommend using memory-mapped files as the backend.
They can be even when opened, as on some systems, file locking is just a hint. Windows can lock files (and is often incredibly annoying about it). File locking is very broken on Linux.
Check this library out! https://www.reddit.com/r/cpp/comments/9x4jde/announcing_leaf_a_new_error_handling_library/?st=JRCNRHM4&amp;sh=e0897293
It comes in the installer?
Can you make that last one available somehow? Code release, in the marketplace, etc...
Hm. I'll see what I can do over the weekend.
They both can only return a single expression. You cant' do `return pack...;` if that is what you mean.
Plenty of Windows C++ in the games industry! It's the primary combination :)
It's not an architecture, but an ABI. x64 with 32-bit pointers, effectively.
Same here. Ones you start and learn using vim for programming you are going to be much more efficient at programming. I struggle with the inefficiency whenever I type at a colleagues computer. I have had people ask me what plugin I was using when they see me use macros or just the search function, once I tell them they usually just say ahh in a disappointed way :(
Juce, FLTK, nanogui 
The big problem with that library is that it uses it's own weird markup language to do layout for no reason. That makes it a nightmare to layout components correct. Juce basically lets you make a kd-tree with min, max and ideal sizes. 
AFAIK you only need to do that if you intend to link statically against QT. &gt; (1) If you statically link against an LGPL'd library, you must also provide your application in an object (not necessarily source) format, so that a user has the opportunity to modify the library and relink the application. [GPL](https://www.gnu.org/licenses/gpl-faq.en.html)
It is. And it is really good. I have been a professional C++ developer for over 25 years - QT is one of the best libraries I have ever used.
It seems like a workaround for the issue yes, is it actually solved? That remains to be seen. It wouldn't help if you run out of memory before debugging because you have Intellisense + Visual assist and you've left the app on for a while. 
What 64 bit backend? 
Didn't know about it. Looks promising!!
üëèüëèüëèüëèüëè!!
Yeh, I have my own, quite extensive, UI framework as well, with dialog editor and all that. But it's not for the weak of heart. Actually, some years back I held my nose and replaced my old one, which was completely my own custom windows, with a new one that wraps the standard controls. Both approaches have their pros and cons, pick your poison. My touch screen system uses a purely graphical scheme, like yours. But that has its own challenges. When you really do HAVE to use a real window for something, it's going going to be on top of everything else, no matter where it is in the z-order. &amp;#x200B;
Try asking this question in /r/learnprogramming or /r/cpp_questions.
Tbh, I'd like to have both behaviors under different names or via an argument to nodiscard. I would use the MSVC style one 99% of the time, but the rare case where the warn_unused behavior is used can be a useful indicator that you need to think more about what you're doing.
Happy cake day 
15 minutes of fame!
Youre using GTK. You're not making your own GUI like you stated.
JUCE
Sorry if I'm mistaken -- isn't C++/WinRT a language projection for WinRT? [The wikipedia entry](https://en.wikipedia.org/wiki/Windows_Runtime) seems to imply that WinRT can exist without UWP. I do wonder about the usefulness of WinRT in that scenario though...
Very neat. I wonder how if any package maintainers are doing these sorts of optimizations for pre-built software.
[Here you go. ](https://stackoverflow.com/questions/19820718/how-to-make-visual-studio-use-the-native-amd64-toolchain)
That is trivial to fix. Just `struct mut&lt;T&gt;{mutable T t;}` and add set dressing.
On Windows I tend to use Win32 controls and plain old GDI directly. Yes, I'm that kind of a masochist.
Linux was considering removing x32 because nobody uses it: https://lwn.net/Articles/774734/ (I don't know the current status)
Yeah, I've heard. Nobody uses it because general distribution support is low and it's difficult to use with the toolchains. I tried to build some parts of the ecosystem targeting x32, but I just couldn't get gcc/ld to play nice.
Minor terminology correction: the toolset consists of the compiler and libraries, and the compiler consists of the frontend (parses C++, implements cool features like templates) and backend (optimizes and emits assembly/object code). For MSVC, the frontend is C1XX (ships as c1xx.dll) and the backend is C2 (ships as c2.dll, also known as UTC). (cl.exe is the "compiler driver".) People who build compilers also talk about three architectures: build (where the compiler itself is built), host (where the compiler binary will run - the programmer-user's machine), and target (where the binaries generated by the compiler will run - the end-user's machine). Here, you're referring to the 64-bit hosted compiler, not just the backend. (Of course the whole compiler is "backend" in a general sense, if you consider the IDE as "frontend", but those words are never used like that among implementers.)
That's the compiler backend's job, although the libraries can sometimes help or hurt by structuring our code in various ways. The backend team now has a dedicated sub-team working on "modern C++ performance", including things like optimizing STL algorithm calls better, and the libraries team is working with them, to prepare test cases and understand how to write our code in a more optimizer-friendly way. We do a lot of work to emit efficient codegen, including extensive metaprogramming in functions like `equal()` and `copy()`, but there are always areas where we're working on improving.
This characterization of MSVC's rationale is absolutely correct, and it's why we've marked 3000+ occurrences of `[[nodiscard]]` in our STL headers, with amazingly successful results. (Great bugs found, with virtually zero false positives.)
How does it compare to crow? 
I ran out of time this week to look into this - /u/TartanLlama, could you ask either Phil or the WinSDK team?
i just stated that the only tool i use is an editor. nobody should ever try to write a gui with just C++ (and the STL). OP asked about glade i figured the question is about tools that help with developing gtkmm. If it's about general libraries to use my answer would be different - it would be: gtkmm or qt. 
Hope this will be made consistent with lambda auto parameters where auto means passing by value and &amp;&amp; means forwarding reference. Otherwise real madness. Also why not make template parameter of std::forward defaulted to decltype(arg)? This way we don't need fwd.
Productivity Power Tools Git Diff Margin
Crow is a very good framework, but Drogon provides more flexible routing and more thorough decoupling. You can try it according to the wiki.
Ah ok. Confusion by all parties. :)
IIRC the Microsoft linker folds binary-identical code when "COMDAT folding" is enabled.
Yeah, it does it in a way that violates the standard unfortunately by giving two distinct functions with identical binary representations the same address and this results in subtle bugs. GCC and clang do it in a standard conforming way by padding distinct functions that are binary-identical with no-ops so that the address is different, but the instructions end up being the same.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ajtcxc/i_know_several_programming_languages_except_for_c/eeztrbq/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;by padding distinct functions that are binary-identical with no-ops so that the address is different That's interesting, so the no-ops come at the beginning? FWIW, the feature can be disabled in the MS linker when needed, e.g. for profiling.
Fun :)
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ajtnzm/c_gui_development/eezuqzr/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, but games are completely indifferent to this WinRT stuff.
Because std::forward is a function and that is how function templates work. It has no way of getting the type of the arg from another context. The declaration syntax will get ironed out. That's why I asked people to ignore the `auto` thing.
Is it normal that compiler does not inline a call to `std::basic_string&lt;...&gt;::c_str()` function in `-Ob3` mode? 
I use the following for mercurial, git should be similar [merge-tools] vsDiffMerge.executable=&lt;path to VS&gt;\Common7\IDE\CommonExtensions\Microsoft\TeamFoundation\Team Explorer\vsDiffMerge.exe vsDiffMerge.args= /m $other $local $base $output "Other Head" "Local Working Directory" Base Output vsDiffMerge.gui=True vsDiffMerge.diffargs=/d /t $parent $child [extdiff] cmd.kdiff3 = cmd.vsdiff = vsDiffMerge opts.vsdiff = /d /t I googled [this](https://blog.dudak.me/2016/using-visual-studio-as-diffmerge-tool-in-sourcetree/) up for git. VS doesn't do directory diffs, so I keep kdiff3 handy in case I need it. VS supports 3 way merges, but only shows two windows at the top (Local and Other). The bottom shows either Base or Output, depending on whether you have selected the checkboxes or not. See [this](https://jazz.net/blog/wp-content/uploads/2017/06/vsdiffmerge.png) for an example. You can edit the output before accepting the merge, with full intellisense.
If you are asking for a language change, why not ask for one that will let you get all the benefits of PIMPL without the hassle? At it's core, PIMPL is a nasty hack that we use primarily to avoid triggering accidental recompilation. We would be much better off if we could change the compilation model (not even the language so much) so that we wouldn't need that. 
One problem is that some compilers are a bit too eager to warn you about unused results even in an unevaluated context. I had a case where the compiler (GCC) was warning about an unused result in a trailing return type where I only wanted to SFINAE the function, e.g. ```c++ template&lt; typename T &gt; auto foo( T&amp;&amp; t ) -&gt; decltype( T::match(), bool() ) { return T::match(); } ``` https://godbolt.org/z/OQEnaD It worked when I explicitly added `(void)`, but I think that `[[nodiscard]]` should generally be ignored by the compiler in all unevaluated contexts. I think I should file a bug report against GCC for that :)
Yes but... Nanogui seems interesting but latest commit was in april. To use Juce you must be willing to pay. 
I find distinguishing between global, local and class variables at a glance to be very useful. Lot of coding standards require member variables to prefixed with `m_` and global variables to be prefixed `g_` or something similar. Using colors for this is far superior IMO, and removes the need for the ugly prefixes. Other colors are less useful, still convenient. See the recent controversy over terse concepts syntax. Just color template functions and concepts differently, and the whole controversy goes away.
Any Idea how many of those target c++20?
Top 10 contributors! 10 | Corentin Jabot 8 | Casey Carter 7 | Michael Wong 6 | Richard Smith 6 | Marshall Clow 6 | Jared Hoberock 6 | Antony Polukhin 5 | JF Bastien 5 | JeanHeyd Meneide 5 | Barry Revzin 
So [P1481R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1481r0.html) still doesn't allow constexpr reference to local variables: void f() { const int x = 42; const int&amp; r = x; // r can be used in a constant expression constexpr const int&amp; r2 = x; // error: bad initializer for constexpr variable } I think this can be fixed by relaxing the rule in [\[dcl.constexpr\]/9](http://eel.is/c++draft/dcl.constexpr#9). Actually, what about renaming _core constant expression_ to simply _constant expression_, and moving [the additional requirements](http://eel.is/c++draft/expr.const#8) to places that really need them? (IIUC only the requirements of template arguments and the definition of *odr-use* need these rules. Other [manifestly constant-evaluated](https://en.cppreference.com/w/cpp/types/is_constant_evaluated) expressions can only have intergral or boolean types.) This should make it easier to learn the definition of *constant expression*.
Perhaps in theory but I don't know of any actual way how you could use it outside of a UWP context. There's no way I know of to call out to Win32 for example. As that wikipedia entry says, it is the replacement for Win32. 
Hmm nice, thanks! I might give it a try. I really like my merges with three windows at the top though. Too bad VS can't do that (yet?).
ahh, gotcha.
The doc number for *Response to ‚ÄúFibers under the magnifying glass‚Äù*, Nat Goodspeed, Oliver Kowalke (P0886R0) seems incorrect and goes to *The assume aligned attribute*, Timur Doumler. (link is also broken).
P0443R10 link is broken and points to P0443R1 with 0 not being part of the hyperlink.
The example for the array with size param is wrong or at least incomplete: It does not specify the padding which means it runs into UB and in practice crashes when optimized.
&gt;So P1481R0 still doesn't allow constexpr reference to local variables: That's by design. `constexpr` references to objects without static storage duration are weird, since the reference would always refer to another object.
Which one is the joint modules proposal targeting C++20 ?
Aren't non-`constexpr` references that are usable in constant expressions weirder?
I want fmt in c++20.
&gt; `constexpr` references to objects without static storage duration are weird, since the reference would always refer to another object. Well it's arguably weirder (in the sense that it breaks the intuition that "`constexpr` means usable in constant expressions) if this is an error: void f() { constexpr int x = 42; constexpr auto&amp; r1 = x; int a[r1]; } ... while this is not: void f() { constexpr int x = 42; const auto&amp; y = x; int a[y]; }
Not sure if satire...
The standard is ambiguous; it states two pointers can compare equal if they have the same address, and never formally restricts functions from having or not having the same address.
[P1337](https://wg21.link/p1337) lol :)
So basically more sane macros?
It c4m3 from the future to save C++!
Is qt creator as slow for you as clion?
I'd rather not, honestly. Rather than investing time and effort into growing a large `std` library, which will in all likeliness become a graveyard of obsolete ideas^1 ^2 , I'd much rather said time and effort was redirected into a unified build and a unified packaging descriptions to make using 3rd-party dependencies a one-liner. This would allow the best implementation to rise, evolve, etc... ^1 *Looking at other languages, the Python Standard Library is often described as ["Where Modules Go To Die"](https://news.ycombinator.com/item?id=3913182).* ^2 *Or in C++, one is invited to look at the `std::istream` and `std::ostream`. Their performance is horrendous, they support formatting in clunky ways (some flags are sticky, others are not), ...*
That is a joke, right? `57d` isn't even a valid identifier.
&gt; P0912R4: Merge Coroutines TS into C++20 working draft Third (?) time's the charm?
Yes :) look at the date and how the paper number relates to the proposal.
What‚Äôs next? std::3dengine? This has no place in the standard library. I hope reason is not completely left the committee to accept this.
Looking at how modules evolved into another mess of compromises and backward compatibility, I don‚Äôt think any time or effort would produce acceptable results. Too much politics and corporate influence.
I want fstrings!
Ackchually, you might want to start writing `decltype(void(T::match()), bool())` anyway. The cast to void defends against `Meow T::match()` where there exists an overloaded `Meow::operator,(bool)` that could mess with your return type computation.
Is it here? https://www.reddit.com/r/cpp/search?q=visit&amp;restrict_sr=on&amp;t=all&amp;sort=new
Hey, there are some basic differences between those data structures, that are related to their layout in memory. &amp;#x200B; Vectors can be seen as resizable arrays. Elements are contiguous in memory, and accessing a random element in it is O(1) (just a matter of arithmetic between array begin and a offset). &amp;#x200B; Lists are node-based data structures. Each element of it is: template &lt;typename T&gt; struct Node { T val; Node\* next; Node\* prev; }; This means that it contains pointers to elements, hence their layout in memory may be more spread. Also, as you can see, there is a memory overhead (2 pointers) to represent a single element. &amp;#x200B; It is said that each data structure have pros and cons, depending on their usage. For instance inserting an element in the middle of a vector, is considered O(n) and in the middle of a list is considered O(1). Take a look at stl reference for containers ([http://www.cplusplus.com/reference/stl/](http://www.cplusplus.com/reference/stl/)). Use them, benchmark and take your own conclusions.
A vector points to a contiguous block of memory for its elements. A list is a node based structure. It points to a node, which has data and points to the next node. A list is not contiguous, the "elements" can be all over the place in memory in any order. Think of it like queuing for something. European influenced cultures (especially western) when they queue form a physical line one after another. Compare that to a common method used in Japan, where you enter the shop and ask who's last. You only need to remember that you go after that person. Doesn't matter who else is in there. 
Just one more thing... You mentioned "Alongside with classes" and I don't quite understood it correctly. Maybe use them as member variables? struct S { std::vector&lt;int&gt; my\_vector; std::list&lt;int&gt; my\_list; };
`std::vector` has a dynamic array inside of it, while `std::list` is implemented as a linked list, you can look these up if you don't know what they mean. It's worth noting that performance-wise, when you have to store a bunch of the same data in a class or elsewhere, you should almost always (unless you really know what you're doing) go with vector, due to how CPUs and caches work (look up locality of reference if interested).
Why not just make the function accept a constexpr argument?
But how would you teach C++ without an audio API?
How about std::webbrowser? Oh wait...
Actually pretty much everyone is indifferent to WinRT.
https://stackoverflow.com/questions/2081640/what-exactly-do-u-and-r-string-flags-do-and-what-are-raw-string-literals
I like the `owning_ptr` rationale. Since non-owning should be the default usage of `T*`, it should also be the less cluttered one.
/r/cpp_questions
Additionally gcc shows some really poor interaction with \`\_\_attribute\_\_((warn\_unused\_result)) \` and function templates: [https://gcc.godbolt.org/z/lVjh7H](https://gcc.godbolt.org/z/lVjh7H) clang supported it in much more convenient manner for some reason. Also clang supported it on classes which has also became part of nodiscard.
I've used to represent "possibly null pointer", and reference\_wrapper to represent "non-nullable pointer" in containers in the past, with neither implying any ownership. It was just a little semantic hint to check for null. In this way, I'd at least like to see such "nullable" or "non-nullable" hint types in the standard. It's impossible to truly ensure this, and it's trivial(ish) to make your own implementations, but I'd just like to see something like that in the standard so it becomes idiomatic.
Here is the quick summary. `observe_ptr&lt;T&gt;` is a vocabulary type of `T *`. It was even called `the world's dumbest smart pointer` in the proposal. It does not own a pointer so it do nothing on destruction. The motivation is, these vocabulary type makes code readable Stroustrup argues that: 1. We have 50 years of `T *` notation experience. 2. `T *` will never be deprecated no matter what. 3. There are billions of existing code 4. `T *` is less verbose than `observe_ptr&lt;T&gt;` 5. ABI problem 6. template slows down the compilation. 7. performance penalty on unoptimized build. So this proposal remove the observe_ptr from Library fundamentals V3.
There is even an idea which make all function `constexpr` on default as we close even more gap between constexpr and non-constexpr function.
At the very lowest level, audio i/o is highly uncontroversial. In fact, it's *extremely* similar to low level socket or file i/o, or even bulk math. Most important, nothing has changed in at least a decade, so it's ripe for standardisation at that low level only. Some of us are working behind the scenes to prepare a unified low level i/o framework for all low level i/o of any kind. Socket, File and Bulk Math are working this. I expect we'll reach out to the Audio authors and see if they're interested in joining. The gain would be that Ranges, or your choice of game engine, can be fed some arbitrary low level i/o implementation and it can introspect how to speak to it properly. What happens above that should not be standardised presently. But where we'd like to get to is zero copy, deterministic, DMA-friendly universal scatter-gather i/o in C++. I find that an eminently worthy addition to the standard library, especially as any third part code can participate as a input source or output destination if they meet the protocol.
Does anyone know if the I/O portion is planned to be proposed afterwards?
I really dislike "we shouldn't change because we've done things this way for so long" mentality. It's not even an "it ain't broke so don't fix it" argument.
Smart and pragmatic man. I fully agree.
It might not be submitted because there's a bunch of in-flight module papers, some of them with the author of the Merging Proposal to IS on them.
Nice write-up! Thanks!
What's happening now is the Chairs and reading papers and they decide what they will prioritize. Big-ticket items and items specified by the Direction Group as important get focused on. The rest of us send e-mails to the reflector debating for (or debating to knock down) certain papers for C++20. I've already sent 3 such e-mails, and I'm on the edge about sending the fourth (p0330, Literal Suffixes. Mostly because it was denied a long time ago and its a simple paper with an easy implementation).
Well, allow me to deviate from general opinion: I think it would be a good idea. In the end it's just another form of IO. We already have support for text IO and file IO, so why not audio IO? However, I'd also argue that it is not more important than network IO. 
This one? https://www.reddit.com/r/cpp/comments/aapa7g/stop_reimplementing_the_virtual_table_and_start/
Is there a place in your universal IO framework for serial, USB, Bluetooth, card, etc.? Have you considered 3rd-party extensibility: would it be possible for a manufacturer to add seamless support for industrial devices I wouldn't immediately expect in the standard, like GPIB, MIL1553, spacewire, canbus, ...? 
&gt; But where we'd like to get to is zero copy, deterministic, DMA-friendly universal scatter-gather i/o in C++. I find that an eminently worthy addition to the standard library, especially as any third party code can participate as a input source or output destination if they meet the protocol. Generic I/O with other devices (no matter what they are) over available buses in a cross-platform manner, if possible, would be a nice addition. 
My most wanted for C++20: PR0429 and P1222: A Standard flatmap/Standard flatset - Very important for data oriented design/cache aware data structures. P0847: Deducing this - This is such a great paper. Would make life much easier for library writers and even enable recursive lambdas! P1035: Input range adaptors - Very useful tools for working with Ranges. P0593: Implicit creation of objects for low-level object manipulation - AKA `std::bless`. Yes please. And all of Barry Revzin's papers about &lt;=&gt; (P1185, P1186 and P1188). Please don't ship a broken &lt;=&gt; or it will never be fixed.
To my knowledge yes.
&gt; I'd at least like to see such "nullable" or "non-nullable" hint types in the standard. I think the only use case where you'd want a non-nullable pointer type instead of a reference is if you store pointers inside a class, but then we might be better off with something that let us change a reference in a class ?
That‚Äôs the one! üòÅ thanks! The keyword I didn‚Äôt have was ‚Äúdouble dispatch‚Äù.
So we now have four coroutines proposals: - Coroutines TS ([p0912](https://wg21.link/p0912)) - active. - Core Coroutines ([p1063](https://wg21.link/p1063)) - active. - Resumable Expressions ([p0114](https://wg21.link/p0114)) - inactive? last update 2015. - Symmetric Coroutines ([p1430](https://wg21.link/P1430)) - active, new.
Yes, as above I mention I've used `std::reference_wrapper`, but that's more for containers/tuples. Non-nullable just helps with ownership semantics and further clarifies when it's safe to forgo null-checking overhead.
I think there is a proposal for a owning ptr with a deep copy which, with unique and shared ptrs should have all the use cases covered
I'm going through the docs now, and they are fantastic. I'm at section 4 and so far the only thing I would like covered in slightly better detail is an example of the dependencies. Perhaps a simple command line installing the dependencies on Ubuntu or Fedora. I'm not in a good position to attempt at myself right now. So just more reading.
A super majority of developers who use C++ list "existing codebases" as a reason for using the language for development. Thus everything needs to consider old code.
This is a reason for backward compatibility. Adding semantics does not break backwards compatibility.
&gt;I'm going through the docs now, and they are fantastic. I'm at section 4 and so far the only thing I would like covered in slightly better detail is an example of the dependencies. Perhaps a simple command line installing the dependencies on Ubuntu or Fedora. &gt; &gt;I'm not in a good position to attempt at myself right now. So just more reading. [Third-party lib installation](https://github.com/an-tao/drogon/wiki/third-party-installation), This section may be helpful to you
There's also the notion of "`*` is potentially dangerous" when you see a `*` anywhere in some codebase. You basically do not know is it a "modern" codebase that 100% sticks to the "non-owning is the default" rule, or not. This can be very dangerous and will not really work in practice. `*` is also very ambiguous. It could **always** be both - an owning or non-owning pointer. `observer_ptr` makes this 100% clear, it is always non-owning.
That‚Äôs a shame. I find it useful for pointers to long-lifetime "anchored" objects that won‚Äôt move (like resources loaded at the beginning of execution), and then I use raw pointers to pass around in parameters to represent temporary short-lifetime pointers that shouldn‚Äôt be saved past the scope of that function.
r/programmerHumor???
They are smart in the same meaning a phone is smart. They don't inherently have intelligence, they are simply a tool with more convenience then the "not smart" version. If an idiot uses a smart phone in a dumb way, that's not the phones fault. Same with smart pointers.
Adding differing semantics has a cost of transferring existing code or dealing with two incompatible systems. This adds to the feature cost and should be considered.
Just because it doesn't technically break anything does not make it a good idea!
Yes, all I've stated is the reason I dislike removing things, not to conflate it with reason for *adding* things. 
It's not similar to socket and file i/o. All OSes provide different API for audio, completely different. Some even provide several APIs. Don't know if Linux and BSD even has standard audio API. Audio is fairly complicated thing. Network and file IO are trivial because OS already abstracts everything away leaving programmers with POSIX interface on pretty much all OSes, even Windows. The effort to implement network and file IO in the standard library is much lower. &amp;#x200B; And audio actually changes and evolves, compared to network and file IO. For example, take spatial audio. Windows recently extended WASAPI to support it. How would C++ deal with this? Would we have to wait several years for that to get into std? Either std::audio would provide something very simple to output things like audio notifications. Or something very complex to cater for both current and future needs and expect everyone to wait years before something new could be added into it. And we didn't even took into account game consoles and custom DSPs like TrueAudio. Either way, I don't see it getting used in any serious application. Much better to stick with well known framework that constantly evolves with the rest of the world and supports all platforms, both PC and consoles. I think std::audio would be just wasted effort. 
I was missing a keyword. Thanks though!
You might want a consteval function with no arguments.
I've never built something bigger than a few files in QT creator so I can't comment too much. It seems very snappy for that size, but I'd prefer Xcode or Clion for small projects... mostly just because they are what I am used to. A lot of people seem to like QT creator though. At the moment, I think Visual Studio is probably the best platform for handling large C++ projects though. I don't use it, but my previous company used it for their core software which was absolutely massive. I was planning on porting a major project to QT creator, but it couldn't deal with my CMake files for some reason. I Couldn't figure it out quickly and didn't have time to dig in since all the other IDE's had no problems with the particular CMake files. CMake works pretty good and is reasonable (well just not horrible) to work with if you stick to the modern Cmake conventions, but since there are no CMake IDE's, it is easy to muck things up in ways that aren't evident or easy to debug. And for whatever reason QT couldn't cope. 
How would that be different from a normal constexpr function in that case? Maybe I am missing something...
What are you suggesting then? Change the behavior, and therefore breaking all existing code that makes use of it? If the C++ committee was going to do that, they'd remove a whole hell of a lot more than just changing `observe_ptr`.
java people that infest those waters would not understand 
That's pretty toxic, my dude
&gt;when you see a * anywhere in some codebase. You basically do not know is it a "modern" codebase that 100% sticks to the "non-owning is the default" rule, or not. Speaking from practical experience, IMO this is not really an issue. Usually you know the wide practices applied in the codebase you're doing work on. A) If you work in a legacy codebase, you *know* that some T* are non-owning and some are owning - this is of course bad, but adding observer_ptr&lt;T&gt; to the standard is not going to change this automatically. This codebase needs manual work either way to transcend to better practices. This manual work might as well be adding unique_ptr&lt;T&gt; owning_ptr&lt;T&gt; on the pathological owning T*. B) If you work in a non-legacy codebase that follows good practices, then you can simply assume that any T* is non-owning. It's very obvious if someone starts putting in owning T* in a modern codebase as it incurs naked new/delete. this is caught straight away in code reviews. C) If you work in a codebase that is ATM transitioning from legacy -&gt; modern, then you can put in active work into searching for new/delete expressions and converting those to unique_ptr/value-types and this will cascade, forcing you to update relevant code. Here it could be potentially useful to at least temporarily make use of a non_owning&lt;T&gt; typedef, along the one that Bjarne proposed, as a way to "cover ground" as you modernise. This can be either kept/discarded later. In none of the above would a full on observer_ptr&lt;T&gt; be particularly useful IMO.
Please don't put words in my comment. It was a simple comment--I said what I meant and that is all. I never said anything about breaking existing code.
Nice, that's exactly what I meant. Those are pretty easy to install dependencies to, often for things like this there's at least one that has to be downloaded and manually compiled or some such nonsense.
&gt; I really dislike "we shouldn't **change** because we've done things this way for so long" mentality. The conversation is about removing `observe_ptr`, you argued in favor of "change". What change could you possibly be suggesting other than either: a) Removing it (breaking legacy code) b) Changing its behavior (breaking legacy code)
verbose_ptr
Why is this getting downvoted? It contributes to a discussion that is worth having, and provides the first actually good argument I have heard for `observer_ptr`. Differentiating between the two might be worth doing, just as differentiating between owning, and non-owning pointers, and this is something `observer_ptr` actually achieves, and it prevents accidentally passing a `T*` to a function expecting an "anchored" object. Whether such a pointer should be in the standard is worth discussing, and so is whether `observer_ptr` accomplishes that goal, seeing as it is typically marketed as an all out replacement for raw pointers, and that would certainly tarnish peoples perception of it, if it were to be standardised.
Which spell checking plug-in do you use? I was looking for one that can spell check PascalCase / camelCase / snake_case identifiers, by splitting them up.
Stroustrup quite obviously doesn‚Äôt have that mentality. All he does is consider that it‚Äôs a change as one reason amongst many to drop this idea. This is like if I said, ‚ÄúYou shouldn‚Äôt do that because it costs money and is boring,‚Äù and you responded by saying, ‚ÄúI really dislike this ‚Äòwe shouldn‚Äôt spend money‚Äô mentality.‚Äù You can‚Äôt cherrypick one item out of a list and act as if it was an argument made in isolation. 
It does enable a workaround for that: ```c++ #include &lt;tuple&gt; template&lt;typename... Consts&gt; class Constants { std::tuple&lt;Consts&amp;...&gt; t; public: consteval Constants(Consts&amp;... cs) : t{std::forward_as_tuple(cs...)} {} template&lt;typename... Vars&gt; constexpr auto operator()(Vars&amp;&amp;... vs) noexcept { return std::tuple_cat(t, std::forward_as_tuple(vs...)); } }; #include &lt;cstdio&gt; int main(int argc, char *argv[]) { std::apply(std::printf, Constants{"%d\n"}(argc)); // OK // std::apply(std::puts, Constants{argv[0]}()); // error } ```
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ak0y0z/i_cant_understand_listsvectors_and_their_use/ef12tfw/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I looked into this and it seems like it will cause VS to use a 64 bit compiler and linker, which is rather nice (though I have no idea why this wouldn't be the default option), but I don't think this will help with the IDE process itself running out of memory/address space. 
Cross-posted from my message to LEWG: --- I would like to see the trend of "paper first, implementation later" reversed, in particular for library-only solutions. std::audio is a perfect example of a library that can be written as either its own independent offering, or part of a collection (including but not limited to Boost). Users get a benefit without the cost of committee time. They also get a faster turnaround, no need to wait around for the entire planet to vote yes on a feature, and then wait for every implementor in the world to duplicate the effort to get it onto their platform. In the past I have done significant work in the JUCE (&lt;https://juce.com/&gt;) community, publishing a number of open source components for working with audio and mentoring other open source authors using JUCE. I have hands on experience working with digital audio workstations, both as a developer (authoring VST plugins) and as a user (producing recordings and operating virtual instruments). My DSPFilters library comes with a live demo that uses JUCE: &lt;https://github.com/vinniefalco/DSPFilters&gt; I also have an example program which shows how to mix audio in a real-time thread: &lt;https://github.com/vinniefalco/SimpleDJ&gt; (These programs have not been touched in a while and may be suffering from uh... some bit rot, caveat emptor) I have read through p1386r0 and what follows is my feedback. I will proceed from the top of the paper to the bottom, quoting text as needed and responding to it inline. --- 1.1 &gt; "Wouldn‚Äôt it be great if the basic functionality of talking to your sound card would come for free with every C++ compiler, as part of the C++ standard library?" Yes that would be great but nothing of value in the standard (or life in general) comes "for free", it is just that as a user the cost has been shifted onto the vendors instead of you. This can be a good thing since it allows the efforts of a handful of specialists to become leveraged for everyone to use. However it is not without cost. In addition to the cost paid by implementors, when a proposal is merged there is a hidden tax paid in perpetuity by everyone participating in the committee. That tax is in the form of the additional labor required to make sure that every future change is in harmony with the thing that got merged. &gt; "Throughout all of this time, PCM is the lingua franca of audio" This is true but I believe there is a more powerful statement begging to be said: "Portable interfaces to audio input and output can be made uncontroversial." Unlike graphics, for which there are radical hardware improvements made every year and new computation models coming out every few years, audio is largely a Solved Problem. With respect to getting audio samples into and out of a program, there just isn't that much API surface area needed. The complications of hardware acceleration simply don't exist in audio: sample rates top out around 192K for high end, and around 48K for consumer with no pressing need to ever improve that due to the limits of the human auditory system. 1.2 &gt; "It [C++] is also a language which lacks library support for many fundamental aspects of client computing. If C++ is to be a language for the client as well as the server, it needs to complete its HCI support." C++ needs HCI support but it does not follow that such support must exist in the standard library. 1.3 &gt; "Consider that a hypothetical Boost.Audio library existed with some interface not dissimilar to what is described in this paper. This is great for everybody who has access to a platform that Boost supports, and who is on a team that includes the boost libraries." It seems to me that there is a small but vocal group of companies that are allergic to anything outside of std:: (and allergic to boost:: in particular). This subgroup appears to be holding the entire standard library hostage, demanding additions to it for no other reason than "we can only use what's in std::" or "we can't use boost::." To put it bluntly, this practice needs to stop; we should not add a std:: component only because a handful of users are averse to using external libraries. Is it really the best use of the committee's time to add something like scoped_allocator_adaptor (receiving only 14,500 hits on Google) to std::? I would prefer to see this energy invested towards eliminating the actual barriers to using external libraries: modules, dependencies, and package management. &gt; "If, on the other hand, audio capabilities were a part of the standard library provided by the compiler, then the embedded chip or OS vendor could write one single high-quality implementation, ship it with the standard library, and all of their customers will immediately be able to use their existing std::audio code on the new hardware." That's not how it currently works. Each operating system provides its own non-portable abstraction (examples: DirectSound, CoreAudio). The chip maker writes the driver for each OS. Then a hypothetical std::audio, which is written against the non-portable abstraction (for example, the standard library for Visual C++ would use at least DirectSound) automatically can take advantage of this new hardware without the need for a new standard library. A Boost.Audio which is written against the API offered by Windows, will work with all new hardware that targets Windows, without modification. If Windows ever rolls out a new audio API, then Boost.Audio can optionally take advantage of that too. If Windows removes the old API, then Boost.Audio will _require_ an update. This is no different than the scenario where the Visual Studio standard library offers a std::audio: it would need an update to 1. optionally take advantage of the new API, or 2. implement the changes caused by the old API disappearing. 4. &gt; "...there is a category of programmers for whom this library is too low-level. For those people, we hope to include a suite of libraries in succession papers once this paper has been put through its paces." The implication here is that anything worthwhile *has* to be incorporated into the standard library specification. This is not a sustainable process. I am weakly in favor of std::audio, because having portable abstractions over hardware (or more correctly, operating system-specific APIs in this case) is one of the strong capabilities of C++. I also believe that going all the way low-level is the correct for std::audio. But I am strongly against an endless parade of new libraries proposed for the standard which build on std::audio and nothing else, since these new libraries being proposed could easily be made completely portable and published as independent libraries. 6.1 &gt; "The API...is a low-level ...API...lays the foundations for higher-level abstractions that can come in the future, or which users can build upon to create their own software and libraries" I am very much in favor of this model of library componentization. Standardise the lowest layer, and let the free market of external libraries satisfy consumers needs and desires by building on that component. As the external library ecosystem flourishes, only then should we decide on what established practice to further standardise. This worked great for std::shared_ptr, et. al. Note that I have taken this approach in Boost.Beast (which is similarly low-level). Conclusion An advantage of writing an independent library is that it can continue to be maintained even after it is voted into the standard. This is of great benefit to those who are not yet on C++Latest (which is most of the community) as they get access to new C++ library components even while using an older version of C++. For this reason, I feel that it is good engineering practice when authoring a library to avoid needlessly using recent C++ language or library features. In my opinion the benefit of gaining access to the larger audience of C++ developers on older versions is worth the cost of having to write out a bit more cumbersome or clumsy implementation (with exceptions of course, some libraries fundamentally require new C++ stuff). Having a larger audience of users for your library means that you will get more feedback, a better view of how the library is used, and in general this information helps make the library better over time. While it is true that there are already a number of similar audio libraries out there, all of those libraries were written from the perspective of a user and not from the perspective of a library implementor. In other words, they were not written with the goal of standardisation in mind. Furthermore, the authors of those respective existing libraries did not have the same expertise and experience with writing std-quality-C++. However, this does raise an important question. If an independent audio:: library cannot become popular and pervasive (i.e. a de-facto standard) then why would that change just because it is prefixed with "std::" (modulo non-reasons such as external-library-phobia). Note, the repository mentioned in the paper contained no code at the time of this writing: &lt;https://github.com/stdcpp-audio/libstdaudio/tree/ebdc0fd138d9d8bc1ace62e6422f5adb553ee12a&gt; Regards 
This patch has been merged on 2018-11-08.
For objects that live the lifetime of the application, why not just use a reference when passing it around? I don't really see the benefit of std::observer_ptr over a reference?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/ak3c0l/cant_figure_out_what_is_the_problem_in_the_code/ef1436x/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
But `*` is only ambiguous if `owning_ptr` and smart pointers are not consistently used throughout the codebase. The same is true for `observer_ptr`. It doesn't magically solve the ambiguity. In both cases ambiguity is solved through consistent proper use.
Why not simply create `constexpr` expressions? std::apply(std::printf, constexpr(format()), argument);
Storing references in structures complicates default initialization and move/copy (unless you use a reference wrapper). My use case here is usually "little things that move a lot pointing to big things that never move". Shared pointers are another option but those have a cost, and setting up aliases shared pointers to resources stored in big array blocks has some boilerplate.
Wish list for C++20: * [P0784](https://wg21.link/P0784) - More constexpr containers * [P1306](https://wg21.link/P1306) - Expansion statements * [P1306](https://wg21.link/P0847) - Deducing this * Modules and constexpr std::vector/std::string
As pointed out by me elsewhere here, PIMPL isn't the only use of forwarding. It's often just aggregation plus forwarding, where the aggregated classes are public ones. Obviously some sort of scheme to have fully hidden implementation classes could be very useful. But, I'm guessing that really WOULD be a massive change, compared to which a forwarding mechanism would be a trivial thing. &amp;#x200B;
The consteval function is guaranteed not to be called at run time, the code isn't even generated. Constexpr is more like a suggestion. Presumably that may become more important with future compile-time proposals. As for your suggestion, I'm not sure a constexpr argument would really forbid the function from being called at runtime.
There is a missing reason for having observer_ptr: `obeserver_ptr` is to `shared_ptr`, `unique_ptr`, and `T*` as `string_view` is to `char *` and `string`. ie you should be able to safely convert from shared/unique to observer, so a function that uses a pointer temporarily, should take an `observer_ptr`, marking it as safe for any smart pointer to be passed in. No need for calls to `.get()`, which makes code review faster - calls to `.get()` are typically spots where you need to check what is going on, ownership, etc. I assume this wasn't mentioned in the paper because I haven't finished my paper :-( https://github.com/tvaneerd/isocpp/blob/master/observer_ptr.md 
I think it is fair to expect people to upgrade their codebase if they want new features 
All true, but I thought the main sell was tooling to tell you "these * are doing ownership-like things; consider changing to owner_ptr" in order to enforce consistency.
And I really dislike "this didn't work out, but let's leave it in anyway"
A) is not that simple. You can't just add unique or owning. Most likely you actually need to add shared_ptr, because someone owns it, but it is shared all over the place. But you don't want to use shared either, because you really do want it to go away when the owner does, and leave the rest dangling - because that is what the code is currently doing, and any change, like changing destruction order, could break something. So you need something like observer_ptr to start to unravel the mess. (Of course you could just make your own, and maybe more than one, you could have `livesonlyaslongasthisfunctioncall_ptr, `iknowitisreallyownedbyfoo_ptr`, `ownedbybar_ptr`, etc.)
Yes, like `std::string_view`, observer_ptr should be used as a function param. Which is why observer_ptr should have implicit conversions from shared_ptr, unique_ptr, and T*.
Try using std::array instead of raw arrays and access values in it with array_name.at(index_num) This way you'd get an exception of you access out of array indices and not a random value. Maybe that's the issue
Forcing upgrades causes those who can't afford to upgrade to never upgrade. Think about how many instances of non-owning pointers are in a 10m LOC codebases, upgrading them all takes years, not just man years but literal years since you have other work to do. Is this feature worth 2+ years of reduced development features to get rid of implicit void* conversions?
I wouldn't call it "forcing upgrades". If you want access to new features you need to upgrade. And you can't remove features from a version or two ago. It needs to be 'old'. I think it would be fair. I would like to have a modern and clean language. Not one where every time we need a good change someone draws the "backward compatibility" card.
As I pointed out in my own reply, that is not necessarily a good idea, and most definitely not for the use case described, since a function taking a `T*`, could accidentally pass it to a function, which takes a `std::observer_ptr&lt;T&gt;`, which then stores it away: &gt; [...] I then I use raw pointers to pass around in parameters to represent temporary short-lifetime pointers to potentially moving objects **that shouldn‚Äôt be saved past the scope of that function**. I must ask you, what is the point of `std::observer_ptr`, if all it does is wrap a `T*`? Why not just use a `T*`?
I dont need someone to handle my pointers, its not C. &amp;#x200B; Smart pointers, vectors, etc, go make a new language and make them default behaviour for pointers and arrays, stop strapping them on to C.
You know the semantic of it just by reading API. You don't need guess or check the documentation / source code of called function. void do_something(T * ptr); vs void do_something(std::observer_ptr&lt;T&gt; ptr);
It would be great to add it in boost and see how observer_ptr get used in real projects. That can make it clear wether it's a good adoption for the C++ standard.
He mentioned this topic during the QA of a talk a couple of days ago in Madrid. Iirc He also mentioned (in the context of the core guidelines) that in the long term static analysis should be able to cope with this ownership issued without extra hints. Because observer and other smart ptrs are just hints for static analysis and humans. I agree 100% with his reasoning: there's no need for library hints, since you should reason about T* as a non owning ptr
BTW I'm one of the organizers of the Madrid C/C++ Meetup. We will try to upload the slides (and recording iirc) asap
What about an annotation \`\[\[observer\]\]\`? That seems like it would offer all the advantages of \`observer\_ptr\` (incl. if desired warnings on \`++\`/\`--\` and \`delete\`/\`free()\`) with none of the disadvantages (ABI incompatibility, compilation time, binary size and so on) and also make it easier to gradually convert existing codebases.
Or just write auto g() -&gt; decltype(static_cast&lt;bool&gt;(T::match())) This verifies that match can be converted to bool and also removes the warning. But still, I agree with d-frey that warning about unused results do not belong in unevaluated contexts. 
If it were a typedef (or something similar) 5, 7 and mostly 6 would be irrelevant.
Desktop apps can host UWP controls starting with Win10 build 17709.
Actually, in my use case I wouldn't want implicit conversions. Roughly speaking, I distinguish the two as follows: Use `T*`: - As parameters and locals, but never stored in structures. - When the lifetime or memory position of the object is temporary, and can't be counted on outside of this scope. Use `observer_ptr&lt;T&gt;`: - Primarily as storage in structures, or to pass into storage to structures. - When the object being pointed to will live longer than the lifetime of the storing object. - When the object being pointed to won't move in memory for the duration of the storing object's lifetime. This distinction comes up a lot with preloaded resources (sounds, images, etc.) that are packed into some sort of struct-of-array resource block, never moved after loading, and never unloaded until the end of execution (or some equivalent end state). I like using `observer_ptr` to convey "this resource will be around for as long as you are, so it's safe to store this pointer to it and use it later as needed". The alternatives are: - Raw references, which complicate default initialization and move/copy operations (the things pointing to these resources may move around in memory, so we need to move their references) - `reference_wrapper`, which can't be null (maybe this object just doesn't use any sound resource, so we need null) - `shared_ptr`, which (a) makes it difficult to point to elements of structures without aliasing boilerplate and (b) has costs in both debug *and* release (unlike `observer_ptr`) Now, all of that said, what I'm describing differs from the stated purpose of `observer_ptr` to abolish all use of raw pointers in C++. Perhaps I should rename my use case to something like `anchored_ptr` or `pinned_ptr`. But nonetheless, it's a useful distinction to make from raw pointers. Even if you don't get any actual static guarantees, it's useful to express intent.
P0114 is not a full proposal it is a proof of concept which requires further work (some of that iterative work has been done in private emails but the paper needs an update). P0114 also needs an implementation to kick around.
Hmm... questionable design choices (no Windows, no Networking TS / Asio).
As many have pointed out, observer_ptr is very useful. It tells me that this point isn't owned. A naked pointer doesn't tell me squat. I have to track down all it's usages to know its purpose. So I do not agree that it should be removed, but be able to observe any pointer. Naked pointers belong as a remnant of the past, and a rich vocabulary replace it instead.
I suppose it depends on exactly how tangled the "A)" case is, and how it is structured in general. :) For the cases I've experienced, most of the time there was one place that was the true owner and the rest of the places could be changed to pass-by-reference. I can see how this is not the case in every such codebase.
Typically if I want a guarantee a constexpr function is run at compile-time, I store its result in a constexpr variable. I kind of just assumed that was the way to force compile time evaluation. Where does my approach break in a way that requires consteval? Some templates? Void returning constexpr functions (and is a void returning constexpr function actually meaningful)?
Someone did do that. It's called C++. If you don't like it use C. Simple as that. 
`consteval` functions are for stuff that *can't* be called at runtime. Requiring every call to such a function to be inside such a `constexpr` block is very annoying.
dead_language_ptr
&gt; no Windows How is that a "questionable design choice"?
There is no legacy code using observer_ptr. It is part of a TS not the current stl.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/ak4lan/help_needed/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
How is that better than allowing a unique_ptr to be converted to a raw pointer?
nothing stopping you from making your own - the point is about the language for everyone.
but so would most of the benefits of using it in the first place
I was actually wondering that. If constexpr works with both constants and not, why not just have it always be on by default? 
Because Drogon is written using non-portable APIs. That was okay, back in 2005-ish. But in 2019? Especially with Networking TS right around the corner.
How will this interact with static_assert? It seems like it'd make static_assert more useful. 
What's your source for that? The committee seems to be operating on a "most C++ has yet to be written" standpoint; they have to pay attention to back-compat the same as any other language in active use (lest one pulls a Python3 situation, or worse a Perl6), but they aren't strictly targeting old code bases as the driving force for making (or not making) language improvements.
I think the concern is that if you change a function's implementation later to be non-constexpr-compatible, it would break uses of the function in constexpr contexts, without warning.
This article would be more helpful if it defined its terms for people who aren't Windows developers. 
Actually resharper gtest is better since it gets the test names from the source code rather than compiling and then getting the names of the tests from the binary. The google test runner is not a paid product and goes well with the Microsoft test runner. So, if you CI with the Microsoft system, then you can use the google test runner. 
There's explicit reasons that implicit `constexpr` wasn't pursued and very hopefully won't be. Namely, the `constexpr`ness of a function is part of the contract formed between the function and users thereof. Implicit `constexpr` means users can (and will) start relying on arbitrary functions being `constexpr`-evaluable based on current implementation and thus forever lock the implementation of that function into being `constexpr`-capable, even if the author never intended such. `constexpr` annotation is less about saying "this is allowed" and more about saying "I _intend_ for this to be allowed."
The extension I use only spell checks in the comments. 
Is the IDE itself running out? Out of curiosity, do the relevant binaries have LARGEADDRESSAWARE set? I was under the impression that the debugger ran in a seperate process.
[citation needed] If a codebase follows the standard practice, that raw pointers are non-owning, unless marked otherwise, then it is really easy to tell. Plenty of people, myself included, care about the performance of non-optimised builds, and using a wrapper class like observer pointer makes it worse as stated in the paper. This comment does a good job of highlighting why telling owning and non-owning raw pointers apart is a non-issue: https://old.reddit.com/r/cpp/comments/ak0vfg/abandon_observer_ptr_bjarne_stroustrup/ef0yq3g/
Apologies. I wrote backend as I figured it would be more readily understood, in a more 'stuff that actually does stuff' sense. On that note, still need to figure out why GCC thinks I'm building Canadian Cross when host, target, and build are the same...
This: constexpr int foo(int); // some function constexpr int a = foo(42); Ensures that `foo(42)` is a constant expression and is evaluated at compile time. But that guarantee is only true for _that specific call_. In particular, it does not and cannot prevent me from writing: int b = get_an_int_from_somewhere(); int c = foo(b); // clearly not a constant-expression The point of `consteval` is to allow the function writer to make the `foo(b)` call ill-formed. 
They have the same address in that symbol table, so how are they padded? I'd expect them to be slightly offset.
Conversion to raw is not safe. You don't know what `Foo *` means in terms of ownership. So `f(uniq)` may or may not be safe. Or just consider: unique_ptr&lt;Foo&gt; up = ...; ... delete up; 
Nobody is suggesting the standard do any of that. You wrap the OS facilities. Same way as you don't implement file or socket i/o yourself, you wrap the OS facilities.
I agree with that for many many proposals for the std library. (Although I think there have been versions of observer_ptr in various codebases, and it is in a TS, so there is some usage experience. Not as much as you'd get from Boost, though.)
(a) is what the C++ standard supports. The standard requires that one can convert from a pointer to uintptr\_t and back and get the original pointer. (b) does exactly what you said (reinterprets the pointer representation as uintptr\_t). The standard does not require this to do anything specific and does not say anything about the compatibility of void\* and uintptr\_t representations. In fact such a conversion can be undefined because of possible misalignment and strict aliasing violations.
I am not quite sure what your point is. Yes, if you follow the convention, that `std::observer_ptr`s are pointers to "anchored", and raw-pointers are non-anchored, then yes you can simply read the function signature, and tell whether it might store the pointer away. That was my takeaway from the original comment too (the one by Recatek). My point of my response, was that his proposal, directly contradicts the use case described by Recatek, namely to distinguish between pointers to "anchored" objects, that are expected to be available after the function call, and pointers to "non-anchored" objects, that may go away immediately after the call, and that implicit convertions to `std::observer_ptr`s directly conflict with that use case. As it turns out, I read the original comment correctly, since that point is shared by Recatek, in their follow up comment: https://old.reddit.com/r/cpp/comments/ak0vfg/abandon_observer_ptr_bjarne_stroustrup/ef1bv8c/ And just to clarify my own position: I don't believe `std::observer_ptr` is a useful type, specifically, since the commonly stated use case is perfectly handled by regular old dumb raw-pointers. The only difference is you don't need to write `T*` in your code, which I personally value negatively. The only good argument for a type like `std::observer_ptr` that I have heard, is the one stated by Recatek, and it is so because it differs from the stated intent of replacing raw pointers, and instead is used to mark an object as "anchored", which differentiates it from all the other raw-pointers, but seeing as that differs from the commonly touted use case, I believe it is better suited for a type specific to that code base (under a name `anchored_ptr` or similar as suggested by Recatek in their comment), since frankly `std::observer_ptr` is not very hard to implement.
Never happened to me with UE3, but it is a frequent issue on our team with UE4. We like to use VAssist, and we advise everyone to turn off Intellisense (which is not so easy to actually do) to save memory for VAssist. It is possible that VAssist causes the issue, but we find it is kind necessary to be productive too. 
At the standards level we only need to provide a generic discovery mechanism of OS facilities. So, on Windows that's probably WSAPI. It'll tell you what channels are available e.g. 7.1 and thus the format, the bitrate they're in and sample precision of audio expected. You feed it gather buffers to render or scatter buffers to record. You get buffer completion notifications when an individual buffer is done, so you can fill it with new data. It looks very like ASIO in this sense. What we care about, in standards, is getting Ranges et al to be able to generically work with arbitrary i/o. Ranges ought to not need to know that it's audio. It's i/o with format and layout constraints, same as any other i/o. In many ways, whether the thing we standardise can actually render audio to a real device or not is moot. What we really care about the genericity of specifying algorithms to work on audio. So, for example, to implement a HRTF, instead of the volumes of hard to parse hand written SIMD math, you could write it in generic Ranges and get within 10% of the hand written stuff. At least, that's the aspiration, and yes I know nobody would use the Ranges stuff anyway in industry. But that's the hope and goal.
Depends on what you think the benefits are. See Stroustrup's first alternative in the paper. It still has the benefits of marking the pointer as non-owning, similarly to the benefits of reinterpret_cast over C-style casts - they make it more visible. Now whether you think it's a good thing or a bad thing is a different question.
I just looked at the first generic program template, and uhh.. have you tried running these programs? do you know how pointers work? int main(int argc, const char ** argv) { puts("Usage: CProject"); for (int iter = 0 ; iter &lt; argc ; iter++) { printf("%d -&gt; %s\n",iter,(*argv + argc)); } return EXIT_SUCCESS; }//end of function main Does this look right to you?
Yeah, we have a lot of that use case too, and use references for this use case, but you are right it can be a pain storing them. I generally use std::reference_wrapper in those cases with a using &lt;prj&gt;::ref/cref so it isn't so much to type
My only interesting point is the percentage of developers that have large code bases. Given how many companies with huge code bases sponsor people to be there I don't think saying they ignore existing code is fair. How you translate your existing code that is async to coroutines isn't important. What replacement for pointers you provide however is a different discussion as it isn't purely new code.
Oh of course, and I do have one of the online implementations of it in my codebase. I just wanted to point out a case where I do find the type itself useful, even if it isn't necessarily the use case described in the original proposal.
Now build all the way up to GCC 8.2.0. Start with the first B compiler.
The way I read it, they argued *against* removing `std::observer_ptr` from the draft. I believe the quote &gt; I really dislike "we shouldn't change because we've done things this way for so long" mentality. is in response to &gt; 1\. We have 50 years of T * notation experience. and &gt; 3\. There are billions of existing [lines of] code ie, from the comment, they replied to. It would also fit with another quote from their comment &gt; template compilation time would be a real reason, though. presumable in response to &gt; 7\. template slows down the compilation. /u/Wh00ster can tell whether I am right, but I am willing to bet that I am.
`string_view`doesn't just point to a string, it can also point to a subsection of that string, without creating a copy. It allows you to do things that you simply can't with `char*` and `string`, because they need to be null teminated (`char*`) or copied (`string`). `span` is similar, it allows you to point to a section of an array, instead of having to terminate it, copy it, or have a separate size variable. `observer_ptr` doesn't add any functionality over `T*`, so I don't think it is a compelling argument.
Could wrap it in a lambda that puts the result into a constexpr auto, first.
I like your post, but I have to disagree with the following: &gt; However, this does raise an important question. If an independent audio:: library cannot become popular and pervasive (i.e. a de-facto standard) then why would that change just because it is prefixed with "std::" (modulo non-reasons such as external-library-phobia). There are many reasons, why an arbitrary open source library might not become a de-facto standard, starting with licensing, over questions of long-term support and compatibility to too many competing libraries to choose from. And even if you consider external-library-phobia not a valid reason, it still does exist. By becoming part of the standard library and thus part of a vendor's toolchain, all of those reasons vanish. It doesn't make it a better library, but it does make it a standard that will automatically see more usage, as long as it is "good enough".
The fact that there exists code that I could write that does not compile does not prevent me from writing the example I suggested. The goal is to make `int c = foo(b);` ill-formed.
Because not all functions receive arguments?
&gt; template slows down the compilation The solution is simple, let's make a non-owning, pointer part of the language. The compiler would make sure we cannot delete through it. 
Thanks for the links. I've updated my [type\_name](https://github.com/willwray/type_name) repo to add the pretty function methods - tested on latest gcc, clang and msvc. See `type_name_pt.hpp` (inline docs in header file, didn't update the readme yet). &amp;#x200B;
I like the spirit of this! But the reality is that not only does it pollute the global scope, since it's a macro it will collide even with scoped names (the same issue applies to the `min(...)` and `max(...)` macros from `&lt;windows.h&gt;`). Thanks for the post! Upvoted ;)
&gt; starting with licensing Ah yes, that is of course a valid point and I should have made it clear that when I say "open source" I mean permissively licensed. Boost and Apache licenses are great. GPL and LGPL are not. And obviously, proprietary licensing is out of the question :) You do bring up other good points. I would say, that even if an independent audio library would not become a de-facto standard, that the attempt should at least be made. Surely it would attract at least _some_ users (otherwise I strongly question the utility of investing committee time on it). The alternative to a good-faith effort of publishing and maintaining an external library as the first step to standardisation of a library-only component is this new, increasingly popular model of proposing libraries "direct-to-std" with its corresponding parallels in quality to "direct-to-DVD" video content.
Yes, you are correct. The regular C rules of prefix everything would apply for C.
&gt; That‚Äôs a shame. No, you said it's a shame, which means you think it's an overall net negative. However, you seem to have completely solved the problem for yourself with a trivial bit of code, so it doesn't seem like there's that much of a win with standarizing it - vs the list of negatives put forth in the paper.
Now I get it...
Even if the statement that most work in existing codebases is true there is no contradiction. Even existing codebases are being extended (and in small steps modernized)
How is that intent typesafe? You intend for those pointers to not not outlive their pointees, but the type doesn't make it so. Of course shared/unique_ptr aren't completely safe either (because of `.get()`) but they leverage the type system to do lots of safety work. In general observer_ptr makes deletion via observe_ptr unlikely, so I guess it helps in that way. But I think it should be used like string_view - mainly for function params.
Like the others said, but it's also worth pointing out that `constexpr` is a metaprogramming annotation, not an optimization directive. If aggressive optimizations are turned on, the compiler has the information necessary to evaluate a function at compile time and its heuristics say doing so would yield a faster binary, then that's what it will do, `constexpr` or not. (OTOH `constexpr` variables are like `consteval` functions in that they *must* be constructed at compile time).
you know what would be cool? template&lt;auto index, typename T&gt; void function(T arg) { // ... } using unique_call(auto arg) { static size_t I = 0; return function&lt;I++&gt;(arg); } but I don't think we will ever get mutable compile-time constructs.
Annotations are ignorable by a compiler. I also don't think it would be worth it. Maybe if you had enough annotations to solve all the lifetime problems, it might be worth it.
Oh no! I submitted that paper on January 4th. I must have mixed up the date format ordering. Sorry, everyone!
It will be no different than `constexpr` in that context, since `static_assert` has always required a constant expression.
What is P0593 supposed to accomplish? Is it simply a fix to a previously broken bit of the standard that accidentally ruled out large classes of perfectly fine code? 
&gt;Annotations are ignorable by a compiler. Not necessarily; `[[noreturn]]`, `[[carries_dependency]]` and C++2a [contract attributes](http://eel.is/c++draft/dcl.attr.contract.syn) cannot be ignored. Aside from that, IMO warnings are a reasonable default; incrementing or even deleting (for example if some condition is triggered that passes ownership to the current scope, or if you call `exit()` immediately after) an observer might be a bad idea, but not necessarily unintended nor incorrect. "Might be a bad idea, but not necessarily unintended nor incorrect" is IMO what warnings are for. Another advantage of warnings instead of errors is it helps for converting existing codebases; you could globally mark all pointer parameters `[[observer]]` then for each warning check that it's a false positive before removing the attribute and documenting the semantics of that parameter. But I'm not married to warnings instead of errors; my preference would be attribute-with-warnings &gt; attribute-with-errors &gt; library feature. Two other major advantages of an attribute I didn't mention: it would be compatible with C APIs, and it would aid static analysis tools with tracking ownership. &gt;Maybe if you had enough annotations to solve all the lifetime problems Well, exactly, this is a small down payment on that larger problem. One possible extension of the idea, not possible with a library feature, is to specify an object it mustn't outlive. For example you might have the prototype `const char* [[observer(this)]] c_str() const noexcept;` in `std::string`. &gt;And if you had that, I'd put it into the language proper, not as annotations. Attributes are part of the language? And they seem, when possible, to be the preferred way of adding new language features, since they don't require new keywords nor syntax.
Because T* doesn't tell you ownership semantics, and thus you can't safely and implicitly convert from a smart pointer to a raw pointer. But you can safely convert from a smart pointer to an observer_ptr, because the type system is telling you it won't be deleted.
Yeah, that "takes a T* then next thing stores a observer_ptr" saddens me. I don't think that is long-term maintainable.
I would like to say "Contract attributes are not attributes" and I think most of the committee would say the same - I've definitely heard the same from many. Of course we then went and used the terminology "contract attribute" right in the standard. :-( `[[noreturn]]` and `[[carries_dependency]]` are ignorable. If a noreturn function returns that is just UB, and carries_dependency can be ignored, you just get more memory barriers. (Also, I think carries_dependency is the thing that is broken and no one should be using? Or is that memory_order_consume, or both?) Attributes allow compilers to generate better code, but you get the same semantic behaviour without them (assuming the program was well-formed to begin with). Contracts are the exception. Which is why they aren't annotations :-) They also (purposely) break the annotation syntax - annotations aren't allowed to use `:`.
Would you be OK with shared_ptr and unique_ptr having implicit conversions to raw pointers?
You could totally have a function receiving a constexpr argument and a run-time argument, therefore being a run-time function.
I think it's a shame because I believe a pointer that fits this use case would be a valuable addition to the standard.
The intent is typesafe because if a structure stores an `observer_ptr&lt;T&gt;` and you attempt to store a parameter that you received as `T*` into it then, without implicit conversion, that will be a compile-time error. You're right in that there's no guarantee that the thing pointed to by the `observer_ptr&lt;T&gt;` will *actually* outlive the thing you're storing it in, but the intention is clear and willfully violating it can be caught early.
Sounds boring.
&gt;If a noreturn function returns that is just UB, and carries_dependency can be ignored, you just get more memory barriers. I'll alter my statement; compilers can ignore `[[noreturn]]` but a conforming program can't. And unless there's something I'm missing, that really should be an error‚ÄîI'm sure everyone would prefer the rule "attributes never trigger UB" over "attributes never result in compilation errors." I was wrong about `[[carries_dependency]]`; I skimmed too quickly over the line "If a function or one of its parameters is declared with the `carries_dependency` attribute *blah blah* the program is ill-formed, no diagnostic required." &gt;Of course, we could break the rule, and allow annotations to be "real language" (and yes, make additions easier than co_await keywords) but the committee has been purposely avoiding that. Given contracts, isn't that cat sort of out of the bag? And like I said, even if it's a "regular" attribute, there are some advantages to warnings instead of errors and quite a few advantages to attributes over library features, not the least of which is simply that it's a compromise between these dueling proposals. :)
Hmmm, yes, I want to use observer_ptr for exactly the opposite as you - I want to rename it temp_ptr or access_ptr or transient/brief/ephemeral/... and only use it in those situations. And you want the opposite. And you want to call it anchor_ptr, etc. Interesting. Naming is important. The essence of the class is "notmy_ptr". No more, no less. I think using notmy_ptr is better in short-lived scenarios where it is obvious that there are no lifetime problems. I can see using notmy_ptr in long-lived structures is a way to say "trust me, we built this system such that these lifetimes are fine, and notmy_ptr is the way we say that we've thought about it and the lifetimes aren't just a coincidence". But that still requires non-local reasoning, thus harder to maintain. I would do this with some tag on the pointer: `notmy_ptr&lt;T, App&gt;` is a pointer to T that lives as long as App does. Etc. Just so you don't need to search docs do figure out the relationships.
We probably want it to be an error to write code that expects a noreturn function to return, but I suspect it is equivalent to the halting problem. So a compiler _can_ diagnose it, but doesn't have too.
In fact, I am waiting for the new C++ standard support for networking TS. These only involve the underlying part of the Drogon framework, which is almost independent of the application interface, so the associated migration is not cumbersome. Thank you for your comments!
&gt;I don't think saying they ignore existing code is fair. I don't think it's fair either. Which is why I didn't even remotely say anything like that and in fact spent words in my prior post to say the exact opposite. :) &gt;A super majority of developers who use C++ list "existing codebases" What is your source to that claim? That sounds like you are thinking of a specific list that has been published somewhere. If so, I would like to see it because it would be both interesting and edifying. :) &gt; My only interesting point is the percentage of developers that have large code bases. If you meant that _as_ your source... then what's your source for this percentage? :)
You can wrap the function declaration in a lambda.
But, why? Even if you get this working, you're just going to set yourself up for a maintenance headache when you want to upgrade to a new version of Assimp. This altogether just sounds like a bad idea with no clear reason for why you'd bother; not wanting to generate and use an external project is a downhill battle in the C++ ecosystem. Especially when you can let a tool like [vcpkg](https://github.com/Microsoft/vcpkg/tree/master/ports/assimp) or [Conan](https://github.com/jacmoe/conan-assimp) deal with building and exporting Assimp for you. (also this is the wrong sub as this one's about the C++ standard itself and not general usage or tooling questions; maybe /r/cpp_questions though I'm not sure that's right either - best would be to go wherever premake users congregate, but I don't know where that is.)
you don't need the macro if you enclose the list in curly braces. no?
Okay, thanks for the input.
I didn't give a percentage, feel free to post anything that contradicts it. I didn't realize that "most C++ developers are working on existing code bases" needs to be defended.
The way I would do it is it's an error for a function declared `[[noreturn]]` to have a `return` statement or to end with any statement other than 1) another `[[noreturn]]` function, 2) a `throw` statement or 3) some implementation-defined or standard way to mark a statement unreachable (which would be UB if reached). So the attribute would never *cause* UB vs. leaving off the attribute.
You do realize you're criticizing a set of 10+ year old C++ bindings for a 20+ year old C library..?
Look, i checked literally half of c++ http libs, and all of them are simply TRASH. just... Straight garbage..
I guess you should check the other half then.
But why? Half is enough, these half-popular trash c++ http libs are all the same syntax wise.
&gt; I didn't realize that "most C++ developers are working on existing code bases" needs to be defended. I thought you had some cool source and I wanted to see it, not because I don't trust you or don't like you, but I just really wanted to see some studies on the topic and thought you knew something I didn't and could help me out. :) But since you put it that way: yes, I'd say that yes it _does_ need to be defended, just as _any_ claim needs to be defended and proven true before we accept it as fact. I'm not saying that you're wrong! Just that we should be very wary about being _certain_ about something which we merely _believe_ to be true. :)
Same problem. You can write a function that the compiler can't tell whether it reaches the end of the function or not. 
There are two possibilities; it reaches the end of the function or... it doesn't return!
Python generally operates at a higher level than c++, so it's normal that the syntax and libraries look more effortless to use. But at the same time, it takes control away from you. Some people like that, some people don't. Btw, what do you expect to achieve here? Cpp devs going over to nim/python because you posted a shot of an old library's documentation? Seriously, why?
Transcript?
My guy, first off i don't care about what side you guys get on, because.. I don't care, secondly regardless of their level i'm sure a cleaner syntax is possible stop making excuses for C++. And i don't care about how old the doc is at the end of the day it's still what? TRASH, simple, every other lib i looked at like libcurl or whatever they are all also what? TRASH.
Sorry, I'm not sure if this is relevant, but getting to the next step of reporting it to g++'s relevant place is intimidating, so I'd rather know if it's right first.
This is unproductive.
Shrug, you have some serious attitude problems, my dude.
What's up with your account?
Lol i just type it that way.
This does look like a bug. Here's an example without any templates: https://godbolt.org/ And here's how libstdc++ defines an `std::initializer_list&lt;T&gt;`: template&lt;class _E&gt; class initializer_list { public: typedef _E value_type; typedef const _E&amp; reference; typedef const _E&amp; const_reference; typedef size_t size_type; typedef const _E* iterator; typedef const _E* const_iterator; private: iterator _M_array; size_type _M_len; // The compiler can call a private constructor. constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) { } public: constexpr initializer_list() noexcept : _M_array(0), _M_len(0) { } // Number of elements. constexpr size_type size() const noexcept { return _M_len; } // First element. constexpr const_iterator begin() const noexcept { return _M_array; } // One past the last element. constexpr const_iterator end() const noexcept { return begin() + size(); } }; The relevant line is `typedef _E value_type`. So `value_type` of `const std::initializer_list&lt;T&gt;` should still be `T`, not `const T`.
C++ already does have a syntactic construct for non-owning raw "pointers", and these are references. When nullable is a concern, there's `optional&lt;reference_wrapper&lt;T&gt;&gt;`. So instead of declaring a function to take `void f(observer_ptr&lt;T&gt;)` you declare it instead to take `void f(T&amp;)`. 
I‚Äôm green when I speak with my moderator voice.
Oh.
But what if it stores that observer\_ptr, extending its lifetime beyond the lifetime of the shared\_ptr? I'm rather have a construct that guaranteed that - by the time the function returns - there are no references left to the pointer or its parts. Basically, 'this pointer is used in a function programming style' promise. I understand the intent of observer\_ptr but its too permissive for me.
https://stackoverflow.com/a/32515251 https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63149
your first example, const std::initializer_list&lt; int &gt;::value_type s = 0; evaluates to const int s = 0; so it's not surprising that it doesn't compile
&gt; Consider that a hypothetical Boost.Audio library existed with some interface not dissimilar to what is described in this paper. This is great for everybody who has access to a platform that Boost supports, and who is on a team that includes the boost libraries. But, let us say that a new embedded chip or a new operating system comes on the market with a new and different API for communicating with the audio hardware. How do users of a hypothetical Boost.Audio library access the audio hardware? The problem is that Boost.Audio does not support this new audio hardware out of the box. Users of these new systems must either modify Boost.Audio to support their hardware (hopefully submitting a patch to Boost in the process), or they have to abandon their use of Boost.Audio for the unsupported platforms and split their codebase. If, on the other hand, audio capabilities were a part of the standard library provided by the compiler, then the embedded chip or OS vendor could write one single high-quality implementation, ship it with the standard library, and all of their customers will immediately be able to use their existing std::audio code on the new hardware. &amp;#x200B; In my experience, if you are going to wait for the embedded chip and new operating system vendors to implement a fully compliant C++20/23 library, you are going to be waiting a long time. If a new chip or new operating system comes around, I would bet that boost::thread and boost::atomic will support the platform, before a vendor written standard library. In addition, if Boost Audio is really popular, any vendor that would have implemented std::audio, likely would have already contributed that to Boost Audio. A vendor that won't contribute a boost audio implementation is unlikely to contribute an std::audio implementation. &amp;#x200B; I have a feeling that this will end up as std::valarray while being a huge time and attention sink like std::graphics has been.
Actually, there have been some examples here on reddit, that showed, that constexpr tends to make the compiler try harder.
I believe you still need the typecast.
Only for C and C++03; C++11 and newer do not need it due to the semantics of list-initialization.
Nice !
That would be great
Why should my modern code become more difficult to read (longer Identifiers/more visual noise) just to cater to some (real or imagined) problems in old codebases? If you are calling a function in c++ you need to know what that function does. That doesn't change no matter how much strong type aliases you are adding to the language and personally I can't say I can remember any situation, where it wasn't clear if a pointer was owning or not owning. The important thing about shared/unique ptr isn't that it tells the programmer that it owns the memory, but that it cleans up the memory automatically - it provides additional functionality. If observer_ptr doesn't provide such an additional functionality then I don't see why I'd want to rewrite whatever functions I have that use raw pointers. And if library interfaces don't get rewritten (so I have to constantly convert the observer pointer to a raw pointer) then it loses even the last bit of utility to me. If you find `observer_ptr` useful, put it in your codebase, but please don't expect others to use it as well. And please don't make c++ even more difficult to teach.
This! Syntax modules can help a bit though.
Great idea, but I do think it should have a terse notation. Maybe something like just putting an asterisk between the type and the name? 
* The guy is sort of against vaccines (or at least not in favor of them) * What lies? Not a single example given, let alone proof * So what would Gates's motives be then now? He's already accomplished everything a human could ever accomplish, at least in the department of success, money &amp; fame. And if one of his motives is to genuinely make the world a better place _and_ up his image at the same time, then so what? That's awesome. The person that should do some sole-searching is you, in my opinion, dear poster. Don't hate.
soul-searching*
Why would you have a goal to make perfectly cromulent code ill formed? 
What's wrong with [cpr](https://github.com/whoshuu/cpr)?
Well for instance if on windows it standardises on Wasapi it means that it won't be used right from the start by people making pro audio software since the de facto standard api for this is Steinberg ASIO in windows (unrelated go boost asio).
Don't answer, IT IS A TRAP.
5 years with no meaningful activity. Glad GCC hasn't changed much.
But what if, Stroustrup forbid, you require one of these observe pointers pointing... *to an observe pointer*?
The other real reason: why? It just makes C++ even more stupidly-verbose for no real reason.
I propose adding more verbosity to `verbose_ptr`.
Is there a reason the Committee seems to have a love for adding verbose templates that both clutter code *and* increase compile times? Why not adopt new tokens like T \^ or T! or something, or provide a sentinel modifier like T * unowned Obj?
That's the genius: you can just keep adding asterisks! ;-) I once ran into this beauty: foo **** fooptr; Would you really prefer this to be called observer_ptr&lt;observer_ptr&lt;observer_ptr&lt;observer_ptr&lt;foo&gt;&gt;&gt;&gt; foo_observer; ?
`template_multiplier&lt;observer_ptr&lt;foo&gt;, 4&gt;`
&gt; There's no guarantees that size_t can represent the values being returned by your iterator. You should get acquainted with how big 2^64 actually is ... 
If the above code would be the actual use case and you would know nothing about the context, yes. But my use case is in a context where I know that this is not allowed (because I define the interface of my library and what `match` is supposed to return). I only need to distinguish between two possible ways to call `match`, not check its return type. In case you are interested: https://github.com/taocpp/PEGTL/blob/66dbe7ef2b89992e6d2dcd75aaade56236468caf/include/tao/pegtl/internal/duseltronik.hpp#L38-L50
Regarding the clock / timestamp section, the authors could at least refer to Ross Bencina's work on this: - https://haptimap.ee.qub.ac.uk/svn/haptimap/branches/qub-android/external/espeak/portaudio18win/docs/portaudio_icmc2001.pdf - and most importantly https://pdfs.semanticscholar.org/7222/1a9d6020341c8db6fd0e87a27569f731343d.pdf
You're showing your age there! You're right that up until Win8.1 or so, ASIO (not the Networking TS, what you call Steinberg) was king. But in Win10 everything audio is WASAPI. Literally sits at the base of all audio on Windows 10, it's the sole way to talk to the hardware, and everything audio is written or emulated on top. This isn't as bad as it sounds. If tickled right, Win10 WASAPI is actually very good. A few contracts ago I had reliable 48Khz 64 sample buffer size HRTF working well, albeit at a hefty CPU cost, irrespective of CPU load or i/o activity. Not bad for a kernel with as awful a thread scheduler as Windows!
The biggest feature of string_view is not that, it's the type erasure. Meaning that you can pass any string-like variable (even user defined types) to a function that takes a string_view and handle it the same way uniformly. Observer_ptr could be the same, a way to type erase any pointer-like variable and treat it generically. It's something that Bjarne didn't mention in his paper.
&gt; But in Win10 everything audio is WASAPI. really ? I pretty much doubt that pro audio drivers such as RME, MOTU or Antelope write their ASIO drivers on top of WASAPI... I don't see how MS could even prevent it since anyone could implement an ASIO-like mechanism in custom kernel drivers. The only thing that I can read about it [here on the audio docs](https://docs.microsoft.com/en-us/windows-hardware/drivers/audio/low-latency-audio) is that they tried to improve latency in win10. But still : Another popular alternative for applications that need low latency is to use the ASIO (Audio Stream Input/Output) model, which utilizes exclusive mode. After a user installs a 3rd party ASIO driver, applications can send data directly from the application to the ASIO driver. However, the application has to be written in such a way that it talks directly to the ASIO driver. doesn't point to the soundcard drivers being implemented on top of WASAPI. Do you have a link ? 
Oh yeah [P1371R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1371r0.pdf) pattern matching! &lt;3 &lt;3 &lt;3 But... &gt;If no pattern matches, none of the statements are executed for the statement form and std::no\_match exception is thrown for the expression form ...why not make exceptions opt-in by demanding the \_ match-all clause? In there, the programmer can always just throw std::no\_match herself. I mean we don't throw if a switch statement has no default: labe either, right? And todays compilers (rightfully) complain if a switch does not cover all values if the switched-on value has enum type.
I don't know premake but meson is an excellent alternative.
``` cmake_minimum_required(VERSION 3.10) project(my-great-project) find_package(NecessaryDependency REQUIRED) add_library(a-really-good-library library/src/library.cpp) target_include_directories(a-really-good-library PUBLIC library/include) add_executable(awesome-executable executable/src/main.cpp) target_link_libraries(awesome-executable PUBLIC a-really-good-library NecessaryDependency::StaticLibrary) ``` 
Depends on what you mean by "worth." If you need it to work for you and it gets the job done, then why not. I prefer CMake because it's the most popular and most libraries use it, which makes them easy to integrate into the project. Also, Vcpkg is great.
Hello! What would be the cost for registration? 
Premake is very nice indeed and based on Lua. But the problem is only few people use it. So going with CMake and its awful language is still the best way, esp. when combined with Conan: https://github.com/conan-io/cmake-conan
Hi there! We would like to set a very small fee (10‚Ç¨) just to soften the drop rate. All the previous editions were free and for this reason we had at least 20/25% drop rate every time. This means waste of food (since the catering brings in line roughly with the number of registrants less a delta) that we do not want to allow anymore.
I'm using premake because--well its easy to read and easy to understand, still rather confused why CMake is so popular, and why MSVC is going out of its way to support it-- &amp;#x200B; Can CMake do all of the following? &amp;#x200B; \-precompiled headers(toggle per lib) \-target architecture(SSE/AVX etc) \-calling convention(vectorcall?) \-multiple targets(debug build, semi-optimized build, optimized build for SSE, optimized for AVX) \-disable warnings per lib \-disable exceptions per lib \-defines (like \_HAS\_AUTO\_PTR\_ETC=1) \-lots of command line options that differ between compilers(MSVC: /0b2,/Gw, /Zo, /Zc:throwingNew etc etc) \-get natvis files included &amp;#x200B; &amp;#x200B;
&gt; * precompiled headers(toggle per lib) There is no portable way to support precompiled headers, nor is there a generic way to make them efficient. But sure, you can set up precompiled headers if you want to. &gt; * target architecture(SSE/AVX etc) &gt; * calling convention(vectorcall?) These are compiler options. Sure, CMake can set those if that's what you mean. &gt; * multiple targets(debug build, semi-optimized build, optimized build for SSE, optimized for AVX) It does this by default yes. &gt; * disable specific warnings per lib &gt; * disable exceptions per lib Again, target specific compiler options. Sure, it can do that. &gt; * lots of command line options that differ between compilers(MSVC: /0b2,/Gw, /Zo, /Zc:throwingNew etc etc) There are indeed lots of compiler options that differ between compilers. Not sure what you're trying to say here. &gt; * get natvis files included I don't work with VS but I don't see why not.
In \`const initializer&lt; int &gt;::value\_type\` the \`const\` qualifies \`value\_type\`, so you are declaring \`const int\` variables and that's why your EDIT examples don't compile.
I probably would, but frankly I don't personally have issues with writing `.get()`.
It depends really. The [last bug I reported](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86314) was a wrong code-gen, and it was fixed within 24 hours. I was thoroughly impressed!
The big reason why you want to use cmake over other build systems is because of how widely used it is in the industry. This also why you should use git, even though it might not be the best VCS.
Pattern Matching is such a well written and easy to read paper. inspect (v) { &lt;int&gt; i: strm &lt;&lt; "got int: " &lt;&lt; i; &lt;float&gt; f: strm &lt;&lt; "got float: " &lt;&lt; f; } It's so much nicer than current visitation for variants. And it can easily be extended to user defined types. I hope we are going to get it soon, while std::variant, std::optional &amp; similar ADT are extremely useful, it's hard to sell to the team to make it a common practice seeing how cumbersome it is to work with them today. 
Yes, so people would never write that.
Wow this is great. Just a few days ago I was looking at porting from hunter to Conan for our projects but found the need to repeat configuration for conan and cmake when configuring the project a bit painful. I wrote my own minimalistic version of this wrapper functionality but can't wait to try out this repo which seems significantly more useful.
Cmake, like everything else, has a learning curve you need to get past. Just put the work in and you'll change your mind.
Don't be afraid of mobs. Write it, the mob will get you more attention. Most readers won't reply but there are more who agree and you might open some eyes and help others form a more balanced opinion.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/akbghq/worth_it_trying_use_premake_over_cmake/ef3u33a/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I use it just for clang-tidy, as clang-format is included with VS.
This is explained in the post.
I believe [https://marketplace.visualstudio.com/items?itemName=EWoodruff.VisualStudioSpellCheckerVS2017andLater](https://marketplace.visualstudio.com/items?itemName=EWoodruff.VisualStudioSpellCheckerVS2017andLater)[EWoodruff VisualStudioSpellChecker](https://marketplace.visualstudio.com/items?itemName=EWoodruff.VisualStudioSpellCheckerVS2017andLater) does this. (Sometimes annoyingly so. No way to say things like AppVeyor are a single name.)
I dont use premake, so I'm not sure how cleanly it handles these things (though you've pointed out that most of it can get handle by targets), but I've been using CMake for awhile viz architecture targeting (AVX2, AVX512, SSE, etc), and while it's not super terse (which is what I think people are getting at when they say "not clean"), you have complete control. Sure, you have to work some of the cases out yourself, but having a couple of architecture specific targets floating around is not a big deal and you can generally reuse them in other projects.
It is a good idea, unfortunately people don't realise the effect of not going when they don't pay. Can you get help from other universities? maybe a partnership so their students can go to the event and they become sponsors? If I am in Italy during this time I will try to go. Best of lucks!
I realized that later on, I just didn't make a third edit.
That's just effectively a bridge to UWP on Windows 10 only. So C++/WinRT remains tied to UWP in that case.
Nanogui works for what it is intended to do, it is simple and uses openGL. You don't have to pay for Juce if you use the GPL version. This is an acceptable tradeoff for many people I'm sure - anyone making an open source GUI or an internal tool would be able to use it without paying for a different license. 
Oh, well that's great! Unfortunately, Networking is delayed until 2023. But you don't need to wait, you could use standalone Asio or Boost.Asio today (these are both identical to net.ts). Anyway if you were to use `std::net::` when it is released, then your library would no longer work in C++11 (which would be a shame).
Nice
Each and every member shall be defined via some template metaprogramming, the variables and constants for which are brought in via multiple inheritance of a curiously recurring template pattern. 
Yes but why invest in something you need to change if the tool become not internal? 
Sorry about that; there are many bugs and sometimes they fell through the cracks. We're in stage 4 so we now only fix regressions, and this problem is not a regression. I'll try to take a look.
How long will it last? I'm going to be in Italy for vacation on the 20th, so maybe I can catch part of it!
Yeah, Jakub is awesome.
How much more efficient is the new binary of the old release?
Wait, is this a thing?
Stop trying to use the standard as a way to force your perferred api, style, etc on others. There's absolutely no need for this, and it would actually make C++ even less flexible.
Not sure about AVX, but I know that SSE2 is included with 64 bit and it's an extension with 32. The big issue is even if pointers take up more memory, you get double the registers. that's where the real benefit is.
Honestly, good. it was obviously a ridiculous idea that nobody actually gave a shit about. Seriously, would you compile your sit in a special mode to save a few megs of memory, when it would require you to recompile literally everything for it? \#Nope.
+1. I work on multi million LoC projects started in around 2000. I never know if the `*` I see is ancient cruft or `unowned_ptr`. 
lol, Xcode is like 12GBs it's compressed on the FS to only tke up like half of tat but still, IDEs are huge.
I think he means it's slow to start up, Xcode opens within a second or two, while VS takes a solid minute to get running.
If you look at his replies in the comment thread, he/she specifically refers to disk space.
If you want to learn pre standard c++, any comp science books from india will do, cause gor some reason that's all those poor kids ever get to do in comp science, pre standard c++
You can check out CommandLineIO as part of FoundationIO (I wrote it) I was designed primarily for media, but it's got extensive support for suboptions. It supports range notation with the double dot syntax (X..Y), it supports setting equal as a delimiter, also in StringIO (Unicode library with support for UTF-8, UTF-16 and UTF-32) there is a group of functions that operate on "StringArrays" aka an array o strings, you can split strings based on single and multi-codepoint delimiters (so for example, set a delimiter as "..", and it'll create 3 sub-strings in a string array, he firt being X, the second being the "..", and the third being Y). When I was designing it I wanted to support really every type of command line interface I had seen on Windows, Unix, etc. Really the only notable feature it does not and will not support, is collapsing multiple options into a single string, like in the gnu world where -wrt is 3 different commands, I never really do it that way, and it was designed more for single words per command. I am thinking about adding support for automatically shortening the options, so for example if you have an Include option, the parser will be able to disambiguate it using the fewest possible codepoints, but that's still a was off, so if there's only that Include option tht starts with I, then just I would work, if there's Input and Include, then Inc, etc. Oh, also it's obviously case insensitive. It is written in C though, not C++
New tokens and/or language keywords have a much higher cost than a new class. (Cost in terms of committee time, learning time, "opportunity cost" - ie those tokens could be used for something else, etc). observer_ptr is not worth a language level change. Completely "fixing" ownership would be worth changes in the language.
Try to get a copy of [The Annotated C++ Reference Manual](http://www.stroustrup.com/arm.html)
oh dear the mobile view is unuseable
Can you ELI5. I know what it is literally, but i dont fully understand the motivation for it
Thanks! I'm picking up a copy from the library tomorrow. Have you read it? Thoughts?
i can only recommend buying any science books from India, the prices are great. 
More efficient than?
Then you have the option to pay or make your GUI open source. It really doesn't seem so bad to me. Qt has a commercial license too and neither are the only choices for cross platform GUIs. I'm not really sure what you are trying to argue here.
&gt; Ensures that foo(42) is a constant expression and is evaluated at compile time. It doesn't? Granted that no compiler would probably do this, but isn't it ultimately just a "hint" and compiler may still decide to postpone it until runtime if it so wishes? At least that's what I remember when I've last read that part of the standard.
(b) can not *just* be undefined. (b) is fundamentally undefined. Now you might be using a - for now - somewhat sane compiler that happens to returns a sensible value, but you really should not rely on that (except if you find a part in its doc where it is explicitly stated that this is supported and will continue to be in the future, and you do not expect to use another compiler) Really: (b) as far as standard portable C++ is concerned, has no meaning.
Looks like the developer study lite put out by the standards committee shows 88% of users use C++ at work but none of the questions have to do with code size or age unfortunately. https://isocpp.org/blog/2018/03/results-summary-cpp-foundation-developer-survey-lite-2018-02 JetBrains did a survey that only had 18% of respondents say they were on C++17 with only an extra 8% planning on upgrading it in the next year. https://www.jetbrains.com/research/devecosystem-2018/cpp/ Combined that points to three quarters of developers having enough legacy code to not want to update due to friction in doing so. And that is with a huge emphasis on backwards compatibility and minimizing the impact of upgrades. I am ambivalent about whether to worry about the exact ratio given the huge amount of indirect evidence towards my point. The sponsorships the posted information on code base sizes (although hard to find) and the discussion points in the conversations around the standard that not only take a hard line against breaking backwards compatibility but also discourage any semantic changes that don't provide a huge benefit.
I watched the first few minutes and the last 12 minutes of this. He talks about going from "almost always auto" to "always auto" with 2020 C++. I think I'm still sometimes auto.
I'm not like some master of "pointer arithmetic" but that shouldn't mean I should avoid pointers for the rest of my life and as for the program this should print the arguments as the user passes them into the program which by the way have you tried passing argument into it?
Yeah so this being Microsoft, there is shim backwards compatibility WASAPI and then "bare metal" WASAPI. You open the latter using a non obvious set of parameters which severely restrict the formats and features you can use. You know when you got it right when 64 samples work fine, and your round trip audio latency drops substantially :) By "everything is now WASAPI", I mean that inside the kernel, there is very little code between bare metal WASAPI and the DMA engine to the audio card. Yours truly spent a week in WinDbg inside the kernel to verify this to be true for a range of common sound cards. No doubt any kernel driver can replicate the same, but to be honest, I came away impressed with the default. The low latency stack is well designed. My verdict is Microsoft finally got some audio experts to redesign the stack after two decades of somebody not versed in low latency architecture doing it. Plus they retained existing APIs for compat. Nice bit of engineering in my opinion. And very long overdue for Windows!
I'd go with a language reference for whichever compiler the chip's toolchain uses. Before the language was standardized in 1998, different compilers essentially implemented different dialects of the language with minor differences here and there. So that could be like: Watcom C++, Borland C++, MSVC, and so on. Although honestly, those are PC compilers because I'm not familiar with what would've been available for embedded C++ at the time...I would've assumed "nothing, it's all C and assembly", with C being considered fairly slow and heavyweight for the time.
I'm still waiting on my g++ frontend codegen bug to be fixed. I suspect it's not high priority because it only negatively impacts AVR.
It is now. [Source. ](https://www.reddit.com/r/cpp/comments/ak0vfg/_/ef37bxp)
Well, the `*` token *is* already used somewhere else. It's just unambiguous where it is. I'm unconvinced that `T ^` would have higher learning time than `std::shared_ptr&lt;T&gt;`. C++/CX uses it to mark runtime-owned handles. Past that... shouldn't any pointer be presumed unowned *by default*? We already have observer pointers - we call them pointers. The owned variant should be wrapped up somewhere else. It's all making C++ *ridiculously* verbose and arcane... I can't even make fun of Java anymore.
&gt; Naked pointers belong as a remnant of the past yea, you never use `this`????