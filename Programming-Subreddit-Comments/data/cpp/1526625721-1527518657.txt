xDDD(9 ͜ʖ ͡°7)D--|_(ツ)_/¯DDd:P~~
There were a few commits since this link was posted, including an optimization to use a single string literal to store the file using binary escape sequences to encode the octets of a file. Before that change, an array of character literals between curly braces was used to encode the file. The string is meant to speed up the compiler's lexing process. The changes appeared in [this commit](https://github.com/vector-of-bool/cmrc/commit/cdda7887b7223b95319a7e60fe3d3a6a2c345ee9). If you want, you can either check out the commit prior to that one or manually revert the relevant sections by hand. Do you have a GitHub account with which you can open an issue? Also, how big is the file that fails to encode?
The file that failed was flower.jpg in your repository. However it also failed on my own file which was 63kb. I made the following patch: diff --git a/CMakeRC.cmake b/CMakeRC.cmake index 4742e4b..045e985 100644 --- a/CMakeRC.cmake +++ b/CMakeRC.cmake @@ -3,7 +3,7 @@ if(_CMRC_GENERATE_MODE) file(READ "${INPUT_FILE}" bytes HEX) # Format each pair into a character literal. Heuristics seem to favor doing # the conversion in groups of five for fastest conversion - string(REGEX REPLACE "(..)(..)(..)(..)(..)" "\\\\x\\1\\\\x\\2\\\\x\\3\\\\x\\4\\\\x\\5" chars "${bytes}") + string(REGEX REPLACE "(..)(..)(..)(..)(..)" "'\\\\x\\1','\\\\x\\2','\\\\x\\3','\\\\x\\4','\\\\x\\5'," chars "${bytes}") # Since we did this in groups, we have some leftovers to clean up string(LENGTH "${bytes}" n_bytes2) math(EXPR n_bytes "${n_bytes2} / 2") @@ -12,14 +12,14 @@ if(_CMRC_GENERATE_MODE) set(cleanup_sub ) while(remainder) set(cleanup_re "(..)${cleanup_re}") - set(cleanup_sub "\\\\x\\${remainder}${cleanup_sub}") + set(cleanup_sub "'\\\\x\\${remainder}',${cleanup_sub}") math(EXPR remainder "${remainder} - 1") endwhile() if(NOT cleanup_re STREQUAL "$") string(REGEX REPLACE "${cleanup_re}" "${cleanup_sub}" chars "${chars}") endif() string(CONFIGURE [[ - namespace { const char file_array[] = { "@chars@" }; } + namespace { const char file_array[] = { @chars@ }; } namespace cmrc { namespace @LIBRARY@ { namespace res_chars { extern const char* const @SYMBOL@_begin = file_array; extern const char* const @SYMBOL@_end = file_array + @n_bytes@; With this change MSVC can handle the flower.jpg file. Do you think you would consider reverting this change to fix the MSVC support?
Opening a PR would be perfect. Thanks for finding the fix!
Happy to do it. I rarely use github so bit of a n00b question: how do I create a branch? Do you need to give me permission to do that? Currently I see no way on the webpage to do it.
Yeah, new bugs
You can disable individual warning swith \` \-Wno\-xy\` .
Not true. Some warnings don't have a switch to disable them in GCC. 
What do you think of [Boost.QVM](http://boostorg.github.io/qvm/)?
You're right, I have noticed that, too. But they are in the minority. Do you remember which warning it was?
To be honest if an IDE supports pointing it to a top\-level folder and manually specifying a compile and run command line then using build system that does not integrate with the IDE works just fine. I've worked with VS code as well as with QtCreator this way and was perfectly happy.
This is far from the main gripe with cmake. The main gripe is that the syntax is horrible and the documentation is unusable, as outlined by OP. I find the 'new\-style' cmake syntax is even worse than before, it looks they married old cmake to perl. For a business case I'd still say go with cmake because you know it will work, even though you'll have to invest a lot of time once your project becomes a bit bigger. For anything else: please use meson/build2, the more people use these build systems the faster we can replace cmake everywhere.
Working on a 100\+ people C\+\+ project. We list all files manually. This has never felt like a problem to me.
[Yes](https://www.reddit.com/r/cpp/comments/8k23ii/getting_started_with_meson_in_c/).
I have nothing in particular to add; I just came here to express my raging hatred for CMake, a hatred that burns with the intensity of a thousand stars. For anyone who claims CMake is adequate: please point to an "elegant" `CMakeLists.txt` which can generate an app bundle on macOS which includes a framework, and say, a dylib. Please prove that it can work in a sane way (i.e. not requiring to change target to install every time you want to build for debug purposes). &lt;/rant&gt;
Any CUDA support yet?
It’s rather intense, better not mention other build systems...
Good point
Why not? This place is for discussion! I see some people trying to say how bad everything that is not CMake is. But hey, there are other people, like me for example, that have a different opinion, but not only that, we can articulate a reasoned reply of why.
First of all, the syntax has not changed. What has changed is the design of how you declare dependencies and pass information between them. And I have no idea about what Perl you’re talking about...
What a bummer, I've already heard this one.
That’s not unlike understanding the difference between `void C::foo() &amp;`, `void C::foo() &amp;&amp;` and `void C::foo() const&amp;` in C++. I guess it’s the difference between knowing it or not.
Does anyone, other than LLVM devs, really give two hoots about LLVM IR? Anyway, it doesn't change the fact that using UB for optimisation opportunities does nothing more than turn a bad program into a very fast bad program.
Well-formed programs are the ones who take advantage of optimizations with UB-based knowledge. For instance, if the language has a rule that unrelated types don't alias, otherwise it's UB, then a compiler will take this knowledge for granted, and optimize reads and writes around variables whose types don't related to each other. Your code might be well-formed, and the optimization is a win in this case. LLVM is not optimizing for ill-formed code, it does the otherwise.
In a definition, the type of a variable is to the right of its name. This is terrible for readability. Making parsing simpler was an excuse in the 80's.
Well, and obviously doing otherwise can break easily [reproducible builds](https://wiki.debian.org/ReproducibleBuilds)
Nice! Since you are here, question: Do you also like the "OOM now kills your binary" part of Herbceptions, or just the alternative semantics of user-defined exceptions (for lack of better word)
Just curious, have you tried QBS? I haven't tried Meson and haven't been able to find anyone who has used both to compare them.
Didn't know it yet, but its application is quite limited as it's not a full linear algebra library (focus only on static size vectors and matrices, say, for graphics applications). Also didn't look at the code, but the doc doesn't mention things like explicit SIMD vectorization or expression templates. Can't really say too much about it. This being Boost, I just hope it doesn't depend on twenty other Boost libraries...
No I did not, sorry :) Zero experience.
I am pretty neutral on the OOM aspect. This does, in theory, break existing code that people may have worked really hard to get right. However, the amount of tested, correct code that this will break is likely tiny, and if the code is tested, they would notice when it breaks. If you liked it then you should have put a test on it. I think the best way to mitigate OOM failures is to not use the heap. It's too hard to prove that you got it right. It's much easier to reason about pool allocators.
Im talking about the generator expressions.
I just consider CMake as the project file format (i.e. it lists all my sources, include directories, etc.) in CLion and don't really use it at all for actual builds. Instead I have custom targets set up that call a simple wrapper script around my actual build tool (*ant*, believe it or not, where I work), and it seems to work just fine for me.
The problem are the programs which become ill formed thanks to inline expansions and other code transformations before the optimizer gets to look into it. Suddenly that if on an well formed function turns out to be something that never happens and gets wiped out.
Sorry to leave you hanging. Your messages came in past midnight local time. The PR process is a bit arduous the first time but isn't hard. [Here are the GitHub docs about forking and submitting changes](https://help.github.com/articles/fork-a-repo/). If it's too much of a hassle, I can go ahead and make the changes myself.
Thank for the link. I will have a read through it. It’s a good opportunity for me to learn about the github pull request process so I would like to try it out. I will try and find time over the weekend - otherwise I will have a look on Monday!
I really like the proposal, it would add a lot of goodies, besides the main aspect of fast exceptions, and ability to use std for everyone, proposal would also add additional side effects: 1) ~90% of all functions std functions will become noexcept, which will reduce complexity and increase optimization opportunities. 2) since most of the functions will be no except, throwing functions will become minority, especially with contracts, which will increase readability 3) uniform error handling for everyone, even with FFI between C, Rust and Swift. I think this is necessary for the future, even though it breaks VERY SMALL portion of existing code, because most of code bases doesn't properly handle OOM anyway.
Thanks for the awesome work JetBrains team, i love your products, they get better and better with time
/r/gamedev post https://www.reddit.com/r/gamedev/comments/8kcemj/after_more_than_a_year_or_work_i_am_thrilled_to/
Sorry, it was a joke. Probably that wasn’t very clear...
How many of these conferences are there? I'd like to go through them and watch interesting talks - I've been slacking off on watching them - and probably have a lot to catch up in the last year. Does any one have a nice playlist/compilation/links ?
&gt; In our case here, such a name could be `EnableIfIsNotReference`, or perhaps just `IsNotReference` Personnally, I prefer `RequireNotReference` which remind the Concept TS or `WhereNotReference` which remind the `where` restriction clause in C# generics. It has stronger semantic than "Is" which remind me only a boolean value not a restriction.
The main ones are [CppCon](https://www.youtube.com/user/CppCon/videos), [C++Now](https://www.youtube.com/user/BoostCon/videos), [ACCU](https://www.youtube.com/channel/UCJhay24LTpO1s4bIZxuIqKw/videos), [Meeting C++](https://www.youtube.com/user/MeetingCPP/videos), [Pacific C++](https://www.youtube.com/channel/UCrRR5mU5aqvtZAuEGYfdTjw/videos).
I can't emphasize enough how much I like this blog
https://github.com/shafik/cpp_youtube_channels
Thought I was on /r/mud ...
Additionally NDC, Build, WWDC also have some C++ talks.
&gt; If you do not have Boost installed in a standard directory or you want to search for an alternative version of Boost, pass the environment variable BOOST_ROOT with the toplevel of Boost where your include/ and lib/ libraries are at configuration time and everything will work. Is there an equivalent to `CMAKE_PREFIX_PATH` for meson? I hate having to set a variable for each dependency and from a package manager's perspective its not easy to automate. Nice thing with cmake, I just set `CMAKE_PREFIX_PATH` to where my dependencies are and that's it. I know I could use `PKG_CONFIG_PATH` for this, but that only applies to dependencies that provide pkg-config files, which won't work for boost.
&gt; https://github.com/shafik/cpp_youtube_channels Wow . thanks 
This is all excellent. Thanks a ton.
It is the official way to build C++ on Android.
Those were a sorely missing feature. They are not a replacement for anything. 
A question came up: Why not accept a parameter pack of Base-inheriting types rather than a full variant type? You could bind the parameter pack to the variant yourself. 
Yes, I've seen it done that way. And the get-the-base function just visits and static_casts (thus failing to compile if A,B,... are not derived from Base). IIRC. And it all goes away by the compiler. There's a godbolt link out there somewhere with the example...
the sites code snippets render offscreen. iPhone 6s official reddit app
One problem with a kit like this is that it looks like mostly toy apps have been built with it. That's totally fine, but it doesn't really look like it's been production hardened. That will be a serious concern for many professional users. From your page: &gt;&gt; mud stems from a strong programming philosophy: it wagers that the future of application and game coding lies in small, self-contained, reusable and shared libraries, and not in gigantic tightly coupled engines of hundreds thousands of lines of code. But this doesn't at all look like what you've done. How would I replace your 3D module with my own? How would I replace your UI module with something else? What about swapping out the keyboard input handling? I respect that fact that you spent a year gluing all this stuff together, but I don't see this as suitable infra for commercial products. It does too much and at the same time, it does too little, ie. not production hardened. You should seriously rethink service boundaries - and development scope - if you want to deliver on the promise of modular app tech. I don't need this product when I can use libraries like Dear ImGUI (or even web tech) to put an app together without having a framework with strange opinions on reflection and serialization.
Cool list! I didn't see [lua primer](https://github.com/cbeck88/lua-primer) on the list. I've been enjoying using that for the most part. Primer claims to be zero-cost, so I expect it would rank well. I haven't used these other bindings though, so I don't know how well it would compare ergonomically.
Lol. Ok. 
No AFAIK. I found this but I think the person asking is you :) https://github.com/mesonbuild/meson/issues/2472
 auto b = !std::is_reference&lt;std::variant&lt;&gt;&gt;{}; // boom! Should I blame `std::variant&lt;&gt;`, ADL, or this idiom? 
This, by the way, is why I want unsafe pointer-to-element for both `any` and `variant`; with it I can write variant-with-base with zero overhead (vs pointer oveehead here). For any, it makes spliting type erasure and storage a tad easier.
Empty variants are ill-formed, so I'd say `std::variant&lt;&gt;` — not all ill-formed code yields diagnostics.
Does meson work with vcpkg?
Not that I know of.
I don't think this would help? It would have to return a `void*`, but you can't cast that directly to pointer to base because the base object may not be at offset zero. At best it would have to be pointer to common-initial-sequence. OP's technique works fine with this. See [here](https://wandbox.org/permlink/xuciWBraFmw5v5QA) for example. (Well I guess you could `dynamic_cast`, but that's certainly not saving you any time :))
Are you even trying to understand what Im saying? Its new and it has a horrible syntax is what I think. Ill be glad to be able to leave it all behind.
&gt; if constexpr (std::is_same_v&lt;Arg, std::monostate&gt;){ &gt; return nullptr; &gt; } &gt; &gt; return static_cast&lt;Base*&gt;(&amp;arg); I'm not sure whether this would work. Even if `Arg` is `std::monostate`, the last line still need to be compiled, and will be a error if `std::monostate*` is not convertible to `Base*`. You need an `else`. &gt; namespace std{ &gt; &gt; template&lt;class Visitor, class Base, class Variant&gt; &gt; decltype(auto) visit(Visitor&amp;&amp; vis, NoteEditor::utils::variant_w_base&lt;Base, Variant&gt;&amp; var){ &gt; return std::visit(std::forward&lt;Visitor&gt;(vis), var.variant()); &gt; }; &gt; &gt; } This is UB. Don't do this. &gt; struct Interface{ &gt; virtual int get() = 0; &gt; } &gt; struct A : Interface{ &gt; virtual int do_smthg() override{ return 1; } &gt; } &gt; struct B : Interface{ &gt; virtual int do_smthg() override{ return 2; } &gt; } There need to be semicolons after struct definition. The method names need to be consistent. &gt; variant_w_base&lt;Interface, std::optional&lt;std::monostate, A, B&gt;&gt; var; I guess you mean `std::variant`, not `std::optional`.
I don't think it's fair to criticise something for not being "production hardened" - it's got to start somewhere! But i agree with the rest. Thing is you can't really make concepts like reflection or serialization modular, they're always going to dictate the semantics of the code base.
Author here. You cannot ever having `span` behave like a container because of `operator=` ``` span a = vector; span b = vector; modify(a); assert(a != b) // boom ``` removing `==` is a bit extreme indeed, however I only removed it from user code, it's still visible from withing the STL that could "do the right thing" you could of course import this operators `using namespace std::view_identity_comparators;` or something like that. Long term, What I think we might really need however is two explicit customization points ``` auto identity_compare(T&amp; other) const; auto value_compare(T&amp; other) const; ``` However this has his set of issue, namely, which one do you use in the STL algorithms ? - it might be an ever bigger can of worms. And very very few type have different values and identity. Identity and value are poor choice of words though... it's more like value and value's value... gosh, this is all very complicated ! 
&gt; People should really stop over think everything. Instead using a factory function, the c++ way is to directly pass parameter to ctor when you empalce_back. But very often you don't know the type of what you are going to construct at compile time. Think for instance loading plug-ins, etc etc
We don’t know what is intended.
I don't wanna come off as rude, but why don't you write yourself some tests?
Sorry I couldn't figure out how to add something above the code snippet. Is my CPager working as a Linked list on some memory, where x is the maximum of free uint32\_t indexes? Like, for 30 free indexes it creates 60 uint32\_t where every i &amp;#37; 2 is the value inside the Linked List and i \+ 1 &amp;#37; 2 is the "pointer" to the next index. I'm quite asking if it can stop working because I tested it for max and mins and it seemed to work, but I'm suspicious.
I just use a `moodycamel::readerwriterqueue&lt;smallfun(whatever)&gt;` , works like a charm (between 2 threads): https://github.com/cameron314/readerwriterqueue ; https://github.com/jcelerier/smallfunction
what else would they be ? 
The problem with reducing: std::enable_if_t&lt;!std::is_reference_v&lt;T_&gt;, std::nullptr_t&gt; = nullptr to: typename = std::enable_if_t&lt;!std::is_reference_v&lt;T_&gt;&gt; is that the former lets you overload with disjoint conditions (because you'd have template non-type parameters of different types) but the latter would give you an error (because you'd have the same function template with two different default template type parameters). That's a good reason to prefer the former. And just wrap the whole thing in a macro so you don't have to think about it: #define REQUIRES(...) std::enable_if_t&lt;(__VA_ARGS__), int&gt; = 0 And you have: template &lt;typename T_ = T, REQUIRES(!std::is_reference&lt;T_&gt;{})&gt; void f(T&amp;&amp; x) {} With pfultz2's trick that he showed in the previous post, you can improve `REQUIRES` to always be dependent and then this can be: template &lt;REQUIRES(!std::is_reference&lt;T&gt;{})&gt; void f(T&amp;&amp; x) {} And of course with concepts we don't need to do any of this shit: void f(T&amp;&amp; x) requires !std::is_reference&lt;T&gt;{} {}
They're constants.
As I said in the post there are a plenty of ready-to-use solutions and there is no need to create ad-hoc bicycles by yourself.
They have to be stored somewhere, and they're always going to be null-terminated contiguous series of characters. Hence, arrays.
That's just what they always were. If you were to introduce a breaking change to the language that suddenly started considering string literals as static `std::string`s you'd create at least one big problem. How do I initialise a `char my_string[]`? Right now I can do `char my_string[]="foo"`. Would I have to do `std::string temp = "foo"` and then `char my_string[] = temp.c_str()`? Or maybe `char my_string[]="foo".c_str()`?
Thank you so much for the explanation why std::enable_if_t&lt;..., int&gt; = 0 is better than typename = std::enable_if_t&lt;...&gt; 
Tradition. C\+\+ inherits many things from C including strings as arrays of `char`. Also, if the string is to be displayed, that is, it is not use exclusively internally, then make it translatable. extern const string hello = _("hello world"); Then it can be easily translated to other languages. See [https://en.wikipedia.org/wiki/Gettext](https://en.wikipedia.org/wiki/Gettext)
`char my_string[]="foo";` already relies on a [special rule](http://eel.is/c++draft/dcl.init.string#1) to work. It could have been made to work with a different backing.
It looks like it's acting kind of like a stack to me. Which I guess could be what you wanted. As others mentioned, you should get in the habit of writing unit tests for your code -- look into cppunit or gtest, those seem to be the two I usually see when people write tests in C++. Most modern languages have unit test frameworks that are pretty easy to use. A lot of classes like the one I suspect this is homework for will have you build on the same code for the entire semester, so having unit tests will save you an increasing amount of time and trouble as you advance forward in the year. I don't think this code behaves like any sort of linked list, since you don't have list traversal methods or any way to add an element into the middle of the list, which are two fairly common use cases for linked lists, but I don't know what you're trying to accomplish, either. You can use a linked list like a stack if you want to, but you can't really use a stack like a linked list. You just have push and pop methods, but you don't call them that. It would be more clear to an experienced programmer if you called them that, assuming you were actually trying to build a stack. Oh yeah, and Hungarian notation is only for products of incest and sycophants. If you use it in the real world, people will automatically assume that you're a bad programmer.
Please, some of us need our ROMable strings to be in .text :)
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
You are not specializing a template function (remember that function templates cannot be partially specialized). You are declaring a new overload, and this is forbidden. 
Given that a huge amount of programs out there have command line options, I wonder why this hasn't been standardized yet.
I hope to see Meson get support in my IDE. Every time I have to work with CMake, I am wasting a ton of time looking up the things I already looked up multiple times before but can't remember anymore because they're so damn confusing and hard to remember.
It's more for the benefit of large Java projects that need a bit of C++ than C++ that needs Java. Frankly, having to install a jvm to run gradle written in Groovy or Kotlin to build C++ seems a bit OTT.
Yes, I see it now... Alas... It seems that it would be impossible to have drop-in replacement to `std::variant`, event with ADL. In particular, `get&lt;T&gt;(variabt_w_base)` will not participate in ADL, due to this https://stackoverflow.com/a/2953783.
Not OP but this is not an issue if there aren't any actual name clashes
Yet yet yet yet yet another command line parser library. But why would any one use this one over the others ?
Maybe because it easier and faster to write a simple loop over argc and argv. Compared to adding yet another library, figuring how to create and configure parser instance, and how to extract actual options from it.
I'm in an adventurous mood today.
#Support for subcommands? Unless I missed it, this doesn't seem to handle subcommands as in: program [program-options] command [command-options] subcommands are pretty useful for a variety of utilities, as they allow splitting unrelated arguments into different buckets. For example, `git` has multiple subcommands such as `commit` and `diff`, and both have different sets of options. #Support for both short and long names? It seems that an option can only ever have one name, when often times command line arguments have a short name `-i` and a long name `--input-file` for the same option. Did I misunderstand the examples? #Variety and user experience I am positively amazed at the number of options (`NumOpts`, `HasArg`, `JoinArg`, `MayGroup`, `Positional`, `CommaSeparated` and `EndOptions`). I cannot help but feel that this is overkill, however. I have no doubt that various developers have various opinions... but since "more features" != "better", I do wonder whether all these options pull their weight. Let's take `NumOpts`, for example: what's the benefit of `zero_or_more` and `one_or_more`? Overriding is script fairly: it allows catenating arguments from various sources without having to parse the previously aggregated arguments. Forbidding overriding seems script-adverse to me, and making it the default adds insult to injury. Similarly, I wonder at the usecase of `JoinArg` and `MayGroup`. The sheer number of possible combinations will likely lead to a fragmentation of the styles used by the various authors, for the greater confusion of the users. Why not instead favor a more authoritative approach to at least enforce some consistency on the produced APIs? *(I also note how the examples are crowded with multiple "modes" for each option added, which feels really cluttered; maybe more opinionated/smarter defaults would help keep this clutter down?)* #Not everything has to be an overload. I cannot help but wonder why `Add` is the only function. It seems that having a handful of `Add` functions would really help keep the number of flags down... The `EndsOptions` in particular jumps at me. And the example is **really weird**: cmd.Add("f", "bool", cl::Assign(f), cl::HasArg::required, cl::NumOpts::zero_or_more, cl::EndsOptions::yes); cmd.Add("args", "", cl::PushBack(args), cl::HasArg::required, cl::NumOpts::zero_or_more, cl::Positional::yes); Let's break this down: - How can something be `required` and have `zero_or_more` occurrences? Doesn't `zero` necessarily imply `optional`? - How can the catch-all sink NOT be `_or_more`? - How can the catch-all sink NOT be `Positional`? I would instead imagine something like: cmd.AddOption("f", "snarky", cl::Assign(f)); cmd.AddCatchAll("args", cl::PushBack(args), cl::HasArg::required);
A simple loop over argv won't give you any good results. That's why command line options libraries exist, unless you want to implement your own parser, at which point we're in the situation where everyone is re-inventing the same wheel over and over again. I mean, the title of this post is "**Yet another** command line parser library" :-)
[I wrote one too](https://github.com/Qartar/qflags)!
getopt() is POSIX.
Now make all the error handling with pretty messages and automatic help generation so I know how to use it. Thanks.
Never used Lua Primer. I'll check the docs. If they are not terrible I'll open an issue request in my repo to add it.
That's extremely basic and doesn't work well. When using cli options, I usually need arguments, in the correct type (numbers vs strings), error messages for unknown options (very important because the user might misspell something), combined options (`-vo` and `-v -o` should do the same thing), long vs short options (`-v` and `-verbose` should do the same thing), and positional arguments.
Whoops I definitely need to assure that I store my convictions in a proper container... :D Keep up the good work!
[I'm the author of the library] Thanks for the review! I'll try to adress some of your concerns below. 1. Support for subcommands? Right, sub-commands are not (directly) supported by the library. The `EndsOptions` flag is actually there to simplify sub-command parsing: The parse function returns immediately and the rest of the command line arguments can then be parsed by an additional parser.) 2. Support for both short and long names? Short and long names are supported. The "name" of an option can actually be a list of names separated by a `'|'`, e.g. `"i|input-file"`. 3. Variety and user experience The flags (`NumOpts` etc.) are used to configure how an option may be specified on the command line. (Yes, not all combinations of flags may make sense.) E.g., the `NumOpts` flag controls how often an option may be specified on the command line: `required`: exactly once, `optional`: at most once, `zero_or_more`: how often you like, and `one_or_more`: at least once. The `HasArg` flag controls whether or not an option accepts an argument. E.g. if an option has the `HasArg::required` flag, one may write "-f arg" instead of "-f=arg" on the command line. If an option has a short name, ie. a single letter, and has the `MayGroup` flag set, one may write things like `"tar -xvf=file.ext"` instead of `"tar -x -v -f=file.ext"`. (I really need to dcument these options more thoroughly.) 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8knab0/what_languages_should_i_learn_to_be_a_software/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ahh! I see now. :) I started from that interface firstly. But than I thought that current one will probably looks more clear : you see exactly were Base, were PossibleTypes... Plus you can directly build `variant_w_base` from `std::variant` type (kinda compatibility). And I needed exactly variant, not virtual classes(I have template functions) - possibility of using `variant_w_base` as local storage for virtual classes is kinda bonus:). That's why I didn't call it `local_ptr`. But you can easily fix it :) ```c++ template&lt;class Base, class ...Types&gt; using local_ptr = variant_w_base&lt;Base, std::variant&lt;Types...&gt;&gt;; ```
&gt; Yes, I will be happy to benchmark whatever library/framework/etc. that you come across, provided it has some form of documentation explaining how to use it. Since you more-or-less asked for it, maybe you would be interested in benchmarking my [apollo library](https://github.com/Oberon00/apollo/)? I dare say, the wrappers for C++ functions generated by its [to_raw_function / APOLLO_PUSH_FUNCTION_STATIC](http://oberon00.github.io/apollo/functions.html#converting-arbitrary-c-functions-to-raw-functions) mechanism have performance near the theoretical optimum (in my own benchmark had no overhead over a handwritten wrapper function). And it does have documentation. :-)
Sure, but come on, it’s not UB
 You might be interested in `std::is_invocable`. Unlike `is_detected`, it's already in C++17 and it directly expresses what you're trying to check.
[You sound oddly confident](http://eel.is/c++draft/namespace.std#1)... ;-]
Pull requests are also welcome, since you could probably do it faster than I could and I might not use the a b s o l u t e f a s t e s t way. But I did open an issue for it. I'll get to it in like 3 months or something, which is my usual turn around time for my smaller side projects.
Alright, the docs look not-terrible: I've opened an issue for it and I should be able to use it. Turn around time for these kinds of things, though, is like 3 months. .-.
I will look into it. I thought it was only used to check invocables before calling \`std::invoke\`. Ty!
Unless I misunderstood, that's precisely what `uses_metadata` is doing minus the fact that it uses regular call syntax instead of `std::invoke`. That simply limits its use, but isn't an issue here.
Right, desired behavior is **always** one possible outcome of UB. What does that prove?
Clang meet your expectations [https://godbolt.org/g/GDDmSi](https://godbolt.org/g/GDDmSi), with your hand-written union. Even if clang version would work as you expected, there is no requirements for this in standard. It *allowed* to have non-linear complexity for this particular case. Though standard does not **require** this... This is purely compiler / implementation good will. See previous discussion [here](https://www.reddit.com/r/cpp/comments/815zr5/stdvariant_and_accessing_baseclass_stdgetbaseclass)
So answer my question; have I introduced UB by writing a type `vector` in a `std` namespace on a platform without a stdlib?
Yep, it's perfect when you have an idea of the signature up front. I've been down the rabbit hole when you don't.
No, because freestanding implementations have different requirements regarding the standard library. But that obviously doesn't apply to this conversation, in which we're talking about adding overloads to an existing implementation. I don't know what you're trying to prove, but being "clever" and pedantic about things that are well-defined isn't helping your case, whatever it is.
XD
what exactly could cause random files appear in the source directories of your repo? or how else would a build won't be reproducible if you don't list files manually?
Thanks. So not UB. We got there in the end didn’t we
&gt; Command line argument parser (C++14) &gt; printf's in example Please, be consistent. Such things discourage everyone.
Compilers don't warn for this, but they do warn for assignment.
why the 'final' on structs with no inheritance?
Writing a motviating paper would still require a whole lot of work, especially to pin down the design details, and will likely go through some number of revisions before actually gathering enough consensus. I mean, everyone agrees that having a standard way to parse program options would be good, but good luck finding someone who actually wants to write the full proposal and support it through the end in the committee v0v
You need to use `typename` when accessing nested `args_decay` [here](https://github.com/p-groarke/declarative_functional_apis/blob/master/src/main.cpp#L98) and [here](https://github.com/p-groarke/declarative_functional_apis/blob/master/src/main.cpp#L101). `static_assert(false..)` is almost never what you want because it always [fails](https://stackoverflow.com/questions/14637356/static-assert-fails-compilation-even-though-template-function-is-called-nowhere). We needed non-type template parameter like [this](https://github.com/p-groarke/declarative_functional_apis/blob/master/src/main.cpp#L81) when C++ had no support for default template arguments for function templates. Now you can: template &lt;class... Ts, typename = std::enable_if_t&lt;sizeof...(Ts) != 1&gt; &gt; Function traits are [not easy](https://www.boost.org/doc/libs/1_67_0/libs/callable_traits/doc/html/index.html#callable_traits.introduction.motivation). Following won't compile: tuple_burrito.execute_freedom( [](char c, short s) noexcept { printf("%c, %d\n", c, s); }); function_traits.hpp:45:58: error: function cannot return function type 'void (char, short) const noexcept' 
&gt; getopt\(\) is POSIX. POSIX != standard While getopt\(\) is great, it is only a C library, isn't thread safe or object based \(just like many of the old c standard functions e.g. strtok\), doesn't come standard with MSVC \(no Windows support\), and doesn't support high level option aggregates like groups or sub\-commands. That being said, the documentation is extremely thorough which came in handy when I had to implement a conforming version to work on Windows.
what pain? https://bitbucket.org/hmbd/hmbdc-rel/overview
POSIX certainly is a standard. And why in the world should it matter if a *command line argument parser* isn't thread safe?
What sort of experience are you looking for? Do you have to be a 20 year industry veteran? Or just passionate about C++? 
Author here: actually, if you saw a graph of which blocks depend on which, you would see that you *can* in fact use: just the ui library, or just the scripting library, or just the reflection library, or just the 3d library. The reflection layer is used by all of them, but it's 4 kLoC (that's less than a third of what Dear ImGUI is), so... don't tell me that's too heavy a dependency ? You don't *need* to use the 3d module. You don't *need* to *do* anything to *replace* it, just don't use that module and you'll be fine. If you just want to use the ui library as an alternative to Dear ImGUI, the "strange opinions on reflection and serialization" won't affect you at all, they are only used internally, and the total is about the same size as Dear ImGUI (and it also does nodes, and docking) I didn't spend a year "gluing all this stuff together", but you're only just talking about something you didn't research at all by now, so I'm not sure you "respect" anything here. As for the "production hardened", that's actually your only valid point: mud is not yet. See you in a year and we'll see where we are.
Well, I apologize for being proud of a thing I took years to put together and refine, and for being enthusiastic about convincing other people to use it ;)
It's not a C++ standard. Or even C standard for that matter.
No need to apologize for that - and pitching skills are more valuable than i made them sound :)
They don't, really. They *only* dictate the semantics of any part that you want to write *in that generic idiom*. If you don't want to write anything in this generic idiom, or you prefer to use templates, that's fine: reflection in mud is *non intrusive*. Nothing forces you to generate reflection for anything. It's a tool just like templates. Serialization is non-intrusive also. Your c++ code is just regular c++ code. The serialization function will just be able to serialize attributes that are annotated (and either public or have a getter).
To mark it cannot be derived from (intent).
\- Is this some more custom behavior from VS? What compiler are you using? \- The static\_assert is in an if constexpr. \- That is an alternative... \- A nice catch, however I've never seen a noexcept lambda in the wild. Ever. It may be an issue if you really depend on noexcept. Out of curiosity, do you have a real\-world example where noexcept lambdas are essential? I would refer you to the post disclaimer : "*The examples are simple demonstrations, not meant to be production ready."*
&gt; Serialization is non-intrusive also. The documentation certainly makes it look like you have to modify your type to make it serializable...
As a huge user and proponent of Boost, IMO: not all Boost libraries are worthy of standardization, and program_options is among the worst.
It prevents EBO; don't do that unless you want to propagate the myth that FP in C++ is inefficient and pointless. ;-]
Overkill _and_ a measurable pessimization in non-pathological code.
What pessimization?
Read the article, there the answer.
Cwize1, Of these choices, we'd be closer to "just passionate about C++," but we really do want some level of real-world experience with the language. We don't test or interview volunteers, it is up to you to decide if you are knowledgable enough to help out. Do you watch CppCon videos? If you understand most of what you are seeing in most of the videos, then you are probably going to be able to help. Almost everyone will occasionally get assigned a submission on a topic that they feel unable to evaluate and we reassign that submission. But we want to avoid being in a situation where we have to do a lot of re-assigning because the PC member doesn't have enough exposure to the range of topic submitted. (Still, I'd rather re-assign than have a member be reluctant to admit that they'd rather pass on a submission.) If you think you can help out, then you probably can and I look forward to hearing from you. Jon
I think you misunderstand what level of support for macros is envisioned. To the best of my knowledge, NO one suggests that import my_module_A Should in any way be influenced by the current preprocessor state it would just add the macros exported by `my_module_A` to the current list of preprocessor symbols. Therefore, e.g. ordering doesn't matter. That being said, there is a whole lot of other problems with macros which I'm also strongly opposed to them being supported by modules at all.
Fair enough man, it looks great to be honest. Is there any reason it wouldn't work on android and los? 
Why does it ?
Why does a final class prevent EBO? Because you can't inherit from it...?
... well that's what I get for hanging on reddit with still a feet on the bed
**Company:** [Loki](https://loki.network/) **Type:** Full time **Description:** Loki (https://loki.network) is an open source, fully funded project aiming to develop a censorship and Sybil resistant mixnet built on top of a privacy centric cryptocurrency. We are seeking C/C++ developers of all skill levels, provided they can evidence a degree of proficiency and self-motivated work. University graduates, junior and senior corporate developers, and self-taught coders are all welcome to apply. Particular proficiency in any of the following areas is desirable, but not a requirement: *Distributed Network Engineering *Blockchain Technology *Information Security/Penetration Testing *Build Systems *Cryptography &amp; Mathematics *Qt/QML *Open Source Projects/git Developers on this project will work in a global team of driven and youthful engineers and professionals who share a passion for privacy technologies. We have offices in Melbourne and in the US, but applicants should be aware that they may be required to relocate for work or be comfortable working remotely. Developers working on this project must gain proficiency in participating in open source development, and once a level of understanding of the project has been achieved, be largely self-directed in their work, balancing their workload between assigned and self-assigned tasks as required. Junior candidates will enjoy a lively culture and a challenging, wide breadth of tasks and projects to work on, and senior candidates will enjoy an opportunity to be more flexible and self-directed whilst working on a project with potential real-world impact. Salaries and rewards will depend on the skill level and proficiencies of the applicant. The range of salaries would be from 50K-150K plus super and additional benefits. **Location:** Melbourne, Australia **Remote:** Yes **Visa Sponsorship:** Potentially, dependent on skill **Technologies:** C++ 11, Git and Github. We mainly develop in Linux environments but windows and Mac development environments are fine aswell **Contact:** Contact me via reddit PM for more details
Thanks :) No major reason it simply wouldn't work, but I didn't try these platforms yet so there *will* be a few issues. Then for ui specifically, there might be some event types to add to properly handle touch, and some work on handling high-DPI also.
Well it forces you to add it as a class member where deer ving would otherwise have been an option. Resulting in one extra byte + padding memory consumption.
Is there a way to do it outside of environment variables? Like passing -DBOOST_ROOT in CMake?
&gt; Clang meet your expectations https://godbolt.org/g/GDDmSi, with your hand-written union. Ah! Glad there's *some* sanity here :) By the way, replacing the `throw "Oops";` by `__builtin_unreachable();` improves code generation quite a bit on GCC; though it still manages to squeeze in a pointless comparison (if `== 1` jumps to `.L2`, else fall through to `.L2`, meh?). &gt; Even if clang version would work as you expected, there is no requirements for this in standard. It allowed to have non-linear complexity for this particular case. Yes, as usual it's a quality of implementation detail. Still, I must admit being quite disappointed with gcc here :(
Is the following code not problematic? struct secret_garden final { template &lt;class Invocable&gt; void visit(Invocable&amp;&amp; invocable) const { for (const auto&amp; d : _data) { std::invoke(std::forward&lt;Invocable&gt;(invocable), d); } } ... If you call visit with a rvalue, you move `invocable` on each call to `std::invoke`. If `Invocable`has a destructive move operation, you are in trouble. Do I miss something here?
I think you are right that this is bad code That being said std::invoke will not necessarily move even an r-value value reference, so this bug might or might not manifest in practice, which is the worst kind of it.
I've gotten in the habit if marking all classes that haven't been thought of as base classes final. I've experienced some serious problems in legacy codebases with rather extreme inheritance from classes without virtual destructors. Ultimately, if your destructor is not marked virtual, my opinion is to always mark final.
I hadn't thought of that \-.\- The post has been fixed, thank you.
You must activate `/permissive-` and MSVC still have many bugs. They still accept a lot of non standard code. Fully compliant is just saying that it pretty much support all feature with an "acceptable" amount is bugs remaining. Still, it will accept missing `typename`, it will accept `static_assert(false)` and other stuff like that. Sometimes I have code that just should never compile and it becomes SFINAE'd out.
Post is rectified. So much for trusting the new MSVC two\-phase lookup.
Yes well that'll teach me to trust MSVC ;\)
In theory, there's no guarantee. In practice, I would expect the layout of a "most derived type" to be fixed, and therefore the offset of any member will be the same no matter how many times you move/copy a value of such type. Under the Itanium ABI (followed by Clang and GCC, among others), I expect the offset to remain stable, even in the presence of virtual bases. The one time it will break for certain under the Itanium ABI is if you slice a "most derived type" with a virtual base. That is, if for `struct A {};`, `struct B: virtual A {};`, `struct C: B { int x; };` you copy a `C` into a `B`, then the offset of `A` in `B` will differ from the offset of `A` in `C`. In a move/copy constructor of your variant this shouldn't happen as far as I can see. I cannot say for certain that it would work with VC++, but I'd find it strange if it didn't work in general.
I am wondering if `invocable` variable could be transformed via `std::bind` so only `std::invoke(invocable, _data[i], _meta_data[i]);` could be used without any `if constexpr` as `std::bind` functor discards excess parameters.
Ok, thank you. Safer to stay with `m_base = std::visit([](auto&amp;&amp; any)-&gt;Base* { return &amp;any; })` then.
AFAIK in Meson you use env variables for that.
Interesting thought, definitely worth a try :) I don't personally find the if constexpr problematic, it states the intent pretty clearly IMHO.
I think it probably is UB, actually. 
Like I said in my previous comment, most POSIX things are not available in Windows \(it doesn't count if I have to use GCC/MinGW\). That is a fairly large target to miss out on. Speaking of Windows, ideally you want to use the command line arguments provided from GetCommandLineW \+ CommandLineToArgvW, discarding the arguments from main\(int, char\*\*\). In the case where the user enters the name of a file \(UCS2 is the native encoding on Windows\) you want to maintain that encoding losslessly. As far as thread safety is concerned, you are correct. However, as someone who has implemented getopt before, you need some sort of internal state to keep track of the parsing. optind is not granular enough for keeping track of parsing args like \-abc \(where a, b, and c are all options\). In addition, getopt permutes the input command line, so that non\-options are at the end. This means that getopt is not const correct. Ideally you would have something a bit more modern with an object that resembles the state of the parser, instead of relying on extern/static global variables, and an API that takes its inputs immutably.
You had me at "game loop" with g\+\+ inside! Awesome time waster effort!
But can you send game requests to your friends on Facebook? Jokes aside, I wonder how much of this meta\-trickery actual Candy Crush code uses.
Lead over-engineer of this "game" project here! I transformed my talk into a blob of text for those that prefer reading over watching a YouTube video. Nice to see that version ended up on Reddit too. Nothing too innovative into this project. I mainly blended C++17 features and idioms to my special needs. The idea being to expose the power of constexpr in a ludic way. If you have any question, you are welcome.
Probably none, since it has to compile on Xcode for iOS ;')
the tiny memes 
Providing that your friends are constexpr, we can definitely provide that functionality and your dream will become true! As for the meta-trickery. With our various programmer profiles and our current code-base, we are in the sweet spot where the C++ wizards will claim that there is not enough black magic in our tech stack, and the more orthodox will yell "vade retro satana" when they dive in some dark corners ;). To my humble biased opinion, the ideal is to rely on these kind of meta or advanced practices in the utilities or core of your stack, but try to reduce the exposure to the people writing business or feature code. In other words, I can understand that someone focusing on gameplay do not want to write such code, understand that she/he has difficulty reading it, but she/he should not by afraid that something deep down is working this way (or you could claim that everyone should be able to write or explained the internals of std::string to use it...).
&gt; Doesn't compiler have / can aggregate information about all instantiated types (in application range), which inherit Interface? It will have quite finite size. No because you can load types at run-time
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8kvlwi/help_compiling_openssl_on_windows/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don’t feel the pain as long I can pass messages between threads easily. 
For what its worth i never needed something like this to do those things. For a plugin i wd just make an abstract virtual base class, and make api take unique pointer to that. The user gives me a function pointer that yields this unique pointer to base type, if we want delayed construction. Done. What copies were we trying to elide again? For units in a strategy game, i never had this problem because IMHO using inheritance for this situstion is not a good idea. IMHO the only time ive found it appropriate to use inheritance in design of a large system is for abstract virtual base class interfaces. And even then you can do without and used type-erased delegates instead. (Inheritance is also necessary for EBO but i regard that as low level trick / optimization not high level design.) I feel like im not sure in what real situation I would use the trick in this article instead of just refactoring the code to make it unnecessary, but maybe theres a situation I didnt encounter or didnt think of.
Disallowing composition via private inheritance is arbitrary and unnecessary. Nobody is using C++ because they want their hands arbitrarily tied, and what you're suggesting prevents both optimizations and semantically valid code.
*You have received a DMCA takedown notice from King.com*
IIRC the latest committee discussions were more about having another way to fetch the command lines arguments from anywhere (à la `sys.argv` in Python) instead of allowing more `main` signatures.
Yeah, loading types at runtime is the bummer here. You'd need runtime compiled c++. I think C# is doing something similar. Thinking about it, as soon as you have virtual template function, you basically have runtime type traits and basic runtime reflection.
Did you set `/permissive-`? Otherwise it's going to allow non-standard MSVC extensions.
But... What about compile-time types only? 
The easiest way is to use Qt with QtQuick for the UI. http://doc.qt.io/qt-5/android-support.html
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8kxe96/programming_apps_for_android_with_c/dzbdurt/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
So if I understand correctly, on one terminal you have game_state.txt open and on another you constantly run render.exe on the command line which updates the content of that text file?
Your point? I donʻt do iOS development, but it looks like the target support for iOS includes support for clang 5 on my XCode installation here... Iʻm using clang 6 right now, for a couple of specific C\+\+17 constexpr issues, but I also havenʻt updated my XCode installation, so there might be clang 6 support for iOS targets now.
&gt; in my IDE. Which IDE would that be?
I love it. Definitely waiting for the full-compile time update!
It's wonderful! But you are not the only one who have to write multi-threaded code in C++.
Alright.. just wanted to confirm first before reporting it as a bug. Thanks!
What is an over-engineer? :)
why would you want to statically assert on something that will have absolutely no effect on any runtime behavior and the compiler could prove that fact.
 template&lt;class...Args, class = std::enable_if_t&lt;!std::is_reference_v&lt;std::variant&lt;Args...&gt;&gt;&gt;&gt; int f(Args...); int f(); int a = f(); // ok template&lt;class...Args, class = std::enable_if_t&lt;!std::is_reference&lt;std::variant&lt;Args...&gt;&gt;{}&gt;&gt; int g(Args...); int g(); int b = g(); // error Now which should I blame, `std::variant&lt;&gt;`, template instantiation, ADL, or this idiom? 
that's an entirely different test case: * you are actually calling the lambda * you have actual side effects in your constructor so. does the compiler do the assert in your case or not?
Is there an **easy** way to use upstream clang for Xcode, and it'll work for all platforms on Xcode, including debugging support etc.? iOS METAL debugging etc? And I mean an easy way to set it up. Some way you can (automatically) include it in your project/build process of your company. Built-in AppleClang is based on I think clang-4, still in Xcode 9.2 and possibly even in latest 9.4-beta. And it doesn't even have a conformant/working `&lt;optional&gt;` (yes they ship one but it's broken).
&gt; you are actually calling the lambda It doesn't matter. The OP's example on SO did call the lambda, my shorter code above didn't. I removed anything that wasn't relevant. &gt; you have actual side effects in your constructor Both the OP's code and mine are contrived examples to reproduce the bug. I suspect the reason you got downvoted so much is because you're questioning the purpose of an [MVCE](https://stackoverflow.com/help/mcve) instead of focusing on the bug it showcases. &gt; does the compiler do the assert in your case or not? It does not. I was trying to show you that the bug can hide something that a programmer would expect to be caught at compile-time. Apologies for now being clearer. It's basically compiling an ill-formed program with no diagnostics, one of the scarier things that can happen to a programmer.
Awesome side project. It remind me that a guy created a c++ template compiler for brainfuck when c++11 came out (sorry for the curious, I can't find it back). Both of those c++ over enginereed projects were really fun to read.
pardon me for commenting on the example in this thread and not something OP wrote somewhere else.
Now you're just being an ass. Your comment was top-level, which means you're replying to the OP, not to me. In any case, you're _still_ confusing code that reproduces a bug with a meaningful program. Finally, I understand this is reddit, but if you can't be bothered with reading the linked post, don't comment on it.
I came over here and got disappoint with the fact there were no warring factions postulating why expected is better than exceptions and vice versa.
This code is ill-formed NDR: there must be at least one valid instantiation of any template. 
The #1 point is a pretty big nice aspect IMO. Adding some inline macros is a far cry from how these systems usually work, i.e. one base class to rule them all.
I like the way author is completely unaware of cmake by saying installing files in meson is easier than CMake. Yeah sure it's hard in CMake: install(TARGETS foo DESTINATION bin)
Where did I say it is easier than CMake? Quote me please. I have used CMake plenty.
Where did I say it is easier than CMake? Quote me please. I have used CMake plenty.
Oh yes sorry I've misread the text. I've read difficult instead of different when you're saying that installing in meson is not different than CMake and autotools. My bad, I apologize.
Haha. No problem. I did not make such claims. This is a Meson tutorial. Not an attack to any other build system :p
Your question should be: What's a good over-engineer?
Because the syntax for conditionals, the space and escape handling were insane and I had to come back again and again to check and guess. It is not that CMake does not work correctly, it is just that I find it easier to work with Meson and if there is something where it lags behind, I can work it myself with the time I saved by those unhandable and frustrating CMake problems. Cross compilation was another place where I got deeply frustrated. The documentation is terrible also. It is like a man page: no examples, nothing. Keep in mind I do not make claims that CMake is not capable, which is a different thing. 
I think that code is ill-formed no diagnostic required, because the template must be valid for *some* type T, but no type can have sizeof(T) == 0. Not that I really think that's the issue here, but you could try `== 27`.
But again... You can't deal with any kind of templates with `dlopen`ed code... There is things you simply can't dynamically load. That's one of them. I don't think we need it to be runtime capable at all.
As a side note, gcc allows 0-length arrays without the pedantic flag: ``` using nulltype = int[0]; int main() { static_assert(sizeof(nulltype) == 0); } ``` works
Never used CMake but I find meson is pretty nice
The vague simplistic philosophy of programming talks like this need to be weeded out of conferences, this is unfortunately unwatchable despite the illustrations. 
I think everyone is too embarrassed that C++ is still debating how to return success/failure.
I had a very similar issue: https://stackoverflow.com/questions/50372167/if-constexpr-inside-lambda-differing-compiler-behavior/50375104#50375104
I disagree. The more tools we have to formally describe the behaviour of programs, the better off we'll be toward formally understanding them. Software Engineering should be embracing more of this kind of thing, not weeding it out.
Lisa's area of research is, roughly, provability and mathematical reasoning. It is not 'vague simplistic philosophy'.
Obligatory XKCD: https://xkcd.com/927/
Has anyone found the slides? Link please? (the official site does not have them)
I really like Herb Sutter's proposal. I actually have a type like that, a union of result type and error type tagged by a bool. It would be cool to have more built in support for that pattern.
[removed]
nice, I also enough of CMake, so I create my IDE project generator myself. https://github.com/Jasonchan35/ax_project_gen
Changing it slightly to: template &lt;class T&gt; struct S { static_assert(sizeof(T) == 1000, "Broken type"); }; auto f() { return [] { S&lt;int&gt; s; return S&lt;int&gt;(); }(); } int main() {} will again not trigger the "Broken type" on VS2017. It does work on gcc and clang.
y u do dis
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8l2q5h/simple_text_editor_cpp/dzccq6c/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Link changed: https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/
The canonical solution is to define something like this: template &lt;typename&gt; struct dependent_false : std::false_type {}; Instead of asserting size 0 (which some compilers will allow for a 0 element array)
I think the challenge is the pretty much the same for everyone. You could do it the hard way (mostly resulting slower code too), which involves all creative use of mutex and conditional variables, or do it the simple way by employing a good messaging tool.
If this is a bit too esoteric for some, I recommend her other talks, in particular, "What is the Basic Interface" https://www.youtube.com/watch?v=s70b2P3A3lg Also somewhat abstract, but hints at how this can lead to better ways of writing, and checking, programs.
#### [CppCon 2016: Lisa Lippincott “What is the basic interface? (part 1 of 2)"](https://www.youtube.com/watch?v=s70b2P3A3lg) ##### 4,338 views &amp;nbsp;👍28 👎5 *** Description: http://CppCon.org—Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2016—When we ... *CppCon, Published on Oct 4, 2016* *** ^(Beep Boop. I'm a bot! This content was auto-generated to provide Youtube details.) | [Opt Out](http://np.reddit.com/r/YTubeInfoBot/wiki/index) | [More Info](http://np.reddit.com/r/YTubeInfoBot/)
CommandLineIO does all of that.
Isn't Herbceptions mostly about effeciency though? Monadic error handling was claimed to give us more predictable execution paths without the syntactic overhead of constantly checking return codes. Or am I missing something?
Thank you! I'm would be open to provide it as an add-on. Unfortunately I don't know much about this. I'm more the Linux / Mac-user :-) Feel free to provide a PR (or a series of PR's).
Hi, no it works. The load was just to much for the server. Sorry for that.
Just make something fit what I need, when couldn’t find others
&gt; or do it the simple way by employing a good messaging tool This is the one of main points of the post.
&gt; It is like a man page I learned a great deal just from man pages. Once I know what I'm looking for, man pages are great. &amp;nbps; With cmake, even when I do know a very specific thing that I want information about... it's a terrible experience.
You need to have attributes to set different flag names or help text, and other semantics(such as short actions to show text, set to count of number of flags, and setting a value(or values) when the flag exists). Even using `std::optional` for a flag is not great either as many times you may have a default fallback when a flag isn't there(which is why an attribute is better). This is why I use the visitor pattern in [args](https://github.com/pfultz2/args) instead as it is simpler to add attributes: struct hello { static const char* help() { return "Simple program that greets NAME for a total of COUNT times."; } int count = 1; std::string name; hello() {} template&lt;class F&gt; void parse(F f) { f(count, "--count", "-C", args::help("Number of greetings.")); f(name, "--name", "-N", args::help("The person to greet."), args::required()); } void run() { for(int i=0;i&lt;count;i++) printf("%s\n", name.c_str()); } }; 
You should tell the Factorio guys :)
Thanks!~
I think that rule is only for constexpr templates
Where is part2 of the talk? I couldn't find it on Youtube. But I found this talk, [https://www.youtube.com/watch?v=1b\_W23lyTPw](https://www.youtube.com/watch?v=1b_W23lyTPw) from BoostCon 2016, it seems to be the same talk but in full length.
I don't think this is correct. C++17 in 17.7/8.1 (emphasis mine): &gt; The program is ill-formed, no diagnostic required, if no valid specialization can be generated for a template [...] and the **template is not instantiated** Since the template is instantiated, a diagnostic is required. The "no diagnostic required" rule is mostly annoying with a non-dependent `static_assert` in a class template, where compilers disagree on whether it should be evaluated during the first phase or when the template is instantiated. In any case, since the `static_assert` in my repro code fires when the template is instantiated outside a lambda or when moved into a constructor, my assumption is that Visual C++ intends to always generate a diagnostic and that this particular case is an oversight.
And mich of that is due to a weird language with weird rules
Premake5 pls
why have you ditched premake then?
If the slides are not available yet, can we _not_ have the talk name be clickable? It would be a lot less annoying to see what is available at a glance, rather than being redirected to what amounts to a 404
No there is a syntactic sugar too. For example function returning int declared as throws is in fact returning expected&lt;int, std::error&gt;. Another important thing is an expression operator try similar to Rust's operator ?
1) I need something like Unite/Bulk build in Unreal which will compile multiple .cpp file at once to speed up compile time 2) Better way to manage project settings (include_dirs, link_files) for example, my_program.exe depends on my_lib project, it will inherit all those settings, which mean my_lib project already declared all settings needed for other project use that lib, 3) I don't want lua or other 3rd party code other than C++11 In fact Premake is pretty close to what I need only minor thing I don't like, but building my own one isn't that hard and I'm not intend to replace Premake, I just made a small tool to help myself out, and I learnt a lot from it and fun 
Is it a conflict of interest to sit on the Program Committee and also have submitted talks / have desire to be a volunteer?
ave a lot to catch up in the last year.
as far as my knowledge goes, for showing the files related to a target in IDEs.
Today I would like to talk about a build system I have been using for a while and what brought me to it and to discard the alternatives.
I do this too! `if (auto foo = do_something()) { // use foo } else log &lt;&lt; foo;`
RemindMe! 1 week
I will be messaging you on [**2018-05-28 23:21:01 UTC**](http://www.wolframalpha.com/input/?i=2018-05-28 23:21:01 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/8l0iir/opening_keynote_the_shape_of_a_program_lisa/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/8l0iir/opening_keynote_the_shape_of_a_program_lisa/]%0A%0ARemindMe! 1 week) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8l5bte/best_c_book_that_covers_more_than_just_c98/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The post refers to the relatively old paper (2008). There is also a newer project by one of the same authors (ROBERT A. VAN DE GEIJN) is [BLIS](https://github.com/flame/blis)
https://github.com/flame/blis/wiki/BLISAPIQuickReference "dcomplex z struct { double real; double imag; }" Funny how people keep needing to reinvent complex number types. They are already in the standard library - even the C99 they wrote it in.
How does this compare in speed to something standard like eigen or armadillo?
Technically, they aren't in the standard library of C; they're literally just in the language.
Yes
https://www.reddit.com/r/cpp/comments/8jxjha/overload_build_a_variant_visitor_on_the_fly/
Thank you, and I don't know how I missed that. I've deleted this submission. 
That's just blatantly not true. read complex.h before you comment next time.
 template &lt;class T&gt; struct S { static_assert(sizeof(T) != 1); char x[sizeof(T) != 1 ? 42 : -42]; }; int f() { auto x = []{ S&lt;char&gt; s; return sizeof(s.x); }; return x(); } Now the code cannot be eliminated, but still no error on MSVC.
Nobody uses it so there hasn't been much need to frown upon it too hard; there's enough frowning as is.
I'm seeing newer high performance technologies in the big data and machine learning ecosystem adopt C\+\+ over something like Java.
I think that's completely different.
Recent post related to this: [Performance experiments with matrix multiplication](https://redd.it/8ivhit)
There is this library that already uses te namespace - https://github.com/boost-experimental/te
What I don't get is this: IIRC early C\+\+ compilers \(in the nineties\) already used this technique, bubbling exceptions up by having exception\-specific code in every function call. In that era C\+\+ had a reputation for being slow \(slower than C, at least\), and the laborious exception handling on every function call was identified as an important reason for this. Later on exceptions were implemented using a table\-based system where only if the exception actually gets thrown, i.e. almost never, any time is spent on exception handling. Now we have a proposal to be return to the old, slow way. My question is, "what's different now?" Why should we go from a true zero\-cost exception system \(i.e. no processing for the non\-exceptional part\) to an exception system where we pay on each function call, regardless of when exceptions happen, unless the function happens to be one of the happy few that will never throw an exception? I certainly see what the attraction of the OOM\-abort feature is: it elevates numerous functions to being exception\-free, thus removing the need for exception processing in its callers. All in all, I'm not happy about this proposal: it brings back something that was already proven to work badly, and it breaks existing code on a grand scale to make the pain of that bad design slightly more palatable. And unlike the existing exception mechanism, it specifies implementation, rather than an abstraction, thus setting this bad decision in stone for all eternity. 
The blog post with the features is linked. Did you read it?
I noticed if you access directly the folders you can see the only available talks.
Or you can mouseover the link, those that are not there link to special page. It is still terrible UX.
&gt;flops/s
Well, at least we can guess a bit before opening :)
Yeah, in C++ they are a library type, although requiring binary compatibility with the C version, but in C there's no such thing as operator overloading so they had to make it part of the language. It's a pretty good argument in favour of operator overloading, to be honest. There are many mathematical types which would benefit from the same thing, and adding them all to C as language types is a bit silly.
I don't think so - but there should be a mechanism to not allow you to vote for your own talks... At least I hope there is one! :D
It looks really nice. I am hoping it gets adopted and there will be implementations or proof of concept implementations. But knowing C++ it will take years, even if adopted.
Complex number are in the language, but incredible slow in GCC. GCC tried to implement std::complex with the help of \_Complex \(C99\) and \_Complex is so ... . Go and try to measure the speed of the multiplication of 2 \_Complex numbers: it's soooo horrible. If you want speed with complex numbers, you have to reinvent them. :\-\( But you should follow the interface of std::complex. Don't blame BLIS about reinventing the complex numbers, blame them for not following the interface. \(BTW: older MSVC compiler had slow complex numbers too, but they are OK since VS2015\)
&gt; If you have any question How much free time do you have on your hands and shouldn't you use your powers for good?
&gt;What's different now? In Sutter's proposal, under the cover, exceptions are small values handled like return values. It is expected this will eliminate the performance problems brought in by the frame\-based exceptions. &gt;Why should we go \[...\] ? Sutter is acknowledging the C\+\+ community is divided, and that it leads to bad design/code, and proposes a solution that eliminates the costs of exceptions, at the price of limiting them to small, trivial values. Let's wait to see if an implementation confirms the expectations.
This is a very, very interesting proposal. Are there any plans to have a beta implementation on some compilers to test these now "exceptions\-light"?
God, this would have been fantastic for my software development class a few months ago.
I didn't believe you at first but well... [shit](https://godbolt.org/g/4MfCYj)
&gt; I need something like Unite/Bulk build in Unreal which will compile multiple .cpp file at once to speed up compile time CMake can do this
Try with -ffast-math... Complex operations as specified by C99 standard (I believe) have some complicated handling for the case when at least one of the components is NaN. The gist of it is that if you do multiplication the naive way, a NaN component ends up "infecting" both components of the result, which breaks the definition of complex infinities. Python has similar issues: https://bugs.python.org/issue25453
Are you planning to introduce generation of CMake files? ;) Normally this is what people do when strange/unsupported by IDEs build system is used. Besides you could have just implemented generation of CMake files and let the CMake do the job of generating makefiles, vs, xcode etc.
It is currently expected end of this year for first prototypes. We just need to get the proposal documents up to sufficient detail that compiler engineers could have a feasible try at implementing them.
good to know, but CMake is slow, and the syntax is really unfriendly
Machine Learning front ends can be python, [backends can be C++](https://github.com/tensorflow/tensorflow) AAA games Hi Frequency trading
virtual machines other languages are running on
I remember hearing a phrase in one of the latest cppcast episodes (cannot remember which one exactly) that it is very hard to argue as to what c++ developers actually do. Some might use it to analyze large amounts of data, others for embedded system and some are using it for web development. But generally, I think that c++ is used primarily when performance is essential e. g. games, 3D/2D graphics software, audio processing etc. 
Regarding to Machine Learning, I thought that it is usually meant as applications (that's exactly front end).
I guess the conclusion you want me to reach is "an engineer that over\-engineers"? Sounds like a very strange job position.
So it looks like CRTP might only work if you only have interfaces and leaf classes, but never have two classes which can be used independently but one inherits the other and both need to be in the CRTP? Like this: template&lt;typename derived&gt; class A; // CRTP base template&lt;typename derived&gt; class B : A&lt;derived&gt;; // CRTP middle class C : B&lt;derived&gt;; // leaf class But you can't inherit a D from C that overrides the base functionality at all, without making C a template that can't be used _without_ deriving it like this: template&lt;typename derived&gt; class C_base : B&lt;derived&gt;; class C : C_base&lt;C&gt;; // Literally only exists to allow for instantiation of C/C_base class D : C_base&lt;D&gt;; // D has to inherit from C_base not C 
As of my post the op was 100% upvoted
C must be made a template, yes, but it could certainly be written such that it could be used without deriving it (via specialization or `if constexpr` or SFINAE+overloading).
See [P0798](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0798r0.html)
Virtually anything real-time (strict latency requirements): signal processing, robotics control, financial transactions, medical devices like pumps and pacemakers.
Person from medical field here. The shift from c to c\+\+ is slowly coming in the high safety embedded systems in the medical field
You mean that one of V8? It's light years behind what Sol provides IMHO, it's much more complicated.
In the same field, which is understandably conservative. C still dominates, but C++ is on the rise, at least on LinkedIn :)
- Most big content creation desktop software. Office, Libreoffice, Adobe programs, all audio workstations, inkscape, krita, etc etc. Here's one I work on : https://github.com/OSSIA/score - Most game engines (unity3D, unreal engine, cryengine, etc) - Big UI toolkits (Qt, WxWidgets) - Imaging (for medical, robotics, or research goals) : VTK, OpenCV... - Compilers &amp; interpreters (GCC, LLVM, but also the JVM, Javascript engines, etc) 
I just did a very similar test myself, on a ThinkPad P51 machine (i7-6820HQ CPU, Quadro M2000M GPU). The results for same 1024x1024 matrix multiplication: OpenCV: regular=780msec, AVX2=26msec Eigen: regular=100msec, AVX2=67msec, using Intel MKL=12msec GPU(cublas)=3.2msec processing, 5.7msec overall with copying 
Is the code that you used for your benchmark available somewhere so that one can reproduce it on its own system?
I certainly could find a way to cure cancer using constexpr, but I deemed it too boring. More seriously, I struggle to find the energy to commit on long-term projects after going out of work. That kind of pet project is rather small, "fun" and makes you explore corners of C++ you would not use everyday.
Re operator overloading: Long ago I attended a machine learning course in Java. I’m still traumatised from entirely straightforward algebra being implemented by convoluted chains of method calls. The multivariate Gaussian kernel looked something like this (using JAMA): final Matrix D = X.minus(Mu); return pow(abs(Sigma).times(Math.pow(2 * Math.PI, k)), - 1 / 2).times( exp(D.transpose().times(Sigma.inverse()).times(D).times(- 1 / 2)) ); Mind you, this required helper functions that JAMA didn’t even provide. — Whenever a Java proponent tells me that operator overloading harms more than it helps, I show them this code. It shuts them up without fail. Luckily these people have become rare.
I think it points to an underlying issue of template types not being what they should be in lambdas. 
Maybe it's just me, but I really don't think the c++ version would look that much better.
Please adopt it to the next C++ standard :&gt;
With operator overloading you would get something like: const Matrix D = X - Mu; return pow(abs(Sigma) * pow(2 * Math.PI, k), - 1 / 2) * exp(D.transpose() * Sigma.inverse() * D * (- 1 / 2)); 
Yes, and I don't find that that much readable. But I'm currently on my mobile. Might be different on a proper screen with syntax highlighting.
Yes, and in C++ I’d probably rely on ADL and make `transpose` and `inverse` namespace functions and call them `t` and `inv`. (And I’d probably write `- … / 2` instead of `* -0.5` but there are arguments in favour of the latter.)
Meson can do pch and unity builds out of the box :)
Meaon can do Unity builds and pch out of the box
It contains *significantly* less clutter (i.e. empty syntactic noise), which makes it much easier to see the structure and find obvious mistakes. — I missed an opportunity here: I should have introduced a bug in the original and see if anybody would catch it. In the C++ code, a wrong order of operation is much easier to catch. It’s also trivial, at a glance, to see the rough structure of the equation: we are multiplying two terms, one of which is an inverse of a square root (I’d write this as `1 / pow(…, 0.5)` — in C++ that’s possible; in Java it isn’t). And the other is a power of 𝑒 — Good luck spotting this structure in the Java code. You can now also rearrange the operations to match the typical way of writing the equation more closely: It’s conventional to put the scaling constant before the Sigma in the denominator of the first term but JAMA doesn’t allow this because it would require adding methods to the `Double` class (or `double` primitive type). We therefore have to write `abs(Sigma).times(…)` instead of the more usual `… * abs(Sigma)`. It doesn’t matter much but it’s an arbitrary restriction.
I have only one question: does the new version allows to pass arbitrary (run-time decided) number of arguments into format function at once? Yes, I do see a family of `v*` functions (`vformat()` etc.) but it seems they take `format_args` which can only be constructed with help of variadic ctor (which implies compile-time fixed number of arguments) or from `format_arg_store`, which in turn can only be constructed only using variadic ctor (which again implies compile-time fixed number). So to me, answer seems like a "no". To achieve the feat we can either rely on containers, which implies homogeneity of arguments types both in language and lib meaning or build the argument list one-by-one, which will probably add some overhead, but still is useful. It doesn't look like an impossible task, in fact I believe there were a couple of GitHub issues exploring the problem or even this [stack overflow](https://stackoverflow.com/questions/39493542/building-a-dynamic-list-of-named-arguments-for-fmtlib) question. Is there a reason why such functionality is not added into the library?
Compile time checking of format strings? Yes!
Most compilers have vectorization passes that are optimized at least for matrix multiplication. All you have to do is ensure you align your data properly (to 64 byte is best, don't forget to pad each line too), inform the compiler on the multiplicity of your matrix size (use assert(width % 16 == 0) and assert(width &gt; 0)) and enable -O3. There are cache prediction, branch prediction, pipelining, superscalar, vectorization issues that your compiler is fine tuned to. Also, the main speed up of other libraries is to do matrix transpose as infrequently as possible because that's what is actually expensive (shoking, right?).
I won't get to try this out until this weekend, but how does the compile-time checking of format strings function with regards to run-time construction of said format strings? Is this a configurable thing, or if it can't be done, it drops to run-time checking? (Or am I totally misunderstanding things? I'm pretty new to this - I just integrated 4.1 to my code *last* weekend, and still have plenty to learn.) Thanks for the great work!
When is Sol3 ready to use?
Afaik, anything you can do in C you can do in C++. Very few C constructs are invalid in C++, and wherever they are invalid, C++ usually provides a better alternative. For languages like Python, the difference in syntax is obviously larger, and I guess Python natively provides constructs that C++ doesn't. However, C++ provides the building blocks to let you build new constructs that can give you the same expressiveness. Combined with today's levels of compiler optimization capabilities, it is often possible to write highly expressive C++ code that is compiled down to assembly that is more efficient than what a highly skilled assembly programmer could produce. For instance, I have a friend who implemented Python's range function, to be used in a range-based for loop: if (auto i : range(1, 10, 2)) { // use i } He then implemented the same thing with an old-style for loop, and the produced assembly was identical.
Well I'll be damned. The test checks only checks that `max_size()` is greater than zero. Thanks friendo. Fixed.
Well I'm sure my goal of having a short namespace name would've had me colliding with *something*. At least the meaning is the same.
How would you call any function with arbitrary run-time decided number of arguments? 
I mean "argument" in a sense of this library, i. e. a pair of either number\-value or string\-value. Whenever you pass them to library facilities they are compacted into a single object (`format_args`). The question is whether can we construct it dynamically, or more specifically decide a number of "arguments" included at run-time.
The user has to wrap the format string in the fmt\(s\) macro \(due to current limitations of the language\). If you pass a string \(possibly dynamic\) without wrapping it, the checks will be performed at runtime.
I would expect the compiler to possibly optimize the get\(\) call away instead of actually copy eliding it, if it can deduce the get\(\) call has no side effects.
The library doesn't provide any public API for dynamically constructing argument lists, so you'll need to rely on some internal APIs to make it work and it will be a bit cumbersome. Technically this should be possible, just noone implemented a nice API yet.
The get() call allocates memory – at present (pre-[P0784](https://wg21.link/p0784), should it ever be approved) I think that always qualifies as a side effect.
Thanks for the clarification - one more follow-up, then. Is there a way to *disable* run-time checking, depending upon the cost of it? (This would be useful if I *know* my format string is valid, for example.) Thanks again, and apologies if these are all simple questions that half an hour of looking at the new version will answer!
Well, that's the point of my post. vector's constructor is not noexcept (because allocating the memory can throw bad_alloc) so it can't elide that way, and size()'s implementations are generally based off of the start and end iterators and the operator-, so there isn't even data continuity in terms of copying member variables.
Just from this code, why wouldn’t the calls to foo methods be inlined and then the extra copy removed?
Very nice and well-written library. Fun to use!
I’m sure you know more about this than me but what does vector’s constructor, noexcept or not, have to do with this?
Note that this is just one possible explanation why copy elision would not occur in this case (there may be more than one reason). Think about it this way, depending on the branch taken during construction, size() may return either the original size or 0.
Surely that doesn't fly. If the branch predictor misfires, you might end up losing 200 cycles or so, but you'd lose far more by having to test every 'throws' function after every single function call - having those tests everywhere stacks up quickly, especially for CPUs without branch prediction. Having those alternative paths everywhere is also likely to make inlining harder, which would cause additional performance loss. 
Ah, I see your point now. The get() itself if done literally copies a value so calls the vector() constructor so could throw. Interesting question. 
Van De Geijn runs the flame group 
Ok I see what you are trying to do, but don't quite understand why. What is the real world use case?
This is already possible via [allocation elision](http://en.cppreference.com/w/cpp/language/new#Allocation), and clang and libc++ have done most of the work, but there are a few bugs (I think) that mean it doesn't quite work yet for std::vector. See: https://godbolt.org/g/m95ANf - this example exploits allocation elision support in libc++ and clang to elide the allocation for a toy vector class: template&lt;class T&gt; struct vector { std::allocator&lt;T&gt; mAlloc; unsigned mSize; T* mData; unsigned size() const { return mSize; } ~vector() { std::destroy_n(mData, mSize); mAlloc.deallocate(mData, mSize); } vector(); // TODO vector(vector const&amp; rhs) : mAlloc{} , mSize{rhs.mSize} , mData{mAlloc.allocate(mSize)} { std::uninitialized_default_construct_n(mData, mSize); std::copy_n(rhs.mData, mSize, mData); } }; There seems to be something wrong with `uninitialized_copy_n` which would be the obvious choice for the copy ctor that prevents the elision optimization, so I'm having to use `uninitialized_default_construct_n` plus `copy_n` instead. Also I'm using `unsigned` as the size type because Clang is smart enough to spot that an allocator request for more than 2^64 / sizeof(T) elements can never be satisfied. (But this doesn't prevent the optimization entirely, it just means that we get some throw code as well.)
Are you sure it isn't the fact that you're storing size in a member variable that allows the elision?
No mention of it.
It was well-received at the [Jacksonville](http://www.zverovich.net/2018/03/17/text-formatting-jacksonville.html) meeting, but I would defer to someone more knowledgeable as to whether LEWG were thinking C++20 or C++23.
Having read through the provided link, and subsequent readings, the only justification I can find is that Dennis Richie said it was an abomination. I don't find that to be a convincing argument, especially since it's a requirement to use for well functioning C language programs. *shrug*.
It's been a while since I used fmt, so my wording may be off, but you know how in c you can do printf and have the same issue you described? C has snprintf, which lets you print into an already existing buffer and returns the length written into the buffer. For the next write you just give it a pointer moved up by the number of characters written earlier. For fmt, I did something similar since you can write directly into buffers. Worked great for me as a workaround.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8lcb57/need_suggestion_for_good_c_programme/dzefasm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It is actually doing both of this in the same terminal, successively and repetitively. 
File an issue. That's how we did it last year. One of the volunteers is doing most of the work; I leave it up to him.
Hey, thanks for your feedback. I appreciate it. I'm currently re/writing the last chapters and really hope to get it out before summertime, but now that you're mentioning early access, this is definitely something I'll think about. Thanks for the suggestion.
More precisely, to be able to qualify or somehow programmatically enforce the elision based on some knowledge of copy constructor invariance.
Yeah that would be nice. There are a whole lot of invariants of my types I'd like to be able to tell my compiler about, but that doesn't really seem to be a thing (it seems to me that optimizer still work primarily on the level of functions)
I don't think the missing noexcept should be a problem: The compiler has the permission to elide copies, even if they would have side effects. But I don't think copy Ellison (as opposed to the as-if rule) does apply here in the first place
In the future, don't remove your posts. That's rather bad manners.
In the future, don't remove your posts. That's rather bad manners.
Where do you think `std::vector` stores it?
Why is it that everytime I see a post / discussion / paper / presentation about "error handling" it is never about the actual **handling** of errors, but their reporting / signalling / transportation?
If you want to enumerate all of your concrete types, you can also just use `std::variant` which provides a form of runtime polymorphism. You can easily write a class that stores a `std::variant` inside. That class can have template member functions, that call `std::visit` for their implementation. This is honestly a much more idiomatic way to do what you are suggesting.
Why was the write API removed? I used it for things that were speed sensitive, and I don't really see a replacement in the format API, regardless of how constexpr parsing the format string is.
I've never been a big fan of chaining operations together. At least not with `.`; maybe `|`. auto res = lifted(function1)(some_optional) | lifted(function2)(some_optional); 
Honest question: What's the advantage if a library like this becomes part of the C++ standard? There's nothing stopping us from using it now, even in older compilers. But it seems to me that it only makes release cycles slower, and it becomes harder to make breaking API changes (which is simply a major version bump now). What am I missing? 
I'm wondering this as well, and also if there is a way to implement formatting for my types *without* using `format_to`, which has to parse a string. It just feels inflexible to have to express the formatting logic of my types as strings. For formatting general output, format strings are amazing, but not for stuff you want tight control over.
It can be used out of the box without requiring people install a third-party library.
because it's so hard to formulate a clear opinion what to do with all of those available options and techniques
most implementations only store the end iterator and size() is defined as end()-begin().
I didn't. What are you referring to?
I think the `format_to_n` provides a replacement for the `ArrayWriter` class (since a raw pointer is also an output iterator). And I think there was a buffer class added that accepts an allocator type. I liked the writer API as well, but I think they want to focus on the part proposed for standardization, which the write API wasn’t part of
The text of your post just says [removed]. Maybe mods removed it, not you. If that's the case, sorry!
Oh, interesting. Yes, that could be part of the problem - although there's nothing stopping Clang working out that `end() - begin()` stays the same through the lifetime of the allocation.
Not sure if this is a point of confusion, but, just to be clear, the user wouldn't implement `lift()`, it would somehow be part of optional. I just see it more as "I have this function, but it is the wrong signature...". Maybe both interfaces have value. Maybe I'd be happier just by renaming `.transform` to `.transformed_by`. That might help. Dot-chaining is often used for builders, where you are modifying the object (on the left of the dot), whereas here it is always returning a new value on each dot. Fine (functional/immutable is great really), but also not obvious until you are accustomed to it. I just don't find any of the syntaxes great. It is like we are trying to be functional, but don't have the language for it. At the same time, Haskell has `do` notation, to look more procedural. You might be able to bury it all (ie the conversion to a "optional-friendly function) in an operator? auto res = find_first("foo") &gt;&gt; function1 &gt;&gt; function2; But mostly, just wondering what people thought, so thanks for your thoughts.
https://github.com/fmtlib/fmt/commit/c2f021692f6fa3ddd4c9fe71526158139e8108e9 https://github.com/fmtlib/fmt/commit/87b691d80c46770d2159aa3100ba441336366228 Looks like they were merged with a different class.
[removed]
One of the early motivating examples in the paper is allowing std::tuple&lt;int, std::string&gt; t(1, "hi"); t[0] += 41; t[1].append(", mom"); How do you implement that without a template?
Seems your right, my post looks like its been "shadow removed". No idea why. Did I break any rules?
Personally I think allowing class types as non-type template parameters ([P0732](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r1.pdf)) offers the same functionality in a way that is nicer and more consistent with the language as a whole, but maybe that's just me.
RemindMe! Tomorrow
I have not seen the talk yet but I'm going to tentatively agree with you *strongly*.
He meant his own post.
I'd strongly prefer [string interpolation](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated). Even Javascript has it now :P
Yes, this paper is a good start. This proposal (if implemented as a template) will actually play well with P0732 too, because it would allow more types to be constexpr parameters.
Ahem... Ok. HOW do I know all concrete classes? That's the thing. If they would be deductable by compiler, it would be possible to have virtual template members with technique similar to this (maybe even at language level). But as /u/grishavanika said, currently this information could be available only at link-time [even if throw away rum-time types (that one, loaded with `dlopen`)].
Also it can be optimized more easily for specific systems.
An alternative to constexpr parameters as implicit template parameters: template&lt;auto X&gt; void func(X) //this would have the following signature: template&lt;auto&gt; void func(); { } int main() { func(42); //builds func&lt;42&gt;(); }
Say you want to call `fmt` from your scripting language. You don't know the number of arguments until you parse/interpret the script.
FWIW, Haskell has an operator `&gt;&gt;=` for the bind (`function{1,2}` returning an `optional&lt;T&gt;` instead of a `T`).
Seems that it requires reflection.
`template&lt;auto&gt;` already has a meaning, and it's not that.
I think it's not about the template auto, but the repetition of the variable name inside parenthesis.
If you are only using thermal then lean gdb 
Makefiles. And depending on how big your hobby projects are, a program like cmake or qmake to generate Makefiles for you.
Do you mean `func(42)` should be (in certain cases) auto transfromed to `func&lt;42&gt;()`? This can be very tricky in the presence of overloading.
like gracicot said, what I was talking about was using non-type declarations in a similar fashion as type ones. template&lt;class T&gt; void func(T); //func(42), T deduced as 'int', calls func&lt;int&gt;(42) template&lt;int T&gt; void func(T); //func(42), T deduced as '42', calls func&lt;42&gt;() The above has no impact on what template&lt;auto&gt; means in any way.
Paging /u/charleyb123 (unless someone else is squatting his handle here)
There is no way to disable runtime checking and I don't think it will save much in terms of performance because you still need to parse the format string. What will really improve performance is generating optimal formatters at compile\-time that was suggested by Louis Dionne: [https://github.com/fmtlib/fmt/issues/613](https://github.com/fmtlib/fmt/issues/613). Now that the format string parsing is constexpr, it should be doable, but it's not implemented yet.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
We use the "plain C" method now and from what's linked that's still the fastest option.
ISO C\+\+ papers are welcome =\)
Thanks again - it looks like I have plenty of reading to do and a few things to try out. I'm looking forward to playing with the new version soon!
Yeah... Not gonna hapoen. Do simple types such as vector or std::string even have compiler-specific optimizations ? In this day and age, if you want such an optimization, write yourslf a clang plug-in.
Please don’t use URL shorteners, as they trigger reddit’s spam filter. I’ve manually approved your comment.
One thing I'd like is being able to tell the underlying buffer, if there is one, to reserve space if you know the size beforehand. With the write API, this was kinda easy to add, as if you write two `int`s and a string, you can easily work out how many bytes are written in the worst case. With the write API (slightly modded) I had something similar to this: auto format(const Foo&amp; self, ...) { return StructPrinter(writer, "Foo") .field("bar", self.bar) .field("baz", self.baz) .finish() } With the output: Foo { bar = 123; baz = "hello"; } I guess `StructPrinter` could be written using `format_to`, but I'm worried about compile times. I also could never figure out how to handle indentation in nested structs properly properly. I think I might have made a wrapper of `Writer` which added indentation on newline, and then called the inner `Writer`. Not really related to writers, but it'd also be nice to have a trait to check if a type is formattable, so that you could, for example, make a wrapper type that just outputs something like "&lt;not formattable&gt;" for types that aren't formattable. This is really nice for tests and debug output, where you want to try and output everything possible automatically.
It seems to me that values \&gt;= 0x80000000 stay as hex. Probably because they would be negative as 32bit integers.
GENie 4 lyf
For vector there's only so much you can do with what the standard allows (for example no small vector optimization). For a formatting library, since each system will have different syscalls for file/console output, some implementations might be more efficient on specific systems.
I figure people are used to dot chaining acting like a pipe operator because of .Net's Linq and Java's streams. A dedicated functional pipe operator would be better, though. But then again, people will want to be able to write a placeholder token indicating what argument position the piped value should be placed in. The inevitable library solutions to this will be a dark contract.
Still has pow rather than "**", enforced superscript, or some equivalent. Then again, I think C/C++/anyone-else's use of "=" is clutter, since it uses a mathematical term for wrong meaning... I am still hoping for efficient parsing of LaTeX equations in code at some point...
I found his repo via [his website](https://bobsteagall.com/2018/05/13/cppnow-2018-trip-report/): https://github.com/BobSteagall/CppNow2018. It has a PDF. Looks as if it's literally that: a DFA for walking through UTF-8 glyphs, and then he adds SSE.
One of the advantages is in the really long term: many libraries somewhat try to support semi-old compilers, but not actually old ones. Once a library is in the standard and works, no matter how old your compiler is if it implements the library you're guaranteed that it will work. Also many libraries target only a subset of compilers (typically GCC, Clang &amp; MSVC) and aren't guaranteed to work on other compilers. If it ships with the standard library, you still have a guarantee that it will work provided said standard library implementation is up-to-date enough. In a first time it doesn't make much of a difference since adoption is long, but in the really long term it helps.
I care about job's done and my own happiness with MSVC, not some ethereal "support of C++ standards"
I haven't tried Conan but from experience with other package managers, the most important part long term is that you can also run a package repository on your own, so you're not fully dependent on the service being kept alive and you can publish your own closed source packages. Does Conan offer this option? Really need to get to play around with it some more. At least I already added some tasks to one of my hobby projects. :D
What I mean is that I may not know how to write a library that relies on template metaprogramming for every compiler taking all the subtleties and bugs into account, but if said library is part of the standard library, you can be sure that standard library implementers will make sure it works for their own compiler, so relying on that new part of the standard library (once widely available) should mostly work everywhere.
&gt; Not sure if this is a point of confusion, but, just to be clear, the user wouldn't implement lift(), it would somehow be part of optional. Right, it's having to call it yourself every time you have a callable that interacts with `optional` that I dislike (unless I misunderstood the code example itself). -- &gt; You might be able to bury it all (ie the conversion to a "optional-friendly function) in an operator? This is my personal preference, vs. dot-chaining, but I don't have the operator-overload phobia that some C++ people seem to have.. I'm not partial to `operator&gt;&gt;` in particular, but as long as something with reasonable precedence is chosen I don't care too much which one.
&gt; but if said library is part of the standard library, you can be sure that standard library implementers will make sure it works for their own compiler I want to agree with you, but `std::regex` begs to differ. ;-]
&gt; For a formatting library, since each system will have different syscalls for file/console output, some implementations might be more efficient on specific systems. A formatting library does not do io. With fmt you still use std::cout/cerr/printf/qDebug/whatever if you want to display the formatted string. 
Microsoft made their own fork of range-v3 which still works better on MSVC than the original library (even though there is ongoing work to make the main range-v3 work with MSVC) v0v
Having a power operator would be even better, yes. I feel that this rather reinforces my point, actually. Conceivably you could overload `^` as the matrix power operator for a linear algebra library. Dangerous territory though.
Clang and gcc are also Open Source and probably more interesting to look at?
I'll start seeing if I can make something pretty. But FWIW, it's also to encourage presenters who click their link to be reminded to send their slides to the appropriate e-mail address... but, well. I'll just kill the links and bother them all directly at some point. :D
Yes, /u/drodri is right. We are using a conan server installed on our internal machines, so we don't depend on any external service. If you are working on C++ projects, this conan thing is pretty awesome and you should definitely give it a chance. It has it's own drawbacks because it's still young, but it's worth it.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8ljz0w/need_help_with_sdl2_basic_movement_without_key_or/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;What is the best way to compile and debug C/C\+\+ in the terminal? I looked into it, how do I debug thouigh
std::cout statements. /s I don't use clang to compile, I use g++. There is a gdb flag to add when compiling that allows for you to step through your code with gdb. I would guess clang has the same option.
std::cout statements. /s I don't use clang to compile, I use g++. There is a gdb flag to add when compiling that allows for you to step through your code with gdb. I would guess clang has the same option.
A different perspective would always be welcome. Also, Walter Bright is indeed a very smart guy. It should be interesting in any case.
DMC is easily the fastest C++ compiler I've ever used. It's behind standards-wise now, obviously, but its parser is something I've been curious to see for _decades_. Just because you're not interested doesn't mean no one else is. ;-]
Sounds good will look into it.
Didn't he invent return-value optimization?
Not sure if Walter "invented" it, but Zortech/Symantec C++ was definitely the first time I encountered it.
Note the title of the talk relates to _Classical_ computers, where correlation is made to quantum interference. The talk attempts to address: (a) Quantization in software, in the context of quantization in physics (b) Implications of highly coupled and invasive data structures, as a corollary to quantum interference The conclusion is: Sequencing is *within* the data structure, as compared with classical sequencing performed through the algorithm. This cannot really be disputed: The observer effect triggers a transactionally atomic reduction to a certain state, where all sequencing occurs within the entity under observation (and not through any external sequencing controls). We likely disagree regarding the fundamental aspects of today's quantum hardware. However, the above points raised in the talk are independent of that disagreement. 
`^^` isn't doing anything, how hard is it to get a new operator into the standards these days
OK, I see. When I read about constexpr format-string parsing, compile-time generated formatters was what I thought it would be at first. That would really be the best of both worlds.
Regardless of how hacky it is, a big issue is that `**` is left-associative while it should be right-associative.
While true in mathematics that's not at all universal across programming languages.
In my concrete case I simply wanted to generate a human\-readable boolean function formula from a BDD. The problem here that I didn't want to store all the info associated with function inputs inside actual tree, both to avoid unnecessary copies as well as to allow some space optimizations \(I expected a good number of similar branches\). So I used a placeholder \(index\) in place of function arguments inside the tree. In this situation instead of passing info around you'd naturally want to generate a format string from BDD and fill the gaps later \- when this information is readily available. That's where problems suddenly came: there can be 2 or 20 or more inputs and no reasonable way to invoke `::fmt::format` for that. I ended up using Boost::Format, it seems to be slow but at the very least it worked.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8llkiq/complete_beginner_looking_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[cppreference](http://en.cppreference.com/w/cpp/locale/locale/id/id) states: `default constructor: creates an object of type std::locale::id with implementation-specific content.`
We are basing our entire CI infrastructure (mainly C++ frameworks and tools, lots of dependencies) on Conan. We keep recipes separate from the product repositories, building is done using CMake. All build artefacts including releases go into an Artifactory instance. So far we are quite happy! Since Conan is Open Source and it is completely distributed, I think there's really nothing to worry about.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8lm5kd/best_book_to_read_between_these_2/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It was C++03 compliant then discontinued before C++11 came out, so I'm not sure why you're being a prick... But congratulations for you, I guess!
Oh you thought it was a bad joke. Ok I guess!
Well, it certainly wasn't a very good one
Can't you construct the output incrementally instead of constructing a format string and argument list incrementally?
I've been enjoying [vcpkg](https://github.com/Microsoft/vcpkg) personally, although initial setup can be slow if you have to build a large library. I found both the Visual Studio integration (*just works*) and CMake integration (*mostly just works if it's a modern CMake project*) to be really great. I've never had such an easy time adding open source libraries to a project before. Almost as easy as app package managers make it, i.e. "scoop install git" style. Something else to consider... no Python dependency, just a C++ package manager written in C++. 
There are people hacking on [Open Watcom](https://github.com/open-watcom/open-watcom-v2). But DigitalMars C++ is mentioned in the [C++ compiler support on cppreference.com](http://en.cppreference.com/w/cpp/compiler_support), while Open Watcom is not.
At least `&gt;&gt;` offers a direction, whereas `|` does not. ie for f | g is the result of f passed to g, or vice-versa?
&gt; There are people hacking on Open Watcom. [OrangeC](https://github.com/LADSoft/OrangeC) is an impressive project that exists with a full toolchain, that also gets very little attention as well, other people's projects to get things better definitely should always get the attention they deserve. :) &gt; &amp;nbsp; &gt;But DigitalMars C++ is mentioned in the C++ compiler support on cppreference.com, while Open Watcom is not. Probably because OpenWatcom doesn't have an "official" how much support of each c++ language they have thing, unlike [DigitalMars](https://digitalmars.com/ctg/CPP0x-Language-Implementation.html)
&gt; random popular libs fmt is, in my opinion, a fairly well-design library that could be adopted by the standard pretty seamlessly. Once fully tested and approved, what is there more to add/update? Besides that I think the std::cout style of formatting is unnecessarily verbose and complex. We shouldn’t be required to pull in an external library for something like string formatting IMO.
Nope, it's completely compile-time. It's just syntactic sugar around {fmt}'s "format" function.
Is it still fast now, how good is the generated binaries?
All around me are familiar faces Worn out places, worn out faces Bright and early for their daily races Going nowhere, going nowhere Their tears are filling up their glasses No expression, no expression Hide my head I want to drown my sorrow No tomorrow, no tomorrow And I find it kind of funny I find it kind of sad The dreams in which I'm dying are the best I've ever had I find it hard to tell you 'cause I find it hard to take When people run in circles it's a very, very Mad world Mad world
&gt; it detects if the iterator is a `back_insert_iterator` This worries me a bit – is specialization/traits _specifically_ for `std::back_insert_iterator` used, or is it looking for some concept? Because I use `ranges::v3::back_insert_iterator`/`ranges::v3::insert_iterator` for any codebase using range-v3 over their stdlib counterparts, and it would be a shame to have this behavior bypassed...
Are you actually in a situation where you need to statically link? If not, you can distribute under the LGPL just fine.
Your comment has been automatically removed because it appears to contain profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8lnpf2/qt_on_mcu/dzhjemh/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Edited to remove profanity because the bot is a baby. Holy crap, you are whiny. Downvote me to oblivion, I do not care at all about worthless internet points, but you just complained about the 10 minutes it took you to talk to someone and you didn't like how their company was trying to handle it's business and make ends meet to pay their developers to continue making their product. The rep was honest with you and you are whining. You think you're entitled to their product for free just because you want to open source something? Your stupid open source project does not pay their bills, they have to eat like everyone else. They don't have a parent company any more, and they're doing what they need to do to survive. Please go find another UI framework, I wouldn't want someone like you using Qt. 
Will definitely try. At first I assumed that it was just now released as kind-of abandonware, but now I see that the repository exists for quite some time.
Please if you can just reply and inbox me your name. I will give you my email and will vemmo you the money when I recieve project 5 and 6.
Good find.
Maybe a dumb question but is this ever intented to be P0829 "freestanding" compatible ?
Yeah your right my bad lol just took more classes than I could handle...sorry about this message I feel embarrassed 
I once believed that Mercurial is a much nicer DVCS than Git. Still believe i was right, but i've forgotten mostly everything about it by now
Why are you using VSCode instead of xcode? You can't use a webshit ide for compiled code without jumping through unnessicary hoops...
Like I said, super novice :/ Honestly I started to like it because it was so lightweight. Since asking this question I’ve already started to realize I’m going to need to switch. I just hate how much memory Xcode sucks from my system :( What are some things that make an IDE better than something like Vim?
It is :-)
"What are some things that make an IDE better than something like Vim?" A lot (me included) would say "nothing". A (different) lot would say that code completion (in case you want that) is usually better integrated and that debuggers (at least the primitive ones) are usually far more easier to use.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; Once fully tested and approved, what is there more to add/update? That's what we though about everything in the stl. But in hindsight, there are so many parts of the stl that are awkward, but can never be changed for backward compatibility, vector&lt;bool&gt; to name one. And even if it's something that can be fixed without breaking backward compatibility, you will have to wait years to get it approved by the committee and implemented by your compiler vendor. Also keep in mind that updating a compiler is sometimes hard. Even today, there are still so many (industrial) projects stuck on gcc 4. Also, this would be the third "standard" formatting library, along with printf and cout. Let's say in a few years a library is developed that is even better than fmt, are we going to add a fourth? Where does it stop? 
looks like `constexpr` goes better and better
Strange mix of .c and .d files. I opened parser.h and parser.d They're both the same thing, except parser.d is really a C++ header wrapped in D (not that you can easily tell by looking at it.) For a company that wanted to replace C++, this source code looks a whole lot like C.
`x` is dependent because the base class depends on a template parameter.
According to this: http://en.cppreference.com/w/cpp/language/unqualified_lookup `For a non-dependent name used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a dependent name used in a template definition, the lookup is postponed until the template arguments are known,` Plain old `x` is non-dependent, so the name lookup takes place then and there. `A&lt;T&gt;::x` is a dependent name, and so it is postponed. Basically, if a name is non-dependent, the language says "I must be able to resolve this", while a depend name makes the language go "I don't know enough yet so I'll leave it till then". And I'm guessing because `A&lt;T&gt;` is unqualified, its lookup is also postponed, `A&lt;T&gt;` doesn't get examined and so can't see `A&lt;T&gt;::x`.
Name lookup doesn't look in dependent base classes (`A&lt;T&gt;` is a dependent base class because `T` is a template parameter). You can use either `A::x` or `this-&gt;x` to refer to it.
&gt;compilutation Pure gold :D
Last I checked `std::back_insert_iterator` was special cased, not sure if that's still true.
Ok, that makes sense, I didn't know about this. Thank you :\)
Took a bit to wrap my head around the difference between `dependency` and `declare_dependency`, but it actually makes sense. Syntax looks like a joy to work with. I do wonder how often people want to differentiate between private and public dependencies for libraries, what's the downside of making all dependencies public?
Correct me if I’m wrong but I believe that in the initial example, the compiler doesn’t know if the instantiation of A&lt;T&gt; that B inherits actually contains a member x. A&lt;T&gt; could have specialisations that don’t include a member called x. I think that’s why the lookup gets postponed as it does. 
Sure, but that doesn't explain why using A\&lt;T\&gt;::x fixes things. After all, this changes nothing when it comes to specializations which don't include x.
Actually declare_dependency is for when you want to combine things and pass around. Dependency is just meson logic for detection, usually but not always, through pkg-config. Yes, the syntax is a joy. If you are interested I published the 4th part of the series just some minutes ago. No Reddit link though.
Went well over my head, sorry.
If that's the case (which is okay, and may be unavoidable), I really hope it's at least a public/documented extension point so that other iterators can easily be similarly special-cased.
/r/cpp_questions is for tech support, not /r/cpp
But assignment flows RtL, as does f(g(x)). Meh.
No. You could for example, in the user code of `B` create a specialization of `A` that makes `x` another kind of entity. For example: struct C; template&lt;&gt; struct A&lt;C&gt; { using x = int; }; B&lt;C&gt; boom; If, in `B`, you were not forced to desambiguate the expressions, and had the unfortunate code doing that : template&lt;typename T&gt; struct B : A&lt;T&gt; { static constexpr int a = 0; void stuff() { x * a; // multiplication } }; In almost every case, `x * a` is a multiplication. But given my specialization above, in the case where `T` is `C`, the expression `x * a` would become another kind of expression: a variable declaration named `a` of type pointer to `x`, which would be `int`. The `using A&lt;T&gt;::x` ensure that `x` is not a type, so does `this-&gt;`.
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8llgce/visual_c_initialization_behavior_of_stdlocaleid/dzi5ij1/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
We are not a bug tracker, please file a bug against the compiler vendor.
Walter is in the process of rewriting it in D, it is WIP.
That is definitely a plus point for vcpkg.
Object lifetime checker for VC++ was shown at CppCon 2016 but it wasn't released then. Is it a part of core guidelines checker now? How good is it?
Yep but it doesn't matter. Git/Github is the standard 
There is no standard.
You can use templates to have a functional langage executing at compile\-time, where your classes are functions : their template parameters are the inputs, and their definitions are the output. Exemple : `\`\`\`cpp` template \&lt;class T1, class T2\&gt; struct add\_values { static constexpr int value =T1::value \+ T2::value; }; `\`\`\`` It "only" takes practice, clean organisation and differents patterns to use it
It can catch iterator invalidation and stuff, that this one I think can't. But this one can catch lifetime of lambda captured variables, that the msvc one can't. I hope we get a combined checker that can do all.
I have not yet tested it, as I spend most of my time in Java and C#. Also have to try it out.
It's possible because somebody had the audacity to stare into the abyss.
perhaps a sticky for this? with contacts if they are willling
This bugs me.
Totally agree with you on it not being a zero-tolerance policy. It's interesting sometimes to see curious bugs or be notified through here if they are serious.
You can also get it to compile by writing `this-&gt;x`, if I remember correctly.
When you stare into a template error novel long enough, the template error novel stares back.
I would be very sceptical about anything that generates format strings on the fly. 
I don't think you can call a C++ function template from a scripting language, or any language that is not C++ for that matter. Such capability would require a rather different design of the library. 
Personally, I really like these "why is the standard like this" questions, esp. because there are often people from the committee here who can give real answers and not just guess.
Without the disambiguating `using` or `this-&gt;`, isn't it also possible that `x` could be a member variable in one specialization, and a namespace-scoped variable in another? (Which would be super weird.)
To quote what I said below: Why do anything at all in the first step, if my type is a template type and derived from a template type? I can understand that there's no concrete definition of A\&lt;T\&gt; yet, but there won't be a concrete definition of B\&lt;T\&gt; either based on the same rationale \(even stronger, being derived from A\&lt;T\&gt;\) , so why stop the evaluation? This makes no sense to me. I think that the workaround with `using` and with `this-&gt;` is wrong \- why should I redeclare all the members I want to use from the base class if all I do is adding a template parameter to B? Because the frustrating part is that if you initially have something like: struct B : public A&lt;int&gt; { void B(): A&lt;int&gt;() { x++; } }; everything is fine, but if you want to add a template to this structure you have to also add a `using` statement. I don't think this is intuitive \- I want to parametrize the structure, not redeclare all contents of A in B. If I wanted that I wouldn't have used inheritance, I would've used composition.
I probably misused the term "licensing". However, they did recently change their download/licensing page, and this was the first time I notices that RTOS \(which almost certainly means this recent MCU business too\) being in the Commercial "bucket".
This is nice. Played with your idea a little bit. template &lt;std::size_t... I&gt; auto formatN(::std::string s, const ::std::vector&lt;::std::string&gt; &amp; c, ::std::index_sequence&lt;I...&gt;) { return ::fmt::format(s, [&amp;c](auto i) { return i &lt; c.size() ? c[i] : ""; }(I)...); } auto format100(::std::string s, const ::std::vector&lt;::std::string&gt; &amp; c) { return formatN(s, c, ::std::make_index_sequence&lt;100&gt;{}); } https://godbolt.org/g/64NAVH 
I find it incredibly helpful that people post bugs here to /r/cpp. Discouraging people from talking about these types of things here will encourage me to unsubscribe and take my eyeballs and commentary elsewhere. The official bug trackers for all 3 major compiler vendors are 1) ghost towns, and 2) horrendously difficult to use, and 3) require yet-another-account-registration. Thusly, I vigorously disagree with this announcement.
then they should be asked as such, instead of as "I have a bug, help me".
&gt; For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. Right there in the rules: `For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.`
Qt just keeps getting better and better
Hmm. /u/blelbach, should we add a sidebar entry with these links?
Even better than adding new operators would be a mechanism for custom operators 😉
I agree with the bare pointer issue. But as you then realise, it's OLD code...
It's nice to see this possibility addressed and clarified, thank you! I should have written something like: "not making a complete ban/etc", maybe it would have made my point clearer: I read current post as bug report had become a big no\-no here.
Nice, though I'd probably not bother with templating it UNLESS I found I needed it to be generic, but then that's just my preference.
The rule will be the same as for questions, more or less. If you copy/paste some code and a vague description of what the compiler does with no analysis or writeup, it's going to be a borderline post, and now I'm going to feel no qualms about removing it. If you do some research and write a thoughtful post about what you think is going on, your post is going to be much better received and we're not going to nuke it. But even if you do the above, please also file bug report :)
I should perhaps mention that this goes one step beyond the implementation in the first half of Bob Nystrom's [Crafting Interpreters](https://craftinginterpreters.com) in that I've gone and implemented a stack-based VM. The performance of the interpreter is okay, but it's not great compared to the C implementation in the book. If anyone has any thoughts on how I could make the code more efficient I'd be all ears.
Also fyi the bug tracker is not a subreddit
Seems like a good idea. It is a pity that there isn't a better how to page for Clang, like MSVCs
Honestly, it hasn't been an issue. Nearly all the bugs posted here have been real ones, surprisingly, and I've learned some stuff...
Be warned that *just download a precompiled version of DMC and DMD* doesn't work, Walter uses an older and slightly modified version of DMD. See this thread on HN: https://news.ycombinator.com/item?id=17131374 .
Doxygen is good for documenting. Apart this, regular markdown files for some part of the project (installation, contribution, licensing, ...)
This one is confusing, but shows the power of what next gen library writers will be using. 
&gt;Doxygen I have a feeling that there should be something 10x better \(or at least more modern\) than Doxygen, they launched in 97.
there are no bugs, only undefined behaviour
They're a lot of different tools indeed but I guess that the best one are still used through time since they accomplish their task perfectly. Also old tools have more documentation and bigger communities so it can be points to consider while choosing a tool. I personally use it since I found it easy to use and to run in Makefile.
&gt; Walter uses an older and slightly modified version of DMD. See this thread on HN: https://news.ycombinator.com/item?id=17131374 . Incredible, that's actually pretty funny
There's [standardese](https://github.com/foonathan/standardese), which aims to be a (non drop-in) replacement for doxygen, which makes use of markdown syntax to generate documentation from source comments.
&gt; I have a feeling that there should be something 10x better (or at least more modern) than Doxygen, they launched in 97. cars launched in 1880 and yet... 
Static asserts to document templatey requirements. Unfortunately no tool is adequate when it comes to generic code.
Sure, but I wouldn't drive a model 1880, or at least it wouldn't be my first choice :D
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8lwxvn/quick_question_about_user_input/dzj4ht1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
amirite
Would you consider the opencv documentation redundant? Or eigen's? 
Sorry! I forgot about cpp_questions. My bad.
Then you should subscribe to /r/cpp_questions
Apparently people here think upvote/downvote is agree/disagree.
If this is the set of checks that includes C26486, C26487, and C26489, then I haven't found them useful. I haven't been able to understand the warnings and the indicated code does not appear to have problems. The online help link doesn't lead to anything - it loads the top-level Visual Studio documentation.
No examples of the language, the link on the github page has no examples of the language...
Actually it should be. This isn't /r/cpp_discussion. This subreddit should be for all conversations regarding c++ from any experience level.
Similarly, nobody is still running the initial release version of doxygen.
Can we have the subreddit scope expanded to include bug reports, please.
and thus the circle of reddit continues
&gt; I don't think this is intuitive - I want to parametrize the structure, not redeclare all contents of A in B You're not actually redeclaring all contents of `A` in `B`. You're redeclaring the contents of `A&lt;T&gt;` in `B&lt;T&gt;`. Because of the possibility of partial specializations that may appear after the main definitions of `B&lt;T&gt;` and `A&lt;T&gt;`, there's no guarantee that the members exist.
&gt; This subreddit should be for all conversations regarding c++ from any experience level. That's /r/Cplusplus I think
I haven't programmed in C++ for a while but GhostDoc is amazing when you're on Windows/VC++.
OpenCV's documentation is atrocious, especially with how they type erase everything but don't make it obvious what type will work fine and what type will do shit. They have some good pages, but a lot of missing information
&gt; this source code looks a whole lot like C. Walter is following the approach of porting the original code as closely as possible to its original form, using dmd's -betterC command line switch (removes D-runtime and the language features that depend on it) to help. Only after the entire program has been ported will he then D-ify the codebase. See https://news.ycombinator.com/item?id=17130816.
Since it's obvious that evaluations can be postponed \(because the `using A&lt;T&gt;::x` does just that\) postpone the evaluation of the entire class. Because if you evaluate only parts of it, you might hit incomplete definitions anyway \- like this x. I don't understand why using x is an error that will stop the compiler, but using A\&lt;T\&gt;::x is not. Perhaps the compiler should not stop on such errors, or perhaps the compiler should not evaluate until it has concrete type for T.
Having no guarantee that the members exist gives no guarantee that the members don't exist either. So here's my issue: we have to specify that we'll use something that we already specified by deriving from A\&lt;T\&gt;. The redundancy is quite painful \- refactoring x into y will leave the code in B\&lt;T\&gt; untouched, because using A\&lt;T\&gt;::x will still remain here. In other words this: template &lt;typename T&gt; struct A { int y; A() { y = 0; } }; template &lt;typename T&gt; struct B : public A&lt;T&gt; { using A&lt;T&gt;::x; B() : A&lt;T&gt;() { x++; } }; is valid code until we have an instantiation. And this code will obviously not compile when we do have an instantiation. I think that's a bit of insanity \- I do understand why this might happen, but I cannot agree with the idea that this is an acceptable solution.
For good measure I use tons of structured bindings so that I get as many auto's as possible in the shortest space I can.
I don't have a bug, I knew how to make the code compile before I asked this. It's not a „make my code compile” thing.
You're using C++, that "launched" in 1985... But it's gotten updates over the years. Just like C++. And everything else :) I mean, if you're using the VERSION of Doxygen from 97 I recommend upgrading. The latest stable is only like 6 months old.
One habit I've picked up that I now swear by is a long form prose document describing the code as a whole. Anything significant I write gets at least a few pages describing the overall architecture, my reasons for making larger design decisions, how I intended to support extensions and new functionality, etc. I'll include installation and that stuff as well, but I think it's invaluable to just describe how to start the process of understanding how it's all put together.
Doxygen is a de facto standard. I saw before Sphinx \(with breathe\) and it looked great. It can extract the doxygen xml and looks better. What I do not know is why OpenCV guys moved just in the opposite direction. No idea. You also have an improved fork of Doxygen called Doxypress and Standardese, which seems a bit abandoned lately so I do not know its status.
/r/Cpp_questions
&gt; we have to specify that we'll use something that we already specified by deriving from A&lt;T&gt; But the point is you *haven't* specified by deriving from `A&lt;T&gt;`, because `A&lt;T&gt;` could have anything or nothing. template&lt;typename T&gt; struct A { int x; }; template&lt;typename T&gt; struct B : A&lt;T&gt; {}; template&lt;&gt; struct A&lt;int&gt; { int y; }; `B&lt;int&gt;` will not have the same base class as `B&lt;long&gt;`. `B&lt;int&gt;` will derive from `A&lt;int&gt;`, which only has `y`, but `B&lt;long&gt;` will derive from `A&lt;long&gt;`, which does have `x`. From the point of view of `B&lt;...&gt;`, it can't even see the specialization of `A&lt;int&gt;`. &gt; is valid code until we have an instantiation It hasn't even been evaluated, so it can't be said to be valid. That's what the process of evaluation means. &gt; I cannot agree with the idea that this is an acceptable solution. Maybe it will be fixed with modules. I don't know. Right now, we are still in the world of header files, and so things like specializations must be handled in this two-phased approach because specializations can be declared any time after the main declaration. Most other languages don't even consider the possibility of specialized generic entities, and that would be even more unacceptable in C++.
You should not sticky posts before 24 hours have elapsed. It just makes it _less_ visible.
You haven't seen the ones that have been removed. With that said, I don't think there are that many as to warrant an announcement/rule for it.
It's not just opencv documentation but the whole project itself which is very weird.
Ok, Can I move this post to r/cpp_questions, or should I just remove it? I just noticed that someone had to post a big warning because I dared asking something around here, so I should comply.
Unit tests and examples ?
My bad. Check out the benchmarks and tests directories in the repo :-)
No need to move it or anything.. just pointing out for future questions
Doxygen, UML and plain basic word documents describing the architecture.
D'oh, I keep forgetting.
Only manually edited documentation. I don't want auto generation tools, too much noise. I use markdown + plantuml http://plantuml.com (open-source, really great) and Visual Assist SourceLink feature + this great visual studio free picture visualizer: https://marketplace.visualstudio.com/items?itemName=MsBishop.ImageComments 
"Back in the old days, Windows only allowed eight character file names. We did have proper include files on Unix, but if you wanted your code to be portable, you had to use wonderful names like "qscrbar.h" and "qbttngrp.h". Wow only 8 characters? :O When was this "fixed"?
Does anyone know of a way to add uml diagrams to Doxygen, preferably using PlantUML? We currently use markdown (DokuWiki) with PlantUML but having it in the code would be much better.
that's pretty cool. What do you mean too much noise? You don't like comments on your code?
Any tool in particular for UML?
I'll take a look at the forks, thanks!
It's so weird to see people charging for software these days :D And that one is actually a bit pricy, I assume their target are large companies, right?
&gt;ThePhD -- known in meatspace as JeanHeyd -- is a Computer Science *undergraduate* at the Fu Foundation School of Engineering in Columbia lol.
I thought his was just a concept, cool to see there are tools out there 
I've made a Visual Studio extension to allow some Markdown syntax in comments (headers, images, emphasis ...) and show the formated text inside the comments (like images with ImageComments): https://marketplace.visualstudio.com/items?itemName=JulienDuminil.MarkdownComments But I'm missing time to continue to improve it.
[Enterprise Architect](http://sparxsystems.com/)
About doxygen's noise, I mean, as someone else mentionned: "In practice you just get an index of public function names, which is already in the source, so what's the point" This being said, it you take a great amount of work (cf. Qt + Qdoc), then you can achieve some great result. As I don't have this time, I just want to concentrate on the architecture on one hand, and the difficult implementation points on another hand. 
No, it's not. I'm a software dev and I like to get paid every month. Sure, there are different business models, but in the end a price tag at a software is still perfectly reasonable.
I mean it's a very good piece of software and it took hard work to produce. You can't blame people for wanting to get paid for their hard work. From my experience I've seen individuals using it for their personal projects but they could have been obtained through a company.
Do you not like, idk, have a job? Jobs generally involve getting paid, and in our case, getting paid for writing (and selling) software.
Windows NT (using NTFS) always had long filename support, but consumer Windowses didn't do it properly until XP (in 2001). Windows 95 finally supported long file names via an ugly hack, it truncated the name to 8 characters (+3 for extension), like "c:\program~1" for "c:\program files" and kept the full filename somewhere in an index, this was done for backwards compatibility for DOS and earlier Windowses. Now, during the transition (and years afterwards) a lot of tools would mess this up (I don't think all syscalls even supported the new scheme) so the only reasonable way was to keep filenames to the 8+3 format. Funnily enough, I ran into this just recently, I needed to use Photoshop for a quick thing so I installed my old copy which of course isn't too happy with recent Windowses, so eventually I had to install it into "C:\Program~2\" to make it go.
Have you ever taken a look at the [SFML documentation](https://www.sfml-dev.org/documentation/2.5.0/)? The thing that makes a documentation a lot more useful than many other documentations, is that it provides some short example for nearly all the classes and the function descriptions are more than just pseudo descriptions.
&gt; The nickname is a std::promise&lt;&gt; on their std::future&lt;&gt;.
I find it interesting that everyone seemed to go for `cout &lt;&lt; 42"` instead of `cout &lt;&lt; 42`.
File a bug report. ^/s
So obfuscation now means Awesome? k...
What was that program that was on reddit recently that fast-forwards sleeps to allow fast testing of things with waits? Would be useful for testing a few of these.
I was wondering why 42, and then I got to the end, where basically the number was chosen because it is the sum of C++11, C++14, and C++17. I'm not sure where the word Awesome comes into play here... Obfuscated would better describe it.
Are you thinking of https://github.com/majek/fluxcapacitor
If you swap loops two and three you will get a 2-4 times improvement more easily. for (int i = 0; i &lt; m; i++) { for (int p = 0; p &lt; k; p++) { for (int j = 0; j &lt; n; j++) { C(i, j) += A(i, p) * B(p, j); } } } 
I like to run Doxygen over a large codebase so I have an easy html index of the code structure, but I agree with you about Doxygen/Javadoc style **comments** being mostly useless. At the end of the day it's another tool to get a good overview of what exists in an unfamiliar/large codebase, but the vaunted advantage of generating actual documentation is pie in the sky nonsense imo.
Doesn't anybody ever wonder why we're still deserializing data from command lines rather than invoking functionality in a more type-safe manner in the first place? 😁
It's been a few years, they could move to C++11 or at least pretend to be interested with a pre release version but nothing. Yes it's a breaking change, but a good interface would be awesome. But it won't happen because it's all about Python now.
My fork of a free alternative is here: https://github.com/x64dbg/CppTripleSlash it’s pretty great if you want doxygen in visual studio.
Is there a good way to understand how vcpkg compares to conan, etc? Overview article maybe? For vcpkg: Am I building the libs or downloading binaries? Can I choose dynamic vs static or is it forced by lib author? 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/8m0v0k/help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This and a short description of what the project actually does are the most important ones to me. The details are in the code if nowhere else, but this information isn’t. The faster I can understand the big picture, the faster I can understand the API.
Never used qdoc. Did you? How does the output look like?
/r/gatekeeping
https://www.draw.io/ I tested many tools, and this is the best free one, IMHO
Everything you see there, and it's a lot, http://doc.qt.io/qt-5/index.html is generated by QDoc from source code comments. The style is provided by css, we're in the html world. 
&gt; I'm also wondering what's the impact of the spellcheck on compilation time. I don't think there's any, since it only happens when an error occurs.
The biggest problem I find with documentation is over\-documentation. What needs to be documented is the include files. They are the API to the classes. They tell you what the class does. The source files tell you how, and need not as much documentation as the include file. Given that most programmers are not given the necessary time to document changes, documentation in the source file should be minimal or it will fall out of date. Only the tricky parts should be documented. Document the include files to describe all the features of the class but document the source files only where there may be confusion.
hmmm good spot
Why everyone needs their own bug tracker instead of use github?
C++ mostly. Every decent IDE can show you the callers of each function. Refactoring gets better with every version. Doxygen can do a good job on a new and unknown code base, especially if you use the advanced features of generating different diagrams.
I've used this feature in Xcode. Click the suggestion - and it's only a suggestion - and it updates the text with the suggested replacement. I generally preferred to fix each error by hand, but it looked like it was producing the right answer more often than not. (I don't think a replacement that doesn't compile is a big problem, because you won't be able to ignore that for long.) &gt; I'm also wondering what's the impact of the spellcheck on compilation time. It only comes into play when there's an error, so I'm not sure the performance matters all that much. But anyway, if you're worried about compile times, why are you using C++? ;) 
There is [Natural Docs](http://www.naturaldocs.org/), but that is just a different flavor of doxygen. 
Even being about python isn't a real excuse. The Python API is a direct mirror of the awful C-like API which doesn't even suit Python. The whole thing could benefit from redesign.
Now I feel old, thanks man. 
I think Python is not a good language anyway, but I see your point.
Time to get my quad rocket on.
Wow, this looks awesome. Well done. I have sort\-of one question/comment. When you do things like that, it means that you'll often have more, I'd say a lot more, comments than actual code in your C\+\+ files. Like a function or class would be 10\-40 lines, and the doxygen comments would be like a couple of pages. Have you perceived that as drawback? I would presume that it makes it harder to navigate source and header files, because you need to scroll much more to see and get a grasp of the actual code? I guess it boils down to: Should extensive documentation like this go directly into the C\+\+ files too, or rather somewhere separate? Or is having such a large documentation \(more than the actual code\) right within the code actually golden throughout?
There's plans about OpenCV 4 which are getting quite concrete. They're moving to C\+\+11 but not to C\+\+14. A joke throughout in my opinion. They blame VS 2015 compatibility.....
It is.
It certainly depends (engineer's favorite word). :D Pages like the "Main Page" actually independent files, SFML just uses one page, but it's a neat feature to integrate even more things. One for example could have guides or tutorials as dedicated Doxygen pages. The "Detailed Description" section is always at the bottom of the header file, as such it doesn't really impact your scrolling experience. The comments on functions certainly adds a lot of text to the header file and I guess here it largely comes down to personal preferences. For SFML as a library with a very compact API, it's not an issue, as you're rarely digging around in the code that much, plus with the documentation, you don't even necessarily have to dig in the code, as you can just check the documentation on how to use the function. For more production-like code with changing interfaces, huge function lists, I guess it can be a bit annoying. Then again IDEs or plugins for IDEs are by now quite smart, so you can easily jump to the function you want to check out. But also here, I'd argue if everything is documented nicely, you don't have to get lost in the code as much, but you can check the docs and just use it. The biggest issue with any documentation probably is to actually keep it up-to-date. It's not too hard with a slowly moving library like SFML, but with real projects, you rarely got the time/budget to actually document parameters, write examples, think of useful descriptions, etc. Even if you do get that for the initial start, once you start bugfixing and feature building, the business probably doesn't see the value in giving the space to actually update the docs. Maybe take the Clipboard as an example so you can build your own opinion: [docs](https://www.sfml-dev.org/documentation/2.5.0/classsf_1_1Clipboard.php) / [header file](https://github.com/SFML/SFML/blob/master/include/SFML/Window/Clipboard.hpp)
vcpkg.
I wonder if they'll do Turok 2 eventually so we can enjoy the cerebral bore again :-)
I wonder if they updated the assets? The Xbox-One reboot uses the old ones https://www.youtube.com/watch?v=0vTxsv3oK_s
Alright... From now on everyone calls me The Supreme Coding Marshall.
I was hoping for source code :(. I do own this on steam though. &lt;3 turok
It could happen on warnings, too, but y'all use `-Werror`, right?
Cool! Thank you very much for your thorough reply and for writing about your experiences. Very nice! :-)
At my company (Win10, VS 2017), we compile OpenCV ourselves, static lib only, and rather than use the OpenCVWorld lib, we use separate libs for each component of OpenCV. Currently on 3.3.0. At this point we are using almost all of the libs for the library, so splitting up the libs and compiling them ourselves seems unnecessary. Can anyone articulate the pros and cons of using static vs. dynamic linking for OpenCV?
I've been using clang's spell checker and it proved to be a desirable feature.
Not in all cases - eg in home not, but I do not have the need for CI in home...
As everything it will likely be better in the future.
If you're going to post this here, can we at least get a discussion of what was gleaned from the experience of doing this in modern C++? What did the language make easy? What was problematic? Did you use any extensions? GPU or SIMD, asm or intrinsics? What could be improved in the language to better enable game development?
Kludges, but no real frameworks. https://github.com/mchalapuk/static-tests https://stackoverflow.com/a/17431484/295231 To do this right, it would have to be driven by a build tool which actually checks for compile error messages. Knocking something together with CMake is theoretically doable.
&gt; Can anyone articulate the pros and cons of using static vs. dynamic linking for OpenCV? well, static linking is typically lead to larger link time, so development is a bit slower.
You could argue some people think 'thank you' isn't necessarily contributing to the discussion. Regardless, this discussion is opinion based, and not technical/fact based. It does end up being a popularity vote for what you like invariably.
Riveting! The `constexpr!` thing sounds odd.
Do you have any interesting links that explore the link time?
Well, for one thing, Github's bug tracker is absolute garbage. Even Bugzilla, which I also dislike, is leaps and bounds easier to use for actual real-world projects. The second, of course, is that Github is a private for profit company, that's capable of doing whatever it wants with it's platform. Relying on it isn't wise for a project that isn't comfortable putting such an important piece of infrastructure in someone else's hands. I'm not saying I have the answers, I'm just saying that Github is absolutely not the right one. 
I cannot understand how you'd want a language that the meaning of the whole code will depend on the base class type. Imagine if you mutate a global `x` when `x`is not in the base class. Better be explicit than wrong.
Folks interested in this might also be interested in [icGrep](http://www.icgrep.com/). (Disclaimer: loosely affiliated with it)
I believe there’s an option for UML in the doxyfile for doxygen generated graphs (caller, callee, etc), and ‘dot’ for specifying arbitrary graphs (but I’m not sure if it can be told to render those as UML)
Yes.
http://blog.llvm.org/2018/01/improving-link-time-on-windows-with.html
I think people got confused because they thought you were pulling things into new namespaces, not their own top level namespace (which honestly, if you don't own it, sounds like it's asking for trouble).
Duh. As if `srand()` (which you supposed to call once, exactly like create `random_device` and `mt19937`, AFAIR) won't give you approx. the same monstrosity of assembly somewhere down in library code. Though it probably wouldn't, actually, since `rand` uses much simpler generation technique.
&gt; std::random_device rd; std::mt19937 gen(rd()); Once again, it strikes again. That's not how to seed a `std::mt19937`. As you say, just use PCG. 
And why OCaml.. ah
Could be. I tried to emulate the clang AST dump behaviour. This shows normal decimal numbers. But I can imagine that you have a valid point here. I'll look into it.
If I'm writing a game or something else where I don't need large random numbers or crypto grade security, I'll just keep using rand until there's a solution in std that is human readable. 
[:-(](https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful)
Comments and plaintext files that include examples.
I realize that reddit won't show the real path, it's supposed to be "C: \ \ Users \ \ my username \ \ Desktop....."
I don't think this is really the best place to ask. But you probably want to use something like [ShGetKnownFolderPath](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762188(v=vs.85).aspx).
icGrep is quite interesting but is almost the opposite principle to Sheng - trying to do one state at a time over lots of inputs rather than doing all states very quickly on one input. We tried many of the same tricks as icgrep in dev branches in Hyperscan but the work never saw the light of day. As a rule, it was usually faster to do cheesy 'acceleration' of conventional NFAs or DFAs - even thought the icgrep approach is much more principled and reliable.
`%USERPROFILE%\Desktop`
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8m5egz/i_need_to_get_absolute_path_for_desktop/dzkz6oe/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
... you are asking this question on r/cpp? Really? r/cpp_questions would be a far more suitable subreddit for this. Not to mention there are far more suitable programming languages for this task, e.g. Python. The reason this is an ambiguous question is that the C++ standard doesn't really properly define this. It's a vendor specific issue, meaning the correct answer may change even between different OS versions. On Windows, the *current* answer would be to use SHGetFolderPath (or a similar function) to resolve the path entirely. 
If only it wasn't so hard/cumbersome to properly seed `std::mt19937` (or so easy to seed it improperly).
I knew rand() was bad, but holy shit...
Many moons ago, as a student, I tried it. It seemed better suited for function-oriented programs in the sense that you can better tell a story through "functions" than through "objects". Almost like a program's data are the protagonist of the story and functions are events. "This happens, the this happens, then this happens" as opposed to "these are building blocks of the story and this is how it's assembled".
Nice, will have a look on it :) First comments, there are several typos in the cmake scripts, and prefer always target_* instead of include_directories() Also there should be not need for add_dependencies()
That's one of the problems with cmake.
Well modules are part of that. If you think modules, you will structure your code in a sane way (hopefully).
Right. We really need a random number generator in std for humans. 
It suggests identifiers declared in code. It's a simple helping hand and doesn't cause a recompilation to check whether it would actually fix the error. I can imagine the compile times getting unwieldly with more than a few errors if it did.
Looks nice! Random tip: replace the server::handlers_ map with an unordered_map :)
This looks like a pretty sweet project! The interface looks legible and easy to use, which is always nice to see in new code. Examples are always a pleasure to see, too. That being said, the first thing I noticed when I peeked at the code was the conspicuous use of `try {/* stuff */} catch(...) {/* ignored */}` blocks throughout error-handling code, which can pretty easily lead to real errors at that level of the program happening completely silently and putting the program into a bad state while the user is none the wiser. If there really is no reason to worry about errors at that point in the code (which is semantically what that sort of thing implies), why not get rid of it altogether so the user can at least be aware that that a presumed-invariant was violated?
`rand` can be so terrible that you actually notice it; some implementations even alternated between even and odd, so `rand() % 2` would give very visibly nonrandom output. I do appreciate wanting a simple RNG, but it only takes a few seconds to copy-paste the minimal PCG code into a header.
You know, you can wrap all four horrible, ugly lines of code that it takes to do this properly into a function and never look at it again...
It's four lines of code that you can write once and not bother with afterwards. I _really_ don't see what the big deal is.
Anyone know where I can find more information on the "production guidelines?" Supposedly, there's some information already out there, but I haven't been able to find it
Then operator&lt;&lt; should be made constexpr! 🤔
That sounds great. I'll look into it!
I'd say replace it with a small array, and replace it dynamically with any map after a certain size/threshold. Any map is a cache killer...
I think the title is bit misleading, as this library has a dependency on Boost. Which I don't think makes it qualify as lightweight nor "nano". 
Why ? Most boost code is template so it will end up much more optimized than non-generic alternatives; and there are hardly ever runtime performance problems with the common boost "infrastructures" types.
There's a nice flat_hash_map on github that stores its data contiguously. Has been a godsend. boost::flat_map has also been there for a long time. And it can work as a container adaptor if I'm not mistaken so flat_map&lt;k, v, small_vector&lt;pair&lt;k, v&gt;&gt;&gt; could maybe work ?
I would expect to be able to drop a lightweight/nano library into an application with little to no dependencies and that any dependencies would have a much lower maintenance/compilation cost than the library itself.
The problem is that people like me who have been writing C++ for 3 years have no idea what you are talking about.
It is interesting to see people blame doxygen and other tools, love likely shadowing the own inability to write good documentation. Doxygen is for API documentation which is used by - let's say - 3rd party developers, comments in the implementation serves an entirely different purpose: they help to understand what an implement is doing, so it is for the implementors themselves. That said, yes, doxygen is an excellent tool for API documentation: Qt, KDE, Eigen, SFML, ...
I like how it uses structured bindings (with some Boost PP magic) to deconstruct a structure. Too bad you'll still have to use macros if you want to get the names of the members.
&gt; Most boost code is template so it will end up much more optimized than non-generic alternatives A fuckton of optimized code does not make an optimized binary. It makes a bloated binary. I've certainly seen extensive smart pointer use triple the size of a real program.
Well, it could be something else than github, but something that hosts projects from all around the world so I can register once and have access to many bug trackers. Really, if I do not report a bug that's because of "registerwall".
But the compiler is wrong by making the assumption that x is not in the base class, because it might not be under certain circumstances it didn't encounter yet. If it's a decision the compiler is not able to take due to lack of information then it shouldn't take it at all.
It goes the other way round too. If you take care of good code structure, then you don't necessarily need modules. Or they would still help you a lot, but the modules alone won't help you anything, if you don't care about code structure in the first place.
Remote Procedure Call. 
What would be a machine-local (i.e. no network) similar lib?
https://github.com/skarupke/flat_hash_map
Cool project! I see mutexes so I assume the server is threaded, is this configurable? Can you choose a single thread to have node.js\-like thread safety?
What's the point of these static functions? Why not 1 with paremeter?
The biased hatred towards cmake is irrelevant to the topic of the blog post. You don't need to convince people to use premake, when they just looked up a tutorial on how to use conan with premake.
The proposal relies on minimal features from the standard library but there was no explicit intent to make it freestanding\-compatible and I'm not even entirely sure what's involved in that.
I love cmake. So easy to use and I don't have to another language to use it when I only want to use C++. Thank god for cmake! Premake seems awful. I have no interest in learning another language (Lua) to use C++.
Yes, but there are many many 'RPC', which one? XML-RPC? ONC-RPC? DCE-RPC...?
&gt;There's no point in supporting VS2015 for something that's not even released yet, and VS2015 supports probably most of what they need. But well, they aren't experts in making good decisions. Not everyone has tremendous freedom in choosing what compiler or compiler version they can use. If users write in "Hold up, my company is not ready to use anything newer than VS 2015" then it is reasonable for them to consider holding off a little.
Well, it is a problem if nobody ever reads your auto-generated documentation enough to know that there is nothing of value in it. That's not Doxygen's fault. Doxygen gives you the facilities to write all the good and bad things you've described. It's just a documentation generator/format. It can't force you to write anything of value.
As far as I understand this uses a custom protocol, so it's using "RPC" generically.
I do think there's a need to point out why Premake is a better option, because using it isn't the quickest solution, so it needs to be justified.
I used both CMake and Lua before Premake. So it's not like I had (1) no interest to learn another language to use CMake. (2) need to learn another language to use Premake.
You feel right 
`lol no observer_ptr`
Why? Doesn't \*"pure C\+\+"\* \(whichever version\) simply imply that it doesn't use system specific API or language extensions? As I understand, Boost is cross\-platform.
Why do you hate cmake so much?
Can you name a C\+\+17 platform that isn't supported by boost :P
Sounds like your agreeing with me here. The problem is that people don't know this and believe that because they have included the Doxygen markup that they have actually created useful documentation. It creates the illusion of Documentation. I suppose that Doxygen could be used to create good documentation, but I'm pretty sure that it would not the easiest way to do it. The main value of Doxygen is to fulfill some requirement for documentation with the minimal investment of effort.
I believed that my article was relatively begginer friendly :(. The idea is to show that C++ can be used to compute things at two different place: during the compilation phase of the language and afterwards at runtime. The kind of computations that can be done during the compilation phase are as powerful as the one done during runtime (it is Turing Complete) - you can compute anything even a game logic in my case. Even more so, during the compilation phase the computations can manipulate the C++ code that will be run later on at runtime ; you call this meta-programming . Your C++ code, at compilation, can "observe and modify" the C++ code and the types used at runtime. There is a drawback to compute things during the compilation: it is slow and it has very limited capacity to handle user inputs or draw fancy outputs. Now, back in the days (C++98), we used to rely on C++ templates to do meta-programming or just compile-time computations. It was pretty awful! C++11 came and brought constexpr to do computation on values (as opposed to types), but it was not a panacea either. C++14 improved things a lot and C++17 even more. It is a bit less slow and hella more beautiful. Now you can have a look at Meta Crush Saga and observe that the code is rather readable and understandable. The same code in C++98 would be extremely disgusting.
Why do I feel like this is a trap?
Gamedev here. What do people use RPCs for? Web programming? I know some games use them, but it's not a very good architecture for games, nor is http transport.
Mainly because of its badly designed DSL, which makes working with it painful, tedious, and time consuming. There's nothing wrong with the core idea of generating build projects, and Premake does it with better design decisions.
I agree that autogenerating a bunch of crap is creating an illusion of documentation. But Doxygen has many benefits, and maintaining docs outside of code and your version control system creates major headaches. So it's a net win by far.
Because it basically is... Half of the "problems" with Boost boil down to the fact that most libraries go way out of their way to work on ancient or obscure toolchains. You'll find decades worth of compiler releases on which `boost::shared_ptr&lt;&gt;` works and `std::shared_ptr&lt;&gt;` doesn't, and that's not even mentioning things like `&lt;regex&gt;` or C++14+...
&gt; inclusion in the standard library some day I really hope so. I has several years which committee has started revamping C++ Standard and while many improvements has been done to the language, I haven't seen much progress in the library side. One can argue that these changes acts as the building block which later accelerate development of the libraries, but there are still crucial "library-sided" features that are left out. Take the famous Modules for instance. Or the fact that in the language of ~40 years old and having millions of users, there is still not a standard and modern way of splitting a string. /rant
I wish. Unfortunately https://xkcd.com/927/
They can work well in the game domain for game runtime &lt;-&gt; tool communication.
With Premake, you have \(or had\) to learn a DSL as well: The way in which it uses Lua. Even if you already know a bit of Lua, you still have to learn all the commands etc. of Premake.
A long time ago, I saw two problems with rand() when used in a particle system: - Patterns in particle emission/position caused by the low quality generation. Games don't need crypto level quality but that doesn't mean quality is irrelevant. - Excessive cost due to use of thread local storage in rand()s implementation. We replaced it with a LCG that generated 64 bit values and returned the more random bits. It was trivial to implement, faster, produced better quality results and could have its state stored in the cache line with state invoking it. Even in the game space, there are plenty of reasons to do better than use rand().
I think we can have reasonable compile times and have this feature. They could do smth like tag all identifiers with what kind of thing they are (type, value, template, ...) and only show names from the appropriate set. Preload the set with some default values and types like `nullptr`, and we'd be good to go
Same thing using Unix domain sockets instead of IP sockets?
Any reason why you're using http?
Smart. Neat.
&gt; You know, you can wrap all four horrible, ugly lines of code that it takes to do this properly into a function and never look at it again... Then... why isn't THAT part of the standard API?
I tend to avoid web-based tools altogether but this one seems pretty solid!
PlantUML is amazing flexible. If there were a tool to integrate Markdown and PlantUML in the same file and somehow pair it with a source file, that would be great.
Because you need a global engine.
So write a global RNG and make yourself the so much needed \` get_random&lt;int&gt;(0,50)` it's not hard and before you ask "Why is that not in the standard yet if it's so simple". Why would standard impose a globabl RNG.
Maybe I missed it but another downside of converting a `unique_ptr` to a `shared_ptr` is it has to allocate the ref count object separately, instead of with the object as with `make_shared`. 
So what? It's a good incentive to finally upgrade the compiler. No decent compiler, no new features -- that's what the deal should be.
Which is why if you know for sure you always want a shared_ptr, which *occasionally* is needed, then use make_shared. Otherwise use make_unique.
&gt; it is much more valuable if it virtually never has false positives. Then it could as well be an error. Warnings are only warnings for a reason. At least it's strange, given that 90% of warning noise todays is generated by signed/unsigned conversion/comparison that is error only in 10% of cases.
how was this not obvious? Do you think it's doing a "spell check" on everything it comes across?
It's not even out yet. Don't be stuck supporting compilers that will be phased out when your project will be released. And 2017 has almost perfect backwards compatibility with 2015, so there's no reason not to upgrade.
&gt; While 90% of discarded releases are leaks, perhaps 10% are intentional, and most people really dislike warnings about intentional code. Why do you think that? I feel if you are interacting with C-style APIs this is the only way to do so without risking memory leaks if (TrySomeFunctionThatEndsUpTakingOwnershipIfSucceeds(blarg.get())) { blarg.reset(); }
This kind is actually useful. The one found in JetBrains IDEs (that tries to spellcheck the whole code, not waiting for an error) is really annoying and in 99% of cases wrong.
&gt; p = nullptr; Meh, now I have to go and verify that `p` is a smart pointer....
I think that's a sweeping generalization. Compilers like Visual Studio cost money at the very least depending on your license, and some people might require plugins that do not exist in newer versions. Again, you don't know what peoples needs are, and if the project maintainers want/need to support VS 2015 then surely they have reasons.
Should look into PCG random, can avoid the STL insanity. has a minimal C implementation that is a good simple replacement for regular rand. http://www.pcg-random.org
If STL added `[[nodiscard]]` to `unique_ptr::release()`, people are more likely to disable that warning, which would be much worse than disabling signed conversion warnings, IMO.
You could do `p = {};` to make it clearer.
Might I add, amazing thumbnail.
&gt; I could swear that sometimes Clang is smart enough to diagnose the accidental call to Widget’s non-virtual destructor, but not in this case. (GCC also does not diagnose it, but I wouldn’t expect them to.) It doesn't diagnose it because there's nothing to diagnose. If you add a virtual method it does diagnose it: https://wandbox.org/permlink/5y9tlhbZxTLBGbdq VS's code analysis detects this: &gt; warning C26436: The type 'class Widget' with a virtual function needs either public virtual or protected non-virtual destructor (c.35). PVS Studio didn't detect the problem, strangely enough.
Why? If it's not a smart pointer you shouldn't have ownership (at least through `p`) and there's nothing to do.
I suppose it is in the spirit of the C family to focus on the language itself rather than the libraries. However, look at the companies that sponsor C++ development. Google, Microsoft, Bloomberg, ... they already have their own internal libraries for everything. They are not going to put money and effort into stdlib stuff they will never use. They focus on improvements that will make the lives of their employees better. I don't work at Google but I'm pretty sure they're not going to start running all their stuff on `std::asio` next year.
I am having trouble reading the site with some guy smiling and staring me down. I think this is the first time in my life that I 'opened up the debugger in my browser and deleted the node that contained the image' in my life.
Sure, there are costs and trade-offs. The same holds for *not* upgrading your compiler, and I think those costs are way higher in the end.
That works equally well for raw pointers though.
That's actually exactly the case you want `release` without referring to the return value. `reset` would delete the object out from under you.
Some people have reasons to want trigraphs, but that doesn't mean we should let them have their way and be stuck in the 80s.
There is some middle ground to be found. I personally prefer to work with new tools, but lots of places use older compilers for legit reasons. My company has standardized on VS 2015 recently. My previous company was even further behind, and likely still is.
Exquisite use of the 'for' loop. Thanks for sharing.
&gt; As for `unique_ptr::release()`, we _could_ mark it as `[[nodiscard]]`, but in VS 2017 we've refrained from doing so. While 90% of discarded releases are leaks, perhaps 10% are intentional Would’t it be possible to narrow the semantics of unique pointer enough that discarding a release is virtually always incorrect? One case I can think of where discarding a release is intentional is when the ownership is conditional for some reason. In that case you would have a dedicated smart pointer type for that. That would allow adding dedicated checks that you use the two types correctly.
Any software implementation of TM that is not backed by a compiler will be much less efficient. My reference implementation of the same idea in Haskell is 6 times slower. And the situation is even worse if we compare STM with hardware TM. But the problem is that systems supporting hardware are not that known and spread, and also the interface to these implementations can be inconvenient. There is nothing bad in having some software implementation, you can find many for different languages. What's interesting, I and one another C\+\+ guy want to wrap the hardware implementation into my library's interface because it allows to substitute the runtime without touching the interface. Explicit context is not a problem, at all. It's just a variable you need to pass into the atomically function. You can even obtain it from a global singleton if you want and wrap your own atomically function that does not have this argument but uses your singleton to obtain the context. So it's really a feature because I have a nice optimization option of providing different runtimes for different use cases. In the reference Haskell implementation, I'm working on the multiple substitutable contexts. In C\+\+ this can be done more easily due to dynamic polymorphism.
It would be worth testing a simple loop Vs this recursive approach - could well be faster, and the compiler might have a recursion limit that wouldn't be a problem for a loop.
I use the O'Neill's library described [here](http://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html). I trust the author and I'd love to see part of it adopted by the STL
Yes, when people start whining about how they don't like the new version, don't extend support on the old one. It only results in the new version never being adopted.
You are correct, I of course meant `release()`
I thought constexpr does not allow loops? But i could be wrong. Could someone clarify this?
It does in C++14 and better.
thank you
It doesn't handle collisions. 
Which C++17 features are you using? I would expect at least std::string_view instead of const char*. 
That's a bit unfair towards Microsoft considering their considerable work toward the STL. Including Mr. STL himself a mod of this subreddit. 
that isn't a DSL, it's an API. Lua is still Lua, nothing changed about how you use it.
Why use const char* and check for the null terminator if you could just do: template &lt;size_t Length&gt; constexpr uint64_t CRC64(const char(&amp;text)[Length], uint64_t seed = 5381) Then you can run a for loop on that. I've been using this since C++14 to great effects, it's quite nice.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [Software Transactional Memory in C++: Pure Functional Approach • r\/cpp](https://www.reddit.com/r/functionalprogramming/comments/8mgz50/software_transactional_memory_in_c_pure/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; readable and understandable https://github.com/graninas/cpp_stm_free/blob/master/cpp_stmTest/tst_stm.cpp#L294 yeah... uh... basically, when we say "readable and understandable", it means that you should be able to take a below-average comp. sci intern and have him be productive on your code
Well, the one in GCC needs some improvements. It often suggests things that are not valid.
Well, when I say "readable" I mean "readable literally". You read the code and see the words describing what happens. But yes, "understandability" highly depends on the reader's background. 
Why would a hash algorithm handle collisions? That’s up to the user if it’s an issue (e.g. if it’s used in a map).
What makes you think they wouldn't disable it anyway. People that disable a warning because it's a false positive in 10% of cases probably wouldn't care about 90% of legit cases either. It'd be still a warning to them that must be disabled.
`p = decltype(nullptr)(0)` will nake it even more clear that it is resetting a pointer, and is more greppable.
Or, they could keep everything unchanged and use a loopback address as the hostname.
i don't understand what point you're trying to make by linking to that piece of test code. it looks perfectly reasonable to me
And when used in switch-case statements, it'll fail on collision at compile time with a duplicate switch case!
you might have better luck asking on /r/cpp_questions. but to get you started, compare the output of sizeof(Bass) and sizeof(Derived)
I usually prefer iterative, but how would you use this to generate hashes from command-line arguments in `int argc`, `char** argv` form (which is the primary use case that got me looking for compile-time hash algos to begin with)?
True, that use case wouldn't be supported like this and then you'd need to either pass the length in as a param or scan it for the null terminator. Though command line arguments wouldn't be compile time constant anyhow, unless I'm lacking some knowledge? In my personal case, the runtime version uses string_view anyhow, which captures all use cases scenarios for my RT needs. I prefer not working with raw char* unless there's no other way.
You're forgetting collisions with the input (which could theoretically be anything).
Correct, the run-time arguments are not compile time. The reason I wanted compile-time string hashing is so I could use them in switch-statements. Seriously. That is literally the *only* use case I have for these. *And I love that I can do this in C++ now.*
You're reading over the vtable pointer of your Pointer variable. `sizeof(Pointer)` is also just gonna be whatever the size of a pointer is which means only the vtable pointer will be written and read to, `int a` won't be written or read.
Stack overflow is where you'll find the answer 
The child and base are the very same object so (unless in certain double inheritance cases) "this" is how you get the child class pointer. Of course this does not help you at all because you are asking the wrong question. You should try to state what problem you try to solve instead of asking how to implement what you think is the solution. Think about that when you pose your question on stack overflow.
And if you want to call methods in the derived class, use virtual/overridden functions.
Good bot.
If the right compiler optimizations are available, this **should** compile down to a loop since it's tail recursive
It's constexpr code - runs at compile time, _interpreted_ by the compiler. It should compile to a single number!
Indeed - but the loop could still compile faster for the runtime version. There's no good reason for this to be recursive. I could see it if it was trying to support C++11, but it's specifically called out as being for C++17!
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8mhsfp/c_how_can_i_test_if_a_function_is_defined/dznrv0z/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Regardless of which you prefer, compile time is a factor even if the resulting code is identical. There have been issues with compile-time recursion being rather slow, so I would definitely write this as a loop.
Thank you very much for your responds now my confusion is clear.
I only ever need this for very short strings. If I needed compile-time hashing of *larger* strings I'd find an iterative approach custom-fit for that use case.
Another use would be if you have ids that may be known either at compile-time or run-time. You'd want to avoid strings for performance reasons but would like to use strings for code readability. Like, say, an imgui-style user interface. You may have a big widget tree where most of the widgets have a id that could be known at compile-time but then you've got a big list widget with items that are only known at run-time. `if (hover_id == CRC64("some widget")` with no hashing overhead but still use `if (hover_id == some_dynamically_generated_item_id)` for cases where you can't.
&gt;below-average comp. sci intern &gt;be productive Pick one. 
c++20 is supposed to have a realloc. Finally!
Please stop posting these here. Thank you.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Well I should've put it in quotes, okay - a "DSL", or as you say more precisely, Premake's API, how it wants you to use Lua.
&gt; when we say "readable and understandable", it means that you should be able to take a below-average comp. sci intern and have him be productive on your code who is this 'we' and where do I submit a proposal for definition rescoping for "readable and understandable"?
OTOH if you share with weak_ptr then you might not want make_shared (if it is a big object) because make_shared ties the deallocation times of the managed object and the control block. 
There's a proposal for it https://github.com/lichray/randint/blob/master/paper/randint.md
&gt; I don't have to another language to use it when I only want to use C++. You missed a word there, but assuming you meant "learn", your statement is still invalid. A person knowing only C++ cannot use CMake right away, because it's a different language - and one that isn't used for any other purpose. He first needs to learn that new language to use that build system.
Idk how often this occcurs and arguably it should occur less with modern APIs. But for such cases it would make sense to define a DISCARD makro that clearly communicates the intent and silences the warning.
You're going to need to express your build script somehow in some language, there's no getting around that. Lua is a good fit for the given task - it's simple, it's fast, and it has a rich ecosystem. My criticism is that choosing to create a new language, which its sole purpose is to be used in a single tool, and it's inferior in every way to free open source languages you could've just used, is a bad choice.
For me VS Code worked out pretty well, with a few extensions :)
emacs + evil + lsp-cquery
Visual Studio and QtCreator are absolutely the best IDEs in my experience.
Just add an if with actual string comparison inside each case block: switch(hash(arg)) { case hash("abc"): if(strcmp(arg,"abc") == 0) { //... } break; } 
I really like QtCreator. It has a minimal UI (which is rather refreshing compared to something like Visual Studio or Eclipse where the UI feels super cluttered) and has good support for CMake, QMake, and QBS based projects. The clang code model has no problems with any sort of code I have thrown at it, and the application handles large projects well. It integrates Qt Designer and ships with stuff to make debugging Qt applications nicer, but works just as well for projects that don't use Qt.
Cevelop (based on eclipse)
I've added two new iterative versions, one taking a const char array reference, and the other taking a const std::string reference.
cquerys (+ kakoune + kak-lsp) is my IDE.
I made a poll about this once, you can check it out here: https://www.reddit.com/r/cpp/comments/7ydk8y/bestworst_c_ide_you_have_ever_used/
Hey, ELI5 would be appreciated as I don't know what most of the things you mention mean ( although perhaps I am not a target audience because of it ). 
I use KDevelop on Linux, Visual Studio on Windows. KDevelop has great highlighting and code navigation, and VS since it's the most integrated with Windows I think.
That implementation would inherently depend on hidden global mutable state. That just encourages bad design. If you use something like that in a library or in part of a large project, you can screw up generation in other parts of the program that depend on a specific seeding. Though, I suppose that wouldn't be a problem if get_random were randomly seeded automatically on first use. If it always provided random numbers that were unpredictable by the user, the global state wouldn't be relevant.
My opition, QtCreator for C++.
My exact setup
I like Code::Blocks
C-Lion has gotten really good after the last few updates.
I really like CLion, but if you want features/functionality I'd go for Visual Studio.
I really like the work-flow that Vim (with NERDTree, restore view and YouCompleteMe) gives. In my experience, it's the best IDE.
Clion, they are highly involved in the C++ Community and also tend to be really quick in updating to a new version of the standard.
i have c\-lion with the student program, and it's awesome, i love it
I love premake! Thank you for this article. Very nice.
vim + gtags. Every time I have tried to use a "real" IDE for C++ I hit enough annoying little performance lockups, buggy code completion, and badly designed UI that I decide it's not worth it. I'd rather give up the supposed advantages than be stressed and distracted by the problems. I mean, when you're writing code milliseconds of UI hang are super annoying. All the IDEs struggle with the fact that C++ is barely parseable.
Visual Studio has its quirks but it is the best.
#include &lt;bits/stdc++.h&gt; - bad code starts here 
Visual Studio + Visual Assist X with Sublime Text for quick file editing and viewing. 
CLion!!!
depense on what plugins. i use cquery for code completion and it does use one specific to it (it will look for a compile.json from cmake or other) but you can just sym link it. it you want to the ms plugin that one is moslty generated for you by the plugin through your intracion from the ui.
I have something that does here: github.com/foonathan/string_id (old project)
vi is only the editor of your development environment. The tool that integrates all the tools together is your shell.
Been using Clion for since it's launch, excellent multi-platform IDE and is getting better with each update. And the pricing is reasonable. For me a second best is QtCreator, but still prefer Clion.
emacs with the cmake-ide package
Spacemacs + ycmd + rtags.
I use Eclipse with CDT. It's a decent IDE. Takes a little work to configure but works well once it is. I build outside of Eclipse though. 
vi
Because it's only _one_ way to do it, not **_the_** way to do it. `std::random_device` is really expensive on some platforms, and you may only want to call it once; the seed may come from serialized state rather than from a generator; etc. There's a lot of flexibility in place (whether anyone uses/needs it, I have no clue), and creating your own ideal abstraction on top of that is again 4-5 really simple lines of code. (Whether they're obvious or not is a matter of RTFM, IMO, but I can how that's a contentious viewpoint). Again, I really don't see the big deal – there's no "right" way, and doing your own "right" way is easy, so.....?
Visual Studio and VS Code on non\-Windows platforms has been the best for me. VS has it's bugs and I don't know why the damn Intellisense stops working when it wants to but it's the best out there. It's got macros and code completions that take into account what sort of a code design you are adopting. Good stuff
I tested several IDEs including CLION and QT and nothing beats Eclipse when you have to deal with large project spread among different repositories. Also I build outisde of eclipse I use eclipse external tools to launch a remote build by pressing a button.
I second your decision but are you not looking over the times when Intellisense just stops working?
I've also been using VS Code with extensions. It's not perfect, but it's lightweight and zippy (for an Electron based app, anyway) and suits my purposes.
Well it's the trade off I guess. Should be fixed nonetheless
CLion, I like the fact I can carry my idea across all three major operating systems.
Nano
80% of what you do in an IDE is edit text, and QtCreator unfortunately doesn't pay much attention to that aspect. The Vim-bindings are woeful, and you cannot even configure line-height.
The CMake plugin for VScode is really a class apart. It's by a 3rd party dev.
Seconded. But their lldb interface leaves a lot to be desired
Netbeans can be configured to work with Cygwin / gnu. This is a great option if you were a former java guy. 
&gt; I have and so have lots and lots of other code bases I've seen, which is exactly, why I would like it to be in the standard library. I think this is the wrong mentality, each of these projects may need to configure the RNG that they use. And so, configuring that as part of defining their global rand interface, is exactly what is supposed to be happening.
I totally agree with you. I've never personally used Lua but I've only heard and seen good things about it as a scripting language. I'd definitely consider using it. Personally I would prefer Python for build scripts, because I already know the language. But everyone will have a different preference, obviously.
What do you use for tag search and autocomplete?
Same
&gt; idea That's a nice typo right there. Or is it?
I've been using DevC++ ever since I started learnig and have had a good experience with it so far. Might try out some of the other IDEs mentioned here.
Not OP, but I work with ycmd
Hah, yeah it was a typo.
I haven't used it in a while, but I would still guess that its Visual Studio with Visual Assist X, that is if you're okay with staying on Windows. 
The answer is: depends. First, what OS are you developing on? What OS are you developing for? Are you developing command line, a background process, a GUI, a game? For instance, I develop multiplatform, do ML, and do embedded. I use a mac as a desktop as it allows for the embedded I do and Linux development. I use Visual Studio Code(+platformio) for the embedded and XCode for the command line or daemon stuff aimed at Linux. I like Mac for Linux development because the Unix base of both allows for nearly identical code to work well without having to fight with Linux as a desktop. I develop multi-platform GUI apps in QtCreator. And finally I use Sublime for the occasional Web work. That all said, Visual Studio on the PC is by far the best IDE but so little of my stuff is for Windows only that I don't get to use it much. 
seems like your management isn't interested in useful things then? 
Visual Studio is best if you don't have millions of Loc and you need to debug it quite frequently. 32 bit Visual studio is too buggy for debugging. In Linux, QtCreator is the rock star, no matter how big is the project, QtCreator handles it well. To make full use, you should use Visual Assist with Visual Studio and Locator with QTCreator. Vim days are gone. VSCode, Atom, Sublime are distractions. 
It ridiculously expensive. 
QtCreator if you need it, Vim if you don't.
Oh no...
Do we really need to go down this road today?
Notepad + cmd
One needs something like the following: #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;functional&gt; #include &lt;random&gt; int main(int argc, char* argv[]) { std::mt19937 engine; { // Seed the PRNG std::random_device r; std::array&lt;unsigned int,std::mt19937::state_size&gt; seed; std::generate_n(seed.data(),seed.size(),std::ref(r)); std::seed_seq seq(std::begin(seed),std::end(seed)); engine.seed(seq); } std::uniform_int_distribution&lt;int&gt; rng; rng(engine); return 0; } However expecting people to do this everytime and taking into account the cost of doing it, it becomes somewhat burdensome.
Ha! Yes we do if some prick expects me to adhere to 80 charcater columns on my 2K monitor. 
I love CLion. However it costs money. In my opinion worth it. The nice thing is that even though they do it as a subscription, you get a fall back license so it's not like you're renting the software.
Vim bindings are always terrible.
give this man more upvotes please. Simpler in this case is absolutely better. And the last thing I ever want is a language or project that forces an IDE.
How do you debug? I still need CLion to debug in ways other than cout, as I dread learning GDB.
It’s treason then. 
that doesn't even have anything to do with vim...
What it means is that if the stock way of doing things is too complicated for new programmers to understand, they will copy paste and make it worse than if they'd just stuck to rand() which is easily learned and understood. 
The latest version of Visual Studio hands down. Since they've added the "open folder" and cmake support my workflow has significantly improved. The Linux compiling/debugging story is pretty awesome too, I'm interested to see how features like this will continue to improve.
CLion.
$89 for a personal license isn't very ridiculous imo. You get a perpetual fallback license plus the cost goes down each year for the first 3 years. They also offer free licenses for open source projects and students. I have a subscription to the jetbrains all product pack since I program in a lot of different languages on different platforms and I think it's a huge value for the money. I spend more money on coffee every year than I do on the IDE licenses, to put it in perspective.
 &gt;Why would standard impose a global RNG Because standard libraries are there in part to simply common operations. &gt; how could it even choose which one to use. Pick one that is reasonably good and allow people to override it if they know what they're doing, like with other things in std. 
This comes up a lot. There was a poll: https://www.reddit.com/r/cpp/comments/7yvned/results_of_the_poll_about_the_most_used_cc_ides/
Unix is great
I've found that CLion is very bad at inspecting objects from libraries. Obviously GDB experiences the same issue, but Visual Studio seems to do some sort of magic and will inspect pretty much anything.
I really like SlickEdit. It handles my very large C++ project of over 18,000 files very quickly. It indexes all the symbols and I can quickly find the definition of a symbol or all cross-references to it. Each text search results are shown in a new search tab, so I can double click on any search result, or my old search result (in previous tabs). It is also cross-platform and runs on Mac, Linux and Windows. Been using it for many many years. The IDE is written in C++ itself so it is very very fast.
Visual studio + Whole Tomato Visual Assist as my main IDE setup even if I am targeting Linux. I generally follow dev/debug on windows and deploy on linux paradigm. With Window 10 Linux Subsystem bash, I don't need a separate Linux dev machine. I actually deploy our linux production builds using WSL. 
VA does work with the community edition of VS
or maybe just pirate it ?
Yes - I just put my own rpc lib on github. I think you should checkout it out - [MqttRPC]( https://github.com/ankitkk/MqttRPC). The requirements were to explicitly avoid boost and have a scale-able architecture. By using two different components for [serialization](https://uscilab.github.io/cereal/) and [transport](http://mqtt.org/) I think I was able to achieve a fairly clean and light rpc lib. or not. :) 
**Sublime Text** \(with **EasyClangComplete, SublimeLinter\-Clang** &amp;** CImprove**d plugins\) for normal stuffs and** Visual Studi**o for heavyweight IDE stuffs. 
Because then if you find out later you need to use a different RNG, you cannot without rewriting all your code or patching the stdlib? IMO you should write your program *expecting* that you may need to change to a different RNG at some point. There's no way you can be sure that you won't.
People are also taught that `using` is evil and they should never use it, and while in this case it's quite useful the dangers are real if you don't know what you are doing.
you're troubled
did it get any faster
GDB is pretty good, try this: https://cs.baylor.edu/~donahoo/tools/gdb/tutorial.html
They're being paid fairly because people purchase their products. Funny how that works, huh?
(Atom + CQuery) + Terminal
VS Code for sure. I maintain a large library with has both C++ and Java code, with a JNI library to interface between the 2, and VS Code is the only editor where I can work on both, with full intellisense for both, at the same time. Once you get the json files built out, it's a dream. And I'm working on some Gradle plugins so allow it to generate the project information and automate even that. The extensibility and cleanliness of the extension API is simply amazing. And being able to edit support and build files with some support from the same editor, it's kind of unbeatable.
Sublime has really fast folder searching and navigation as well as the best multi point file editing I have used. 
Jetbrains CLion is magical
Vim + ctags + ycm + gdb/lldb 
Anything that isn't a Linux terminal text editor.
.idea
Heh - I am the odd one out - I use Xcode on a Mac. I like clang / llvm. Also, the debugger is excellent. If vscode gets good CMake support and C++ completion, then I will check that out at some point. I've used vscode for typescript and js and it was better than anything I've used before.
please fix your typo, thx
What about Qt Creator in vim mode? :-)
I also use emacs and I use `cquery` which indexes the whole project. It works quite well and is simple to setup.
&gt; I'm also wondering what's the impact of the spellcheck on compilation time. It should be exactly zero, since it only needs to fire when there's a compilation error.
Doxygen. I don't actually even know if there's anything else available...
vim + tmux The only way to go. 
Why do you believe you're entitled to someone else's work/labor without fairly compensating them?
&gt; If they literally just copy paste complex SO code that they don't really understand all over their project, then they are bad programmers and they shot themselves in the foot. Remember, we're talking about new programmers here. The std library makes something that should be simple complex, which is the opposite of how it should be. There should be a general purpose random number generator that can be specialized for additional control by people *who know what they're doing*. What we have now is a simple and bad option (rand) and a complicated and bad option (random_device). On the balance of things, for new programmers rand is better, because they can at least understand what it is doing.
I still genuinely don't understand how people debug effectively with gdb. I tried for a while and it's ok if I'm inspecting something very specific, but if I try to understand how data flows through the program in general and find the point where it's going wrong, the experience is horrible for me.
You are welcome.
*"If you need more than three levels of indentation, you're screwed anyway.*
You know how I know you're a millennial brogrammer? 😆
Just 2 for now: 1. Cmd+S should save the file, not delete the entire line when Vim mode is active. 2. Configure line height.
While I agree on the user interface aspect, I have had nothing but trouble with the clang code model and QTC. That's not to say the old code model based on Raggi's parser didn't have its quirks, it did, but performance has never been an issue as much as lacking functionality following new C++ features. The clang code model brings my QTC instance and/or computer to its knees whenever I work with large projects. 
What do you mean by changing the line height? Do you mean that the editor should be able to insert padding between lines in addition to what your font provides? Why would this be useful, let alone necessary, for editing text?
[juCi++](https://github.com/cppit/jucipp); fast, stable, cross platform, easy to use, supports latest C++ standards trough tight libclang integration, written in "modern" C++.
What's you opinion on language servers?
More space between lines makes text look less cramped and easier on the eyes. Even Xcode, the least customizable IDE, added 3 line height options last year. Other editors like VS Code let you specify it in points/pixels totally flexibly. Furthermore, configurable character spacing is also useful – I use it to compress Fira Code (with ligatures) so it doesn’t look too horizontally spaced out. 
Main quirk being, it doesn't run on Linux. :(
After a quick search, it should be possible to run clion on arm. Just some tweaks and removing of bu dled executables (which are built for debian). I don't have an arm platform to test it, but it would be nice to try.
&gt; Using a rand()-like interface in a library or in part of a large project, may screw up generation in other parts of the program that depend on a specific seeding. If a part of your program depends how on specific seeding that part should not use the global RNG. Simple as that. That should not prevent a easy to use solution for the project (parts) that don't have such special requirements. &gt; get_random were randomly seeded automatically on first use. That's exactly how it is supposed to happen. No one needs another stand/rand interface.
Visual studio with (this extension)[https://marketplace.visualstudio.com/items?itemName=AngryJonathan.PowerToolsStructureVisualizerFrom2017]
What exactly would be the harm? If I have specific requirements, I can still use the low level interface.
I think there have been a number of random related proposals, but somehow, nothing came ever it of it (the proposal you linked to is 3 years old.
You don't need to, use remote compiling (debugging) from VS.
&gt; tend to avoid web-based tools altogether b I thought the same, but no installation anymore required, you get the latest version instantly and so on. I don't use any other tool anymore. When you use confluence, you can embed the tool into your documents and can work on it with versioning. 
Ok, that's fine if I only wanted to develop in VS for Linux. But I want to run VS *on* Linux so I can run VS on *not Windows 10*. This OS as a service concept is turning out unpalatable to me.
VS Code in zen-mode. With disabled cpp tools because it's intellisense is failing to handle nested folders. I'm not using autocomplete other than based on words from current file, it's too distracting and always failng to provide good results in any IDE I was working with.
Yeah I was kind of hoping /u/STL could shed some light on that.
Vim \+ YouCompleteMe \+ gdb for developing on remote machines only reachable through SSH
Very cool. I recently came across [an approach to evaluate small DFAs using SSE](https://branchfree.org/2018/05/25/say-hello-to-my-little-friend-sheng-a-small-but-fast-deterministic-finite-automaton/), so maybe that could be a future direction for further performance gains.
Check out this meson sample project for people who've never used meson before: https://github.com/tiernemi/meson-sample-project I found it really useful and thought the meson community could use something like this. It's like an implemented version of the [how to x](http://mesonbuild.com/howtox.html) Feel free to share that meson-sample-project.
vscode works fine for me for c, c++, javascript and python. can't do that in qtcreator. 
How many projects do you know that have specific requirements for their global RNG other than that "it should be good and reasonably fast". In my experience, specific RNG requirements are usually local to a particular module or even function in which case you can fall back to the low level APIs that give you (almost) full control. 
RemindMe! 1 week
I will be messaging you on [**2018-06-04 09:05:09 UTC**](http://www.wolframalpha.com/input/?i=2018-06-04 09:05:09 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/8mk8ku/c_ide/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/8mk8ku/c_ide/]%0A%0ARemindMe! 1 week) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
as all compile time string hashing used in switch, this does not check for possible hash collisions with the input, and it you'll get a compile error when two cases would lead to the same hash.
"this person made some good software, so everything they say is law"
Download any of IntelliJ's IDEs and go to the Font properties in the settings, you'll be able to modify the line height. Once you go 1.3 you never go back.
I never thought about needing such a config. Maybe you have too many adjacent lines without a blank line? 
This is so hard to write that your snippet has a double-free in it.
This assumes POSIX-style zero-for-success.
Well, I don't know, if the function returns 0 on success or false on failure. I usually wrap C APIs because of exactly that reason. The error codes and freeing of resources, so I would have to write that code only a few times and I have a lot of time to think about it.
+ Visual Assist.
Btw, any sane IDE on mac that can fully work with xcode project files? 
I like visual studio because it's easy to customize and hook up other build tools. VSCode is also nice.
Me too, one of the few I find it simple to understand what is going on with behind the scenes.
Codeblocks
This is too heavy and almost irresponsive on my old pc
System libraries or random libraries? With headers available or without?
I've been using CLion for the past 6 months on 64-bit Linux. Right now I'm using CLion 2017.3. I highly recommend CLion over Eclipse CDT, which couldn't even parse c++14 correctly last I tried it! That version of CLion still struggles with some c++17 features, but it's pretty good. My word of caution with CLion is that they've got a rapid development cycle that results in bugs that might make a particular version of unusable for your program. For example, last week I tried upgrading to CLion 2018.1 after the latest bugfix announcement. At first 2018.1 seemed better since it's faster than 2017.3, but then I noticed that the code completion popup window did absolutely nothing (window appeared, but it was always empty), so I just reverted to 2017.3 where it works very well. --- On the topic of IDEs: Does anyone here have a good solution for GDB's python pretty-printer bindings for C++? Background: For a couple of years now I've been wishing for a turn-key solution where I feed pairs of class name and either member or global function. A while back I got as far as writing a perl script that calls `objdump -t $prog | grep to_string | c++filt`, and then uses regexes to find member and (namespace-correct) global functions called `to_string()`, but I have no idea how to go about how to use that information to install python pretty printers in GDB. The [man pages](https://sourceware.org/gdb/onlinedocs/gdb/Writing-a-Pretty_002dPrinter.html#Writing-a-Pretty_002dPrinter) aren't really any help for me because I don't grok Python. Do any of you have a script that "just works" to install pretty printers that call `to_string()` (or even `operator&lt;&lt;()`) functions found in the binary? p.s. If GDB version matters: I'm using GDB 8.x in CLion and occasionally as a free-standing debugger.
C\+\+ not only needs to evolve, it needs to deprecate more rapidly. IMHO, semantically versioned modules which extend the core language should be the #1 important feature to get right. After this, the only things that go into the C\+\+ standard should be things which directly affect language semantics/syntax. Everything else should be a versioned module.
also, metaclasses so that more of the language can be expressed directly in-language and less in the standard
Yes, I agree with that, and if possible, in versioned modules :p
I pay annually for the entire Jetbrains pack. The amount of time their tools save me in the course of a week, is well worth more than the cost of my annual subscription. Additionally they provide free licenses to open source project maintainers and students, and a few of their products have free community edition licenses (not clion however) So while I'd say yes, it is expensive compared to free options, but imho it is cheap for what a professional dev gets in return. Especially if you're on Linux or mac, where the alternatives are imho not as good.
If that were to happen I'd maybe start liking boost.
There should be a way to clean up the language at agreed points a bit faster, creating as little incompatibility as possible, based on the stability and velocity proposals. That is very important. After that, some smaller features are ok I think. I would like to see, personally, some kind of terser lambdas but that has failed several times. That extension would not be big and it would affect every day coding. From the bigger ones, in my opinion, the most important are: \- modules \- coroutines \(though I do not like the current proposal compared to the original from Christopher Kohlhoff\). I agree also with Google paper that they are too complicated and that they need optimization technology that could be avoided. I think having around 15 functions and a code generator on the backend is just too much. I am sure it can be simplified. Though, the Google paper also invents extensions as they go... so I am not sure it would be the way to go either. Isn't it possible to just rely on lambdas \+ address to solve the whole probem and just use libraries for schedulers, generators or whatever we need? I still think that the best solution, after closely following all the coroutines proposal, was Chris' one because: \- it was simpler to reason about \(function objects\) \- it moves complexity to the library, which is not hardcoded In fact, when I saw Google's proposal with its function objects I told myself: "yes, man, this looks much more like C\+\+ and I know what is happening". With the current coroutines I just get a bit lost, one of my personal pain points being that it uses regular functions as async functions when lambdas can do a good job here without any type erasure. \- ranges with views in the standard library \- concepts \- metaprogramming with strings
I'd like to see both your configs please!
Well one of the advantage of C++, being ISO certified,etc, isn't it that it doesn't really deprecate ? Useful if you're planing software that span more than 10 years life time.
[Maybe this would be less of a problem if you could discuss ideas without writing a paper.](https://i.imgur.com/taeq93s.png)
Just curious. Is this a joke or a real recommendation? Lol!
I guess I can also post here. I'm using optional whenever I write unit tests where I need to test classes/objects with lots of configuration parameters. For anything highly configurable, lots of things can have values or are simply not set. Instead of using a class / funtion with tons of defaulted parameters, I write a so called builder (factory) with a fluent API (at least that's what it's called where I work). You can then easily create complicated objects, where you only need to specify the specific parameters you need. https://godbolt.org/g/cRrZFn
I agree.
Bjarne is right.
Mostly, but not entirely, a joke.
Well, that's the thing. Yes, it's an ISO standard, but there can only be a single version of it. ISO standards aren't versioned. If you write code in C++14, you're using an obsolete, officially withdrawn, standard. 
What's dangerous to the language is discouraging people from contributing to it. If C++ continues at it's current pace, it's going to be a legacy language forever. Today, many write code in C++ since it's somewhat of an industry standard, but they hesitate. Once there are better alternatives, they'll switch. And there will be better alternatives. 
Just sent this to my congressman. 
That's the best kind of feel
https://github.com/DarkWingMcQuack/emacs_config
From a users point of view, it generally works well. This style API is prolific in android. From an author point of view... that boilerplate.... For me to use it on a regular basis, IDE’s could use a generate builder option in their code generation.
Is working on three different OS - really part of your every-day work?
Good points, though I will have to disagree re: lambdas and coroutines. First class coroutines as more general functions, are so good to use, the change of perspective is worth the effort. A lambda based approach would obfuscate the nature of the construct too much.
&gt; Is working on three different OS - really part of your every-day work? dunno for OP but I *at least* work on win, mac, and linux on any given day.
Why does anyone want to use vim bindings?
And maybe if there was an easier/more standardized way to handle dependencies (e.g like pythons pip), less people would consider standardizing auxiliary things as a viable library distribution mechanism 
I use it on a 2016 MacBook, with 2 core, 1.1ghz + ht CPU and 8 gigs of ram on small-mid sized projects.
https://en.wikipedia.org/wiki/Straw_man
Yeah, I do move around enough to see the advantages of using the same toolset everywhere. Also, I never said working on three different systems is part of my everyday work. 
If only he had thought about this 20 years ago.
Even languages with excellent package managers have a stdlibs with useful tools. Just limiting to vocabulary types is far too limited. Ranges will be fundamental addition to the stdlib. GUI I agree though should not be standardised.
\&gt; Once there are better alternatives, they'll switch. And there will be better alternatives. I'm curious what are they ? Where they are, several years have passed.
several decades more like :)
Yep.
FYI - speaking of the Vasa there is this: https://www.youtube.com/watch?v=ltCgzYcpFUI 
I happily agree. My experience was different, around 1/2 startups doing anything more than webpages were working with c++ in background. And 4/6 companies had C++ as main language used for everything. Maybe it's about what kind of companies we looked at. I'm curious about Go. What made you like it that much? I ask honestly without sarcasm. BTW: I also hate people who think they do C++ when their last knowledge of standard is from 98 (20 years ago) and their skills are more "I know C, so C++ is included". But it's changing, more and more of these people learn and improve.
Thanks for pointing at this, I will give a try
Or, as a halfway house, if Boost was built on a C++11 system, have boost::shared_ptr be a typedef alias for std::shared_ptr, so I'm not using the Boost implementation. This provides a transition to the standard implementation while still being backward compatible for older systems. Right now, I implement this myself for all the Boost components which were moved to the standard library.