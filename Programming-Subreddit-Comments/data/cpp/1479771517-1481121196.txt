desktop: the easiest way to navigate is just to use spacebar key mobile: swipe seems to be the best option with reveal.js
[Zeroing Memory is Hard (VC++ 2015 arrays)](https://randomascii.wordpress.com/2016/07/17/zeroing-memory-is-hard-vc-2015-arrays/)
If anything, we have the *opposite* problem.
I am currently working a lot on mixed C++/Python code. Some observations: * *Boost.Python* saves a ton of boilerplate when providing python bindings for a C++ library, and I think it has been written mostly with this use-case in mind. However, I found the opposite direction (i.e. using python objects in c++ code) quite clunky, extract&lt;&gt; gets old quick and list, dict, etc. have a very bare-bones interface so you have to drop down the C API frequently. And of course, the infamous TMP-style error messages over thousands of lines filled with colons and angle brackets do occur frequently. * The *C API* is not so bad, most annoying thing here is the manual reference counting that needs to be done correctly or things will segfault. This leads (unsurprisingly) to a distinctly C-style look and feel in the interfacing code, with lots of return value checking, manual casting and goto's into cleanup sections. If you write in C, or if the interface between the Python and C++ parts of your code can be kept fairly small, this will be the way to go. * Last but not least, I also wrote my own python-embedding library at https://github.com/lava/wrappy . I'm obviously biased, but I think the API is a bit less...overkill than boost, for lack of a better word. The downside is of course no support and no community, so you'd have to contribute any missing features yourself. Anyways, answering your actual question, embedding python is as easy as #include &lt;Python.h&gt; int main() { Py_Initialize(); PyEval_SimpleString("print \"hello, world\""); } // g++ python.cpp -I /usr/include/python2.7/ -lpython2.7
You should try the [latest release](https://www.visualstudio.com/vs/visual-studio-2017-rc/) of Visual Studio! It requires a lot less disk space and time compared to the old days. Might be worth a shot! (Full transparency: I work for the team that is working on this)
You can [set your user flair](https://www.reddit.com/r/cpp/comments/4tm8k9/user_flair_is_now_available/) to identify yourself as a VS dev.
Just wait until the author gets mad and pulls this pointless package from NPM, causing thousands of deeply-nested dependency chains to break.
Wow, that's going through a whole lot of metaprogramming (i.e. paying compiler throughput for no good reason). I'd recommend just naming the lambda on one line, then calling it on the next.
The JS standard library comes with your browser or node/io.js runtime. Not sure what you're referring to.
Just watched this and there's a great demo of Vcpkg, including how to use it with CMake's FindPackage. This could really bridge the gap in terms of making C++ code build easily across platforms. CMake has helped in a big way, but finding packages has always been more painful on Windows. 
I know exactly enough to get my window handle and opengl context and run away screaming. 
Can you backup how all libraries are terrible, as it seems you claim?
I can't tell if you are joking, serious, mocking them or using some mode of communication I am entirely unfamiliar with.
Maybe C#? I always seem to find decent resources and there's usually only a few popular ways to approach a problem. It seems to me that the standard library is very robust so you don't have to reach very far to get stuff done and most people don't try to. And when you do, there's usually a popular package on NuGet that fits the bill. That's just my limited experience however.
Ha, I'm not sure we're entirely sane. There's a certain degree of masochism required to truly embrace C++.
In my experience I would say the prevailing culture is one of detail-orientation. Either you need performance and need to understand the consequences of every allocation or you need cross-platform compatibility and need to understand some details of the underlying operating system or you just like knowing exactly what your code is doing but you also don't like repeating yourself. But by the same token it's really easy to mess something up and spend hours tracking down a simple mistake. So yes, there's a lot of nitty-gritty coding but again C++ is for those who enjoy "getting their hands dirty". In some ways its the antithesis of modern JS development. The use cases are (in my opinion) much more varied than those for JS so you don't have big frameworks competing for attention. In my observation many of those frameworks are trying to solve the ever present problem of "presenting a website the single best way possible" and so have a narrow focus. And when you buy into a JS framework it seems to dictate the entire project infrastructure. This is not at all my experience with C++. Mostly because C++ libraries typically solve one specific problem or a small set of problems and most have C interfaces (which are well-supported and well-understood if somewhat cumbersome) and so you have lots of people putting together combinations of libraries to solve their specific problem. Boost is a great example of a collection of small libraries that you can pick and choose from to solve a particular problem. Personally, C++ is my favorite language because I feel I have the right degree of control over performance and I know my code can be ported to most operating systems including mobile operating systems, so my experience is portable too. The price I pay is having to pay attention to seemingly minor details and if I didn't enjoy doing that I don't think I'd enjoy C++. That being said, I love designing library interfaces and utility classes and modern C++ is making it very easy and enjoyable to build composable abstractions. And in my opinion composable abstractions are the antithesis of giant frameworks. And I think the C++ community reflects that. As for the culture I can tell you that C++ is popular in what I would call smart devices. Not so limited as to require C code, and not so fully-featured to be able to afford garbage collection. In my work that includes embedded control systems, embedded touch screen applications (such as automotive displays), and soft real-time systems. It's a fairly small niche and no one really tries to dictate how our team's work should be done based on buzzwords or the latest trends. My team is fairly autonomous and our work environment is relaxed. We come in around 9 and typically leave around 5. Working on a weekend would only be done in extreme circumstances. Most of us are in our 30s. Now if only we could all agree on a standard build system. Here's hoping CMake is improved and a widely-adopted cross-platform package manager emerges.
Thanks!
This would get much better results if it was posted to StackOverflow instead of on his blog. edit: I didn't know people hated SO so much :(
It depends on what you are installing. For example if you are just installing the Linux workload, it is around 1GB (pretty much as barebones as you can get because no compiler). Keep in mind that VS also includes the compiler, so ~5GB for a desktop app development environment is pretty darn good. I would argue that VS is also a better beginner environment. No need to install a separate compiler, or do any of the build system configuration, just write your code and hit the play button and it runs. May be worth giving it a shot! I think you'll be surprised how much better it is compared to before. 
His more recent posts to stackoverflow.com have gotten little or poor attention. That may be a factor. 
I'm pretty sure if he posted it on stackoverflow, the comments would look like: "I'm voting to close as off topic because he is asking too many questions; this should be broken down into multiple posts." "Possible duplicate of www.stackoverflow.com/completely-unrelated-question" "Hi there, welcome to StackOverflow! Please take the time to read the rules and edit your post with a Complete, Minimal, Verifiable Example. This will help people better answer your questions."
..yup, help in converting to D.
I thought he said all 3 compilers gave the same result, right? Edit: oops, I'm wrong. Serves me right reading articles at 1 am :p
I've heard this argument before that make_shared is good for both performance (1 alloc instead of 2) AND cache coherency, but I don't really get the latter. The control block will rarely be accessed by that first shared_ptr, like when it gets created and destroyed, and when asking for the weak count, but not when accessing the pointed-to object. Furthermore, all other shared_ptrs built from the one returned by make_shared would get no cache perf gains as they would likely not be allocated on the same cache line as the control block.
They were similar until he tested `explicit`. 
Fair enough. Truth be told, I haven't made projects big enough for compile times to bother me. Having the lambda in the line before would save some compile time...but I still feel like `std::invoke` is more expressive. I understand that `std::invoke` is a behemoth when it comes to TMP. We can do better. Wouldn't something like this solve the issue? template &lt;class F, class... Args&gt; decltype(auto) iife(F&amp;&amp; f, Args&amp;&amp;... args) { return std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...); } Or even template &lt;class F&gt; decltype(auto) iife(F&amp;&amp; f) { return std::forward&lt;F&gt;(f)(); } and use lambda captures.
I *so* agree with you! It's actually *easier* for me to wrap my head around C++ because you have more control/know more about what's going on "under the hood" than the very high level languages. Even still, the type of "hard" that C++ is I can handle. I can't handle switching and learning frameworks every 2 seconds when they are replaced next month repeatedly. That's not fun to me. Not to mention isn't the whole point of software engineering to REDUCE dependencies or at least factor them out from the business logic?
Amazing insight. Thank you *so much*!
alright thanks for the detail info :) 
but to realize that, they set the CMAKE_TOOLCHAIN_FILE ... I'm not sure if that is the right way.
Hahaha this is GOLD! But it's actually really annoying and a great example of why I can't stand the JS landscape/culture right now unfortunately. It's a shame because Node.js itself is a great piece of C++ software.
So the best part about this is that I got a terrible night's sleep last night and Im sitting here doing some data structure work nodding off, drinking a coffee. This post made me laugh so hard I'm now wide awake.
I'm pretty sure that wouldn't be the case.
I'm glad I'm not the only person who thinks his problem is that he's using C++.
The stockholm syndrome is strong in this subreddit. I lurk here because I use C++ in my day job....I can see what's good about it and I can see the pain. Ruby is my other daily language... and the feeling of ease and freedom when I step away from C++ to Ruby or D is palpable.
Yeah, that's it. A bunch of intelligent people are delusional, and couldn't possibly have opinions of their own...
Yeah, I'm sure the 27 people (as of now) who upvoted Gollum999 are all cretins who can't be bothered to do a quick google before posting a question. SO can't possibly have a culture problem.
StackOverflow is has sort-of-okay culture, so long as you don't run across any power users. I can say without hesitation I would never hire a SO power user.
What has replaced C++ in its core competencies (performance, control, tools, and portability)?
SO is not the correct format for blog posts - if he were to post it on SO, he would probably have to change the format.
actually, *everything* is terrible. Nothing works. There are always crashs, bugs, unhandled special cases that you happen to stumble upon. Even without this, there would still be cosmic rays that'd flip a bit once every few years. The universe is a sad place.
&gt; If you want to detect 0, use the positive-zero module. I can't even
&gt; Attempts at improving this like CMake do a decent job but it still is terrible compared to what Rust or Crystal have. The problem is that Rust or Crystal or Go or $LANG supports very few operating system / executable format features, or do it in weird and convoluted ways. Just look at how linking to the MSVC C runtime is done in Rust : https://github.com/rust-lang/rfcs/blob/master/text/1721-crt-static.md The day these language handle most of the specificities and intricacies of the native toolchains / operating systems correctly is the day where they do five times the size of today's CMake (which while good is also far from handling *everything*).
&gt; legacy code bases with &lt; c++11 How is this an issue? C++11 adds stuff, doesn't change/remove existing stuff. 
&gt; It's supported. "Supported" as in having an actual split function in the standard library. &gt; Sorry, that's an understandable mistake but you're wrong. `-1` is a signed int. I know, the point is that because of http://eel.is/c++draft/basic.fundamental#4 (which applies to conversions as well), the conversion to an unsigned type necessarily produces all-bits-one, regardless of signed representation or the size of either type. &gt; All the time, and **I don't worry about it** because I haven't used a platform where this didn't apply since the early 90s other than DOSBox, and I wasn't using that for programming. Right, which is why it's a strange conflation, because actual undefined behavior *is* something to worry about.
On the other hand Reddit has a very visible anti-SO circlejerk and bandwagon up votes anything negative said against SO.
I don't know if Scott reads Reddit, so you might want to post this on his blog!
One suggestion is try creating a local meetup for "C++ learners" or something on Meetup.com. I host a local web development meetup and believe it or not, a veteran developer showed up willing to help and now we're all friends/coworkers. As far as a great tutorial for C++... I was *surprised* how much this site covers: http://www.learncpp.com/ . The good thing about a basic C++ class is for the most part you will have to teach the basic language constructs. The students hopefully won't expect you to be able to solve random/bizarre errors as a result of their non-class related projects.
Don't talk - show!
Oh, OK - I suppose I might fall in that category (150k rep, but not a moderator) but I hope that don't behave like a dick - I mostly just like helping people, and sometimes I learn something myself. Admittedly I don't have a lot of patience for people who are just lazy, looking for homework solutions, etc, but, for people who genuinely want to learn, or just solve some immediate problem, then I generally go out of my way to help.
The number of upvotes is obscured to deter spammers by fuzzing the actual value a little, but it is close to the number of people agreeing - and what's this "linear", as if clicking an up arrow would be worth 0.4 of an upvote?
Let's bet. We can copy and paste Meyer's questions easily.
Yhe sorry I couldn't think about a better term, I just meant that the score of 27 doesn't actually means that 27 people agree with the comment.
I wonder if this kind of thing varies with different programming sub-communities ? I think the bulk of StackOverflow activity is in the area of JavaScript and web/mobile development etc, whereas I'm active in totally different areas (C/C++/embedded/DSP/SIMD/etc). Maybe some sub-communities behave more dickishly than others, so your personal experience might be coloured by that ?
I mainly consult SO for desktop-related areas, and there are tons of valid C++, java and C# questions closed for poor reasons. Its infuriating, and part of me suspects thats intentional. Ita not all bad tho. For my jsf stuff tho, BalusC is a full-on hero.
Well, i may try but i left VS few months ago in favor of Clion, it is not perfect but is much better than VS, the only disadvantages is cmake and the compiler options you have (the lack of it) GCC is much better than Visual C++ compiler (i send a negative feedback about the bad performance of the code) in my case is 3 times faster with the same -02 flag and i think it compiles faster Cmake is not that worse as you use it, in VS you need to do "strange" things to in order to compile as adding a dll o mixing projects so now is more or less the same with cmake But Clion is much better because the debugger works great, i see what i want (char[] array instead of string is not cool), the intellisense is far better than VS and it has the same or more cuality that VS So i may try but you lost me, it has to be very good to switch back to VS
You can have e.g. a 32-bit atomic counter, and use lower 16 bits to count strong references, and upper 16 bits to count weak references. Once the complete counter is zero, you can get rid of the control block.
I appreciate you taking the time, thanks for the suggestions.
[This one](https://www.youtube.com/watch?v=hHRaZy1LZPA) shows ;-).
Firefox users can open the page in Reader view to make the code readable. Just click the book icon next to the reload button. Not sure what tricks work in other browsers.
Holy crap, that tutorial is a didactic swamp. It takes about the most strained roundabout way of teaching what C++ is really about. Seriously: covering operators first? Sigh. The basic language constructs in C++ are much higher level than the syntax.
Very strange. In Readit App (Windows 10 application) source code style is very ugly, it is shown in white over white with a black shadow. But in Baconit (other W10 app), it is shown well colorized and over a black background. In Narwhal (iPhone App), it is shown as in Baconit. Microsoft Edge, Chrome and Firefox shows same right colors. Seems Readit App is doing something strange with the CSS. I think you don't need to be worried with this. Guilty is Readit, and only Readit. Sorry to be worried you!!
Stephan talks about it in [this video](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Advanced-STL/C9-Lectures-Stephan-T-Lavavej-Advanced-STL-1-of-n) starting around 36:40. 
I haven't really observed differences by area of activity. What I did observe was people unfamiliar with a particular domain suddenly appearing out of nowhere and doing random stuff to questions, for example closing them as duplicate or off-topic when an expert in the relevant area would have been able to tell right away that it wasn't.
&gt;Indeed. That's why I stay away from that toxic hellhole unless I get the results from Google search and there's no other option. If being a _toxic hellhole_ is what it takes to get you to Google a problem before posting on stackoverflow then you can see how it got to that state. 
&gt; StackOverflow has become a somewhat toxic environment for beginners because there are so many burned out people, but it is an excellent resource for finding questions that have already been answered. Part of the problem there is that there are so few reasonable questions. At least with the C++ tag most are "Why isn't my code working?" I vote to close way too many of those. Second most common are just silly questions anyone could have answered themselves with a modicum of googling or reading...or ANYTHING. Shit that gets asked all the time so that there's like 10-20 duplicates you can link to. I think I could count the number of actually interesting questions I've seen there the last 3 months on one hand.
I found that in [std::allocator::allocate](http://en.cppreference.com/w/cpp/memory/allocator/allocate). Probably this means that std::allocator won't rely on this feature. However, std::allocator_traits version is not tagged as deprecated. I was probably wrong: any standard compliant custom allocator is able to use the hint, although std::allocator won't. See [std::allocator_traits::allocate](http://en.cppreference.com/w/cpp/memory/allocator_traits/allocate). Therefore one might be able to support reallocation if allocate's returned address is the same as the user provided hint, just as it happens with libc's realloc, right? This is something I'm really interested in. 
I found it pretty easy to read.
You can say that again.
Not literally "standard", it's things like angular, mqtt/redis/socket/db clients, some small syntactic sugar providers (around 10-20 things overall). Browser-side. There was like 5-6 shell commands in what the web team presented as their steps to build the app. The list of the libs appears in the html file (to load them, apparently) and in one or two config files for the package managers. And all the libs are committed into the repository of the project anyways.
They are doing it wrong. They should invest some time looking at a tool like webpack, and plugins like uglify-js or Google's closure compiler. There should be two commands, `npm install` once after checking out the code, and `webpack -p` when you're ready to build your bundle. And a single include line in the html for their stuff.
I didn't even new sccache existed before, so I guess I'm not the only one who could be interested.
if the CMake cache creation and building of the project work correctly, we should take a look. Please ping me at mluparu at microsoftdotcom
Hmm I wonder if the remote debugging could be used for embedded platforms also. Using CLion for embedded has been a bit of an exercise so far.
Yes. That is basically the point of the LGPL. Of course when you modify the Qt code itself you have to publish it. In any case best is if you read the licence and its interpretations. IIRC enough information should be on the fsf website.
Sad that it's not open source.
This is true. I'm not complaining, just hopeful. Keep up the good work :)
so a comercial KDevelop… great! I want that. If only they parsed qmake files :(
CLion is free for open source
I see coloured fonts on a black background. I suspect you're blocking CSS.
&gt; If a prospective employer were to sneer Personally, I'd take that as a pretty serious red flag. An employer that do not 1) know (or even cares) what requirements (e.g. exotic architectures, lack of modern compilers, embedded systems) your code had, or 2) understands that a professional software developer can work with the tools he's given whether it's STL-less C++03 or hypermodern C++17, is probably not someone I want to work for. We're professionals, for crying out loud. We're code wizards, able to work our magic with paltry cantrips and powerful spells alike depending on what's in our toolbox at the time. Flip the table and show the employer the problems that arose in your previous projects, how you dealt with them, and why you dealt with them the way you did. On the last point, remember that "because it was quick, it worked, and it didn't cost us too much technical debt" is a perfectly valid answer that a project leader can appreciate. You're looking to pitch yourself as an adaptable problem solver, not a hardwired code monkey that happened to be raised speaking a different C++ dialect.
This is off-topic.
As someone who interviews people often, I would rather see something personal on your personal github. Not "implementing algorithms for my practice", but a bunch of haskell that even you can't understand anymore, a niche unix utility that only you care about, a data structure that you believe is better than boost.whatever (and you have metrics to prove it is for some use case). Sure it's even more awesome if you're the maintainer of some library we actually heard of, or if you fixed a dozen bugs in gcc, but impersonal programming exercises don't make an interesting portfolio. Still better than nothing though - 95% of candidates don't have any github profiles.
Ah, this makes a lot of sense. /u/STL, this is quite clever.
FINALLY better UE4 support and performance increases. It's been a pain in the bitch to get CLion to play nice with UE4's code base.
I am wondering if the "Lifetime Safety: Preventing Leaks and Dangling" approach by Herb Sutter &amp; Neil MacIntosh is able to detect this, assuming the vector implementation has been properly annotated with owning pointers and such. If I understood that approach correctly, it would have detected this memory leak here. Doesn't VS have this kind of analysis already? Would be actually nice to try this.
Can you please walk me through the reasoning behind the first part of your first sentence? What parts of the Standard get you from `X&lt;T&gt; x{{}}` to `X&lt;T&gt; x{ T{} }`? I find the Standard tricky to follow, because we need to list-initialize not just `b0` but also the parameter `il` in `b0`'s constructor.
While I like using modern C++ (C++ 11 or later), I think use the right tool for the right job. First check, in your current organization whether they can support C++ 11. Some features in C++ 11 support heavily OO by guaranteeing that by checking at compile time and generate error if the code look bad. Try to make the case to modernize and refactor the code base one bit at. Research and make the case to modernize at the code would be easier to understand and maintain for newer developers and many implementations of the STL are more performant and less error proned then hand crafted objects. Boost I avoid using for portability, as it is in not part of the standard library, but if there is something like lock-less concurrency queue I might use for a need. If your current employer reject you ideas the look at a project that you can build on you own time like raspberry-pi or arduino or look at building a game engine or trading engine, etc. with modern C++ tools. A good resource is en.cppreference.com for modern C++. Also I think a lot of companies are looking for C++ 11 and current now cutting edge or bleeding edge technologies. 
This excites me so much. I know that (currently) copy elision is able to happen 99% of the time and you just shouldn't worry about it. But... If I'm writing something in C++ instead of Python, it's cause I want total control, 100%. And not knowing if some huge object is going to be copied on return or not kind of breaks that whole thing for me. Again, yeah, I've never personally run into a problem where it turned out to be copy elision not doing its job. But this just feels right. Like wearing a seatbelt. I've never been in a horrible car crash... but peace of mind is nice :)
I think your conclusion is correct, but I'm not sure you get there via `[over.ics.list]`. I agree that a key question is whether we can convert `{{}}` to `std::initializer_list&lt;T&gt;`, but I think the proper route to take may be [dcl.init.list]/3 bullet 3 ("If `T` is a specialization of `std::initializer_list`"...), which tells us to use the rules "described below," which presumably means [dcl.init.list]/5. [dcl.init.list]/5 tells us to try to create a one-element array of `T` whose element is copy-initialized from `{}`. When `T` is my class `DefCtor`, such copy-initialization is valid. If this is correct, credit goes to the commenters on my blog. If it's not correct, the fault is mine for failing to follow their logic, and I'd be grateful if you'd point out the flaw in my analysis.
Well good to know I still a lot to learn ;p (truly, the more I seem to know about the language the less I feel I understand)
The inquiry for overload resolution is whether you can form an implicit conversion sequence, not the semantics of the initialization. [over.ics.list] controls whether an implicit conversion sequence can be formed (and hence whether the constructor is viable, see [[over.match.viable]/3](https://timsong-cpp.github.io/cppwp/over.match.viable#3)). If the overload is selected, then the actual semantics of the conversion is controlled by [dcl.init.list]/3.3 and 5.
Right, the `b0` case is not an identity conversion; the conversion sequence for that is the conversion sequence from `{}` to `DefCtor` (per [over.ics.list]/4's "the worst conversion necessary to convert an element of the list to X"), which is a user-defined conversion sequence per [over.ics.list]/6, bullet 2. `a0` is an identity conversion, however, and that is what I was referring to above (the `{}` in `X&lt;T&gt; x({});` to `initializer_list`).
using CLion daily for remote debugging and dev of an embedded platform. What are your issues ? 
How does this compare to KDevelop? I switched to KDevelop recently from emacs and I really like how it offloads most of the magic to libclang, git, cmake, doxygen etc. - so it's an IDE in a more literal sense as it integrates existing cutting edge tools. It's got some rough spots... the CMake configuration menu isn't as accessible as I'd like it to be, an the git integration is mega clunky next to magit But, what does CLion have that I should be excited about?
The Clang/C2 compiler uses the Clang front-end with the VC++ code generator, so it probably won't be useful for this endeavor. VC++ does support Linux development from Visual studio, but it does so by connecting to a Linux box on your network, and invoking the compiler there, so VS is basically just acting as a remote editor (and debugger front-end).
You can use docker for this task if you're on windows and you want to compile for Linux!
Using a pointer is not really an old technique. I mean it actually is kind of similar to how the language works: `dynamic_cast` exception throwing version is enabled by passing references, and the pointer returning version also takes a pointer. In boost variant they also did it this way: `boost::get` takes a pointer when you want it to return a pointer, and takes a reference when you want it to throw exceptions. Idk, I don't think it's bad to use a pointer here instead of `std::optional`. If the return type is supposed to be a pointer also to the thing that is pointed then it's pretty hard for the programmer to screw it up about the lifetimes.
I am specifically looking for a cross compile solution. Also, AFAIK it's not possible to run a docker instance natively on Windows without a VM.aybe things are different on Windows 10.
Even after blocking all kinds of js (using uMatrix), the code is displayed fine in Firefox.
You can't compile for Linux using Clang with Microsoft c2 codegen. But you can easily compile for Linux using windows Clang with stock LLVM codegen.
The "Microsoft CodeGen" is specifically Windows-only. There is a separate "Clang for Windows" install which uses llvm's codegen, which might support cross-compiling (I don't know for sure but it's much more likely). Alternatively you could install Linux Clang+llvm inside the new Windows 10 Ubuntu subsystem and use Visual Studio's remote compilation pointed back at the same machine, if that works.
Why are you sad that this IDE specifically is not open-source? Is that really truly your sentiment or do you just want it to cost no money? It may be presumptuous of me but you might benefit from reading [this Wikipedia entry](https://en.wikipedia.org/wiki/Gratis_versus_libre) on Free vs free.
Yes, I think that's a problem with how the review queues work - they really ought to filter the queue so that you only have to review stuff with tags that you're interested in. I find I have to skip a lot of questions unless there are glaringly obvious problems, as there are whole subject areas that I know nothing about. I suspect others may not be so reticent. Without the review process though the site would have a terrible signal-to-noise ratio and would consequently be a lot less useful - it can be brutal but it's necessary.
You know, it's funny. I had these same conversations about 10 years ago, before people realized we'd hit peak MHz. Back then people said the same things, that we didn't need to worry about performance because machines were always getting faster. The top P4 chips hit 3.8 GHz, and we're only barely past that today. We have better IPC, which helps, but IPC has moved very slowly for many years now. We have more cores, which we're still figuring out how to use well. For the most part though, progress has slowed to a crawl. In many use cases, other languages are fast enough. It's true. Many (smaller) games are written in C# these days, for example. The core use cases remain with C++ and will until something better comes along. And the new C++s are better than C++98, so the the bar for a replacement language is only increasing over time.
Thanks, just updated that bit
That's legal code?
Could be a bug with C++11 support? The type_info of the thrown exception has the name NSt8ios_base7failureE Using typeid(std::ios_base::failure).name() in the source gives NSt8ios_base7failureB5cxx11E The standard library used does not throw the right exception.
Well, I thought that maybe it would be nice to try it out, but if that is more work than `apt-get install clion`, I won’t do it (and stick to Emacs). And for the easy installation to work on Debian, it has to be DFSG-free, which includes open source.
&gt; Still better than nothing though - 95% of candidates don't have any github profiles. Because we have better things to do with our live that keep on coding outside work, like I don't know family and friends, and most of the employers don't allow for placing company code outside of their virtual walls. 
I'm a *huge* fan of the new way of handling CMake. The only downside is that I previously had a configuration for debugging and one for building a release binary and could easily switch between them. Now I've lost that apparently.
&gt; If a prospective employer were to sneer "wow your job don't even use STL that's 20 years old?" A job interview is not only a place where your potential employer decides if you are a good fit for their team. It is also a place where you decide if a potential employer is a good fit for you and what you want. If a potential employer looks at your past experience like that, you should probably avoid the job (because it is probable the other employees were the ones that _passed the criteria of this guy_ and you would have to work with them). &gt; I'd like to point to meaningful code I've written and use that as a stepping stone to something newer. Ideas? Focus on design. Sometimes a small designed utility class can change the way you write the client code drastically, and eliminate entire classes of defects from your code base. What I would look for (I am not an employer): - how easy are your APIs to use? - how easy are your APIs to misuse? - are your APIs documented? Well named? Self-documenting? Intuitive to use? - what do you add to the documentation of an API? (what do you consider important information to be found later?) - do you document your assumptions? do you validate them with code? - is the state of the instances of your classes always valid? consistent? - do you use RAII? raw pointers or other resources? - how well are your concerns separated? Do you mix levels of abstraction? - does your code have superfluous features? Is your design rich? Is it poor? what are your abstractions and how did you come up with them? - do you pay attention to efficiency? how? (what do you focus on? algorithms? implementation speed? have you ever systematically measured the state of your code before making changes to it? What changes did you choose?) My previous job was maintaining a code base with C++ code written on a 20+ years C base, and the team had the experience of 20+ years of C coding. I ended up writing some code at home for C++14 (not related to my work), which I never completed or published, but it gave me a good starting point in the interview for my current position: I could talk about what I do or do not like in the current standard, provide a sample of code for an utility class I had written and posted on code-review and so on.
Unfortunately not - without a specific "expand allocation" allocator function, you can't support it. The reason is that the standard pattern for reallocating the storage of e.g. std::vector is to make the new allocation, copy/move-construct the elements over, destruct the old elements, and then free the old allocation. If the new allocation is actually the same allocation, then the copy-construct and destruct steps break down and destroy your data! I guess I've found out what the problem with an "inline" allocator type is...
Anyway, I've also tried this with VS 2013 and the failure::code().value() is 1 (EPERM) instead of ENOENT so still not interesting yet :(
And they are not even serious about fixing it. I mean the comment about using environment variables to decide which version to throw just hit 11 on my wtf scale. Problem: The ABI of std::fstream changed because it now has to throw a different exception. Obvious solution: Provide a c++11 version of std::fstream with the ABI required by c++11, just like they did for std::string 
That's really nice! Thank you :-)
Cheers, I will make sure to feed back! I gather you're in some way involved in the development of CLion. Will makefile project support be ready any time soon? (Sorry for the "are we there yet?" question, but I truly am interested) 
While i don't think this will have any performance implications (as compilers are pretty damn good at doing copy elision already), being able to pass and return non-movable/copyable types by value is a great addition.
I rather like working on personal projects, what you consider "better" is subjective.
why not `std::observer_ptr` then? even though, I don't share this idea of using pointers like that anyway, since we already have tools to substitute that.
Any particular reason for making the move constructor argument in the snippet `const`?
The Conan team was very excited about this at Meeting C++. Seems Conan has a great future and even more resources to build up on, good news.
Why don't you simply use KDevelop? It's free of any charges and also free to be used commercially, so there are absolutely no restrictions. My intention is not to hijack this thread, but in fact, the features of CLion are also supported by KDevelop out of the box, and given KDevelop uses libclang in the background, it also supports essentially *all* of C++. :-) - Feature tour: https://www.kdevelop.org/features - Download: https://www.kdevelop.org/download
Refactoring, code navigation, code generation, analysis - to name but a few areas it excels in. The Git integration is pretty smooth too. Why not try it yourself to see how it fits your needs, personally? There's a 30-day free trial.
Glad you're enjoying it. It's a trade-off for sure, but it sounds like you appreciate the direction we've taken. We're still considering ways we can have our c(m)ake and eat it! (i.e. get the fast switching back).
Ah, interesting, thanks.
If you are lucky a company may even want to get their hands on software you have written to either sell or continue development for them.
The only reason for making it `const` is that I could, since I wasn't actually swapping anything. It's kind of a special case and I agree that it might be confusing so I've updated the snippet! 
Yes, an awful "tutorial" that doesn't cover anything important about pointers (pointer arithmetic, null pointers, dangling pointers, ...), let alone which C++ constructs provide better alternatives. Newbies - please look for better tutorials. This one blows.
That is just the beginning of the c++ tutorial, more pointers tut will come
I agree and have actually watched that talk. Btw if you have or get a trial of a Pluralsight account, Kate has SEVERAL *great* courses on C++. She's very good teacher and nice as well, she's on my Twitter.
Graphics and Game programming. Sometimes medium to large tools.
I use it to build [real time image processing apps](https://github.com/matt-42/vpp) running on desktop computers, smarphones (and sometime port them for fun to javascript with emscripten). I also use it for [web programming](https://github.com/matt-42/silicon). Check the links for more information about these projects.
[removed]
I am not currently actively working on an embedded project on CLion, but I have used it for development for ARM in the past. If I recall correctly the main issue was the inability to tell CLion to use arm-gcc, and I think I had issues with coupling it to my debugger (gdb via openOCD iirc) as well. A lot could be worked around through custom cmake targets and running external tools with keyboard shortcuts, but that wasn't always a great solution. Since it was a while ago that I worked on this project (a year or so) and even longer ago that I actually set up my dev environment, maybe my issues are no longer present in newer versions of CLion.
Backend application with a strong need for performance.
Me too man :3
Graphics programming
Cross platform mobile code. C++ is the 'write once run everywhere' of the mobile world. Pretty incredible.
Synthesizers (as in audio). And also a wide range of other random microcontroller hobby projects (C++ is my goto language for embedded work).
&gt; Having a project sitting around gives much more insight and can allow for better decision making. This almost amounts to a lie because employers and recruiters do not seriously review this stuff. Maybe you personally look over github profiles, but it's really not that common. "Have a github with solid personal projects to get hired!" is the claim and it's just not true. Nobody cares and nobody looks over the code before the interview starts.
Client side, cross-platform consumer applications. 
Embedded Linux devices that process GPS and communicate over cellular and high security radios as well as using GPIOs for inputs and outputs. Windows graphical programs to interface with those devices to configure them, collect their logs, and monitor them in real time to provide live updates to web-based mapping displays. And lots of other stuff. :P
Compilers
You're right. I'd checked that after posting and forgot to add it to the comment. The only option would be to either specialize std::vector (not a good idea imo) or implement a new vector-like container specially designed for this. So reserve() should look like: if( capacity() &gt; newCapacity ) { // Let oldBuffer = data(); std::allocator_traits&lt;allocator_type&gt;::pointer newBuffer = std::allocator_traits&lt;allocator_type&gt;::allocate( get_allocator(), newCapacity, data() ); if( newBuffer != oldBuffer ) { std::uninitialized_move(oldBuffer, oldBuffer+size(),newBuffer); std::allocator_traits&lt;allocator_type&gt;::dealocate( get_allocator(), oldBuffer ); oldBuffer = newBuffer; } }
Well, you can use 80% of it and be happy :)
thanks for the advice, will improve on my next tutorial :)
&gt; some huge object is going to be copied on return or not kind of breaks that whole thing for me. Why would you return a huge object by value?
Wow. Well written and very interesting. Thank you for taking the time to do this :) 
Seconding this, currently trying out `vulkan.hpp`.
MPI based distributed memory applications, recently it has been fluids based simulations. If a simulation is going to take weeks to run, then I care about performance. But these simulation codes are built of lots of code, and only a portion is performance critical. I like that I can use one language to simultaneously get abstraction where I can afford it, and performance where I need it.
That's a problem, then. There are essentially no mainstream programming languages (save for D) that have RAII, and without RAII there's no C++. The question of "how do you do xyz in C++" isn't merely one of literal translation from language X to C++. It's a question of how to reformulate your problem to leverage what only C++ has to offer. And that tutorial fails miserably at that. Further, I claim that the tutorial is useful for no one: for a beginner, it's in entirely a wrong order and doesn't focus first on what makes C++ - C++ and not, say, Java. For someone coming from a different language, it lulls them into thinking that a mere understanding of how syntax translates will make them productive. There's plenty of Java and C written using C++ syntax and it's just sad.
telco infrastructure - server/client applications
I work on a classical composition software based in stochastic random processes and graph theory all in C++
I've not really looked at the new and improved C++ stuff for a while... it's just a cascade of ever increasing minutiae of the language features and I thought the list of "don't ever do this" was long enough already.
Networked game engine.
Production movie studio renderers and associated tools.
Audio programming for games. Currently I'm building a procedural music engine
Oceanographic engineering data manipulators for clients and in-house work mostly. Bit of OpenGL when called for Don't use it for personal projects, I mostly stick to python for that
Control system for heavy machinery
Embedded systems. It's basically the same as the C code you would see in an embedded system, but the compiler does more work for us.
Genuinely curious, what do you feel gives beginners trouble when using VS?
Sweet! There aren't *too* many of us out there. We've probably run into each other at SIGGRAPH. Or you're my coworker.
Assuming I don't use any third party libraries, or when I do, their 80% matches my 80%. :)
VS has a TON of features and it can be a bit of an exercise getting your head wrapped around the VS ecosystem of projects and solutions, although this has been improved. It may be simpler to start out with a less feature-rich IDE at first so you can focus on the code and not the IDE.
For when Java or .NET need some integration with OS APIs not exposed on their libraries, or some optimization help (after profiling). When making use of JVM or CLR native management APIs. Writing portable business logic code between Android and UWP.
Competitive programming.
This has been fixed by [LWG 2193](https://timsong-cpp.github.io/lwg-issues/2193) since C++14, and all sane implementations would backport the fix to their C++11 mode. Meanwhile, [LWG 2510](https://timsong-cpp.github.io/lwg-issues/2510) explicitly depends on this behavior.
The video description here contains a bunch of useful links, including links to Connect videos that include demos: https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-54-Whats-New-In-Visual-Studio-2017-RC-and-Introduction-To-Vcpkg That video was intended to be more of a summary :). 
Real-time computer vision and graphics rendering technology for broadcast video environments (http://supponor.com/).
How does that works for Android? You go through the NDK? 
Another vote for MPI parallel science simulations here. Also, simultaneously using GPUs attached to the processors. CUDA version 8 does a pretty good job of enabling modern C++ on GPUs.
What computational geometry library do you use? I've tried CGAL for CAD/CAM purposes, but it seemed to value correctness over speed to an absurd extent.
Of course. Works well!
Emulation, performance focused backends and game servers.
Bots and automation tools for online games
Submarines.
More likely graphics as in image generation (2d or 3d), and/or image processing. Which is the same for me. The UI libraries for C++ suck; there are much better platforms on other languages that are better suited to UI. 
Data analysis and physics simulations using ROOT and GEANT4. 
Does it have any effect on performance compared to other mobile development languages?
Embedded software to control a medical imaging device (motors, data transfer, record data), and software to reconstruct medical images from said data with GPUs.
It certainly can perform better than Java, Obj-c and Swift. Bridging the languages can have significant cost that needs to be considered in the design of your code. You can't really build an app with just c++ though. It's more for platform independent code. Building a complex networking stack is a good example. Write support for a custom network protocol in c++ and then reuse it on all desktop and mobile devices. 
Chronologically: - High performance log parser - News feed parser and distribution - Content Management System capable of handling 10K+ connections per second - Pump control for moving around honey, pudding and syrups. - Train driver and passenger communication and information systems - Distributed heating and hotel interface system for bungalows - Prototype networked ERP core, data abstraction and UI core with scripting and client synchronization across mobile, tablet, online and offline pc clients. - Compressor and Condenser Rack control for food retail (from tiny to hyper markets) - System Control and UI for Reefers (Cooling containers for shipping)
Im using JavaFx for an application but i want to try to write it in another language (for practice), and i installed VS2015 to use visual C#, What language would you for a pleasant UI experience other than javafx? Sorry if its off topic
I guess this does only work if the function body is in the same translation unit. So in many practical cases copy elision would not apply.
Medical image processing with ITK
I embed a domain-specific-language for fast image processing in it: http://halide-lang.org/
In order of how I spend my time these days: - robotics industrial/embedded software (current dayjob); - game dev (home projects now); - generic libraries (that I end up using in my other projects); - tools for digital-native narrative art creation and publication (open source project); - computing experiments (mostly to check if something is possible in practice); - some web-related experiments (because it's interesting to use C++ in web domains); Note that I don't do much graphic dev, I don't have enough time to learn everything yet. 
We use Clipper and Boost. Everything else is written in-house. 
I use it to write project/library level code used in bioinformatics and computational biology, usually related to custom database solutions, scientific computing and machine learning. I use it because it's performant, well structured, and relatively stable compared to things like python. Usually we cut all corners to maximize productivity because a lot of the projects are one offs. For those that need to be solid and reusable I prefer to write them in C++ if only to force myself to write it better. 
!removehelp
Submit your resume here: http://jobs.intel.com/. We have positions open for both front and backend compiler work, both experienced and RCG. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/5eg6oz/problem_with_stdifstreamexceptions_and_open/daczlq3/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is a bug, so it's kinda in scope, but as this has been answered I'm going to remove it.
JavaFX and FXML is very similar in concept to WPF and XAML, so if you're going to the Microsoft stack, it looks like you're picking the right tools. Use C# and WPF. 
Ahh, excuse me for not reading the rules!
Vision sensor and 3D camera firmware
goto....hehe 😋
I'm making a DAW (digital audio workstation) specifically designed for live looping and performances. (https://zenaud.io)
Large scale data processing.
Nope as in game engine graphics.
GUI programming from scratch without using any 3d party gui toolkit
Options Market Making / HFT
Chances are, you're actually the same person!
Decentralized, cross platform VoIP platform.
I thought you guys used EDG for the front end
We do, we end up customizing a bunch. ICC strives to be MSVC compatible (even more compatible with MSVC than MSVC sometimes!), so it ends up being a bunch of work in that regard. We also end up finding and fixing a decent amount of EDG bugs. I personally tend to concentrate on FE features that Intel cares about that we share with the community.
As a lead developer of one of said code bases, it's a pain in the ass. We're shipping a fairly broad development platform, so lots of exposed API. There are lots of things that we want to do for our users, that would be way easier to express if we adopted C++11, but our supported deployment targets aren't all quite there yet. We've decided to abandon the last laggard after our next release, in the coming ~month. Then we'll be free to actually make use of all the C++11 niceties.
It's a factory function - what's your alternative?
Genetic programs. Its the only choice for getting reasonable speed.
Skype for Business
veloper?
GUI applications (I contribute to KDE)
Programming games, embedded development, tools that are too complicated to just do in a terminal session and most other programs I write. I'll rarely decide to use python, lua or ruby if I fancy a change or want something a little less verbose, but often I spend so long looking through documentation I may as well have written it in C++ anyway. I really don't do any web development so I can do everything I need with it pretty well.
I'm impressed that very few people here seem to use C++ to develop cross-platform desktop applications. I didn't think we, GUI application developers, were such a small demographic group.
Controls applications, mostly in a robotics context
This headline can only be written by a noob...
To be fair, if the return type of the factory is a polymorphic type, the factory can return a `unique_ptr` or `shared_ptr`, as per Herb Sutter's [*GotW #90: What should factory functions return, and why?*](https://herbsutter.com/2013/05/30/gotw-90-solution-factories/). But for a non-polymorphic return type, Herb notes: &gt; Guideline: A factory that produces a non-reference type should return a value by default, and throw an exception if it fails to create the object. If not creating the object can be a normal result, return an optional&lt;&gt; value. EDIT: Of course, a factory that returns a user-defined type, a `unique_ptr`, or a `shared_ptr` would be called like this: auto x = myfactory(/* args... */); which is just what /u/mcmcc showed above.
A decent tool for maybe teaching as someone else said, but for actual development it does certainly lack a lot of useful/necessary tools which anyone trying to actual develop something would want or need.
Cool, never heard of this before. ROOT appears to be more akin to Matlab than a raw storage format. What's the advantage of ROOT over other "full suite" solutions such as Matlab (other than being open-source, of course)? I'm using a mixture of c++/python and a custom encoded data-format (c++) for my research today (not physics), always looking for new alternatives!
I think you replied to the wrong guy
Game programming
I should really crack that out and toy around with Vulkan. I downloaded the Vulkan Programming Guide about two weeks ago. What are you enjoying and loathing about the new API?
We end up being compatible with older versions of MSVC, since we have a version flag for them in ways that newer MSVCs tend to abandon.
hows compat with gcc, clang?
Evil
No loathing so far, but I've barely gotten started. I do enjoy the simplicity, it's all simple in the same way assembly programming is simple. Low-level, but no surprises.
I wrote / am writing a [platformer game engine](https://github.com/MQDuck/Chimp-Engine) in C++/SDL. It's designed to be highly generic and customizable but there's currently no level editor (I promised my friend he could make it) so it's hard to play with it too much. I dunno if it will ever be of interest to anyone outside of me and my group of friends, but I'm still pretty proud of it.
Honestly I mostly just play with it to make sure I don't get too rusty and keep myself better-rounded. My proficiency and my career are in Java and for my personal games projects I like LibGDX. I am mostly here to read what others have to say about the language, and to read about programming concepts that, while they may not apply to the language I use in my daily life, can change the way I think about my approach to problems. 
I feel like that is something you cannot write in a public forum.
Mathematical optimization, distributed systems. Cross-platform or Linux only.
Molecular structure design and prediction.
Finance / Banking: High Frequency Trading (HFT) platform software - low latency is so much easier to hit with zero-cost abstractions! C++ gives me a way to write complex object-oriented code that compiles down to very little assembly. Equally importatnly, it allows me to mindfully manage what goes into the CPU caches, which is the difference between 1-nanosecond latency and 100-nanosecond latency. (And that's the difference between making another 1K or losing it.)
Avionics/SDR/Embedded
Professionally, I use c++ to build data tools to make my life easier. Personally, I've used c++ in games, compiler tools, and I am currently writing a distributed game/simulation engine for big mmos.
I don't want to start holly war, but could you elaborate more about your hatred towards OpenCV?
Where are you guys located? 
Gamehacks and different interpreters for my own languages.
1. A torrent tracker-proxy with TCP and UDP TPROXY and non TPROXY mode. 2. A TCP P2P cache proxy working in TPROXY mode only. 3. An HTTP cache proxy (in development) with some new concepts for caching (it's not request based only). 4. A few more networking applications which support some of the above applications.
Software for an embedded system using Linux on a Beagleboard.
Last time I applied to intel, they responded after 8 months only to say the position was already taken. This time it's been a month, I'll be looking forward to the response in 7 months. :-/
Sensor based flight stabilisation on baremetal cortex-m0 with 8KB ram!!
The syntax of the web framework is freaky!! But it looks cool!!!!
Well, there's two parts to wrapping C APIs. 1) Knowing how to design a C++ API (which not everyone can knock out of the park and is definitely a learned skill. You can definitely jumpstart it with Martin Reddy's book "API Design in C++") 2) Knowing C API design choices and how those might translate to C++. Keep in mind that there are effectively 3 ways to wrap C APIs: * Thin wrappers for lifetime (unique_ptr with a custom deleter) * A full RAII object (something that might hold a unique_ptr) * Full types that wrap the C API in its entirety, but do not use inheritance and expect to be used in a composable way Part of the reason I wrote the `retain_ptr` proposal was so I could have a thin wrapper option (just the `retain_ptr`) for APIs that use reference counting, instead of needing a full wrapper object. I definitely need to get around to releasing my SQLite wrapper that I've been using off and on for a few years now. I personally think it's a good example of how to wrap a C library, and might help people coming to C++ from an inheritance focused language. :) On the subject of getting into C, I recommend it if you think knowing the whole picture would help. It certainly can't *hurt* to know C, especially because it is such a huge difference from C++. Once you know quite a bit of C++, you can see certain design decisions for C interop while learning C, like why we can technically do `struct Foo foo` in C++, but it is just easier to do `Foo foo`. (I hope this helps. It's late where I am right now)
Looks fine in [night mode.](http://img.cleroth.com/chrome_2016-11-24_09-50-43.png) =[
Embedded programming, DSP. 
&gt; it looks like windows command prompt That's the worst advertisement I've ever seen.
Everything. But mostly PowerDNS.
Looks really nice that web api library. Good job!
Competitive Programming.
High-performance networking. Antivirus. Video game development.
Qt
man, thanks, there are so many useful projects that have spun off of ROOT !
Games
I think you are right.
Do you mean VST synths here? Something like Serum, Massive etc. Did you find any resources online that helped you out with your projects?
Videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r5ehrel?feature=playlist&amp;nline=1) VIDEO|COMMENT -|- [Le mouvement de l'air / The movement of air](https://vimeo.com/145201272)|[3](https://reddit.com/r/cpp/comments/5ehrel/_/dacpjn4?context=10#dacpjn4) - Think of shows where you have both audio tracks, video tracks, light control, some motion capture of the performers, etc (they are generally all handled by different software). At some point you want to be able to synchronize everything to make some... [Visual Spray Assistant -VSA- 1.0 release](https://youtube.com/watch?v=TiTLzi8pV-Y)|[2](https://reddit.com/r/cpp/comments/5ehrel/_/dadmzqu?context=10#dadmzqu) - I made this :D a 3rd party tool to help train aim in cs:go. [CppCon 2015: Chandler Carruth "Tuning C++: Benchmarks, and CPUs, and Compilers! Oh My!"](https://youtube.com/watch?v=nXaxk27zwlk)|[1](https://reddit.com/r/cpp/comments/5ehrel/_/dadpm5a?context=10#dadpm5a) - Gosh, nothing off the top of my head. The basic cycle is: Measure code to find bottlenecks (latency or memory). Discover measurement was flawed and was measuring the wrong thing, and fix measurement. Repeat 1 &amp; 2 until you get a good measurement... I'm a bot working hard to help Redditors find related videos to watch. *** [Play All](http://subtletv.com/_r5ehrel?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get it on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
&gt; My code runs in CPU isolation, no other threads get to run on the same cores.... when you tell the kernel that only one thread can run on a core, then you can be fairly sure that any latency is caused by the thread TIL about isolated profiling! That's a good point indeed. &gt;Don't switch AVX instructions on and off. Either keep using them, or skip them entirely. So either we write code in such a way that's "vectorizable friendly"(madeup term) or don't use them at all (I'm assuming vector instructions take more cycles compared to regular ones because, well, they're _built_ for larger batches of data) so I guess some kind of tradeoff analysis is necessary (I wonder how that'd go) Anyways, thanks for the links and information! I know what I'm doing this weekend :) 
I'm not sure I understand your question but here is my answer anyway. I think you should find a thing that you want to work on. Having background in back-end you probably should look at boost/asio. If you want to play around with desktop development play with Qt. For a bit of game development take a look at libcinder. It's up to you that you want to start with. Pick a topic you already familiar with and look around how can it be implemented in C++ way. Port your pet projects from C# into pure C++ or spice them with libraries. At the end it's not about language it's about willing to learn new stuff and use it in practice.
Along with CUDA for parallel programming for my school!
damn dude, use `var`.
I didn't say I *liked* using Swing. In fact, I feel dirty doing it. But yeah, JavaFX does look better. 
MPI no longer ships with C++ bindings. Its a C only implementation. 
yes but for a starter it is a good tool
Everything
Chill out on the comments. Otherwise, good job. :)
I agree, chill out on the comments, but also place them a line above the piece of code you're referencing, not to the right of it.
1) too many comments 2) using namespace std; 3) char array instead of std::string 4) macros 5) no need to close out file if you are going out of scope anyway
This might get moved to /r/cpp_questions soon, but while it's here... I reckon this is a pretty good attempt. Just a couple of nitpicks: * If you haven't come across `std::string` yet, then you're in for a pleasant surprise! It can make your program a bit simpler :-) * In C++, don't use `#define` for numeric constants like your `LINE_WIDTH`. It's preferable to say const int line_width = 100; or, even better in C++11 constexpr int line_width = 100; * It's not wrong, but there's not need to say `f.close()` at the end -- the file will automatically be closed in the destructor anyway. * Lastly, it looks as if the program will quit if it sees any line beginning with a `Q`. Instead, it should probably quit if the line contains *only* a 'Q' and nothing else. 
At work I use it to produce high-quality cross-platform navigation software. At home I use it for retro text-based gaming libraries and applications.
What do you use for your toolchain, Linaro? Sourcery Codebench? Your own build of GCC?
A good way to do that is to go get involved in the open source community, like LLVM for example, and watch for job postings on their mailing lists.
You can have a look at my Github repos, but they are just prototype quality. Message me privately if you want more info.
`using namespace` gets called out a lot, but it's important to remember that using directives are only really harmful in header files, where they can have unintended effects when included; in source files, they're generally fine, though it's always better to restrict their scope as much as possible.
I agree with previous comment. Turbo Vision, OWL and VCL are for me the best C++ ones, but sadly faded away. Qt guys seem to be focused on moving everyone to JavaScript, specially outside the desktop targets. The only C++ GUI toolkit that gives me joy to use currently is XAML + C++/CX, with Microsoft finally adopting C++ Builder RAD like tooling for Visual C++.
Thank you very much :)
Can I ask you a question? I am new to Linux development and I want to learn. I wish to program on Visual Studio and compile and debug on a raspberry pi, is there a useful guide or book that I can use ? I am just starting and any help. Would be appreciated. 
A possible solution: public class example { public static void main(String[] args) { int[] arr = {2, 3, 9, 4, 10, 99, 7}; java.util.Arrays.stream(arr).sorted().forEach(x -&gt; System.out.printf("%d ", x)); } } Java *6 lines*, C++ *10 lines* :) 
AStarDemoCpp ? Thanks!
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/5enprs/i_have_reached_the_critical_stage_of_my_c_lesson/dadwd0w/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I definitely agree there's a trade-off! Some people are more on one side, other people more on the other side :-) The link you posted is definitely awesome, it's amazing what you put together and how easy it works! I would just want the syntax to be more C++-like, even if it means it'll be a few lines more - but that's my personal opinion :-)
&gt; why we can technically do struct Foo foo in C++, but it is just easier to do Foo foo. In C++ you'd actually still use `struct X x`, however it'd be for forward declarations, like `struct X foo(class Y y);`
Industrial non-destructive testing (steel, railways), machine control, data acquisition/processing/imaging, signal/communications intelligence
Was this just a blogging exercise? Perhaps, because nothing is confusing here other than the examples. Swapping the various constants, ie, using k2 in f3 seems to add an extra layer of obfuscation.
Using XAML GUI tooling, interacting with Blend or creating UWP controls for .NET consumption still isn't supported. I only plan to advise using it when it reaches feature parity with C++/CX, specially since it appears MS management is still unsure which horse to bet on.
I previously used [GNU ARM Eclipse](http://gnuarmeclipse.github.io) but now I use [System Workbench for STM32](http://www.openstm32.org/HomePage) because it's compatible with ST's CubeMX code generator. It just makes it a lot faster to get up and running on a new board since it generates all the boiler plate code for you based on pins you map out. ST's libraries are certainly not the best but they are very convenient at the beginning. I tend to replace a lot of the generated code later in the project.
That was entirely unintentional, but I'm going to leave it as is :)
I have not worked on VSTs, just software running stand-alone on platforms other than PCs. It's not so hard finding material on DSP and digital synthesis. I don't know if the same can be said for VST-specific materials. 
If you're going to learn IP sockets, use boost::asio. That library will eventually become a part of C++ standard library. For doing communication and security, Linux is a good match with its command-line tools that show what's going on (strace, netstat, nmap, nc, gdb). And also for reformatting sets of textual data: grep, perl, etc.
Thanks for the info! 
I wish someday I could really understand the implementation of boost multi-index container (there are few others as well). Is there anyone out there who understands it (not just using it) well ? OR could it be implemented in a more simpler way using the new language features in c++14 or c++17 ?
Do use compiler key `-fconstexpr-steps=50000000` and bisection to evaluate your eliteness. (on clang)
Try to write some (more or less) useful software, maybe something that helps you do something, or a little library which provides functionality x.
Nobody ever claimed that captureless lambdas were pure. If you want purity (or as close as you can get to it in C++), use `constexpr` — it'll be applicable to lambdas starting in C++17.
I have made a couple of programs that help me resolve mathematical calculations but now I'm looking for other ideas so I can try and program something a bit more complex and challenging. 
There is [a bug](http://stackoverflow.com/a/40106926/1430927) in gcc related to this technique.
Thanks for the recommendation, I'll definitely try and get my hands on that book! 
For future travelers, be forewarned that multi index comes with a very heavy compilation cost. It could definitely be improved with the new c++ features — it predates even C++11 — and the older C++ syntax weighs heavy on its API. That said, it is a great library, but sits in a peculiar place. I've since migrated most code from using it, to using either flat_map or vector etc, or SQLite for large data that needs multiple indexes or memory paging. The data in the middle of these two extremes is where multiindex shines. 
The following code fails to static_assert with VS 2017 RC: namespace detail { constexpr std::pair&lt;const TCHAR *, bool&gt; in_bounds(const TCHAR *str_, const std::size_t num_args_) { std::pair&lt;const TCHAR *, bool&gt; pair_(str_, true); std::size_t acc_ = 0; while (*str_ &gt;= '0' &amp;&amp; *str_ &lt;= '9') { acc_ *= 10; acc_ += *str_ - '0'; ++str_; } pair_.first = str_; if (*str_ == '}' &amp;&amp; acc_ &gt;= num_args_) { pair_.second = false; } return pair_; } } constexpr bool args_in_bounds(const TCHAR *str_, const std::size_t num_args_) { for (; *str_; ++str_) { if (*str_ == '{') { std::pair&lt;const TCHAR *, bool&gt; ret_ = detail::in_bounds(str_ + 1, num_args_); if (!ret_.second) return false; str_ = ret_.first; } } return true; } int main() { static_assert(args_in_bounds("Test{0}{2}", 2), "Error"); } However, intellisense correctly gives the red underline.
The only time I think this would be good for beginners is if they have a weak PC, such as a laptop which they take to class. Other than that, a proper IDE like Visual Studio would be very useful, due to the underlining of mistakes making it easier for them to see where their errors are. To add, it is better to get used to the professional tools at the start so that when you do get to higher levels of programming, the user would already be used to it.
A simple implementation would be something like this - struct Index1; struct Index2; //...etc typedef std::unordered_map&lt;Index1, Node*&gt; Map1; typedef std::unordered_map&lt;Index2, Node*&gt; Map2; //etc. struct Node { Node* prev, *next; Map1::iterator m1Iter; Map2::iterator m2Iter; ///etc. }; struct HackedMultiIndex { Node* nodeListHead; //just maintain a doubly linked list somehow. You could use std::list here but I hate std::list Map1 map1; Map2 map2; }; When you insert a node, just add the actual data to all the maps. From each map you can get the node to get any other piece of data. It's easy also to throw any other data structure in here, doesn't have to be std::unordered_map. This solution isn't too efficient, but works for basic multi-indexing needs. In general now instead of trying to solve this problem with a single container, I've found it's usually easier and more elegant to solve this with intrusive data structures, which can very easily be added to multiple data structures simultaneously, at the price of needing to be explicit in your coding.
the sections on [manual simulation](http://www.boost.org/doc/libs/1_62_0/libs/multi_index/doc/performance.html#simulation) and [spatial efficiency](http://www.boost.org/doc/libs/1_62_0/libs/multi_index/doc/performance.html#spatial_efficiency) are as close as you will get to an explanation how it works.
I take part in a lot of programming contests as a sort of hobby on sites like codeforces.com etc. C++ is pretty much the ideal language for programming contests because it is fast as fuck, has a great standard library and is not too verbose.
If it's not "pure", it must be "leaky". Whatever those words mean.
Type-erased concepts are often called "virtual concepts". Andy Prowl is working on a very in-depth analysis of how they might work: see [here](https://github.com/andyprowl/virtual-concepts).
Because it is elegant and costs nothing.
Hum. If I understand correctly: * There are all sort of pointer tables ( similar to vtable ) that are generated, but it's less obvious to the programmer what they will contain. * The object still need to be dynamically allocated ( obviously ) - but the allocation is completely hidden away, which isn't very "c++y" to me. * Inheritance is already a type of runtime 'concept' ( in that it defines a set of requirements ) * The fact that concepts are implicit is great at compile time but at runtime... not so sure. It's not because a class has a method `foo` that I meant for it to be used in a place that takes a virtual concept having that requirement. In other word, I don't think having a certain set of method signatures is enough to determine what is a valid user of a class. Given a virtual concept Foo, What is Foo* ? Foo&amp; ? Foo. How many indirection are there between the instance of foo and the actual underlying object? Is it on the stack on the heap, optimized away somehow ? How would the feature impact size binary, etc. My point is, I have the feeling it messes with the relatively simple memory model of C++. Probably with a lot of edges cases and caveat that could hurt the readability and teachability. Do I miss something ? 
&gt; There are all sort of pointer tables ( similar to vtable ) that are generated, but it's less obvious to the programmer what they will contain. Do you need to know though? Already, knowing about vtables is kind of advanced and a detail of implementation... I tend to not think about vtables when I'm programming. &gt; The object still need to be dynamically allocated ( obviously ) - but the allocation is completely hidden away, which isn't very "c++y" to me. That feels extremely like modern C++ to me: hiding memory management has been a goal for a while (from make_unique instead of new to PIMPL). std::vector hides memory management, std::function (which is closer to what we are speaking) does too. &gt; Inheritance is already a type of runtime 'concept' ( in that it defines a set of requirements ) I kind of wish Concepts where an evolution of "interface", but it looks like we are headed towards having two notions: one for runtime polymorphism (virtual methods, inheritance) and one for compile time polymorphism (concepts). Having virtual concepts means I can deprecate a lot of the uses of virtual methods and do polymorphism the same for runtime and compile time. &gt; I don't think having a certain set of method signatures is enough to determine what is a valid user of a class. That's an interesting point. Can you elaborate? It certainly feels like we do that a lot with templates. Iterators are a good example of a somewhat complicated interface without requiring inheritance. I think the fact that we are speaking runtime polymorphism vs compile time polymorphism is somewhat irrelevant here. Maybe we need a better way to declare "I intend for this class to implement this concept". With interfaces, you subclass, with concepts, you don't say anything... Is that kind of where you are getting at? &gt; Given a virtual concept Foo, What is Foo* ? Foo&amp; ? Foo Replace Foo with std::function. std::function&lt;void()&gt; is basically a virtual concept equivalent to the interface struct Function { virtual void call() = 0; }; What is std::function&lt;void()&gt;*? std::function&lt;void()&gt;&amp;? std::function&lt;void()&gt;? I guess they are what you think (a pointer, a reference or a value type that represent an object that can be called). &gt; Is it on the stack on the heap I hope that we could get a small size optimization (similar to how std::function works) such that small objects can be stack allocated. &gt; it messes with the relatively simple memory model of C++. Probably with a lot of edges cases and caveat that could hurt the readability and teachability. Do you feel like std::function is harder to teach than unique_ptr&lt;ICallable&gt;? I certainly feel like std::function is easier to read and understand. There might be a reason why type erasure for lambdas works better than type erasure for other concepts, but I'm not sure I'm seeing it.
My comp sci program has a senior level compiler class. I'll have to look into taking it. Don't think it's offered next quarter unfortunately. 
&gt;Scientific computing That sounds pretty interesting? What sort?
No filesystem.
Summarily, whatever you can access from a namespace-scoped function without needing to pass as an argument is what you can access from a lambda without capturing; and if it would be a member function instead of namespace-scoped, capture `this`. This isn't revelatory, and lambdas are _not_ "magical".
The g() function serves no purpose, AFAICT, since references are never allowed to bind to a nullptr address.
"Without the static keyword, the compiler isn't bound to set the value at compilation, and could decide to set it later." Citation please? Are you assuming that the definition is inside a function body?
For someone new to c++ having a web framework with a DSL makes it a bit more complicated to learn. But I am sure what you did has its advantages.
Yeah..intrusive containers is what came to my mind immediately when I saw this. But thats another one heck of an implementation :). But luckily, I kind of know how that works to some extent.
Robert, The way this is currently worded, it's out of scope for r/cpp. We got reports and one of the other mods removed it. Contact me or the mods if you'd like to discuss (I'm sure r/cpp would be interested in a post about safe int, etc if it's framed correctly). - Bryce
http://cegui.org.uk/
fixed.
If your course said "for runtime polymorphism, C++ uses vtables, like so", it presumed *way* too much. Standard says nothing about vtables. tl;dr "a detail of implementation".
I'm not sure. I asked a similar question on stackoverflow a long time ago, it was about `dynamic_cast` not getting optimized as I expected. http://stackoverflow.com/questions/38035722/what-is-the-meaning-of-dynamic-castt My impression is that anything that potentially involves runtime type information is just not going to get optimized like you expect. In many cases it will be complicated and depend on whole program information -- all the possible things that could derive from the type, not just what is visible in this compilation unit -- and it's just not low hanging fruit for the optimizer so they don't put much effort into it. My impression is, if you really want maximum performance on all compilers you should probably avoid exceptions and RTTI when you don't really need them. If you use things like `variant`, compile-time polymorphism, etc., instead in such cases, it will all be transparent to the compiler and not require link time information to fully reason about. (I'm not an expert on compilers.) Admittedly in your case when you are throwing `int` the RTTI thing shouldn't be an issue. However, almost no one actually does that in real code, and I'm pretty sure the people who work on compilers are aware of that. I would expect that no one puts special effort into optimizing `throw 0;` versus throwing something derived from `std::exception`.
also no &lt;memory_resource&gt; or &lt;execution&gt;
I think having a way to have an allocator stamped on the virtual concept wouldn't hurt indeed. I'm not entirely sold on the syntax proposed [here](https://github.com/andyprowl/virtual-concepts/blob/master/draft/Dynamic%20Generic%20Programming%20with%20Virtual%20Concepts.pdf). I think having something closer to std::function might be desirable. If instead of "virtual Foo", you had "std::type_erased&lt;T, Allocator = std::allocator&lt;T&gt;&gt;" (maybe with an extra parameter for the size of the small buffer if the class do small object optimization), that would allow to control how the memory is allocated while still removing the burden to worry about memory allocation and resource management from the developer.
Thanks. I assumed incorrectly that a lambda of the form `[](){ ... }` behaved the same as `[=](){ ... }`.
It does still buy you something. The compiler must assume non-noexcept function with a definition in another TU has multiple potential exit points. This assumed potential thread divergence can affect code gen (vectorization in particular).
aos_view allows you to fake an array of objects, whose members can be either: * a reference to an element of an other array. * the result of a lambda function: [] (int i) { return ... } * a method: [] (int i, method_args...) { return ... } It is copy-less, only references to the original data are involved. array_view does a similar job but to fake a simple array: std::vector&lt;int&gt; A = {1,2,3,4}; auto v = array_view(A.size(), [&amp;] (int i) { return A[i] * 2; }); for (int i = 0; i &lt; int(v.size()); i++) assert(v[i] == (i+1) * 2); 
It is definitely a worthwhile class to determine whether you have interest, though I've yet to see a candidate come in with a compiler class that was all that applicable. I'll note that Recent College Grads are much easier to hire with less/little compiler experience though.
It is for developer who can not use Boost. Unfortunately it appears to me that a lot of devs who use Boost can not imagine why someone can not use it. 
Your post has been automatically removed because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/5evcbt/i_am_doing_cpp_for_9_years_i_suck_at_interviews/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Story Time: We were hiring a senior engineer and weren't sure about two candidates. One of the guys said he didn't know C++11/14. Another one of the guys showed us a game and media app he wrote in his free time that used some C++11 features. We ended up hiring him. Conclusions: Yes, you need to show some C++11/14. The best way to do it is through projects where you use the features.
Yes, I know it from python, but it's nice if range-v3 implements it too. I would say that aos_view is differ from zip the same way named parameter differ from c++ parameters. Accessing tuples with an index is much more error prone than accessing an object with a member name : std::get&lt;1&gt;(v[0]) vs std::get&lt;0&gt;(v[0]) v[0].name vs v[0].city 
Looks like they only went for stuff you can easily implement using only standard C++.
Because exceptions 
Not even with -flto ?
A compiler could optimize the example you posted, but not while adhering to the rules of the Itanium ABI (which you really want to stick to if you want compilers to play nicely together). The Itanium ABI (http://mentorembedded.github.io/cxx-abi/abi-eh.html) describes the external functions that are called as part of the exception handling process. If I want to, I can choose not to link libc++/libstdc++ and provide my own implementations for these functions. Given this fact, the compiler cannot assume that _cxa_allocate_exception/_cxa_throw have no side effects, and so also cannot assume that they can be optimized out.
The author might have revealed his age.
&gt; which is a library call, which can't be optimised. Why can't it be optimized? (There's no rule that library calls can't be optimized -- and in fact they commonly are). 
As I understand it there are a few things that use caught exceptions to abort recursive cases, like some JSON parsers. You could imagine that after a little inlining/optimization, you could end up with transformed code that includes a couple guaranteed exceptions.
Seems to me like this only applies to the ordered containers, not the unordered ones: http://en.cppreference.com/w/cpp/container/unordered_map/find. Are you sure this applies to `unordered_map` ? Is there a plan to make this apply to unordered_containers? It doesn't seem that way.
Whilst the claim that a call to a library function cannot be optimized isn't 100% true, it's also not totally off base. A function can be optimized out only if doing so won't change observable behaviour. We can do that to functions in the same translation unit because we can reason about them. We can also do it to functions that the compiler knows are pure functions. But we cannot do it in the general case, and we definitely can't do it in this case because the compiler has no idea what `__cxa_throw` or the other functions actually do until we link the implementations in.
I'd recommend also asking this on SO. That's bizarre.
I think you can just put the attribute as a declaration by itself in the beginning of your TU. There are no attributes currently usable as such with which to demonstrate. Turning off warnings about known attributes, though, I can drop the following pretty much anywhere: [[foo]];
Exactly. So ... what does aos_view bring to the table? A composite iterator shouldn't be that much of a thing to do, and while it would be nice to have it in the standard, is not a deal-breaker if it isnt. &gt; to enable programmers in performance constrained domains to use the Structures of Arrays data layout while getting the nice syntax of an array of structures. And here is where it fails, since it forces me to use array.a, array.b while referencing the A or the B arrays. Why would I do that versus just using the arrays directly? If it would provide a nice and simple view of those 2 arrays, without forcing me to think about which ones do I need it could prove useful. As it is ... it's more of a meh ... who cares?
This is an attribute applied to the null statement. An example of that already in the standard (almost) is `[[fallthrough]];`. The thing about the null statement is that it's classified as a declaration, so it also works outside of function bodies. In fact, that's why the compiler doesn't error out on `void foo() {};`. If there's something special about an attribute on a null statement at file scope, then I haven't heard about it.
It allows you to do array[0].a array[0].b instead of soa.a[0] soa.b[0] or worse if you would use tuples.
The use case of the idea is intentionally narrow like this, if the programmer wanted to use a variable holding a value of the enum, I would suggest defining an enum as usual.
From the start, I was already aware of the very limited use cases, but I still went ahead and posted this because I didn't see any drawbacks, so improvement is still an improvement.
And wouldn't you agree that allowing me to do array[0] (picks from A) and array[5] (picks from B) would much more useful? As it stands the usefulness is debatable. 
If a TS is published but not part of C++17 does that mean I will need an extra switch to enable it besides -std=c++17 ? Does it have any other importance?
For example, to use concept in GCC 6.0+ you also need "-fconcept".
The other implication is that the feature may undergo breaking changes between the TS version and its final standardized version. So, for example, Concepts as standardized in C++20 (assuming that will happen) may not be 100% backwards compatible with the Concepts TS.
This is good to know, thanks for the info.
HI Duheee, Thanks for your idea. Here is a usecase that will help you to understand where aos_view is pretty useful: Let's say you write an open source library that will be used by lots of differents programmers. Let take for example plot_rgb_points that plot a list of RGB pixels. For this, you need a list of x/y coordinates, and a list of rgb colors. One way do implement such an API in classic C++ would be: struct point2d { int x,y; }; struct rgb { int r,g,b; }; plot_rgb_points(const std::vector&lt;point2d&gt;&amp; points, const std::vector&lt;rgb&gt;&amp; colors); This has one drawbacks. If Bob, a user of the plot_rgb_points library has to create std::vector&lt;point2d&gt; and std::vector&lt;rgb&gt;, involving more code, and expensive data copies. With aos_view, you can rewrite a plot_rgb_points function that will let Bob call it in just one C++ statement, for exemple: plot_rgb_points(_x = [] (int i) { return my_coordinates[i][0]; }, _y = [] (int i) { return my_coordinates[i][0]; }, _r = my_red_buffer, _g = my_green_buffer, _b = my_blue_buffer)); No copy needed involved here, and the compiler is able to generate a plot_rgb_points function that is better optimized for Bob's data. At the end, Bob has less code to write, and its program spend less time executing the plot_rgb_points function. Pretty useful no? The concatenated array view you propose serves different usecases and is also a nice idea. I'll keep this in mind and add it whenever I need it. 
&gt; there were objections to naming the type “byte”, on the basis that there is a lot of existing code out there that uses this name It's in namespace std, so what's the problem? I don't think anyone serious created byte in that namespace or wrote "using namespace std;". 
Touché! :) Actually I imagine if you make use of Python's functional packages, maybe it is possible to reduce it to a single line.
I can only imagine how many codebases have `#define byte unsigned char` in them. [In fact...](https://github.com/search?utf8=%E2%9C%93&amp;q=%22%23define+byte+unsigned+char%22&amp;type=Code&amp;ref=searchresults)
Speaking for myself I was doing this on MS-DOS, so I can sympathise with the committee not wanting to break everyone's code.
To be fair, C didn't get `true` or `false` until C99, and even now, they're macros for 1 and 0 in `stdbool.h`.
This seems more like a use case for a pragma to me. Put "#pragma my_attribute" at the top of the file and you are good to go.
Results as expected but still interesting.
It's important to test different sizes. std::map will actually be faster for small maps, the size of which depends on the cost of the hash function. 
Why is a pragma here better than an attribute?
Well I'll be damned, that's a lot of projects. But on the other hand, if so many of them duplicate that definition, it seems to me it should be handled in one place - in the C++ library itself.
&gt; The proliferation of concept definition syntaxes. The “abbreviated function template” notation (where you get to write a function template that looks like a non-template function, using concept names in place of type names) in particular seems to be somewhat controversial. Allowing this syntax was one of the reasons the proposed merger of the Concepts TS into C++17 was rejected (the other major reason being insufficient implementation and use experience). Based on my conversations with other committee members, I get the impression that this objection is likely to persist the next time Concepts comes up for a vote While I believe there are indeed more way to define and use a concept than required ( haha ), I don't think, that in this instance, the "abbreviated function template" notation would undermine the semantic or readability of the program. I believe this syntax was something Bjarne have wanted for the long time, and the current complexity of the template-related syntaxes come, in part, from FUD. The compiler have full information, there are no ambiguities possible ( 14/5 ), the developer should only care that the function argument is of the parameter type, not about the nature of either the argument or the parameter. And, if for some reason one wishes to still differentiate templates from concrete types, the tooling could provide that information ( say, by the mean of coloration in an IDE). Maybe it could be useful to enforce that a particular type enforce a set of concepts, but I don't really see a need in differentiating template and non-template parameters in function declaration. 
Depends on the compiler. GCC doing this: https://godbolt.org/g/mJitZg
Both are using caching, but not in the same way. ccache is only helpful if you recompile a file without changes. zapcc caches internal compiler data structures inside the compiler. If two files are using the same structure, zapcc can help you but ccache does not. (I don't have anything against ccache, it's a great tool ;) )
Performance simulation and analysis in the aerospace/defense industry.
It's where they take race and gender into hiring consideration So a form of both racism and sexism Modern discrimination at its finest
Nothing.. I love Python.
Which is a shame because Java is horrible for desktop apps EDIT: But maybe it could also be because the C++ and the Qt community don't talk to each other as much as they should and/or Qt coders don't use Reddit much -- /r/qt5 being almost dead is an example of that.
My main concert with using something like this would be correctness -- with all the caching how do I know that the compiler is not re-using outdated state?
&gt; all modern platforms use zero-overhead exceptions (table-based unwinding) Except x86 Windows. (Even though the operating system uses amd64 nowadays most of the time, users are running a lot of stuff on WOW64 still.... :) )
&gt; when you are throwing `int` the RTTI thing shouldn't be an issue It will be an issue on all platforms that use the Itanium ABI since they power their exceptions with RTTI. It won't ever be an issue on MSVC++ because our exceptions are never powered by RTTI. (That said I don't think RTTI is the expensive thing here) 
A 1.3x speedup is good enough for a proof of concept, but I'm not entirely sure I'd trust it to produce correct code without a lot more information and experience. And it's a commercial product with no listed price, which suggests that it's not going to be cheap.
&gt; there's no "frame setup" overhead that could be removed if the compiler is convinced it won't be needed. There may be no runtime overhead, but there's still code size overhead because the compiler has to generate code to allow the stack to be unwound (destroying local variables, etc.) in the event that a method call throws an exception.
I get the impression that what you really want is tag dispatch: http://www.generic-programming.org/languages/cpp/techniques.php#tag_dispatching
The guys working on it are great and did two cool presentations at CppCon, but it still isn't up to C++/CX in terms of tooling support. I can only advise it to our customers when XAML, Blend and creation of UWP controls for .NET consumption reaches feature parity with C++/CX. 
One would hope that a commercial product has been extensively tested with professional test suites.
On the same system using Win10. Intel 17.0: * time for std::map: 0.840789 seconds * time for std::unordered_map: **0.06557 seconds** * time for spp::sparse_hash_map: 0.0672506 seconds GCC 7.0: * time for std::map: 0.914142 seconds * time for std::unordered_map: 0.0740962 seconds * time for spp::sparse_hash_map: **0.0440542 seconds** Clang 4.0: * time for std::map: 1.0707 seconds * time for std::unordered_map: 0.0733637 seconds * time for spp::sparse_hash_map: **0.0683782 seconds** VS 2015: * time for std::map: 0.99013 seconds * time for std::unordered_map: 0.0850722 seconds * time for spp::sparse_hash_map: **0.0563417 seconds** 
&gt; BTW I assure you I am not Stephan Lavavej. Right, that's /u/STL, primary moderator of this subreddit. ;-]
Yes.
I prefer the bare-bone [MinGW-w64](https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/) distro which is actually used by the Nuwen - but Nuwen is awesome if you want boost and other stuff bundled and ready to go!
/u/STL the super hero of the modern age.
I found that his version produced binaries that are incredibly slow for unknown reasons. Plus it's rather lacking in available libraries and tools. Msys2 and mingw-w64 are okay. 
Actually, I'm intermediate seniority (mods are listed in order, most senior at the top) with an intermediate level of mod activity. I should update the distro this weekend or the next instead of playing Diablo 3.
msys2 is **awesome** as well. It's the most complete (and at the same time most slim) distro ever, not the least because it has a great package manager (pacman). It's at least equally good as STL's MinGW :-) But nevertheless thanks for your awesome work STL!
I couldn't agree more haha! Let them suffer. They deserve no better. ;-)
I asked you about it once like a year ago. Never did figure out why, but binaries produced by your version were orders of magnitude slower than those produced by other Windows ports of the same version of gcc using the same optimization flags (including -march).
I use MSYS2 to bootstrap the distro. It's way better than mingw.org's MSYS. The only thing that annoys me about MSYS2 is recorded in my [Issue#20](https://github.com/StephanTLavavej/mingw-distro/issues/20).
The question is: why should compilers spend resources to optimize this when they get better code improvements at other places? You have shown a trivial case where you are throwing an `int` in a function with no local variables. Nobody throws `int`s in real code. And if you throw real objects in functions with real stack frames instead, matters get really complicated really fast. If you avoid going through the runtime library, you'd risk that your optimized code behaves differently, for example, because of the exception object being copied a different number of times. You'd have to make sure that if you're destroying an object on your way to the `catch` block, `std::uncaught_exception` gives the right answer. You'd have to make sure that within your `catch` block, `throw;` does the right thing. All in all, it's quite a lot to be done for an optimisation that is applicable only very rarely.
 * sizeof(std::map) 16 * sizeof(std::unordered_map) 64 * sizeof(spp::sparse_hash_map) 88 | | size bytes | peak size | alloc count | free count | :----------------------|:----------|:----------|:---------|:---------| | std::map | 400_000_000 | 400_000_000 | 10_000_000 | 0 | std::unordered_map | 508_435_367 | 603_979_750 | 10_000_017 | 17 | spp::sparse_hash_map | 105_165_800 | 105_166_040 | 11_715_044 | 11_402_544
Or you could just use one of the actor model implementations and skip the stage of learning co-routines then thinking 'wouldn't it be nice if classes were co-routines' and go with OOP as it was always meant to be :)
Heh, funny. Not what I meant by size. I meant test different element counts.
Is the standard library fully feature complete? Last time I checked &lt;thread&gt;s weren't available of Windows because of philosophical reasons.
No the same person but horizontal scroll bar appeared in me as well, but I realized that in my browser %125 zoom was enabled. Scrollbar disappears when I switch to %100. Maybe /u/joebaf has the same thing
Keep in mind this search is case-insensitive. Many of them use `BYTE`.
you've never been on a large c project, have you?
one would hope that. having worked on a number of them, that hope is often unfounded, although one would hope a compiler company would be extra careful.
True. Templates are a joke. Wonder if anyone has tried to compile clang.
It's based on Clang which has a fair amount of functional test cases. I hope it passe them all. But, I do agree, the business model makes it not really interesting. And modules should produce a lot more speed up ( once the STL and others widely used large library adopt the TS ). 
Computer graphics and image processing.
Concerns about correctness are valid. I just don't see what caching has to do with it. Other compilers cache things too, just not as much.
Why not use an enum for the category instead of strings? 
That doesn't generate windows binaries (by default) and doesn't work with not-windows-10. You still need to install a cross compiler and deal with the issues of cross compiling.
&gt; Templates are a joke. There are so many reasons you're wrong, I don't even know where to start.
(•_•) Sounds like you need a response... ( •_•)&gt;⌐■-■ (⌐■_■) *template* 
They all started fast until they tried to add optimization and more workaround and correctness and cross platformness.
I use STL's MinGW distro on Windows for Competitive Programming (Windows since I love using Far Manager), and I can tell you, it's a beauty to work with!
Because Windows. That's why.
It's not just me? Yay, I'm not going insane. 
Diablo 2 is better game.
TS?
[Technical Specification](http://en.cppreference.com/w/cpp/experimental)
I've been using &lt;future&gt; with no issues... What are the actual threats of using the POSIX wrappers? 
works fine on my mobile (Lumia), horizontal bar appears on Desktop: Edge, Chrome, Firefox - 100% zoom in all browsers set, Windows 10
Not always. There are valid C constructs that are not valid C++ constructs, and although most C++ compilers tends to include them as extensions, this is not always the case and you can construct code that will compile on gcc but not g++.
Hehe! `update-core` is gone by the way since a few months. I don't really mind closing the shell, as it happens only every few weeks or couple of months that the distro gets updated and the shell needs to be restarted. But I can see how it can annoy somebody.
Please tell us what is so funny about them. 
FWIW, it's guaranteed to be allowed in C++1_7_; N4606 §23.3.11.1/3 ([vector.overview]/3): &gt; An incomplete type `T` may be used when instantiating `vector` if the allocator satisfies the allocator completeness requirements 17.6.3.5.1 ([allocator.requirements.completeness]). `T` shall be complete before any member of the resulting specialization of `vector` is referenced. Similar wording is present for `forward_list` and `list`.
When comparing O(log N) with O(1) the results obviously depend on N and the cost of hashing. One can have absolutely arbitrary results by picking different container and key sizes, including those where `unordered_map` is instead 10 times slower than `map`. EDIT: O(log N) of course
you mean comparing O(log n) and O(1) probably.
Well Stallman predicted that there would be non-free extensions which sooner or later made the open parts very inferior or not usable. We'll see how it plays out. What do you think?
Am I the only one who has trouble fully understanding what the author is trying to say? He lost me at the table-like list of bools that doesn't seem to map to his previous code snippets.
You can not use "boostorg/variant" and "boostorg/filesystem" without boost it self! So they are unfortunately not standalone. Also boost filesystem need to be build and linked, boost variant is apparently headers only but a lot of them. There are only some rare boost libraries that could be used without it like nowide. Of course boost has one big advantage it is quality and correctness. 
If it was quicker, it could be useful for syntax checking/linting/use in a CI machine. 
I plan to change it to a more liberal license for the first stable release. I still have to choose which one. The GPLv3 was chosen as an interim conservative option. One way to help me choose one of the most liberal licenses is to get your company to join the sponsorship program ;)
So `immer::array` is like `std::vector` and `immer::vector` is like `std::deque`.
Well, it depends on how you look at it. `immer::vector` is very much like Clojure's and Scala's vectors. It is kind of your go-to random-access sequential data structure. It's big-O complexity for immutable operations is also kinda similar to their mutable counterparts of a `std::vector`. The `immer::array` is more similar in its internal representation to a `std::vector`, but all its immutable updates are `O(n)`, which is quite different... I wanted to follow the STL convention of naming containers by their external properties and intended usage instead of their implementing data structures. But I concede that it is weird topic :)
Genuinely interested, as an author why do you pick GPL? As a developer I tend to try and stay as far away from GPL as possible so I'm interested in the reasonings behind why it's used and where my limited understanding is. 
Can you update the site with some use cases ? I have never needed such a library before though I have used serialization and database as per the needs. Where does this fit in ?
There are lots of pragmas that affect an entire TU, or at least affect a TU from the pragma forward (pragma pack, pragma once, pragmas dictating section placement). That's the reason. If there were already an ecosystem of attributes that applied to a whole TU, then it seems like it would be a fine choice. So part of the answer depends on your priorities. Is it more important to you to get something working quickly, or are you interested in pioneering the usage of a small piece of C++?
This is an extension of Clang, which is BSD-licensed &amp;mdash; I doubt Stallman ever considered Clang 'free' to begin with.
relicensing is "fun". if you ever accept any contribution, you need a written permission from all contributors or you need to remove their code. and people would be hesitant to contribute, knowing well that the license will be changed to something they might not like. currently, you are in a lose-lose state.
The FSF considers BSD/MIT licensed code free software. 
I am not the OP, but here are some good resources for optimization http://agner.org/optimize/ One of the manuals on that site is a table of instructions which allow you to see how long instruction latencies are. Of course the number of cycles a sequence of instructions takes is not just the sum of the latencies because of pipelining, but you can see that vector latencies aren't much higher than scalar latencies, and in many cases are identical. I remember reading that Intel CPUs take some time to power up the vector unit, and power it off after some period of inactivity. I believe this ramp up period is something like 100 cycles. I looked quickly for the exact numbers and didn't find them, but I'm sure it is somewhere in Intel's massive documentation (check out their software optimization guide). Another very useful thing to optimize once you have the cache under control is reducing branch predictions. Example: I got good speed up doing a linear search where previously there was binary search because the arrays were very small and binary search clearly will have unpredictable branches assuming the distribution of your accesses is roughly uniform. The branch miss penalty is something like ~15-20 cycles. A lot of work can be done in that amount of time with how efficient current pipelines are.
It's much better since the modularization effort &amp;ndash; now most libraries only depend on themselves and Boost.Core, and Boost.Core is trimmer than one might expect. The real remaining problem with bcp is that it brings in everything ever possibly included, even if the inclusion is in an `#if`/`#ifdef` that never applies to you (e.g. for different platforms, or different C++ versions than you're targeting, esp. C++03 boilerplate that disappears with variadic templates and/or rvalue refs).
Boost is modular, and all libraries (except Hana AFAIK) depend on Boost.Core. So, no, not standalone, but Core+Variant or Core+System+Filesystem are still considerably smaller than Boost in its entirety.
GIS applications. ~50% shared C++ code for rendering, networking etc., the rest in Java, C#, Objective C for the target platforms, but hoping to move more business logic into C++.
The signedness is a bit orthogonal. The question was - why use `long` (which differs in size among major OSes) instead of something like `ssize_t`(which for some reason exist only in POSIX standard).
I think you're almost right here. I expected that a temporary would last at *least* long enough for the entire expression to be evaluated, and indeed this appears to be the case with no optimization. The temporary `binary_transformed` object of the first `operator+` lives long enough to not leave a dangling reference. But what *seems* to happen is that when optimization is enabled, only the base class (e.g. a `reference_holder` with a dangling reference) is constructed instead of a full-blown `binary_transformed` object. If I try to prevent the `binary_transformed` object ctor from being optimized away (for example by adding a simple `printf` stmt in it) then indeed the bug vanishes. Or alternatively, if I create an `operator+` that takes a `binary_transformed` object instead of a `reference_holder` then again it seems that the ctor cannot be optimized away to leave a dangling pointer. I'm not sure, could this be a bug in the compiler (seems to be the case with clang as well)? Or do I have bad expectations about temporaries?
`reference_holder` seems to be duplicating the functionality of [`std::reference_wrapper`](http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper/reference_wrapper), which solves the problem you are talking about by deleting the constructor that accepts rvalues. OP should probably use that, since GCC 6.1 has it
But actually I want something like `std::reference_wrapper` that keeps rvalues "alive". Otherwise I can't evaluate expressions like `auto bad = bar + bar + bar;` at least with my current scheme.
The only way to keep an rvalue alive is to bind it to a local reference or to give it storage.
Seems like you know the fundamentals of C++, why not try working on an open source project based in C++? This will help further your experience with the language and you'll learn more within the community about applications written in C++.
Such questions are off-topic for this subreddit, please see the sidebar. This should work, and my brain-compiler says it will be accepted by VS 2015. What error are you seeing?
Not OP, but I like GPL because I want people who use code I make available to have to return any changes or improvements to the community, in order to improve things for everyone (all 2 or 3 of them) who use it. (I wish I was better at coming up with ideas for useful potentially popular projects). 
Yes, that is something that should come free with the data-structure being immutable. I was more interested in knowing how exactly is being used and to solve what kind of problem.
Can somebody please present me with a use-case where immer::array would be preferable over std::array with custom manipulator functions (like `std::array&lt;T,N+1&gt; push_back(const std::array&lt;T,N&gt;&amp;, T&amp;&amp;)`)? I.e. why would the type need preserving if it's only going to be initialized?
Not really. On this very beefy desktop machine it takes 3 seconds to compile without optimisation and 15 seconds with optimisation enabled.
**Company**: TomTom [Career page](http://www.tomtom.com/careers) **Type**: full-time **Description**: Realize innovative in-car navigation solutions by porting TomTom's in-car navigation suite to different automotive platforms: QNX, Linux, AOSP, Tizen. Also make it collaborate with other in-dash components like the heads-up display, entertainment- and Bluetooth system. **Location**: Eindhoven, the Netherlands. (English spoken) **Remote**: No, only on-site **Visa Sponsorship**: Yes, we sponsor visas **Technologies**: C++98/03, C++11, knowledge of different OS's is a plus: Linux, Tizen, QNX, Android, WinCE **Contact**: daan.smit@tomtom.com 
From my experience, unless you have ideological principles on the matter, prefer BSD or similar since that would allow wider adoption and more contributions (some of which may lead to sponsorships). Many companies using open source libraries do in fact contribute back PRs, fixes, features etc. without the need to open up their own code. GPL is often a major turnoff for devs looking for available quality open source solutions. Your lib might not get more than a cursory look, let alone a serious consideration or evaluation. 
So to bring this into modern day, and less of a newbie question, I'm going to go a little meta. When you ask, "is there any flaw in my program?", I'm going to ask: "why do you not know what your program is doing?" You have a bunch of things that your program is supposed to do, right? Well then. Write some code that actually does those things and ensures the output is what you expected. TL;DR: write some tests.
Depending on what your college taught you, you might want to pick up modern C++ (C++11/14/17) before writing any big new project. See e.g., cppreference.com (which marks which part are 11, 14, or 17).
`slice` is just one of the many algorithms/operations that can be done on a tuple. Libraries like `hana` implements almost all of those algorithms as one can find in a functional programming language like haskell. I am not sure which is the right way to put forward such proposals, one by one or as a complete pack ?
Also check out my lightning talk video with a quick demo: https://www.youtube.com/watch?v=zoSGHMi-0lE
Depends, almost all algorithmic facilities have had amendments since C++14 so somewhere someone proposed them (some of them probably in isolation) and new facilities have been added to existing ecosystems (eg http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique to the existing unique pointer). Code doesn't need to reach a critical mass to be proposed, the question is not one of organization but usefulness ... so to go full circle : "Want a slice?"
I prefer library that can be used in header-only mode. Something like FMT_HEADER_ONLY in https://github.com/fmtlib/fmt but done a bit better. Also why people use *.cc for C++ files ? Why not *.cpp ? Of course it is better as *.c++ that is not recognized by any tool that I know. 
Unfortunately not possible. As I mentioned the positions require the ability to obtain a security clearance. One of the prerequisites to apply for a clearance is having U.S. citizenship.
The purpose of a library is to provide some pre-canned code for another developer to use so they don't have to develop it themselves. If your build system causes friction, people may go elsewhere, it depends how many options there are and how good your library is. The goal should always be to minimise that friction, IMO. There is a hierarchy, and header-only is typical at the top. Just below that is source-only. Once you go beyond that, to requiring scripts or libs or *shudder* build systems like CMake/etc, you're just putting a filter on who will pick up your library. Something like [dear ImGui](https://github.com/ocornut/imgui) is a good example of a happy middleground IMO. That library doesn't try to cram everything into a single header, but equally doesn't resort to &lt;insert-developers-pet-build-system-of-choice-here&gt;. My personal preference is for a source-dump with perhaps a master.cpp (that just #includes all your .cpps) and master.h which you can use to kickstart usage. Include the master.cpp in a single .cpp of your project, use the master.h wherever you need to interact with the library - this gets you 90% of the way for bare minimum effort. If you find later that including master.h is too heavyweight for your TUs, just include what you need. If you want to make a separate lib and link that in, you can do that too. Flexibility is key and helps the user.
 The polymorphic allocator stuff (`std::pmr::vector` etc) from `&lt;memory_resource&gt;` would be nice to have, but I'm not aware of any standalone implementation which I could "borrow". I think the use-case is a little more niche than the other headers which are included. Likewise, `&lt;execution&gt;` seems a little pointless without the full parallel STL.
last time I tried to use rangesv3 the compile times were *insane*, I think they're probably waiting on modules/concepts.
For small libraries I really prefer header-only. If this is something that will solve one simple problem inside my program, I don't want to build the library and then link to it. There is also the advantage of versioning with header-only library, you simply pack the headers in the application. 
&gt; never been on a large c project, have According to the documentation, there won't be any speedup for C projects, but it will work as long as clang is able to compile your code. 
It depends on the size of the library and the compilation time of the project. Libraries like Boost Spirit makes you rethink before changing one line in a file that is affected by the parser.
This makes me wonder if something like python's enumerate exists... I could probably 100% eliminate classic for-loops in favor of range based for-loops if that existed. edit: enumerate expands a list `[x, y, z]` to `[(x,1), (y,2), (z,3)]`
Please have a look at [this page](https://github.com/nothings/single_file_libs), which gives a list of 1-file (a header) or 2-file (a header plus a .c/.cpp file) libraries. If your library doesn't depend on external libraries and fit ~1000 lines of code, my preference would be to make a 2-file library by combining files together. When someone else want to use your library, they just copy the two files into their source code tree without installation. A 1000-line .cpp file is not too bad to read if you clearly separate different parts with comments. Compiling 1000 lines of code does not take much time, either. I would not recommend this approach if your library has &gt;10,000 lines of code. Actually when you library is that big, header-only libraries are usually not a good fit, either, as doing that may greatly increase compilation time.
I'm developing a header-only library, so I have a hard-requirement on any of my dependencies to be header-only as well. Maybe it is kind of side-stepping a C++ build system issue, but if you want to build on Win, Mac, Linux, Android and iOS, it's just ingenious to have only header-only libraries :-)
Just to clarify a common misconception: The GPL only requires source code to be available to those to whom you distribute the binaries coming from that source code. Making the source available on a web site is one common way to do this, but not the only one. If you sell your software, you can also make a link available to only the people to whom you sold the software. If you never distribute the binaries, there is absolutely no need to publish the source code. Of course, once someone has legally obtained a copy of the binaries, they can a) demand the source from the person from whom they got the binaries and b) distribute both under the GPL to third parties.
Thats really interesting, thanks. I generally use tldrlegal to see what I can and can't do but it doesn't provide much depth (obviously)
It is pretty common for library part of the project to be more permissive (like LGPL) and executable part to be strict GPL.
In the future if you have things that only with certain compiler flags, try [UndefinedBehaviorSanitizer (a.k.a. ubsan)](http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) and [AddressSanitizer (a.k.a. asan)](http://clang.llvm.org/docs/AddressSanitizer.html). IIRC both are also available for GCC with the same flags (for activation, not further configuration).
&gt; Striving for header-only is the direct result of the pathetic build systems we use in C++ today. Not only. With generic code, you often find that almost all the code *must* be in headers anyways (they are templates), and there is literally nothing to put into a .cpp file. 
Scary, but understandable I guess. Do you know of anywhere maybe more akin to a forum or message board that puts-up with and/or focuses on those repetitive, beginner Q&amp;As?
This is a fantastic summary; well-organized and with an appropriate level of detail!
At the end of the day, compiler time is way cheaper than programmer time. All I meant was that compiling C is faster. It's only a statement of fact, not and indication of "C is better hurr durr" stance. High level languages aren't free. Their high level makes you more productive. You pay for that with some cheap sweet CPU time. Big deal.
I like simple static libraries. I love libraries that are nothing but a bunch of plain-vanilla source files you can drop straight into your project without having to muck around with any special build process. Putting the entire implementation into the header file...? That's just nutty. Why take it to such an extreme? Why make the compiler run through the entire body of the implementation every time some other part of the project needs to #include its interface?
It's always everyone else who should change, so obviously no-one ever changes. You have about as much chance with this as you do of getting the world to agree precisely how to indent their code. 
Also look into Google's flatbuffers
http://i.imgur.com/SsbX9yC.gif
I still can't tell you anything without the error you're seeing.
Unless it's popular enough to make it into a variety of package managers and you can tell users to just install it with pacman, apt, etc., header only is certainly easier to distribute.
Hey, as long as those synergies are being levergaed in a dynamic, social way that inexplicably involves VR for no apparent reason, I am on board!
I think it depends. Many time I do not care about the underlining implementation. With templates, I cannot think of a way to escape header only portions of your interface and separate interface from implementation. I think look at modules as proposed by Gabriel Dos Reis and implemented by Microsoft and Clang. If I at just using a library, I usually do not care about how the interface does the work as is should. The exception is the case performance matters with both run-time and compile-time performance and with run-time being first importance. I also see the benefit with "normal" static library (*.lib files for Windows and *.a files for Linux) is the bugs is the implementation could be fix without changing user code. Also consider creating Shared library (*.dll files for Windows and *.so files for Linux) for users who might uses this library in several point in their application.
One problem I've seen is that somebody says, "this library is small, therefore being header only is fine," but then it gets used in a very large project, so that small library gets build 10,000x for a full build because it gets included in so many source files. So effectively that small library has the build overhead cost of building a massive 10,000 source file library with every build. Even though it's 'just one file.' Because the author never sees how large the user's projects are, they may never realize the issue with it. So I feel like it's best to err on the side of caution and prefer things not to be only header-only. In my own code, I even do explicit template instantiation to avoid templates being compiled in some of my headers. Not for everything, but it's a pretty neat technique to keep build times sane for some of those things.
Seems like it uses nonconforming gcc/clang extensions throughout the code (like switch ranges).
primary author of cereal here: yell at me if you want. Development has been a little slow lately but we'll be dropping a dependence on boost for unit testing in favor of doctest which will make it much easier to do our cross platform testing and help speed the process up a little.
If it's not header-only, at least make it simple to include as a submodule and set it up so that it just works if I do the following in CMake : add_subdirectory(3rdparty/rpclib) target_link_libraries(my_software PRIVATE rpclib)
I have a find module for cmake, so it can be used like [this](https://github.com/rpclib/rpclib/blob/master/examples/mandelbrot/CMakeLists.txt).
this is mostly useful if rpclib is shipped precompiled as part of a package manager; I'd rather use it from git in order to build it along with my software (so that I can use my build flags, etc.). 
If a library' document claim "header-only" like a feature, it is red flag to me. Because it means either auther does't understand how to use their own toolchain, or its target audience is someone who doesn't understand their own toolchain.
&gt;Why would you bother defaulting copy/move constructors for a pure virtual class? I'm not OP, but isn't that because the move-constructor is implicitly deleted if you default a destructor. And you'll probably want to declare / default a virtual destructor if you're declaring virtual functions.
I'm not an expert, but this is just something I remembered from Jason Turner's presentation at CppCon16: https://youtu.be/uzF4u9KgUWI?t=955 But I guess it doesn't matter if you default move constructors in the base class or in all your derived classes...
Thank you very much! I have to agree with everything you said. The defaulted IBody methods where there to follow the rule of five, but as you correctly pointed out, the class is pure virtual anyways, so we don't need them.
&gt; As a developer I tend to try and stay as far away from GPL As a developer I tend to put everything I work on personnally under Affero GPLv3, because I want my acts to reflect the world I want to live in (i.e. a world without private property of ideas). With permissive licenses I allow other people to build closed gardens more easily, and I want less closed gardens in the world. I am also lucky enough to get paid each month to contribute to a GPL codebase.
&gt; if I use GPL code my whole code becomes GPL. No, the derivative work combining your work and the GPL work is under GPL. You could always strip all the parts where you use a GPL library to replace them with a BSD, MIT, code, or even your homegrown proprietary solution.
A slightly more realistic example which show the same behavior: https://godbolt.org/g/JJUXiF. It gets nicely optimized with "-fno-exceptions". Interestingly in the version with a lambda (https://godbolt.org/g/ZuWMzB) clang actually optimizes out all __cxa* but still doesn't fully optimizes it.
And this is why I prefer not using prebuilt libraries and either use header only libraries or ones that can be integrated easily in my build environment to target whatever OS I want and use my build flags. Nowadays, with tools like the clang sanitizers, it's quite important to rebuild everything. And you don't want to manage many pipelines producing binaries and synchronizing the build flags between them. I even rewrote the Boost build system quickly with CMake to integrate it in my app and get rid of huge binary distributions and tons of different flavor builds. It took me a day to setup and it saved me DAYS of work everytime I wanted to upgrade it.
You may actually not be able to default it in the derived, if the base is not defaulted. So this is a good point.
Flatbuffers are really promising, but very hard to use if you have nesting objects to any depth, or need to mutate strings.
STL and boost are much larger than "couple thousand lines". If you use a significant portion of STL and boost, you would not be concerned with a relatively small header-only library.
I have this vision of being to to just do the following: * git clone myproject * git submodule update * cmake Having a CMake compatible boost would just make my day - then it just becomes another submodule to get and not a dependency I have to have on my system.
Please. Rhetorical questions are for feeders only.
`vector&lt;shared_ptr&lt;Base&gt;&gt;::push_back()` is overloaded to take `const shared_ptr&lt;Base&gt;&amp;` and `shared_ptr&lt;Base&gt;&amp;&amp;`. Calling it with `Derived *` would attempt to construct a temporary `shared_ptr&lt;Base&gt;`, but that's an **implicit** conversion. `shared_ptr&lt;X&gt;`'s constructor from `Y *` (which happens to be templated, which is irrelevant here) is marked `explicit`, forbidding its use to construct such temporary objects implicitly. `emplace_back()` works because it performs the construction explicitly. **HOWEVER, YOUR CODE IS DANGEROUS.** When you say `v.emplace_back(new Whatever)`, if the vector needs to reallocate and can't, it will throw an exception, and your `Whatever` will be leaked, because no `shared_ptr` holding it has been constructed yet. This is a special case of the general rule that every `new` in your source code is likely to be a leak if you aren't very careful.
That's a really good question that I suddenly realize I can't answer adequately. I need to read up on PCH a bit before I feel like I know what I am doing with it. You may have just given me that nudge. It used to be considered a pretty uncommon / unstandardized feature and I still kind of think of it that way. Sounds like the world has moved on around me. If you are dealing with Windows DLL stuff where things are declspec import/export depending on context, and stuff like that, how does PCH handle that sort of thing? 
With MSVC you can't share precompiled headers across projects, so you incur the cost on a per-project basis (but not per-compilation-unit).
Say i want to understand how this works. Should i read it and then write my own version? Or am i better of reading datasheets?
+1 for library name
Hey, thanks for writing a great library :) What does the cereal team think of: - generic serialization based on metaprogramming techniques that offer limited reflection on fields, e.g. using Boost Fusion or Hana - serialization with ranges instead of streams or iterators (e.g. using Range v3 https://github.com/ericniebler/range-v3)
I'll see if I can open source it as it belongs to my employer or just rewrite it from scratch. Note that I didn't build ALL the native modules, just the ones I needed, but there were quite a few. Also, it was quite fast to compile, like 14s on my 4 cores machine. Download the sources once, compile fast for all platforms (I had support for Windows, macOS, Linux, iOS and Android). But basically, you don't really want to have it as a submodule. There are just way too many files and Windows users will hate you. Downloading a zip / tar archive is the way to go. Preferably a slimmed down version without docs and that other file with unicode characters in its name that usually fails to extract :P The interesting thing was that it didn't require any update at all when upgrading the boost version. They didn't change the file list at all in the compiled libraries I used, so it always was a smooth transition!
Macros and compiler flags.
Oh... Unity builds. Thanks for clarifying!
I prefer modules.
No. `new` is dangerous.
Is there a way to specify a custom format instead of cereal format? I have a current XML data model that i'd love to use cereal as the reader/writer for this data. 
http://wiki.nesdev.com/w/index.php/Nesdev_Wiki
Reflection would be the best thing in the world for a serialization library if it was built into C++. Bringing in something like Boost Fusion or Hana into the core of cereal is unlikely (even if they are decoupled from the rest of Boost). However, this is something that could very likely be created as an add-on/module for cereal for those that are comfortable introducing these libraries into their development process. Regarding ranges over streams/iterators - I really love what I've seen with ranges and I would have to play around with them before I felt comfortable answering this properly. I can say however that we aren't really tied to streams - cereal essentially does a last minute hand-off to the stream to write data, with most of the actual work the library does being getting the data to that point.
Not sure if this is just nit picking, but you define most of your functions with auto, and still specify a return type. This seems like code that you don't need, auto return types are mostly useful for heavily templated return types, but in this case you don't save much. Especially weird to me is a void function specified as auto return. Also, there are several places where you pass strings by value, and I believe these are fine if you only ever pass temporaries in, but for longer json strings that are most likely not temporaries, you'll suffer a penalty. Pass by const &amp; instead. For Genome::GetJSON(), I'd highly recommend using a stringstream instead of concatenating a bunch of smaller strings together using operator +=. Pretty solid otherwise! 
If you have an easy way to make PCH work across Linux, Mac, and Windows, using GCC, Clang, Intel, Microsoft, IBM, and Cray compilers, please do share. It would make me so much more productive!
&gt; Now the "trick" I am trying to accomplish is to allow such transformations to stack, e.g. the result of one transformation can be supplied as the argument to another one -- see the main function above where I have illustrated the nice behavior I want using operator+. This is usually referred to as [expression templates](https://en.wikipedia.org/wiki/Expression_templates). With current C++, as an alternative you could consider overloading the operations on rvalues. This is [what `std::string` does](http://en.cppreference.com/w/cpp/string/basic_string/operator%2B), for example, so that `x + y + z` only needs to allocate one more string instead of two more... or even no more if they're already rvalues. This might not be optimal in as many situations as expression templates, but it can be a lot simpler.
Performance counters will help you characterize the behavior of your numbers but if you don't know what you're doing writing your benchmarks they aren't going to be of much help to you. The point is microbenchmarks of `&lt;string.h&gt;` functions don't generally match how those functions are used in real programs, and are likely to lead to skewed results in favor of more complex implementations as the branch predictor will be "warmed up" for that.
Have a look at pybind11: https://github.com/pybind/pybind11
IMO, it is not difficult (at least for me) to build a portfolio in C++. The key is to spot the deficiency (which C++ has plenty) for you to fix. This was one of my articles in 2003 which got me my 1st C++ job because it impressed the manager so much though I am not good at explaining. [Pointer to Pointer and Reference to Pointer](https://www.codeproject.com/Articles/4894/Pointer-to-Pointer-and-Reference-to-Pointer) That was the only article which talks about reference to pointer in 2003. Also in 2003 before I got work as C++ dev, I also wrote next_combination to complement the next_permutation. At that time, a few open-source projects was using my next_combination. They are using my function not because they liked to but that was the only next_combination in 2003. Right now, there are next_combination written by others which are more efficient. In 2010, I wrote a easy to use [XML DOM and SAX parser](https://github.com/shaovoon/elmax) which nobody give a hoot. In 2011, I presented a simple DirectShow C++ MP3 Player(copied from flipcode) (which I added some minor improvements) to be easy to use and popular(popular because C++ has no easy to use MP3 player) In 2014, I wrote a (header-only) [Minimalistic CSV Stream](https://github.com/shaovoon/minicsv) just because I want a no-fuss CSV stream which work like STL streams. In 2015, I shared and improved a [custom RTTI class](https://github.com/shaovoon/custom_rtti)(copied from a gamedev book) because C++ RTTI is very slow. In 2016, I create an efficient [string_view to integer/float conversion](https://github.com/shaovoon/str_view_conv_ex) (based on Boost Spirit Qi) which was going to be obsolete after C++17 comes out next year because C++17 has own conversion method for string_view In 2016, I gave my 1st C++ talk at Autodesk. In 2017, I am going to write a concurrent next_permutation and next_combination because they are not in C++17 concurrent STL algorithms. With GPU version in the plans if feasible. The above I listed are in my public repos under GitHub but I spent most personal time in private repo under BitBucket. I have many ideas to write for C++ in personal time. The only restriction is I do not have that much free time. I got companies(local and aboard) contact me from time to time. When I asked them who recommended me, they said it was their own engineers (whom I have not known). You notice I use C++11 in my projects but in my job, codebase is C++03 and C++11 forbidden to use. I learnt C++11 with my personal projects.
There are a lot of cases when you can beat the compiler by a lot with finely tuned SIMD intrinsics. Matrix-Matrix multiplication, convolution, exponentials, ... But it's only worth doing that in small kernels that are well isolated. 
1. I agree. I can thank MSVC that I had to write it like that. 2. Nice catch, this will be burned 3. Thanks, gonna double check them 4. Can you elaborate?
 - The paranoia evidenced in the first line disappeared in the second: using Any = ::std::any; #define HIPPOCRATES_ANY_CAST std::any_cast - This: std::vector&lt;supervised_body_t&gt; bodies; bodies.reserve(trainingInstances); for (std::size_t i = 0; i &lt; trainingInstances; ++i) { supervised_body_t body(data); bodies.push_back(std::move(body)); } should at least use `emplace_back`, and in all likelihood be simply `std::vector&lt;supervised_body_t&gt; bodies(trainingInstances, supervised_body_t{data});` - This is "let's make it compile, everything else be damned": template&lt;typename T&gt; static inline file_string_t to_file_string(const T&amp; t) { Any s; if (std::is_same&lt;file_string_t, std::string&gt;::value) s = std::to_string(t); else s = std::to_wstring(t); return HIPPOCRATES_ANY_CAST&lt;file_string_t&gt;(s); } 
&gt; C++ pretends we can only use the stack as a call stack, What.
Thank you very much! This is really helpful, written in a way that is easy to understand and will save us a lot of trouble in the long run. I will get on it ASAP.
What's the largest project that uses cereal?
I took the code and changed it to stop recursing when the size of the array is 10 or less. Now c++ code beats assembly. I speculate that compiler trades some overhead in order to make inner loop faster. Which makes perfect sense in the real world, where we turn to insertion sort when arrays get small.
At the time of launch I thought C++/CX was a bad idea marketing-wise. Now I see it was even worse technology-wise.
That's more a lesson in avoiding use of globals than anything else, I'd say.
I follow this subreddit regularly and I haven't seen this posted in the last few months, if not ever. Also, it wasn't posted by the author of the library itself.
Header only are nice when they are not too big. They increase a lot the compilation time. They are also nice since you just drop them into your project and use them.
&gt; Also why people use *.cc for C++ files ? Why not *.cpp ? I'm the author of [fmt](https://github.com/fmtlib/fmt) and can answer this question: the library uses the .cc extension because it (mostly) follows [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html). Also any suggestions to improve the header-only mode are very welcome.
I prefer non-header-only libraries, because of the compilation time and because it's trivial to add a library dependency in the build system that I use (CMake).
They've got to continue pushing a storefront no one wants for a couple more years before they abandon it.
With all due respect, if the compiler accepts the code and it respects the standard it is C++, you can say that it is old style C++, but you can't say its not C++ just because you (or I) don't like it.
I don't think the sort algorithm was the point of the article. Think at it this way: author wrote some C++ code, than reimplemented same code in Assembly by hand and compared the running time of these two pieces of code. 
Actually, you can, just use a #define macro. It's not pretty, but it works.
&gt; it can be hard to assess if any other functions called in the body mutate it unless you make a local copy. Thats not actually true. If you get a `const int* const` variable the compiler **must** ensure **every function** you call with it as an argument takes it as `const int* const` (except if you cheat and make a cast, but then you're on your own). The real problem with your example is that you're using a *global* variable. Any context which can access that variable directly, will use it as it was declared, i.e. a non-const. That's why global state is a Bad Thing&amp;trade;. Try this on your compiler of choice: #include &lt;iostream&gt; #include &lt;string&gt; int x = 3; void doStuff2(int&amp; y) { y = 5; } void DoStuff(const int&amp; z) { doStuff2(z); } int main() { std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; "\n"; // Suprise! DoStuff(x); std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; "\n"; // Suprise! } You'll get a **compiler** error on the call to `doStuff2` inside `DoStuff`.
Maybe I shouldn't be saying this on cpp, but for me the sadness is that we didn't got WinRT with .NET Native already from the get go. Borland already had it with VCL and their Delphi/C++ Builder combo, so it isn't as if Microsoft couldn't have done it. Specially with Anders and other ex-Borland guys on board. We had to wait almost 20 years for it and still isn't quite there. 
Starting with Windows 10, UWP apps are desktop apps. There is no difference for the end user. Also going forward, only UWP will get new APIs anyway. Win32 is done, so to speak. 
I only used it for accessing API that so far have been kept away from .NET developers, like DirectX. Is anyone using it for 100% C++ applications? Maybe this would be a reason why performance hasn't been properly fine tuned. In any case I would welcome that Microsoft would make their mind in just one version of C++.
I thought of that too, but I'm not sure of the caveats.
I do think it matters. The thing is, a higher-level language allows you to express *algorithm* changes more easily; and algorithm changes (such as switching to sorting networks for small sizes instead of recursing to death) enable greater gains than micro-optimizations in general. I'll link to [u/andriusst's comment](https://www.reddit.com/r/cpp/comments/5fhh5z/beating_the_compiler/dake4gd/): &gt; I took the code and changed it to stop recursing when the size of the array is 10 or less. Now c++ code beats assembly. Another example is how Eigen has spread even though it is, on a single operation, generally slower than a Fortran-based library: its use of expression templates allows it to see the *whole* computation and apply high-level optimizations before delving into micro-optimization. Yet another example, on the front page of r/programming: [Why V8's tendency to performance-optimize bad code is bad for good code](https://www.reddit.com/r/programming/comments/5ffgfe/why_v8s_tendency_to_performanceoptimize_bad_code/), where the author shows how the same function written in JS and Dart performance more poorly in Dart (which is supposed to be faster). And it turns out that's it because the function is insane, but V8 has a specific optimization in its handling on strings to give it palatable performance. --- Comparing the *exact same algorithm* in different languages does not make sense, because different languages have different strengths and weaknesses. What matters is the *result* and, if you have to write or debug the code yourself, the simplicity/elegance of the code.
Yes you can. Declare the variable as `constexpr` and it won't change no matter what you do with it. You can also declare a const, non-reference, local variable. Or simple a const global varaible. They won't change value no matter what you do. If you trick the compiler with `const_cast`, it may not even change the value or simply crash.
The hole allows aliasing TO `char` or `unsigned char`, not FROM `char`.
I'm not sure to be honest - we don't have anything set up to list big projects using it. The project it was originally developed for a ~100k LOC [neuromorphic robotics toolkit](http://nrtkit.org) (website woefully out of date), but it's likely being used in something larger.
You would need to create your own custom archive, likely modelled on the current XML archive, to support a format that differs from what cereal provides. Archives are essentially given data in its most basic form and then decide what to do with it.
Why is this focusing on basically emulating a standard container? The biggest advantage of Boost.MultiIndex is doing things that standard containers can't (i.e. access the data from more than one view).
I think you should do something like qt instead of UWP, i never used and i never plan to use it, you are wasting time and resources that may be handy in other project like vcpkg that it is really great and maybe made me switch back to VS and Windows If i want to make a windows program i will use C#, at least for the gui and if i want to use it anywhere i will choose qt or Java, at least for the gui
The compiler does not check what others do with the underlying storage the `const int* const` is referencing. ~~For example~~ (edit: my example was exactly yours after the change to `const int* const`) If you're now pointing the problem towards having a global - then I refer you to this thread: https://www.reddit.com/r/cpp/comments/5fflcb/const_is_in_the_eye_of_the_beholder/dakh0mo/ I'd say the problem is mutability and sideffects more than it is about anything being "global".
And in that case you're using intrinsics, not asm.
I notice that the handwritten version doesn't seem to emit frame pointers and similar as specified in normal ABIs. I think the author needs to compare his assembly with that the compilers emit before saying that they're outright worse.
https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html
&gt; [The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time](http://en.cppreference.com/w/cpp/language/constexpr) `#define` and `constexpr` definitely fulfill the "never changes" requirement. It would be nice if I could also have runtime "never changes" variables. Kind of like what one might expect from a const reference, but to be truly immutable. Maybe it should be called `const reference const`, a reference that is guaranteed to point to a concretely const variable (like a constexpr or a const field on an instance).
libc++ includes a synopsis of the header in comments at the top of every header. The synopsis isn't full documentation but is often enough to jog your memory of the contents and signatures. The synopsis in the comment is free of the otherwise-required underscore uglification.
No the problem is not mutability, it's bad encapsulation. You have public fields and a "fake" accessor. It's exactly the same problem with the global: you have two ways of accessing the same memory location. One through the "accessor" and the other through the public field. If you, by analogy, consider the global scope as an instance of a class (in particular a singleton), you have the same thing going on with global variables. To avoid those problems we have the private fields with method accessor pattern. Creating a const&amp; accessor for a public field won't magically protect the field from changes. In fact having an accessor for a public field is a huge code smell, I'd be expecting lots of bugs like the one you seen.
Besides what I said in the other thread, the code seems to forget what a reference means. It treats a const reference like a local copy. In both cases you want *the value* that the reference points to, *not the reference*, in other words you want a (possibly const) **copy of the value**, not a *const reference* to the value.
After looking at some of the other responses, I will agree that there may be UB because of lifetime / object creation issues. I doubt the UB is intentional from a standards perspective though, as it seems it breaks malloc. If you can show me a released compiler in the last 10 years that intentionally and subtly breaks malloc behavior through lifetime legalese, I'll show you a worthless compiler. (no points for showing me realloc UB). [basic.life](http://eel.is/c++draft/basic.life#1) seems to have a saner concept of lifetime than [intro.object](http://eel.is/c++draft/intro.object#1). Pretty sure you can alias to and from char * though. See [basic.lval](http://eel.is/c++draft/basic.lval#8). The aliasing rules just say which pointers are allowed to access the stored value of an object. Origin of the object or directionality doesn't really come into play. 
To clarify the need, although I don't think it's major, currently if you want to guarantee constness of a const-ref variable passed into a function then you must make sure there are no side effects affecting the underlying data behind your const-ref. The need to use a const-ref to begin with is to avoid making a copy of the variable. So there are workarounds - have no side effects, or make a copy. It could be a nice feature to be able to guarantee no side effects can affect a const-ref variable, thus guaranteeing the implied immutability.
FWIW, I'm working on a proposal to add parts of Hana (algorithms on tuples basically) to the standard library. My personal stance is that adding functionality one by one is bad, since we'd lack a unified vision. Just like you don't design the standard library one algorithm at a time; instead you come up with abstractions and make sure they can be used to implement (almost) all algorithms, at once.
Please make major improvements to the template error stack trace, especially for people USING template libraries (as opposed to authoring them) First of all, **the order of the stack should be inverted**. Since most people are not authoring template libraries, the instantiation site (currently the LAST thing) should be first. There should also be magic support for knowing which template argument was wrong at the initial invocation (whenever possible, which it often is). static_assert(sizeof(_Ty) &gt; 2) ? Point out the error in the original invocation by chasing _Ty backwards to the input type and position where it was written! This should also be possible for other type errors, like the type not having an expected method/field/other, this is an extremely common condition! Also, each frame is ridiculously long. 2&gt;error-continuation C:\enl\dev1.public.amd64fre\internal\sdk\inc\ucrt\stl120\xmemory0(1097): note: see reference to function template instantiation 'void std::allocator_traits&lt;_Alloc&gt;::construct&lt;_Ty,zzz::classname&amp;,int&gt;(std::allocator&lt;_Ty&gt; &amp;,_Objty *,zzz::classname &amp;,int &amp;&amp;)' being compiled 2&gt;error-continuation with 2&gt;error-continuation [ 2&gt;error-continuation _Alloc=std::allocator&lt;PropertyKey&gt;, 2&gt;error-continuation _Ty=PropertyKey, 2&gt;error-continuation _Objty=PropertyKey 2&gt;error-continuation ] 2&gt;error-continuation C:\enl\dev1.public.amd64fre\internal\sdk\inc\ucrt\stl120\vector(924): note: see reference to function template instantiation 'void std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt;::construct&lt;_Ty,zzz::classname&amp;,int&gt;(_Ty *,zzz::classname &amp;,int &amp;&amp;)' being compiled 2&gt;error-continuation with 2&gt;error-continuation [ 2&gt;error-continuation _Ty=PropertyKey 2&gt;error-continuation ] You should compact it with something like this, because it can easily be half as long and twice as readable. 2&gt; + C:\enl\dev1.public.amd64fre\internal\sdk\inc\ucrt\stl120\vector(925) 2&gt; | 'void std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt;::construct&lt;_Ty,zzz::classname&amp;,int&gt;(_Ty *,zzz::classname &amp;,int &amp;&amp;)' 2&gt; | With [ _Ty = PropertyKey ] 2&gt; + C:\enl\dev1.public.amd64fre\internal\sdk\inc\ucrt\stl120\xmemory0(1097) 2&gt; | 'std::allocator_traits&lt;_Alloc&gt;::construct&lt;_Ty,zzz::classname&amp;,int&gt;(std::allocator&lt;_Ty&gt; &amp;,_Objty *,zzz::classname &amp;,int &amp;&amp;)' 2&gt; | With [ _Alloc=std::allocator&lt;PropertyKey&gt;, _Ty=PropertyKey, _Objty=PropertyKey ] That is, remove "error-continuation", make something smaller. And flatten the type mapping to a single line whenever possible. Make sure both the start and the end of the stack are very easy to spot. Make sure that when there are multiple distinct template errors, the stacks are VERY easy to visually distinguish at a glance when scrolling-- don't let them appear to blend together into a giant stack!! I recommend solving this by when printing the root error (which I recommend be at the bottom), you should have it stand out enough to draw a ton of attention to it and thus, if more template errors follow it, they will be easy to identify as separate errors even when scrolling quickly.
[Yeah, what kind of crazy person would attempt such a thing?](https://en.wikipedia.org/wiki/RollerCoaster_Tycoon#Development)
While it is apparently UB, if a compiler actually made use of it then it would make reading binary data over the network impossible.
Different times
No, everything is in place on Windows 10, of course running on other OS won't deliver the expected results. Even any basic Win32 Visual C++ application will complain about missing runtime if it is dynamically linked and MSVCRT or its dependencies aren't found.
I started with Managed C++, as I had access to .NET on its early alpha-days as many MS Partners back then and we exploring how to bring our product stack to the platform. What I liked about C++/CX was that it finally seemed to be something similar to C++ Builder (native &amp; access to a proper OO framework not MFC/ATL stuff).
What you are asking about is simply impossible. The compiler cannot know what your functions are doing to check if you change it's value (assuming you use multiple cpp file) and even if the compiler could know your whole program, then an external process (just like cheat engine) could change the value of your variables referenced by your "const guaranteed" variable. It's not about adding a thing to C++, you cannot forbid a mutable variable to change. What you could do is a wrapper around a pointer, and copy the variable if it's value is changed to mimic what the const guaranteed would do. But again, you'd still need a copy, and a lot of overhead. Btw, now I think you know why mutable global are bad: they lead to a side effect mess. If you don't want to be in that mess, I strongly recommend you to not use them. 
If you use QtCreator you can install directly the cppreference offline manual too: http://en.cppreference.com/w/Cppreference:Archives see Qt help book section.
What's wrong with your screenshot? Yes, I think it's supposed to look like that. I don't see anything missing. It sounds like you can't perceive the slight color difference between 2 of the colors used, for example in Application::Application. The only issue I've ever had with CLion was when I started using it the typing felt delayed, and so I instantly gave up on it until I tried it again and either got used to it or the delay went away. Typical java bullshit. It blows my mind that people create latency sensitive applications in java.
Screenshot you posted seems accurate, although you can play with the coloring and syntax highlighting as much as you want. How were you searching for usages? If I search for usage of a class in my project, it gives me a list of the places where that class is used, not just comments including the name of the class. I use it just because it was the next IDE I tried after using Sublime for a while because I got sick of Visual Studio. CLion has everything I need so far and I haven't run across any major problems I can't solve, so I've had no reason to shop for other IDEs. I also like the other Jetbrains IDEs (I use IntelliJ and PhpStorm regularly), and it's nice to have a unified feel.
Why did Microsoft introduce C++/CX if the whole thing can be done in standard C++?
Because doing it in standard C++ meant having to deal with COM and that is a REAL pain, because COM interfaces != C++ interfaces and there is no reflection and so and so. They thought extending the language and pushing it to the standard was the way to go ("want to use a smart pointer? use ^ as syntatic sugar"), but nobody ever bought that and C++ programmers are already used to the template syntax so that was never a problem. Building a whole C++ API to work around that was a much bigger task and nobody wanted to tackle the problem untill Kenny Kerr came around with ModernCPP (https://moderncpp.com/), which was renamed to C++/WinRT after MS hired him. Also, the language extensions meant that whenever you wrote a WinRT library it worked right out of the box with other managed languages, no need to write COM interface by hand, which is not available with WinRT. 
Find usages is an unfortunate usability regression that will be fixed soon, sorry about that (https://youtrack.jetbrains.com/issue/CPP-8211). Basically, "Fins Usages" supposed to return non-code usages as well, which is cool by itself, but currently they are less subtle than expected. Other than that, I don't see immediate problems in the screenshot, if there actually are, feel free to create a ticket in the tracker, use "Help | Submit feedback" IDE action or write to (clion-support at jetbrains.com).
InteliJ based IDEs will be slow even if coded in C++, nothing to do with Java. I had to turn most of the plugins off to be able to achieve CPU and HDD usage comparable to Eclipse and Netbeans. InteliJ made me like Eclipse again.
You have a lot of options for syntax coloring in CLion, you just need to configure it to your liking. [clion syntax coloring.jpg](https://postimg.org/image/hefjdwc3b/) https://blog.jetbrains.com/clion/2016/09/clion-opens-2016-3-eap/#semantic_highlighting
I like CLion's UI and the fact that it's projects just show you're file tree. I don't use it much because I prefer kdevelop on linux and on windows it needs to use mingw. Also because they are writing their own parser instead of using clang or buying one from someone (like MS does with VS), they fall down on more complex C++ code.
I think kdevelop can actually pull docs directly from cppreference. Not 100% sure how well it works though.
&gt; How were you searching for usages? Like this : https://webmshare.com/PYYQR
&gt; well, I just asked my coworker and he couldn't see the difference either on my screen, unless zoomed very big. I mean, sure, one can change the color but the defaults should at least have some important contrast. While the theme is low in contrast, I think your monitor is the problem here. &gt; ugh, yes. I tried and this is atrocious. I have an i7-4770 with 16gb ram and I can see lag at each letter. Try typing/spamming some keys for a bit and see if the lag goes away. The vast majority of the time the lag shouldn't be there. I recommend that you give CLion a proper chance. I love using it.
I also use [KDevelop](https://www.kdevelop.org/download). I have tried CLion several times, and I see absolutely no benefit.
&gt; Well it's my work monitor. Just don't let an artist anywhere near that piece of crap (unless it's the indoor lighting that is having this effect somehow)! &gt; I tried to code a class, it's unbearable. I don't have those problems anymore and you're just noticing them now?
I don't know how much you can trust that page. The iostreams are supposed to implement c++11, yet they still throw c++98 exceptions which you can no longer catch in c++11 code (unless you catch a common base type or ...). 
First of all, if you are having trouble with indexing, make sure you mark project folders either "Project source files and headers", "Library Files" or "Excluded" (right click on the folder -&gt; Mark directory as). Especially cmake build folders should be marked excluded to avoid needless indexing. I like Clion for * The integration with cmake and controlling everything from CMakeLists.txt, making it really easy to connect with external libraries instead of fiddling through obscure settings within the IDE. I feel it makes the whole project far more portable. * Semantically aware autocomplete and refactoring. This is the only IDE I've found which has an autocomplete popup balloon for browsing class members (and argument types of all overloads) that comes close to VS's. I actually learn c++ from it. * Great UI and syntax coloring, almost as good as VS. Colors are well chosen, beautiful even, both for light and dark theme. Syntax coloring works properly for external libraries. Haven't found anything else nearly as good in Linux. * Easy to use and helpful debugging mode. EDIT: Also, great choice of keymaps (emacs, netbeans, vs, eclipse...) and last but not least, great github integration. 
You could also give [juCi++](https://github.com/cppit/jucipp) a try, at least if you are on Linux or OS X (it works on Windows too, but is harder to install there) It's faster, more stable, and less resource demanding than most IDE's. We are currently working on solutions of finding usages in unopened (and unparsed) source files through libclang, but that is the most lacking feature. Feel free to join the discussion though. juCi++ also supports debugging through liblldb, which I believe is faster than the alternatives (feel free to correct me). Although, liblldb and lldb-severs might not be as well tested and stable as for instance gdb.
The solution to a low contrast theme that displays badly on non colour-accurate monitors is not "get a new monitor you twat", its "why is the theme such low contrast if relatively normal monitors are having difficulty showing the difference between colours" 
Whoever designed that color theme was an idiot. I mean it. There's no excuse for that color theme. And it's not a matter of opinion or perceptive skills. It's objectively bad.
It's still possible and doable :)
&gt; InteliJ based IDEs will be slow even if coded in C++, nothing to do with Java. It's much easier to see how an IDE in a virtual machine would run slower than one machine compiled. I suspect the garbage collector has a hayday with all the strings.
While the lag that I experience with CLion doesn't render it unusable, I do find it is noticeably slower than other JetBrains products like IntelliJ or PyCharm. Have you tried tweaking the jvm settings at all?
Just the company is good at creating the hype. Sure, their IDEs can have some nice refactoring capabilities (though not exclusive to them) but I had almost nothing but negative experience with them (performance/lag/bug-wise) whether I was trying to code Java, Scala, JS, and etc. and whether I was using i5 ultrabook or i7 haswell @ 4Ghz, 16 GB RAM + SSD desktop. While using QT Creator or even Visual Studio was always more or less smooth.
It is not something our current developers are prioritising. We usually solve the various Windows errors within a week or so though, and have been contributing to make the dependent libraries work on Windows (gtksourceview(mm)3, gtk and libgit2 for instance), but you currently still have to fight your way through the rabbit-hole! Look through the issues with MSYS2 in its title (currently 2, or 1 if you skip debugging support). 
I just put in a Solarized color theme and it works wonders.
atomics do both: they change the behavior of the compiler to account for the specified order at compile time and they change the codegen to guarantee the specified order at runtime. mutex is a lot more like a release/acquire atomic access (in fact, mutex lock and unlock are classified as acquire and release operations in the standard)
Until there are some mechanisms for notifications when a top level post is made (i.e. actual job posting) this thread is not that useful.
&gt; So in this thread we know of exactly one monitor with this problem so far, well, we all have the same monitor here (Dell U2412M). And I had the same experience when I tried it at home a few versions ago (with a Iiyama one).
&gt; his is the only IDE I've found which has an autocomplete popup balloon for browsing class members I wonder what IDEs you tried, Visual Studio's one seems subpar to me compared to QtCreator's and KDevelop's (especially since they integerate CLang). 
&gt; I recommend that you give CLion a proper chance. I love using it. But I *tried* ! Ever since CLion was announced, I try it every time there is an update of the releases, because it *seems* so useful and feature-packed, but the main stuff I use my IDE for, i.e. actual writing of code, is in my opinion still sub-par.
&gt; juCi++ also supports debugging through liblldb, By any chance would you support the "revert to the previous step upon segfault" of LLDB ? this would be awesome.
&gt; Have you tried tweaking the jvm settings at all? mh, no, I'll look into it.
True. But it was the same OS (win 10), same everything. Has VS installed, worked under it, didn't work standalone. Maybe a compiler switch? Probably. But definitely it didn't run by itself.
That hasn't been my experience at all. Is it still indexing or anything in the background? The biggest issue I have with it is when it tries to autocomplete a boost type and can sometimes hang for a minute. I believe the only tweak I've done to it is letting it use more RAM to deal with a relatively large/convoluted project.
I don't understand either. I had a variable of the type of a complex TMP result and it didn't autocompleted me, and underlined a lot of non-existent error in my code that uses sfinae. Right now I use kdevelop5. The parser has nearly perfect correctness, but is still buggy (I have to reload the files a lot). I hope they get better in the future.
Yep, Solarized and tick on Semantic coloring. Fantastic stuff.
&gt; Yes but how many actually use it? Exclusively, coming from a workplace Eclipse installation and heavily customized vim.
Not really removed, just changed. The c++98 version of the std::ios_base::failure exception is not ABI compatible with its c++11 version and resolves to a different type. The library throws the c++98 version, code compiled in c++11 mode tries to catch the c++11 version, your program terminates. https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66145 . 
this bug is absolutely terrifying
&gt; The only Java IDE which is slick &amp; fast True but is it as feature rich as the competition? I have used it for simple personal projects and for me it is pretty decent (I am not a Java pro) but most Java programmers seem to prefer the other IDE's. JCreator is not that popular it seems despite the free / low price. Also no updates since Jan 2015..
CLion is a very good product so it is normal that people recommend it I use as my C++ IDE and it is not perfect but it is far away better than VS and other ides i tried, at least for me I dont like the yes or yes use of cmake or the google test for testing but day after day the product is getting better and in a few years it will be almost perfect
That screenshot is an excellent case of poor use of color. Depending on your screen (and angle!) and color vision (remember, almost 10% of the target demographic has color vision problems), significant portion of the colors look exactly same. The brightness also varies too much, making it harder to read than it should be (for example "m_applicationSettings" is much darker than "(appSettings)").
Ugh. It bundles the right version of java with it now so that probably isn't the issue. For comparison my work computer is an i7-2600 with 16gb ram and spinny rust drives. Clion using about 1.6g of memory.
Check out [Unreal Course](http://unrealcourse.com). You can usually find it for $30 or less and the combination of relatively modern C++ from zero background as well as using it with Unreal Engine later on is perfect.
The moment I have to start tweaking jvm settings to make an IDE work correctly is when I switch to another IDE. Come on, it's supposed to help me do my job, not create new unnecessary problems to fix in my day job!
I am willing to change the whole style to trailling return types. However, I see one caveat: if someone is implementing a template and forgot to specify the return type, it can guess the wrong type if a reference was needed. It raises one question on the matter: suppose you adhere to trailing return type everywhere and you write your whole codebase like that. Now, you have a function that you want to make it deduce the return type. What to you write? // I want to deduce `decltype(auto)` auto my_func() -&gt; decltype(auto) { ... } decltype(auto) my_func() { ... } // I want to deduce `auto&amp;&amp;` auto my_func() -&gt; auto&amp;&amp; { ... } auto&amp;&amp; my_func() { ... } // I want to deduce `auto` auto my_func() -&gt; auto { ... } // seems redundant auto my_func() { ... } However, if you add this to your compiler argument (I know this is bad, please don't throw rocks at me) `-Dfunc=auto` now it become much clearer: // I want to deduce `decltype(auto)` func my_func() -&gt; decltype(auto) { ... } // I want to deduce `auto&amp;&amp;` func my_func() -&gt; auto&amp;&amp; { ... } // I want to deduce `auto` func my_func() -&gt; auto { ... } // seems redundant func my_func() { ... } // same as -&gt; auto
Looks pretty crap on my BENQ monitor at work too. Downvoted for being abusive because someone has a different experience than you.
Aha, thank you, and in that case: yes. I got the following from running "p my_func()" in Debug Run Command: error: Execution was interrupted, reason: EXC_BAD_ACCESS (code=1, address=0x0). The process has been returned to the state before expression evaluation.
As a Linux guy I use vim and multiple windows. I've never understood the ide fascination, but I'm working with some folks who need an ide for Linux. They are coming from Windows with visual studio. Any good ones I could recon for them? Before you start hating me I do understand the validity of an ide for Android or iOS development, but for Linux c++ I don't get the ide fan frenzy.
&gt; an ide for Android or iOS development, but for Linux c++ I don't get the ide fan frenzy. why would the needs be different for iOS, Android, or Linux development ? you're making software all the same. I personally mostly use QtCreator but I try to be open to new stuff.
I hadn't even noticed it. As you can see, it puts the focus to a random node as soon as it ends the search.
That line is the *definition* of the term "object", as indicated by the italicization of the word. They are the only way to create objects in C++, by definition.
I wish I could still run windows 98 second edition, those were the golden days :p Please, make windows great again!
I've tried visual studio, netbeans, eclipse, QtCreator, KDevelop, Code::Blocks and neovim with clang-complete/ycm. I liked visual studio's the most, for its performance, ui-style and practicality. For instance, it can collapse/uncollapse overloads making it easier to glance over. Clion's imlementation is the most similar imho, even though it lacks the collapse feature. Clang-based autocomplete is alright I guess. I suppose my opinion of it got colored by the rest of the experience. After moving to linux, Clion is the only IDE to give me a similar sense of cohesion and attention to detail to what I found in visual studio. In my opinion it is basically the only IDE with a great dark theme out of the box without ugly UI glitches. But I admit this is highly subjective. 
well at least it let's me see the OS level file/folder structure instead of this crap that VS imposes upon you with their virtual structure. YUCK
Java is compiled to machine code as well. Any savy Java developer knows multiple ways of doing it. I have seen my share of very poorly written C++ code. Just because it is C++ doesn't mean everyone writes sane fast code in it.
Can kdevelop show call hierarchy and type hierarchy?
Hm, does this actually imply that any attempt to use the val member in a C library with an API like this struct Foo { int val; }; struct Foo* create_foo(); void delete_foo(struct Foo*); will result in UB by definition?
I do C++ development for Linux. IDEs have indexers that understand C++: they can show a call tree for some class member, rename a class member, rename a type. Also, they have precise autocomplete and type-awareness.
Except that that section refers to basic.life which seems to say that for objects with vacuous initialization (such as SomePod) lifetime begins once storage with proper alignment and size is obtained: http://eel.is/c++draft/basic.life#1. My reading of that says that the lifetime of the (conceptual) `SomePod` object begins as soon as the storage for `buffer` is allocated. It is somewhat unclear whether the storage is allocated once execution reaches the declaration of `buffer` (when its constructor would run) or whether it comes into existence the moment the containing block is entered (assuming this is in a function and has automatic duration). http://eel.is/c++draft/basic.stc.auto#1 clearly says that the storage lasts until the block exits, even after the destructor would run, but it doesn't mention when the storage is allocated. If this wasn't allowed, I don't think there would be any legal use of `malloc` in c++. `int* p = (int*)malloc(sizeof(int)); *p = 1;` relies on the same ability to implicitly create trivially constructible objects in properly aligned storage. Note that these links are using the C++17 draft language which isn't 100% official yet and contains some substantial changes in this area (such as `std::launder`).
you're right, sorry
&gt; Is QtCreator useful if you are not using QtLibs for development? Yes, I also use it for pure C++ projects without Qt involved. It has a decent CMake integration, which should be improving in the next releases. As /u/devel_watcher says, what's useful is refactoring (e.g. for instance first write all your members in the .hpp, right click on the class name, "Move all functions to source file") and everything is put correctly in the .cpp (except template functions of course). Or "find all usages of...". Also QtCreator's locator, Ctrl+k, is fantastic (but I have heard a lot of good of CLion's too). http://doc.qt.io/qtcreator/creator-editor-locator.html For instance : * `ctrl-k c MyClass[enter]` -&gt; goes to MyClass definition * `ctrl-k ? MyClass[enter]` -&gt; show the HTML documentation of the class etc... 
Like judging a movie on the car park, but okay...
Or just use CMake and source_group to have VS structure make sense like you want it to.
Could you bring out a few points that in your opinion make CLion better than Visual Studio?
I use bt in gdb. Never needed a call trace while writing code.
It's used when reading, not writing.
All of them, if executed on a JVM with JIT. If you are willing to wait more than usual for the startup with the Oracle JVM, set *-XX:CompileThreshold* to a value close to zero or even 0, and everything will be straight away JIT compiled native code. For brownie points, install a JVM that does JIT/AOT caching like IBM J9 http://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.lnx.80.doc/diag/appendixes/cmdline/commands_jit.html
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to /r/cpp. 
So this question: https://www.reddit.com/r/cpp/comments/5fowev/why_the_hype_about_clion/ pertains to cpp but my question did not. Goddamn I love reddit moderators.
The 42000 subscribers to r/cpp aren't here to answer your questions. Read the sidebar. Which part of it says "subscribe to this sub to answer newie questions on a daily basis!".
CLion is the closest we will get to full Visual Studio on Linux. Personally it's the easiest thing to get me to write C++ code on Linux. CLion + Linux = Love. They are advancing with more features and gaining on Visual Studio, but until that time comes I'll keep VS on Windows, and CLion on Linux. But also the base IntellJ Idea is great for Web Development, Java, Python and I've used it on Windows, OSX, and Linux for C++ development, and for embedded development as well. It just does everything, and fairly well.
I know this is my peeve and not necessarily your hill to die on, but there is absolutely no reddit experience worse than submitting a thread and then coming back later to find it removed, not because it was spam or anything, but because an automoderator or other moderator felt it belonged elsewhere. Wish you would ask spez and get together with other subreddits in your keiretsu so that you all could stop removing posts and creating extra work for people you actually seem to want to help by not removing threads but moving them. Until then, what I see is removing threads (like stackoverflow's killing them) is the biggest f u ever to the community.
Which of these are not questions? http://i.imgur.com/mMEaCRy.png But by being polite and marking my question as newb, I managed to trigger you.
Ability to move threads between subs would probably create more problems than it would solve. It's getting close to giving moderators the ability to edit titles, for example. At most, the submitter would have to agree to the move. Then there's the problems of commenters. They might not want to have their comments on another sub. Now that I've mentioned the problems moving submissions could have... I honestly don't see the problem with deleting the submission here. It takes like 15 seconds to copy your post title and content to r/cpp_questions, where you should have posted your submission to begin with, if you had read the text in RED everywhere. At least I would've understood if you had posted there and had gotten no response, but this isn't the case. It seems you just want to reach as many people as possible.
&gt; At most, the submitter would have to agree to the move. Um, it's not like you ask submitters for permission to delete their threads. So a moderator move to the proper thread would be a hugely advantageous option for the submitter. &gt; It takes like 15 seconds to copy your post title and content to r/cpp_questions, That assumes so much + what kind of device I am on + my physical abilities (maybe I am blind or disabled) But mostly, for me, the problem is that I will post a question because I am looking for help in an entirely reasonable thread, then I will leave the computer to do something else, use the bathroom, go eat, make dinner for the kids, go to a meeting, leave work, go to bed, etc. ONLY to find out later that my question I posted to a reasonable place BECAUSE I NEEDED HELP was arbitrarily removed by a moderator. Well thanks moderator for all your support!
More like judging a car company by its bikes. 
well, with an ide you can double click on a line of your call stack and it will take you to the same line in your code for instance.
UWP (and Windows 8.x Store) apps must be registered with the OS before they can be run. This is just how things are, you're not missing a compiler switch or the like. To run an app on your own computer, VS will do the registration ("deployment") for you when you debug the app; to run on a different computer (or without using VS), you need to [package your app](https://msdn.microsoft.com/en-us/windows/uwp/packaging/packaging-uwp-apps).
I barely see qtcreator mentioned. Great ide, fast, simple. 
The only thing I can think of is that string is a class and the rest are builtin c data types. 
hmm, yea. not sure I'm a fan of this uwp thingy. It's a catch 22 with it catching on: since there are no apps no users will use it, since there are no users no developers will bother making apps. I hope that MS will revamp windows desktop application frameworks, pull them out from the shelf, clean the dust and make them better. UWP ... the big question is: why even bother?
OTOH, C++ developers have been whining and complaining about having 3rd-rate GUI tools for the last 15 years, and now we have an efficient standard-C++ framework with the same design tools as the .NET and web guys. MS is banking on the tooling selling developers, and while it's going slowly, I don't necessarily think that's going to fail. EDIT: grammar
instead of arguing, how about just hearing other peoples' opinions
This is all good constructive feedback for VS. We try to always improve the experience based on feedback release after release, so I would definitely like you to try VS 2017 and share your thoughts on it. Sorry about your experience with the VS2017 installer. Any chance you can reach out to me at mluparu at microsoft dotcom and I can try to sort out the issues you've been seeing while installing VS? I'd also be happy to discuss in more detail some of the edit/build/debug issues you brought up. Thanks!
When I messed with it a while ago, I was surprised about a few Qt-y things. The biggest surprise Qt Creator had for me was that the only dependency is Qt, and an optional clang if you wished to integrate it for code completion. Even building Qt was surprisingly straightforward: IIRC you need python, ruby, git and Visual Studio in your path, and have an OpenSSL build if you wish to use ssl. If you want to build OpenSSL yourself, you need nothing besides Visual Studio itself. Qt is probably the easiest toolkit of such scale to build on Windows. If something requires autotools to build, it's useless on Windows, and has a build system so baroque as to be worthy of instant replacement. Somehow the GNU people don't understand that.
If you want to have a more in-depth understanding of the topic I recommend that you to learn about the C++ memory model. The best resource I found is chapter 5 of the book [C++ Concurrency in Action](https://www.amazon.com/C-Concurrency-Action-Practical-Multithreading/dp/1933988770). It's also helpful to learn about the [MESI](https://www.youtube.com/watch?v=-p9tfMMu1PE) cache coherence protocol used by modern CPUs.
You're not checking that the file opened correctly. 
You still work at DWA?
Yes. ifstream has an is_open() method. And then use errno to tell the user the reason the open failed.
&gt; Here's the naive C++ quicksort * ```extern "C"``` * uses raw pointers to arrays instead of std::vector * declares structs with uninitialised members * writes own swap instead of using std::swap * unnecessarily copies Items instead of of referencing them This is C, not C++. Also, for some reason you hardcoded the pivot to the last member of the array. At least use ```rand()``` like a true C programmer would (but don't you dare use ```rand()``` in C++ code). Yes, you mention in the article that it has caveats, but if you are going to write a blog post you could at least write it using real code you'd use in real life, in this century, not some contrived example from 20 years ago.
Why do you say TCP has better throughput than UDP?
I know this is a bit harsh but I question why people create almost anything in Java. Years of doing help desk support have really made me biased again Java (the runtime, not the language) though. Maybe my bias clouds my judgement. 
Herb Sutter's `&lt;atomic&gt; weapons` talks are also helpful: https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2
Because I'm oversimplifying things. =P UDP can be faster if you're transmitting over a low-traffic network, or (and this is usually the critical one) if you're okay with a few packets getting dropped now-and-then. If, however, you're doing something like a file transfer or other kind of "large amount of important, validation-mandatory data", TCP often outperforms UDP simply because programmers love to "reinvent the wheel" when they use UDP, and a lot of the mechanisms that TCP uses to reduce congestion and make sure the packets arrive safely (handshaking, flow control, etc.) are usually better than whatever the programmer tries to roll by hand.
Only 1k occurrences of C++ code. I don't see the issue in breaking their code; they should have typedef'd it instead.
Keep in mind there's a lot of C code that gets compiled with a C++ compiler for some extra checks and whatnot, and that C projects can migrate to C++ later (I think this happened in GCC). I'd still recommend a typedef in C, of course.
I think almost every C++ programmer gets surprised by this at some point in their career. I remember it took me a little time to wrap my head around what "const volatile int x" means (thankfully, volatile is something most programmers never need).
C already has quite a few non-compatible differences with C++ (such as `sizeof('a')`), so I don't see the harm.
Yes, that condition is too restrictive. I do not want to add 2 lines to all my source of my personal projects. Viva64 should not afraid people exploit their static analyser for free. It is true some dishonest people will do so but most people/organization are honest. Many years back, I requested for free license for my open source project and offer to recommend to my company (if found promising) but got rejected. That was potential sale of a few licenses. I did not use PVS-Studio, therefore cannot do recommendation. I think a freemium model should work better for Viva64.
&gt; because the UI seems very polished This basically. There are problems with parsing, but once you used diff with clipboard in debugger tab, you can't go back.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/5ftsh0/problem_reading_a_simple_text_file_using_ifstream/danc69e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Could have gotten mixed up with `auto foo();` deducing a type by value. That said, `auto&amp;` and `decltype(auto)` are just as legal, moving out of a function is a standard thing, (N)RVO is a de-facto standard thing, and guaranteed copy elision is about to be a thing.
Cool. I remeber seeing you on the How to Train Your Dragon 2 Movie thread. Can't wait for number 3 but its like a year and a half away :(
Check r/gamedev SDL * http://lazyfoo.net/tutorials/SDL/index.php * https://www.youtube.com/playlist?list=PL006xsVEsbKjSKBmLu1clo85yLrwjY67X SFML * https://www.amazon.com/SFML-Development-Example-Raimondas-Pupius/dp/1785287346/ * https://www.youtube.com/playlist?list=PLS9MbmO_ssyCSyqZC2NEfblIa9_xSrMqR * https://www.youtube.com/watch?v=6tXhETE7Whw&amp;list=PLx2OWCj5oxNMf0g1ggEzcboCzdYYFuXF6 * https://www.youtube.com/watch?v=kAbkFY6lwAY&amp;list=PLHJE4y54mpC5j_x90UkuoMZOdmmL9-_rg * https://www.youtube.com/playlist?list=PLTEcWGdSiQenl4YRPvSqW7UPC6SiGNN7e 
How does this compare to Clang's static analyzer, that is already integrated in Qt Creator and does not impose strange requirements on the user?
Damn, this one pretty sucks a lot. Another reason why trailing return syntax must be used only when necessary. Coming from C a very long time ago, I still like (but not doing it) the return type on its own line std::vector&lt;std::string&gt; split(const std::string&amp;s) { }
There's still a big issue left: storing functions. Using a static/global approach works for multiple calls with the same type. But sometimes these callbacks are stored away for later. I ran into this when I was playing around with some code that created a lightweight interface system for interfaces with only one function. This was an intro for something to play around with when reflection and reification come in. If you don't care about a motivating example, skip to the end. Here's what I believe you could potentially do to use an OO interface style for single-function interfaces in C++ with reflection and reification, and a couple general improvements: // Alternatively, a handwritten single-function interface. using IFoo = Interface&lt;"do_foo", void(int)&gt;; // Poor-man's DI. Example of no dependencies in impl. auto impl_type = implement&lt;IFoo&gt;.with([](int i) { std::cout &lt;&lt; i; }); using FooImpl = decltype(impl_type)::type; Bar bar(FooImpl{}); // Bar has a dependency on IFoo. // Boost.DI. Example of dependencies in impl. auto injector = boost::di::make_injector( bind&lt;IHandwritten&gt;.to(third_party_foo), di::bind&lt;I1&gt;.to&lt;Impl1&gt;(), di::bind&lt;I2&gt;.to&lt;Impl2&gt;(), bind&lt;IFoo&gt;.to([](dependencies&lt;I1&amp;, I2&amp;&gt; deps, int i) { auto&amp;&amp;[i1, i2] = deps; std::cout &lt;&lt; i1.do_thing() &lt;&lt; deps.call&lt;I2&gt;(i) &lt;&lt; i; } ); // DI library wires all the dependencies. // The extra deps parameter is stripped away in the impl type. auto bar = injector.create&lt;Bar&gt;(); /* Other ideas for dependencies: void impl(I1&amp; i1, I2&amp; i2) { return [](int i) { ... }; } void impl(I1&amp; i1, I2&amp; i2, int i) { ... } */ Note how well this integrates with existing code: - Because the generated interface is identical to a handwritten one, you can gradually change them. - Because the implementation class is identical to a handwritten one, you can change them. - Since this works with more than just lambdas, you can use a third-party function to implement an interface, allowing you to more easily stub out (part of) a library. There are also advantages to doing this instead of passing functions: - The interfaces are named rather than being based purely on the signature. - It can interoperate seamlessly with an existing DI library. Functions can declare dependencies on existing interfaces in a lightweight manner. The way this would work, and did work in my initial experimentation (where the lack of reflection and reification meant my interfaces were standardized to use `operator()`). --- ## So what's the catch? Local classes can't access parameters. Obviously, the local class implementing the interface must call the given function. Here's what would go on behind the scenes: template&lt;...&gt; // Infer from below auto implement_interface(F f) { class Implementation : Interface { Dependencies&lt;Deps...&gt; _deps; public: Implementation(Deps... deps) : _deps{deps...} {} Ret unreflexpr(single_member_function_name_m&lt;Interface&gt;)(Params... params) { f(_deps, params); // UH-OH } }; return TypeHolder&lt;Implementation&gt;{}; } The dependencies go into the constructor, which is the usual place for them. An appropriate member function delegates to the given one. The problem here is that `f` isn't available for the local class to use. This is the same problem as trying to convert a capturing lambda to a function pointer. So what do you do? You copy the parameter to a static local variable. This works per unique set of template parameters, but it's pretty easy to run into more than one set of the same parameters. The real problem is that the generated member function is called after both implementations are created. Thus, both implementations will use the same data and actually behave the same! There are three main ways you could fix this, and they all kind of suck: - Keep a static local to count calls to this instantiation and assert at runtime that it is called no more than once. User can't always have more than one implementation. - Make the user pass a unique tag. This works if this particular function call to create the implementation type will occur only once. If, for some reason, the user had this in a loop or in a function called more than once, then the same tag would be used. Also more work for the user. - Use magic. Remove all pain from the user and torture the compiler into turning a runtime value (how many times this instantiation is called) into a compile-time type (a unique tag type). Assert at runtime when passing a hardcoded max calls per instantiation. Since this is before the TL;DR, I should note that without reflection and reification, this approach to lightweight interfaces becomes much less useful. In the end, I discovered a different way to interoperate with Boost.DI and could instead use a tagged `std::function` as an interface type, with the implementation being any type that function can store, plus a middle man to handle wrapping a function with dependencies in a function without any. I'm pretty happy with it. ## TL;DR: Here is the magic and torture that can force the compiler into calling a function and passing a parameter with a unique type every call, up to a limit: http://melpon.org/wandbox/permlink/yaCfvG68E3pUdQv8 I have a utility called `make_function_pointer` that turns a callable into a function pointer and uses black magic to work properly for up to 100 calls (which is around where the compiler goes from having a good time to erupting in flames really quickly). I also have a broken version that uses a simple local static that will be unique per instantiation. I have a helper function that stores a lambda for later and captures a given integer parameter. Calling this helper function twice causes the same instantiation to be used when creating the function pointer, invalidating local static state (and the post's injector). The black magic one continues to work because of a helper that forces a unique instantiation based on the runtime value of how many times this instantiation has been called. std::vector&lt;FPtrType&gt; saved; void store_function(FPtrType f) { saved.emplace_back(f); } void call_saved_functions() { for (const auto&amp; f : saved) { f(1); f(2); } } void store_printer(int state) { store_function(make_function_pointer([state](int i) { std::cout &lt;&lt; "Printer - state: " &lt;&lt; state &lt;&lt; ", i: " &lt;&lt; i &lt;&lt; "\n"; })); } void store_broken_printer(int state) { store_function(make_broken_function_pointer([state](int i) { std::cout &lt;&lt; "Broken Printer - state: " &lt;&lt; state &lt;&lt; ", i: " &lt;&lt; i &lt;&lt; "\n"; })); } int main() { store_printer(5); store_printer(6); store_broken_printer(7); store_broken_printer(8); call_saved_functions(); } Output: Printer - state: 5, i: 1 Printer - state: 5, i: 2 Printer - state: 6, i: 1 Printer - state: 6, i: 2 Broken Printer - state: 7, i: 1 Broken Printer - state: 7, i: 2 Broken Printer - state: 7, i: 1 Broken Printer - state: 7, i: 2
&gt; Visual studio is the gold standard I find VS really subpar in contrast to QtCreator, especially for C++, but to each his own I guess
Typocally using a free engine is recommended over making your own when starting out, because game development can be complex (and frustrating ) process for those starting out. And you will know better what to code for an engine later. However, if you really enjoy coding itself, engine can be as good place to start as any. 
&gt; diff with clipboard in debugger tab could you explain a bit more ? seems useful but I can't see exactly what it is.
Just imagine how your code would look like if you added 2 lines in every source file for every "potentially good service".
You have only declared a const pointer (or reference) to a const int which means that you cannot modify the value by writing through that pointer. It doesn't change the constness of the referenced address, so when you assign a new value to col.red elsewhere you have (arguably) invalidated the pointer. As /u/rcoacci said, if you want to cache the current red value then you want a copy of the value.
I don't understand the hype either. When I last tried clion, it felt like a reskinned version of eclipse. Except that a bunch of cool eclipse features were missing.
Thanks! 
Thanks!
How would you suggest this be spelled? This reminded me of gcc's always_inline feature, so how about: __attribute__((always_vectorize)) Can you think of cases where the optimizer might conclude that it should *not* vectorize for best performance? E.g. if it can statically see that an array is only 4 elements, or something like that?
That's still accessing the object all the same. You'd need to do: T obj; memcpy(&amp;obj, buffer, sizeof(obj)); Nobody would write this though.
 There might be some situations where vectorization would be worse, but I'd rather the compiler leave it up to the programmer to make that decision. Perhaps it could emit a warning if it thinks vectorization would produce inferior results. I'm not so concerned with the spelling, as I'd just stick it behind a macro anyway. Your suggestion looks fine to me.
FWIW, we're about to get a bunch of [algorithm support](http://en.cppreference.com/w/cpp/experimental/parallelism) where we can tell the compiler to vectorize it.
That's just a trick - how to determine inappropriate behaviour. E.g. someone might think that if he throws some wrapping on the street it is not a big deal. The street is still almost clean, but what if everyone will litter everywhere? We will live in the mud and suffer from the plague (like it used to be a few hundreds years ago). So we can conclude that littering is inappropriate. The same logic can be applied for the adding 2 lines of comments. Should you like to use g++- please add 2 lines of gcc ads, the same for clang. Want to run cppcheck, use boost or editing in Emacs? Please make ads for all of them in your source files. Someone in your team prefers vim, someone Gedit or Notepad++? Add lines for all of them. And yes, are are free to add some code after a few hundreds lines of advertisements. Fortunately for us this crazy idea came to only their heads. But we shouldn't support inappropriate behaviour of anyone if we still want to live in civilised world.
Yeah, don't even touch the qt specific stuff
&gt; InteliJ based IDEs will be slow even if coded in C++, nothing to do with Java. Care to back this claim up?
Maybe the goal is to only highlight the built-in types and not the library types.
Yeah, it'll be good, though!
 Unless those algorithms guarantee vectorization, I fear they will be no more useful than the current auto vectorization :/
Just because C++ allows for bleeding edge execution speed, it doesn't mean it will happen if the code is written poorly. I have seen my share of not using the right algorithms or data structures for the applications, thus leading to lots of slow down, caused by cache misses, memory fragmentation, quadratic complexity, UI freezes and application crashes. Proof are IDEs like Visual Age for C++, CodeWarrior and quite a few others that were also written in C++.
You need an object for lifetime to begin. Objects are only created with definitions, new, via a union, and temporaries. Otherwise something like `alignas(64) char buffer[1000];` could be said to begin the lifetime of an infinite number of PODs simultaneously.
&gt;We fixed that the run button could spuriously stay disabled after parsing QMake projects. Oh gawd, I'm not crazy then. lol
Even if a library has multiple `.cpp` files, they can be easily added to a project as source files, without having to build an explicit intermediate static library target. The next logical step is to have an amalgamation of the sources into a single `.cpp` file, to make it easier for users to include in their projects. That's what sqlite does, and it makes most sense.
&gt;set -XX:CompileThreshold to a value close to zero or even 0 Thank you very much for that tip
The real issues in a serious IDE are: * Lexer * Parser * Code analysis So the advantages of C++ is manual control, since lexer/parser generates _a ton_ of temporary object, which explains why some managed IDEs spend 50% of the time on GC. Code analysis is to a degree parallizable, so C++ is a benefit only if you are targeting specific hardware (e.g., Xeon Phi). I write my programs with Xeon Phis in mind, but other people do not. I could go into GPU/FPGA land here, which is also unmanaged C/C++ (to some degree) but I guess I'd alienate the 0.0001% of people still reading this comment.
yea, I was getting this problem too. you aren't crazy lol.
I don't see where writing a `SomePod` is required, the only requirement is that "storage with proper size and alignment is obtained". This code does the same thing that `SomePod* p = static_cast&lt;SomePod*&gt;(malloc(sizeof(SomePod)));` does, which is obviously valid.
 Either you did not read, or did not understand the post... As I mentioned above, we already have /Qvec-report:2 on MSVC, which is superior to grepping about, but which is still insufficient. Currently I use intrinsics for vectorization, because auto vectorization can't hold its weight, but it would be nice to occasionally be able to use the auto vectorizor for semi-performance sensitive code. Obviously for highly performance sensitive bits I will still have to write it in intrinsic form, as c++ does not support many operations which are available in intrinsics. 
Would probably be better served as a C++11 attribute on the for loop: [[msvc::always_vectorize]] for (...) { ... } But otherwise seems a reasonable approach.
With libclang? I just checked and it works here with Qt Creator 4.1 (both . and -&gt;). Are there any circumstances when it doesn't work?
How long has it been since you have used it? In a windows environment it is lightning fast with intellisense, autocomplete, and other advanced analysis features. It also feels fairly polished in my opinion. 
&gt; It's a selectible theme, and there are different themes that can be selected by people with impaired vision or bad monitors. But if you do not *suspect* that there are different colors, why would you try and select another theme? I remember a few years ago, a colleague complained about the (in-house) tool we used to play our integration tests a lot. Well, we all complained about it, so nobody really paid attention to his rants... until one day as I was investigating an issue with him, and after playing a ~50 steps test I saw him expanding each step one at a time looking for the step that failed. WAT? The failed step is red, the others are black! Easy! Well, said colleague was a daltonian. No red cones. He perceived red as black. He never even *thought* that the software was able to identify the failed steps. A quick bug-report, and a few months later an icon was added (tick vs red-cross); his productivity while investigating test issues soared!
This works just fine for me, even inside a Catch test SECTION.
Well C++ did require copy ellision &gt;since C++17 &gt;Under the following circumstances, the compilers are required to omit the copy- and move- constructors of class objects even if copy/move constructor and the destructor have observable side-effects: &gt;In initialization, if the initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination, the initializer expression is used to initialize the destination object: &gt;In a function call, if the operand of a return statement is a prvalue and the return type of the function is the same as the type of that prvalue. [source](http://en.cppreference.com/w/cpp/language/copy_elision) Copy elision and vectorization are optimizations. Although I don't know if C++ defines SIMD... so I don't see any way it could be required without having to introduce SIMD. But implementation of which SIMD used would likely be up to the compiler writers as it knows the target machine so it knows the fastest SIMD instruction set available.
I think it's possible to distinguish between when the compiler's heuristics say vectorisation isn't beneficial, vs. it would like to vectorise but cannot for some reason, in which case that would be a warning or compilation failure under this attribute. This does seem like a legitimate concern when a seemingly minor refactor can make a previously vectorised loop fall back to scalar. Seems like the Intel Compiler has some controls already, although they are more about forcing vectorisation than leaving heuristics and precondition analysis alone but telling you when they say "no". #pragma ivdep #pragma vector always #pragma simd https://software.intel.com/sites/default/files/m/4/8/8/2/a/31848-CompilerAutovectorizationGuide.pdf 
The standard already has pecedent; `std::atomic&lt;T&gt;::operator=` returns by value.
`/Zc:wchar_t-` represents everything that's wrong with unnecessary, stupid, evil complexity. If you use it, your code is bad, and you should feel bad.
... which I consider a perfect example of "specious value".
You're not wrong, but then again, not all of us are *masters of our source code domain.* If you know what I mean...
Or your code is maintaining binary compatibility since the days of msvc5 or earlier. The "your code is bad and you should feel bad" part may still apply in that situation though.
I'm sorry, but there's no real proof here that you aren't crazy in general.
Oh, yeah. That would be nice, but probably unlikely. I don't think there is the demand for that. 
I use it every day. I've been using VS since version 6, I think, way back when it ran fine on 16Mb (yes, megabytes) of RAM. It works well enough, but the level of bloat it brings with it is utterly unnecessary, and some of its behaviors (e.g., the algorithm of adding references to .NET projects, which is O(n^2)) are clear-cut examples of *terrible* engineering practices. The RAM consumption of Visual Studio is also terrible in light of Roslyn which you cannot even turn off, so it takes up ~600Mb RAM even when you don't really need Roslyn if you are using ReSharper. Regarding IntelliSense, it's better now, but in the 2008-ish years, the situation with C++ IntelliSense was *terrible* -- it got so unreliable that one would have to regularly delete the NCB file just to get it to work. Plus, actual reliability of IntelliSense was never 'great', it would frequently miss things. And BTW, IntelliSense *is* autocomplete. As for 'advanced analysis' things, unless you are talking about ReSharper C++ (which is *not* Visual Studio proper), there's actually very little and, furthermore, the amount of spurious code analysis garbage that VS throws when your project compiles with an error is quite simply bewildering (and blatantly unnecessary).
**Company:** Morgan Stanley Canada **Type:** Full Time **Description:** You will join a team that is responsible for infrastructure development to implement core C++ libraries and tools for our low-latency algorithmic trading platform. Our extensive platform provides other developers inside Morgan Stanley with all the functionality they need to build high-performance and reliable trading applications. Our libraries are used daily by hundreds of developers across Morgan Stanley. **Location:** Montreal, Canada **Technologies:** C++11/14, Linux, python, FIX, **Contact:** https://ms.taleo.net/careersection/2/jobsearch.ftl?lang=en **Job Number:** 3078885
How much vectorizing needs to happen in order to not be a compile error? I'm not sure how you would really accomplish something like this in practice. As long as it uses a SIMD register somewhere in the function with the pragma, it can say it vectorized it somehow, and pass the test, regardless of whether there was any performance benefit, or even if it had to make it slower to meet the requirement of using vectors.
Have you filed a bug report?
This really should be on /r/cpp_questions. I'm not sure I understand the question either: do you want to parse the input or assemble a random sentence and output it?
Just to get you started, you can't define a string "as x or x". You'll need to compare your value using `if`. When you end up with too many `if`s, you'll probably want to put the possible values in a `vector` and loop through it.
Bet if you have a SSD the speed difference will be drastic.
http://doc.qt.io/qtcreator/creator-clang-codemodel.html This page says that to use the plugin Qt Creator needs to be built from source, but I'm quite sure that 4.1.0 comes with the plugin, it just needs to be enabled in Help/About plugins
!removehelp
Found it. But (as mentioned in the bug report comments) while code completion works, following a symbol does not. Let's hope this bug gets cleaned up soon.
The concept of coroutines is very clear to me, having used them in large scale projects in Python an C#. I just long to have them in C++, so I studied thoroughly Gor Nishanov's proposed specifications, reaching a good understanding and getting to like them very much. I also found time to experiment with coroutines in Visual Studio. Yet, I too find it difficult to get the point of this article. In particular: why should I care if that thing is UB?
What about just using SSE intrinsics? If you want vectorization that is probably the best way to convey it to the compiler, and will probably always be the best way. The thing is even if you can guarantee that a compiler does auto vectorize a loop, you can't be sure that it will do a good job. For example try comparing a hardcoded scalar product for size 4 float vectors, vs what the compiler generates even with all the optimizations on. It just is simply not as good. 
_Everyone_ forgets about this; it's really a good thing it doesn't matter in practice.
Well, the C++ part has pretty much been answered by the cppreference.com link.
Implicit conversion from an enum has been answered. Implicit conversion to an enum wasn't.
Actually, lifetime of objects with trivial constructors begins when a sufficient amount of properly aligned storage is allocated (http://eel.is/c++draft/basic.life#1.1). It seems to me that OP's snippet is not fundamentally different from calling malloc() and then using the returned pointer to store a C-like POD struct. EDIT: Actually scratch that, I based my reasoning on the older C++11 standard but it seems in later standards the wording has been clarified.
From the same cppreference link: &gt; Values of integer, floating-point, and other enumeration types can be converted, such as by static_cast, to any enumeration type. The result is `unspecified (until C++17)` `undefined behavior (since C++17)` if the value, converted to the enumeration's underlying type, is out of this enumeration's range. It doesn't explicitly state that there is no implicit conversion, but it would be strange for them not to mention it if there was one. (Still, would be nice to have it confirmed by a "language lawyer").
That an interesting and piquant piece of legal nitpicking! But, since C is a subset of C++ (or mostly so) then those C functions could also be considered (i.e. compiled as) C++ "language" functions and this whole hypothetical problem goes away. In any case, what you say pertains (in principle) to any function pointer (from a lambda or not) coming from a C++ linkage function. It has nothing to do with "smuggling" state into such functions which is the actual subject of the article. 
you could also grep http://en.cppreference.com/w/cpp/language/implicit_conversion for enum: int to enum is not there, while enum to int, enum to float, and enum to bool are. Note also that C++17 makes enums with fixed underlying initializable from ints without a cast if you use direct initialization with curly braces
Oracle Studio doesn't forget
Great article. With [some C++17 magic](https://vittorioromeo.info/index/blog/checking_expression_validity_in_place.html) you could do this: template &lt;typename T&gt; struct StorageImpl : Storage { T m_t; StorageImpl (T t) : m_t {std::move(t)} {} void docall() override { if constexpr(IS_VALID( _0.foo() )(T)) { m_t.foo(); } else { foo(m_t); } } }; I still strongly believe that UFCS should be introduced into the language, as it would make it **much** more expressive. Think about composing operations on ranges, or implementing monadic continuations on `std::variant`, `std::optional`, `std::future` *(etc...)* as free functions. What you currently have to do is either: 1. Re-implement the class you want to extend in order to provide member functions. 2. Deal with unreadable syntax: then( then( then(x, f0), f1, f2))) // ... 3. Use operator overloading *(e.g. use `operator|` as "pipe")*
&gt; By specifying the “contextType” for a given task to equal “build”, “clean” or “rebuild” you can wire up the VS build-in commands for Build, Clean and Rebuild that can be invoked from the context menu. So, just to confirm my understanding, if we make `build2` generate `.vs\tasks.vs.json` with appropriate tasks, then the user will simply be able to open the directory in VS and it will work more or less the same as if building via `.vcproj`? If that's the case, then, yeah, I think #1 reason people advocate CMake has just become `NULL` and `void`. Exciting times...
Yes. Not exactly the same behavior but similar enough. Now the question is do Visual Studio Code support the same `.vs` system ? 
Why is that considered to be a bad thing that is worth avoiding? I mean, by definition PODs are free to construct, so constructing an infinite number of them is still free.
C++17 as a whole has been *incredibly* disappointing. Not just f(x)-&gt;x.f() UFCS was lost (easily the most important feature lacking in C++), but we're also not getting modules, concepts, coroutines, or ranges. If it weren't for structured bindings, I'd probably skip moving my codebase to C++17 and wait for C++20. The C++ committee has grown too large and divisive to pass even simple changes anymore. A culling is long overdue.
Or write your own allocator. 
You should almost never have to switch to an array for "more control". The primary reason to switch to an array is that you want to the data allocated on the stack instead of on the free store (heap). In that case, you usually want to switch to `std::array&lt;T&gt;` rather than using a built-in array directly. `std::array` is guaranteed to be an aggregate type, which basically means that as far as code generation goes, it will normally be essentially identical to a built-in array type. At the same time, it provides some *really* handy capabilities, such as a `size` member that tells you its size in elements (rather than bytes, as `sizeof` would).
Maybe this is a minority opinion, but I think the error was allowing TBAA in the first place. Consider the large number of project that use the `-fno-strict-aliasing` flag. We've tried removing it from our product, but found no speedup, so it doesn't seem to be buying much at least for our use cases. I think a better solution would be to allow a rich set of non-aliasing hints, kind of like `restrict`, but with more flexibility. For example, it would be nice to say that two specific pointers don't alias each other, but may alias any other objects. Or that a member pointer may alias other pointers, but will never alias `this` (like the pointers in std::vector). I don't think these annotations would be all that common outside of core libraries such as the std containers and other code that has been profiled to show that the codegen can be substantially improved by these hints. I guess my main issue is that it seems like TBAA is in a category of optimizations that may add low % perf improvement, but makes it harder to do the bigger optimizations in source when it really helps. Things like using mmap or shared-memory with structs, or putting objects in raw buffers on the stack, seem to be increasingly illegal based on the letter of the standard. I think the strict aliasing rules also makes things like calling a JITed function UB strictly speaking, and I'd bet JIT offers far more perf improvement than TBAA.
I am honestly impressed, the amount of PVS Studio promotion in the past made me weary, but this is a great compromise, and the tool finds an awesome amount of potential bugs, far more than any free VS-compatible analyzer I've tried. A lot of the "bugs" found are not really bugs, but I'd much rather have a lot of false positives than not enough.
That is a valid point, and would make sense if you had a lot of assembly developers whom you wish to build a bridge to, who thought in assembly, but didn't quite understand the complexity of C.
&gt; void foo( int arr[static 10] ) {} Is this standard C++? I tried on godbolt with gcc 6.2, it was rejected at C++11, C++14 standards.
(A bit out of topic : if you like Massif, check [Heaptrack](http://milianw.de/blog/heaptrack-a-heap-memory-profiler-for-linux) : it's awesome.)
C++ caters to a lot of different sort of users. So it has to offer different tools, for different job. Having a screw driver and a hammer in the same box just means that you have to know when to use each. I don't think there are useless or dangerous or over the top features in C++. but you don't have to use them all 
If you are lucky, you don't even pay for the virtual function ;) https://godbolt.org/g/mpB3sa
[This was posted yesterday](https://www.reddit.com/r/cpp/comments/5fuyqo/how_to_use_pvsstudio_for_free/), but was deleted. I'm curious as to why this one hasn't been deleted yet.
Can I ask what was the reason this wasn't implemented earlier?
If you wish to get rid of the restrictions imposed by a demo version, you may just [write](http://www.viva64.com/en/about-feedback/) to us fog get temporary license.
it's C11 or something?
I had send the mail, i didnt sent it before because i was trying the VS17 and want to make sure all the stuff is in there If you need more info ask for it and thanks to you, i really appreciate that you want to make it better
Hey, I just released v2.0.0 of guardonce. I originally built these tools a few years back to convert a bunch of closed-source projects to #pragma once. My reasoning was that if we could convert back at any time, I would calm a lot of fears about portability. Why did I even want to use #pragma once in the first place? I was tired of changing the include guards whenever I renamed a file. It was one small step to making refactoring a little easier. I also noticed a couple headers with identical include guards due to copy/paste errors. Actually, just using checkguard to ensure that all include guards matched the project's coding standard would have been handy every once in a while, even if I never switched. While I like using #pragma once within projects with well-defined supported compilers and platforms, I certainly don't think that everyone needs to switch to #pragma once. I'm quite pleased to see that the library has been useful for people wanting to convert in either direction. This was [previously submitted](https://www.reddit.com/r/cpp/comments/584xj6/guardonce_utilities_for_converting_from_cc/) about a month ago, but the v2.0.0 release is a major overhaul. This new release was a work-in-progress at the time, and it is so much better that I wasn't planning on telling anyone about the project until it was done. Finding the project on the front page of /r/cpp was a surprise. The new release is much easier to use than v1, so I hope people find it helpful.
Also, in C++14 using [`fit::conditional`](http://fit.readthedocs.io/en/latest/include/fit/conditional.html) you can easily write this: void docall() override { fit::conditional( [](auto&amp; x) FIT_RETURNS(x.foo()), [](auto&amp; x) FIT_RETURNS(foo(x)) )(m_t); } This avoids all the `void_t` boilerplate.
I'm interested in hearing about other tools that people use. For example one thing that I use that's missing from this list is ccache. Also it doesn't seem to list profiling tools (perf?).
Modules, concepts and ranges are huge, but UFCS is meh and doesn't really bother me much. I'd never use it anyway.
That was disappointing. I watched the whole thing hoping that I would learn something neat/new/redeeming about a feature I don't care a lot about. If you want to waste my time, fine, this is reddit, but in my /r/cpp at least say so up front.
You can name your own variables/types override or final, I think. The committee rarely adds new keywords lest it break existing code. In this case, the grammar guaranteed that it would be safe to introduce these new pseudo keywords after the function declaration.
I wouldn't be surprised if that's part of the joke.
It exists in all major vectorizing compilers. `#pragma simd` in Intel, for example.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/5fq2gg/looking_for_a_good_book_or_online_resource_for_c/dapzme6/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. a C++ question or homework related. Help posts are off-topic for r/cpp; this subreddit is for news and discussion of the C++ language only. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/5f4hkj/rambling_longwinded_question_about/dapzqdh/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
C99
List of C/C++ static checkers I've tried, all are free for, at least, published open source projects (some with an additional non-commercial and/or individual dev condition): * PVS-Studio * cppcheck * clang-tidy * /analyze of msvc * sonarqube.com * scan.coverity.com (listed without any particular order) For now it would be hard for me to strongly prefer one or the other, at least because I did not found any bug with any of these in my project. The false positives are usually not too numerous. Some might be a little too much opinionated by default about random style elements for my taste, but that usually can be tuned. 
Hey, can anyone explain what the: flag ? true : false Means? I've never seen it with c++ in my school
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/).
[I know it as a conditional operator](https://en.wikipedia.org/wiki/%3F:#C.2B.2B) but there may be other names. Its purpose is to assign a value depending on some boolean flag, taking second or third operator. It's quite useful in situations where you can't simply use if/else, e.g. initialize a variable of type without default constructor. In this case it's pointless because flag ? true : false assign true when flag is true, hence it's equal to: flag A more useful example: int result = isSparse ? solveSparse(matrix) : solveDense(matrix);
To an extent, anyways. flag ? foo(x) : bar(y); requires `foo` and `bar` to have the same return type. This is because the entire expression needs to evaluate to a particular type. In that case the above is a direct substitute for if(flag) { foo(x); } else { bar(y); } but the conditional operator (sometimes the "ternary operator" since it's the only operator with three parts) also allows you to set `const` variables to a non-compile time determinate expression, eg, const int value = flag ? foo(x) : bar(y); where an `if`/`else` would require `value` be non-`const` or would require you to build a function that's just `if(flag) { return foo(x); } return bar(y);` so you could use `const int value = my_func(flag, x, y);`.
Not quite - the rules for converting return types in the conditional operator are complicated, but they don't have to be the same.
The talk lets you in on the joke like 30 seconds in and it's 5 minutes in total. I don't know what kind of time you were wasting. Were you pausing and taking notes? 
Please read the sidebar, beginner questions are off-topic in this subreddit.
!removehelp
You must be fun at LAN parties. 
Among CI services there's also [tea-ci](https://docs.tea-ci.org/usage/overview/).
Quite a few years ago, viva64 posted quite a number of articles on the bugs found on open-source projects and stated open-source projects can get a free license. I requested for one but told to write a article to promote PVS-Studio with no criticism allowed and that article is to be fully vet by viva64 before publishing. Is that still the case now?
I also posted on the C++ Enthusiasts Facebook page where viva64 employees are active. It also got deleted without good reason. Too much of a coincidence, I must say.
Makefile -- probably not. But think of a build system (like `build2`) that handles compilation using the VC++ toolchain (`cl.exe`, etc) natively. Said build system could auto-generate all this integration so that you can develop (cross-platform) projects that don't use `.vcproj`/MSBuild but with native Visual Studio IDE integration.
What I'd really like to see is an operator.. or chaining operator. Often times you want to do a series of operations on an object in sequence. But other times, you care about the return value. So currently you have classes that are mostly: object&amp; object::replace(...) { ...; return *this; } And occasionally: bool object::trim(...) { ...; return didTrim; } But now you can't chain object.trim().replace(); And it's also annoying needing to return *this; from most functions. But what if you had operator.. which meant, "discard the return value, and instead return a reference to the object" (constant reference if the object is constant)? Now you could say: if(a.trim()) a = b..trim()..replace(); In this way, we don't have to repurpose the pipe operator, which is still incredibly useful for integral types. And no additional code needs to be written to use this. operator.. could be an implicit language feature available to all objects.
Thanks for the information. &gt; CMake support is a bit different because you don't need a build to bootstrap the experience [...] The `tasks.vs.json` could already ship with a project if there is a way to determine whether this is a Debug/Release build, 64/32, etc. Are these somehow accessible via `${env.VARIABLE}`? My guess is probably not. Alternatively we could include a "bootstrap" `tasks.vs.json` which would define the `Configure` task which can be used to bootstrap a specific configuration (Debug/Release, 32/64-bit, Shared/Static, etc). BTW, have you thought about support for build systems that use the out-of-tree build model? That is, sources and build output live in parallel directory hierarchies.
Nice article, but which imbecile made the decision to have all links go through google first?!
You can compile ISPC to intrinsic C++.
I expect `operator=` to always replace values no matter what. For any other behavior you'd need some weird proxy class and that would be annoying to deal with and not at all intuitive to understand. I don't think the `my_map[key] = value;` behavior is quirky at all. I'd have thought more people would believe both outputs to be B. So, IMO it's the `insert` behavior I find quirky.
Sounds like some moderator felt I was using this news item to promote views of my CPPCon talks which address the issues raised in the news article. LOL - that's exactly what I was doing. I just didn't, and still don't, see anything wrong with this. It seems to me to be a common thing to me. see https://www.reddit.com/r/cpp/comments/5ebgmu/clion_20163_released_with_more_c1114_support/ and https://www.reddit.com/r/cpp/comments/5e8bgh/goingnative_54_whats_new_in_visual_studio_2017_rc/ but then I'm not promoting a commercial product and of course there's https://www.reddit.com/r/learnprogramming/comments/3xo4bo/i_made_47_free_c_tutorials_on_youtube_and_wanted/? I took a look at the reddit content policy here https://www.reddit.com/help/contentpolicy I don't see how my post falls into the "prohibited content" (spam maybe?). I don't see another guidelines specific to r/cpp. Never the less, I'm happy to reword/restructure it to conform to r/cpp standards - whatever they might be. So I'd be happy to receive any specific suggestions. Thanks 
`operator=` and `insert` should be thought of differently. For one thing, the former cannot be used if the `mapped_type` is not `DefaultConstructible` (because of its behaviour). Personally I prefer using `std::map::find` and `std::map::insert(_or_assign)` for lookup and insertions respectively. And I use `operator=` where I want the just-give-me-a-damn-object behavior (e.g. `input_stream &gt;&gt; my_map[key]`).
https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms633518(v=vs.85).aspx
Dear Visual Studio, could you please add a UTF-8 mode for MSVCRT so that functions like `printf` will accept UTF-8 encoded strings (`char*`) and print them correctly on the console (using `WriteConsoleW`)?
&gt; A class is a POD, if it's trivial, has a standard layout and all of its non-static member are PODs. The definition is quite concise It can actually be more concise, because the third clause is completely redundant. A trivial standard layout struct is POD. The definitions of trivial and standard layout already recurse on non-static members. Also, trivial is quite useful but standard layout is only useful under pretty specific circumstances. If you're going to write the struct into a memory buffer and read it back out in C, or in another language, or try to cast specific offsets from the start of the struct into members (which is almost never necessary). In most cases when you're writing pure C++ trivial is the most you need (often you only need trivially copyable). Trivial basically says that the class is just a collection of bytes; it's actually really very much like plain old data, the only thing it leaves unspecified is where the plain old data happens to reside within the class. The opening sentence of the article is quite misleading: &gt; Plain Old Data (POD) obeys the C standard layout. Therefore, you directly can apply the fast C functions memcopy, memmove, memset, or memcmp. In most situations of interest you can apply all of these functions to things that are trivial, POD is not required. E.g. you can copy an array of trivial classes to another array with `memcpy`. In fact, you only need trivially copyable, not trivial! 
I don't get it. What's the point?
To not have to do every time: mkdir -p src include and create manually a Makefile
Waaaat? I googled around, I can't find a link explaining this. Do you have a link, or willing to explain in a few sentences why this happened?
I was confused, `is_literal` was deprecated by [this paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r1.html). But we still don't use `is_trivial` or `is_pod` for dispatch, it's always `is_trivially_copyable`.
More or less - I believe the CMake support in VS still relies on generating `.vcxproj`s under the hood, not sure if they need them for intellisense, discovering build targets or something else.
&gt; UFCS breaks encapsulation How so? 
[There's no constructor](http://en.cppreference.com/w/cpp/string/basic_string_view/basic_string_view) for a `std::string_view` from a `std::string`, I suspect specifically to avoid this type of bug.
`basic_string` provides a conversion operator to `basic_string_view`, see N4606 21.3.1.7.1 [string.accessors]/7. That doesn't help when template argument deduction must be performed, but in this case, `f()` isn't a template.
Your particular example is fine, since the temporary `std::string` lives until the end of the full expression, which should be the end of the function call. 
The temporary lives until the end of the full-statement, which includes the entire duration of the function call. There's no boom in this example. 
I don't get it...what is the bug?
The point here is that after any write through a `char*` the compiler has to assume that all of the memory in the program has been changed (unless it can prove otherwise), and after any other pointer write the compiler has to assume that any read through a `char*` is different (and so it can't do store to load forwarding there). Reads and writes through `char*` get the special rules. Reads and writes through `T*` do not.
An exception is usually not appropriate for that case. If your program is designed so this is possible then it's not an exceptional condition and you should handle it within the normal execution paths. If it is "not possible" then you could document it using an assertion. If an exception is appropriate in some circumstance then there's nothing to stop you throwing one yourself. But this is very much a minority case so it would not be appropriate to make it the default behaviour.
Is there a way to declare how own types fullfil a concept, similar declaring instances of type classes in Haskell? Let's say I have written my own bounding box class and I know that bounding boxes fullfill the concept of a ``monoid`` under the operation of merging two bounding boxes: ``bbox merge(const bbox&amp; lhs, const bbox&amp; rhs)``. How would I specify that this function, together with the identity element (the zero bounding box) forms a monoid using C++ concepts?
C is not a subset of C++
!remove
Checks that the function is applicable and that there is something that is called 'identity' (there is probably a way to force a static const on it). Since we are operating on classes, I can't see how the actually useful things can be checked: that the identity value is really an identity or that the operation is associative. Stroustrup would probably call it too small to be useful (according to the video). #include &lt;algorithm&gt; #include &lt;iostream&gt; template&lt;typename T, typename Op&gt; concept bool Monoid = requires(T a, T b) { { Op::eval(a, b) } -&gt; T; { Op::identity } -&gt; T; }; struct bbox { unsigned int v; }; struct bbox_merge { static constexpr bbox identity = {0}; static bbox eval(bbox a, bbox b) { return {std::max(a.v, b.v)}; } }; void f(Monoid&lt;bbox_merge&gt; &amp;&amp;b) { std::cerr &lt;&lt; b.v; } int main() { f(bbox{3}); } [online compiler](http://coliru.stacked-crooked.com/view?id=8cb866cd37110309) First time I'm writing something with concepts.
This is the problem with concepts. They're **not** typeclasses or traits (Rust). I really don't like the idea of concepts being only syntax sugar for pretty SFINAE, only to give better error messages when compiling. It could've been designed so that really useful things (like what's done with traits in rust) were a possibility. And I believe the problem with error messages for concetps being worst in some cases is due this lack of specialization of concepts for types. Right now, you just write your types and there's no connection between a concept and a type. The only thing concepts do is check if a certain expression works for that type. It is just pretty SFINAE.
a typeclass describes the operations and traits of a type. For example, let Iterator be a typeclass that describes a type like so (gonna use concept syntax just for the example's sake): template &lt;typename T&gt; concept bool Iterator = requires (T&amp; self) { typename value_type; { next(self) } -&gt; std::optional&lt;value_type&gt;; }; In C++, there's no thing like "implementing" a concept. To use it you have to do `Iterator&lt;your_type&gt;` and it returns whether those expressions would compile. A typeclass has to be specialized, as in explicitly implementing that concept for a type. Typeclass above requires a type to say what `value_type` is and what `next` is. template &lt;typename T&gt; struct VectorIter { std::vector&lt;T&gt;&amp; vec_ref; }; template &lt;typename T&gt; impl Iterator&lt;VectorIter&lt;T&gt;&gt; { using value_type = T; auto next(VectorIter&lt;T&gt;&amp; self) -&gt; std::optional&lt;T&gt; { if (!self.vec_ref.empty()) { auto item = self.vec_ref.front(); self.vec_ref.erase(self.vec_ref.begin()); return { item }; } return std::nullopt; } } That's a stupid example, but my point is that the typeclass (concept `Iterator`) is explicitly related to our type `VectorIter`. Compiler has now more information about this relation and can reason about it in a clearer way.
Link to the proposal?
Yea, I've been ignoring concepts in C++ for a few years now, since the first proposal was ... confusing to say the least. Hearing Bjarne explain it this way makes it a lot more simple sounding and useful. Removing a lot of long/potentially complex boilerplate code you'd use to set up simple TMP deduction rules and reducing `enable_if` usage will be really nice.
Off-topic for this subreddit, please read the sidebar.
I try not to look inside GCC's implementation, but I do know a thing or two about Microsoft's implementation...
Please don't spam our subreddit with off-topic links.
This is part of the Document Foundation's ongoing efforts to rid LibreOffice of all Java dependencies and use only C++ in its codebase.
I dont see how that relates to C++, it only relates to LibreOffice. We cant very well have a post for every project that decides to use C++
&gt; for example almost all binary APIs written, even now, in C++ expose themselves as C still, because the ABI is standardized C has no standard ABI either...
Hmm, this confirms my concerns about concepts and is actually quite underwhelming. In my opinion, typeclasses (or traits) are really some strong points of these languages. Do you know if the proposed version is something like a stepping stone towards full-fledged typeclasses (similar to how structural bindings are a step towards pattern matching)?
I use crow for a small sql/json content server, it's pretty nice and stable.
Please read the sidebar, this is off-topic for our subreddit.
https://github.com/fffaraz/awesome-cpp
https://github.com/syslandscape/syslandscape logs, template engine and soon with session support.
It's all supposed to be taken in the context of "C++ Best Practices" and these are various tools at your disposal that you should be aware of and using if you have access to them. It is not meant to be an exhaustive list of all tools available.
https://github.com/mattgodbolt/seasocks Not a framework per se but a very light and well built C++ web socket server.
I am doing Assembly language 80x86 and they want me to write Assembly code that, "implements" what I just wrote in the OP. I assumed what they wrote looked like C++.
In C++ it isn't valid syntax. In Pascal, `:=` is the assignment operator.
:= is used in some programming languages to assign a value to a variable. In your code, when you write the expression "count = 0" you are saying if the value of the variable count is equals to 0. (Comparison) However in the later statement, "count := 0" you are saying that you want to give to the count variable the value 0. (Assignment)
Sorry, it was suppose to be count := value. Thank you for the explanation of := though!
I think names starting with two underscores are forbidden by the standard, aren't they? Maybe not the best example you gave there ;-)
Why do you think a C++ web framework you've never heard of is going to struggle less than Django?
If I wanted this kind of two-tiered structure, I could implement it with C++ concepts (http://melpon.org/wandbox/permlink/WPBdDONVMFUx9sVX). First define the `Iterator` concept: template &lt;typename T&gt; concept bool Iterator = requires(T&amp; t) { typename T::value_type; { next(t) } -&gt; Same&lt;std::optional&lt;typename T::value_type&gt;&gt;; }; and then a mapping `IteratorMap` to map types to "concept implementations," and a concept `Iterable` to describe types that have a valid mapping: template &lt;typename T&gt; class IteratorMap {}; template &lt;typename T&gt; concept bool Iterable = requires(const T&amp; t) { requires Iterator&lt;IteratorMap&lt;T&gt;&gt;; IteratorMap&lt;T&gt;{t}; }; It requires some more explicit syntax than your description of Typeclasses, but functions can easily accept `Iterable` types and perform the mapping to `Iterator` directly: Iterable{T} void print(T const&amp; t) { auto imap = IteratorMap&lt;T&gt;{t}; while (auto i = next(imap)) { std::cout &lt;&lt; *i &lt;&lt; '\n'; } } So, as someone who has a rich understanding of C++ concepts and no knowledge at all of Haskell Typeclasses / Rust traits, what's lost in this translation?
&gt; what's lost in this translation? Error messages can still get tricky and worse, as the compiler still has no way to better reason about the relation between a concept and a type. And honestly I have to say it is so much tiring and misleading to write something like your translation. Instead of improving, it is just making things worse. edit: please, don't just downvote. Elaborate on your criticism. This is r/cpp, not some other shitty subreddit.
This is one I wrote https://github.com/KayEss/mengmom It's used in a few places, but should be much better. Got an improved one in the design phase, just need some time to work on it
I'm a long time Django user -- since before the 1.0 release (I organised the 1.0 release party in Bangkok). I think that many like me feel that Django no longer is trying to solve the sorts of problems that we need to solve on web servers. Since the advent of good single page JavaScript the web server is now relegated to API server and Django just isn't a great fit for that any more. I've been working on my solution, [Fostgres](https://github.com/KayEss/fostgres), which is really an experiment in "web APIs as infrastructure". It's a very thin wrapper around the facilities that Postgres provides and just tries to get out of the way. Instead of writing web APIs you configure how data matches the tables you're using. You can build entire CRUD applications with nothing else, and where you do need back end processing you attach it to Postgres' LISTEN/NOTIFY and do whatever you want in any language you care to use. The advantage here is that Fostgres (not yet optimised) is about 100 to 1000 times faster than Django for the same requests -- it's currently about twice as fast as psql, and I'm sure with the right work can be ten times faster still. Configuring a SELECT statement is also a lot faster than writing a Django view, and you don't have an O/RM getting in your way, so the full power of the database is also available to you. So, I see Django as improving -- it's better than it used to be (the overhaul of the transaction handling was well overdue and a big improvement) -- it's just that the direction it's improving in is largely irrelevant for the sorts of problems that I, and many like me, need to solve.
That's STL I was responding to! The maintainer of the Visual Studio C++ Standard Library. When names starting with two underscores are reserved, it's so that *he* can use them. But you're right. I've changed my example and I added a section in the docs to remind people of the rules for choosing valid identifiers.
That sounds challenging and ridiculously fun
I like the thought of embedded, but I'm not much of an electronics guy. Is there any decent reading on doing some embedded stuff from a more desktop dev perspective?
I don't see what is toxic about a respectful, technical comparison, without name-calling and groundless claims?
Used this (and readerwriterqueue) in its various guises for a couple of years. Reliable, well documented and fast. Just need Cameron to submit it to boost or the standards committee! Take a rummage around his github as well for the single producer/single consumer queue and microbenchmark.
No, it's merely that `std::string str; str = "Foo"` is stupid. If you write stupid code, you deserve it to be slow.
MinGW and Cygwin are not compiler themselves, these are just toolchains. You can then select clang or gcc from whichever you've configured, if you have them installed from MinGW/Cygwin.
The concept is brilliant, although I used my own, I think much simpler, implementation. http://cpp.sh/3f4nn
As has been noted elsewhere that is not the default theme. Colour themes are notoriously subjective - and CLion has a lot of options for customisation. Personally I quite like the lower contrast themes - but I'm fortunate enough to not had colour-perception issues. A new feature relating to colour is Semantic Highlighting, which gives different variables their own unique colour so you can more easily see the flow of data through your code (although, admittedly, the defaults there often lead to low contrast differences).
Well is a big jump from an Java based database to a C++ RDBMS and that brings a lot of benefits to the LibreOffice Base http://www.ahunt.org/2013/09/lo-embedded-firebirdhsqldb-performance-comparison/ 
You will note that my version does not allocate anything. If you just take the iter::eraser() code it is also about the same length.
I should have phrased it this way: I couldn't understand your implementation, so I used my own :P (in particular, the next 30 lines after this: https://github.com/dtrebilco/Taren/blob/master/Iterator.h#L137)
The article fails to mention that you cannot move from a variable marked as const, and instead the copy-constructor/assignment will be invoked more often. So spraying const-glitter all over your variables may do you more harm than good.
That is just the std::remove algorithm http://en.cppreference.com/w/cpp/algorithm/remove I threw in a std::is_pod to remove a branch on non-complex types
@What @are @you @trying @to @say? 
Right, your example was tailored to STL ;-) Then it would probably have been best to mention that, so any other reader doesn't take it as a general example that they should follow. Maybe I'm nitpicking a bit here but I do think it is important to not spread code snippets and stuff around the internet that would be wrong for 99% of the people so I do think the "disclaimer" is important. Anyway - Great tool you got there! :-)
The compiler can't see the definition of `eat(int const&amp;)`. When `eat` is passed a non-const variable (by const reference) the compiler has to assume that the definition of `eat` could modify the variable using const_cast. However if the variable was initially declared as const then modifying it using const_cast is undefined behavior, so the compiler assumes `eat` doesn't do that.
Interesting, thanks! I didn't consider const_cast
&gt; Doesn't that violate the C++ standard? Doesn't what violate the standard? EDIT: The optimization shown in the link is purely due to the first point, not the second.
In "How to dequeue types without calling the constructor", please recommend using std::optional, instead of using memcpy.
The bug I'm talking about is already reported. In template code, everything that is a dependent type nearly has no completion. If you do something like that: template&lt;typename T&gt; struct SomeType { T value; }; template&lt;typename T&gt; void test(SomeType&lt;T&gt; t) { // write `t.` here, no autocompletion about t, I expected the IDE to propose `value`. } Additionnaly, emplace back in vectors is barely autocompleted, as other methods are clearly recognised. And I recently reported a bug about template aliases not being hightlighted. My code use a LOT of them, so I barely got highlighting. The other problem that I need to refresh the file is when I made changes elsewhere that fix an error in a particular cpp file, it can take quite some time for the parser to remove the error highlight. Maybe I'm too impatient. I usually refresh because it feel faster most of the time. I should try 5.0.3, maybe my bugs are fixed!
`const char*` is `const char*`, string literal is a string literal. In particular, `!std::is_same&lt;decltype("Hello"), const char*&gt;::value`.
I closely abide to the 76-80 character limit on my lines, but C++ has always been one of those languages where I can’t manage to do it in a good way. At least people have wide screens and high resolutions nowadays.
Now that 4.14 for UE4 &amp; CLion 2016.3 are out, I'm having quite a positive experience with CLion-UE4 integration. Thank you very much for the added emphasis on getting these two apps to play nicely! It's greatly appreciated!
Compared to clang, it is interesting to see that GCC does **not** generate any better code when `const` is in place.
I've learned to accept that I'll have to use more width with C++. 80 characters is a holdover from days when that's what you had but 132 column terminals have been around since the dark ages (read: vt100 AVO). I find vertical real estate more valuable. Scrolling vertically is more costly to me in terms of reading code than the occasional horizontal scroll. Of course you could just do as someone before me did and use namespaces in header files to reduce width but then I'd have to find you and take away your compiler. 
That one was ... wow! I've left this session with a big grin in my face. I totally want stuff like that. Fast forward - engage!
Chandler Carruth in his LLVM optimization talk both directly, and vehemently disagrees with this. @Eric. I added some complexity to your example here : https://godbolt.org/g/COuOAu . The optimizer folds everything down irregardless of const. Can you show how in a case like this where const offers extra clarity for the compiler? In other words, beyond trivial cases, where does const, in practice, improve perf?
Game development and love it.
Assuming you mean the Windows command prompt, you can [change the code page](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686036(v=vs.85\).aspx) it uses. 
Awesome keynote. I want `reflexpr` so badly...
Can you link the talk please?
**three, five, or zero ;)
If it got much longer I might but with my screens it's easy enough to read even with two columns in the editor. We have some limits defined by consensus of the group I'm in but they are pretty generous. Another group has some people who are really C programmers at heart and stick to 80 characters religiously and it's much harder to read their code overall for reasons of line length (ignoring the parts where it's hard to read because they are C programmers using C++). 
There is also no const correctness here. In fact the only use of the const keyword I see here are for global constants which should be constexpr anyway (assuming C++11/14). Thinking about whether things should be const or not alone should help a lot with bugs like this. &gt; But since that was getting us nowhere, we decided to bring out the big guns, and went on to run the program with GDB. Shouldn't this usually be first instinct? I feel like if you're spending more than five minutes trying to solve some issue you should be using a debugger. The "big guns" is using something like valgrind's memcheck (which I feel you should also run with some frequency). gdb should be a part of your standard workflow.
Yes but `std::is_same&lt;decltype("Hello"), const char(&amp;)[sizeof("Hello")]&gt;::value` and `std::is_same&lt;std::decay_t&lt;decltype("Hello")&gt;, std::decay_t&lt;const char*&gt;&gt;::value` 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to /r/cpp. 
**EDIT**: It seems all of these points (and more) have already been made over on the [other discussion thread](https://www.reddit.com/r/programming/comments/5gdjbj/my_favorite_bug/) pointed out by /u/lurkotato. *** template &lt;class T&gt; int size(T x) { return x.size(); } The copy construction issue is the least of this thing's problems. First and foremost, why does this function exist? Is it really so much less work to write `size(x)` than `x.size()`? I could also mention that using unconstrained templates like this isn't a good idea or that the standard containers measure their sizes with `size_t`, not `int`, but I will leave that for another day. *** #define pb push_back Why? Just... why? *** const int INF = 2147483647; const double EPS = 1e-9; ... #define BP 0.20 #define MAX_LEVEL 10 I guess BP and MAX_LEVEL don't deserve to be type-safe or constrained to this header. *** typedef pair&lt;int, int&gt; ii; typedef vector&lt;int&gt; vi; typedef vector&lt;ii&gt; vii; typedef vector&lt;vi&gt; vvi; typedef vector&lt;vii&gt; vvii; C++ has a beautiful type system. This is not it. *** void clear() { while(head-&gt;next &amp;&amp; head-&gt;next[0]) erase(head-&gt;next[0]-&gt;item); } void erase(T target) More copy-constructor fun times here. *** #define FIND_UPDATE(cmp, target) \ int pos[MAX_LEVEL + 2]; \ memset(pos, 0, sizeof(pos)); \ node *x = head; \ node *update[MAX_LEVEL + 1]; \ memset(update, 0, MAX_LEVEL + 1); \ Why is this not a private member function that takes **`const`** references to its parameters (see /u/mr_snowf1ake's comment for details)? The function body is fairly short (especially when you remove the unnecessary second memset). The inliner wants to be your friend. Let it be your friend. *** Also, [rand is considered harmful](https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful).
In your example, what is the performance difference of this when there is a potential cache miss for the array? When constructed on the stack there shouldn't be one. I am not a fan of using assembly code to determine if something is faster, I prefer profiling.
Can capturing lambdas can be handled in this way since you would need two packs perfectly forwarded to the underlying lambdas' constructors?
Hm, unfortunately there seem to be quite a few things wrong with the article. - The complexity of the implemented binary search is O(m*log n) where m is the length of the pattern and n is the size of the suffix array. An implementation actually using the LCP array could achieve O(m+log n); See Manber &amp; Meyers. - Your suffix array construction is O(n^2 log n) not the O(n log n) stated in the comments. - Similarly, the LCP construction is O(n^2) far from an optimal O(n). - The LCP array is commonly one element longer than the SA with the first and last element set to -1. The latter is necessary for a simple definition of LCP-intervals. - SuffixTree and SA+LCP are not equal in performance unless you add RMQ or CLD-tables to the latter. - SA+LCP do not improve cache locality. Not a good resource. ☹
Following any kind of "guidelines" blindly doesn't help. This does - you now have enough information to decide where you need const and where you don't. Sorry, but you have to know what you're doing while programming.
I think both are valid. Moving is generally useful only with "big classes" such as `std::vector` where moving is much faster than copying. It won't change anything if you declare an int const. And it won't change anything if you declare a `vector` const since you're just reading from it. Moving is useful if you return a modified vector and can discard or reuse the underlying pointer of the input one. 
&gt; gdb should be a part of your standard workflow. Well, seeing code examples in the /u/OmegaNaughtEquals1 I instantly realized that the author was a competitive programmer. Bad code practices, ugly defines/typedefs and such (which may be understandable when your goal is to write something fast) and reluctance to program in something other than FAR (or analogue) (and as such treating tools like gdb as something last-resort), is a very common and distinctive trait. And my guess was right.
Worked for me. #include &lt;iostream&gt; #include &lt;random&gt; template&lt;typename L1, typename L2&gt; struct S : L1,L2{ using L1::operator(); using L2::operator(); S(L1 first, L2 second):L1(std::move(first)),L2(std::move(second)){} }; int main(){ int j = std::rand() %1000; int k = std::rand() %10; auto a = [=](){ return j; }; auto b = [=](int i){ return i * k; }; S&lt;decltype(a),decltype(b)&gt; s{a,b}; std::cout &lt;&lt; s(3)&lt;&lt;'\n'; } 
You want documentation of software (which is already in use by real projects) to recommend a C++17 feature which isn't even formally standardized, *instead* of the thing which works now?
Now that I'm not on mobile, I gave it a go. It seems to work with more complicated objects, as well. This is very interesting, but I'm not entirely certain how the correct constructors are being invoked. I'll have to think about it. #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;numeric&gt; template&lt;typename L1, typename L2&gt; struct S: L1, L2 { using L1::operator(); using L2::operator(); S(L1 first, L2 second) : L1(std::move(first)), L2(std::move(second)) { } }; int main() { std::string s{"Hello, world!"}; std::vector&lt;int&gt; v {1, 2, 4, 6}; auto a = [&amp;s]() { std::cout &lt;&lt; s &lt;&lt; "\n"; }; auto b = [v](int i) { return i * std::accumulate(v.begin(), v.end(), 0); }; S&lt;decltype(a), decltype(b)&gt; x{ a, b }; x(); std::cout &lt;&lt; x(3) &lt;&lt; '\n'; } 
I love the top comment on that thread.
This is how boost::hana::overload works.
can you execute your program from your web root? are you sure have PHP on the server? if those are both true, you should at least be able to rig something up. PHP can call your program with http://php.net/manual/en/function.system.php , and PHP can of course read a text output from your program. It's a little ugly, but it might serve your purpose. 
This totally is the best intro to Hana talk i've seen to date. 
What would be an example of a real world practical application for this?
Write projected_order, which takes a function object and returns a lambda that takes 2 args, projects them, then calls less on the result. (Very nice way to write ordering function objects in my experience) Now write two lambdas that project from type A and B to the same type X. Search a vector of A for B by sorting A by projection of lambda A to X, then equal range on projection of overload of both lambdas (A to X and B to X). (Actual use case in production code). If you add is_transparent to the projector, you can also use this to write a transparent ordering for a std map or set. 
Just a little suggestion: don't be an asshole.
Under the MS ABI those will have to be the same as far as TBAA is concerned forever :)
`__wchar_t` is not UTF-8, ever.
PATL, though I'm not sure what the definitive source is since code.google went offline, but the following seems pretty complete: https://github.com/jnorthrup/patl
A visitor, it's a design pattern, look it up :)
Here is a Windows keylogger called [Micro keylogger](https://www.microkeylogger.com).
I use const whenever I can on variables, function arguments, and member functions. Not about performance, but it leads less bugs.
Async is nice but, I kind of want a bit more control, for example number of threads. It's a bit of black box.
I believe GCC misses its chance to do the optimization here what it looks like a fairly common and/or trivial case.
The questions at the end should be different for every talk :)
Turn it sideways
Me too!
That's actually kinda beautiful, especially if each code for a visit is small or is dispatching work somewhere else.
Frankly, zapcc looks like a cash grab for what should ideally be a contribution to LLVM. I don't mind permissive licenses, but projects like these remind me why we have the GPL. I have no excitement for this tool.
The build times are faster but what about the performance of the code? I prefer to wait one minute if the code will be a lot faster And by the way, you use clang 3.9 but instead of gcc 6.2 you used 5.4, any reason?
Isn't `int j();` also MVP? There's nothing special about the `TimeKeeper` class.
I would prefer union. Especially if you are planning to add more things to store in that place later (otherwise you would need to compute the suitable alignment and size somehow). And I find syntax cleaner and less error-prone (it is clear what member of the union you are working with from syntax).
Since this is just normal Clang + some caching, they would need to mess up a lot to affect code performance.
You might find this article useful https://akrzemi1.wordpress.com/2015/07/15/efficient-optional-values/
And now I've broken source compatibility on lots and lots of code :) To this suggestions credit though, this one is at least possible to accomplish (though expensive). The prototype time machine I've been working on isn't stable enough to fix my binary compatibility problems.
std::vector is the one reason I don't push adoption of braces at work :/
It's correctness that I would be worried about. Unless you are 100% confident that zapcc didn't screw up while trying hard to reuse (potentially stale) results of previous compilations, you will often end up with this vicious cycle: my application segfaults but now I am not sure it is my mistake or maybe its zappcc's -- so let me rebuild everything for good measure. Once you get down this road, you might as well use stock Clang/GCC.
&gt; Such folks understand that in some cases (e.g., creation of a std::vector with a given size and initial element value), parentheses are required. It's not that parentheses are required, it's that they're required *sometimes* that makes it confusing. This will initialize a vector of 10 elements just fine: std::vector&lt;std::string&gt; x{10, "hello"}; but this will initialize a vector with *two* elements: std::vector&lt;int&gt; y{10, 2};
Does that mean it is just text being plugged into other text? 
Reading his description though, this code is stuff he can /bring/ to the coding competition. There is no reason for the code he writes in preparation for the code competition to be low quality. If anything I would think he would want it to be as robust as possible. Though maybe as /u/flashmozzg implies, competitive programmers are just bad programmers. There are so many flaws in this piece of code that it seems like the programmer is missing a lot of the fundamentals of C++.
I remember another post about something similar where issues were caused by prefetching unknown instructions that were guarded by an if. Yet they were speculatively executed leading to a crash. Why not provide multiple executables hidden behind a common executable (or script) that automatically selects the right one? Suddenly this "more complicated" solution would solve all the runtime issues.
I went looking, and he has over 10 hours of footage to go through all on LLVM optimization stuff. So that's bad on me. I'll keep looking (I think it was during a Q&amp;A session, but his rationale is the same as you'd find anyway, which is the optimizer cannot _depend_ on the declaration beings truly const due to aliasing. Thanks for explaining your example. That makes a lot of sense.
Please file a compiler bug; this is off-topic for /r/cpp.
Look at your report, it was completely mangled.
If the code is C, then compile it as C and tell in your video that it's C. If it's C++, then compile as C++ then tell in your videos that it's really C++ and use `constexpr` instead of macros. You would be surprised how the two languages are not compatible, as the type system in C++ is much stricter than C's. 
&gt; I remember another post about something similar where issues were caused by prefetching unknown instructions that were guarded by an if. Yet they were speculatively executed leading to a crash. Link? Intel and AMD tend to bend over backwards to not allow speculatively executed code to cause hardware exceptions.
&gt; And now I've broken source compatibility on lots and lots of code :) Too bad. Keeping code that can't be compiled with a standards conforming compiler for 18 years is not OK. People fixed their `/Zc:forScope` messes and they can fix this too.
Reuploading the full version on Thursday, this version is shorter then it should be. Rendering had some error around 57:xx...
At least in the `malloc()` case, the storage is typically produced by an opaque function call, so the compiler can't usually prove there /isn't/ an object of the right type already living in that storage (... but the bad thing might still happen if you LTO your `malloc` implementation into your program.) If the compiler tries to be "clever" by saying they know that `malloc` didn't put an object there, then they deserve to have you switch to a different compiler. That said, it would be preferable if the standard officially blessed that pattern, perhaps by explicitly saying that `malloc` creates whatever objects are needed to make your program work (and likewise for at least `memcpy`), or perhaps by saying that happens for all suitably-trivial types in all cases. I don't think following C's "effective type" model (which is pretty much what your "at the first instance of an access" rule gives) works well here, because it seems like it would interact poorly with object lifetime -- in order to allow a bit pattern of an int to be copied into a char[4] and then accessed as an int, we need the lifetime of the int object to have started during or before the copy. So what I'm thinking is something more like: "There is a set of additional objects of trivial types and array types created during program execution, created as necessary to give the program defined behavior. If there does not exist any such set of objects and accompanying lifetimes for which the execution of the program would have defined behavior, the behavior of the program is undefined; otherwise, an unspecified such set is selected. [Note: The selection of this set need not satisfy any causality property, and in particular, the first read of a region of storage as a particular type may trigger the storage to acquire that type prior to earlier modifications with `char` lvalues, in order to avoid the behavior of the read being undefined.]" I think that would also fix the implementability issue with `vector`: we'd automatically and retroactively conjure an array object of the right type and bound (with no elements) at some point around when the storage is first created. But we should probably discuss this on the core reflector rather than on reddit :)
Personally I like Stroustrup for general C++. For modern C++ which is actually a little different, Scott Meyers' Modern Effective C++ is great. Also all the other Scott Meyers books are good too but maybe not where you should start. 
I have encountered a bug with speculative execution once, and heard of one other case. In both cases the instruction in question was a specialized pre-fetch instruction that had side effects. It didn't cause a crash, but it damaged memory coherency so that future code would crash. Neither case was an x86/x64 processor. 
Since when does placement new work in a `constexpr` constructor?
Under the circumstances, I'd probably go for *Accelerated C++*. It's dated (pre-C++11), but teaches a style that makes heavy use of the library of the time, so it's still *fairly* modern (and easy to move from what it teaches to using lambdas and such).
Meh. He did work and is asking for money in exchange for goods and services. If you don't care enough about the difference to pay for it, it's not a problem for anybody. If Clang was GPL, this work would probably have never been done. The only difference would be that you wouldn't have the option to buy it even if you wanted to.
I am using rigth now cmake + GCC 6.2 + GDB 7.11.1 and i can perfectly use any build debug/release so i dont see the problem, GCC 5.4 is also using GDB for debug build also so why not using the last version And even if there is a problem on debud build, why is not present on the release build? because there are both test and on the release is 100% sure you will use gcc
My style, which has never given me grief and is pretty simple to apply: 1. If you want to use the empty constructor, always use braces. This calls the default constructor if it exists, or value initializes aggregates/primitives so you don't have uninitialized memory. And it avoids the vexing parse. 2. If you want to call a normal constructor that takes arguments, use parens. 3. If you want to call a constructor that takes initializer list, use braces. I can't think of any situation where these 3 simple rules have failed me.
Maybe yes but i am an engineer so i only trust data and results from it, maybe clang is doing much more than zapcc is not doing I am happy with GCC so why change it for other compiler? If it offers more perfomance and faster builds time i will do, otherwise i will stick with a great compiler
My condolences, lol. I binned my Athlon what... 12 years ago? Possibly more...
What you're talking about is not even up for discussion. Sure you have to think for yourself. But as an intermediate-skilled programmer, these contradictory statements can be very hard. All I asked for is an explanation for when maybe use one and when the other... Of course I know that these rules only apply in what, 80-95% of the cases, and you still have to think for yourself... Thanks for this lesson.
 I would have thought SSE + AVX in the same binary would be not such a great idea, there is supposedly a 70 cycle penalty switching between them, would need a decent amount of work to offset that. From page 132: http://www.agner.org/optimize/microarchitecture.pdf "It appears when code that uses YMM registers is mixed with code that uses XMM registers in non-VEX instructions. The transitions B  C, C  B and C  A take approximately 70 clock cycles each on the Sandy Bridge 
I like the comment by Francisco Lopes that shows how to read a binary file into a vector: ``` std::ifstream source("myfile.dat", std::ios::binary); std::vector&lt;char&gt; data(std::istreambuf_iterator&lt;char&gt;(source), {}); ``` [his stack overflow answer for more detail](http://stackoverflow.com/a/33697347)
that is one nasty thing to debug.
Ugh. In his first two examples, `...` is pseudocode. Confusing because `...` is actually part of C++ syntax in similar situations. The point could have been made just as well using real code. 
Why do you use a double for your prices? You will lose precision very quickly.
Wouldn't sending order messages through sockets increase the latency? Instead of calling directly the native code? 
Awesome, thank you. I'll look into this. At first glance, this seems to be just what I'm looking for.
!remove
inlining: hell of a drug
.... Jesus. The first should definitely be an error
Good to see boost::python being used. It was almost abandoned and no new features being developed. After py3 support, it is back to life.
Xbox 360 PowerPC CPU.
I have used floating and fixed, and have seen both used. Some of our algos calculate factors that are price multipliers, so floating point is a natural choice there. Other options are often slower. It doesn't have to be an issue, as long as you understand how the number is ultimately used. It sure can be if you're not careful though. 
it is also the predictibility of latency. by going through sockets, you are opening yourself to the all possible delays and interrupts of OS
In the same binary is potentially okay, as long as you don't switch too often. That is one of the subtle problems that I raise - if the linker ends up choosing the non-AVX version of floorf (or whatever) then you get no crashes, but reduced performance.
You have to use braces if you want to initialize an aggregate type. Then, imagine that you are writing generic code, you prefer to call a normal constructor, but you don't want to lose the ability to initialize an aggregate type....
Just to be clear, this is not my project ;) I'm using beta testing it and having fun. I do agree that this would be better in Clang directly, but as you say, they did the work and deserve something in return. 
On my benchmarks of this library, I haven't seen any difference in neither speed nor correctness. As for gcc 6.2, the reason is simple, it's still hard masked in Gentoo and I don't install hard masked packages ;)
Hi, &gt; As /u/JuanAG asked, why not use gcc-6.2? Still hard masked on Gentoo, so I won't install it. No better reason. &gt; This is not a good idea- even when looking at relative speedups. I agree, but this only is for my loose comparison of gcc5-4 vs gcc 4.9 and clang 3.9 against 3.7, this is not relevant for the main matter of the article. &gt; Any particular reason not to include this, even as a separate timing? No particular reason, I wanted to keep the results clear of link times. In my case, the link times are pretty low, about 10s, but I didn't want that noise. &gt; Your debug flags are inconsistent across compilers as gcc and clang have different default optimization levels That's a very good point, I completely forgot they had different optimization level by default :s &gt; For the "release" builds, you only show timings for one make job instead of the one, two, or four jobs used in the debug builds. Is there a reason for this asymmetry? The speedups are almost the same whether it's in j1, j2, j4, ... Therefore I decided to save some time and space and only show the result in j1. I made the test in j4 for release build, but the speedups are not significantly different. 
Yes, if you're using OS sockets. But for low-latency, you can use "kernel-bypass" drivers. They replace the socket calls with their own functions that talk directly to the NIC. I've seen consistent latencies of under 1 microsecond for TCP reads and writes. And by consistent, I mean an 99.999% average, over millions of operations. Oh, and this was only one way - from the software to the fiber (measured with a tap). It still has to go through routers, if you don't have a true cross connect, and there's the latency on the other side, too.
More: * http://libfuzzer.info/ * http://tutorial.libfuzzer.info/ * https://github.com/google/oss-fuzz 
We definitely have too many different meanings for mvp
I'd like to see a list of things boost::python can do but pybind11 can not (yet) do. I am on the fence currently but would probably prefer the true-and-tried for now.
Last I looked at pybind it didn't support embedding very well
Regarding mobile app, another solution is to generate bindings using eg. SWIG and call this API using native code (eg. within a phonegap plugin).
If you are looking for an easy to use c++11 interface then Crow is very nice https://github.com/ipkn/crow
I don't get it. That loop will simply be removed by the compiler as soon as the optimization is turned on. What is he measuring there exactly?
Welcome to the world of software development, where most of bloggers are incompetent and just trying to "make themselves visible" so that they can negotiate a bigger salary.
lvalue casts are so weird
At the moment (master branch), pybind11 does a lot more than boost.python with the notable exception of embedding.