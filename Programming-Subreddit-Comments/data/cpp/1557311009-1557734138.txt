I think the call site must also use the return value to make it UB. This oddity goes back to the old days of C, when function prototypes weren't a thing, everything was assumed to be an `int`, including the return type of functions. C++ kept this for backwards compatibly, but I think it's a mistake, maybe even worthy of a paper to fix it.
I recently swapped out Eigen's call to std::malloc with dlmalloc and my release mode builds went from 2hrs to 26mins. However your point is still valid and I will be checking on ways to optimize the memory usage in the algorithm.
Ugh, the motivational example is everywhere in my code base at work and it would be so much nicer to switch to this.
Quote from the C++17 standard, ¬ß9.6.3/2 \[stmt.return\] &gt;Flowing off the end of a constructor, a destructor, or a function with a cv void return type is equivalent to a return with no operand. Otherwise, flowing off the end of a function other than main (6.8.3.1) results in undefined behavior.
&gt;I think the call site must also use the return value to make it UB. Quote from the C++17 standard, ¬ß9.6.3/2 \[stmt.return\] &gt;Flowing off the end of a constructor, a destructor, or a function with a cv void return type is equivalent to a return with no operand. Otherwise, flowing off the end of a function other than main (6.8.3.1) results in undefined behavior.
[removed]
I was surprised by the fact that the compiler figures out `f()` means `this-&gt;A::f()` even though the type of `*this` does not apparently inherits from `A`. (Actually, only Clang does).
This isn't accurate. First off, you were looking at the C documentation, not C++. But even in C, it's not that those identifiers are reserved, but the C standard cautions you that additional functions with those names could be created and declared in specific headers. You're allowed to use functions with those names, but the standard cautions that you might have to get creative is it ends up conflicting with future language changes. C++ mostly doesn't have this problem because it has namespaces, and C functions are also placed in `std`.
Absolutely. From those numbers, *at least* 75% of the 2h runtime were spent with memory allocation, probably much, much more. I had a very similar behavior before, and it's most likely that your allocation patterns are off. The fact that it runs slower on Windows is then just a symptom. If you fix that, your algorith will be 10-100 times faster. If you are using MatrixXd.resize(old_size + (1,0)), that would be the issue. Use MatrixXd.resize(old_size * (1.5, 1)).
Performance: Why return something when you can prove that the path where nothing is returned is never taken, but which the compiler can't prove.
But the member needs a separate definition after the class is completed. For static constexpr members, it might be a bit tricky to find out how to declare and define it correctly.
Because you're sing that crap called "Reddit redesign".
&gt; That C++11 implicitly adds `noexcept` to destructors Only if there are no data members or base classes that have a throwing destructor :)
Well, time for my response to OP: C and C++ differ on this detail! Quoting from C11 6.9.1/12: &gt; If the `}` that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined. And now that I think about it, I think Clang inserts an instruction to terminate the program if you trigger this UB. I'll bet they do that in C++, but not C.
Yeah only the new design. Some (mobile) Reddit clients also don't support it.
&gt; I think the call site must also use the return value to make it UB. That's only true in C.
I started with How to CMake Good https://www.youtube.com/playlist?list=PLK6MXr8gasrGmIiSuVQXpfFuE1uPT615s
Consider int foo(BigNum n) { for (BigNum i : all_prime_numbers) { for (BigNum j : all_prime_numbers) { if (i + j == n * 2) { return 1; } } } } The compiler need to prove or disprove Goldbach's conjecture before it can reliably decide whether to issue a warning.
Or, it can just see the return is conditional.
&gt; Also, I just spent many years working alone, BECAUSE of negative reactions like this. If you could appreciate the irony of this statement, you probably wouldn't have spent as many years working alone.
Yup! See my comment above.
Finally, someone did what I've done at work for the three relevant compilers used there. Thanks a lot sir!
I kind of can relate with your reaction; I am writing some library code too. I am my own best customer and ALL design trade-offs have been made to satisfy myself only so I can live with it. ;) The moment you try to satisfy everyone the design will become a convoluted mess and not especially good at anything. That said, being multi-thread safe is important to a lot of people is that w/o that "little thing" it is very hard to use the code as drop-in replacement; everyone would have to audit every line of code they ever written. That makes the requirement quite chiseled in stone.. if you are single-threaded in allocator that means most likely use case your code can be used is project that is right now starting from scratch and have to keep these in mind ALL THE TIME, which is also something that is unique to most code. Most containers and other object don't need to be MT-safe because programmers already use them in isolation and can design when different threads interact and how. If you creating an array somewhere in some thread, the basic expectation is that it WILL WORK.. since you are not interacting with other threads in any way with that code. Of course it would be complete lunacy to implement thread safety to every classes every method.. code like that would be retarded. :D So a little bit more about the "higher standards" .. yeah, I see someone asking "how can I do X" and most of the time the answer is "use Y", where Y is kind of shit, but well known shit.. that is depressing but over time you just have to let it go.. people flock to something that is repeated often enough. The trick is that YOU shouldn't repeat / spam it everywhere all the time, people get sick of that.. but if many people do it, then it's all kosher. Welcome to humanity, pal! :)
I would simply jump straight into Meson. CMake is very complicated and burdensome to use.
The C++ standard requires the compiler to be successful if the program is well-formed. Even if the execution of the program might have UB. As for why standard specifies this to be UB rather than ill-formed (latter would allow failure to compile), I think the reason is historical. Before introduction of \`\[\[noreturn\]\]\` attribute, you would have to have added a return statement after a function call to a function that doesn't return, which would have been redundant and confusing.
I bet every employer that supports more than 1 compiler is doing this üòÇ Btw, thanks a lot for the sharing OP!
p.s. for me the 32 bit -only is a show stopper; I don't really do 32 bit stuff anymore.. at least, 32-bit only. Say, if I compile for Android the APK will have 64 and 32 bit binaries in it.. so the code has to work on both.
Redesign only
If Goldbach's conjecture holds, then `i + j == n * 2` above will eventually yield `true`. The compiler just needs to prove the conjecture.
They would fall through even without those "goto case" sentences.
after 23680 seconds, deal.ii is compiled and it works. I have tested some examples, and it works properly.
I wouldn't put big binaries and such into git itselft. Are you aware of https://git-lfs.github.com/ ? That aside: Prebuild binaries can be a problem if the ABI/API is succeptible to changes in the compileflags or toolchain versions (which many modern c++ libraries unfortunately are) but otherwise I don't see a problem with it. Of course you should always make sure that you can quickly rebuild the libraries with the right settings when needed regardless of whether you use prebuilt binaries or not for your regular development process.
I believe this is to be uniform with executable parameters: `argv[0]` is the name used to invoke the executable and the first parameter is in `argv[1]`. This is a very old convention, if not one of the oldest conventions we have.
Crazy girls do crazy things: http://ceoq.l5dusnkq.org/touq282h/
Don't open this link. Its spam to a porn site.
The reason they differ is probably because C++ has constructors and destructors. Both GCC and Clang (and probably other compilers) will optimize based on the assumption that the UB case never happens. This code ... int foo(int x) { if (x == 0) return 5; } ... can be optimized into the same as: int foo(int x) { return 5; } [https://godbolt.org/z/RtCnym](https://godbolt.org/z/RtCnym)
Massive orgies: http://ceoq.l5dusnkq.org/touq282h/
I added `goto case` to case 2 for uniformity (you should always write something at the end of a case anway: break, return, a fallthrough comment, or in that case a goto), but it's absolutely required in case 1.
&gt; That said, memory allocator being multi-thread safe is important to a lot of people Of course. I'll make it thread-safe when theres a reason to do so. As-in, I need it, or I'm being rewarded enough to make it. Or... if it's cool enough for others (because they tested it as it is), they can do it themself. Anyhow thanks for the reply :) have a nice day haha. Yeah I know about liking to "pattern match" and blindly apply X to Y.
Definitely recommend as well.
Crazy girls do crazy things: http://ceoq.l5dusnkq.org/touq282h/
It could be. However, what would happen with HEDLEY_NON_NULL(0)?
But not more than one URL of the same protocol-scheme per function. Man, C++ has some crazy rules...
I don't think I've ever gone from "this is a silly post" to "this should be something we do every quarter" any faster than this. Props to op.
Like I said, treat this as a passion-project, not a "solution for your company's needs". If you have passion for C++ and want to encourage "some kid" to make his allocator better, try it out and give encouragement. I'll be fixing the 64-bit thing soon. But its still "just a passion project" that I also happen to use in a real-world programming language I made.
Dunno. Not compile?
New Dating Site! Check it out: http://ceoq.l5dusnkq.org/touq282h/
I hate it when I find code like if (foo) bar(); baz();
What surprized me when I first saw it in other C++ code was that one can force a "lambda-to-function pointer" conversion using an unary plus: #include &lt;iostream&gt; template&lt;class Fun&gt; void sink(Fun) { std::cout &lt;&lt; "generic sink\n"; } void sink(void(*)()) { std::cout &lt;&lt; "function pointer\n"; } int main() { sink([]{}); // prints "generic sink" sink(+[]{}); // prints "function pointer" } How? For every type `T` the unary `operator+(T*)` is considered to exist which returns the given pointer as is. Here, `T` is not restricted to object types but includes function types. A lambda object that didn't capture anything has a conversion operator to a function pointer. The unary `+` triggers this conversion.
&gt;"vector V;" is missing the template arguments Interestringly, you could simplify your own version by letting the argument be deduced: std::vector V = {4,3,6,2,8,9,1,5}; This of course doesn't work for OP since they don't have the initialiser.
You don't need the plus though. The lambda will be implicitly convertible to function pointer if it doesn't have any state.
Meet the love of your life: http://ceoq.l5dusnkq.org/touq282h/
He is asking how to learn cmake this answer is definitely not useful.
&gt; I don't want to use an ORM. Sadly https://github.com/fnc12/sqlite_orm is the best SQLite C++ wrapper &gt; For example sqlite_modern_cpp looks like it might be stagnant, or is it just done and stable? I have used it, was pretty easy to use but spotted multiple problems: - it is indeed stagnant - it does not have own directory (examples have `#include &lt;sqlite_modern_cpp&gt;` which is bad) - the API is unnecessarily limited, and the implementation does a lot of wasteful allocations - SQLite does support non-null-terminated inputs but the implementation creates `std::string` from anything... - also, any BLOB is pretty much `std::vector&lt;unsigned char&gt;`, **there is no support for iterators, the library always takes `std::vector&lt;T&gt;`** I think if I had to (and for whatever reason couldn't use the ORM one), I would use it but as own source code with corrected implementation - unless you are OK with converting everything into `std::string` and `std::vector` to match it's API.
Even trigraphs were only removed in C++17.
Cmake is helping me in mid to big project with crosscompilation from many years. You are free to dislike but how is this answer useful?
In real life I would prefer a cast though. The unary solution is neat, but could be confusing for others.
Better than Tinder: http://ceoq.l5dusnkq.org/touq282h/
I have to ask, sorry if this is offensive. Is English your first language? The tone and style of your post and Jeebox's README is just... odd. Atypical, for sure.
Massive orgies: http://ceoq.l5dusnkq.org/touq282h/
The python skills required are pretty minimal. Conan is by far the most flexible package manager. It can do whatever custom build/environment you need.
lol
&gt;I bet every employer that supports more than 1 compiler is doing this Definitely not...
I say right there that I don't mean offence (my inbox shows your other reply, although I can't find it).
yes, in that case msvc will only show a warning telling that not all control paths return a value. I often construct my bool returning functions so that there will be only one return statement in the end, and then I forget it, so it's very important for me to configure the compiler so that this does not happen.
- `int` to `double` is promotion but `int` to `float` is not - you can do `class_name&amp; class_name::operator=(class_name&amp;&amp;) = default;` in a source file (useful for pimpl) and this: - `T&amp;&amp; t` takes 1 argument of arbitrary type - `Args&amp;&amp;... args` takes arbitrary amount of arguments of arbitrary types - there is no support for arbitrary amount of arguments of 1 type (proposed for C++20 though)
If kernel code written in C were a good place to look for C++ style cues, I might agree, but it isn't.
Boost Beast uses this in their examples all the time and when I first saw it, I was like, WTF, is this an empty macro or what?
Why not? Are they really going to use ifdefs?
This would be really hard to go through. C++ doesn't like exceptional rules for standard library (Bjarne said that user-defined types should be as well supported as standard library types for any feature). OTOH, we could go with the range-based-for route and just specify a requirement for certain member functions which existence could enable such feature.
Well, you can still use SFINAE to constrain the parameter pack.
This [https://gcc.gnu.org/wiki/cxx-modules](https://gcc.gnu.org/wiki/cxx-modules) ?
This is nice, but it's missing uniformisation of architecture detection across compilers.
No :/ there‚Äôs another link that shows the changes to the svn branch with comments on the changes. There was a new change daily-ish.
I'm definitely that type of programmer who has worked with C and I will call `free()` so help me gods of C++.
 #define WATS_DIS this #define UwU delete
I also can recommend it. The time spent on reading it through was one of the best investment I ever made, finally I'm *almost* feeling comfortable using CMake.
Great idea, looks like a better version of Boost Config - `HEDLEY_(un)LIKELY(expr)` can be `[[(un)likely]]` in C++20 - I don't like `HEDLEY_DEPRECATED` - it should just take a string and use it directly, by adding "since" you limit the interface. And standard (or at least cppreference) says the syntax is `[[deprecated("reason")]]` which expresses something different
https://en.wikipedia.org/wiki/Dangling_else
No. `else` is it's own keyword. There's in fact no difference between if() {} else { if () {} } and if() {} else if () {}
Never had a such need (never needed multiple overloads), just went with static assert but good catch anyway.
I still don't see any misleading identation in here.
You might be overreacting a little bit; while I get that you are upset that something great you did is not received as you expected, you must be prepared to accept feedback, including negative one, and it would be best if you can avoid taking it personally: this is just source code after all, and not a big deal if people prefer other libraries for the task, nor if they find drawbacks or sometimes potentially even bugs. Now if you really want to "market" your allocator and interest the community (let say for special use cases, for example), it is unrealistic to not benchmark it against state of the art ones. You will simply get virtually no users if you don't. Anyway thanks for sharing that interesting bit if code. Maybe I will never use it, but then I can see multiple reasons for how it can still be interesting for me and tons of people, including studying allocation techniques.
That would be ambiguous only if you had no idea how if statement works in C++. First statement that follows if statement is bound as conditional. If it's another if statement, then next statement is bound as conditional too. It continues on and on. let's rewrite `if(x) { y }` as just `if y`, where y is a statement. Then, you can chain ifs however much you want. E.g. `if if if if if if if if if else` If will ALWAYS be if if if ... else
There is also [sqlpp11](https://github.com/rbock/sqlpp11), though it is generic it has a connector for sqlite3. Interface was nice but my use case was pretty trivial. Maybe someone more experienced can compare
404'd
&gt; it can still be interesting for me and tons of people, including studying allocation techniques I'd be more interested if people were interested in ME... lol. A teacher can't teach without any wages. How can I teach allocation techniques if I am poor? This is a passion project. It's not about marketing. Think of me as a passionate inspired kid. Then you have 90% of the understanding towards how to deal with me.
I've seen people make their own macros, and a few use ifdefs too much. But only a small set of the things in Hedley are truly essential for most people. The rest are just cool nice-to-have features.
Hi, there might be a local meetup in your area. In Melbourne, I go to this C++ meetup and met some pretty smart ppl who share the same passion as I do. I also joined /r/Graphics Programming discord server which is mostly C++ users, some really beautiful minds on that server too. I hope this helps in some way.
Yes, by hand - AddRef() and Release() methods of base IUnknown. This (and other com-like stuff) is usually handled by lifetime management object not unlike smart pointer.
&gt;Just a while ago I wrote replacement for something as trivial as std::vector for critical path performance optimization. The throughput doubled. &amp;#x200B; &lt;skeptical fry meme&gt;
includecpp has a good discord server, lots of heavy programmers hang out there and the vibe is very inclusive, there's a link on their webpage here [https://www.includecpp.org/](https://www.includecpp.org/) &amp;#x200B; I think all the other cpp discord chats I'm in are audio or game based.
https://en.cppreference.com/w/cpp/string/basic_string/basic_string As you can see at the bottom, you can embed the Stack Crooked online compiler, that's just an example
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Well, I guess in your code you would write `static_cast&lt;int&gt;(std::round(x))` anyways? `static_cast&lt;int&gt;(x)` where `x` is a floating point number would only make sense to me if the precondition were that `x` had exactly an integer value.
Ok, then maybe it's this one: [https://gcc.gnu.org/svn/gcc/branches/c++-modules/ChangeLog](https://gcc.gnu.org/svn/gcc/branches/c++-modules/ChangeLog) ? :)
They use gotos sparingly, to implement exceptions which don't exist in C. My point is that people really do omit curly braces in production code. It's more readable.
If you can't see it, then that precisely why you should be using braces. The indentation in the above example suggests the code should flow as follows: if (foo) { if (bar) { for (;;++bar) { if (bar == 4) { break; } } } } else { if (!bar) { switch(bar) { default: return 1; } } } When in fact it flows like this: if (foo) { if (bar) { for (;;++bar) { if (bar == 4) { break; } else { if (!bar) { switch(bar) { default: return 1; } } } } } }
Yeah, I agree
:o this is different, but similar. The page I'm referencing had a new change about every 20-24 hours or so, and the comments remarked on changes of the code's behavior (in contrast to the build stuff mentioned in your link). I'll keep this one too though :)
How did you double throughput over vector with a custom implementation? That sounds like nonsense.
Some of this sounds great but I'd like to see a bit more motivation for why you are replicating fundamental standard library types like pair. In case of sting: Is there no way to provide the additional functionality ontop of std::string (e.g. via free functions)? I really hate it, if each library I'm interacting with defines its own string type. Also, why a "modern" c++ library targeting high performance systems still tries to be backwards compatible to c++03 in 2019 is beyond me, but you probably have your reasons.
Don't get me wrong, I'm all in for inclusiveness and equality of oportunity. But I, along with many others, would rather stay away from "communities" that wave personal political opinions so blithely. Seems to encourage an attitude akin to "I'm right, you're wrong".
To be fair, a higher percentage of young developers use stackoverflow than would probably visit [isocpp.org](https://isocpp.org) or visit r/cpp.
The main problem is, you cannot guarantee that between calls push\_back, pop\_back someone other thread not purge it first, i mean lock vec.empty // returns false unlock // -&gt; other thread acquire lock and clears it lock vec.pop_back // &lt;--------- ouch crash I try an another approach [https://github.com/bvbfan/stlxx](https://github.com/bvbfan/stlxx) it not perfect but always can be improved :)
it probably shouldn't be called a vector, when it only provides the interface of a // simple thread-safe multiple producer, multiple consumer queue begin() and end() are declared const, but return non-const iterators which allow mutation outside of the lock typename std::vector&lt;T&gt;::iterator const begin() typename std::vector&lt;T&gt;::iterator const end() some operations use a mutex/condition_variable, and others use a spinlock - this is not thread-safe
Maybe it was this: https://gcc.gnu.org/viewcvs/gcc/branches/c%2B%2B-modules/?sortby=date&amp;view=log ?
This looks like something which should be a part of Boost
Even if they returned const\_iterator you wouldn't be protected against another thread modifying the vector while iterating over it because the iterators are just regular non-thread safe iterators.
[https://gcc.gnu.org/svn/gcc/branches/c++-modules/ChangeLog.modules](https://gcc.gnu.org/svn/gcc/branches/c++-modules/ChangeLog.modules)
That‚Äôs it! Thank you!
that's right, and resizing the vector would invalidate any iterators. vector is not a good primitive for a concurrent queue
Trivial when you know the specific problem. I was basically appending variable-length blobs of data to the end. I didn't know the size before hand so couldn't just reserve the shit out of it (typical sizes were from 1 byte to 5,000,000 bytes.. repeated from 1 to 10,000 times or so). I flush to disk when a buffer is full, but having number-of-thread buffers all maximum size was not very economical for memory usage (I tested with up to 64 cores / threads) so that was out of the window, too. The growth-rate of std::vector on overflow varies between implementations, typically between 50 and 100%. I could choose growth rate that fit the problem I was solving with the trade-offs I could measure giving best performance per byte. The initialization and copy overhead was also visibly smaller. I know std::vector is supposed to be super smart about these things.. but.. it isn't. May I ask why you think this sounds like nonsense? You believe that it is so well optimized code that no one can do better and that it is the pinnacle of c++ coding possible for linear storage container? Or some other reason that I don't have imagination to suggest? Just curious.
Highly recommend [CppLang Slack](https://cpplang.slack.com).
Good points to a review of my code. This is the things that I need.
I even said in the article that several points about the security of the transactions with the vector needed to be refined.
The reallocations when the vector reserve is depleted was a bottleneck where had very little control to reduce the generated bloat. Also, the growth-rate was at implementations discretion which is typically between 50 and 100% which was dictating how frequently the slow path in code was taken. I simply calculated how many bytes (in optimal case) the implementation has to copy with the growth pattern of the container. This was quite easy to instrument by reading the capacity and adding up size()-1 to a counter every time the capacity changed. The growth pattern I chose resulted in ~60% less "work" so that gave me "unfair" advantage. Another thing was that I don't initialize the memory to zero as I know my data is "just" raw bytes. This is simple mathematics, not scientology, jeez.
This is ***the*** single best resource and worth every cent. It also gets updated regularly and you'll find CMake 3.14 stuff in there. Even better than any blog post. I can't recommend it more!
&lt;serenity prayer&gt; (‚ÄúGod grant me the serenity to accept the things I cannot change, courage to change the things I can, and wisdom to know the difference.‚Äù)
This is another thing where C and C++ differ. It's only legal in C++. :)
How is inclusiveness political?
Any ffmpeg video discord chat ?
It did confuse me at first. I found it in some code using pybind11 to enable "function overloading" which pybind11 only supports when given function pointers as opposed to other function-like objects.
ThEy WoN't InClUdE mY hAtrEd FoR iNcLuSiVeNeSs!
If you've not dug into COM thus far, I wouldn't go out of my way to do it. It serves its purpose, but it's a tedious system. I only deal with it when I have to wrap some OS API that is COM based, of which there are quite a few. They came up later with ATL to sort of make it less tedious, but I never bothered with that.
AFAIK wait-free does not mean that process is never scheduled out, but rather that any thread is guaranteed to make progress in bounded time (number of steps). And with unbounded amount of operations of unbounded length which also executes serially I have no idea, how their execution time can be bounded... Well maybe length of operations could be bounded with correctly implemented STM, but not the number of operations.
&gt; This is simple mathematics, not scientology, jeez. You created a 'better vector' just to counter not allocating memory properly? You realize you could have done the same thing with a std vector right? You can reserve as much space as you want any time you want.
There are libraries that do it obviously.
Why does erase notify the condition_variable? Could use shared_mutex and lock with shared_lock in read operations and unique_lock in write operations. Also, using a mutex for some operations and a spin lock for others is just wrong...
I work with old C codebases on occasion still and that is why I avoid it.
I don't see a single political thing on that site, not sure what this comment is referring to.
Yeah, I was figuring if I ever had to I would use something like ATL or some of the newer Microsoft libraries rather than going directly to raw lowlevel unless of course requirements force me to or I inherit a code base with it. That seems to happen to me from time to time. The danger of being one of the main C++ guys at my workplace.
Overloading a member function for universal references. In other words: a memf that will only be called on universal references (entities subject to move semantics, like temporaries). Example: `#include &lt;iostream&gt;` &amp;#x200B; `struct X` `{` `void print(std::ostream&amp; os) const &amp;` `{` `os &lt;&lt; "const refs overload\n";` `}` &amp;#x200B; `void print(std::ostream&amp; os) &amp;&amp;` `{` `os &lt;&lt; "universal refs overload\n";` `}` `};` &amp;#x200B; `X make_x(void)` `{` `return X();` `}` &amp;#x200B; `int main(void)` `{` `X x;` `x.print(std::cout);//expected: const ref overload call; passed;` `make_x().print(std::cout);//expected: u-ref overload call; passed;` `std::cout&lt;&lt;"Done!"&lt;&lt;std::endl;` `return 0;` `}`
Interesting, is the second part necessary? Wouldn't it be enough to have delete this, be the last thing in a member function, return, let the destructor run and done. As far as my (definitely flawed) mental model for C++ says that would be ok, but I would love to be corrected for future knowledge.
Argh I just got old code base trauma where I was consulting a place that legit liked shipping code that had: `#define private public` And they even had a class that had const defined to nothing at the top. It was insane to read their code in general. That was one of the places were I thought there should be an accreditation for software engineering that could be revoked for horrible ideas like that.
"permitted" and "actually works" are different things.
I strongly feel free/new/delete etc are also just C++, just a lower level of the language. At least, I really feel we shouldn't snub them as not part of C++.
The `__extension__` keyword exists for the express purpose of shutting up people who think `-Wpedantic` is meaningful.
Yup, many UBs "actually work". Doesn't mean you should use them.
Why would you ever `#define private public`? Was this like for importing headers and trying to strip access rights from it? What living nightmare is this?
But if you introduce a temporary variable for the result of `foo` (using `auto` for the type), then the code is no longer legal. I like the consistency...
This is IB though, not UB. And if all implementations do the same thing ... who cares?
If I had to take a guess, I'd say that for large allocations, `malloc()` on Windows is always going to call `VirtualAlloc()`, period. Whereas for MacOS, Blaine Garst (a long time WG14 standards committee member) wrote its `malloc()` implementation, and I would not be half surprised if he uses `madvise()` tricks peculiar to Mac OS instead of ever calling `mmap()`. The difference is that `VirtualAlloc()`/`mmap()` must zero fill pages and perform a TLB shootdown. `madvise()` tricks do not do either unless there is memory contention. That makes a big difference to performance. dlmalloc is a fairly straight allocator. The Windows default allocator beats it easily, but only if you do not run your process inside a debugger, because then it uses the debug allocator. I'd suggest jemalloc or tcmalloc instead, in that order. jemalloc is the better general purpose allocator which also will do `madvise()` tricks (perhaps even on Windows? You may need to hack `DiscardVirtualMemory()` support into it), but for your specific use case tcmalloc might do better. Be aware tcmalloc never shrinks its address space, and so can skip free space coalescing, which in turn makes it faster.
I don't use malloc/free in my C++ code except in extra extra special situations where maybe you link in a special malloc implementation for performance reasons but I always wrap it in C++ RAII constructs and the like. As for new and delete in general I would say I snub them because most new code in my opinion should be written using unique_ptr's and make_unique and only in the rare situations like making memory pools or really high performance should actual calls to new/delete appear in code. Because I want my code to be generally memory safe and only increase the risks (and the reviews) when it is in isolated situations.
Running `delete this` is fine. I was commenting the part about accessing instance variables after `delete this`. My point is, if your class is trivially destructible, accessing its members after running destructor does not cause UB. So technically you could do something like this.
In that shop it was because the people writing code there were -- I'll be polite -- not smart about C++. The other time I saw it was to avoid making proper interfaces for unit testing. So they instead did the define thing to open up the private (and protected using the same trick) parts of their classes and wrote their unit tests to directly fiddle in the innards of the classes they were testing. It was pretty bad in terms of code and the interface design in general showed to me that the exercise of making interfaces testable is a good helper to improve the design of functions, structures and classes.
That's not refinement though, that's the whole thing. Putting locks around each function of a data structure is trivial, it at least needs to be thread safe.
Ah thanks for the clarification :)
Only generally though. Not everything that an object deals with is just local data and not everything an object deals with is something you want dealt with at the point of construction. And it's possible you don't want the cleanup to happen in the context of the destructor as well (for instance it could happen in a different thread than the one that did the setup, and in some cases that might be bad, or happen a lot later than it optimal for error reporting reasons.)
That's entirely possible.
Isn't that a problem with the \`cvtsd2si\` instruction? Or is it C++ specific?
I was wrong to use term "UB" here. However, the standard [requires](https://timsong-cpp.github.io/cppwp/n4659/dcl.array) array size be greater that zero: &gt;If the constant-expression is present, it shall be a converted constant expression of type std‚Äã::‚Äãsize\_t and its value shall be greater than zero. AFAIK, allocating a dynamic array of size zero with `new` is IB.
I did not note the git-lfs. We use bitbucket, I am not sure if they have such plugin or not. but I will take a look. Thanks. &gt; if the ABI/API is succeptible to changes in the compileflags. I did not notice this one, but see answer below. &gt; you should always make sure that you can quickly rebuild the libraries Yes and no, I can always rebuild all of them, but it would take a very long time, I estimate a couple weeks of one person for every one of the library and for each platform. So I am not too worry about seeing issues after updating compiler. Thanks, I will definitely look at the git LFS, because currently it takes almost two minutes to stash a change in the git because the repo is huge.
It's worse than that - every employer that supports more than 1 compiler is NOT doing this but would benefit from doing this!
I would reccomend the vehicle module of Chrono: http://api.projectchrono.org/group__vehicle.html C++, and a permissive BSD-3 license.
I thought it would have been the de facto standard to support this stuff. I mean, I'm still a student but to support MSVC Clang and GCC I did the same thing.. I will use this header instead of mine though
Seems interesting, thanks for sharing.
That's worrying indeed. As to why this is: * Whether deserved or not, C++ has a bad reputation: it's "hard" and "unsafe". It's the only language that I know of that has attracted something like the FQA. This is hard to fight; read this subreddit for a while, and you'll come to realize that the only "true" way to add two integers is by writing 6 pages of template code. And what if you do try to write simple, clean C++? The community, at least on this site, will tell you that "if you are not trying to extract every last cycle, then C++ is not the language for you!". * Actually getting into it is hard. You can't just do something like this: &amp;#8203; std::window window; window.add (std::button ("Hello!", [] { std::cout &lt;&lt; "Hello, world!"; })); Your first weeks in C++ land are either spent in text-only land, or fighting with arcane APIs, or trying (and most likely failing) to compile and integrate external libraries. * C++ is, unfortunately, used by universities as a tool to teach all the hard stuff: "craft me a linked list, young learner!" Combined with the generally lousy level of C++ skills that the teachers demonstrate, and students could be forgiven for thinking that C++ is hard and just not worth it. How can we fix this? The reputation thing is hard to fight, but the community attitude is something we can work on. If someone comes in here asking questions, don't just tell him to forget the whole thing and pick up an easier language instead. Being slightly more welcoming doesn't hurt anyone. The second point is a tough one. The graphics proposal could have helped at least a little bit, but the problem here is that it is hard to reconcile all the different needs. Some want only fast 3D graphics; some want high-quality 2D graphics. Windowing support that might be great for a beginner might, by the time it gets sufficiently competent to build professional applications, not be so simple anymore. And yet - having *something* there, pre-installed and ready to run from the first moment when you install the compiler, so you can have that window on the screen and grow your skills out without having to climb that 10km cliff, is vitally important to bringing in new people. The third point is perhaps the easiest to tackle: we could provide decent teaching materials. This would have many benefits: * It would immediately and sharply raise the quality of C++ teaching on any school or university that adopts it. * Teachers might be grateful for not having to come up with a course on their own, but having a high quality, ready-made one available. * Anybody who wanders in here and asks about C++ can be pointed in that direction and have an excellent start to his programming career. * It immediately places the student programmer on the path towards good quality code. Thoughts?
Alright, I never wrote code without braces before, and I see what you mean now, and it does make sense too, else from the left binds to the "nearest" if statement, not the one that you'd expect to "surround" all other statements.
Forgot to mention, our project is fully built by cmake, but most of the dependency libraries are not. So it is not possible to include all them as part of our cmake (by using externalproject_add()). Also, it is very unlikely to need to update the dependency libraries (none has happen since project started 2y ago), so I don't think it is necessary to add that "switch" to build them or not in our cmake (assuming all of them can be externalproject_add()) but thanks for mentioning externalproject_add(), it could be useful in the future when we need a dependency that has to be always up-to-date.
One of us can't read the charts. I see that 12% have programmed at most two years using C++, 34% at most five years.
If I read cppreference right, the compiler can do whatever it likes in any case (the layout of bitfields is implementation defined). Still, I don't see the purpose of bitfields, if the compiler then adds padding again. And it seems it doesn't for smaller numbers (as long as a and b together fit in 64 bits). But you are right, setting pack to 1 solves the issue. It's just strange to have to use a non-standard extension to fully take advantage of a standard feature.
Yup I don't know how, but I completely crossed wires reading the first two charts (How many years programming experience). The number still doesn't paint the picture of a growing language, but the death rate doesn't look nearly as dramatic. Edited my original post
most of them said, use https://github.com/fmtlib/fmt
[I wondered the same thing.](https://www.reddit.com/r/programming/comments/bls5y2/program_to_find_position_of_an_element_using/emuhl83/)
It is good library. It gives type safety but not interpolation. Bash: echo "Hi, $NAME" Javascript: console.log(`Hi, ${name}`)
But it makes sense. There can be no variable without type. This must be ashortcut to save writing multiple versions of template function where T is return type.
I hear you, but this is C++. How should a std::string member function get at the to-be-interpolated variables without passing them to the function? fmt::print("Hi, {}\n", name); is as good as it's going to get.
Looked at [https://github.com/jlctools/evo/blob/master/include/evo/array.h](https://github.com/jlctools/evo/blob/master/include/evo/array.h), started counting issues, than stopped. If this is indicative of the overall library quality, I will take a raincheck, thanks.
That's the idea behind string interpolation, putting a variable inside the string with a specific syntax like `{variable}`.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Some more recent work in this area exists in the form of [P0847](http://wg21.link/p0847), which came out of a talk given at CppCon 2018 by Ga≈°per A≈æman called [_My Little `*this` Deduction: Friendship is‚Ä¶Uniform?_](https://www.youtube.com/watch?v=yB4E-SzQPdI). What _I'm_ wondering, though, is where open multimethods ([N2216, _Report on language support for Multi-Methods and Open-Methods for C++_](http://wg21.link/n2216), [_Open Multi-Methods For C++_](http://www.stroustrup.com/multimethods.pdf), [_Design and Evolution of C++: Open Multi-Methods_](https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf)) went‚Ä¶
Oh he was in germany. Fritz coke became quite popular there
&gt; I estimate a couple weeks of one person for every one of the library and for each platform. Sounds like you need a larger build server/workstation TBH.
1. Why you are calling `// simple thread-safe multiple producer, multiple consumer queue` a `vector`? 2. Why are you using `boost::` thread facilities instead of instead of `std::`? 3. Your `begin` and `end` functions are completely and utterly broken - you return an unchecked iterator to the container, which would be (potentially) invalidated with any modifications to the underlying container. 4. Your mixing of mutex and spinlock for concurrent answer is a recipe for disaster. 5. Code lacks discipline - sometimes you do use lock guards, sometimes you do not. 6. You assume the type is default-constructible, which might not be the case. Overall, this is a very poor quality code. General observation - if making thread-safe containers would be as easy as wrapping each method with lock/unlock, this would already be part of STL.
Compilers try to put things on alignment boundaries (whole multiple of 1, 2, 4, 8, ... bytes), depending on the target and type. So if you ask for 24 bit members, it could use no padding on 8 bit procs, 1 byte on 16 or 32 bits procs, and 5 bytes on 64 bits procs. But anyway, bitfield aren't that good anyway. They aren't used often enough for optimizing them to be really worth it. Most of the time you're better off using hardcoded bitwise operations.
Also JavaScript, python and a lot of others. I would love it. It may come in c++34
I've seen this in some languages. I know of at least one that even allows expressions: std:: cout &lt;&lt; $"Hello. I'm {name}. My name has {name.size()} letters."; Although at some point one has to ask if too much sugar is good or bad.
Right now the thread on the learning chat is about linear algebra, the available libraries for linear algebra and the proposal to codify some linear algebra stuff in C++20. The thread in the cpp chat is about printf and ostream and compilers. In the audio chat they're talking about C++ audio libraries and the possibility of an audio standard in C++20. I'm not cherry picking. The includecpp discord server is for C++ and that's basically all anyone talks about. But, you do you.
So, I have checked the Chrono and it might be what I'm looking for. It's nice that commands can be also run via *Python*. I didn't have that much time to study all of its possibilities and features, I will do that tomorrow but so far so good :). Thanks
when reflections is finally added in maybe you can pull something like this off, until then good luck as nothing in the language supports it. You'd basically have to make a hacked together auto capturing lambda and then still parse a string to determine what you're doing... which feasible and slow at compile time; and exceedingly slow and generally impossible at run time.
It's also fundamental to std::shared\_ptr (except it spells it with allocator::deallocate(this))
Here is my library for C++-lize sqlite3: https://github.com/yangacer/sqlite3cpp/blob/master/README.md
https://godbolt.org/z/XSnIY6 is equivalent to the version which was slower.. anywhere you see ways to improve let me know.
I think you posted on the wrong subreddit. Here -&gt; r/ProgrammerHumor
/u/sphere991: &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Isabella Muerte (/ur/slurps-mad-rips) already has this covered with [P1282, _Ceci N‚Äôest Pas Une Pipe: Adding a workflow operator to C++_](http://wg21.link/p1282).
That's not the same thing, no.
Thank you for the detailed feedback. I will try to use CppCheck again. &amp;#x200B; About Clang Static Analyzer. It already has some lifetime analysis in CSA (possibly it disabled by default).
 size_t s = v.size() + count; if (s &gt; v.capacity()) { v.reserve(growth_policy(s)); } v.insert(v.end(), ptr, ptr + count); I had Buffer::append which was doing something along those lines as the backing container for Buffer was std::vector&lt;u8&gt;. Here's the commit from December 14, 2018. Notice the call to reserve on overflow? https://github.com/t0rakka/mango/commit/9e315fcb34d8bf1b0d7fd33696a1ba18da75764b#diff-082d95b359aee203757454f1ebf221d4 At this point in conversation I would like to see your version of the code that improves the performance EVEN IN THE SLIGHTEST AMOUNT. Even 5% will be appreciated!!! It all comes from a budget of 64 core ARM64 __aarch64_ server running streaming real-time compression. More clients we can serve with same amount of hardware the more money will be saved.
So will we be skipping a year, or is that slippage from C++2x?
I don't know the performance, but the code that gcc and msvc generate in compiler explorer looks shorter and more elegant for the bitfield version. I have to do a conditional to do the sign extension from 42 to 64 bits in a portable manner and neither compiler understood how to eliminate the branch. C++ makes right shift of negative numbers implementation defined, but the bitfield access generates the correct sign extension shifts and is portable.
It's very low down on the list of things I want in C++.
Excellent, thank you for sharing your passion project. You seem like a person who wants approval, but this will not make you happy in life. Give what you want and don't expect any thanks. Expecting thanks before it is given makes you entitled, and people can sense it from a mile off. After all, who are you to say how much thanks you deserve? I think you need to spend more time working with others to learn these things. If you spend too much more time working alone, you will find human nature even more confusing than you already do. Take on the worst criticism from this thread and try to understand where they are coming from rather than dismissing their views. Best of luck in the future, I hope you find your job!
 size_t s = v.size() + count; if (s &gt; v.capacity()) { v.reserve(growth_policy(s)); } v.insert(v.end(), ptr, ptr + count); I had Buffer::append which was doing something along those lines as the backing container for Buffer was std::vector&lt;u8&gt;. Here's the commit from December 14, 2018. Notice the call to reserve on overflow? https://github.com/t0rakka/mango/commit/9e315fcb34d8bf1b0d7fd33696a1ba18da75764b#diff-082d95b359aee203757454f1ebf221d4 At this point in conversation I would like to see your version of the code that improves the performance EVEN IN THE SLIGHTEST AMOUNT. Even 5% will be appreciated!!!
Hm, actually you might be right to [call it UB](https://timsong-cpp.github.io/cppwp/n4659/intro.defs#defns.undefined), but it's not the dangerous kind, only the first case is dangerous: &gt; Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).
I think there are way more important features in C++ than this.
Oh, wow. It is weird that it took so long. As a tip, next time you can use &gt; ./candi -j 4 where 4 is the number of CPUs cores/threads that will be used to compile the code. In our workstations, I tend to set this to 24, while in my computer, 4 is a good choice. In any case, if you already compiled, there is no point in recompiling. I hope it all goes great to you!
It only takes about 1 day to actually compile them. but couple week is the time for someone who has never compile them before and try to follow the instruction to setup the build environment to build each of the library in the way that we specified, and import the needed library to our own build, and update the documents. It also include the time to debug and test to make sure everything works after the re-compile.
By quickly glancing the article through - I've picked up " eh\_frame" keyword and tried to github google for it - and found one repository which is somehow involved with eh\_frame parsing, see following header file: [https://github.com/etherealvisage/unread/blob/master/src/dwarfunwind.h](https://github.com/etherealvisage/unread/blob/master/src/dwarfunwind.h) But this is definitely large unexplored area, I'm not daring to go alone. Went into mixed mode call stack determination once - good that been there, done that, but after 4 years don't necessarily want to go into miracles of disassembly again. ( [https://github.com/dotnet/coreclr/issues/23681](https://github.com/dotnet/coreclr/issues/23681) ) Send me mail to tapika-at-yahoo-com if someone wants to bite this bit deeper. I could help, but as a side kick, not main hero. :)
I would firmly assert that gender and race are not relevant to topics such as programming. Feel free to explain to me otherwise. This attitude passively **excludes** people who feel uncomfortable injecting these topics into their daily lives. Hell, it even excludes people who aren't even allowed by their country's law to discuss these issues. &gt; How is inclusiveness political? Due to the modern change of meaning in *equality*, inclusiveness now implies promoting the work and merit of minority groups relative to the rest. This is known as **equality of outcome**, which most people to the right of modern progressivism heavily disagree with. However, I still have to meet someone, myself included, who disagrees with the concept of **equality of opportunity.** Why the need to treat minorities differently? Instead of treating them like children with an "everybody wins!" attitude, **why not just treat minorities like normal people?** It's like trying so hard to not be racist, they go full circle to become the racists. And I don't like racists.
I totally believe that someone can implement data structures in way that easily outperforms those in the standard library (usually by limiting/ focusing the scope and making use of experience gained in the last 1-2 decades). But why reimplement pair? Why reimplement array? Atomics?
I see. So does it make sense for a class to contain values, and have its getters return pointers to said values?
Open spaces should be used as punishment and highly private cubicles as a rewards.
Looking at the first example here: https://nemequ.github.io/hedley/user-guide.html I've always wondered, for a compiler maker that has to support all these different software/hardware combinations, is that what a function could possibly look like? Like let's say you had some std::dothis() function that a compiler maker had to generate. Could it end up just being a crap ton of nested ifdef stmts customizing every single line of code for every single permutation of hardware/OS?
nice try
It needs: * reflection * a standard customisation point to stringise things, like ToString() in C# (yes, there's `ostream&amp; operator&lt;&lt;()`, but streams are meh). With that it should be possible to implement it as a user-defined literal.
&gt; The includecpp discord server is for C++ and that's basically all anyone talks about &gt; &gt;Links directly from the [https://www.includecpp.org/resources/](https://www.includecpp.org/resources/) page: &amp;#x200B; * [Things You Think Aren‚Äôt Sexist, But Really Are - RuthBurr.comRuthBurr.com](http://www.ruthburr.com/things-you-think-arent-sexist/#.WYDWv53TXL1) * [Talk: Not one of the guys - finding myself in an industry dominated by cis men: AlterConf](https://alterconf.com/talks/not-one-guys-finding-myself-industry-dominated-cis-men) * [Where are all the women?: Girls in Tech London](http://girlsintechuk.com/2014/11/12/where-are-all-the-women/) * [How do I get more women to speak at my conference?](http://www.annashipman.co.uk/jfdi/how-to-get-women-speakers.html) * [Coding Like a Girl ‚Äî Medium](https://medium.com/@sailorhg/coding-like-a-girl-595b90791cce) * [The Woman Speaker Slot ¬´ Accidentally in Code](http://www.catehuston.com/blog/2015/03/11/the-woman-speaker-slot/) * [Congrats, you have an all male panel!](http://allmalepanels.tumblr.com/) * [GDS and gender diversity at conferences and events: Government Digital Service](https://gds.blog.gov.uk/2016/03/08/gds-and-gender-diversity-at-conferences-and-events/) * [How to get more women presenters for conferences, and, why there are so few. ](http://lisacrispin.com/2016/04/17/get-women-presenters-conferences/) * [Rob Conery: Diversity and Speaking](http://rob.conery.io/2017/01/25/diversity-and-speaking/) * [Gender-neutral Technical Writing: TechWhirl](https://techwhirl.com/gender-neutral-technical-writing/) * [Managing unconscious bias ‚Äì Facebook](https://managingbias.fb.com/) * [Mansplaining - Wikipedia, the free encyclopedia](https://en.m.wikipedia.org/wiki/Mansplaining) * [What Is Mansplaining? The Origins (And Misuse) of the Term](http://www.makeuseof.com/tag/mansplaining-origins-misuse-term/) * [Straight White Male: The Lowest Difficulty Setting There Is ‚Äì Whatever](http://whatever.scalzi.com/2012/05/15/straight-white-male-the-lowest-difficulty-setting-there-is/) And that's not even a 1/4th of the blatantly misogynistic and misandrist bullshit on the page, ^(but you do you). I just don't want gender/race sprinkled on top of my c++, thanks.
I feel like you may be adding in a bunch of your ideas in to their charter. Are you basing your ideas on conversations you‚Äôve had or just what you read in their webpage? What I got from reading the web page is it‚Äôs just a a bunch of people who like cpp and wanted to provide a discussion forum where people could go and not get harassed for who they are. They are certainly not excluding anyone in any way. You are free to join them, not join them, etc.
Maybe. But you‚Äôre still fundamentally misunderstanding the situation if that‚Äôs your question.
&gt; Who sprinkles their code with calls to new T in 2019? I still do. [https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception](https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception)
Heh, I used to implement atomics for different game consoles, Linux, Windows, etc.. but I say that the &lt;atomic&gt; standard header is God Sent Gift From Stroustrup (GSGFS). The &lt;thread&gt; header also beats having posix-thread code, Windows thread code and God Knows What - all coming in 100 different flavours. These are Good Shit headers - these are not the headers you are looking for (to reimplement). KABOOM; deprecated tons of junk that is now someone else's problem. &lt;chrono&gt; ; tons of boiler-plate crap, just gone.. WHAZAM!! The chrono interface is unwieldy at best.. I mostly use it wrapped up a bit: Timer timer; u64 time = timer.ms(); // duh? Yeah, I know, that's dumb but dumb code for dumb-fucks, amirite? Back in old days, 1990's you wrote your own containers.. it was a bit magical moment to have linked list and array (definitely NOT called vector, LOL) implemented as templates. Tons of C-macro-hell stuff some still adore (Looking at Linux Kernel linked lists) just went away, which was very super cool. These were the primary reasons I started loving C++ in the first place over C. The std library containers were pretty shit for a very long time, weren't available or correctly implemented in many places.. anyone still remembers why some platforms had STLPort? Because there were no decent alternatives, at least unless you forked money over the counter. But that was then, now is now.. the thing with std is that it smells over-engineered. Take something trivial like linear sequence container, smart people always find ways to make it more complicated and convoluted it has to be. I would like to see that smart going more towards something less-trivial like atomic queues and other means to communicate between threads, the kind of stuff we really need now that the Core Explosion is finally in progress. Want more computing power? Go parallel. That's where we want more cool shit at, not trivialities like Computing 101 containers for crying out loud; we already know you can make them crap. Make something good like chrono, atomic, thread instead!!! Every year people think that the world's ready just because it is &lt;current year&gt;, oh, how something like this can happen &lt;this year&gt;.. yeah.. how.. how strange indeed. ;-)
&gt; Are you basing your ideas on conversations you‚Äôve had or just what you read in their webpage? Let's just say I'm familiar with the environment and I don't want to dox myself. I've seen very competent and respectful people get completely erased from forums and repositories by admins/moderators who couldn't handle legitimate criticism about their code, stating that his reviews were patronizing, emotionally abusive and constituted harassment as stated in their code of conduct. &gt; ...a discussion forum where people could go and not get harassed for who they are I believe this should be, and nowadays is, the default for any public forum. The need to explicitly put such obvious statements reeks of virtue signaling. Idk, excluding a few bad apples, the c++ community has always seemed quite formal and respectful to me.
Gender and race are a fact of life. These topics have to be dealt with. Refusing to deal with them or to acknowledge that there are issues surrounding these topics in every community and in our society is myopic at best and willfully ignorant at worst. C++ does not exist in a vacuum. It's written by people in a community in service of the society as a whole. Why you wouldn't want this community to be welcoming to all members of our society is beyond me. I don't see a single blatant example of either misogyny or misandry in those topic titles. Even if I did, headlines are notoriously meant to grab attention, not to provide cogent arguments. And somehow I doubt you read all the articles that are linked above in an effort to explore those arguments. Maybe try writing about the issues you have with these issues in a constructive way instead of labelling something bullshit and picking fights on reddit. And they say sjws are always looking to be offended, yeesh.
it's also kind of ironic that you're pushing us to talk about race and gender in a programming thread because you're uncomfortable with talking about race and gender in programming forums/spaces.
A closer version is the "named argument" feature: fmt::print("Hi, {name}", "name"_a=name);
With C++11 Evo uses the standard atomics. Before that Evo uses compiler-specific atomics. Either way, code using Evo is portable before and after C++11. std::array wasn't added until C++11 evo::Pair has methods for different contexts. This makes Map code more readable, for example: MapList&lt;int,int&gt; map; for (auto&amp; item : map.asconst()) { item.key(); item.value(); }
The conversation here is that there is no reason to write your own vector. You claimed you made your own vector that allowed you to get double the throughput. Just as people might hav guessed, that doesn't seem to have been necessary at all. You asking for a performance improvement makes me think you haven't even followed the topic at hand.
Having CoW string and hardcoding Unicode to UTF-16 seems like exceptionally bad idea.
&gt; Why you wouldn't want this community to be welcoming to all members of our society is beyond me That's a straw man right there. Let me quote myself: *I'm all in for inclusiveness and equality of opportunity.* &gt; Gender and race are a fact of life. These topics have to be dealt with. Refusing to deal with them or to acknowledge that there are issues surrounding these topics in every community and in our society is myopic at best and willfully ignorant at worst Diarrhea is a fact of life too, and I would safely state that it is absolutely tangential to c++. &gt; Maybe try writing about the issues you have with these issues in a constructive way instead of labelling something bullshit and picking fights on reddit. Maybe try writing to neonazis that jews are not an inferior race in a constructive way instead of labeling something bullshit and picking fights on Reddit. Not trying to be harsh, just trying to show you the other side of the coin.
It's not that I'm uncomfortable, it's just that I don't want to mix cake with onions.
This is probably one of the least interesting parts of Evo. But have you given similar scrutiny to STL source? :D If you found any bugs or design issues I'd love to hear about it! &amp;#x200B; Some TODOs I have for Array, but they're low priority: * Support custom allocators * Refactor implementation macros into proper methods/functions
T&amp;&amp; is only a "universal reference" ("forwarding reference" these days) when it is deduced, i.e. a function template parameter. In non-deduced context (like your comment), they are r-value references.
I do not know if you can deduce that C++ is dying. If one third of the programmers have less than six years of experience, that does not sound like a dying language at all.
I can‚Äôt speak to code reviews I haven‚Äôt seen. However, I will assume, as I‚Äôve seen this in many code reviews, that maybe the critique was valid, but the phrasing caused issues? (ie Linus Trovalds levels?) I think the is an art to code reviews, because everyone‚Äôs going to have some ego about his or her code. You can be technically right, but still not helpful if you can‚Äôt communicate effectively. This is true not just on forums but also on the job. As for the c++ community, let‚Äôs just assume not everyone has had the exact same experience you‚Äôve had, otherwise they wouldn‚Äôt feel the need to make such a forum. It‚Äôs a lot of effort and little gain otherwise. Also, moderation is good. We may not agree on what rules are applied to moderation, but that doesn‚Äôt mean it isn‚Äôt a good concept.
Why not just make a variadic print function that converts all the arguments to strings and concatenates them? Then you just put commas in between the strings.
I have not written my own vector. I have used std::vector as internal member of a binary buffer class and replaced it with custom code with the outcome that the throughput increased. The binary buffer is NOT a vector replacement. I admit that I was careless with my wording in the initial comment you focused on but the confusion should be cleared now. OK; so the reserve-on-overflow looks good on your books? Or is complete rubbish? What's the better way?
You wrote this: &gt; Just a while ago I wrote replacement for something as trivial as std::vector for critical path performance optimization. The throughput doubled.
Having + operator that delays combining the inputs until assignment would be a nice feature, at least. string + string -&gt; S(string, string) S + string -&gt; S(S, string) string + S -&gt; S(string, S) S + S -&gt; S(S, S) string = S // invoke S::evaluate() This way the storage for the resulting string would be known at assignment / initialization of string. The storage could be allocated and the S::assign() could walk the resulting type tree and copy the characters into the allocated storage I implemented string class like this back in.. 199x..200x but threw it to dustbin when went full-std in 20x0's. We have the string_view now, which is a fun optimization for playing with strings, especially parsing since avoid a lot of allocation-deallocation overhead. It could still be better with little expression meta template magic sprinked on top.. The only downside I can see is that it requires template meta programming, which is kinda lame.. I had hard-on for that stuff 15 years ago but learned my lesson: simpler code is probably better. It's just string is one of the places where this stuff would actually help.. and make error messages 20 pages long... :D
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;What makes you say that? [The examples given in that paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1282r0.html#examples), particularly the Ranges ones, match up with those shown here.
Of course it doesn't, because it is not std::vector implementation.. I think we got that cleared by now. It is replacing std::vector as a member of a class, not replacing std::vector as a better std::vector! :D
Why bother with this when we have variadic templates? You pass whatever amount of strings you need to concatenate and you get back resulting string. The functions itself does 1 allocation and appends all the stuff.
Does the std::string do that, or is there some specialization that does that for the std::vector, or how does that work? (I am not doubting, I am just not that up to speed with variadic template related optimizations to std::string)
She's proposing just a nee operator spelling that otherwise behaves just like any other binary operator. The only difference with her proposal is whether the Ranges implementation declared `operator|()` or `operator|&gt;()`. With this idea, there's no operator declaration at all. The implementation just is a single, binary function `filter` which can be invoked as `filter(rng, f)`or `rng |&gt; filter(f)` as a language rule. These are very different.
This is not in the standard library yet, only proposed. But implementing it seems really easy if you want only strings. You sum the sizes, reserve that and append.
Oops.. you replied, so courtesy: got what you meant. Have to Write Your Own for now. Ie. unwind the parameters and accumulate size &amp; keep track of what to append after the unwinding is done. Gotcha. Ie. "write a helper function" ; something like.. std::string result = help("my name is ", name, foo, bar, etc);
&gt; The third point is perhaps the easiest to tackle: we could provide decent teaching materials. This would have many benefits: &gt; &gt; I think "dying" is actually a hyperbolic mischaracterization of what I was trying to say so apologies if that's what it read as. But that said, I'm viewing it from the lens of the fact that software as an industry has boomed year over year, as had popularity of the computer science degree. Given that, you would expect the graph to slope the other way.
I suppose only few functions needs ifdefs to know the platform or arch. For instance, you don't care which hardware you're running on while using memcpy, it's the memcpy function that cares about that. This allows you to write a std::vector without ifdefs for instance.
I got a naming suggestion.. the.. CONCATENATOR!!! Umm... maybe not.. probably nicer if it is just one more constructor &amp; assignment operator... but CONCATENATOR!!! sounds so cool.. maybe I write one for laughs and see what happens in the code review on Friday... xD
Like good old `writeln` in Pascal :)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ah, I should have figured that out myself. Now it's obvious! Thanks for punching through whatever was making me obtuse before.
``` template &lt;typename... Args&gt; std::string Concat(Args&amp;&amp;... args) { std::size_t size = 0; size = (std::size(args) + ...); std::string result; result.reserve(size); (result.append(std::forward&lt;Args&gt;(args)), ...); return result; } ```
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;So, like metaclasses, but for functions, control structures, and continuation-passing style!
thanks, stackoverflow
cmake is very easy to get into, and later on, to learn as needs demand...start with simple examples or tutorials online, they're not too difficult to understand
As opposed to Boost.Config and Boost.Predef?
When I learned C, they taught us Assembly first. All of our tests required us to hand compile non-optimized code
Two things that spring to mind when I read what you're looking for : * [Address Space Layout Randomization (ASLR)](https://en.wikipedia.org/wiki/Address_space_layout_randomization) * [Relocations](https://en.wikipedia.org/wiki/Relocation_(computing))
Thanks for posting. Sounds like the conference was a bit of a disappointment. I'm not sure what's going on with the micro-specialization. Also, I think the conference suffers from the fact that it was largely the same presenters. I myself do extensive development in C++ for embedded systems, and I've found that the larger C++ conferences, in spite of not being specifically about embedded systems, offer me a lot more in the way of learning opportunities. Perhaps I'll change my view if/when some of the EmBo++ talks from 2019 are posted on YouTube. They're still on the 2018 videos right now.
[removed]
Envy everyone who lived in that dark pre-11 world.
I can't imagine anyone looking at a bland corporate webpage called "Managing Unconscious Bias" and coming away with the impression it is "blatantly misogynistic and misandrist bullshit".
&gt; Diarrhea is a fact of life too, and I would safely state that it is absolutely tangential to c++. Gender and race obviously intersect with the C++ community far more, since women and minorities seem to report sexism and racism in the C++ community, whereas I don't think anyone has linked C++ to the spread of norovirus.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bm7ol1/any_library_that_features_vehicles_dynamics_and/emvty0c/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Good advice, I was looking at jemalloc and tcmalloc benchmarks recently but could not come to a conclusion if they are better than dlmalloc. I was advised to look for a "higher" level solution such as intel's vmem for custom allocation. Thank you for explaining on mmap, I was not aware of these internal processes.
This has been implemented a few times in C++, but it's lacking the characteristic security flaws of interpolation.
I guess to some people, "don't make sexist/homophobic/transphobic jokes" is considered political. The intent is to obviously make people talk about C++ and not subjects that will offend other people that have nothing to do with C++.
You have all of the necessary information, but for consistency, please include **Technologies** and **Contact** sections. The list of qualifications seems to indicate what technologies you use, but in that section, you can describe what Standards level your codebase typically uses (e.g. "mostly C++14, beginning to use C++17, and our toolchain is VS 2017 15.9"). For Contact, just move your "send your resume" sentence. Following the uniform template helps keep everyone's job posts nicely scannable. Thanks!
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bmcu5s/possibility_of_dynamically_contaminating_a/emvvxhb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Is this the first step in getting asan into windows?
I used this a few years ago in a small thing and it worked fine. https://github.com/ptrv/sqlite3x If you're 100% tied to sqlite I'm not sure there are reasons to bother with a library over the provided sqlite API. The thing I linked is super thin glue.
It‚Äôs absolutely string interpolation. Your definition isn‚Äôt widely accepted.
No that is one form of it. What it really is is using placeholders in the string that are substituted for values at runtime.
&gt; I would firmly assert that gender and race are not relevant to topics such as programming. Feel free to explain to me otherwise. &gt; &gt; when 95% of programmers are men, and when workplaces are full of toxic sexist culture, I think it rather is a little bit relevant These topics are *already* injected into our daily lives, but I personally don't have to suffer from it because I'm a white dude. I get to pretend that its not an everyday thing for other people, but that doesn't mean that it doesn't exist I've read more than a few horror stories from women in the tech space, and every woman I know has experienced varying degrees of sexual harassment - from being groped in public, to generally extremely creepy men, to general toxic behaviour, all of which I've never experienced to even remotely the same degree as a man We don't get the luxury anymore of pretending that these things aren't relevant as people that aren't affected by it. There's no going back to when this wasn't a problem, because it was always a problem - its just that most people in the space weren't affected directly by it
There are of course reasons to ignore any rule of thumb or best practice, but someone asking a very basic question like this is almost certainly is not ready to make an informed decision to ignore a best practice.
No, I don't want this.
Especially LeakSanitizer as it distinguishes between direct and indirect leaks :) But I don't think so: https://github.com/google/sanitizers/issues/686
Okay I think I'm starting to understand. I'm sorry, but could you give me an example in code between a pointer that is owner vs an observer. If it's too much trouble, a link would suffice. I have done my share of googling, I guess I haven't understood it correctly. I appreciate the guidance.
Yes but it would probably over complicate an already complicated language.
Just use clang and you're good to go.
&gt; ... architecture detection ... What do you mean with that?
Nope
As far as I remember, valgrind stopped working on macOS a few years ago.
Ah ok then I misunderstood "We'll fix it.". I did create some tickets fwiw. Not sure why.
I used to manage a team of devs having Mac and Nix systems. We went with CLion IDE. It's noob proof and does the job. As we are very small team so as a pirate bay fan we used crack licence server to use full features. Cmake is enough to configure cross platform builds and linking. Our project was quite big and it builds for all platforms and all cpu archs including for Android. So above worked great. GCC or LLVM is imba enough to ease the CPP compilation pain.
The only implementation of this is the GCC-style [nonnull attribute](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-nonnull-function-attribute), the position numbering scheme is based on that attribute. I don't know why they went with it. GCC's syntax has also been adopted by icc, armcc, and clang (so also some compilers which use clang/llvm such as xlc, emscripten, and armclang). The only way I can think of other than the nonnull attribute to achieve something similar in other compilers that I'm aware of is using [SAL](https://docs.microsoft.com/en-us/visualstudio/code-quality/understanding-sal?view=vs-2015) (the `_In_` annotation, for example). SAL is pretty strictly MSVC-only; the SAL header where all those macros are defined is distributed with MSVC, so if you try to compile with anything else you'll end up with a ton of errors. It's really hard to ifdef around, and there isn't an easy way to define all the annotations away (like `#define __attribute__(attr)` for GCC-like attributes), so you pretty much only see it in code that isn't really concerned about portability, like Windows drivers. Basically, it came down to MSVC or every other compiler, and I chose every other compiler. If you use MSVC and SAL sounds interesting to you, I put together [another header](https://github.com/nemequ/salieri) a while back which you can drop in your project to allow you to use SAL but keep your code compiling on other platforms. Frankly, you'll probably get better results than with all the GCC/clang style attributes; MSVC's code analysis tool is pretty amazing with code annotated with SAL. Even if you skip the "Static Analysis" section in favor of SAL, though, Hedley does still have [plenty of other macros](https://nemequ.github.io/hedley/api-reference.html) which you may find useful.
GCC will generate a warning (-Wattributes). Clang will generate an error. Compilers which don't understand the `nonnull` attribute will not react at all; it is defined away by Hedley. This is a common theme in Hedley. We try to get as much info to the compiler as we can, but if the compiler doesn't know what to do with it Hedley *will not break your build*. This allow you to utilize your own compiler more completely (including the newer features), but also if you can build with other compilers you can get warnings/errors from them (maybe via CI?) so maybe even if your compiler doesn't pick up a bug another compiler does.
Yep, this. There is a question in the FAQ ("[Why?](https://nemequ.github.io/hedley/#faq-why)") which speaks to this: &gt;Partially for my own purposes; every time I created a project I found myself copying the same code into it, which certainly got old, and having to maintain twenty copies of the same thing is definitely not fun. &gt; &gt;That said, the real reason is that I constantly noticed that other projects didn't do the same thing. They simply omitted the features that Hedley makes available‚Ä¶ features which help improve security, stability, and performance. I want software I rely on to be safe, stable, and fast, even if I didn't write it. More often than not people just skip a lot of the cool stuff and miss out on the features.
I think this needs to be a core language feature. IIRC, Reflection will not give you the original argument name of a function parameter.
If only it were so easy.
I actually have [another header](https://github.com/nemequ/simde/blob/master/simde/simde-arch.h) that does that. Or, if you're talking about runtime detection of features (like SSE/AVX/NEON/etc.), I have [some code for that](https://github.com/nemequ/portable-snippets/tree/master/cpu), too. But if you only care about GCC [the `target_clones` attribute](https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-target_005fclones-function-attribute) is awesome.
Thanks :) Awesome, didn't know about `[[(un)likely]]`, thanks! I'll definitely look into it. I see your point about `HEDLEY_DEPRECATED`. It is written that way because it is intended to work as part of a system to help people calling your code deal with different versions (there is [a bunch of info about it in the User Guide](https://nemequ.github.io/hedley/user-guide.html#versioning) if you're curious). I'd probably be willing to add macros with a reason argument; for example `HEDLEY_DEPRECATED_BECAUSE(version, reason)` (I'm not tied to the naming). Would that work for you?
I develop with C++ on MacOS on a daily basis, have never felt I'm missing anything.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bmfzc3/websitesbooks_that_have_practice_problems/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is actually all you need to "get it". The rest is available in the reference documentation.
A lot of code isn't constantly dealing with platform-specific APIs, so it's really not so bad. This is especially common in libraries, for example. All the stuff in Hedley is progressive enhancement. If a macro can't be implemented on the platform/compiler currently in use, the preprocessor basically just defines it away and the code keeps working. You may miss some warnings that another compiler could generate, some compilers won't be able to understand of all your optimization hints, etc., but the program still works. But if your code is portable you can use CI to run it on multiple platforms, static analyzers, etc., and hopefully catch a lot more issues. But yes, code that has to deal with a bunch of different platforms can certainly be pretty annoying. Luckily there is a lot of interesting open-source code out there to help abstract away the differences. If you're curious, you might find my [portable-snippets](https://github.com/nemequ/portable-snippets) project interesting‚Ä¶ And yes, there are lots of ifdefs :/
Hedley is designed to be usable in C as well as C++. There are even [a bunch of macros](https://nemequ.github.io/hedley/api-reference.html#cpp) in Hedley to help make it easier to write code which works well in both C and C++.
Nice nitpick. What kind of wannabe orwellistic authority feels the need to tell people how to think? Manage my unconscious bias? How about you manage your own, and leave people be?
What function parameter are you talking about? The idea is to parse the string, find names in curly brackets, somehow get a list of all variables visible in the previous stack frame and replace mentioned variables with their values.
Why do you find this not easy.
Legacy code. 20+ year old code that has been using msvc for a long time. I‚Äôve been working to get it compiling with clang but it is hard.
Ah, right, that's a pain. I had that on some small projects of mine as well [switching over]. All that time [before] thinking that I was writing correct C++ [not, as it turned out] with sometimes things that we're hard to figure out how to fix it [not helped by 'it compiles in VC'].
Valgrind and [heaptrack](https://github.com/KDE/heaptrack) are the only two that I miss. Otherwise macOS is a pretty comfortable environment IMO.
Damn. these two are quite useful. Is there an equivalent software for Mac ?
/permissive- is such a help for the transition. It leads to the ‚Äúfun‚Äù situation where cl decides to stop because it hit 100 errors in one file. This leaves you with no idea if you have 100, 101, or 1000 errors in that file. Just have to fix up what you know about and then try again. Refactoring tools can only help so much when the problem is something like being allowed to pass a char literal to a function that takes char *. Thanks whoever decided that was a good idea to add as an extension 20+ years ago.
&gt;somehow get a list of all variables visible in the previous stack frame That's just it: don't think reflection will enable you to do this. I actually thought your comment was in a different thread, where someone suggested something like `printf("Hi, {name}", name)` instead of "real" string interpolation.
thank you for the tip. It was weird because my computer in quite new, it has two months. any way, it's compiled
Xcode comes with a suite of profiling tools called "Instruments", which include memory leak checking amongst others. Instruments is definitely not bad, and maybe I just use it wrong, or I'm just too accustomed to the Linux tools, but I still don't find it as useful as valgrind and heaptrack.
If you use Docker or VM's for isolated build environments, making OS-X guest environments is a pain in the neck.
Install Ubuntu in a VM and get the best of both worlds: one codebase, two build environments.
Did you ever had a Mac? Because I had and regret it. Just waste of money. Only get this thing if you're gonna dev for their locked in ecosystem. Regarding what you gonna miss related to C++. Linux-land is a much more sane environment. Ugliness spans from package managers and getting libs to compilers you have to live with. And if you ain't doing it natively, and grab a VM or docker for that, it just sucks anyway.
Fixed the 64-bit thing. It works for 32-bit and 64-bit now. But its still not a drop-in replacement so I don't think it can do what you want unless I was given time to write some wrapper-code (wouldn't slow anything down).
You can use address-sanitizer (`-fsanitize=address` during compilation -- works with both clang and gcc), or something like [libgmalloc](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/libgmalloc.3.html) as a first approximation.
How about: void print_hello_message(const char *name, int age) { std::cout &lt;&lt; "Hello. My name is " &lt;&lt; name &lt;&lt; ". I'm " &lt;&lt; age &lt;&lt; "."; } It looks weird, I know, but we might get that in C++20...
`auto f(){` `struct T{` `int x, y;` `};` &amp;#x200B; `return T{};` `}` &amp;#x200B; `auto x = f().x;`
Thanks! I'll add this to project issues and fix it.
Yeah, looks good. Just anything that works 1:1 with the string so it doesn't unnecessarily limit the interface. I had similar problem earlier with some command-line arg parser library which to every group of named arguments appended `" options:"` and there was no workaround.
Thanks for your input. :) I'll add these issues to my repository and work on them next week.
Since I use Linux from Slack 3.0, I can say that for my use case the switch felt like ‚ÄúLinux without pain‚Äù. Xcode is decent, you can use CLion if you want (I prefer Xcode).
I think men are the real victims of toxicness. I should know. I experienced about 90% negative replies from men. For just sharing something great, that I was enthusiastic about! And that's it! My crime. Of sharing something great and tell people how great it is. If a female did the same thing and got the same reaction, she could accuse others of being misogynist and holding her back. Me? I can't. But isn't it discrimination still? Discrimination against people who have emotions of kindness, friendlyness, openness. (me)... in favour of people who believe in power-structures and makign cruel comments to anything new.
I wrote some amazing code. *I wrote some amazing code*, wrong. Don't be so confident on your work, there's always room for improvement. *And a 10x faster allocator is definitely useful for people making game-engines or programming languages.*, not if it isn't thread safe and 64-bit capable, as that's what people need now. *You look like a king*, the phrases I highlighted shows that you believe a lot in your project, but too much. For instance, as others already told you, does your allocator guarantees ~10x in any situation? - multiple reallocations in a loop - multiple separate small allocations (from 1 to 16 bytes) - multiple separate big allocations (megabytes) - multiple separate allocation, some small and some big - what happens when you run out of memory? - multiple deletes, both small and big - multiple new and delete, alternating, randomised etc. - what if I want aligned memory? What about cache alignment? What about page alignment? What about custom alignment? Last but not least, did you realize that your basically asking *I don't like you, give me a number of someone better.*
&gt; I wrote some amazing code, but it got a bad reception here. And people said a lot of untrue and unkind things about me. This is one of more common code review mistakes: "attack" the code, not the author. &gt; people seem to approach me with the wrong attitude. They don't seem to react well to passion-projects. [...] just to get slammed down on the forum here for all sorts of ridiculous accusations like "you think you are a king" or "Your a bad person because you didn't explain how it works" I live in a place (or just meet a lot) of people who have similar attitude but it's more like: "Why are you even doing this project? You won't get paid for it. No one except you uses it. There is already X. You waste your time. And why even C++ - it's such a bad language full of traps and ugly things". It is really discouraging. If everyone had such attitude, we would not live in the world where GNU and Linux exists. Regarding usability: I have written so many 1000- lines of code projects and they are totally unusuable. But I'm glad I did, they were to learn and memorize the stuff, not to make something useful. Today I can see how I learned. I'm more excited by the fact that my currently going biggest project ever with 10k lines can actually be useful and not only for me. Even if not, it will be a great thing for showcase on interviews. But I'm already using it so unlikely to drop the support. &gt; So... wheres a good forum for rewarding very potentially useful passion projects? A place with a positive encouraging feel to it. Would like such thing too ^^, I need some criticizm on my own project and a source of ideas/suggestions. I'm sure somewhere there is a forum for connecting people that would like to work together on their projects.
So I checked out your posting history to find the thread you are speaking of and ... honestly, I don't think the place you are looking for exists and/or this is the closest thing you can find to it. Yeah, a couple of people were rude and unconstructive. They should learn to do better. Other people should learn not to upvote that junk. But social traits are on a bell curve and there will always be people on the left as much as on the right, no matter the community you are part of. Moderation may help, or it may hinder. An empty community is not a welcoming one either. But for the most part, you did have constructive feedback: that new/delete as they stand are general-purpose and must work reasonably well in all scenarios, e.g. in the presence of threads and high contention. To compare your work to new/delete means to compare your work to those properties; that there are in fact other allocators for use with different scenarios that you might want to compare against and even learn from, and so on. I urge you to stick around. There are some real experts, and a wide breadth of knowledge here that we all mutually benefit from.
\&gt; but couple week is the time for someone who has never compile them before and try to follow the instruction to setup the build environment to build each of the library in the way that we specified, and import the needed library to our own build, and update the documents. &amp;#x200B; I'm not going to tell you whats best for your team/project, because I've neither the experience in general, nor the specific knowledge about your shop to to so, but this sounds broken to me. Once you figured out how to optimally compile your libraries, there should be a well documented, easy to follow procedure (ideally completely automatic) to rebuild them (at least as long as the library / tool versions don't change). &amp;#x200B; In an ideal world, you would put the build scripts into a separate repository and have a CI-job continuously check if they still work automatically.
\&gt; I urge you to stick around I think I'll be on the lookout for something better as this is not any way forward. Also, it wasn't constructive, but dismissive. Let me give you some examples to help: Constructive: * Yeah its really fast. But library XYZ is equally fast, but good job anyhow. (OR) * Yeah its really fast. There doesn't seem to be anything quite as fast, its got a good chance of gaining acceptance if you put some time into it! (This or above, depending on which is true.) * Yeah its fast, but I found a bug while running it. * Yeah its fast, and your tests pass OK. (depending on which is true.) * I think its fast enough to warrant further development, maybe if you ported it, you could get some actual users? (I only got 1 guy being constructive: Hes also made libraries for himself and tried releasing them, so he knows what it's like to be in my shoes). Dismissive/hostile: * Wow you didn't even explain HOW it works, that just makes me angry. There's no basis for your claims and no tests (false, there is a speed-test but he claims theres none.) * Yeah, well... it may seem fast but it won't be once you add multi-threading and its not even tested on real-world applications so it will slow down even more. (both false) * Wow you didn't even add multi-threading? Your project is not so great. 95% of the replies were like this. With false statements (that it will slowdown or that there isn't a speed-test). Or just dismissive. ... So 95% negativity is not a place that gives any way forward.
Is this a rewrite of GFlags? And does it have the same problem that if you include a library that declares flags, they will show up in your cli program?
And no mention of C++...
You make a lot of specific statements with percentages and quotes that are not accurate. Looking through the post your reference, I find a lot of useful criticism and a little bit of hostility. Frankly, trying to sell others on a single-threaded, single-platform memory allocator is like selling a car missing an engine and saying it's a car with low mileage on the engine. It looks nice until you try and use it for something reasonable, like a multithreaded application or any platform but MacOS. Lastly, adding multithreading support \*will\* slow it down, and significantly. This is likely where most of your performance speedup originates, as there is no need for synchronization or locking. I suggest you invest some time in multithreading support, then reassess the performance of your work with proper benchmarks.
I hope they make better use of the text answers than just making a soup out if it. "backwards compatibility" - does that mean people want *more* backwards compatibility or *less*? It could be both.
You *did* get a bit of constructive criticism (though admittedly some of it was poorly worded), and some objections that you were not making a fair comparison because your allocator made different (and very relevant) trade-offs compared to the default allocators. On the other hand, you're replying to those posts in an extremely defensive manner; it seems to me you're looking for validation rather than (constructive) criticism.
&gt;Lastly, adding multithreading support *will* slow it down, and significantly spinlocks are fast.
OK, so where's a community that is actually kind and encouraging and doesn't make false-statements? or get upset if I correct them.
Almost equally verbose syntactic sugar for &lt;&lt; operator. I do not see any significant benefit.
&gt; OK, so where's a community that is actually kind and encouraging and doesn't make false-statements? or get upset if I correct them. When corrections are of the form "you're wrong, I know better than you", I'm not sure there's any community that won't get upset. People don't like being told they're wrong, but they *really* don't like being told they're wrong by appeal to authority; if they *are* wrong, consider framing it in a less hostile way.
&gt; there is no support for arbitrary amount of arguments of 1 type Should be possible with some SFINAE magic.
&gt; `ABSL_FLAG(std::string, name, "you", "Name of the person to greet");` With a macro? I like the approach of cxxopts (or program_options) much more!
It is, already got that reply 20h ago
Same for me! TIL.
This is exactly why you get "hostile" responses.
So where's a better community then? One that's not hostile and hateful. Thanks :)
For someone as arrogant as you? Doesn't exist, mate.
With \`evo::String\` you can just use \`operator&lt;&lt;()\` directly, which appends as it goes. You can \`reserve()\` in advance or let it grow automatically. This is much more efficient than \`std::ostringstream\` Example: #include &lt;evo/string.h&gt; using namespace evo; int main() { String str; // Append string and number str &lt;&lt; "Testing " &lt;&lt; 123; // Clear string and append new string and number str.clear() &lt;&lt; "Foobar " &lt;&lt; 1.23; return 0; } See: [http://jlctools.github.io/evo/evo-0.5.1/html/\_string\_formatting.html](http://jlctools.github.io/evo/evo-0.5.1/html/_string_formatting.html)
I‚Äôve been following this thread all morning in just absolute amazement at how arrogant someone can be so i‚Äôm glad you pointed it out. ‚ÄòYou‚Äôre wrong, i know better than you‚Äô, Jesus, what a statement, it‚Äôs like reading the words of an angry teenager who‚Äôs unable to accept any criticism, life‚Äôs rough, don‚Äôt expect to be pandered to your entire life, grow up ffs
From my experience CoW (and the other optimizations) has been worth it for the performance, and I've found having interfaces with explicit "mutable" methods has improved my code quality. Following the conventions [here](http://jlctools.github.io/evo/evo-0.5.1/html/_string_passing.html) also makes the intent more explicit on how a string passed to a function is used inside the function -- you can tell the intent by parameter types (\`String&amp;\` vs \`SubString&amp;\`). UTF-16 is the "default" with Windows and [ICU](http://site.icu-project.org/home). The main reason Evo even has \`UnicodeString\` is to make it easier to work with Windows APIs and ICU. Otherwise, Evo embraces [UTF-8 everywhere](http://utf8everywhere.org/).
&gt; I don't seem like I'm looking for validation, unless you want to pretend to believe that while blindly ignoring everything. Really..? From another comment: &gt; Constructive: &gt; - Yeah its really fast. But ... &gt; - Yeah its really fast. ... &gt; - Yeah its fast, but ... &gt; - Yeah its fast, and ... &gt; - I think its fast enough to warrant further development ... And just here: &gt; I'm happy to accept people telling me that: &gt; - Something is wrong with it "Yeah its fast ..." It seems in order for something to be constructive they have to give you validation first. And yet you haven't provided comparisons to other well-known allocators that people use for the same reason you present, so how would anyone know "its [sic] fast" to begin with? You even get offended that people might suggest such a thing. Absolutely amazing.
I refer the honourable gentleman to my previous statements.
Thanks for the detailed answer! Makes much more sense now.
I just kind of haphazardly wrap `sqlite3` and `sqlite3_stmt` pointers in `unique_ptr`s and have things like a function to create a `std::string` from the strings returned by `sqlite3_column_text()`. Works well enough for my purposes.
Thanks :) Yes it is very discouraging. Its good to learn! Everyone has to start somewhere. Thats what a lot of people seem to forget.
Does Linux Workload also work with macOS as target?
Pretty much. It's a feature, not a problem. That said, in the linked 'best practices', they recommend not defining flags in libraries.
Does clang actually support address sanitizers on windows?
I find this curious: &gt; In general, don‚Äôt reach for flags. More often than not, flags are poor choices for binary configuration. As global variables, it is difficult to avoid conflicts with other flags, and difficult to deprecate and remove flags once they are no longer useful. And &gt; Prefer to define flags only in the file containing the binary‚Äôs main() function. Although Abseil flags may be defined anywhere in any namespace, avoid any usage outside of main() as it will otherwise be difficult to resolve conflicts. &gt; Prefer to reference flags only from within the file containing the binary‚Äôs main() function, for the same reason. I feel like a good way to ensure that flag the definition/parsing logic remains in main() is by not using globals at all. Isnt that how others like boost program options and Clara do it? Without macros too! Other problems that they mention, such as collisions, would go away too It's also a good incentive for internal APIs of the application to actually expose the inputs they need to function? As opposed to bypassing the whole thing by defining global variables that can be accessed by different C++ files (although it looks like for this to happen with abseil you have to be explicit about it and define them in a header file). Is there something I'm missing?
Yes, but only in release mode, pass -fsanitize=address.
&gt;Gender and race obviously intersect with the C++ community far more, since women and minorities seem to report sexism and racism in the C++ community That's what everyone claims. Yet in my 6 years working in the industry I've never witnessed this. Sure, there are ass\*\*les (like everywhere), but I don't think the topic of C++ and discrimination are inherently linked.
&gt;when 90% of programmers are men (or whatever the stat is), and when workplaces are full of toxic sexist culture, I think it rather is a little bit relevant So the sheer presence of man implies a "sexist culture" for you? Interesting. &gt;we don't get the luxury anymore of pretending that these things aren't relevant Nobody pretended that sexism isn't relevant, but as long as you can't provide any data on it being especially/statistically relevant in the C++ community I don't think it makes sense to discuss it here. Groping someone in public without their consent is, in fact, a crime and hence not debatable. If you're concerned about how these crimes a prosecuted you should probably discuss that on r/law.
I had it working this way at least a year ago. It is a bit annoying to have VS debugger attached to the asan-ed program - VS forgets every time to ignore the exception which asan internally uses.
The keywords and, or, not, are actually quite visually pleasing in my opinion.
it's 2019
Tl;dw, but by your description it sounds like they have an actually empty string to get the size from. They don't need to check if the string is empty to determine if you need to return 0. It sounds though they do need to do the check when you modify the string, to replace the string with some a non-empty instance in order not to mutate the shared empty string. It's the difference between: size_t some_container::size() const { if (backing_store == null) { return 0; } else { return backing_store-&gt;size(); } } and size_t some_container::size() const { /* always valid, even in the presence of empty string optimization */ return backing_store-&gt;size(); }
Ok, I understood that they use an array of bytes (which are initialized to zero) to represent the empty string because they simply go to the starting of the array to get the size **but why is it 25 bytes array**?
For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.
&gt;It sounds though they do need to do the check when you modify the string, to replace the string with some a non-empty instance in order not to mutate the shared empty string. They had to do that check anyway because they used *copy-on write*.
Presumably because that's the size of a normal string object. The size might be stored in bytes 20-24, for example, so to be able to use the same code as for normal strings it needs to be normal string sized.
make sense. It uses 24 bytes (assuming 64-bit architecture) to represent size, capacity and the reference counting (Because gcc was using COW semantics before gcc version 5). So a total of 3 words (3 x 8 = 24 bytes + 1 byte for null terminator). Awesome.
I haven't looked at the code but a guess is *two pointers* (2√ó8 bytes), one to the beginning of the data and one to the end, and a *null character (1 byte)*, which marks the end of all strings, even empty ones. That leave 8 bytes for holding the reference count.
I really like SQLiteCpp: https://github.com/SRombauts/SQLiteCpp. At the bottom of the README there's a list with other wrappers for SQLite.
A 64-bit pointer is 8 bytes, so 25 bytes fits 3 complete pointers: begin, end, and capacity end. The one extra byte is a \0, which is returned by `c_str()`. So actual implementations could be ie: size_t string::size() const { return m_data-&gt;end - m_data-&gt;begin; } const char* string::c_str() const { return m_data-&gt;begin; } m_data would point to the 25-byte array. Which I guess needs to be always in the same location so that the pointers work.
-1 because it's explained immediately before your quoted part. "In gcc [&lt; 5], a string is indeed a pointer to the heap, and the heap data is prefixed with the size and the capacity." (And also the refcount, which he does not mention, but is shown in the slides.) Size (8 bytes) + capacity (8 bytes) + refcount (8 bytes) + actual data (1 byte) = 25 bytes.
&gt;64-bit pointer is 8 bytes, so 25 bytes fits `struct string` `{` `size_t size;` `size_t capacity;` `atomic&lt;int&gt; refcount;` `}` &amp;#x200B; GCC (version &lt; 5) uses Copy-On-Write semantics. So they need to have a reference counting. So I think begin and end pointers doesn't make sense.
I don't mind about the -1. But sometimes some concepts will not be understood by everyone at a single step. So they post questions to clarify them. Thanks.
I discovered that inline namespace can be a useful tool for dragging only a subset of a library in the current scope but still having the whole library available under a common namespace. Apart for user-defined literals I haven't seen that used in the wild.
So that's the 25 bytes (one byte for data) you were looking for right there? I'm assuming data is just stuck after that struct.
I am not sure of the exact implementation by GCC. But yes, 24 bytes of above struct + null terminator.
True. I just thought you are doing it in the wrong order: you are supposed to do the research before posting questions here and [on StackOverflow](https://stackoverflow.com/questions/56059970/gcc-version-5-uses-a-25-bytes-array-to-represent-a-empty-string), not the other way round.
Yes, I agree with you. I deleted the post on SO.
I think there are legitimate use cases for defining flags within a library. It's just not the preferred way to do things for typical use. Consider a flag like --logtostderr. Within Google, this flag is defined somewhere in the logging library. It's available on every binary using that library and always behaves as expected. Developers don't have to do any extra plumbing in main() to make it work. I'm not sure how you could replicate this behavior without *some* library-contained global state.
So I didn't previously know that class template members are only instantiated when actually used, not all at once when you make the class. This means you can write SFIANE code easly (no need to specialize or anything) but it also makes finding /permissive- errors relatiing to MSVCs old "you can use dependent base types without disambiguation" annoying. I did not know about that particular extension, that's not as bad as references to temporaries though :D sidenote: I actually like the -fms-extensions extensions (these are like better unions and stuff)
glib's flag parsing deals with this problem _very_ well imo
How does one join the channel? Seems you need to be invited to join the CppLang channel.
auto is the thing I hate about modern C++ the most - in my opinion the bad use case is EVER using it in C++. auto comes across as some kind of lame attempt to make C++ cool with hip young JS developers at the total expense of readability whilst also circumventing advantages of strong typing such as wrong-type compile time errors (on the flip side I do acknowledge that it helps avoid rare implicit casting errors - but this is not enough compared to the huge practical negatives IMO). I'm sick of reading through other people's code (including hundreds/thousands of lines of library code) where I don't know what on earth is going on because it is littered with auto. In fact, I'm here because I was searching for forums to complain about this. And LOL at the people suggesting it's ok because an IDE can tell you what it is - unless you have spare minutes or hours to sit around hanging the mouse over every variable waiting for Intellisense to figure out what is going on and then making a whole load of notes, that is not a solution. I also read some responses claiming that not knowing the type is not important for readability... wow, let's hope you never have to debug any code involving data types or overloading etc! IMO Don't be lazy, for the sake of your coworkers' sanity just write out the types, it takes a few seconds and can save hours for someone else!! This is not JavaScript, C++ code can be complex and knowing the data types can be crucial to efficient debugging or working with an existing codebase! Rant over, wishing everyone a great day! :)
CoW means very unpredictable performance in multithreaded applications. The usual way to pass stuff between threads is to copy it but with CoW you don't get a copy so there is unpredictable performance penalty down the line. That is why CoW strings are explicitly prohibited since C++11. UnicodeString is a horrible name for UTF-16 string. If you want to be consistent, have UTF8String, UTF16String and UTF32String. Looking at code I thought that String is for execution character set.
Just switched from Ubuntu to macOS. tmux + vim + coc.nvim + ccls works like a charm. Technically I can use a iPad + keyboard to do C++ development...
It's even better: It uses size|capacity|refcount|NULL which is all zeroes so it does not even need to be initialized by init. It's just put in a zeroes area of the loaded binary image.
Just pop your email address [here](https://cpplang.now.sh/) :)
Thanks for the tip :) had the same question.
It is well documented, but there are so many steps for almost every one of them. And it is very hard and some impossible to script all together. It comes to the use case, if something you might repeat once a year and takes two weeks, would you spend 2-4 weeks of time to make it easier at the beginning, but still cost 1week once a year. I thought about it before, decide not worth it. Luckily I am and will be the one to do all this if need it, so it won't take me two weeks, 3-4 days max.
There's nothing cool about cancer, Mike.
Appears to be windows-only? I was wondering if you were going to do something nifty with NACL or something to get your code to run in the browser itself portably. I've done similar things in X11 before, but always feel a bit dirty about it. There's gotta be a better way for one process to communicate to another.
It looks nicer than gflags, but I still don't see a reason to use it over boost program\_options. Not supporting short flags seems like an odd choice.
Okay, that's pretty cool.
To teach a 5 year old how to program? I would recommend looking into Scratch [https://scratch.mit.edu/](https://scratch.mit.edu/) . I do not think a 5 y.o. could effectively learn c++
‚ÄúTell it as if you would for a 5 year old.‚Äù Is a phrase/idiom used to describe a gentle introduction that explains everything in a slow-pace and easy-to-grasp way.
&gt; There can be no variable without type. `void` is a type, so the variable would have type `void`. It's not a very useful type by itself, granted, since like all unit types it can only ever hold a single value, but for consistency in generic code it's so very useful.
Mac used to work really well for dev. But it is no longer the case. Valgrind is broken, compilers are out of date, debuggers refuses to attach to system processes, userland ws compiled by Methuselah, with signed code crap left and right. And it is getting worse, so the long term prospects may not be too good. That said, it is still a competent development environment. So, depending on the toolset you use (ie: what app do you use) and the kind of code you write, you may or may not be happy with a Mac.
Well played.
As far as I understood, coroutines are normal functions that have state. You save both its stack and its instruction pointer. When you return with `co_yield` the state is saved, when it's called again the state is restored. The stack is saved for automatic storage variables and so on, while the instruction pointer to remember where we left.
I think understand coroutines in general. However my experience is that in C++ everything has sharp edges as well as surprising applications. So I want hoping for an in-depth, but still accessible-for-non-geniuses introduction.
One of the edge cases might be recursive coroutines, I wonder if they are allowed, or even possible.
Interesting. Yeah. I can imagine such a thing. A generator that flattens stuff. It could call itself to dive into elements that are non-scalar.
For a long time I thought like you did. I had my own domain-specific language (for controlling industrial devices), and it was great - extremely specialized for its task, with all sorts of cool stuff (I used to joke that its only datatype was the regular expression, which was sort-of true). And then I did a prototype based on Angelscript - and having normal, familiar control flow, normal data types, normal classes, normal scoping rules, etc. proved to be a massive boon. Angelscript is not about its basic types, it's about the functions and classes you extend it with (same as C++ isn't about writing everything using only \[u\]int\[x\]\_t. You wouldn't use integers for version numbers, you'd have a `version_number` class with an overloaded `operator&lt;`, so a script could do something like: const auto version_string = "1.5.6"; if (lib.version &lt; version_number (version_string)) throw ("Please upgrade lib xxx to at least version " + version_string); This is valid Angelcode, btw., assuming of course you have implemented a `version_number` class somewhere. For the rest it compiles into byte code (and the compiler gives excellent error messages), it runs fast, can be used in multi-threaded environments, integrates easily, and is generally a very pleasant experience. I'm not all that clear on what capabilities you would want for a new build language, but consider this: cmake is already targeting C++ users, and by selecting a language that is highly similar to C++ you will make their life that much easier.
yep. the "additional feedback" is mostly just words like "nice", "stuff", "maybe", "really" etc. not too helpfull :(
I think he means "explain like I am 5]
I'd recommend learning Modula-2, if that's still possible (it's old language). That's where I learned coroutines.
Right. I understand the genetics of coroutines. I wrote generators in Python. I would like to understand the C++ version of it.
Hahaha for a minute i seriously thought you looking for resources to teach coroutines to your 5 year old child.
Probably could. All I would need is some props. The bigger question is: would it be ethical? ;)
/u\[CubbiMew\] can know something
From what I've seen the standard C++ coroutines will be an uglified and possibly impracticalized variant of Microsoft's earlier coroutine support in Visual C++. In Python everything's pretty dynamic and as I recall one can hold on to a function's call context even after it's returned. In a language like C++ the call context consists of processor registers and a stack frame. It's gone when the function returns. And so in C++ each coroutine needs its own stack and its own processor register state, just like a thread (except that with proper support I guess it's possible to use linked stacks for coroutines, optimizing the memory usage for stacks). And so a C++ coroutine is best regarded as a kind of *restricted thread* nested in an ordinary thread, namely with the restriction that within a thread, all coroutines have mutually exclusive execution, just one at a time executes. Implementing coroutines in terms of threads, to experiment with them, i.e. implementing that restriction, is however non-trivial. It involves at least some mutex and condition variable stuff. That's sort of paradoxical, because at the assembly language level creating coroutines is simple (I did that as a student in the early 1980s), while implementing thread at that level, is complex.
It looks like `[[unlikely]]` / `[[likely]]` may not be usable unless they decide to change the syntax. The C++20 attribute seems to be usable as [[likely]] case 42: or if (x == 42) [[likely]] { ‚Ä¶ } But Hedley does something like if (HEDLEY(x == 42, 1)) Because that's how all the compilers that support this functionality (at least GCC, Intel, ARM, Oracle, IBM XL C/C++, TI, TinyCC) work. Once C++20 starts to get closer to finalized and I can start testing the implementations I'll check to see if something like `#define HEDLEY_LIKELY(expr) ((!!(expr)) [[likely]])` is feasible.
Looks [pretty gentle to me](https://stackoverflow.com/a/44244451).
Will look, thanks. Although it starting with SIMD sound like a deep dive into computer architecture right there.
See thread run. Run, thread, run. Wait, what's that? That's Dr. DeadLock. He's not nice.
And that‚Äôs all he had to say about that. ;)
wrong MS, but I can ask someone who does
Whether or not a `char` is signed or unsigned is implementation defined. I always thought it had to be signed until I ran across this code: int32_t validateUnicodeChar(const char* text) { int32_t c = text [0]; if (c &gt;= 0) return 1; ... } This code is supposed to check whether the character is an ASCII character. That is, check if the last bit is set or not. If the char on the platform in question is signed this just works, otherwise not so much. It worked on Windows, Mac, iOS and Web (through emscripten) but not on Android.
I haven't watched the video, so I wouldn't have learned about this implementation detail if /u/Almx1 hadn't asked the question without doing proper research. So thank you for your explanation and thank you, /u/Almx1 for your question.
It is used by the brand new Terminal App. That alone is an indication of effort.
For other curious readers: Terminal source code is here: https://github.com/microsoft/Terminal
I'm not thinking this through so it might be a brain fart, but couldn't you just define (std::string) cast operator for your struct in appropriate scope?
I'm not saying it's not being used, I'm saying there doesn't seem to be a lot of activity on the github repository.
Yikes why would you do this to yourself :(. From a hardware perspective alone a transition to a mac pro in this day and age is painful. If I need to ship a mac product, I‚Äôd sooner throw an el cheapo mini in a build farm or something.
That's what I meant. You **should** know people who do.
We can implement the project together, please follow me on github and i will do that also.
Cast operator must be a member function. Primitive types can't have member functions, and you can't extend structs that aren't yours (without UFCS at least).
Wait, which platform? I don't think coroutines are widely supported yet.
Not platform. Standard.
Maybe /u/STL or /u/BillyONeal would know?
Sure, but as far as I remember, they are planned for c++20 if all goes well, did something change?
Yes. They were voted into the working draft.
I wonder what might be the reason for downvoting...
Right, right, but that's the thing. gcc doesn't support them yet, and clang has only partial support, and if I remember MS compiler has a non-standard implementation. How can a tutorial exist before that? Because if you find one, I'd like to learn them too!
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;I doubt the committee would find hitching a preprocessor feature to functionality from the standard library very palatable. As far as I can recall, there exists no precedent for this ever having happened before. It could get‚Ä¶interesting, too, to put it mildly&amp;thinsp;‚Äî&amp;thinsp;Arthur O'Dwyer once pointed some examples of similar dependency troubles that exist because _core language_ features got tied to standard-library types out in [a blog post](https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/#but-there-are-some-magic-types), those being '`std::type_info`' and '`std::exception`.'
I asked for an introduction I think. Not a tutorial.
Your post says "a gentle tutorial." O.o Ok, never mind then.
Oh. Then I was out of my mind. I wanted to write introduction. Ooooops. :)
Howard, I understood everything in your Answer except "*When* `sizeof(value_type) &gt; 1`*, the union with* `__lx` *forces where the padding goes in* `__short`*: Always right after* `__size_`". &amp;#x200B; I understood why they are doing this but I don't what they are doing. I really appreciate if you can explain this with an example. &amp;#x200B; Thank you very much in advance.
Why `!!`? This is not C where you would need double negation to ensure `bool` type
I'm most of the way through reading this and can also recommend it. Very up to date and well written. Teaches modern techniques while still covering old approaches so you can maintain or upgrade legacy CMake. It also teaches all the warts in CMake and offers ways to work around them.
Do I really have to install bleeding-edge gcc and a third-party library to use this C++17 feature? gcc has claimed C++17 support since gcc-7.
I wrote my first template meta program when i was 4. If you don't even understand pointers at age 5 your educational system has failed you.
The short-string optimization is more or less universal in quality c++ libraries. Also 20 nano seconds in nothing, also one branch is nothing. Strings can be fast, but nano second level optimizations and branch eliminations are for tight flop loops, string operations are expected to be on another realm of slowness.
That's the status quo for GSL. I highly recommend you roll your own of their stuff that does what you want. The bugs in not_null&lt;&gt; were embarrassing (you couldn't use unique_ptr and it made copies by value of shared_ptr, for two examples) up until quite recently and it's still poorly implemented.
I like clipp.
Yes, you need GCC 9 and a recent version of TBB. GCC 9 just added support for parallel algorithms in STL.
Removed. Please post this in the stickied jobs thread.
I am late in the party, but as C++ compilers lacks standard ABI Application Binary Interface, it is generally not possible to link object codes generated by different compilers and even different versions of the same compilers. So, one will not be able to link an application built with MSVC (VC++) with a library compiled with Mingw on Windows either as static or shared library. The only way to ensure that a library and an application are binary and other object-codes are compatible is by using the same compiler and same version for building all parts. &amp;#x200B; \&gt; It seems like we chose the better way. What do you guys think? It doesn't seem to be the best way as the purpose of git is to store mainly source code, I guess that it will be pretty slow to compare git logs with a repo of that size. I've heard that the Conan package manager can be used in the local network and can provide source code and compiler-specific pre-built binaries. So, it may another option.
lol ye
OMG! I can't believe that Microsft is adding a new decent terminal to Windows!
Given that a moved-from \`not\_null&lt;unique\_ptr&lt;&gt;&gt;\` violates the class invariant ...
I think I read in a comment that the GSL is pretty much only maintained in the spare time of the new maintainer. But I never had the impression that Microsoft was investing a lot of effort in it and mainly used it as an experimentation platform for standardizing std::span.
MS does tons of cool things nowadays, but sometimes I can not avoid to wonder if some approaches are really that much good ideas of just plain old reflex of embrace-extend attempts (arguably far less extinguish, now). But they have telemetry everywhere so surely they must know: so are there a lot of people out there doing "MSBuild-based Linux projects"? And in case there are: why??? No mistake: I very much appreciate some ASAN integration anywhere, and VS is a very good IDE, and I welcome the general idea. It was just the "MSBuild-based Linux projects" bit that disturbed me; I did not know that exists, and I'm not even really sure I actually wanted to know :P
[removed]
[removed]
I'm pretty sure that C++17 was marked as experimental until GCC 9.0. See the change log below where they state it's no longer considered experimental: https://gcc.gnu.org/gcc-9/changes.html But if you want to use GCC 9.0 without having to install a different compiler, you can use Fedora 30, it comes with it installed out of the box.
Better compile times on a machine with 2x the ram/cpu for less $$$ ;)
[removed]
Casey has asked the C++ Static Analysis team to comment.
I can do my compiles on another machine if I need them to be faster. I mostly work off laptops though.
I was forced to use a macbook pro for a previous job. It's hard to describe how much I hated the workflow. Even if you're not compiling, you still need to do symbol lookups, reindexing files, and more. If your codebase isn't big, and you can throw all your compute elsewhere, sure, but between how crappy the keyboard is gotten and my PTSD, I'm really not planning on going back.
yeah, the reason is this is reddit. I suppose now they will down vote me too.
Yes, the full text of write in responses was sent to the committee and I know people are poring through the responses. Including them here would have made this summary PDF very long...
In its Application Verifier / page heap form, asan has always been there. You don't even need to recompile.
For copy across threads: the solution with Evo is to use param type \`const SubString&amp;\` with a function that would copy across threads. This forces a deep copy. Or force directly with \`copy()\` or \`unshare()\`. High performance code has trade-offs &amp;#x200B; evo::String holds any string and doesn't enforce any character set, though is always bytes/chars. Certain methods will assume UTF-8, where it makes sense. Otherwise binary data works fine. evo::UnicodeString handles a "unicode string" -- this is the same naming used in ICU so those that care about calling a unicode/wide API shouldn't be confused. I get your point though that they can both hold "unicode" strings. This is a fair point.
This is a nice set of articles: [https://lewissbaker.github.io/2017/09/25/coroutine-theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory) [https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await) [https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type) However, for 5 year old we need to wait a little bit until we get standard generator and standard task type and then the 5 year will be able to write simple coroutines without having to roll our own. Possibly (close-enough-what-would-be-in-the-standard-but-not-yet-there) will work as well.
Thanks, these are good questions. I updated the FAQ: [https://github.com/jlctools/evo/blob/master/FAQ.md](https://github.com/jlctools/evo/blob/master/FAQ.md)
Note: I added a "hello world" example to the \[README\]([https://github.com/jlctools/evo](https://github.com/jlctools/evo))
Could 2020 be the year that Windows commandline apps can finally support Unicode properly?
C++ doesn't care about formally proving code anywhere else, so why would it in this case?
It checks for that and errors on access after it‚Äôs been moved out of. Which is completely worthless yet has a runtime cost. It‚Äôs garbage.
&gt; A related problem with that is the inability to pass containers between shared libraries without coming across a cross-module allocation issue. If one shared library overrides operator new, if you pass a container to another shared library, when that container is destroyed it will call the wrong delete. This wouldn't be an issue if the allocator was polymorphic by default. This is actually an issue with how DLLs are implemented on Windows. On Linux you have a thing called a Global Offset Table, where it puts all symbols in the order it detects them. So if you have a library that overrides operator new strongly it will override the symbol process-wide. Windows executables and DLLs have a table per module, and also a heap per module, which complicates things even further. I hate this behavior on Windows so much, I considered writing my own ELF loader for Linux and hack up a solution to output an ELF executable using LLVM.
Buckaroo's dependence on Buck will kill it. Buckaroo is easy on Linux (and therefore on Windows Linux Subsystem): download the executable, put it in your path. Buck, on the other hand: install a bunch of packages and build from source. But then you find out that one of those packages (`watchman`) must also be built from source. So you start on that project only to find out that one of its dependencies (`libfolly`) must also be built from source. I feel like I'm back in 1993. CMake, for as much as I hate it, is just a `sudo apt install` (or `yum` or `rpm`) away. If Buck were bleeding edge, just released a few months ago, I could understand this - you pay a price for early adoption. But Buck's first tag is in September 2015. Is anyone going to want to put up with all that effort to build and contribute to my software? It would have to be really compelling software. Until Buck gets a binary package (or at least a simple installation procedure) I cannot adopt it, and thus I cannot adopt Buckaroo. I'm sure I'm not the only person who is making this decision. I know that my employer (with 700+ developers) also considered and rejected Buckaroo (although their reasons were different than mine).
I found this quite helpful: https://izzys.casa/2019/02/everything-you-never-wanted-to-know-about-cmake/ It's not the most comprehensive reference ever, but the tongue-in-cheek tone hits on a lot of the frustrations I have with CMake, so it tends to address some of the problems / confusions that more optimistic literature glosses over.
besides what others said, gcc has claimed *language* support for C++17 in earlier version, but it never claimed complete library support for C++17. Even gcc 9 doesn't have everything from the C++17 standard library.
Empty STL containers allocating memory is one motivation for [EASTL](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html) My [Evo](https://github.com/jlctools/evo) C++ library doesn't alloc for empty or null containers, and also supports older GCC versions
&gt; I've found that the larger C++ conferences, in spite of not being specifically about embedded systems, offer me a lot more in the way of learning opportunities. As a ground-up entrepreneur, I'll say a word of encouragement to EmBo++. It's not easy to put on a conference. What they might want to do is plan to take a year off. They could have a 3 year cycle -- two years on followed by a year off. Also, judging from a distance, the larger conferences have been going sideways the last few years. Hats off, though, to all the conferences.
Confirm.
Easiest way to try is to pull a `fedora` docker container, and install `gcc` and `tbb` inside.
I like the classic \`&lt;&lt;\` operator. My Evo C++ library embraces it with evo::String [https://github.com/jlctools/evo](https://github.com/jlctools/evo)
[removed]
Lot's of types aren't safely usable in their moved from state. I don't see how `not_null` is special in this regard.
[removed]
Hedley is designed to work in both C and C++, so all the other implementations use \`!!\` (since they're not C++-specific). Even if you don't really need it in C++ I'd rather have the consistency. Besides, C2x will probably add C++-style attributes, maybe this way we can share an implementation.
This question is extremely vague and not answerable. (What is "infrastructure"? What isn't?) Look at the C++ jobs thread for an idea of what C++ is used in.
SSE instructions
&gt; as long as it allows for sane choices and the defaults are the sane choices. That's my primary intention. &gt; Built-in is not required. It can be a separate library. Agree, but there must be some way to static_assert on your assumption of origin units. In case of my solution built-in units conversion is there to provide basic convenience functionality. If not used, no extra space/performance price is paid. &gt; Does your solution allow the automatic creation of big switch statements? I think built-in generation of "switch" statements does not make much sense because you have to put your custom business logic inside each "case". There is a C++ library (used by the code generator) that allows you to parse the schema files and know what messages / fields / frames are being defined. You can easily implement your own auxiliary code generator that generates "switch" statements relevant to your application. &gt; No, it does not. There is absolutely zero proof about that. What proof do you expect? It's all subjective based on one's experience. In my case it does require writing a boilerplate code (I consider manually written "switch" and/or "if" statements to be boilerplate code) which needs to be updated every time you add new message and/or field to a message. In case you design your own protocol, I suppose you can make it simple enough and get away with plain structs with no variable data lengths and/or fields present on particular condition (for example depending on the value of some bit in previously encountered field or version of the protocol). Many (if not most) of already defined third party protocols are not like that. Such cases require extra implementation logic and/or extra data variables (manually written or generated). In my experience class-based designs allows encapsulation of such extra logic together with the data (regardless of having polymorphic behavior), hide unnecessary details and eventually leads to cleaner and easier maintainable code, but again, this is very personal and subjective.
For dev on my [Evo C++ library](https://github.com/jlctools/evo) I mainly use Windows 10 with MSVC for editing and Ubuntu 16 &amp; 18 both running through Windows Subsystem for Linux, and I'm able to directly access the same files from all 3 -- it's great. I use Cmder for terminals and Tortoise Git. I also test on a Mac Mini and often run into all kinds of annoyances: * Apple has their own special Clang/LLVM fork (via xcode app) and it lags on updates * This seems to be the case with "Apple Git" as well * Just xcode command line tools is a multiple GB download for some reason * As others mentioned, some debugging tools like valgrind don't work * POSIX APIs on MacOS have many differences, and some things you might expect are missing or work differently -- if you're using C++11 (or newer) or libs you probably won't run into this * Linux tools like grep, make, etc have many GNU extensions, though you can install many of the GNU versions with [brew](https://brew.sh/) * Brew can also install some common libraries like libevent or boost * Macs require an itunes account for xcode and software updates, which also generally requires a credit card on file -- this just bugs me * Home/End keys -- if you plug in a normal keyboard with them they often won't behave as you expect
See `std::monostate` for a useful empty struct.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bmt1g5/why_cant_i_pass_this_function/emzfefa/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
They may be in an unspecified state, but they do not violate their invariants. (At least in regard to stdlib types.)
It looks like you're passing a pointer-to-member-function. Given `void Cat::meow()`, `&amp;Cat::meow` can be stored in a `std::function&lt;void (Cat&amp;)&gt;`, or `std::function&lt;void (Cat*)&gt;`. Fully worked example: https://godbolt.org/z/iMgrA2
C++ is a common systems language, for stuff with higher performance requirements and such, as opposed to something that is more dynamically typed and loser and possibly even interpreted. It's not that uncommon to use something like C++ for the core of a system and then allow for extensions and customizations via a more 'macro language' type of language that is simpler to understand and with a quicker turnaround cycle. I do it for my automation system. It allows the C++ interfaces to remain internal details, while still allowing customers to extend it via a much less powerful but much safer language for non-programmers to use.
Thank you very much. I will have a look at your implementation.
I don‚Äôt understand the point of this article.
¬Ø\\_(„ÉÑ)_/¬Ø
You need to keep in mind that in most programming languages there's a standardized string conversion function, such as \`ToString()\` (C#), \`toString()\` (Java), \`\_\_str\_\_()\` (Python) etc. This means that every single type is, one way or another, convertible to a string representation, and in no case will the interpolation give an undefined result, since all objects inherit from \`object\` (which has its own default implementation) and primitive types define their own string representations, too. So if you want string interpolation you first of all have to define a default for every single type, plus a contract for user-constructed types. Then, you need a compiler to inspect strings and preform replacements that concatenate strings with those representations ‚Äî this is doable, but you need to statically check that every expression evaluates to something string-representable. It's doable. Only problem is, C++'s evolution is not necessarily about usability.
IIRC from I think yesterday, it has gcc-9.1.1.
TF-1 or TF-2 ?
This explanation of [SSO-23](https://github.com/elliotgoodrich/SSO-23) is pretty much comprehensive. He presents the big-endian version, if you'd work it out [as home-work] you'd see the little-endian version is even simpler.
Python is a glue language. Its never great on its own, but its interop with other language is decent and straight to the point. When you call an import statement, most likely the libraries behind it is written in C or C++. C++ have steep learning curve, but you can use it for almost anything (with an exclusion of extremely ancient devices). To answer your question; yes, it is a common "infrastructure language".
&gt; Nobody knows what "most" C++ programmers do. ‚ÄîBjarne Stroustrup https://youtu.be/g2aDll3QvJY?t=2442
Fishing for free corrections in your consultancy code, huh?
Works for me on Win10
Do you get tired of being summoned to every C++ thread somewhat connected to Microsoft?
They're is still no reason, why `not_null&lt;unique_ptr&gt;` shouldn't compile. It would just be non-movable and non-copyable.
The "glue language" comment is simply old-fashioned and out of date. I have been programming in C &amp; C++ for 30+ years but use and champion Python for most things now.
I was lucky enough to attend a talk from Bjarne Stroustrup a few days ago at my local university, and he said a lot of people are working on it daily.
hi, yes it does; there are two considerations (which we'll be addressing in the future), one is that we support password and private key auth but not keyboard auth (default on OSX), so that will have to be configured on OSX; and two, today we do well with gdb but not lldb, so that will need to be installed
We also do CMake really really well :) MSBuild predates CMake, it has history, and you are correct about telemetry, we do have it and we do use it in the decision making; MSBuild projects have utility, for example the MSBuild Makefile based project is really useful for all sort of things, it provides language services, it can invoke any build, if your build system is not CMake, regardless of what build system you use, and it has robust debugging, with gdb or gbserver. It can be used for IO, and all sort of things. And any of these can be used independently or together.
If your data or types don't form any sort of cycled graph, sharing them is easy even without a library. Problems start when you want to share more complex structures, with different types of relationships between different objects, or when polymorphism comes into play.
&gt; C2x will probably add C++-style attributes C2x? I have seen projects in modern C++, but C? Practically everything I see is so stagnant that it's good to see a project written in C99.
There is also a megadiscussion in /r/windows10 about the new Terminal: https://www.reddit.com/r/windows10/comments/blgbmj/introducing_the_new_windows_terminal/
It is agony, being paid to post on Reddit all day.
I like this a lot. As I split my time between python &amp; C++ I've made something similar in the past - but it wasn't as polished as this. It definitely fills a nice middle ground between nothing and ranges. &amp;#x200B; We're currently stuck on C++11 though (X-compiler must support Solaris 9...) so sadly I can't replace my code.
Its usability completely depends on what you're doing. Python is ideal for doing research and finance stuff due to surplus amount of supporting libraries, but I'm sane enough to not use Kivy for developing android apps or TKinter + pysound + matplotlib for developing VST. Most popular Python libraries are still written in other language as we speak. Hence, its not wrong to call Python a glue language.
I found Hedley to be substantially better documented than both Boost.Config and Boost.Predef for the tasks and actions that I needed it for...
Yeah iterators is definitely one of the things Python does right. X-Compilation really is a bitch. We just recently got most of C++17 working so we can finally get some of those sweet structured bindings and constexpr ifs!
That sounds like more of a reason for Hedley to be a part of Boost. While Boost is a collection of C++ Libraries primarily, Hedley's features also make it easier for C++ Developers to create applications in my opinion. Hedley probably saves several devs a considerable amount of time and ensures their code supports a wider variety of compilers as well. And Hedley espouses the re-usability of code that Boost is all about I believe.
&gt; nothing in the language supports it. That appears to be precisely OP's point when they ask whether we would like it added.
This is a nice way to make an iterator over an on-the-fly computed sequence. I think I'm going to be using this!
Exactly. Containers are our saviors.
Take a look at [CppIterTools](https://github.com/ryanhaining/cppitertools/), it has really nice Python-like iterators too.
Thanks, I'm glad you like it!
„Åã
Thanks for sharing! They seem to be focussed on creating specific iterators, while EasyIterator is mainly about simplifying iterator creation. But they do have some very cool iterators!
This is amazing, and you've inspired me to go back and try C++ again. I've been using Rust for a while but Iterators are one of the big reasons why.
Thats awesome! I haven't tried Rust yet but C++ is really getting better with each release (I can't wait for concepts). If you want, you can check out my other project [CPM](https://github.com/TheLartians/CPM) as well. Having a setup-free dependency manager for C++ was really a game changer for me.
Nice article, although a bit outdated (GCC 4.8.1)
Dude. CPM looks awesome. Sweet jesus. Thanks for that.
You're very welcome :D
Extrafunway: Overload comma operator so that evaluation order is undefined. (Sadly not possible for built-in types :()
Where did you learn all the CMake syntax? I consider myself a decent cmake user and this blew me away
Mostly just by googling what I needed along the way. CMake also has a great documentation, though imo its missing useful examples. There was also this [great blog post](https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right) by Pablo Arias that changed my perspective on how to use CMake.
Both of those choices are silly. I'd rather use an existing mature language.
Work in progress (draft version) of C++20 coroutines resources: https://gist.github.com/MattPD/9b55db49537a90545a90447392ad3aeb#file-cpp-std-coroutines-draft-md
Well, I completely agree with your frustration about the way MS prioritizes their work on features and bug fixes, yet I'd say this particular issue is not that disappointing. Compiler itself does become better and better. Including build times. We recently switched from VS2013 to VS2017, and build times went down by 20%. With approximately the same runtime performance.
What are they saying?
Wow. Cool. Thanks!
I disagree, actually. C++ gets iterators **mostly** right, because it's effectively impossible to split up stateful iterators into ranges for complex algorithms (even simple ones like binary searches). Languages with stateful iterators either need to define custom iterators for these operations (like rayon in Rust) or operate on the container (like NumPy in Python, or just plain lists/deques). C++ has an idiomatic, built-in way to make algorithms generalizable for all containers of a certain type (random access, bidirectional, etc.), which is way more powerful than what is present basically anywhere else. There's just one major issue: writing your own iterators requires a lot of boilerplate, and using them for simple cases is anything but idiomatic. Ranges (and this library) are a good step forward, but one of the major advantages of C++ is its non-stateful iterators.
Assigning the returned temporary to a reference as shown in the very first example is completely useless. I don't understand why people still think there would be an extra copy if it was simply assigned to a local variable.
Nice!
Nice job, though you may want to look at Eric Niebler's `range-v3` library to see what the logical conclusion of this line of programming is. (And it's a glorious conclusion!)
You make a valid point that C++ iterators are incredibly powerful, though I feel that they are actually **too** general and therefore complex to be very useful outside of the std (and boost). When I am writing an algorithm requiring random access, I find it way more intuitive an unknown data type with an index and size method rather than a random access iterator. If I want to perform an operation on a subset of a container, a view type feels better than an iterator pair imo. etc. Of course in the end it all boils down to personal preference, but I really like the simplicity of python-style iterators.
&gt;like there c predecessors their*
This would be good if it was more informed and more professional. Nanovg doesn't have 'dependency hell' (it is actually very easy to get going). Juce is not heavy like Qt (static binaries with no dependencies can compile to 2MB). Saying it is an audio library with a GUI is also disengenuous since it has plenty of controls. Fltk is WAY off here. Static binaries can be under 200KB, which means that "lightweight?". Should not have a question mark after it. It stands for fast, light, toolkit. It also is not 'ugly af' in my opinion, but writing this makes you sound like a child. If all this wasn't enough it is actually pretty easy to compile from scratch. Just load the visual studio solution and build. Also saying dearui has no cons is a bit silly when the components and layout controls are limited.
Wow I haven't head of range-v3 until now. That is an incredible library and a glorious conclusion indeed!
Hi all, I am the maintainer of GSL, and I did mention on a few occasions that I mostly maintain it on my free time. That said, I recognize that this is an omission and I am currently looking into gaining more official support for it. Will keep you posted.
With it? Probably. On it? Not judging from the activity on the official repo at least.
Ah, I see, that makes more sense then. I was kind of hoping Microsoft was paying someone to work on it rather than making people do it in their spare time... thanks for doing the work anyway!
In `Rvalue Reference Qualified Functions?` section is there any danger if we return rvalue references like `Address &amp;&amp; Line1(std::string l1) &amp;&amp; { ... return std::move(*this); }` ?
I'd say it's things that you use to build software -- operating systems, compilers, libraries and servers are examples of infrastructure. C++ is used for all of those. If there's a more important infrastructure language, I don't know what it is. (I may be biased though as I'm working on an on-line code generator in C++.)
Function chaining is an abomination, it baffles me that anyone thinks this makes for readable code.
The best thing about juce is it is such an amazing example of phenomenal design and implementation in such a unified, pleasant to use way. Using JUCE is an amazing way to learn how C++ works and lots of best practices, along with *why* there are best practices.
I still use valgrind on macOS
How? I haven‚Äôt been able to use it for years.
Well, it's THE library as it lives as a very popular std proposal.
I really don't want to get sucked into a debate on this, so let's just say that that is very much not my experience, and if you replace C++ with Rust and C with C++ you'll probably have a pretty good feeling for how that statement looks to me :)
This is primarily another step towards making VS more friendly to the C++ tools that developers use day-to-day, a continuation of the work we've been doing integrating support for CMake/CTest, clang-format, Google Test, Boost.Test, Clang/LLVM, etc. As for ASAN on Windows, you can upvote this suggestion here: [https://developercommunity.visualstudio.com/idea/435735/add-sanitizers-ub-address-thread-etc.html](https://developercommunity.visualstudio.com/idea/435735/add-sanitizers-ub-address-thread-etc.html) but as mentioned in the official docs too ([https://clang.llvm.org/docs/AddressSanitizer.html#current-status](https://clang.llvm.org/docs/AddressSanitizer.html#current-status)) the Windows port is not as well supported as the other ports.
`Any access to the nested state via a function (member or free) disables lifetime extension of the parent. For example Person().GetName().first\_name would no longer trigger lifetime extension of the temporary Person.` I do not understand why it is a surprise for anyone. Here is a quote from Standard 6.6.7/6: `The temporary object to which the reference is bound or the temporary object that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference if the glvalue to which the reference is bound was obtained through one of the following...` Since here the first temporary object returned from function was not bound to a reference, it's life time is not extended and it is destroyed at the end of the full expression.
I think, it comes from a pre-mandatory copy elision times.
I think, it is called `Builder` pattern.
Perhaps, but at the same time I'm not sure that Hedley would be a good fit because it often isn't idiomatic C++. My experience with Boost is that it mostly tries to push idiomatic C++ without much regard for C, whereas Hedley tries to make everything work in both languages, which tends to result in a more C-like API. I'd certainly be happy to work with someone on making Hedley, or substantial portions thereof, available in Boost. I'm just not going to get my hopes up :/
I utterly believe that youtube is one of the worst suited tools to show code. The only tool worse I can think of would be spelling it.
True, that's why it provides link to the source besides the cool showcase video he made.
I don't think though we should aim for Python-style iterators for the base language though, just have syntactical sugar that makes it as easy as possible to define and use Python-like iterators from the existing iterators. That much power isn't worth giving up, and C++ has taken the completely wrong turn by deprecating inheriting from `std::iterator` and the like. We can have stateful iterators from stateless ones (like ranges), and easy-to-define and easy-to-use iterators. Which is why I'm glad your library exists, I just use C++ mostly now for complex algorithms I cannot efficiently implement in any other language.
Thanks! Documentation is a PITA, it's always nice to know that people actually appreciate it :)
I hate to say this but I completely lost track because I tried to follow along while reading the code on the slides... Please use spaces, even if the compiler doesn't need them!! The subject is already complicated, makingtheexamplecodehardertoreadreallydoesn'thelp
It definitely can in some cases but with designated initialisers in C++20 I no longer see the need for it.
My guy Bisqwit has some of the coolest projects on yt, it's all tas coding tho so it's really only about the result.
For people that are interested, the section in question is `.bss`, which is automatically zeroed out on program start.
I didn't fully understand you. Just wanted to state that while I see many projects being made in modern C++ (and moving up with language standards), I hardly ever see a project written in C11 - most are C99 and even though they are C99 their code looks like C89 (eg variables at the top of the scope).
Ok now it makes more sense. I thought you were mandated to use MSBuild as your main buildsys, that's why I found it so weird.
David Krauss researches the origins of this rule [here](https://softwareengineering.stackexchange.com/questions/293813/genesis-of-c-temporary-object-lifetime-extension). It appears to have been established to prevent class copies. In modern C++, there's a much simpler solution to the "gotcha" in this article: don't use references to manage object lifetimes.
You almost certainly didn‚Äôt make one that is better in all situations. Your next goal should be to understand why yours is worse in some situations than all the other good ones.
It got standard approval with iostreams. How that sways your argument, I can't be sure.
Universities don‚Äôt teach c++. They may teach concepts using c++ but learning c++ is a side effect.
Ewww.
&gt; (I guess no one would suggest to store all the third party source code in our git and build them before building our own code, because it is just impossible.) Why not? It's pretty easy to mirror a Git repository, forces you to keep your build system functional, and usually doesn't really take all that long. Depending on stuff that was built "once apon a time" manually means that when you need to update something, you are fairly likely to eventually create a strange difference in behavior because Dave built boost differently than Gary used to, so now some functionality you depend on 'randomly' stopped working or became 20x slower or something because of an optional build flag. The description that somebody builds things by hand for production is actually waaay scarier than checking binaries into Git. If you depend on something really Giant like Chromium, it can become infeasible, but you can still do it for other dependencies without any problem. Something like Artifactory is a pretty common thing for storing build artifacts internally that you might want to look into, but you can also set up yoru own package mirrors and stuff without an integrated solution like Artifactory. Another solution you might look into is Docker. You could make base Docker images with all of your dependencies pre-built, and tell your developers to build inside of that container, just bind mounting the source code for your specific project into it. Generally speaking, checking your binaries into source control is an anti-pattern. It works badly, and the tools handle it poorly.
It is impressive for an older C++ library. I'm not sure what the current state is, but more modern C++ would be even better.
It sounds like you also need some configuration management for the dev workstations. It's possible to use salt (or whatever) to set up the base dev environment with compilers and packages and things, so the developer can just sit down, clone a repo, and run build.sh or whatever on the first day as soon as they get an account, and have it just work. (even if the first build takes a while to crank througha ll the dependencies.)
What does "tas coding" mean?
Also with std::string, as in [this example](http://eel.is/c++draft/expr.call#8.example-1). I'm sure I'm not the only one who think this is the opposite of readable code.
Well my uni teaches C++ but it's a game programming course and we only do C++, so this is a very brough statement but I do agree that if you study software engineering you don't learn C++ usually.
In particular, range-v3 have \`basic\_iterator\` [https://github.com/ericniebler/range-v3/blob/master/doc/index.md#create-custom-iterators](https://github.com/ericniebler/range-v3/blob/master/doc/index.md#create-custom-iterators) . std::ranges::basic\_iterator it is part of C++20 standard now. Also there is \`view\_facade\` - aka range abstraction (also part of standard now). And there is \`view\_adaptor\` which allow you to "inherit/override" another range (this is not part of standard, and probably interface-wise will change). That's all poorly documented on [https://en.cppreference.com/w/cpp/ranges](https://en.cppreference.com/w/cpp/ranges) , mainly because there is still no (non-experimental) compiler support for this, so there is no std::range implementations yet.
Tool assisted. I.e., he's not actually typing it in...it's a program he wrote to make it look cool as if he was typing it
I was mostly curious what "C++ 3.1" was. I think I found it in the video's description: &gt; Borland C++ 3.1
Ah, yeah that seems much more reasonable than what I thought you were saying. My experience is that you're largely right for most open-source projects since we try to make sure the code is usable by as many developers as possible. Proprietary software, OTOH, only needs a much smaller number of people to be able to compile as long as the result is still usable. As for why we're stuck with C99, the reason is pretty simple: Microsoft. MSVC still doesn't fully support C99, and they weren't even close until circa 2013 (when they finally added stdint.h and some other stuff). Unfortunately there is still a lot of demand for code to work on MSVC. MSVC, at least as far as C is concerned, is the IE6 of C development. It's a pile of antiquated crap that holds everyone back, but it's so popular that we can't just ignore it.
Get gud. It‚Äôs not bad at all. The code is pretty neat so spacing isn‚Äôt too big of a problem.
This has nothing to do with copy elision (at least not with copy elision as an optimization or the c++17 RVO). The ABI of most systems mandate that return objects are placed in caller allocated space. Obviously the caller will reserve the space of the final variable for that. So in effect, the calle will always place the return value at the final location
Yeah, I see your point. You mentioned ToString() so I thought that you already constrained the problem to your own structs, but even in that case I guess that all standard classes in C# already implement toString() so your point is still valid.
The part I think that C++ got wrong is the conflation between how I access things with an iterator and the result of calling operator*/operator-&gt;. I think they should be two concepts. This would allow for things like accurately describing vector&lt;bool&gt;::iterator and generators
Missing this: https://coherent-labs.com/products/coherent-gameface/ Relevant since other commercial options are listed.
I think the concern isn't about copying so much as slicing. In a pre-auto world, if you wanted to treat the return value of a function as one of its base classes, lifetime extension is the only way to do that. As far as I know there's no use for lifetime extension at all now that auto exists.
But that tells you nothing about the actually copying. Pre C++17 nothing stoped compilers from allocating this space in a temporary and than performing a copy-construction from returned object into your actual variable.
This is actually a great idea. What we currently do is to distribute VMs, but people find that to be slow for day to day use and end up install the environment natively themselves. The environment setup is complicated but we'll documented. I will take a look at salt or similar. Thanks.
He uses some program to retype everything, it's like a TAS or somem. It's kinda cool but a lot of the videos are just text begin written at light speeds, with only the last few mins begin the actual result. Still one of my favorite of these types of youtubers tho.
Someone cool indeed
&gt;concepts I'm already using concepts and they are really cool. Just give g++ the `-std=c++2a -fconcepts` flags and the stars are all yours!
This episode was great... I happened to be working on a python library at the time and decided to run mutmut against my existing tests and it found real gaps in my tests even though I had 100% coverage and "good" tests
That's not really the case. The standard requires that moved-from types be in a "valid but unspecified state". That, notably, typically means that the type invariants are maintained. This is unpossible for `not_null&lt;unique_ptr&lt;&gt;&gt;`.
That‚Äôs really cool, though I probably won‚Äôt be able to use that for work until it‚Äôs fully supported by all major compilers and platforms. Even C++17 is creating some issues as it‚Äôs not completely supported in iOS &lt; 11.0.
&gt;Incidentally, Java would requires another return at the function end. This is just based on the presence of a conditional whether or not it can be demonstrated to hold in all cases.
Develop under the platforms you target. I would avoid macOS if I could. AppleClang/libc++ always seems to be behind the standard and has interesting... bugs. The OS also has some interesting bugs on major subsystems. I filed Radar but Apple has been sitting on it without doing anything.
I'm with the OP on this. I've been inspired by his approach over the years. One thing I like about it is it makes your software more accessible to those with slow hardware. I also don't think your example is accurate. With a programming language there's more than just letters. Here's one of my functions: template&lt;class...T&gt;void leave (char const* fmt,T...t)noexcept{ ::fprintf(stderr,fmt,t...); ::exit(EXIT_FAILURE); }
Spaces are good man.
is joke
I'd prefer the library not register its flags with a global arg parsing system unless I call a function it exposes which does so. Or is that what GFlags/Abseil Flags already does? Because based on jcar's comment it sounded like it's an implicit registration when the flag globals are initialized.
If the function returns a reference then binding it to a local variable (and not a const ref) creates a copy no?
Formatting does matter though. Putting each call on a separate line would make this much easier to read
There are spaces in my function.
what's a joke?
We use it at my job for firmware development, without any big libraries tho, so no STL, no Boost, etc.. Because the microcontroler is way too small for this. I would say it is not uncommon, but most of the embedded projets I have come accross that were without OS were only coded in C.
Well at least you have a sense of humor, unlike way too many other folks around here.
That's fair. &amp;#x200B; &gt;accross that were without OS were only coded in C. What about with OS? Also, if one needs to land a job in embedded, would one be better off doing C projects? One thing that I need to get stronger at is OS fundamentals. I recall getting blanked out when I was thrown a bunch of OS related questions in an interview.
/r/cpp isn‚Äôt a place for requesting code reviews. It‚Äôs supposed to be for production ready code.
About everyone agrees that overloading the comma operator is as evil as const methods that change the underlying object.
First time anyone said I have sense. ;)
I think you're in the wrong subreddit.
No one from here goes to Cal Poly?
i mean... id be down but 1. idk how this relates to c++ and 2. theres no address or anything so idk if i can even make it in time :/
bro cpp stands for c++ like the programming language c++
With an OS it's really project dependent because it will often be custom built to suit your needs. The last one I worked on was a homemade linux distro, we had a large core library in C, and the product built on top of this library in C++. If I had to choose between C and C++ for embedded firmware dev, I would go with C. You're guaranteed to have that working on any target, and you can pick-up some C++ along the way.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bn6guc/recommendations_on_books_for_a_complete_beginner/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yup my fedora 30 updated gcc yesterday
No elision is and was not as if.
This is already supported by pybind11 out of the box. All you have to do is include pybind's stl header and pybind will auto convert most stl containers into appropriate python containers. Take a look at the documentation for stl. https://pybind11.readthedocs.io/en/master/advanced/cast/stl.html
I don't understand how the first "bad" example shows something specifically wrong with _function chaining_ per se - it's wrong even without the chain of functions. This: auto &amp;addr = Address().Line1("...").Line2("...").State("CA").Zip(12345); ...is just as wrong as: auto &amp;addr = Address(); I mean even most compilers will complain about that. The _real_ nastiness is this: const auto &amp;addr = Address().Line1("...").Line2("...").State("CA").Zip(12345); ...which is also UB I believe. (nasty because it _looks_ like a normal const reference lifetime extension, but isn't... or am I having a brain fart?)
In my previous job I wrote software for several embedded devices, and in all cases we were limited by the platform and what was available. The HW we used was typically the cheapest thing from [MOXA](https://www.moxa.com/en/products/industrial-computing/arm-based-computers/uc-7100-series) or [ICPDAS](https://www.icpdas.com/products/PAC/i-7188_7186/upac-7186ex-mtcp.htm) general purpose microcomputers, embedded into single purpose box/machine. I loved using C++ there. Even if the features were limited (e.g. for the 80186 I used DM compiler, for the Linux there was GCC 2.95.3), etc. You generally don't go too crazy about objects and dynamic allocation. There often isn't general purpose malloc, just mmap that always rounds allocations up to nearest power of 2, so either you use a pool of available memory that you partition to support certain maximum of *users* (whatever that mean in the case), or you keep counters and test brutally to make sure you don't get caught by oomkiller (which cannot be turned off on some stripped-down kernels) and still you program a way to safely restart if you do. Exceptions, contrary to the popular opinion, are okay as long as used appropriately and cautiously. If the device's runtime supports them. It's kinda old-school programming. The embedded software must work flawlessly in all imaginable cases out of the box, and you usually don't have any way of reporting errors, so you program to safely recover from anything. I love the challenge this brings.
embeddedartistry.com has a ton of great content focused on embedded C++
Wait, what will be the output of the following program: std::function&lt;int()&gt; three(std::function_ref&lt;int()&gt; arg) { std::function&lt;int()&gt; local = arg; return local; } int main() { std::function&lt;int()&gt; f = [x=42]()mutable{ return x++; } auto g = three(f); std::cout &lt;&lt; f() &lt;&lt; "\n"; std::cout &lt;&lt; g() &lt;&lt; "\n"; } Are you implying its gonna be: 42 43 ?
 template&lt;class... T&gt; void leave(char const* fmt, T... t) noexcept { ::fprintf(stderr, fmt, t...); ::exit(EXIT_FAILURE); } there I fixed it for you, yw
Likely depends on stability of your particular environment. Last project i was in had C compiler which produced ICEs on not so complex C code. Attempting to go C++ there, would be just a huge yikes.
That's correct. std::function&lt;int()&gt; local = arg; creates a `std::function` that calls a `std::function_ref`, which in turn calls `f`. The function reference has to be type erased, so by the time it's being assigned to the `std::function` it doesn't even know that is references another `std::function` object.
Seems like a pretty bad idea to me, to allow construction of std::function from std::function_ref then. Im sure other people thought that through better than me though. Also, wouldn't: std::function&lt;int()&gt; func_ref(std::function&lt;int()&gt;&amp; f) { return [&amp;] { return f(); }; } Be exactly equivalent to function_ref? Is there any additional motivation for this type?
Here is your example in code form: The pybind .cpp file: \`\`\` \#include "pybind11/pybind11.h" \#include "pybind11/stl.h" \#include &lt;vector&gt; using namespace pybind11; struct Sequence { std::vector&lt;float&gt; feature; std::vector&lt;int&gt; label; }; std::vector&lt;Sequence&gt; generateVectorSequence(unsigned int sequenceLength) { std::vector&lt;Sequence&gt; sequences; for (unsigned int i = 0; i &lt; sequenceLength; ++i) { float iFloat = static\_cast&lt;float&gt;(i); int iInt = static\_cast&lt;int&gt;(i); Sequence sequence; sequence.feature = { iFloat, 1.0f + iFloat, 2.0f + iFloat }; sequence.label = { iInt, 1 + iInt, 2 + iInt }; sequences.push\_back(sequence); } return sequences; } PYBIND11\_MODULE(SandboxPy, m) { m.doc() = "This is an example module using stl containers"; class\_&lt;Sequence&gt;(m, "Sequence") .def\_readwrite("feature", &amp;Sequence::feature) .def\_readwrite("label", &amp;Sequence::label); m.def("generateVectorSequence", &amp;generateVectorSequence, pybind11::arg("sequenceLength"), "Generates a vector of Sequence objects."); } \`\`\` &amp;#x200B; And then on the python side: \`\`\` import numpy as np import SandboxPy as s vector\_sequence = s.generateVectorSequence(10) for seq in vector\_sequence: feature\_data = np.array(seq.feature, copy=False) label\_data = np.array(seq.label, copy=False) print(feature\_data) print(label\_data) \`\`\`
&gt;Seems like a pretty bad idea to me, to allow construction of std::function from std::function_ref then. Possibly, it's definitely an awkward edge case. &gt;Is there any additional motivation for this type? Off the top of my head: * it aviods the need for copies and heap allocation * only has to type erase one operation, so creates less code bloat than `std::function`
I think he has some argument there. A lot of C material is very focused on understanding the hardware you are writing code for, which in turn helps you to write more performance oriented code. Anyone who is writing very high performance code is not going to be using much if any STL and will be writing their own data structures. When you write high performance C++ it begins to look a lot like C, if you look at CLANG source code and watch some of Chandler Carruth's talks. There's also people like Mike Acton and Jonathan Blow, who prefer C to C++ when it comes to writing fast game engines, as C++ features don't really help that much.
Ugh.
&gt;Attempting to go C++ there, would be just a huge yikes. In terms of?
That's why you try to avoid vendor lock-in.
If you have a function from an api that you don't own, and accept the return value by const reference (because you don't need to modify it) then you get optimal behavior with regard to avoiding copies regardless of if the api currently or in the future returns by value or by const reference. If you accept by value. But don't need to modify it, then if the owner of the api changes the api so that instead of returning by value they return a const reference to something stored elsewhere, you now incur an extra copy that you wouldn't have otherwise need to pay for. If you are going to modify the returned value accept by value or rvalue reference (which causes lifetime extension, while still avoiding slicing) otherwise. Accept by const reference to avoid unexpected copie s due to changes in the api.
I think you misread the comment.
At least in the past much embedded code has been written by EEs on the side. Often they just about learned C in uni. The hardware vendors are only interested in locking you into their platform with shitty custom compilers. So yeah C is still dominant in the embedded world. But that doesn't mean you can't code properly in C++ as long as you pick a proper platform that let's you use gcc. You can freely pick the features you need, like enum base types, destructors for automatic resource cleanup and constexpr.
Yes and no. It's more that my answer is horribly written. What I tried to say was: that my uni is teaching us C++ directly not as an side effect. Besides that we do learn computer science aspects based on C++ examples. As it seems my university is an exception.
I work with several Linux based embedded devices now. Most of the code we have there is built with C++ compiler but written by the guys who were better in C, so it is essentially C. Some new code is proper C++, with stl, boost, etc. But our devices don‚Äôt have limitation on dynamic allocation so we‚Äôre writing usual code, without any major changes.
&gt; Also, wouldn't: &gt; std::function&lt;int()&gt; func_ref(std::function&lt;int()&gt;&amp; f) { return [&amp;] { return f(); }; } &gt; Be exactly equivalent to function_ref? Is there any additional motivation for this type? No? int foo(int); function_ref&lt;int(int)&gt; x=foo; `x` can be called on the next line. Yours is UB to call on the next line. `function_ref` is a reference to any callable. `function` is a type erased copy of any callable. Yours is a type erased copy of a reference to a type erased copy of any callable. A reference to a box that can contain anything is not the same as a reference to anything. The first requires a box. Plus, putting a reference to something inside of a box that can contain anything is not the same as a reference to anything. The first requires a box, and it forgets it is a reference. Yours does both. Which means two extra boxes and forgets part of what it is. Those boxes are not free, and they require extra lifetime management. You can strip off one of the boxes: template&lt;class F&gt; std::function&lt;int()&gt; func_ref(F&amp; f) { return std::ref(f); } which is the box containing a reference to something, as opposed to function ref's reference to anything. Here the problem is that the box isn't free, and it forgets it is a reference.
I used this to make a macro to provide a "constexpr" lambda in MSVC2015, which doesn't support real constexpr lambdas. I wrote more comments than I did code explaining how the black magic worked and why it was horrible though :-)
I work for a small electronics company and all our different products run C++14 except for a few projects that are in transition from C99 to the new state of things. Our core framework is planned to go C++17 as soon as those last hold outs change over to C++. And that is on everything from microcontrollers with no OS, over microcontrollers with RTOSes to embedded Linux. So it used to be all C but over the last decade the company and indeed most local companies have transitioned to C++.
Ouch. I was in the same boat. Had to write my own std::apply. Used it to make something very similar to this guy: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1228r1.html And also to turn a crap ton of tuple handling code that was written 15+ years ago with 20 overloads per function to provide a fake "variadic template" solution into real variadic templates.
&gt;One thing I like about it is it makes your software more accessible to those with slow hardware. Wut
Writing an ELF loader for linux? Or for windows?
mutable lambdas are simply structs under the hood. std::string foo; int bar; [foo, bar](){} turns into struct /*unnamed*/ { std::string foo; int bar; void operator(void){} };
&gt; A lot of C material is very focused on understanding the hardware you are writing code for, which in turn helps you to write more performance oriented code. Spent just under 5 years writing C professionally in "high performance" networking and "high performance" industrial control situations. (quotes because high performance means different things to different people) All I can say to your sentence is "meh". I've yet to meet more than 2 C programmers who care about, much less understands, the performance impact of their code, and it's absolutely not the case that any of the academics that I learned C from have any knowledge of this. Had one professor tell me that "int" was 32bits on every computer that had ever been created. He wrote in C, exclusively. &gt; Anyone who is writing very high performance code is not going to be using much if any STL and will be writing their own data structures. When you write high performance C++ it begins to look a lot like C. Citation needed. All of the high performance code I've ever worked with, including several situations where it was standard operating procedure to spend an hour or two every day checking the assembly code that their c++ code generates, made extensive use of the STL and hardly ever strayed into the territory of custom containers. &gt; if you look at CLANG source code and watch some of Chandler Carruth's talks. There's also people like Mike Acton and Jonathan Blow, who prefer C to C++ when it comes to writing fast game engines, as C++ features don't really help that much. Good to know, i'll take a look at material from these folks.
&gt; you can do class_name&amp; class_name::operator=(class_name&amp;&amp;) = default; in a source file (useful for pimpl) There's actually a good argument for doing this regularly. Imagine that there are two possible situations for a given struct. Either that struct has a trivial constructor / destructor, or it does not. Typically, the trivialness is going to come from whatever the member variables are. Something like std::string has a complex constructor / destructor. So if you have a string as a member, it follows that your class won't be able to be trivial. So if you have a trivial constructor / destructor, then having your constructor / destructor defaulted is great, and you won't incur any extra code generation. But if you have a constructor / destructor that's not trivial, and you use = default in your header file, you're forcing every translation unit that includes that header file to generate the code for your constructor / destructor, which the linker will promptly throw away (all but one such, anyway). I also heard, based on a discussion that I had with someone here in /r/cpp, that until C++...20? Not sure which one specifically, using the = default syntax INSIDE the class definition did something bad, but it's a bit late so i don't remember the specifics. So the more "how long it takes to compile" friendly way of handling your gang-of-5 functions is as follows; Declare all 5 in your header, as part of your class / struct definition. Then, in your header file you should assert one way or another if your class is trivially constructable / destructable. Asserting this in your header file is largely to ensure you don't change that property by mistake without also fixing up the following. If your class is trivially constructable / destructable and so on, you should use the = default notation as inlines in the header file, like you would any other inline member function defined outside of the class. If your class is not trivially *tructable, you should use (assuming that you don't want to provide some other definition) the = default notation in the cpp file. From the perspective of consumers of your class, if the code doesn't get inlined (which is rather unlikely, if it's not trivial), there's no difference. A function call happens either way. But if it's not getting inlined, you can save yourself the build-time cost of generating all those extra copies of the function in every translation unit.
The struct that shall not be named.
Furthermore, char, signed char, and unsigned char, are required to be 3 distinct types. Specifically, char can't simply be a typedef to one of the other two. Makes my blood boil, to be honest.
This is specifically *not* what OP wanted. OP is trying to use numpy and replacing the buffer protocol with `pybind11/stl.h` has terrible performance implications for this use case. Also, your formatting is completely broken on [old.reddit.com](https://old.reddit.com/r/cpp/comments/bn49fv/pybind11_buffer_protocol_for_non_trivial_pod_class/).
That is a valid argument for using const ref, but the claims in the blogs unnecessary copies in the first and some other examples are still - to the best of my knowledge- wrong.
(I'm the author of the `function_ref` proposal.) This is a really good article and the discussion during my C++Now 2019 talk was very *very* valuable. One of the reasons why I love C++Now is that not only the audience learns from the speakers, but in almost every talk the knowledge sharing is bidirectional :) Anyway, I want to make it clear that the std::function&lt;int()&gt; three(std::function_ref&lt;int()&gt; arg) { std::function&lt;int()&gt; local = arg; return local; } example is quite artificial - I cannot think of any good reason why you would want to store whatever `std::function_ref` is pointing to (and - as shown - it is not possible). Regardless, this helps me understand that the parallel with `std::string_view` is not 100% accurate and I will make sure to point the issue shown in `three` out when making that parallel in the future.
Yes, but the functions the Blog author is really about at the beginning don't return by reference.
 struct foo; foo bar(void); foo myFoo = bar(); //&lt; The foo returned by bar will be constructed directly into the myFoo variable. No extra copies will happen. So I guess I agree with you.
&gt; Nanovg doesn't have 'dependency hell' (it is actually very easy to get going). Just built `NanoGUI`: one `git clone --recursive`, one `CMake` command, build and run the examples, no problem whatsoever. The list is good, listing the dead ones is also good, the judgements on some of them, not always so good.
Sure but it still an argument in favor of const ref, both for readability and performance. First, the callee could be changed to return a reference (or be overloaded). Secondly, const ref means "I don't care where this comes from, I don't even know if I own or borrow it, just let me read it". Copy ellision is nice but (in this case) is neither a performance nor a readability improvement.
&gt; I also worked at Taligent, which many here won't remember. Some of us do. I was NeXTstep at the time. To be honest, Taligent was supposed to be the big bad wolf that would be eating us all, but when I looked at the doc of the textfield (iirc), I had the clear impression that you needed a team meeting of 8 people to understand how to instanciate one due to the gory multi hierarchy was. Then I got a Taligent demo on a 128MB IBM (prob ppc) that was obviously struggling to do 1/10th of an 8MB NeXTstation delivered, and decided to ignore this (I later had a similar feeling looking at BeOS). I disagree on some of your choices (in particular not using the STL). Not when you made them (because I did the same), but nowadays, it makes no sense to avoid it. Reimplementing Zlib as anything but a wrapper on the zlib is also a waste of time, imo. Reimplementing crypto is a huge security risk. That said, congrats for the work, and the sharing!
If the function suddenly returns by reference, how do you know that the object that reference will be alive long enough for your code to work? What you are saying with taking a referenc is not "I don't care" but that "I trust that the object will stay alive as long as I need it". That certainly doesn't make the program easier to read, because it prevents local reasoning. As shown in this article - you have to know where the returned reference comes from in order to determine that the program is correct. Regarding the performance: The copy elision in this case happens automatically with all compilers I'm familiar with. Check it out on wandbox: For a function that returns by value, there will be no copy. Even with a ten year old compiler, in **debug mode**! Its just simpler for the compiler to do it that way. So, when we just look at the example in the blog, there is no reason to use references at all. If we take into account potential code changes, I'm usually much more afraid of my code breaking than not automatically getting all possible performance improvements. So the only area, where I do think that using a reference to capture the return makes sense is, if I know from the beginning that the function returns a reference and I have determined that it is indeed safe to use (common scenario is e.g. deferencing an iterator or capturing the result of `operator[]`).
&gt; I want to make it clear that the [...] example is quite artificial - I cannot think of any good reason why you would want to store whatever std::function_ref is pointing to That's backward. This is a toy example and of course nobody will write exactly this code directly. I also can not think of any good reason why you would want to dereference a null pointer. Yet given the language don't forbid it, it happens in lots of non trivial programs. Example are a common way to show shortcomings of a design, and it does that job perfectly here. I know there is that legacy culture of letting the programmer shooting themselves in the foot, but I find that very unfortunate, especially given the ever increasing impact of those bugs with modern compilers, and then the increasing impact of the vulnerabilities it yields in a connected world.
The native WSL integration is great.
Want to know a great way to do that? Make some markdown documents that put the document in plain English. By its very nature, you‚Äôll be forced to learn everything, but now everyone else can benefit from your exercise.
Why would anybody ever use that? There's Open Watcom if you want DOS support.
It is fairly easy to something like with variadic templates auto s = make\_string("Hi, ", name, '\\n'); String interpolation is nice, but there are already solution to achieve something similar.
My gripe with std iterators is that they have to own (or at least borrow) the iterated value. Non-owning forward-only iteration is the most commonly used one, so it makes sense that newer languages like Rust or Swift single it out. Not to mention it works beautifully with optionals. I feel that other cases are better covered with collection abstraction, like Swift does it.
What about Templates?
I'm still reading the materials, but it looks like the authors didn't take into account the existence of the two implementations of STM: my monadic Haskell-like [cpp\_stm\_free](https://github.com/graninas/cpp_stm_free) and production-ready [Wyatt-STM](https://github.com/bretthall/Wyatt-STM) by Brett Hall. It would be nice to see the comparison to them.
&gt; we dereference a dangling reference and produce undefined behavior &amp;#x200B; Note that as long as your lambda doesn't capture anything (or capture but doesn't use) this will probably work as expected even though the closure object is already dead. It might explode years later when someone decides to actually use the captured state.
But, does it still compiles with MSVC on WSL? Or it uses Clang, and maybe you need to install it on WSL?
Does MSVC even work on Linux?
&gt; I also heard, based on a discussion that I had with someone here in /r/cpp, that until C++...20? Not sure which one specifically, using the = default syntax INSIDE the class definition did something bad, but it's a bit late so i don't remember the specifics. I would like to hear about this "issue". I can't think of anything changed in C++20 regarding defaulted/deleted members. &gt; A function call happens either way. But if it's not getting inlined, you can save yourself the build-time cost of generating all those extra copies of the function in every translation unit. You sure? If the non-trivial class holds few strings, the class copy ctor will invoke strings copy ctor. I think that the call of the class copy ctor will be inlined but to few calls of string copy ctor. I don't think that you pay the sum of costs of all members all the time - I don't think that the copiler would reiterate over string copy ctor in each class that contains it.
That's why I'm asking. They support WSL natively, but I didn't understand if it still uses MSVC and do some special hacking with WSL or if it uses it like a remote build like with ssh. After all they worked with Canonical to map Linux syscalls to the Windows ones, so everything is possible from my point of view ahah
I think, I didn't make myself clear. Pre C++ 17 elision was an optimization, and standard generally allows optimization under as if rule. Elision optimization clearly broke this rule. However, standard made an exception, and allowed elision even when it changes observable behavior.
Through wine it does.
&gt; x can be called on the next line. Yours is UB to call on the next line. Can you elaborate? I don't see any undefined behavior here.
Why does it need MSVC? Or Clang? What's even the point? It's remote debug/remote compilations, if you are on windows and want to compile for Linux target on a WSL. Here they talk about GCC: https://docs.microsoft.com/en-us/cpp/linux/cmake-linux-project?view=vs-2019
&gt; I cannot think of any good reason why you would want to store whatever std::function_ref is pointing to (and - as shown - it is not possible). This kind of argument can be applied to any bug. I mean we may as well never design anything with safety, security, and rigor in mind because as you said... I can't think of any good reason why someone would want to have a bug or security exploit in their software.
It's undefined behavior even for stateless lambdas.
Only the most advanced C++ developers know how to optimize their programs by reducing redundant spaces!
Bisqwit is weird and crazy smart in all the right ways, love this guy and I don't even write native languages
The difference between your first two examples is that, assuming typical APIs, the first will compile but not the second. Free functions in the vast majority of cases return by value, which makes an expression invoking such a function a prvalue which can't be bound by a mutable reference. And your third example is the entire point of the article.
I misunderstood the article.
No, because WSL is Linux and MSVC doesn't do Linux. Definitely does gcc, maybe clang. The point of the blog posting is that they have made it easier to use Visual Studio when doing work on WSL as compared to connecting to a separate Linux machine or VM.
For Windows. Basically the idea is to use the LLVM linker to output an ELF file, and write a loader that does ~~all~~ most of the work that ld.so does on Linux. The ELF file does still link to things like kernel32 and all, so it's not something that you can run on Linux. Just a different binary format with a custom loader.
Actually, they announced at Build that the next version of WSL has the complete Linux kernel - [https://www.theverge.com/2019/5/6/18534687/microsoft-windows-10-linux-kernel-feature](https://www.theverge.com/2019/5/6/18534687/microsoft-windows-10-linux-kernel-feature)
I know, thanks. The point of the comment is not "it can be safe so go for it", but "beware, it can be hard to even notice".
Had to fix this for my even slower hardware: template&lt;class...T&gt;void leave(char const*fmt,T...t)noexcept{::fprintf(stderr,fmt,t...);::exit(EXIT_FAILURE);}
Is there no room for personal projects that choose not to use modern C++ or STL? Can he not share some code online for people to see without using a traditional license?
So can I use all the Linux syscalls then?
From the same source I see no problem, when it's something like CMake. From the linked article it looks like it can be as easy as switching [configuration](https://docs.microsoft.com/en-us/cpp/build/media/vs2019-cmake-manage-configurations.png?view=vs-2019).
Don't let strangers on the internet police your project. You're the one developing and using it. The C++ community continues to demonstrate its obsession with coding conventions, and language lawyering.
That was one of the motivations, yes.
I try to stick to 80 characters per line. Chandler Carruth and others suggest abiding by an 80 character limit. I could do something like this (I always put a space after the function name): template&lt;class...T&gt;void leave (char const*fmt,T...t)noexcept{ ::fprintf(stderr,fmt,t...); ::exit(EXIT_FAILURE); } Thanks for your comments.
PYBIND11_NUMPY_DTYPE may be what you are looking for. Example where I use it to expose a struct, and also split a float into 3 uint8s. https://github.com/nedrebo/upgraded-funicular/blob/44976a53371ac3fafa1ac896f028be0046703e87/src/Core/PointCloud.cpp#L49
What about just don't use function chaining? It doesn't fix the problem with magic numbers, though.
&gt; The difference between your first two examples is that, assuming typical APIs, the first will compile but not the second. Sure, but the first example doesn't even _look_ valid, and my point was that line was invalid regardless of whether there was function chaining going on or not. (although I take your point that it would have compiled, unlike the second example) &gt; And your third example is the entire point of the article. That _should_ be the point of the article, but for some reason the author didn't do it - their (one and only) example of the problem assigns to a mutable reference, which is never going to be valid to do for a temporary. So they lost the main issue at hand. Although it's not a huge deal - I'm being a bit hyperbolic, I must need more coffee. :)
If we stopped using anything as soon as someone doesn't like it nobody would ever write another line of cpp
I don't know how you define "infrastructure". But even if that definition is "low level libraries", then I'd still say the answer is no. I write end-user applications in C++ and I know lots of others who do too. And I know people who that in C too. If I look at the software I'm using daily, and then check what language they're written in, it seems to be mostly C++ or C. And I'm not just talking about developer tools and such. Things like Spotify, MPV, my desktop (KDE), my PDF viewer, my email client, etc, etc, etc. All end-user applications and most of them are written in C or C++.
It can be very readable code in certain cases. For example the `.then()` continuation model for futures is almost always done as function chains, and is far more readable than alternatives. Although it's also different than the article's example, because `.then()` usually returns a new future (and thus by-value), I believe. Boost [program_options](https://www.boost.org/doc/libs/1_70_0/doc/html/program_options/tutorial.html) also use function chains frequently. Even things like `operator[]` on a [nlohman::json](https://github.com/nlohmann/json) or [folly::dynamic](https://github.com/facebook/folly/blob/master/folly/docs/Dynamic.md) are used as function chains (e.g., `foo["bar"]["baz"]["qux"]`). Obviously it's a different reference each invocation, but the same lifetime issue exists as the article tries to describe.
&gt; I cannot think of any good reason why... template &lt;typename Func&gt; void addCallback(Func func) { callback = std::move(func); } Assume that's a class member function, and `callback` is a class member variable of type `std::function&lt;int()&gt;`. What happens if a user of this class invokes the above function passing it a `std::function_ref&lt;int()&gt;`? Because the above function's pattern is pretty common in code I use. Or variants of it, such as using a forwarding reference and `std::forward`, or even just copying by value, etc.
Yeah. Otherwise, whoever disassembles an application first can just put it up online and go "hey look guys, halo master chief collection is open source now!"
&gt; I cannot think of any good reason why you would want to [...] I find this both obviously true and obviously false. In a way, this is similar to code like: string_view sv = "hello"s; The example is artificial and there is no reason to ever do this, but add a few layers of hierarchy and maybe some templates, plus some delta time where some function used to return one thing and now returns something else... and it'll happen. I don't think we should change either `function_ref` or `function` in response to this particular situation... I don't even know how we would. This is one of those problems that C++ is ill-equipped to handle at the moment.
Or at least link to the comment in the OP. Providing updates on reddit is a solved issue.
Ah yes, the example that stopped working as soon as compiler vendors stopped believing in it, and led to the crazy ad-hoc "guaranteed evaluation order" rules in C++17.
If the vendor cant get C compiler to stability, touching anything from C++ side is likely just a suicide.
Both compilers I mentioned supported them. Obviously you don't go in all template-metaprogramming guns blazing, but that's mostly to keep the code simple, readable and easy to reason about. Both of the mentioned platforms have STL but I often ended up writing custom containers myself, because I needed it non-throwing and working with fixed-sized buffer, or something like flat set. Not always though. If the application was 200 lines long, then for storing small amounts of data, with carefully following preconditions and evaluating worst-case scenarios, you could use STL containers. If someone ends up choosing one of the devices I linked, let me know and I'll dig up my lists of gotchas and tricks I've compiled while working with them.
Who is the target audience for this? What group of developers is targeting Linux software for Linux usage but has to work on a Windows device? When I use WSL I'm more negatively effected by the combined constraints of being on a Windows computer and being in a WSL environment more than I feel the perks of the combination. If I'm doing something for Linux and I'd rather be on a Linux machine. And if not, I'd surely choose macOS over Windows.
What happens if a user of this class invokes the above function passing it a `std::reference_wrapper&lt;int()&gt;`? Same difference. There may be a difference in degree, but it's not a brand-new problem. The blog post is merely calling it out as something to be aware of. Anyway, this would be a problem for the above code even if `function_ref` weren't standardized and people had to keep using `tl::function_ref` or [`llvm::function_ref`](http://llvm.org/doxygen/classllvm_1_1function__ref_3_01Ret_07Params_8_8_8_08_4.html) or whatever they currently use. All "reference to a piece of code" types will have this same problem. Unless they somehow manage to disable the conversion to `std::function`... and `packaged_task` and `fu2::function` and `inplace_function` and whatever else people currently use. It might be a problem specific to `function_ref`, but it's not a problem specific to `std::function_ref`.
Yeah, I used to work with something built on [C167](https://en.wikipedia.org/wiki/C166_family) and you had to occasionally randomly reorder case statements within switch to get the code to compile. It was actually fun then, but I was younger.
&gt; x can be called on the next line can it? isnt it the same like in the video at 1h 15min: https://www.youtube.com/watch?v=WHRao43ab3I
Everyone always says that about the crypt stuff, but it's really not. I think that people have always heard "don't implement your own cryptography" , and that's true enough if you aren't an expert. But I've not done that. These are all well defined algorithms with plenty of available (expert approved) examples. So I've just implemented these algorithms, not created new ones. The secure channel stuff is just in fact a wrapper around the Windows secure channel stuff (which itself is so stupidly complicated and under-documented that it's a mental security risk because no one can understand it.) And I also respectfully disagree on stuff like Zlib. The thing is that that means it works in terms of my memory buffers, my error logging system, my exception system, my statistics system, my assert system, and so forth. If you use third party stuff you can't really integrate it, you can only attach it. CIDLib is about really integrating stuff. It's a really powerful thing, though of course it does take a good bit of effort.
Luckily the code I was stuck working on wasn't that old this time. I have worked on stuff that old though so I definitely know your pain. Definitely a reason to break out the vodka.
LOL what a clusterfuck. To clarify, this isn't the original example. The example in the video: int get_number() { return 42; } const function_ref&lt;int()&gt; f = &amp;get_number; std::cout &lt;&lt; f() &lt;&lt; '\n'; Note that `f` is initialized with a pointer to the function, instead of directly with the function itself. As it stands now, that pointer to the function will get created as a temporary itself, and by the time `f` is invoked, that pointer will no longer exist. Very weird.
yes it's black belt stuff you won't understand little grasshopper
my life
The entire Xilinx FPGA SDK is C and C++ [https://www.xilinx.com/html\_docs/xilinx2018\_1/SDK\_Doc/index.html](https://www.xilinx.com/html_docs/xilinx2018_1/SDK_Doc/index.html)
yes
I actually never thought about using constexpr as a hard-check for undefined behavior! Really nice idea
Author here. I'd say the project is relatively experimental, but I'm wondering if the idea of a template-based ECS framework that generates an engine tailored to your systems and components would be something worth exploring further. Does anyone know of similar projects out there?
&gt;So my options are agree with you or I'm an arrogant a-hole? You can respond with: 1. Humility, or 2. Obstinance. &amp;#x200B; Only Humility will help you grow as an engineer and a person. Obstinance will be a brick wall that obstructs your progress through life.
It would be much easier to simply republish it under the Boost Software License, which has undergone extensive legal review: [https://www.boost.org/users/license.html](https://www.boost.org/users/license.html)
Public moderation creates more bang for the buck
I think it's too late for that.
Well, for one that wasn't exactly the nicest reception anyone ever got in the internet, and I was a bit tired of it by then. And for another, this is the internet, where everyone wants something different, but if you don't agree with them all, you are being obstinate. Not to put too fine a point on it, but it's my project, I'm the one who sacrificed my adult life to do it, so I did it the way I want it. Anyone who likes the way I want it, it's there for them and free. If they don't, it costs them nothing not to use it. So accept it as it is or ignore it, problem solved.
How to use variadic templates! Still a beginner, but drilling through the language step by step.
I cannot really see why myself. The standard says that this is just the way it is, but not *why*. I would guess there is a good reason though, otherwise it is a very strange choice indeed.
Neat article but unfortunately this is not a good way to actually determine if something is undefined behavior. The amount of work that would be needed for compilers to implement this feature is simply not feasible, and alas, none of clang, GCC or MSVC implement this other than for trivial instances. For example this is undefined behavior but goes undetected: &amp;#x200B; constexpr void f() { int\* x = nullptr; { int z = 123; x = \&amp;z; } \*x += 1; }
`-Wlifetime` catches this. https://godbolt.org/z/__qqLL
Nothing in your code is actually evaluated aft compromise, so no wonder that no compiler catches it.
It's still undefined behavior as is. Even in your revised example GCC accepts it, clang rejects it.
Developing libraries that should work on multiple different platforms with multiple different compilers is quite common. With this I can develop my code in VS-Studio for windows and immediately check if it also runs on linux with gcc.
Well if you do cross platform development you can directly try it. Better than waiting for the CI. Also helps making sure msvc isn't going to throw a tantrum when trying to compile your Linux fix
That's a cool new feature. Here's another example of undefined behavior that goes unchecked by all compilers, don't know of a flag that will catch this: #include &lt;bitset&gt; #include &lt;iostream&gt; constexpr auto f() { constexpr std::bitset&lt;0&gt; a; return a[0]; } int main() { constexpr auto i = f(); std::cout &lt;&lt; i &lt;&lt; std::endl; } Overall, don't think it's useful to rely on ```constexpr``` to find undefined behavior. Seems really wonky in practice.
Yes, it is undefined behavior, but the compiler is only required to catch UB if it happens during compiletime evaluation. The compiler is not required to perform a static analysis of constexpr function. If gcc doesn't catch that example, that's a compiler bug.
WSL 2 is a lightweight Hyper-V VM that starts in about 1-2 seconds, uses 500 MB of RAM and has some network/filesystem integration.
That's my point, no compiler implements this aspect of ```constexpr``` to a degree that can be relied upon. I posted another example that no compiler catches, not even clang here: https://old.reddit.com/r/cpp/comments/bncvmm/exploring_undefined_behavior_using_constexpr/en5r9dm/
Some knowledge should remain forbidden
This is my go-to ECS framework: https://github.com/skypjack/entt. When developing with it, I feel like writing in a prototyping language üòã.
Excellent ideas here! I've been working on my own template-based ECS framework, except mine only has Systems which manage their own memory entirely and register components via type traits. Template prototyping is the way of the future IMO, especially for ECS. great job!!
&gt; The above program is ill-formed (by [except.throw]/5). But every vendor will compile it successfully. And every vendor will run it successfully ‚Äî except for MSVC. MSVC will triple-delete the state_ member of the exception object (once from the stack, and then again from the heap, and then again from the stack), leading to heap corruption and crash. This was an interesting read however it's 2 AM on a Sunday and I've had a few so I think I'm missing something. If the code is ill formed according to the standard, does it matter that MSVC doesn't handle it the same as other vendors? Invoke undefined behaviour, get undefined results.
Looks very cool! It seems like there are a few similar ideas. It's interesting to see what's different though. So far I can see that signals go through function pointers, whereas I made it so dispatching a signal effectively compiles down to inlined function calls to the various handlers, the "framework layer" disappears. Also it seems like the storage system is quite a bit different. It uses a sparse set as the underlying data structure, whereas my implementation maintains separate vector-based registries for entities and each type of component. I also buffer creation and deletion operations at the registry level to prevent the internal vector from resizing when the user iterates over it.
Thank you I will check this out.
Thanks! I agree templates open a lot of possibilities for ECS frameworks. I'm also really hyped for metaclasses and how they could allow us to take everything even further.
I sometimes summon him for C related issues lol.
their code formatting is non-existing.
Not really. It's only undefined if it actually happens. It's not undefined if the function is never called.
ill-formed != UB This is a diagnosable rule per [intro.compliance]
I already addressed those points elsewhere.
Well, in the grand scheme of things, Watcom was relatively unknown back in the DOS days. Borland on the other hand was big enough to be generally viewed as a direct competitor to Microsoft. Their "Turbo" lineup of dev tools were rather ubiquitious (Turbo C++, Turbo Pascal, e.t.c) and frankly just fine for what they were at the time. Obviously, this raytracer was not actually written back then, but it's not difficult to imagine why someone might reach for BC++ 3.1 if they had "authenticity" as a goal. The compilers originated by Borland, now owned and developd by Embarcadero, still extend C++ in some ways I personally wish were more widely adopted, BTW. E.G.... properties! Real properties. Or at least as real as they can possibly be in C++. Plus like, I read a proposal about "C++ metaclasses" perhaps six months ago, that was literally just describing exactly interfaces as they've been implemented in Delphi and other Object Pascal implementations since ~1996 or so. Come on guys. If we do it, cool, but let's not pretend it's anything new or interesting...
Fair, should have been more precise with the standardese. If it's ill formed but not 'no diagnostic required' then the problem seems to be not that MSVC does funky double frees but that it doesn't spit out an error message on compilation. Is it just the wording of the article that is off then, since it seems to suggest the code is ill formed for everyone? The other vendors are compliant because they don't arse around with the stack and therefore for them the code isn't ill formed?
What is the difference between your algorithms and STL?
Technically, *all* the implementations are non-compliant because they don't emit a diagnostic. But there's strong precedent for not actually emitting the diagnostics for documented extension, so it's reasonable to say that MSVC is "more non-compliant" because it introduces undocumented UB.
There is my single-header ECS implementation: C++14 Entity Component System (work in progress) https://github.com/BlackMATov/ecs.hpp
From the linked repo readme: STXXL is an implementation of the C++ standard template library STL forexternal memory (out-of-core) computations, i. e. STXXL implements containersand algorithms that can process huge volumes of data that only fit on disks.
Definitely programming in hard mode, unless you are smart about having very minimal shared state.
Not going to lie, I had a really rough time with CMake in the beginning. I'm still no expert but I use it for everything now. Googling "modern CMake" has given me the best results for best practices using CMake 3.x.
This is exactly how I'm feeling right now after researching cmake for the past few hours without making any headway on implementing its use. I would really appreciate it, thanks.
My rule of thumb? Don't, unless absolutely necessary. *I wish I followed my own rules more closely. I would have saved myself a lot of headaches.*
It's "git gud", ya scrub lord
Right, but I want to know how this changes things. I‚Äôm asking about the details.
Multi threaded applications are actually quite approachable with modern C++. The best thing I can recommend is to read up on the tools provided to you in the standard library. Look up condition variables, futures, promises, Async, mutex, unique locks on cplusplus.com. Try the examples out.
You cannot use quicksort anymore, for example. And iterators are not tiny wrappers around pointers into memory (file offsets instead?).
It's best to avoid shared state entirely if possible and communicate with messages between threads using queues etc. But even then you have to be careful when sizing your queues or making operations on them blocking / non-blocking.
The answer is: you want to use it from the very beginning, even if you just had one source file. See [here](https://www.reddit.com/r/cpp/comments/blz0w1/whats_a_good_resource_for_learning_cmake/) for resources on learning CMake. In particular, the book [Professional CMake: A Practical Guide](https://crascit.com/professional-cmake/) is structured in such a way that beginners can find easy footing and make fast progress. I can highly recommend it; even if it is not free, it is an excellent investment.
Second the request for links
Are you saying it‚Äôs recommended for all projects? Even small 1 file projects? Let me know if I misinterpreted your comment. If that‚Äôs the case, this is the first time I‚Äôve heard this. And now I‚Äôm wondering why it wasn‚Äôt recommended/required in my C or C++ classes I took. Thanks for the recommendation on resource. Personally I think it‚Äôs weird that there isn‚Äôt any free online simple tutorial that anyone can recommend.
Please keep memes to r/programming
It's actually not that hard. But, like everything, it's hard until you've done it quite a bit and get the issues. The key thing is figure out what needs to be shared, and strictly limit how it can be accessed. The more paths to accessing it, the more paths that you have to try to understand the interactions of. If you can't mentally picture all the possible scenarios, it's probably not strictly controlled enough. Using what I call 'lock janitors' which will lock a mutex on a scoped basis and make sure it is unlocked upon exit of that scope, is a really, really useful tool. You always will want to have a minimal scope that you lock things for. Aways avoid if possible having two lockable things. If you absolutely must, create a specialized lock janitor that always locks them in the same order. If you have two lockable things and one thread locks A and tries to lock B at the same time that another thread locks B and tries to lock A, you are doomed. Anyhoo, it's hard to really cover all the issues in a post. But ultimately it's just a matter of experience. You work out techniques that work for you and that you understand the consequences of.
Try this https://cgold.readthedocs.io/en/latest/ I use it even for 1 file throwaway test. In that case is a 5 row cmakelists. Txr. It isnt requires because there are many other ways to manage the builld besides cmake. Visual studio projects Make Meson Scons Bazel .....
Quicksort is in-place so you totally could swap around data on disk. Memory offsets or file offsets, doesn't matter because the standard iterator abstraction is fine with either. Hell you could just mmap the file. Obviously this doesn't cut it for all of big data processing but the key differences are something else.
allright
np, I have 10 videos out related to C++, continuously producing and publishing more. It's all in the playlist. &amp;#x200B; Thanks
Of course, technically you can apply quick sort to such data. But it will be *much* slower than merge sort on a HDD because of high latency of random access. You might use SD, but their size and price will really limit your data. And just mmap'ing is not a solution either (really large data will not fit ptrdiff range). Random access to large datasets is way slower than sequential one, you have to account for that. And there might be not a file, but set of files across set of drives...
Thanks. Yeah I realize that. I've always used visual studio on my pc and xcode on my mac that's why I'm confused by the other comment
This 'creating intermediate out of bounds pointers is UB', that's where C++ goes *OTT* again. How is the situation in C?
If you ask about cmake people speaks about cmake. For me i prefer cmake even when forced on VS.
read concurrency is action imo https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition
I'll be interested the day VS runs natively on Linux... Meanwhile I'll happily just keep using QtCreator
I purposely left out the standard library because [\[expr.const\]p4.6](http://eel.is/c++draft/expr.const#4.6) explicitly leaves out the standard library: &gt;an operation that would have undefined behavior **as specified in [intro] through [cpp] of this document** .. The standard library can do all sorts of strange things and can rely on things outside of standard such as builtins or rely on implicit knowledge of what the compiler will do which is not advisable to user space programs. [offsetof](https://twitter.com/shafikyaghmour/status/999338780958969856) is an example of this.
Simple c++ programs require only simple cmake files: # In CMakeLists.txt: cmake_minimum_required(VERSION 3.5) project(MyProject) add_executable(my_exec src1.cpp, src2.cpp src3.cpp) That's it. I don't see any reason to not use cmake even for very simple projects. Where cmake becomes complicated is when your projects become complicated (e.g. lots of dependencies, platform specific build logic custom build options you want to provide to your users etc..) But at that point manual compilation via the command line isn't really an option either.
CMake is one of the better options but is still kind of shitty. There are alternatives. You could also just maintain per-platform build systems. It's not as bad as people make it out to be if you have less than 2 or 3 to maintain. If your projects are structured to require heinously complex build settings, maybe fix that before trying to use CMake to solve your problems.
I just gave up on msvc. From time to time, the compiler would give you weird ICEs even in preview branch. Switching to clang as a drop in replacement feels so much better.
&gt; Even small 1 file projects? Honestly, no.
&gt;And now I'm wondering why it wasn't recommended/required in my C or C++ classes I took. Probably because they wanted you to focus on the actual programming language. Trying to learn both at the same time can certainly be distracting. As you know by now, CMake can be hella confusing and your teachers might not have wanted to have to help all their students with all their CMake problems on top of their C++ problems. But yes, would definitely recommend using CMake for every project at this point. Also, if you're authoring a library for public consumption, make sure that you also export your build targets correctly to make it easier for others to install your library.
A much more reasonable approach is to look for a higher level task library and use that. Using mutexes and condition variables is similar to using `int* arr = new int[5]` to create an array. Sure, a c++ programmer should know how to do it, but also be wise enough to use higher level constructs (e.g. std::vector) when appropriate.
What libraries do you suggest looking into?
Yes please! If your project is small, setting up CMake should be fairly simple, and it makes it ridiculously easy for other users to consume your project. Basically just add_subdirectory on your folder, and then target_link_library. Now CMake is even useable for header-only libraries!
&gt; Quicksort is in-place No it's not. It requires, in the best case, O(log *n*) extra storage in the form of a call stack. (Some people still call this behaviour ‚Äúin place‚Äù but as can be seen in this discussion, that's just extremely misleading.)
Why even try to maintain 2 different build systems when you could maintain 1 meta build system that lets you generate the files for virtually any build system in common use?
I am not sure, but I think it situation is the same in C. I was reading about pointer comparisons recently and discovered that it's UB to even compare pointers which don't point to the same object, or within the same array. Apparently this is the case because in some (old) addressing schemes you could do a much cheaper comparison if you knew that the pointers being compared had to be in the same segment (?), or something like that. I don't know if this is generally a problem these days. Maybe this will follow the path of twos complement and we will be able to do this without UB.
I've been doing that for years, and it always works &amp;trade;.
how did you do it? I would like to use the latest version of openmp so I need to use clang on visual studio. There is a "clang-cl", that's what did you do? Also, can you debug? MIcrosoft uses PDB files
Because you probably have two branches for msvc and gcc/clang in your CMakeLists.txt anyway. Save yourself the generate step and just update build files directly. Worst that happens if you forget to update the solution or the makefile, and people make fun of you when you come into work the next day. And ideally you have a good CI setup which warns you about the issue before you even leave the office for the day.
&gt; If you absolutely must, create a specialized lock janitor that always locks them in the same order. If you have two lockable things and one thread locks A and tries to lock B at the same time that another thread locks B and tries to lock A, you are doomed. In C++17 you can use scoped_lock to lock multiple mutexes safely: std::scoped_lock lock{ mutex1, mutex2, ... }; In C++11 and later, your can use unique_lock and lock: std::unique_lock lock1{ mutex1, std::defer_lock }; std::unique_lock lock2{ mutex2, std::defer_lock }; // ... std::lock(lock1, lock2, ...);
- c++17 parallel algorithms (not sure if gcc and clang have them already), - Intel TBB, - https://github.com/stlab/libraries (https://youtu.be/zULU6Hhp42w) - Depending on the use case also Boost.ASIO
llvm made a vs (extension)[https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain] for that. You basically just change the toolchain in project settings, and most thing will work as expected. If you use vs preview, you can install a bundled version of clang/llvm, and use it with or without the extension.
that's nice, thanks
&gt; Using mutexes and condition variables is similar to using int* arr = new int[5] to create an array. No mate, no it's not. If I interviewed someone who didn't know how to use a mutex they'd be out the door
I also hope that if you interview someone who doesn't know how to use a new to create an array, he/she would similarly be out the door. Please read the rest of my comment - not just the part you quoted.
In this case we're talking about an artifact of the ABI of exceptions so the particular compiler in use isn't really relevant (unless clang actually diagnoses here?)
Yeah, people define in-place in various ways, but O(1) space complexity does seem to be overly limiting. If I don't need to store the whole result set (less than O(n) space), I would probably consider the algorithm in-place.
Interesting indeed! This kind of reactive functions remind me of the way tensorflow and other deep learning framework handle computations: you first build a DAG that describe the computations, and they will be performed later during a session. For example, using tensorflow you would write something like this in python: # Build the computation DAG a = tf.constant([5, 3, 8]) b = tf.constant([2, -1, 2]) # Below, c will be defined as a DAG that describes how it can later be computed # either on the CPU or on the GPU c = tf.add(a, b) # # later when running the session with tf.Session() as sess: result = sess.run(c) Concerning the lack of spaces in his presentation, I agree, but on the other hand, I would also argue that his library code [*urp.hpp*](https://github.com/joaquintides/usingstdcpp2019/blob/master/urp.hpp) is quite readable given the complexity of the topic. Standard headers such as [*&lt;optional&gt;*](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/optional) sometimes give me more headaches.
In fact, one of the goals of the presentation was to show how expressive recent versions of C++ have become. Writing this even in C++11, without return type detection nor generic lambdas, would have easily had taken x2-3 the code lines.
For all practical purposes, O(log n) stack space is little enough compared to O(n) space of the actual data or a copy of it during merging in merge sort or whatever. The dataset for which the common amount of RAM can't fit the logarithmic stack is just astronomically large, if being modest.
Although 'keeping it simple' in Cmake does require a bit of attention, it's easy to dig oneself in with overly complex scripts. The parent shows how it's done right: no fluff. Check on the '\_target\_' stanzas, they are the core of 'Modern Cmake', and really help hooking up 3rd party libraries.
There is a well-known adage for multi-threading: &gt; Do not Communicate by Sharing, instead Share by Communicating. Decrypted, this means that a multi-threaded application should be organized like a distributed application. The ideal goal is to have no mutex, lock, conditional variable, ... or indeed share any mutable state between threads. Instead, the application should organize its threads in an Erlang/Go fashion: using queues to communicate between threads. This is not completely trivial, however not sharing mutable state naturally eliminates data races and thread safety concerns, and only leaves race conditions on the table, which are a higher-level functional concern where regular debugging tools can be used for diagnosis. Of course, it is not a silver bullet, and some problems will be better solved by low-level approaches using mutexes and such. In my experience, though, most service or GUI application can be architected with queues and eschew the low-level approaches entirely, so there's a sizeable portion of applications covered.
&gt;makingtheexamplecodehardertoreadreallydoesn'thelp the code is trivial to read. i can read it in my sleep. Are you not experienced in reading code?
[What do you mean "thread-safe"?](https://youtu.be/s5PCh_FaMfM) by Geoffrey Romer is a pretty good talk on the subject. It won't tell you how to achieve thread-safety, but it gives an intuition of how to think about thread-safety. For actually making safe multi-threaded stuff, you'll have to study the mechanisms for doing so of course, like futures and promises, locks etc. There might be some nice online courses for concurrent programming. I know I appreciated the university course I took on the subject. I think this is a very important subject to grasp well, so I'd suggest taking your time to learn it properly and actually trying to applying it in some small test programs.
For situations where you're directly sharing objects between threads (which, for the OP, you'd generally want to avoid doing, but is sometimes necessary (or just more convenient)), the [SaferCPlusPlus](https://github.com/duneroadrunner/SaferCPlusPlus#multithreading) library (shameless plug) provides facilities to help ensure data race safety in a manner somewhat akin to Rust. The [Folly](https://github.com/facebook/folly/blob/master/folly/docs/Synchronized.md) library also has some (not-quite-as-comprehensively-safe) features for object sharing.
For libraries, I recommend it, because it makes it easier to consume your code. For applications, it matters less, so whatever works best for you.
Also, the section on multi-threading in Bjarne's *The C++ Programming Language* is pretty good for getting a feel for the threading mechanisms. Though it won't help you much in actually applying all the concepts in practice.
Right, except that we're just now discussing data that's too large to fit into RAM. That's easily too large for its log2 to fit the call stack. Consider the example of a kind of dataset that I'm dealing with almost daily, which is about 100 GiB in size and needs to be sorted. No way I can allocate a logarithmic call stack for it.
How the hell does it not? If you consider the extreme case where each of the bytes in 100GiB is separately addressed, you have 1.0737418e+11 elements. log2 of that is merely 36.643856, i.e. 37. That's just 37 stack frames to recursively split down to single bytes. For quicksort you need two 64-bit indices to signify the range, that makes 16 bytes per frame; totalling at a whopping 592 bytes at the deepest. You must be using pre-Bill Gates era RAM for that not to fit.
Watch this, to get a good introduction into the overall problem: Kevlin Henney: [https://www.youtube.com/watch?v=2yXtZ8x7TXw](https://www.youtube.com/watch?v=2yXtZ8x7TXw) Have a look into Sean Parents talk on this: [https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency](https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency) Do not start with low level synchronisation primitives, but use high level abstraction like, futures, channels, or actors. See libraries: (Future and channels) [https://stlab.cc/concurrency](https://stlab.cc/concurrency) (Actors) [http://actor-framework.org/](http://actor-framework.org/)
It's even better with the 2019 preview
The latest preview version of Visual Studio has built in support for switching between MSVC and clang, as a first class citizen. You need to be using cmake though.
on which version of macOS ? IIRC it's 10.10 that had kernel changes that prevented valgrind to work
&gt; Because you probably have two branches for msvc and gcc/clang in your CMakeLists.txt anyway. the immense majority of CMakeLists.txt don't have branches for anything
I especially wish that cmake had a simple way to raise the warning level and specifying Debug or Release builds wasn't so clumsy
Alternative: https://github.com/thomasmoelhave/tpie
&gt; If you have a single cpp file, write a Makefile for Linux and MacOS and set up a Visual Studio project if you are actively compiling on Windows. Why? A make file isn't any shorter or simpler than a cmake file, so what is the benefit? I can understand if someone says "I don't need a build system at all to compile this two file project -just type `g++ file1.cpp file2.cpp`" but if you are going to use a build system at all, why use make over cmake? (Btw: I like your hack)
No, you're totally right. Brain fart.
Not from what I've seen on github so far.
It is still easier to maintain a single cmake file with a few compiler specific options than 2 or more completely distinct build tools. Also, the world exists of more than just make and visual studio. Someone might want to use ninja, or IDEs like QtCreator, clion, vscode all of them (and I guess also xcode? understand cmake)
conclusion is wrong Person().FirstName("C") is really returning a lvalue (Person&amp;) *you* know that is this, so you think compiler will extend lifetime, since the this is really the initial temporary created by Person() but that is not the case, you could as well return some other value (not *this), *compiler* does not do that kind of analysis so what you're really doing is to bind a const type &amp; to a lvalue (type &amp;) and that lvalue expires (of course) at the end of statement try removing the const and you'll see, your code still compiles and is still wrong, but at least you'll know that it's not a temporary we're talking about here (not a rvalue) so those rules you're mentioning do not apply here
The implementation of the standard library is exempt from rules about undefined behavior. Its use, however, is not exempt. My example is one of use, not implementation.
&gt;DWARF index cache: GDB can now automatically save indices of DWARF symbols on disk to speed up further loading of the same binaries. Sweet, one of my main issues with GDB is that it takes a really long time to startup, compared to lldb or visual studio's debugger. The terminal styling changes are welcome too.
at the beginning...really, cmake is very easy to use for simple projects
But if your data set can be orders of magnitude bigger than RAM (which is what this has explicitely been designed for), everything other than O(1) space complexity won't be able to run.
Don't underestimate the power of logarithms. O(log n) space can be done in memory for all fathomable dataset sizes except for super memory constrained platforms. For example, assuming you have a 600 exabyte array of 64-bit integers you want to sort. It will run quite a lot g time since quicksort is O(n log n), but it will only require 67 stack frames.
Source highlighting in TUI mode is sweet!
Personally I think for small projects cmake is relatively overkill. For large scale project cmake could be used, but it's odd dialect and not being able to debug cmake files makes you double consider if it's worth of doing it. &amp;#x200B; Complete list of alternatives to cmake can be found from here: [https://docs.google.com/document/d/1C1YrbFUVpTBXajbtrC62aXru2om6dy5rClyknBj5zHU/edit#heading=h.tikib2y2uck4](https://docs.google.com/document/d/1C1YrbFUVpTBXajbtrC62aXru2om6dy5rClyknBj5zHU/edit#heading=h.tikib2y2uck4) syncProj is also one of command line tool for building up projects, but it targets to windows. See also: "Comparison to other project generation tools" [https://docs.google.com/document/d/1C1YrbFUVpTBXajbtrC62aXru2om6dy5rClyknBj5zHU/edit#heading=h.qm9m5e7jipnj](https://docs.google.com/document/d/1C1YrbFUVpTBXajbtrC62aXru2om6dy5rClyknBj5zHU/edit#heading=h.qm9m5e7jipnj) Meanwhile I would not recommend syncProj either, at the moment I'm working on replacement of cmake, c++ scripting support. See initial presentation over here: [https://www.reddit.com/r/cpp/comments/bg29qb/c\_as\_a\_scripting\_language\_c\_runtime\_type/](https://www.reddit.com/r/cpp/comments/bg29qb/c_as_a_scripting_language_c_runtime_type/) At the moment targetting for windows / Microsoft compiler. But if you dare to pick up c++ scriptable into use for windows, I can pick up new requirements for other OS / platforms.
Nice ! I'm using cgdb front-end for this exact reason (and it's easier to put breakpoint), but having it on vanilla gdb is a welcome change.
Better way to enforce the language standard and ensure all targets are built using the same language version: set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_CXX_EXTENSIONS OFF)
I have some branches: [https://github.com/Ebenezer-group/onwards/blob/master/CMakeLists.txt](https://github.com/Ebenezer-group/onwards/blob/master/CMakeLists.txt) Is there a way to avoid those?
Making it defined would violate the principle that you don't pay for what you don't use.
You are right. That was literally my first draft and them I decided I didn't want to discuss this with all the people telling me to use cxx_std_XX instead ;)
Not OP but I have two links you might enjoy. First is probably the tutorial you‚Äôve already found, but I‚Äôve found it a decent reference when I forget simple stuff. [link](https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html) Second is a video given at a conference about the differences between old cmake and modern cmake, and from it I learned a substantial amount about structuring projects easily. I use this resource more than the pdf above. [link](https://youtu.be/y7ndUhdQuU8)
Just replied to a sibling comment; copying my answer here in-case you‚Äôd like to see it too :) Not OP but I have two links you might enjoy. First is probably the tutorial you‚Äôve already found, but I‚Äôve found it a decent reference when I forget simple stuff. [link](https://cliutils.gitlab.io/modern-cmake/chapters/intro/installing.html) Second is a video given at a conference about the differences between old cmake and modern cmake, and from it I learned a substantial amount about structuring projects easily. I use this resource more than the pdf above. [link](https://youtu.be/y7ndUhdQuU8)
If you want to get that technical, then just about every algorithm has logN space requirements because the size of a pointer, or index into your data set, is size logN too. So even something trivial e.g. computing the sum of an array has that overhead. So it's usually more logical to ignore it.
[removed]
If you think about it, logarithmic space might as well be called constant in this case. Most CPUs only have 42 - 48 bit memory addressing, which means if it can be held in memory, the stack depth would have to be less than that. 128 bit addressing should account for every byte of data on Earth. 256 bit could address every atom in the universe (maybe every unit of the smallest division of energy in the universe). The stack depth will never need to exceed 256.
Once there is more than one translation unit (i.e. just calling "$compiler main.cpp" is not enough to compile your whole program).
Could you open issues for these two very valid points on the CMake GitLab [https://gitlab.kitware.com/cmake/cmake](https://gitlab.kitware.com/cmake/cmake)?
Yes! Use CMake even for 1-file Hello-worlds! Visual Studio 2019 Preview now even also has a project template for new CMake projects with a 3-liner CMake for a hello-world.
TLDR? Anything new exciting for C++ debugging? Will the Ubuntu 18.04 package be updated?
When you have more than one cpp files, switch to cmake. It's definitely worth it, your cmake files will be quite simple for a simple project. It also helps with compile times: once you got cmake in place you can use ninja.
Those are hardly new things. There even seems to be some recent development on the warning side: https://gitlab.kitware.com/cmake/cmake/issues/19085
By the way, your condition does not look right. It implicitly assumes every compiler on Windows is command-line compatible with MSVC and every compiler not on Windows is compatible with GCC. Which is not the case, see Clang for Windows. Should not it branch on compiler rather than on operating system? if (CMAKE_CXX_COMPILER_ID MATCHES "GNU") ... elseif (CMAKE_CXX_COMPILER_ID MATCHES "MSVC") ... else () message(FATAL_ERROR "Unsupported compiler: ${CMAKE_CXX_COMPILER_ID}") endif()
How would this be different from the [[nodiscard]] qualifier?
I'm working on my own ECS exploring the possibilities of compile time concurrency guarantees. Similar to yours I buffer create an erase operations on entities. Not even close to finished yet but getting there. https://github.com/Dreyri/matter
Can someone explain the versioning scheme of gdb? I have version 8.3.50 installed. Now 8.3 is somehow an upgrade to that?
The qualifier is per function, no? The Misra check issues a notification per what it checks, not a specific function.
Build systems are a complicated topic. You asked about cmake, and it is likely the most common one these days, but there are other good build systems for C++ in relatively wide use so it isn't necessarily helpful to learn any particular one. The main knock against cmake is that it can quickly become complex and difficult to maintain as projects scale up, and it has some unintuitive quirks that you need to learn to avoid frustration. If your project is tiny, you are unlikely to run into any of these issues using cmake, the configuration will be relatively straightforward. &amp;#x200B; For new C++ projects, I am among the many people that switched from cmake to meson, largely because of the lower cognitive overhead as code bases become complex and the excellent, opinionated defaults. The practical issue with cmake on my software engineering teams has always been that they rely on self-taught cmake experts to maintain/debug the builds, which isn't their job, because the learning curve for the average engineer was too steep and it was too easy to do things incorrectly. With meson, everyone seems to understand the build system well enough that the maintenance load is shared across the engineering teams.
8.3.50 is the version number for the current development head that'll become 8.4 (presumably) once it's released.
I can see how it's a feature but I've seen it abused to make both horrible library APIs (using gflags as the way of configuring pure library code by programmatically setting flags in the caller) and horrible (for human) CLIs with dozens to hundreds of flags. Plus, trying to shoehorn subcommands and similar idioms into gflags makes a mess of a CLI that isn't useable without reading the code itself (in my experience). I know it's a preference thing and I'm hoping others have had better experiences, but I'm definitely not a fan
No, that's unfortunately the MO of Ubuntu, they cut a release by freezing packages and then only security patches get in (except for some exceptions, such as webbrowsers). Point release is not a very nice system for this reason.
Yeah I'd rather call `logginglibrary.init(&amp;opts);` or something similar to make it explicit but not encourage using flags as a library API, which in my experience is how gflags are commonly used
I changed it now as you suggest. Thanks.
I'd use even for Hello World. It's good practice.
why
You're screwed if you used placement new
Avoid it entirely. For the cases where cmake would be easy, a makefile with a little $(wildcard) and $(patsubst) will be just as easy; for the cases cmake would be complicated, the makefile will be easier to understand and extend anyway.
The last update is from 2018-08-30, so it seems a bit old. Isn't there a newer one?
&gt;Experimental support for compilation and injection of C++ source code into the inferior (requires GCC 7.1 or higher, built with libcp1.so). What does this mean?
Who are the unnamed pragmatists and idealists on the slide? I can't be the only ignoramus. Sometimes I feel bad when I see my competitors supporting 2011 C++ or older. You make me feel a little better about things with your comments about 2017 C++.
Compiling C++ code while debugging; here's some background: https://developers.redhat.com/blog/2016/10/06/cxx-support-in-libcc1-a-comprehensive-update/, docs: https://sourceware.org/gdb/onlinedocs/gdb/Compiling-and-Injecting-Code.html
What's people experience with cppcheck? When I looked at what to include into our CI I included clang-tidy but gave up with cppcheck since IIR it was unable to even parse some C++ I did throw to it. And we are limited to C++11! I'm losing anything by not using cppcheck when I'm already using clang-tidy?
* Pragmatists: Aristotle, William of Ockham, Poincar√©, Quine, Grace Hopper. * Idealists: Plato, Duns Scotus, Cantor, Frege, John McCarty.
I am. I want to develop on windows, but don't want to exclude Linux as a a target platform.
No, it can be applied to a type as well.
First, don't use `add_definitions()` , use `target_compile_options()` and generator expressions to change settings for each compiler. Or better, just have separate toolchain files with those options!
What's not to like about add\_definitions()? I'm not sure it would be better to have separate files. Wouldn't I have to have this: if(WIN32) target_link_libraries(genz wsock32 ws2_32) target_link_libraries(sendExample wsock32 ws2_32) target_link_libraries(receiveExample wsock32 ws2_32) endif() in both files?
I don't quite understand the amount of money that is being requested. Approximately 200 Euros is worth around one man day of developer time if you were to pay someone to do it. Seems like it is not worth the effort to go around asking for money if it is something you can do in a day. Or is it a much bigger job and you are basically asking for pizza money while you are doing something for the community? I think it would be good to include a time plan so people know what it is they are paying for. But I like the idea. It would be nice if people could get paid when they are contributing to OSS.
You don't strictly need it. CMake just makes it easier to define a project as a component/dependancy of another project.
The mem buf setter won't get moved inline, so that's not a concern. Or, if I decided to at some point, I would just provide a separate 'safe' version that cannot be and use that for such things. If the compiler starts ignoring out of line calls to user defined functions / methods, then we are all in serious trouble. RAII would pretty much go out the window if that happened. On the STL, I just couldn't do a lot of what I do if I used that stuff. It would be a seriously compromised system. Look at the stuff on the ORB and how easy it is to use because of the fact that everything is based on my own interfaces. Any object that supports binary streaming can be used as parameters to remote calls. And the very smart enums, there's no way to force those on the standard libraries. And the standard libraries are horrible wrt to streams and text transcoding. It would be a massive step backwards.
I would also use CMake for anything these days. It's good to just get it into your fingers to adopt good style and best practices. For anyone interested, I'm going to add some resources that are really good in my opinion: * [Talk - More Modern CMake (3.12 -&gt;)](https://www.youtube.com/watch?v=y7ndUhdQuU8) * [Talk - A bit slow, but nice](https://www.youtube.com/watch?v=bsXLMQ6WgIk) * [Talk - Nice overview](https://www.youtube.com/watch?v=eC9-iRN2b04) * [Book - Professional CMake](https://crascit.com/professional-cmake/) And then just learning by doing, force yourself to use it and make it work and eventually your skill will grow and you will become more fluent!
Though neither of those will insure you actually pass the mutexes in a consistent order. A simple typo and you could have a deadlock. A very simple, dedicated locker will guarantee it happens right. And such things are done so often, that it's not like this is a huge burden to create one.
Can you explain what is going on in the if-else statement? What is the difference between these two? `target_compile_features(my_exec PUBLIC cxx_std_17)` `set (CMAKE_CXX_STANDARD 17)`
Another commenter posted this but I found this fairly straightforward https://cgold.readthedocs.io/en/latest/index.html
There are countries where you can get a full week development for that money. (just saying)
Over six years since the last release. Not good.
My experience is that compilers are pretty smart already, can be configured to enforce many rules, and for anything else, you can write a compiler plugin.
`std::lock` is explicitly safe regardless of the order of its arguments.
Only if there are still architectures in use which have this property. What I meant by "follow the path of twos complement" is that twos complement is so universal that c++20 is actually defining signed integers to be twos complement, and that it's possible that the same might be (or soon be) true of pointer operations of this kind.
To start with: * write good code in the first place. * explicitly pass/embed all objects that functions are using, i.e. no mutable globals unless they're actually `thread_local` * data structures must not contain any shared pointers to mutable data, either * if you have to have mutable shared state, use a mutex around *every* access to it - reads as well as writes. Use destructors appropriately! * if a mutex is too slow, think about atomics (but you probably won't need that yet - libraries that provide queues generally do this for you, the key phrase is "lock-free")
The link was very useful! Do you have any resource on recommended project structure?
Well it's matter of debate but try this : https://github.com/vector-of-bool/pitchfork
The add_compile options should be self explanatory, the string replace on Windows is necessary, because cmake (prior to 3.15) automatically adds /W3 and if you just add /W4, you'll get a warning from msvc about flags overriding each other. I don't know how to properly explain the difference between the two methods to set the standard in a reddit post. Should be easy to find a proper explanation on the internet or someone else can give one.
OK, but looking at it, it seems it would be considerably less performant than something that knows what the order is and just has to lock them. It is jumping through a lot of hoops to avoid deadlocks that wouldn't be necessary if you just always locked them in the right order.
I guess people downvoting you are not msvc users eh
Why? I don't want a system that changes core packages at random points in time. If you want the latest GDB, you can easily build it.
Waiting for IDE support for this. Amazing!
&gt; The mem buf setter won't get moved inline, so that's not a concern. TBH, I was expecting this answer, which closes the discussion. Good luck for the future.
No, it also violates the principle if it prevents optimization opportunities.
I found cppcheck wasn't useful given we have clang-tidy - it does a poor job of understanding code (especially in C++11 and above). Cppcheck's idea is that it doesn't need to know your full include paths or compile options, and I think it suffers compared to clang-tidy because of that.
&gt; I don't want a system that changes core packages at random points in time. Why not? There's nothing wrong with it. I prefer having an up to date system than a system with old packages, which have fewer features and more bugs. &gt; If you want the latest GDB, you can easily build it. Sure, but what if it depends on a newer version of some library? You might also break other packages by upgrading the library.
Works ok for my purposes, which is using it as an extension in VSCode so I get real-time in-editor code linting.
&gt;* Pragmatists: Aristotle, William of Ockham, Poincar√©, Quine, Grace Hopper. &gt;* Idealists: Plato, Duns Scotus, Cantor, Frege, John McCarthy. Stroustroupe was also an idealist, especially in C++'s early design days.
In contrast to many others here I would advise against CMake in favour of Meson, which you will likely find much easier to learn (note the nice documentation)
&gt; double\\[\\] I've never seen this notation before. Is that a typo or is this a feature of c++ I don't know about?
The proposed MISRA rule is garbage. It's at the same level as the famous single function return statement MISRA warning. It might sound appealing to some but in reality there are many functions whose return values are commonly ignored and it's completely OK. Examples are printf and std::set&lt;&gt;::insert. Do you really want to get warnings from calling such functions? Wrap your calls in static_cast&lt;void&gt;() for greater readibility? Or better yet do you want to maintain an exception list to this rule? Think again. Sorry if the post sounds too harsh but I have a lot of personal experience with MISRA.
An attempt at escaping the brackets, presumably.
 std::shared_ptr&lt;double[10][10]&gt; arr(new double[10][10]); Does that work? The main thing is you need to know the dimensions at compile time, but otherwise you should be able to do this without issue. It also looks like std::shared_ptr&lt;double[][10]&gt; arr(new double[10][10]); works. So long as the compiler can tell the size of the inner-most arrays, I suppose the type is valid.
I think reddit tried to autocorect it, it should have just been double[].
Depends on your definition of embedded. I work in defense and write kernel level applications for vxWorks. We are free to use the STL and boost.
Here are the links I promised. Basics: * http://codingnest.com/basic-cmake/ * https://codingnest.com/basic-cmake-part-2/ * https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 Further explanation: * https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/ * https://cliutils.gitlab.io/modern-cmake/ My personal CMake reference: * https://github.com/Adobe-Android/Cpp_Docs/blob/master/Basic-Template/CMakeLists.txt
Are you using Visual Studio 2019? The upgraded CMake support is amazing! BTW, a major benefit of CMake is that it can build project files for different IDE's like Xcode, Visual Studio, etc (though in VS 2019 you don't require a project file and it's great).
The reason for the makefile is that most people doing builds on linux knows how to use it. Something that also directly does incremental builds (not generates another build system that can), but has simpler syntax more like a basic CMake project would be better. Maybe Meson or build2 will save us. I'm glad you like the hack, I stole the idea from @won3d :) It could def use some cleanup to make the preamble shorter, but it hasn't bothered me enough yet to change.
Thanks for pointing this out. It got me motivated to to do some cleanup here and to work on custom allocator support for Evo (which will be similar to C++17 polymorphic allocators).
The obvious gotcha is that this doesn't work for any scenario where all threads must see a coherent view of some information. That's quite a few of them. The asynchronous nature of queues raises its own set of complications, and in a lot of cases there would actually be far fewer moving parts if you just need to synchronize a few contact points. Queues I would say are more for one thread to inform other threads that something has happened, but it's not very useful for those threads to maintain any sort of common view of the state of the world (at least if any decisions are going be made based on that view.)
I like [/u/quicknir's suggestion](https://www.reddit.com/r/cpp/comments/9qms4n/chained_functions_break_reference_lifetime/e8de5wc/) to just use a separate builder class.
Use. LTO.
It may be simpler (depending on your use case) to simply create a single array of size height x width and do the indexing yourself. E.g. i = y * width + x. Personally, I've always found that to be more straightforward and flexible than working with C++'s built-in multidimensional array faculties. Just my 2¬¢ though. :-)
Instead of trying to create an array of arrays, instead index a 1 dimensional contiguous block of memory as a set of rows. `new double[size_x * size_y]`, then to index it as `arr[y * size_x + x]` or `arr[x * size_y + y]`. Chose the kind which matches how you will access the memory in order to increase cache hits.
TL;DR: f(void) is not C++. The end.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bnvx0e/should_i_use_debug_layer_or_not_with_directx/en9p24f/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
If your build file just describes a list of files and list of flags, it's really not that bad to maintain 2 or 3. If you have more than that, then meta build system generator things like CMake start to become worth it. I used to think it was a huge waste of effort to maintain the two separately, then I joined a team where we use Visual Studio and Make and found that I rarely forget to update both and spend very little time doing so. When I do forget I get a nastygram from the CI system and the issue is resolved quickly. I've used (and periodically still use) CMake, premake, and GENie, so this is not coming from a place of not liking modern things for the sake of it. I was honestly surprised that I didn't hate the setup. &gt; IDEs like QtCreator, clion, vscode all of them (and I guess also xcode? understand cmake) Visual Studio too. It's true, CMake's nearly ubiquitous, but not quite there. I hope something better supplants it before that is cemented. But also, I really don't care about people on my own team getting to use their favorite editor/IDE (just standardize on one per platform, or standardize on a non-integrated build system). So this argument only applies to libraries that have build steps which are complex out of true necessity.
You can always create an interface target `networking` that links against those on Windows only using generator expressions and link against it. On other platforms, it will pull whatever system libraries are required. The big issue with `add_definitions()` is that it does not support generator expressions and works at the DIRECTORY scope while being a mess since you add any flag in there. There are now modern commands to add compile flags, compile definitions or link flags directly at the directory level and the target level (preferred).
Isn't a `T[][]` essentially guaranteed to be allocated and indexed as a contiguous block? I know it is on GCC/clang/MSVC at least, though I don't know what the standard says about it. You'd be right for sure if OP was trying for a `std::shared_pointer&lt;std::array&lt;std::array&lt;T,M&gt;,N&gt;&gt;` monstrosity though
No, I wouldn't say so. A T[][] is analogous to T**, which obviously mandates a pointer to a pointer, and not a contiguous block of memory. Perhaps it's an optimization compilers do if the type is concrete and never exposed, but it's definitely not something I would rely on.
Is it actually guaranteed in those compilers? A trivial, single threaded program with small array sizes might show that behavior, but I don't think there's any such guarantee once you account for heap fragmentation or giant arrays...
Sounds like you are to trying to do c programming... With whatever is the new c++ fad/shiny... In this case... Shared pointers. I haven't done more than 2d dimensions. But when I did... You just use std vector from c++98. So you embed a vector inside a vector n times. Std vector will take care of your memory as good or better than shared pointers approach you are describing. And std vector is fast if you do [] operator because that operator is unchecked and can be compile time optimized. --- You can keep going down the path you described... You just do everything the same you do with regular pointers... Just replace regular pointers with shared... And let the shared pointers take care of memory management. ... Another reason to avoid shared pointers is that I think their access is thread safe... So maybe slow? I don't recall. That is why there is std unique ptr.
&gt;Why not? There's nothing wrong with it. I prefer having an up to date system than a system with old packages, which have fewer features and more bugs. I run gdb automatically in production to grab information about a crashed process from the generated core. I absolutely don't want /usr/bin/gdb doing anything different. That's the tested version. On the other hand /usr/local/bin/gdb or /opt/gdb/bin/gdb can be whatever version is most useful. &gt;Sure, but what if it depends on a newer version of some library? You might also break other packages by upgrading the library. This is the answer to your "Why not?" question.
I just jumped into the standard to check, so assuming I'm understanding things correctly, here's my reasoning: &gt;An object of array type contains a contiguously allocated non-empty set of N subobjects of type T. [dcl.array] There's no special handling for multi-dimensional arrays that I can see. So given some `T[][]`, I think I can reason it's defined as a contiguous array of `T[]`, which are in themselves defined as a contiguous array of `T`. The interesting thing is dereferencing, since that requires the size of the inner arrays which get lost if the type decays to a pointer. So I'm not actually sure now! I do know that it's illegal to do something like: int x[3][3]; int **ptr = x; So clearly there's a bit of complication here.
When I know for sure what the crap I'm dealing with I am glad I have the ability to use raw pointers and manual memory management. I do some algorithms programming and I usually end up writing C with a C++ compiler just because it's easier than dealing with the stl sometimes
That is completely and unequivocally wrong. Arrays are not pointers and all arrays are guaranteed to be contiguous. When you use new, the outer extent of the array decays away and thus `new int[n][5]` has type `int(*)[5]` which is a pointer to "arrays of 5 ints". Note that since the extent of the inner array is embedded in the type, it must be known at compile time. This is why dynamic multidimensional arrays aren't that useful in practice. https://en.cppreference.com/w/cpp/language/array
C++ game dev of 5 years now. My answer: literally nothing. Not for runtime speed, not for speed of development, not for ease of understanding. The only thing I can imagine being the exception here is if you think C++ style means OOP; in that case, there are loads of things that are better off written as ‚Äújust‚Äù free functions operating on structs and such. But the reality is, C++ is multi-paradigm: data-oriented or functional programming is still nicer in C++ than C.
Not sure, honestly! Interesting point. Standard seems to say that: &gt;An object of array type contains a contiguously allocated non-empty set of N subobjects of type T. [dcl.array] which I'd think would apply recursively, so you'd have the same issues trying to allocate a massive multi-dimensional array as a single-dimensional one of the same area. (I'm also not sure that would be legal if array behavior changed with the size of the bounds; that'd be kinda funky.)
Runtime plug-in systems. C for the ABI, but even then we generate (sometimes templated) C++ wrapper classes for ease of use.
I'm in agreement with gcc here. Let's simplify the types, so we can see what's really going on. A: arg() B: std::forward&lt;arg&gt;(A) C: std::add_lvalue_reference&lt;arg&amp;&gt;::type D: std::add_lvalue_reference&lt;arg&amp;&gt;::type(B) `decltype(A)` is `arg&amp;&amp;`. No troubles here, we're just creating an r-value of type `arg`. `decltype(B)` is `arg&amp;&amp;`. Why? The template argument passed to `std::forward` is `arg` without any reference qualification. Hence, you get back what you put in: `arg&amp;&amp;`. `decltype(C)` is `arg&amp;`. In fact C is a no-op because you gave an l-value reference type as the template argument, so you get back the same thing. D is a bit misleading. What you are actually doing is a C-style cast. Recall that `T(x)` is the same as `(T)x`. Your code then would be the following: void func1(arg &amp;){} void func2(arg) {} int main() { func1((arg&amp;)arg()); } You are asking the compiler to cast an `arg&amp;&amp;` to a `arg&amp;`. That's not allowed. --- As an aside, this kind of question would be better suited for /r/cpp_questions. It's not terribly off topic, so the mods probably won't complain.
I'm just not sure how an allocator would know it could allocate a multidimensional array continuously considering other allocations/frees might be happening on different threads. I guess if the compiler was smart enough to see that it _was_ a multidimensional allocation and do it in one go then it could work.
Winner: best non-sequitur for May 12th 2019.
Ah, for clarity, I thought T[] was legal and just an alias for T* (not T[n]). I try to stick to the STL as much as possible.
 Nothing. Unless there is some external technological basis for using C (e.g. small microcontroller with custom toolchain that doesn't have a c++ compiler) there is no reason to ever use C.
Declaring functions with no arguments as f(void) . Just a personal preference to be explicit about lack of args.
Not teaching C is silly. Many companies still use C, or at least are developing on top of legacy C codebases. Having strong C chops is definitely a big help for C++. It gives you a far deeper understanding of where C style languages come from. C++ becomes easier, Java becomes easier, python becomes easier, etc, etc.... If you just want to program c++ in your jobs, sure, no need to learn C. If you want to understand language theory that will make you more flexible and valuable, then learn C.
That's false. You can get up-to-date compilers/debugers/other tools from https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test
This is the right answer. If you erase the dimensions, then you can't do the multidimensional index. Need to save the stride. @ /u/TimeTravelHenry write a helper struct template to do what _Ashleigh says.
Other posters have explained that it is possible, but for posterity you might want to look into using a map using a tuple as a key, especially if not every value will be filled.
Same here! That's why I wasn't sure how it worked myself.
Idk about the rest but +1 for suggesting std::vector
Soon, I'll be taking the CAP cert exam after about a year under my belt of classes at a technical college. My parents are unaware and as far as they know assume I am continuing a degree in IT. I have not told them!
Wat
It's entirely relevant. The whole problem goes away with LTO. No need to be worrying about the definition being in the same translation unit.
&gt; champaign HAHAHAHAHAHAHAHAHAHA
If i &gt; j &amp;&amp; j &gt; i Hold on we have a quantum computer programmer here...
F
Another reason to simply use C++. Even if it's still C Code that's just compiled in C++ mode.
Doesn't exist in C.
It's an artifact of supporting two different websites at once... It escapes it for the redesign and looks fine there, but looks broken on old.
`sprintf`. There's something about it that fills a gap that pure C++ can't. Yes, it's not exactly type safe, among other problems. Maybe somebody will make a fmtlib-like version someday. Also, I just can't bring myself to use `std::array` instead of raw arrays, especially if multiple dimensions are involved.
cpp or: if (I do not code); do (my homework);
I mean, how else would it work? I'm not aware of any types that are allocated in chunks (including one-dimensional arrays), and `sizeof(T[M][N])` is known at compile time to be `M*sizeof(T[N])` which is `M*N*sizeof(T)`. Given that arrays must be contiguous, I can't see any reason why any array type wouldn't be allocated all at once; if that's not possible due to out of memory or fragmentation or whatever then presumably the allocation would fail like it would if you tried to allocate any other type of the same size.
What is wrong with vector&lt; vector&lt; something &gt;&gt; ?
Clearly `(i &gt; j &amp;&amp; j &gt; i)` should be TRUE exactly when `!(i &lt;= j) &amp;&amp; !(j &lt;= i)`, that is, when either `i` or `j` is NaN ("not a number"). But we see from the declaration `int i` that in fact `i` _is_ a number. So none of these tests execute, and the result ends up being the same as if we'd just written #include &lt;iostream&gt; using namespace std; int main() { int i = 1, j = 2; cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; }
Somebody posted this on reddit. That const&amp;&amp; sometimes makes sense. &amp;#x200B; When there are mutable fields.
If the title is a reference to the CppCon talk, the idea isn't to stop teaching C, but to teach C later instead of at the beginning.
Its from the cap exam resource. Clearly not reliable according to reddit. However, it displayed 8 as cout statement, so, it worked ü§∑‚Äç‚ôÇÔ∏è
I don't think you should have been downvoted, but I'd argue that not putting anything between the parentheses *is* being explicit about lack of args.
Tbh the correct way to set C++ standard is to use package manager. Otherwise, overriding C++ standard inside CMake will create potentially ABI incompatible packages. Think of trying to build c++14 package yet cmake script would override it to c++17. What a mess.
Could one of the **anonymous downvoters** please explain the downvote? I know from my own experience that this answer to how to learn coroutines for someone unfamiliar with them (the 5 year old mentioned by the OP) is a good approach. It deserved lots of upvotes, not lots of downvotes. I surmise that the downvotes are based on ignorance, total incompetence and a very strong will to translate one's ignorance and incompetence into safe social argumentation, namely anonymous downvoting. If you're one of the downvoters and think you have some reason, that just at that moment you were unable to articulate, e.g. due to being very tired or otherwise incapacitated, please state it here.
I'm not trying to convince you that 2-3 build systems are significantly more effort. I'm trying to understand why I should do it. What does having a manually created make file and a manually created vs-project file give me that a cmake file doesn't?
I'm thinking if the size of the array _isn't_ known at compile time, otherwise why allocate on the heap, other than size?
But, what is "the C way"?
&gt; ... teach C later instead of at the beginning. I would agree with that, I learned C before C++ (as many I guess), and had a hell of a time getting my mind around things like classes, it just did not sink in. I also started with converting C-free-functions into classes as member-functions, this is a weird exercise if you only know C [it seemed so pointless at the time].
Beats me as to *why*, but if the size isn't known at compile time, you aren't actually making an array (VLA isn't allowed in C++ to my knowledge). You're just allocating M T* that each point to N T, which is a totally different operation with similar access syntax.
A vector of vectors isn't contiguous in memory like a 2D array or a 1D vector is, so if cache misses are a concern that would be one reason to avoid such a structure.
C is faster than C++. Linux is written in C, why stop using Linux?
Not the same thing, but I have found myself copy-pasting this fairly often: ``` // Usage: std::string s = (Str()&lt;&lt;"hello world "&lt;&lt;5); struct Str { std::ostringstream os; operator std::string() const { return os.str(); } template &lt;class X&gt; Str&amp; operator&lt;&lt;(const X&amp; x) { os&lt;&lt;x; return *this; } }; ``` The other option is a heavyweight solution. Google's `StrCat`: https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h#L20
No one mentioning the semicolons after each if.
&gt; Why not? There's nothing wrong with it. I prefer having an up to date system than a system with old packages, which have fewer features and more bugs. False. An old package does not necessarily have more bugs. More critically, an old package has *known* bugs. Updating is simply a risk you cannot take in many scenarios. &gt; Sure, but what if it depends on a newer version of some library? You build that library. &gt; You might also break other packages by upgrading the library. No, you don't. You don't replace your system libraries, nor your applications. Instead, you install the library and the app in another location, meant just for the latest and greatest applications that need it. In fact, I typically have *several* versions of compilers and other tools built and installed to test and ensure everything works. But I still want to rely and use the system's one, which is the one that is supported by Canonical/Red Hat/your vendor and the one end users/clients will use.
I mean in rust that's implemented as a procedure macro, basically a function made to alter the AST at compile time. It's really freaking powerful, so maybe we shouldn't focus in the end features but in the primitives to implement them.
Make it 1-dimension and add functions that map your 2D-grid coordinates into the 1D-array.
This is awful, every if statement has a ; so none of that matters, it's just incrementing i and j by 2 and multiplying them.
How often would you call a function with no arguments that this would actually matter? It seems totally inconsequential.
it just feels more complete to me to explicitly state that there are no parameters..
Another poster mentioned that it is dependent upon your definition of "embedded". For example: I work on a software platform that is deployed on an embedded device that uses freescale components, multiple expansion boards, fpga's etc. Depending upon where you are in our development team you could be writing kernel modules in C, applications in user space with C++, desktop/mobile apps that interface with our embedded system using javascript, swift, java. So, your question is contextual. If what you're looking for is a shop that needs C++ code written on embedded devices, then you should find ones with the use case which warrants it.
Take a look at xtensor: https://github.com/QuantStack/xtensor/ Cheers
The article uses the term operator overloading, while it should be using the term function overloading.
std::format is coming into C++20 based on {fmt}: https://github.com/fmtlib/fmt
 auto q = std::shared_ptr&lt;std::array&lt;int, 5&gt;[]&gt;(new std::array&lt;int, 5&gt;[10]); //auto q = std::make_shared&lt;std::array&lt;int, 5&gt;[]&gt;(10); // c++20 int&amp; t = q1[0][0];
The problem is the other way around, dis-allowing this prevents coding short-cuts, like in the case of non-zero-based arrays, as now, the calculations have to [all] be done at run-time. Conside something like: [[nodiscard]] constexpr value_type at ( const std::intptr_t i_, const std::intptr_t j_, const std::intptr_t k_ ) const noexcept { assert ( i_ &gt;= BaseI ); assert ( i_ &lt; I + BaseI ); assert ( j_ &gt;= BaseJ ); assert ( j_ &lt; J + BaseJ ); assert ( k_ &gt;= BaseK ); assert ( k_ &lt; K + BaseK ); return ( m_data + K * ( -BaseJ - BaseI * J ) - BaseK )[ K * ( j_ + i_ * J ) + k_ ]; }
It does: [https://godbolt.org/z/0\_5nhq](https://godbolt.org/z/0_5nhq)
In C programming you have typically have a lot of those to reference static variables. ie: Init(void) functions. Typically in C++ you just have a class with constructors. In C++ a lot of methods may only need to work on member variables so they would have a void arguement.
‚Äî which both do. One of those is the old syntax for the same semantics from before function prototypes.
Nothing. The only people that really prefer C to C++ are people that have not yet taken the time to learn C++. Literally the only advantage C has over C++ is that it is easier to learn. I have never met a single person that was more than an intermediate level C++ programmer that still preferred C. I have met a lot of C programmers with remedial C++ skill that were pretty certain that they were top level C++ talent that still preferred C, but non with real skill that did.
`Vector3f((float)x, (float)y, (float)z)` is way more readable than `Vector3f(static_cast&lt;float&gt;(x), static_cast&lt;float&gt;(y), static_cast&lt;float&gt;(z))`.
Easier to learn, quicker to compile, less resources to compile, smaller binaries...
&gt; Though neither of those will insure you actually pass the mutexes in a consistent order. A simple typo and you could have a deadlock. A very simple, dedicated locker will guarantee it happens right. And such things are done so often, that it's not like this is a huge burden to create one. The code I showed does not require you to pass the mutexes in a consistent order, it will lock all the mutexes in a dead-lock avoiding manner - i.e. either all mutexes are locked, or none are locked and the thread will try again.
Is OP looking for a data structure with a contiguous memory allocation?
I've read somewhere that overloading comma operator will soon be deprecated and remove in ordre to use them natively in [] operator. It will certainly open the way to multidimensional array.
Good catch! fixed
There was confirmation in the comments in HN that LTO w/ Clang also allows the optimization. [https://news.ycombinator.com/item?id=19896385](https://news.ycombinator.com/item?id=19896385)
I don't know. I'm just pointing out that the suggested vector of vectors isn't equivalent to a multidimensional array, which *is* what OP was looking for.
Yes, but in what cases where you need to call functions with no arguments would the minimal overhead of a few instructions actually be meaningful? You're not going to call Init() to set up static variables in a tight loop.
In C you should always declare f(void) if your function takes no arguments, because if you have f(), then you can call it with arguments and it wont generate any error. [Example](https://godbolt.org/z/yIc5P4)
It might be on its way for C2x though.
Raw pointers, manual memory management, (s)printf. Not all the time of course, but there are many situations in embedded systems.