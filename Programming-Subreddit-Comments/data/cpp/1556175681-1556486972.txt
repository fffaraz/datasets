So how would you phrase it? "Parallelization of C and/or C++"?
I didn't realised, but since C++17 whith garanted copy elision and in practice since much more time), it's not even a move, it's an in-place place construction.
I opened a ticket some time ago where I had similar issues: [https://developercommunity.visualstudio.com/content/problem/355350/cmake-project-discovery-is-painfully-slow-on-folde.html](https://developercommunity.visualstudio.com/content/problem/355350/cmake-project-discovery-is-painfully-slow-on-folde.html) My best guess is that the discovery step (visual studio seems to scan for all CMakeLists.txt in all subfolders or something like that ) can take ages when you run cmake from a folder with lots of files (e.g. place a CMakeLists.txt in C:\\ and add a few subdirectories).
You are correct but that is generally not the case. In this specific case it would only be UB if the class has const or reference members, otherwise any reference to the old object can be used to access the new object without UB.
You're right. I was hungry when I wrote it, and I'm grumpy when I'm hungry. Sorry.
&gt; garanted copy elision I'm unfamiliar with copy elision so I'll check that out , thanks for the tip. I am not confident about widespread support for these features just yet though. I'll echo my concerns about portability, how many compilers / workplaces are really using C++ 17, I know my workplace isn't.
No worries, it happens to the best of us ! Cheers :)
Nice! Some solid advice in there...
Casting away constness mentioned in "mistake #8" is undefined behaviour. I would not take that into consideration.
It was implemented as an optimisation circa C++11 by at least gcc/clang/msvc, and it's required by the standard since C++17.
No, casting away constness is never undefined behavior. *Modifying* an object that was *declared* `const` is undefined behavior. If you cast away constness and don't modify, you're good. If someone gives you a const ref to a non-const object and you cast away constness, you're also good.
How does it fall apart if you use same length integers and a packing of one byte? It does not. I've worked at embedded systems where one part was an embedded CPU and the other a desktop pc, there were a lot of messages with variable length etc. There was absolutely no issue between the two totally different platforms.
I was just about to mention it as it was the single most easily understandable argument against this. Exception on ctor would be 2nd
&gt; Especially when dealing with embedded communication, there are many additional considerations - connections may not be as stable as you'd like and/or susceptible to interference, so features such as error detection/correction/recovery become very useful. This has nothing to do with the '"protocol" itself (except for the message fields required to do checksums).
Thank you!
Thanks ! Yes - a lot of thought and as often happens, a lot of reworking after alpha feedback :S
 In my test the new version [martinus robin\_hood::unordered\_flat\_map](https://github.com/martinus/robin-hood-hashing/) is quite faster than before expecially with bad hash function. I also fix and improve emilib hash\_map. The new verison and can pass all you test case now.
When reading this I stumpled over the problem with `std::swap(x,x)` which involves a self-move. In case anyone else does: It is completely fine. The sequence is: swap(T&amp; a, T&amp;b){ T t = std::move(a); // temporary copy made with values of a a = std::move(b); // In case of self-swap this may do anything, but doesn't matter as a is already empty b = std::move(t); // Restore state of object } So if the only post-condition of (self-)move is to leave the src-object in valid (but unspecified) state, this works flawless. The proposed operators in this thread do not fulfill this requirement (unless destructors reset the values foe e.g. pointers, handles...)
"Parallelization of C, C++ and Python on Clusters"
Extremely wrong approach to things. For example, unit conversion does not belong in a library like this. Using virtual functions for encoding/decoding is also wrong. Transmitting metadata, also wrong. Using metadata to capture differences in versions and field types, also wrong. All the stupid things protobuf does...which are not of help at all, blow up the API and require huge amounts of work for little benefit. Protocol version checking should happen only at the handshake phase. Struct headers should be shared by all involved parties, or if that is not possible, the definitions of structs must be clearly documented and the documentation must be readily available to all parties. Endianess should be agreed upon before compilation and struct members shall use endianess-aware types: there is no need for a second pass or copy to buffer if data are already prepared in the appropriate endianess. Variable length data should be copied once to the message to allow for the creation of a continuous buffer. Variable length data should only be used in cases where there are really required, and a fixed length buffer is not possible. Message structs should contain as many as continuous parts as possible and those shall be blasted onto the network using scatter-gather, if available. Message structs shall not contain any metadata whatsoever, because it makes it impossible to use them with other protocols (one of the major reasons protobuf sucks). Further encoding/decoding on messages shall happen with a switch statement, not virtual functions. Using virtual functions requires a switch on the message id anyway, in order to instantiate the appropriate class. Memory allocation should not be done at all. Big enough buffers shall be used for in-place manipulation of messages, both at sending and receiving end points. A class based design for messages is wrong because it leads to all the bad decisions mentioned above. The best approach is to encode the messages in using/XML and then have a tool create all the boilerplate code, and integrate the tool into the workflow. I don't want to use an external tool, but the language itself lacks the facilities needed for this so an external tool is necessary.
No, you've got it slightly wrong. The standard says that the compiler can assume that an rvalue reference parameter \*\*of a standard library function\*\* is a unique reference and doesn't alias any other parameters (including \`\*this\`). But that only applies to the standard library, not in general. The compiler \*\*cannot\*\* assume that an rvalue reference doesn't alias another object in the general case. &amp;#x200B; And even in the standard library, we're now relaxed it so that the rule doesn't apply to move assignment operators (or swap member functions), because accidentally doing a self-move-assignment sometimes happens in practice, and should not cause undefined behaviour.
The reference is [http://eel.is/c++draft/res.on.arguments#1.3](http://eel.is/c++draft/res.on.arguments#1.3)
All around good advice, except for #8 and #13, which feel a bit misguided to me. If it is a problem that your user is casting away const and modifying objects, why use const **anywhere** at all? If this is a problem with #8, it is also a problem with #7. The better option IMO is to treat this (the user casting away const and modifying objects) as not a supported scenario; supporting this is frankly insane. This sort of footgun requires very deliberate action to trigger and protecting your users against it is very costly, as you have to design everything without const. A similar argument applies to #13. In order for the user to gain access to private members via a friend class in your API, they need to take very deliberate action (and involving UB too, I think? The text does not describe what the supposed problem scenario is but I guess it involves defining your own class with the same name as the friend or something like that). Once again, I don't think supporting this sort of thing is worth dropping a useful language feature altogether. Basically, I disagree with this part: &gt; So is it their fault ? No ! It is your fault for allowing them to shoot themselves in the foot in the first place by exposing the friend class. It *is* their fault, because they have to go out of their way to achieve this. When the text says that this "can allow users to gain access to all protected and private members of your API", it makes it sound like private is a tool for security when it is just a tool for API design.
Thanks for the clarification!
Don't string literals have static storage duration? So wouldn't sv here not dangle? I haven't had any practical experience with string_view yet so maybe I'm missing something? I tried this with MSVC and printed out "ello" as I would expect. If that's the case the second example would be an unnecessary conversion and copy.
Thanks for the clarification. It was more subtle than I understood.
Yeah, #13 is pretty bad advice, really. Friend declarations provide a granular access to private data that you otherwise requires a public API. You're actually reducing the surface area of your API by making internal classes friends where necessary. Just don't abuse friends (in life or C++).
This is really a nice reminder for a lot of these topics. I have a really hard time keeping \*all of this\* in mind at once, even after years of writing C++. I also think if I were to strictly follow all of these rules, and fix my existing codebases where they deviate, I'd add a year of work onto every project... The spirit is willing but the flesh is weak.
As the second example doesn't immediately crash I would favour that. I think writing: auto s = my_string_type{some_string_expression}; // why am I not writing: auto s = some_string_expression; ? would be is more effective way of getting the author to think about what type s needs to be as you are explicitly changing the type on the right hand side to what you want as opposed to what the compiler gives you. In the second example, without the context of the first, I don't see any indication that the author wants a string_view? The variable is called s and there's no string_view in sight. For performance, `std::string{"Hello"} + "World\n"` already does a bunch of creation/copying and whatever we write on the left will not change that. In fact, assuming no SSO, `auto s = ...` will only result in a cheap move.
I think #8 refers more to the "reference" bit rather than whether it is const or not. Returning a reference to object internals does exhibit the problem if: what happens if you have a reference after the object has been destroyed.
Yes, but casting away constness is a big code smell regardless in user code, because in many cases people end up modifying a previously const object. Therefore, every `const_cast` should be well documented.
\#13 is a bit inaccurate. there are ways to make this safe, like marking the friend class as \`final\`.
&gt;Firstly, your formatting is off. Some of it isnt displaying as code. Are you reading it on a phone? &gt;About your code, the parts i could read atleast :) checking this != &amp;a is completely unnecessary in ctors (copy ctor, moce ctor) for obvious reasons. also im not aware of a situation where move assigning to self would happen. Well, I agreed. :)
Technically yes. This more like my old habit. I always like to write \`this-&gt;\` because it makes it obvious that it's a member variable of \`this\`.
I have to disagree with #13... If someone wants to access private members they don't even need any friend classes. I mean with some template magic you can access private member fields/functions anyways. I don't see how friend classes make this problem better / worse... [https://github.com/insooth/insooth.github.io/blob/master/accessing-private-members.md](https://github.com/insooth/insooth.github.io/blob/master/accessing-private-members.md) There are even some libraries to avoid most of the boilerplate :P [https://github.com/hliberacki/cpp-member-accessor](https://github.com/hliberacki/cpp-member-accessor)
I mean you should learn by yourself in addition to what you have at the University. Here is a list of good books to use: [https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
using class instead of struct, which needlessly adds boilerplate.
For #13 if the class befriends a template, you can specialize the template to have access to the internals of the class which befriended it.
&gt; How to fix it ? &gt; Simply mark the move constructor and move assignment operator as ‚Äúnoexcept‚Äù Uh, you have to ensure that the operators themselves cannot throw and that all functions they call are noexcept. "Simply mark it" is deeply misguided -- it's not the mark that's important, it's actual behavior. :smdh:
The example in #7 is wrong, making the function cost only makes "this" const, and says nothing about the vector objects being passed to it.
Excellent article.
&gt;Don't string literals have static storage duration? So wouldn't sv here not dangle? You are right. It's a bad example. A better example would have been a function that returns a string view were it is not obvious from the name that it returns a string\_view. In that case using auto could lead you end up storing a string\_view when you thought you were storing a std::string. auto oldName = x.getName(); x.setName("Alice"); std::cout &lt;&lt; oldName &lt;&lt; " has changed name"; // Not good if oldName is a string_view
Great! I need clang for up to date openmp support.
I misread that as uvu.
I've been wanting to use libuv but haven't found a good way to manage object lifetimes. Does this wrapper provide a way to do that?
\#5 Be careful when adding noexcept to a public API because removing it would be a breaking change.
Yeah, lifetime is implicitly managed by the handles. The README contains enough details for that but feel free to ask me if something isn't clear enough.
&gt; videos from 3014 where Herb Sutter gave a talk about modern CPP features That's some extremely modern C++
I do not see any significant difference, care to elaborate?
Instead of Circle(double x, double y, double radius=10.0); you say we should write Circle(double x, double y); Circle(double x, double y, double radius); but I don't understand your concern in #11.4. If the user can specify the radius by passing a third argument he obviously must know what unit he's dealing with. If the user does *not* specify the radius he probably wants to know what the default radius is. By hiding the default radius the code is no longer self-documenting. The exception is of course if you want to say it is unspecified and the user is always supposed to set the radius explicitly.
&gt; memcpy is an obvious solution and constexpr helps a lot, but is there no way to avoid a copy and not hit UB? What copy? You would not believe how many `memcpy`s a compiler can optimize out.
4\. `BOOST_ENDIAN_*`
Did Not Connect: Potential Security Issue &amp;#x200B; Firefox detected a potential security threat and did not continue to [habr.com](https://habr.com) because this web site requires a secure connection. &amp;#x200B; What can you do about it? &amp;#x200B; [habr.com](https://habr.com) has a security policy called HTTP Strict Transport Security (HSTS), which means that Firefox can only connect to it securely. You can‚Äôt add an exception to visit this site. &amp;#x200B; The issue is most likely with the web site, and there is nothing you can do to resolve it. &amp;#x200B; If you are on a corporate network or using anti-virus software, you can reach out to the support teams for assistance. You can also notify the web site‚Äôs administrator about the problem.
Really? `memcpy` being a C function whose implementation is somewhere inside `libc.so`, I didn't think a compiler could optimize them at all.
Well, that's odd because everything is fine for me and the certificate appears to be valid https://i.imgur.com/Xp5je8G.png Are you sure it's not your local Wi-Fi or campus network eavesdropping on HTTPS connections?
Nope. It works on IE
What version of IE do you have installed? HSTS was added in IE 11 https://support.microsoft.com/en-us/help/3071338/internet-explorer-11-adds-support-for-http-strict-transport-security-s
 std::ifstream in(....); std::string line; while( std::getline(in, line) ) std::cout &lt;&lt; line &lt;&lt; '\n';
[pre-commit](https://pre-commit.com) is a tool to organize the scripts that should be triggered on git commit. I created a [pre-commit hook](https://github.com/pocc/pre-commit-hooks) that integrates clang-format, clang-tidy, oclint, which format and analyze your C/C++ code. Using these linters as part of cmake or directly in your editor is also a good idea if you're not doing so already.
Never though that my project setup would be: Visual studios with a CMake build system, compiling with clang, with all the dependencies (including clang) supplied by conan. Not to mention that the visual studios debugger and intellisense all work perfectly fine.
They can. They can add hidden calls (when optimizing ctor calls in a loop to a single memcopy/move) and remove explicit ones (optimize to register moves). Sometimes there is even an issue with password storing as many approaches involve memcpy call or loop that assigns string contents to zero to securely erase sensitive data before that memory is freed. Compilers often remove such calls because "why would you want to zero-out an object just before it dies, these are useless writes"
Yeah, for #8 possible const\_cast is not an issue. Of course, the documentation should be clear what the liftetime of the reference is. Another thing I've noticed though is that although returning a const ref provides better performance, there are tradeoffs. What if a method returns a const std::string &amp;, but it becomes a computed string in the future. If you don't want to change the signature of that method, then you'd have to cache that computed string.
I knew the problem with zeroing out strings that held passwords (dead writes), but in the case above it wouldn't be a dead write. Perhaps I'm missing something, because your first paragraph isn't quite clear to me.
The only time I tend to use friend classes is for making unit tests.
Thanks for the comment. It may not be so fast, but I think it is possible. Do you want a stable "lazy" sort?
Here is very simple (and naive) coma-delimited tokenizer built on `std::getline`: static constexpr const char delim = ','; std::string string_to_tokenize = ...; std::istringstream tokenizer_stream(string_to_tokenize); std::string tok; std::vector&lt;std::string&gt; tokens; while(std::getline(tok, tokenizer_stream, delim) { tokens.push_back(std::move(tok)); } // Enjoy your tokens!
Yet another another PVS studio promotional. I am utterly tired of those.
Compilers can optimize various operations to mem copies/moves if they can prove it has the same effect (the as-if rule). For example, if you create an array of some trivially constructible type (it may hold pointers, built-in types and other trivial types) the compiler can optimize looped ctor call to a single memset/cpy call if it has the same effect on the values of all members. Small range memsets/copies can be optimized to register moves if they fit. And if you do that memcopy just to safely bypass aliasing restrictions, it might as well be completely optimized out and the same register will be read as different type, knowing that aliasing may happen.
`static` and `constxpr` don't mix because of lifetime oddities.
That jumped out at me, too.
That's untrue. Marking a function as ```noexcept``` guarantees that the function/operation will not throw. There is nothing particularly unreasonable about marking a function ```noexcept``` that would otherwise throw an exception due to incredibly rare circumstances like out-of-memory errors or potentially undefined behavior.
They could have stated it more explicitly, but I understood it as "mark your simple move operations as noexcept", since they go into detail about move only being shifting a pointer, basically. If moves are so complicated as to require operators that could throw, it seems to me that you should think hard about making this class moveable anyways.
Took time to look into the mistakes described in the article. Here is what I found: 1. Putting API in the namespace. Overall a no-brainer, but the example they provide has `using namespace std`, which is an abomination. Should have come up with a better example. 2. Do not pull other namespaces in. No-brainer as well. 3. Follow the rule of 3. My take - better yet, follow the rule of 0. Also, it is not specific to API - just a basic C++ rule - and seems like it was only put on the list to achieve the magic number of 25 items. 4. No objections, but as in 3, not specific to APIs. 5. Same as 4. 6. Same as 4. 7. Same as 4. 8. Not returning the internals of your API via const reference - I can't get my head around it. If it is returned, it is not internal, by definition. Not sure what author wanted to tell here. 9. Splitting code between different headers. No-brainer. 10. Explicit template instantiation. Wholeheartedly disagree and likely an antipattern for generic APIs. 11. Prefer overloads to functions with default arguments. See 4, also sometimes default arguments make more sense than overloads. 12. Use named constants instead of #define macros. No-brainer on itself, also see 4. Also, the last paragraph widely suggests **always** using `enum class`. Over generalization, there are still good reasons to use vanilla enums. 13. Never use `friend` classes. Anti-pattern. Language feature exists for a reason, and not using it when it is called for is a mistake. For example, non-trivial container iterators are friends with their containers. 14. Do not include unnecessary includes. I might add - also do not put the whole text of 'Nibelungenlied' in the comments. Useless advice on it's face. Could be useful if author would suggest a tool or technique of removing unnecessary includes (rather than do not include if you need it), but alas. 15. Do not forward-declare symbols from third-party libraries. No-brainer. 16. Same as 4. 17. Provide versioning of your API. Yes, and please write good code. Wishful thinking without specific tools or techniques. 18. Incorporate linking mechanism (dynamic vs static) into library design. Anti-pattern. Best libraries are provided as both .so and .a. 19. Be cognizant of ABI. Yes, and please write good code. See 17. 20. DO not add pure virtual methods to already released classes. Yes, and also do not change functionality of a class which is called NetworkManager to be a VectorizedImage without changing it's name. Moot point. 21. Document API as synchronous are asynchronous. Weird advice. Why only this aspect? Just document API, period. And least I forget, please write good code. 22. Do not depend on the features which are not available to your customers. Also, do not include Posix function calls in Arduino libraries. 23. Consider using header only libraries. Controversial. There are pros and cons, and with modules in sight, there will be less pros. 24. Write consistent code. And good code as well, please! 25. Review and plan your code. Did I tell you that you need to write good code? Overall impression: wasted time.
Eh, a simple constraint to avoid those issues is to limit the returning of references unless their lifetimes can be assured. If you have a code module whose primary instantiation is only valid during the context its return values would be used, then there's no problem. But that's primarily the case for sub-systems. For a library that's more general purpose, however, it's less sensible to return references unless there's a really good reason.
&gt; Marking a function as noexcept guarantees that the function/operation will not throw. Are you sure? Note that [this function](https://godbolt.org) marked noexcept definitely can call `__cxa_throw`. As I understand the specification, specifically ¬ß14.4 (5) &gt; Whenever an exception is thrown and the search for a handler encounters the outermost block of a function with a non-throwing exception specification, the function std::terminate is called. I read this as: a function marked `noexcept` can throw, and that throw results in the program being terminated immediately. &gt; It's not deeply misguided as you put it, it's a trade-off, something that software developers should be more appreciative of as opposed to overwhelmingly dismissive. I think you misattributed what I think is deeply misguided. It's deeply misguided to "just mark it `noexcept`" without analysis of whether it can actually throw an exception. If the answer to the question is yes, then you have to follow up with a question about whether it's acceptable that this exception causes an immediate termination. It's not at all deeply misguided to go through this exercise and conclude that the terminate is acceptable and mark it `noexcept`. But that's *not* what the article suggests -- it simply says mark it, without actually thinking it all the way through.
When you get a point where you nitpick every minutiae presented as a generally good advice on how to write C++ programs, you may as well dismiss all articles, all speakers, everything period at that point and basically spend hours and hours deliberating on every little tidbit of your codebase to the point that you barely produce any workable code. Of course no one does that... we make trade-offs based on guidelines, and the guideline that move constructors should simply be marked ```noexcept``` is a valid one, even if it would otherwise throw an exception. It also results in significant performance benefits when such types are used with the STL. Being dismissive and nitpicky is great for winning Internet arguments and gives you an opportunity to show how much you know that the author doesn't... fine... you can have that point. But for people writing actual C++ software who wish to benefit from having efficient code and a decent API, mark your move constructors as ```noexcept```. Having a potentially throwing move constructor is a bad API that incurs a significant cost on numerous standard library functions and just isn't worth it in the rare case that your system runs out of memory.
There is an extra `const` there in my snippet, it is true and I will edit and remove it. But your comment makes no sense, sorry.
&gt; Mistake # 16: Not making a header file must be compilable by itself Mistake #16.1: Not making sentences readable must be in themselves readable correctness. (And the example in #7 is wrong. Const is about the object, not the parameters).
My bad. `static constexpr int foo = 0;` is allowed, but the following isn't: constexpr void foo() { // &lt;source&gt;:3:26: error: static variable not permitted in a constexpr function static constexpr int x = 0; return x; }
&gt; I read this as: a function marked noexcept can throw, and that throw results in the program being terminated immediately. No exception has left the function. So no, the function can't throw. If you want to trade a possible speed-up when putting objects of your class in std::vector for the possibility of a spectacular hard run-time crash if your move ctor would happen to throw is another matter...
Inheritance narrows down the problem of "wtf does this mean?" to a (hopefully small) set of child classes. I imagine the number of complaints is correspondingly smaller.
Well, I don't really need it at this time, but I think it could be useful and perform better that doing a full std::sort. Suppose you only need the 5 smallest values from a vector, right now you'd probably do std::sort and get the first 5 values. With the merge sort you can do only the comparison needed to get those five lowest values at the beginning. This is one of the reasons why merge sort is used in Haskell.
Reassigning pointers isn't UB. Destruction of an object that keeps being used *is*.
Yes, no exception has left the function. But an exception can be thrown during execution of the function. You are right, in some sense "it can't throw" is true because of the former. &gt; If you want to trade a possible speed-up when putting objects of your class in std::vector for the possibility of a spectacular hard run-time crash if your move ctor would happen to throw is another matter... Yes. And "yes, I would like to make that choice" is a perfectly valid one that I support fully! But the programmer has to go into the choice realizing it, not just blindly marking things noexcept.
Can you be more specific, I am particularly asking how is the example I posted not relevant to the code OP was posting?
That is true. Constexpr functions do not allow static variables for obvious reasons. I would make an exception for static constexpr variables if I was on the committee, but for better or worse I am not :)
Pretty sure they meant to type this: ``` bool AreCoordinatesSame(const vector&amp; vect1, const vector&amp; vect2); ```
I mean, I do write actual C++ software, which is run pretty darn often, and the team absolutely do nitpick because correctness and safety are our most important goal. &gt; Of course no one does that... we make trade-offs based on guidelines, and the guideline that move constructors should simply be marked noexcept is a valid one, even if it would otherwise throw an exception. I just plain disagree. A move constructor should be marked noexcept if and only if the programmer has reviewed and understood all the possible exceptions that could arise during execution and judged that the behavior of a hard crash due to those exceptions is acceptable. In other words, I don't disagree with the **conclusion** that in many cases `noexcept` is correct. I disagree with the **process** that says you should mark it before understanding exactly what behavior you are causing. Saying "because this is the right answer in a lot of cases, we should just assume it's the right answer always without doing our due diligence" is not a valid guideline, even though I agree that `noexcept` is the right thing to do in a lot of cases. The programmer writing actual software needs to understand exactly what they are doing, especially in C++ where there are who-knows-how-many ways to hang yourself.
From your link: delete p_; // Line #1 p_ = new Wilma(*f.p_); // Line #2 This ends the lifetime of `this-&gt;p_`. OTOH, OP's code has: this-&gt;~Foo(); new(this) Foo{other}; which ends the lifetime of `this`.' It's reasonable to assume that members will be invalidated after assignment, so your case is rarely going to lead to UB. OTOH, OP's case is UB within the posted code itself.
std::partial_sort? Or - with an older C++ - nth_element + sort of beginning.
Probably true, but I still say that if you're looking at code that calls a function and you have to ask "wtf does this mean?", then you need better function names more than type info.
&gt; I just plain disagree. A move constructor should be marked noexcept if and only if the programmer has reviewed and understood all the possible exceptions that could arise during execution and judged that the behavior of a hard crash due to those exceptions is acceptable. Then you are making the mistake of conflating an API with its implementation. A move constructor should be marked as ```noexcept``` if it provides a more useful API for the consumer of that class and better reflects the intent of that data type. This has nothing to do with implementation details, which may not be known at the time that the API is declared, and which may change in the future. APIs should be robust against changes to implementation details, and the manner by which you have chosen to specify whether a move constructor is ```noexcept``` makes your API brittle in the face of such changes.
Hmm. I've never been a fan of client-side check enforcers like these. One big reason is that `git commit -n` exists and it prevents easy `git commit -a -m 'saving work; putting out a fire'` (though `git worktree` can help there, if it's an expensive project to compile, sharing the same source tree can be very useful). Much better to have the checks enforced at the PR level with on-demand "fix stuff for me" mechanisms. The other big reason to not rely on client-side checks is that not all tools are stable. `clang-format` is a big problem here where the same configuration can have different formatting based on whether 5.0 or 6.0 is being used.
This is about as irrelevant as claiming that the following function throws because it contains a ```throw``` clause: int f() noexcept { try { throw std::exception(); } catch(const std::exception&amp;) { } return 1; } I mean, yes, that function has a ```throw``` clause, but it's not a function that throws. A function that throws an exception is about how that function appears to a consumer of the function, not about the implementation details that are invisible to the caller.
Though is there a point of declaring `constexpr static` variable? `constexpr` will force it to be evaluated at compile time.
Just when I thought I had seen every possible anglicized spelling if Chebyshev... &gt;Gauss-Tschebyschow
üòÅ
To some extent, yes, but given that not even the STL is really good about this, there's only so much that can be done. Can + throw? Does [] perform an insertion? Will erase() invalidate references to things you didn't erase? The only way to know is to figure out what the types are.
Yes. I think it will be faster to pick up the top N than to sort everything. If it is an unstable sort, it may be relatively easy. I think stable sorting is difficult.
OK, obviously *uncaught* was implied. Anyway, I think we basically agree on the actual ground-level facts.
And Ninja is 1.8.2, is there a problem with 1.9?
But the API and the implementation have to be in sync right? They are supposed to mirror one another. If you write the API first and then find the implementation doesn't match what you wrote, you've got to figure out how to align them. &gt; APIs should be robust against changes to implementation details, and the manner by which you have chosen to specify whether a move constructor is noexcept makes your API brittle in the face of such changes. Yes, which means that by committing to a `noexcept` API, I am constraining my future implementation choices. Which we both agree is probably the right thing to do, but again, the programmer has to understand what they are doing. Look, I think you clearly understand what's going on. So the advice of 'think for a second before marking things noexcept so you don't hit unexpected pitfalls' clearly doesn't apply to you. But for a less-experience developer (the kind who might read a listicle) that might not yet understand this nuance, and so might have to consider things more carefully.
Unfortunately, it's unclear whether this is a class member or a stand-alone function. In many cases, the author has been discussing OOP-related constructs, so I was assuming this was a member function. That needs to be clarified. If it's a member function and not a stand-alone function, then the function should be const as well. Otherwise, you're correct.
Works with Firefox 66.0.2 on Mobile.
OTOH I assumed it was a free function since other examples were either in class or `MyClass::`'d
Will you stop teaching me how programming works and listen to my points? \&gt;because you should get a memcpy and a heap allocation, especially if you concatenate a string? will that copy the memory from the heap into the stack and back? \&gt;I didn't do anything like that and I made sure to keep my buffers significantly smaller. You are litterally using ATLEAST 7k of heap memory inside of the program, so thats not significantly smaller than 100 bytes. &amp;#x200B; \&gt;I'll also point out that the compiler will generally combine strings it can, so I have accounted for that when counting. Or are you implying that the compiler will use the same memory for different strings AT THE SAME TIME? &amp;#x200B; \&gt;All the extra includes for basically the same functionality led to an extra 20KB in the binaries, so strings were using up more space than the buffers. Get yourself a C++ compliant compiler. Or - to quote the C++ philosophy: [https://ibb.co/kGdc2kw](https://ibb.co/kGdc2kw) "You don't pay what you don't use" I doubt that you need 20KB to implement basic std::string functionalities. &amp;#x200B; Other thing: where are your bound checks when working on the char-arrays? \&gt;The whole point of a buffer is to be large enough that you shouldn't run out of space but small enough that it can easily fit on the stack, and then you omly deal with memory in buffer sized units. &amp;#x200B; This is a non-answer. Unless you want to have some spooky sigsev's (not implying that I don't believe that you can't count to 2048... But i dont think that every dev is able) :D
&gt; Uniform initialization syntax is one of my favourite features of Modern C++. It was also my favourite. That is, before I learned it. &gt; For Modern C++ there is also a third difference: the way brace initialization is handled. That's not a difference between `struct`s and `class`es. &gt; attributes The word "attribute" has a different meaning in C++. &gt; Even though we‚Äôve explicitly deleted the two constructors, this code compiles just fine. Not in C++20 any more. &gt; direct initialization &gt; copy initialization &gt; user-defined aggregate types (containers, etc.) These can probably be rephrased to avoid clashing with existing terminologies. (I suggest "direct initialization" =&gt; "initializing the members one by one"; "copy initialization" =&gt; "be explicit about the type"; "user-defined aggregate types" =&gt; "non-aggregate types that want to support list initialization".) &gt; The initializer list (and its list of initializing objects) is an r-value expression. A parameter is not an rvalue, sans explicitly cast. The underlying array is technically a temporary, but lifetime extension makes it trickier. &gt; To invoke a non-initializer_list overload you must use the parenthesis constructor notation List initialization would be much simpler if this were true.
It's awesome that F14 maps are open source. In [my benchmarks](https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/) `F14ValueMap` was a few times on the pareto front with quite low peak memory usage, but sometimes it's relatively slow compared to the top performers. The hash `folly::hasher` didn't do too well though on average. Building with cmake was a bit troublesome, it took me a while to figure out that I have to add this to my CMakeLists.txt: list(APPEND FOLLY_CXX_FLAGS "-march=native") because folly does not seem to make use of the `CMAKE_CXX_FLAGS_RELEASE` setting.
Just try it with llvm. I usually have to kill it because of how long it takes.
Products gonna market. Given that, doing so by providing interesting, useful information to me is a big win over just blaring their brand at me constantly. Until we figure out how to inform ignorant, passive, potential customers without marketing, content-marketing is the best evil that I've seen so far. Hell... I run r/TheMakingOfGames "Making of" videos are totally content marketing. But, they also humanize developers and help customers appreciate what goes into making the products they like. Total win over "Explosion Trailer #34852782!!!" Our rule is that it's totally fine to promote your own game there, as long as your content is *how* you made the game, not *that* you made the game.
Hey, my engineering team is telling me that in 16.1 Preview 2 there are some "secret"\* large performance improvement in all Open Folder scenarios including CMake. Not saying that your particular scenario is affected, but can you give Preview 2 a try to see if you notice improvements? We can take it from there. In the meantime, we'll take another look at the repro in the ticket you shared. Thank you! \*) secret in the sense that we're still working on blogs for those.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; F14 is a good default ‚Äî usually a great choice and never a bad one, regardless of the use case. They need to prove it. They did most comparisons to std::unordered_map, which is pretty much the worst for small keys and large tables. Chunking and the tombstone treatment do look interesting, but how much they help with practical performance remains a question.
I completely agree! It's about lifetimes when it comes to that. I think that in some way that's what #8 is trying to say hehe
The things that should be at the top of every list are (and this is NOT in direct response to this article, just a general observation.) 1. Understand that any advice you read may be from someone who writes code completely different from you. People who write embedded code, web sites, gaming engines, large scale general frameworks, operating systems, etc... though they clearly will have a fair bit of overlap, will have many of their own concerns and constraints that may or may not apply well (or possibly at all) to your situation. 2. Understand that any advice you read may be from someone who is overly obsessed with some bit of minutia that is really not terribly important in the larger scheme of things. 3. Understand that some people who post advice are more interested in the language than in using the language for what it's intended for (i.e. to create products for people to use), and may have some to many views that are academically perhaps correct but perhaps not so practical or important in the real world. 4. Understand that we already had all the language tools needed to create good (and completely currently functional) software ten or twenty years ago, and that a LOT of what is being talked about has more to do with people and organizational issues and trying to avoid them in an automated way than with writing software (and hence may or may not apply to you in your situation.) 5. There are a lot of fads in software these days, lots of them. There are so many people going in so many different directions that to keep up with it all would mean spending way more time worrying about whether your software pants are tight enough than actually doing what we are all supposed to be doing.
\#19 is pretty oversimplified, imo. Binary compatibility is *really* hard to maintain. I think it's best to just not bother with it unless you have good reason to. The easiest method is to use semantic versioning and increment the major when there are breaking changes. For actual binary compatibility I'd pull a Qt and do all the magic that they do, with all the testing suites and the likes that comes with maintaining an ABI stable library. For a lot of libraries it's just not a hard requirement to be ABI compatible, so I think the advice of "Just be ABI compatible LOOOOOOOOOL" is very shortsighted.
Not really, just muscle memory of typing all this `static constexpr` class members.
I find the implication in #11.2 that the default radius is an implementation detail problematic. If the raduis is 10 in one version and 20 in the next you can be sure that peoples code will break. The correct solution for 11 is not to provide a default value or an API that implies a hidden default value when you cannot guarantee that its behavior will remain sanely stable. I just had a library pull the default font size under my feet, half the text in my program ending up too big is not an implementation detail.
For you, large scale guys, rule number 0 should be read and embrace "Large-Scale C++ Software Design" :)
If everything is const correct, then the only time you are casting away constness is when you're going to modify it. These shouldn't be two different things.
Great! Is there also a way to use a Ninja-based build for IntellliSense without CMake? Because I have a project that builds with Ninja but the Ninja build file is not generated with CMake (it's using a custom tool). In VSCode this seems to work, it only requires a compile\_commands.json, which Ninja can produce ...
cool, didn't know about std::partial_sort.
LLVM actually still worked for me. It had to copy LLVM three times into itself to trigger the problem.
Redo the same experiment with the code (this will take the first argument and print out "Hello " + argv[1] + "!". char buffer[8000000]; char * buffer_index = buffer; buffer_index += snprintf(buffer, sizeof(buffer) - (buffer_index - buffer), "%s", "Hello "); buffer_index += snprintf(buffer, sizeof(buffer) - (buffer_index - buffer), "%s!", argv[1]); printf("%s", buffer); and you'll see that the stack pointer will be incremented by 8 000 000 and the "Hello!" string will be 7 bytes in memory. It's a memcpy of seven bytes, however many bytes are in argv[1], and an exclamation point. Then do std::string str = "Hello "; str += argv[1]; str += "!"; and you'll see two, maybe three heap allocations and four memcpy calls. If you want, you can call str.reserve(40), which will get rid of one of the heap allocations. Incrementing a pointer is much faster than heap allocations because it's literally addition. Now, I want to make a few things clear. First, std::string is more easily usable and safer. If you don't write the code exactly as I have written it, you could easily get a segfault, overwrite the section in memory, etc. In my code, I should have either wrapped it in a function or a class. Second, memcpy will happen whenever you copy memory. There is no way to get from a const char * to a std::string without copying the memory from the const char * into std::string's heap allocated memory. Lastly, std::string uses dynamic memory management, which means it will have to allocate more memory, copy its data into the new memory, and free its previous memory whenever you allocate more than its capacity. A stack allocated char buffer just needs a memcpy, but it can't get more memory. In my program, I was using at most 7 kilobytes of stack allocated memory at any given time, but that was mainly because I didn't reuse the buffer, which was bad on my part. Bound checks were either in while loops that I knew were null terminated (while (buffer[i] != '\0')) or in four loops where I knew the maximum size of the buffer. I got a bigger binary in part because I also included &lt;unordered_map&gt;, &lt;iostream&gt;, &lt;fstream&gt;, switching them out for stuff like &lt;cstdlib&gt; and my implementation of a hash table. In other words, I switched most of my code from what it was before to the STL. I was also using everything I could to make the binary smaller, as you can see in my Makefiles. I am currently using g++6. I have heard all your points and most of them are flat out wrong ("the heap is on the stack" didn't get downvoted out of nowhere).
hi! 1) path has various methods that allows conversion to all string types (in cpp17): wstring, string, u8string, u16string, u32string, not sure about cpp20. 2) std only gives you a way to get the current directory, but I don't think there's easy way to get exe location... the design is based mostly on boost, so developers could reuse that experience
&gt;and you'll see that the stack pointer will be incremented by 8 000 000 and the "Hello!" Where is the space for the stack allocated? &gt;nd you'll see two, maybe three heap allocations and four memcpy calls. If you want, you can call str.reserve(40), which will get rid of one of the heap allocations. memory allocations (the heap is the thing that keeps space for globals and literals, if you want) are definitely faster and less clumsy than having 7kb of buffer in your exe &gt;There is no way to get from a const char * to a std::string without copying the memory from the const char * into std::string's heap allocated memory. welcome to the magical world of DMA... Oh well, thats another story for another day. This copying is yet another reason not to use your buffers, lol &gt;Bound checks were either in while loops that I knew were null terminated (while (buffer[i] != '\0')) or in four loops where I knew the maximum size of the buffer. where do you bound check when assigning? &gt;I have heard all your points and most of them are flat out wrong ("the heap is on the stack" didn't get downvoted out of nowhere). My claim was the opposite... or atleast should have been the opposite... Now, if you want to call the heap litterally anything that is allocated by malloc (or new, by extension), sure... thats just a nomenclature thing. My points still stand.
If you want to compare your library to mine, replicate the output of [this program](https://github.com/TheLandfill/cpp_cli/blob/master/src/test_cpp_command_line_parser/) using your library. It should be able to parse all [POSIX standard inputs](https://stackoverflow.com/questions/14737957/handling-command-line-flags-in-c-c/14738273#14738273) and generate help on its own. Rules - Your library, with all features I described implemented, should beat my library in some way, whether it be memory usage, speed, flexibility, ease of use (Since it varies from person to person, we'll say fewest number of lines/bytes in the command line parsing section wins, whichever you think better captures the essense of the program. If you do bytes, you should not count off for things that make the code more readable. You should not count the bytes in the help message, as we would both use the same help message.), etc. - You don't need to include any asserts or whatever, just what you need to parse the command line. - It should also be able to print out all the non-options, or things on the command line that are not arguments to flags. - You can extend your library, but you'll have to explicitly say that you have and that your library could not replicate my library at the time you recommended my library. For reference, your current commit is [aa137c9a](https://github.com/Wittmaxi/CommandEr/commit/aa137c9a8a1580536427b3d59751fa5739d3ff9c). If you think any of these requirements are unfair, then you can explain why. If you can't replicate the functionality of my library with your library, you cannot tell people to use it instead of my library, plain and simple. I would also like to see a program that causes my library to segfault or do something unsafe. For it to cause my library to segfault, the segfault must happen inside one of the functions in my library. You also cannot tell it a buffer has more memory than it does if you were to use a buffer (that's a bound check, by the way), provide it a pointer to variable and then delete it or let it go out of scope before the program parses the command line, or provide a char buffer that does not have a null terminator by doing char test[5] = "Hello"; or char test[5] = { 'H', 'e', 'l', 'l', 'o' }; or anything else that would cause an std::string to fail. Since you didn't know what subcommands were and WSpecializations are kind of optional, I won't press you to replicate the output of either of the other two programs.
&gt; Over generalization, there are still good reasons to use vanilla enums. Other than C compatibility, what are those reasons?
If you don't want to use linters... then don't. That said, I appreciate the feedback. I've added a `--version=` argument to enforce a linter version project-wide.
Would be cool to see it compared to Abseil's hash tables.
Oh wait I am made to actually put work into an online debate... ¬Ø\_(„ÉÑ)_/¬Ø Fine your lib is better. ... as long as you don't look into how the internals work
Rereading, yeah, that probably came across a bit harsh. Sorry about that. Was more looking to share my experience with such things. The version argument is a good idea. Thanks :) . (I care because sometimes I contribute to projects using setups like this and either they're running `master` or expecting Ubuntu LTS-1-era software when I run latest Fedora.)
Basically, any inter-operability with the world outside of your application, not exclusive with C. OS API, network communications, etc.
"Put your money where your mouth is," always works on people who talk the talk but can't walk the walk. Also, I looked into your internals and your library runs in quadratic time while mine runs in linear time. :D
My library runs in quadratic time? Lol how bad was I back then? xD (I still doubt that it runs in quadratic time though, more like linear)
&gt; path has various methods that allows conversion to all string types (in cpp17): wstring, string, u8string, u16string, u32string, not sure about cpp20. I asked mainly because cppreference.com lists &gt; `std::u8string u8string() const;` (since C++20) And if C++20 `u8string` is just a specialization of `std::basic_string` for an UTF-8 character type, then it's not assignment- or initialization-compatible with `std::string`, and in that case, breaking existing portable code and Windows code. *nix-specific code presumably doesn't use `u8string` to get UTF-8 strings; only Windows code or portable code needs to do that. It looks to me like a political maneouvering, sabotaging a major platform. But rather than just assuming that it is so, I ask.
:D
I think the whole of #11 doesn't make sense. Before adding the radius parameter the circle had a radius already. The default radius value was already defined internally in v1. Adding the parameter and defaulting it to the same thing doesn't break anything. And the stuff about "what if you add units?" is arbitrary and silly. You update the default to use the unit that was used before implicitly. The only sin to be made here from an API perspective is to change what the default radius is.
&gt; At scale At what scale?
Well, for me personally, it's in the million line range. I'm not going to get into what the ANSI standard for 'scale' is in software. It just means quite sizable projects. Probably at a point where it becomes very difficult for any one person to really understand it all in detail and hence coordination and logistics become serious factors. Where the are multiple large layers to the product, maybe even multiple separate code bases, being maintained by separate teams most likely. I think most everyone would know if they fit solidly in that category or not. Obviously some folks would be on the border line.
Here's a list in no particular order : 1. Root Cause Analysis. Always. 2. Never underestimate vulnerabilities: they don't need to be critical on their own to be part of a critical chain; also, hackers can be much more creative in leveraging them 3. DRY; Factorisation is key. 4. TDD; If a feature is worth coding, it is worth testing. 5. FP; Learn about functional programming patterns, they are incredibly valuable. 6. PostModernC++; Leverage the procedure. 7. Strive to ¬´ Live at HEAD ¬ª 8. CI; Continuous integration is key: test suites, sanitizers, static analyzers, fuzzers, etc. 9. Dig deeper. 10. Own your mistakes and keep learning.
Without any information about what type and scale of software you tend to work on and what your experience level is, that information isn't as useful, since a newbie has no idea if you do the kind of software he wants to do otherwise, and hence how applicable what you recommend may be to him.
Re: casting away cobst. Isn't the idiom design against Murphy, not machievelli? If someone wants to cast away const then that's the ball and bug pretty firmly in their court to fix.
It is new for C++17 if I remember correctly. But nth_element has been therre all the time.
nth_element doesn't help... the idea is that you don't want to sort the whole sequence.
Nice work!
Well, this is the only list you've received in this topic at this point in time. Maybe you should wait a bit longer before concluding that it's not generic "as evidenced by the fact that other people give considerably different ones"?
It creates a new scope. Useful for RAII and for naming...
Well, I know because I've read many people's recommendations over time. They will be all over the place. Even just between his and mine there's little overlap.
Just out of curiosity, aren't points 1,7,8,10 used almost everywhere?
I would certainly hope so! But if I had to teach 10 things, I'd focus on those core principles rather than any specific code snippet or algorithm.
Not really. As a for instance, some people think that #7 and all that 'agile' type stuff is a cancer on the body of software. And, anyhoo, it's not whether they are used, but how much emphasis people put on them. Many people may not have any of those in their top ten list.
Two different lists doesn't imply a sizable group won't rally behind either of those rather than bring up a third candidate. (then replace Two with N and replace third with N+1th)
As /u/CptBread says, it makes a new scope. So if you do this: &amp;#x200B; int x = 3; int z = 0; { int y = 5; z = x + y; } &amp;#x200B; std::cout &lt;&lt; x &lt;&lt; '\\t' &lt;&lt; y &lt;&lt; '\\n' &amp;#x200B; you'll get a compile failure, because y has fallen out of scope, but if the output was &amp;#x200B; std::cout &lt;&lt; x &lt;&lt; '\\t' &lt;&lt; z &lt;&lt; '\\n' &amp;#x200B; it would write out 3 8 as you'd expect. &amp;#x200B; Sometimes useful, sometimes not. I came across a main in one of our test runners at work today that had literally everything except a last "return 0;" wrapped in a scope. Since I've not idea what the point in doing that was, I wondered whether to revert it and then said, "Feh, who cares?". It causes no harm given we use the test runner its a part of daily, but it's a file that I've not looked at in, evidently, almost six years, so it's not really worth the bother of fixing, sending out a pull request, running through the test suites and checking in.
The Angles did come from Germany.
Not very likely. If you've done much reading, people are really all over the map with this stuff. And I can almost guarantee that a sizable group of people around here will NEVER rally behind anything I say. At least it's not happened since the Big Bang, which is a probably a pretty predictor of future performance.
I still disagree. Have you actually ran into problems with std "polluting" the namespace? std is well known. I'd get angry with someone if a library is re-using functions/classes that the std defines. It's a great way to confuse people. If a library has to do it then it's the only time I think not using std is acceptable. This whole thing sounds like one exit per function which is a C thing that dumb people think still apply to C++
It's a *compound statement*, i.e. a statement that contains other statements. Every time you use curly brackets with `if`, `else`, `for`, `while` and `switch` you are actually using a compound statement. For example, the if statement is defined to have the following form: if ( *expression* ) *statement* As you can see we are only allowed to have one statement. That is why we normally use curly brackets to create a compound statement that contains all the statements that we want inside the if statement.
It's definitely useful for RAII but (ab)using it for naming local vsriables can create bugs that horribly difficult to find.
 void DoStuff() { // Do stuff. // ... { std::unique_lock&lt;std::mutex&gt; Lock(MyMutex); // Do protected stuff. // ... } // At this point, the mutex it released. // Do more stuff. }
..so many years after kdevelop ;-) Does clang on win is able to compile mfc , or mfc app still may be build only with cl ?
Sure. I usually go by the rule that the variable shouldn't shadow. But having two separate scopes using the same name is fine.
Yeah, that's a sensible policy. If only everyone agreed with it...
/u/enable_if , your insight would be great here.
It means if you put a variable inside of it, it will disappear at the `}`. VERY useful. Esp in larger functions.
"What's your Personal Top 10 List?" &amp;#x200B; "You're Personal Top 10 List is WRONG!"
Every time I see 1), I'm always surprised that it has a name. But apparently too many people don't understand basic problem identification/solving technique that it has to be given a name.
Your examples in Rust are not even simmilar to the c++ examples in the original post
What exactly would happen? Would applications written against older API versions simply crash with the exception if an exception was thrown inside the once-noexcept function? That would the same behavior as throwing in a noexcept function normally. Or, would the ABI compatibility be broken? Or is it UB?
The reason 1) needs to exist is because people frequently fall into the trap of treating the symptoms without looking for the underlying cause.
TLDR; You can thank Microsoft. While I certainly agree that Windows is *disadvantaged* here in terms of performance, I **disagree** that it is "sabotage". For better or worse, Posix and Windows have wildly different (hereditary) behaviors when it comes to text/string processing. * Posix tried to be encoding-*agnostic* ("make it the application's problem!"). That works fine as long as everything remains 8-bit pure (hence UTF-8 is an *outstanding* successor to ASCII, especially for Posix). As soon as your data is UTF-16, or anything else not 8-bit pure, and you are stuck with non-portable, platform-specific extensions (or convert it yourself). That means that Posix file paths *tend to* be UTF-8 (even if only because most of them are actually pure ASCII), but that's in no way certain or guaranteed. * Windows has tried to be encoding-*explicit* since the beginning -- either you're dealing with code pages, or with wide strings. Even the UTF-8 "code page" wasn't *real* (ie couldn't be used except in conversion routines) until quite recently [(ref)](https://twitter.com/matarillo/status/931050853347110912). Now *if* you are working with a `std::string`, and it happens to contain only the pure-ASCII subset of UTF-8, *then* you can use it as-is without doing anything. But if not, then you would have to *either* be running on a brand-new OS (which the programmer cannot know in advance) *or* explicitly convert the string to UTF-16 (which is what MS' internal Unicode APIs actually require). So the cost on Windows comes down its encoding explicitness plus UTF-8 being an after-thought on that platform. C++ is merely having to play by Microsoft's rules.
The C++ standards committee has been pushing us all towards greater data/type safety (which is a good thing), but hasn't always done the most consistent job of it. Hence I completely agree that the return type *change* for `path::u8string()` was truly dumb. (The point in my other reply was that using UTF-8 is what actually hurts you on Windows, not `path::u8string()` itself.)
I'll defer to [this](https://old.reddit.com/r/cpp/comments/aha5nn/is_c_fast/eecrw3p/) conversation (and the Github issue it links to). I'm really not the one to ask about SwissTable performance.
&gt;But the API and the implementation have to be in sync right? They are supposed to mirror one another. If you write the API first and then find the implementation doesn't match what you wrote, you've got to figure out how to align them. By changing the implementation to conform to the API, not by changing the API to conform to the implementation. If APIs followed the implementation there would be no to specify an API, the compiler could just examine the implementation much better than a human ever could to produce the API on our behalf. The benefit of an API is precisely to avoid needing to reason about a modular piece of software by examining its internal details. If ```noexcept``` was just about a careful consideration of every operation and function call, it would be a waste to have a human do that analysis and we wouldn't need that specifier, the compiler would simply infer that for us. Instead, ```noexcept``` is a statement about how a function is to be used, it's not a statement about how a function happens to currently be implemented. &gt;But for a less-experience developer (the kind who might read a listicle) that might not yet understand this nuance, and so might have to consider things more carefully. Do you go through these nuances when implementing destructors? Do you sit there and carefully consider all of the operations and all potential future implementations to decide whether a destructor will throw an exception? Or do you instead follow the rule that a destructor shall not throw an exception because as a matter of principle and good API design, a destructor that throws is incredibly painful to use properly and so you will do everything you can to ensure that your implementation respects that principle? Do you use principles to guide your implementation, or do you use your implementation to guide your principles? Well the same thing goes for move constructors. It's not the implementation that determines whether a move constructor should throw, it's a matter of principle and simply good API design that a move constructor shall not throw so that users of that class can leverage the benefits of a safe and efficient API. Now, if after all this you disagree, so be it... it's actually fine to disagree about things in C++, afterall it's a really complicated language and things like ```noexcept``` are relatively new. My real problem with your original post was just how dismissive and authoritative your post came across, like it's just a settled matter that move constructors may or may not be ```noexcept``` after careful deliberation on the issue and spending time thinking about all possible implementations and operations instead of taking it as a matter of principle that move constructors should not throw an exception by design in much the same way that most C++ programmers accept that destructors must not through as a matter of principle (nothing in the standard says destructors may not throw, it's a matter of principle). It's just not a good way to open a conversation on a subject by saying it's "deeply misguided" and you're shaking your damn head in disappointment because someone has a different opinion from yours, one which I and many other C++ developers agree results in faster and safer software and which is included as part of the C++ Core Guidelines: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c66-make-move-operations-noexcept http://blogs.microsoft.co.il/sasha/2014/08/08/make-move-constructors-no-throw/
I get downvoted for some reason. Maybe I just don't get it. The best I could do is leave the subreddit, I guess. Some words before I did &gt; don't believe I ever said there was anything "wrong with it" I never said there is something wrong with anything. &gt; Honestly, I fear you are operating under the mistaken impression that I have something against Rust I never said that as well &gt; P.S. mem::free doesn't exist, so your code doesn't compile. Your statement that "there is no runtime check of any way here" is both grammatically incorrect and completely wrong according to the official docs. Sorry, english is not my primary language so I'm doing my best to make it comfortable to read what I write. &gt; You do not "literally do the same with C++" because the compiler always calls the destructor for objects at the ends of their lifetimes (although a type like std::optional can effectively make it conditional, but that's behavior you opt into). So let us dispense with the pedantry. You either has two drops in any language, one earlier after check and another at the end of the scope or you just don't drop value after check and unify both execution flows and call destructor once. The latter one doesn't need any explicit drops so the whole check is redundant. But if you actually want to have a conditional drop then you have to option but to check it at the end of the function and free the memory if it wasn't freed before. It's completely language-agnostic, it's just what math says about it.
But what if there's an underlying meta-cause? :-)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bhegpv/how_can_you_have_curely_brackets_without_a/elsfeeh/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; I'm not trying to comment on how often it happens. Regardless of how often it happens it's not good c++ and I don't think we can talk about the safety of the language unless we assume ppl are going to actually try to use the language correctly. I think we should consider the real word cases. It it's happening often then it's reality. When we talk about language safety we are talking about the mean case. And the mean case is what I described above (it's my personal opinion though). &gt; That's the thing, I really insist that proper c++ usage will prevent all of those almost entirely. Of course no system is 100% secure and every program will have bugs, but those memory type errors are almost non existent if you code correctly and use tooling. The problem is that proper C++ usage is impossible. It's not C++ fault, it's human nature. You know airport dispatcher don't work more than several hours in a row because they can't be focused more. You can't be focused all the time so it's only the matter of time again when you fail. You can't just "write code better", you already do your best. And you probably introduce some memory safety bugs as well. If so then "proper C++" doesn't help or you don't write proper C++. I actually thing the latter, or more specifically "there is no propery C++ anyone written ever". Because it's just impossible for reasons above. It's applied to any languages as well, rust/haskell/idris, doesn't matter. The only question is how large is the mistake field and how much language helps you. The C++ balance doesn't fits with me well at all. &gt; Edit: deadass double free and out of bounds are a joke at this point. We've had destructors and raii for like 20 years there's almost no reason to have a double free. Out of bounds? Ever heard of vector::at? It's not hard to use and boom somehow the out of bounds errors stop happening. I saw people caching `iterator::end()` before calling `remove` on the vector so shit happens, with best of us. If I recall Mozilla report correctly they actually had out of bounds and/or double free. Heartbleed abused out of bounds which doesn't exist in C++ codebase for last 20 years, according to your writings. How could that be possible? Or is openssl just written badly?
Recently ran into an issue at work due to `using namespace std`. We're currently upgrading compilers, and we now had `std::tuple` conflicting with `boost:: python::tuple` because of a `using namespace boost::python` declaration somewhere else in the TU. The solution was, of course, to qualify the tuple, but the whole thing could have been avoided entirely if we didn't have a `using namespace std` floating around in some header. Unfortunately in our case, too many headers to make fixing the situation worth the effort.
Okay, let's check the second example (because why not?): ```cpp std::function&lt;int(void)&gt; f(std::shared_ptr&lt;int&gt; x) { return [&amp;]() { return *x; }; } int main() { std::function&lt;int(void)&gt; y(nullptr); { std::shared_ptr&lt;int&gt; x(std::make_shared&lt;int&gt;(4)); y = f(x); } std::cout &lt;&lt; y() &lt;&lt; std::endl; } ``` vs ``` fn f&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Fn() -&gt; i32 + 'a { move || *x } fn main() { let y; { let x = 5; y = f(&amp;x); println!("{}", y()); } println!("{}", y()); } ``` I literally wrote the same thing in Rust. What kind of "non-similarity" do you see here?
You replied to a reply about using plain structs, but I assume you meant it as a comment to a post. I think you completely misunderstood logic and architecture of my solution. Let me cover and respond to major points of your comment. &gt; Transmitting metadata, also wrong. Agree completely and utterly. Most protocols used in embedded system don't. The corner stone of my solution is to support such already defined third party protocols. It does NOT invent or uses its own protocol and does NOT attempt to send any metadata over. That's the **main point**, because of metadata not being sent over, it **should** find its way into the generated code, otherwise it leads to too much boilerplate integration code, which in turn must be manually changed every time you decide to update your metadata in the protocol definition. Very error prone. &gt; Extremely wrong approach to things. For example, unit conversion does not belong in a library like this. Agree (to some extent). There are many sophisticated unit conversion libraries. However, used units is part of protocol definition (usually not transferred over wire) metadata, which is expected to be known to (and used by) the integrating developer. It is better to have built-in limited required units retrieval facility than not to have it at all and use boilerplate code to do the manual units conversions. &gt; Protocol version checking should happen only at the handshake phase. As was already mentioned above, the corner stone of my solution is supporting already defined third party protocols. Many don't use any versioning at all, some transmit version with every message in the transport framing, some do it as you sad in the handshake phase. The primary objective of my solution is to support all such cases. &gt; Further encoding/decoding on messages shall happen with a switch statement, not virtual functions. Using virtual functions requires a switch on the message id anyway, in order to instantiate the appropriate class. That's another reason why I created my solution. Some available code generators introduce polymorphic behavior (virtual function) for every operation on the message object, which creates problems for various embedded systems (especially bare-metal ones). Other code generators produce only plain structs without any virtual function at all. It leads to writing a significant amount of boilerplate code (such as switch statements you mentioned), which needs to be manually updated every time you introduce a new message and/or new field. My solution allows **compile-time** configuration of your polymorphic interfaces. If you don't need any, then don't define one and use every message class as plain struct (no v-table is created). My solution also contains a [library](https://github.com/arobenko/comms_champion#comms-library) with multiple facilities to dispatch your message into appropriate handler function (with O(1) or O(log(n)) runtime complexity) without having to write a single switch statement. &gt; Memory allocation should not be done at all. Big enough buffers shall be used for in-place manipulation of messages, both at sending and receiving end points. My solution is flexible enough to allow not using dynamic memory allocation at all automatically calculating (at compile time) and creating a buffer of required size to allow in-place creation of any used message. &gt; A class based design for messages is wrong because it leads to all the bad decisions mentioned above. Let's agree to disagree. Struct based design leads to other bad decisions and having significant amount of boilerplate integration code. &gt; The best approach is to encode the messages in using/XML and then have a tool create all the boilerplate code, and integrate the tool into the workflow. I don't want to use an external tool, but the language itself lacks the facilities needed for this so an external tool is necessary. As was mentioned in the post, my solution originated in a single library that allows having a **single message class definition** (single source of truth) for every possible application, which in turn configures at **compile time** its required polymorphic interfaces and/or custom data structures to hold field's values. Normal systems (with proper OS underneath) may use default configuration and multiple virtual functions with functionality not always being used compiled in, while bare-metal ones may completely exclude dynamic memory allocation, limit usage of virtual functions, use its own custom types to store problematic data, such as strings or lists, etc... I made a C++11 compiler itself to be my code generation tool. With time the library got quite complex and started requiring from a developer some knowledge of its internals and a particular way to be used in order to create completely generic protocol definition. That's why I also created a separate code generator, that produced a proper highly compile-time customizable code. Hope it clarifies some things. Cheers
Well, it's written by actual engineers, not marking people spouting out buzzwords and corporate platitudes. It's fine. And useful.
Partially, not completely. It's difficult to say, there is no much information on the website and no proper way to try it out without registration. Based on the example from the website below are features that I'm missing: - I want an ability to exclude usage of streams in my serialization / desiralization. The example shows the following functions I do **NOT** want to have. ``` /* IO-Operations */ void read(std::istream &amp;stream); void write(std::ostream &amp;stream); ``` - I want an ability to introduce polymorphic behavior (virtual functions) when I need it and for selected operations I need to be able to write a common code for all the message types. - I want an ability to use my own data types for fields like lists and/or strings - I want an ability to define transport framing for all the messages, even more than one (different I/O interface may require different framing). - I want a built-in (or generated) ability to efficiently parse an input data, create appropriate message object and dispatch it to my appropriate handling function without a need to manually write switch statements and other boilerplate code. - I want an ability to specify meta-data that is not transferred on the wire, but still available to the integration developer to act upon (preferable at compile time), such as units used (conversion if possible), values with special meaning, ranges of valid values, what to do on invalid value, etc... - I want an ability to have multiple forms of the same message (message object having the same ID, but different contents). Not sure whether it is supported right now or not.
&gt;&gt; Uniform initialization syntax is one of my favourite features of Modern C++. &gt; &gt; It was also my favourite. That is, before I learned it. Kind of in the same boat. Sometimes it seems like the best thing ever: return {}; (Not a silly example. I really like being able to do that.) Other times it makes me go read header files that I otherwise wouldn't have to, because a piece of code uses brace initialization on the grounds that it's "better", not because it needed to.
I know, I just find it interesting that lots of people don't have that mindset drummed into them from childhood.
Background: new codebase. no crazy requirements: not doing anything really specialized like embedded, or super nanosecond performance. Time Spent At the Grindstone: ~3 years Team Size: idk who counts as "team" but ~5 ofc this is just a personal list, but i hope its really not that surprising. 1. prefer pure functions. keep your network,file, db, etc. code away from your logic. 2. Always test your code. strive to write great tests. *ideally* everything that your application does should be checked with some automated test. 3. Continuous integration, also some nightly builds. Include static and dynamic analysis. ideally at least clang-tidy and address + ub sanitizer. I think i'll sneak containerization in here too. 4. RAII 100% no excuses. (i havent found one yet but obv we're new). Try to write code that is memory safe. basically avoiding things that arent bounds checked, just general best practices like in the core guidelines. 5. when designing types, prefer regular types (over class hierarchies). Try to make your types clearly resemble the fundamental components of the real thing the type represents. I just think of that as something to always get better at, finding the best design can be challenging. 6. Strive to make your code as expressive and clear as possible. focus on using language features/types expressively. avoid adjacent arguments of the same type. dont do stuff like `some_function(int, int, int)` also use concrete types with units. like using `std::chrono::millisecond` instead of `int`. I like what Kate Gregory says in one of her talks, something like imagine your kid having to maintain the code youre writing today. 7. when designing a solution for a problem, prefer in order: std library code &gt; existing 3rd party libraries &gt; a hand made solution. 8. I will steal your #10 in my own words. have some quality standards and stick to them. dont get tempted by the quick fix. think as much as possible about how design choices will play out long term. Although balance that with the fact that you have to meet deadlines and make money at the end of the day. 9. well not necessarily code, but try to encourage a healthy and productive culture with your team. I actually think its pretty important that people feel safe sharing ideas and collaborating. Encourage ppl to be passionate about their work and do a good job, but dont be a psycho and ask people to work overtime every other week. Make C++ fun for your team. 10. Similar to your #5: always go for the simpler solution (obv this takes practice) with everything from functions to applications. as a guideline, with something small like functions simpler may mean less control statements, for an application simpler can mean high level components are well separated and the behavior/information flow is easy to follow. some thoughts on your top 10: i didnt really find it controversial. except for maybe 2. im actually kindof surprised where youre seeing soo much "fragmentation". i mean sure ppl think differently about some things but when we're talking about basic best practices i feel like there is at least somewhat of a consensus.
First few are good, but then it gets questionable pretty quick.
I suggest: 0. The person writing this list may be smack dab in the middle of the Dunning-Kruger effect.
But it's really not. Beyond the first couple, a lot of it is quite nuanced and anything that says "always do X" or "never do Y" is always wrong - and by telling people there is a rule, you may be doing more harm than good. Much of it is contradicted by people whose job it is is to focus on the language.
&gt; Are you reading it on a phone? Anyone using old Reddit sees a mess at present. 4-space prefix works universally.
Beats for whom? Yes, beats for vast majority of developers and application being developed. However, there is a niche called "Embedded C++ development", which in many cases cannot use available solutions "as-is" or at least finds them "not good enough". That's where my solution comes in to satisfy needs of certain group of developers and applications. I by no means intend to create a solution suitable for every one.
&gt; some people think that #7 and all that 'agile' type stuff is a cancer on the body of software. what? really? people think that CI is cancer? that sounds like some flat earth type shit. also how does CI == "agile type stuff"?
&gt; And the mean case is what I described above (it's my personal opinion though). if you want to talk about the mean case, you may be correct. I just see that as more of an education issue than a language issue. im not even talking about coding perfectly or even like an expert. just following some simple best practices. But i see your point, you want that kind of protection in the language, and you dont have that in c++. &gt;I saw people caching iterator::end() before calling remove on the vector so shit happens i agree people make mistakes. in this category i also put the original example with string_view. remember address sanitizer exists, also remember we already said that bugs inevitably happen in any language. &gt; If I recall Mozilla report correctly they actually had out of bounds and/or double free. I dont know much about mozilla's codebase, but they've been around since the early 2000s right? I cant say much without more details of the bug, but keep in mind i am talking about *modern* c++ &gt; Heartbleed abused out of bounds which doesn't exist in C++ codebase for last 20 years, according to your writings. How could that be possible? Or is openssl just written badly? openssl [writen in C](https://en.wikipedia.org/wiki/OpenSSL) afaik. so if we're talking in terms of a c++ program then yea, i guess so.
&gt; That's not a difference between structs and classes. That's when I stopped reading.
Does that work with clang-cl?
Im a pretty big fan of clang-tidy. It‚Äôs helped me learn some neat things I didn‚Äôt know about in modern C++ (range-for loops).
The authors of both implementations compare and contrast in the thread [here](https://groups.google.com/forum/#!topic/hashtable-benchmarks/-nT-3fESXq8).
Actually Azure account is not worse than Dreamspark, actually it's a lot better, they only need to to update this platform faster
using namespace boost::python was in the header!!! Ok I see the problem. Boost is a pretty well known library too so... I may have added that depending on how many files needed it (if very few use the header I'd use using)
As an obviously example of how different people can be, I would put #7 in totally the opposite order, and actually do in practice.
This is actually the bigger problem for me; returning references slightly leaks the abstraction and puts limits on the implementation.
&gt; I would put #7 in totally the opposite order, and actually do in practice. i've noticed actually :p imo this is a product of drastically different scenarios. had i been coding c++ since before there even was an STL I would probably feel differently. but now with how mature the c++ library ecosystem is I dont think non experts need to be hand rolling much by now. also, even if you dont do that guideline yourself, im sure you agree its the right call for newer developers.
"*Make* move constructors noexcept" is a good general suggestion. "*Mark* move constructors noexcept" is a bad general suggestion, because it doesn't make it clear to a novice developer that they are also supposed to take care to not throw exceptions.
Nothing teaches you how a car works better than building a working car. They don't have to take it as far as I have of course. But it's very, very instructive. I would say though that it had nothing to do with there not being a mature library ecosystem. It was because there was not, and still is not to this day, anything like my stuff in the standard C++ world, which is a comprehensive, tightly integrated system from the ground up. The C++ world is stuck in pieces and parts mode, while other languages provide pretty broad standard libraries. Even something like QT is built on top of the standard library stuff and so cannot be a fully integrated system in the same sense. That's more what I've been interested in creating.
Well, a lot of agile people make that continuous integration stuff a major part of their mantra, AFAIK, and so probably a lot of people probably associate the two to one degree or another. I'm sure some people would prefer a more 'engineered' approach perhaps, and might see that as basically throwing code at tests until the tests stop failing, at least as it ends up in real world practice in some cases.
One large problem is the even with non "C written in C++" tutorials most initially start of learning about objects and invariants as the key abstraction and understanding with analogies from real life but eventually students reach a point where they understand enough to think of an object in terms of its memory layout, see the power of reinterpret\_cast and raw memory allocation/management. Suddenly they start to see objects as simply raw memory and then the quickly delve into the realm of UB as they still don't understand enough about how the compiler compiles and optimises C++ in order to avoid UB. There's nothing worse than seeing people treat std::vector as an array of raw bytes.
Background: VM farm administration/3rd party integration and high-speed analysis/simulation. Time: ~9 years 1. Test everything, often. Unit tests aren't there just to get code coverage up to threshold so the CTO will get off your ass, they're there to keep you honest and help you figure out how you shot yourself in the foot. 2. Integration should be a part of your design. It doesn't matter how amazing your software is if it's impossible to deploy. 3. Compartmentalize what you do. It's easy to get tunnel-visioned on your current tasking and create a solution so feature-creep'd it is functionally unusable outside of your immediate task parameters. 4. Make your calls intuitive. If another dev can't get a rough approximation of what your function/class/etc. does just from looking at the declaration/name/call signature then neither will you when you need to maintain it in six months. 5. Paper trails are your friend. Some of my biggest clusterfucks (both in terms of product and performance review) are because I agreed to ticketless tasking. 6. It's rarely wrong to take a breather and reassess what you're doing. If your mental model is trash, then your code will be too. 7. Don't use a hammer to turn a screw.
Am I right in thinking that your second option is emulating signals and slots?
Some libc functions like memcpy also exists as intrinsics within the compiler and the compiler will intercept these calls and replace them with a builtin.
I'm not to sure on the details but for STL containers that store memory contiguously (e.g. std::vector) the iterators returned aren't event raw pointers they're just simple wrappers around raw pointers in order to simplify template argument deduction. I vaguely remember for writing my own standards complaint std::vector for fun and having an ambiguous call these two constructors: vector&lt;int&gt;::vector(size\_t size, const T&amp; val); template &lt;typename InputIt&gt; vector&lt;int&gt;::vector(InputIt first, InputIt last); And fixed this by creating a similar wrapper and avoided having to do some SFINAE trickery.
KDE libraries are not cross platform. Qt is. You can use Qt Creator- works great for cross platform.
Can I use WORA?
Yeah, we actually use MinGW on Linux for our Windows target at work. It's been doing great for 5 years now, so I have no problem recommending it. It's definitely tricky to get your build environment set up nicely, though.
No. C++ is compiled. You need to compile it for each platform.
Thanks for your help üòä
I know so I ask about is there any way to use WORA in C++?
What do you think WORA is?
That's a cool idea. I take it, though, that it doesn't handle MSVC? Or do I misunderstand?
Regarding the code, I think you have the design backwards. You use an object to manage calculation of the weights and roots, and a free function to implement the integration. In doing so, your integration function is computing the root/weight list on each call. As you pointed out, the weights and roots are general, so a better design would be to have the integration function be a member of an integrator object, and that object would compute the weights/roots once at construction and then reuse them whenever an integration of the desired order is needed. The calculation of the weights/roots is conceptually a ‚Äúpure‚Äù function: given the order of the quadrature, compute the roots and weights. This could/should be a free function that just returns a vector of root/weight pairs (or similar). This function would then be called in the constructor of the integrator. The newton iteration and the evaluation of the Legendre polynomials could also just as easily be free functions; neither has any real state that needs to be preserved between calls. I‚Äôm enjoying your posts! Looking forward to the next one.
If you take special care to avoid tying your code to platform-specific functionality and non-portable libraries, you can hope for WOCA (C being "compile").
Kf5 is cross-platform, [https://api.kde.org/frameworks/index.html](https://api.kde.org/frameworks/index.html) it has exception but most of are.
I think they're using using the compiler in MinGW to cross-compile Windows binaries from a Linux host.
#1: while I generally agree on this advice, nested namespaces should be decided VERY carefully. Sure, it make sense to group internal things from external ones, but I would be careful to group everything, when it seems to make sense. As a consumer Boost.Asio is really the bad example for me. I'm constantly searching, in which sub-namespace this type or that enum is defined and than I have very long names to type, which clutter my source code.
Sure you can, you should use MinGW for Windows build and Darwin for Mac, also you need Qt everywhere build for ARM if you want to target Android. But the most valuable if you want to target desktop OS and mobile one, at once, is QML (not plain QWidgets since they does not have mobile Look'N'Feel) also note Kirigami is best fit.
Thanks, these are good points. I wasn't paying really much attention into good code quality and more into the actual algorithm. I will focus more on code quality next time.
I want to make softwares for desktop only.
So you can develop it on Linux, when it's ready you can cross-compile it.
How?
Yep, this. MSVC isn't involved. By design. :)
https://uncannier.com/cross-compile-qt-mingw-windows-applications-on-a-linux-host/ It's for QtCreator but can be adopted to any IDE, just you should make same build steps.
Not, really. Almost every article about their product has wrote same way. It is: \- look at my code, it has bug! \- you do not see it? how dare you?! \- we lie you coz function XYZ is macro/do\_something\_else\_or\_do\_nothing\_or(...) \- look at our program! it is amazing! buy it and make your life of programmer better! &amp;#x200B; Everyone forget one simple thing. That's code they showing is big piece of shit and should not find on production. Every guy who wrote something shit should be fired instantly after commit. I know everyone can make mistakes, but if that shit is sooo common... i do not want to live on this planet anymore
Thanks for this good guide.
Background: Embedded motion control. Maintaining software written long ago (usually with poor practices) and adding features to that software, sometimes radically new features where the vast majority of code is brand new. Time Spent At the Grindstone: 20 years Team Size: 2 to 25 (varied by project and economic outlook) 1. Testing in an environment that requires external hardware creates serious lag in obtaining test feedback. (i.e. not all tests can be run quickly.) Do what you must to minimize the amount of time it takes to get feedback, including multi-stage automated testing. (ex: run tests that directly relate to code you changed first, run fast tests second, etc..., run the really slow tests last) 2. Use hardware simulation in tests where you can. Being able to simulate hardware allows for faster unit tests as well as being able to debug locally without having to use printf-style debugging. 3. Don't rely on hardware simulation to tell you everything is OK. Often you'll find that the hardware you must deal with is buggy, doesn't follow spec, has weird timing issues, or a myriad of other problems. Simulation won't tell you these things and tests, even if slow, must include real hardware. 4. Calling operator new explicitly is a code smell unless you're writing a container or writing Qt-related code. 5. Use expressive types or at least expressive typedefs and names. std::map&lt;int, std::vector&lt;std::string&gt;&gt; is not nearly as clear as std::map&lt;MotorIndex, MotorSettings&gt;. 6. For anything that acquires a resource, use RAII. It's a must. I do not want to see another manual Release() call. 7. With very few exceptions, turn on all warnings and treat all warnings as errors. (There will inevitably be some you want to disable, but start on playing-it-safe side of things.) 8. OOP has its place, but it can be abused too. Use the correct paradigm for your problem domain. 9. Stay up-to-date with what's going on in the programming world. It will eventually leak into your niche domain. It's better to be ahead of the curve, possibly helping drive innovation at your company (or wider community) than being stuck in the past when new idioms or technology arrives. 10. Make you you take time off to enjoy time in the real world. We all need it!
&gt; I dont know much about mozilla's codebase, but they've been around since the early 2000s right? I cant say much without more details of the bug, but keep in mind i am talking about modern c++ Could you elaborate then and show some example of modern C++ project which doesn't have memory bugs, please? &gt; openssl writen in C afaik. so if we're talking in terms of a c++ program then yea, i guess so. Okay, I buy it ;)
I think it's messy. It flags errors [like a missing brace (1) or parenthesis]. And then there are weird things, like "remove `const` on function parameter declarations", for better readability! How on earth is that gonna help with readability [or my understanding of what that function does/can do].
This was also posted to the CDDA subreddit: https://www.reddit.com/r/cataclysmdda/comments/bh7kpn/cataclysm_dark_days_ahead_source_code_analysis/ ...where they have some comments from the CDDA developers. Opinions of PVS Studio notwithstanding, Cataclysm: Dark Days Ahead is fantastic and you should all play it. Easily the best free open-source ASCII zombie apocalypse survival RPG ever made!
I assumed that was the case, just making sure (I work with people who only want MSVC builds on Windows, so I wanted to make sure you didn't have some magical way of testing MSVC on Linux.)
For learning purpose, implementing your own solution is fine, but this is not sustainable in the long run in a real-world situation. Using an already existing solution, assuming it is a sound implementation, as several benefits, for example less maintenance on your side, and people coming in your team don't need to learn yet another API. Implementing a binary tree is not trivial, why do it all over a again? To deal with low-level corner cases while I have to implement more high-level features? Hugh... Could you tell me where you found out that Qt is built on top of the STLM I highly doubt that; however it does provide compatibility with STL idioms, such as iterators, for example, but if I recall correctly it implements its own containers, algorithms, et al.
Background: Petroleum software, Medical software, High performance scientific modeling platforms, engineering software, real-time 3D rendering, large distributed display systems. Time spent: 20 years Team sizes: up to 20 people, roles incl Dev, Lead, Architect and Manager &amp;#x200B; 1. Unit test everything. Build integration and system tests. 2. Automate as much as possible. This is builds, deployments, unit testing, code style checking, issue management, source code management, linking issue and source code management with hooks. 3. Focus on shipping code that works, instead of not shipping perfect code. Your success is measured in the amount of functional code you ship, not how perfect you write code. 4. The code should clearly indicate how it does something, the comments should clearly indicate what and why it does something. Keep your code SIMPLE, imagine someone half as good as you having to read and work on it. If they wouldn't understand it, your code is probably not maintainable by the average developer and this IS important. 5. Learn debugging and profiling tools, being able to run code through a profiler or debbugger can be the difference between being a good developer and a great developer. 6. Understand the business you work in. Your code is usually nowhere near as important as you think it is. You being able to ship code is because there is an entire company doing non development work to make and sell a product. 7. Don't try to make everything generic or reusable. If you have to write it twice, comment it and be happy. If you need to use it more than twice, look at refactoring to make it more reusable. 8. There is a difference between a programmer, developer and computer scientist. Learn this and understand how a productive team usually requires all three. No single one is better or more important than the other 9. Newer language features maybe shiny and cool, but the language has existed and done everything for the past 30+ years. New features don't always make things better (or faster) 10. Learn memory management, shared\_ptrs and scoped\_ptrs are not universal. Sometimes using a raw pointer is the best approach &amp;#x200B; Yes. I know most of these aren't specific to C++, that is on purpose. The language you choose to develop in is really less than 10% of your ability to deliver high quality software on time/budget. The best code you write is code that nobody ever reads, because it's so simple it works without fail and never has a bug.
Demand for fast std :: partial\_stable\_sort felt high.
It is UB. The compiler could have made optimizations based on the assumption that the function never throws. It's also possible to test if a function has been marked noexcept (std::vector does this when deciding whether it should move or copy on reallocation) so even without any optimizations the code could still end up doing the wrong thing. If you make sure to recompile everything it could still break code because people might have used the function with the assumption that it will never throw. If it suddenly starts throwing it might lead to the exception not being handled correctly, and/or resources are leaked because the function was used in exception unsafe code (e.g. while using some C library without RAII).
I actually installed the 2019 Preview 2 to test this issue again. First of all - it actually got much better. That being said - instead of taking forever it now still takes \~10 mins. From my point of view there are 2 main problems: 1. If the folder where the root CMakeLists.txt is big enough the indexing step can take a very long time and only when the indexing was at 25% Visual Studio started the configure step for the root CMakeLists.txt 2. Why does it also run the configure step for CMakeLists.txt that it finds under the root folder, but that are completely unrelated to the root CMakeLists.txt? For example we have some third party libraries and development tools that we rarely have to compile and they are not related/referenced in the main project. Visual Studio seems to run the configure step for those as well, which doesn't make sense to me and everything take even longer.
Hi, EDG, our IntelliSense compiler is fully C99 compliant, when used in the Clang scenarios, it is set in Clang mode and it should support all C99 features. Since we are using our STL library, you might only be missing some library bits.
thank you for the feedback, we are using Clang 7 and planning on releasing 8 soon, once we do we will probably add that to the setup as a hint
we've tested and dogfood the Clang experience on LLVM, and made sure we provide a very good experience for that in Visual Studio, if you see otherwise please let us know, it might be a bug
really great to hear, if you see something lacking feature wise, please let us know
we haven't tried with Qt, but that is a great suggestion, thank you
thank you for the feedback, there was no problem with 1.9, we will try to update it in the next release
Hi, we have something akin to compile_commands, called CppProperties.json https://devblogs.microsoft.com/cppblog/open-any-folder-with-c-sources-in-visual-studio-2017-rc/, we have plans to support compile_commands directly in a future release
thank you very much for this feedback, we will investigate
thank you for the kind words
&gt; Large amounts of inline code is bad in large scale software, due to rebuild time. So minimize templates and do a lot of work to keep as much non-trivial code out of line as possible. This seems like an issue with your setup. If you're truly getting into the large build time range you should look at tools like incredibuild to conquer that, rather than increasing the menial coding you're doing. Unless you're really worried about ~10 minute full rebuild times (obviously you're doing incremental builds the majority of the time, which should be considerably quicker).
&gt; I want an ability to have multiple forms of the same message (message object having the same ID, but different contents). Not sure whether it is supported right now or not. This requirement is normally met by using inheritance. The common contents would be in a base class, and the incompatible variants would each be a subclass.
Background: academia, game-dev, computational geometry. Time: 17 years. Team-size: from 1 to 22. 1. Everything is a resource. Code brevity, algorithm performance, library portability, time you spend, experience you gain, money you earn - everything. 2. Making software is about balancing these resources. 3. Therefore, no rule, technique or methodology should be taken as the absolute truth. If you have to go against the rule to do the thing "improperly", do it and be ashamed at your own free time. 4. Abstraction is a misnomer. We're not algebraists, we don't have that. What we have instead is "automation". 5. There were no revolutionary leaps in computer languages design since 1978. 6. Your physical and psychical health impacts your productivity far greater than any productivity enhanced tool, technique or methodology. 7. When using third party solution, you gain expertise in using this specific third party, when solving the problem yourself, you gain expertise in solving problems. 8. You can't gain all the expertise in the world, use the third party solution when it's something outside of your core expertise. Which is supposed to be often. 9. Making someone else happy with your work is more important than having TCO in your language of choice. 10. Having TCO in your language of choice is still rather important.
To make it actually 1:1 mapping we need to make Rust code bit slower and use `Box&lt;dyn Fn() -&gt; i32 + 'a&gt;`
We can make `x` and `fn` both boxed, but it won't change a bit.
You do make some good points, however I have some nits to pick. &gt; Endianess should be agreed upon before compilation and struct members shall use endianess-aware types: there is no need for a second pass or copy to buffer if data are already prepared in the appropriate endianess. If possible, yes it is preferable to have all parties agree on endianness. However, it is faster to use the native endianness for recording. Between taking longer to encode, and longer to decode, I choose taking longer to decode. Sometimes you might want the opposite decision anyway, so it makes sense for a library to give you options. &gt;Further encoding/decoding on messages shall happen with a switch statement, not virtual functions. Using virtual functions requires a switch on the message id anyway, in order to instantiate the appropriate class. There are pros/cons to using virtual functions. Having to use a factory to instantiate a class-based message is not a big drawback. One advantage of using virtual functions is that you don't have to encode/decode the whole message if you don't want to (and there are often cases where you don't want to). The flip side of that is you get into decoding on each function call (more computation) or caching some results (possibly more memory usage and complications). &gt;Memory allocation should not be done at all. Big enough buffers shall be used for in-place manipulation of messages, both at sending and receiving end points. This is too prescriptive especially if you don't need strict requirements on message size. I just envision gross overkill, or max buffer thresholds that can keep breaking things because someone added a message that's too big for the current scheme. I suppose you could make it configurable, but it's the kind of configuration option that nobody wants to deal with if they don't need strict memory policies.
I didn't say it will make program incorrect. Just closer to 1:1 match. Ah. And `std::shared_ptr&lt;int&gt;` in Rust would look more like `Rc&lt;UnsafeCell&lt;i32&gt;&gt;` ;)
I have rewriten the idea "I want to return a closure which captures a reference to a value", I didn't mean to reproduce the whole C++ flow. I see what you mean but I wanted to write a real example how you write it. `Rc&lt;UnsafeCell&lt;i32&gt;&gt;` is a complete overkill here. And it still won't change anything, so I didn't write it for simplicity. At the end we could just reexport C++ functions and call them to have the exactly same behavior. But what's the value? :)
I just joking with you cuz you told it's 1:1 mapping ;)
I know, that's what smiley at the end was for :)
&gt; We all know the hoary old interview question: ‚ÄúWhat‚Äôs the difference between structs and classes in C++‚Äù. And we all regurgitate the same answer: I don't. I would first seek clarification on the premise implied, and then see if the premise can use some debunking. &gt; For Modern C++ there is also a third difference: the way brace initialization is handled. MSVC's `std::array` (the version installed on my computer) is declared with class-key `class`. Its instances are aggregates. Is `std::array` a template of "struct" or "class"? What does "struct" mean to you anyway?
*The C++ Programming Language 4th Edition* written by *Bjarne Strostrup* focuses only the language and is considered an intermediate level book.
Yes, that's how I understand it. Looking in GCC's name mangling, it seems that a global counter is used in the mangling of such lambda expressions, so some definitions may happen to be merged as expected, and some may be merged in an unexpected way.
I really don't disagree! Move operators *should* be noexcept, and if your implementation makes that hard to achieve that's a really bad code smell. On the other hand, when I see code that marks functions that obviously can throw as `noexcept`, that's also a bad code smell (IMHO, YMMV). I don't mean to be dismissive about it, in fact my complaint about the listicle was that they were very dismissive of the important "check your implementation for possible exception throwing" part to ensure that your implementation is holding up it's half of the noexcept bargain. After all, APIs are a contract, and the implementation is on the hook to fulfill it. Also, you're holding up a really high standard of dialogue for a small snippet of internet snark.
Agree with the OP completely. My additions (in no particular order/position on the list): * Make very good friends with your QA counterparts. Spend time to teach them how to read/build the code. Make sure they feel comfortable contradicting you (with evidence) even after you dismiss them. * Engage in the QA process. Understand their test cycles, suites, whatever. When they are defining the testing methodology for a new thing, jump in and suggest other ways. Be always able to replicate the QA environment at your desk. Many new developers gravely underestimate how many times they will fuck up, code review will not catch it, our CI will not catch it and then QA will save their ass from embarrassment.
I'm a bit worried no one so far mentioned documentation. I worked in some validation projects and it was just impossible to test something without relevant information.
Not sure who downvoted this, but I've definitely had bugs that were First level cause: developer wrote a memory leak by cycle Contributing cause: automated testing for leaks didn't cover this codepath Second level cause: library is non-ergonomic and requires the developer to think really hard about shared/weak pointers and cyclic relationships Ultimate cause: Library writer is not as smart as [Herb Sutter](https://github.com/hsutter/gcpp) and `deferred_ptr` not yet available in Boost or other library. Hence no available abstraction relieves the developer from thinking hard about cyclic relationship :-P
Learn.cpp(https://www.learncpp.com/), its great tutorial website for beginers and intermediates, with good coverage on OOPs as well.
Actually `std::partial_sort` has been in the standard library since C++98, and was even part of the SGI STL before that :)
I am brand new on the talk scene. How can I submit for lighting talks?
`std::nth_element` doesn't sort the whole sequence: it merely partitions it around a position and can be computed in O(n) time (using introselect I guess).
As someone who speaks both - C++ is intrinsically harder than Python. There are all sorts of subtleties like "move semantics" that don't exist in Python (or most other languages). There are all sorts of ways to shoot yourself in the foot, too. Don't get me wrong - I love C++ because the amazing performance you can get, but that performance comes at a cost. Modern C++ is a much better language, though, and still backwards compatible! ---- I have the books for you, though: Scott Meyers' Effective C++ and the sequel, Effective Modern C++. These are hardcore, specific books at the intermediate to advanced level. They're full of "here's how to use these features, practically, in a project". And they're also a good read. I think they'd really hit the spot for you.
#6, some people don't realise how it is important. I didn't understand #5, would you so kind to explain it?
&gt;&gt; V501 There are identical sub-expressions to the left and to the right of the '||' operator: rng(2, 7) &lt; abs(z) || rng(2, 7) &lt; abs(z) overmap.cpp 1503 I'm fairly certain `rng` is stateful and thus this is false positive.
The StackOverflow C++ FAQ obviously isn't a substitute for a decent primer, but it certainly complements it.
RAII should be taught in all introductory C++ courses imo
Thought using the standard namespace was frowned upon almost universally?
I've not read it, but would *A Tour of C++* fit, too, as an overview for programmers coming from another language? Though perhaps OP has already done some C++, and doesn't need the overview no more.
Scott Meyer's books are definitely seconded.
&gt;There are all sorts of subtleties like "move semantics" that don't exist in Python (or most other languages). What many people don't realize is that move semantics can be seen as an optimization. It was not in the language before C++11 and you can still write code pretending it's not there and still get some of the benefits. The exception is move-only types but those could be learned separately (you don't need to know much about move semantics at all to use those). My recommendation is that you just ignore move semantics for the time being until you are more of an expert.
Stroustrup says that *A Tour of C++* is more like an intro while the other one is the real deal.
That's right. C++ was touched by college, but I never felt like committing. I instead jumped into Java and later Python. I am confident with Python and Java, but I feel like I will be an inferior creature if I don't bring my C/C++ competency to the same level.
You might want to consider actually going even more ham on the basics by reading a [tuorial on assembly language](https://www.nayuki.io/page/a-fundamental-introduction-to-x86-assembly-programming) to learn the how microprocessors actually work at a much deeper level. This is very useful since some of the more subtle idiosyncrasies of the C and C++ languages are actually thin abstractions over common microprocessor features like testing for zero or non-zero as a true/false condition or accessing sequential memory locations via index registers with post increment modifiers (which is where the ++ in c++ comes from).
Obviously people will say to spend a lot of time learning the specifics through books but I feel like even for C++ the best experience is by writing code https://learnxinyminutes.com/docs/c++/ will give a brief overview of syntax and give you an idea of where to start https://en.cppreference.com/w/ is essential
Re 2. I would like to point out that I like this behaviour! Our projects often have small little platform abstraction layers with different sub folders for each target. In this case I like that vs includes those files in the solution tree so that it‚Äôs easy to navigate and add new APIs to all platforms at once - even if I can‚Äôt compile the other targets ü§ó Also, vs includes all files, including headers. Some other devs that use qtcreator often add each .h file just so they show up in qt.. clutters the cmakelists sooo much... üò° /rant
You can do that later, but the link is only shared with attendees, as that is a requirement for giving a lightning talk. Right now its all about submitting the normal talks.
Don't forget about memory management or it will bite you in the ass
I'd recommend [https://www.learncpp.com](https://www.learncpp.com) as a good point to start. In C++ you should keep in mind that it is old, complex and multi-paradigm language, so some architecture decisions of language can looks weird because of many reasons. * After the tutorial you should read Stroustrup's book to understand paradigms of language, his history and idiomatic view of C++. * After that I recommend to read OOP C++ book, [https://www.amazon.com/Object-Oriented-Programming-4th-Robert-Lafore/dp/0672323087](https://www.amazon.com/Object-Oriented-Programming-4th-Robert-Lafore/dp/0672323087) for instance, cause OOP paradigm in C++ has his own features. * [Nicolai M Josuttis](https://www.amazon.com/Nicolai-M-Josuttis/e/B001ITYMY2/ref=dp_byline_cont_book_1)'s C++ Standard Library will be good to understand full power of STL, although is not so big as Python standard library. * [CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines), Scott Meyers' books(all) are good things but make sense after some experience with C++. In a matter of fact this things are sets of advices, best practices in modern C++. To make a long story short, I want to advice you good books for intermediate of C++: * Exceptional C++ by Herb Sutter * C++ In-Depth Box Set First Edition, Vol. 2: Accelerated C++: Practical Programming by Example * C++ Concurrency in Action: Practical Multithreading * C++ Templates - The Complete Guide, 2nd Edition by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor * C++ In-Depth Series &amp;#x200B; Good luck!
I would also go with this book. If you consider yourself past the beginner level, then now is the time to commit to going through Stroustrup's book and learning all the details. Consider it a first reading: go through as fast as you can, picking up as much as you can, with a view to another reading (or reading a complementary book) in a year's time.
Been in the business 30 years, and these are the three rules I always fail to hammer into beginners. They just never learn. 1. Write code to be as easy to read as you can (if it can't be read, it can't be debugged, and if it can't be debugged it will have bugs). 2. Given the above, write the simplest code you can that gets the job done (every bit of complexity adds potential for more bugs, so don't add what you don't need). 3. Given both the above, write the shortest code you can (the more lines you have the more bugs you will have, so minimize that).
You should have said you used java sooner! The move from java to C++ was fairly painless in my opinion, just having to learn ever so slightly different (and much more convenient imo) syntax, getting an understanding of pointers, and handling your own garbage collection. Once I started C++ I never turned back to Java, best of luck!
I do not think it is possible to add anything to this list: [https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/388282?r=SearchResults&amp;s=1|247.0614#388282](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/388282?r=SearchResults&amp;s=1|247.0614#388282)
You wanna jump in the deep end? Inside the C++ Object Model Book by Stanley B. Lippman is an infinitely detailed book about C++
I agree with this. Sometimes knowing what the assembly is doing actually makes C++ much easier.
For the C++ aspect of actually coding it. Please post this to r/cpp_questions **not here**. You will be asked what you've attempted thus far and what you are stuck with; so you may as well note that in the post. If you do not know the mathematics behind solving the question, pop to r/learnmath first.
If a tutorial is teaching beginners manual memory management, its probably a bad tutorial. Beginners should learn the modern RAII based methods for resource management such as memory, file handles etc as they tend to be much cleaner to read and less prone to bugs. That said, eventually you need to understand what is really happening behind these abstractions and you may need to roll your own in certain corner cases.
"Do my homework" again? That's not even a programming task.
thanks for the hint is my firt time on reddit.
&gt; My question is: why not require trivially copyable AND standard-layout type for increased type-safety? In C++ the answer is usually, because it doesn't come at no cost. &gt; A side note: It seems that std::mutex is also trivially copyable according to gcc and clang, but not to msvc, even though it is not copyable or assignable and has a non-trivial destructor (in the libc++ implementation), see https://godbolt.org/z/JEj_6g, is that a bug? Copying mutexes seems like a (very) bad idea to me (without looking at any std or implementation), iff one has any clue about what these things are doing.
How you've managed to grasp assembly language but not reddit's code formatting syntax is a mystery for the ages.
This will not happen. `inline` asm will **never** be part of C++ standard, and as such, will always be compiler-specific. And compilers will do what they like. You might be able to pressure a particular compiler to change their inline assembly syntax (especially if the pressure comes in a form of pull request which is backwards compatible), but that's about it.
Forgive me; I used the \`\`\`cpp (code)\`\`\` markdown syntax; what is the idiomatic way?
Just teasing mate. Code blocks are indented with 4 spaces.
Why will it never be part of the C++ standard?
reddit is dumb and that formatting only works with the new reddit layout. You need four spaces in front of each line of code, for it to work with the old one.
Yeah they don't bother me because in my own experience those issues almost never come up. So, in the meantime, I'll enjoy having less noise in the source text. I'm perfectly open to seeing the light in the future though. Maybe if we had more template heavy library-esque code at work, but the codebase I work in is 99% "C with classes" style application code.
This article is about API design, not about implementation. When designing an API, mark your move constructors as ```noexcept```. It's then up to the person implementing the move constructor to ensure that the API is satisfied.
I think he means it‚Äôs a question for compilers not the language itself. Each compiler can be finicky and brings its own culture and ‚Äúvoting block‚Äù for the committee
My two main languages of choice are also C++ and Python, and my preference is: it depends :) Python *also* has certain details that are not easy to get to know. Simple stuff such as passing parameters: are these copies, or references? If `a=1; b=a; a=2`, then what is b? To me, that's as much of a gotcha as C++ move semantics. With clearly defined variables, references and pointers, at least I know where my objects are. I agree that in Python it's almost always easy to find the one obvious way to do things, and almost always that is what you want. With C++, you can solve problems in many different ways, and a newbie, heck, even an experienced user, can be easily confused. However, (modern) C++ is very much a language where easy *is* possible, it's just a matter of sticking to that style. I rarely touch template programming for instance. Nothing beats libraries though, and Python's standard lib, and its library ecosystem, are the best I know. So, for getting concepts out the door fast, Python is my first choice. However, for getting *fast concepts* out the door, usually I pick C++ ;)
A lot of non-modern C++ books being recommended here. I'm not sure that's a great idea. Honestly, I've found https://en.cppreference.com to be a very useful resource for the language and libraries. Effective Modern C++ and A Tour of C++ for beginners. Skip the ones that are just revisions of pre-2011 books. And be prepared, I expect C++20 to transform the idiomatic norms much as C++11 did.
It seems that GCC &amp; MSVC have CPUID support. Probably Clang too.
you can't ignore move semantics, STL uses it all the time. any non-trivial project will include code where \`unique\_ptr\` is the best choice, and you won't get \`unique\_ptr\`s to compile if you don't understand move semantics.
Rust has a more compact community, they have 1 compiler, while C++ has many many many more xD ICC, MSVC, GCC, Clang, embedded ones and so on. How would you standardise something like that? For instance, MSVC prohibits inline assembly if you compile for x64. Only intrinsics are allowed.
Yes, anything that is C with objects should be out of the running.
First of all, why not just write AT&amp;T assembly? Yes the syntax sucks, but you write inline assembly so rarely that personally I think it is just easier. In fact, you can write both: bool supports_fp16_conversions() { int temp; asm ("mov{l $1, %%eax| eax, 1}\n\t" "cpuid" : "=c"(temp) // output operands, =c means copy from the ecx register. : // input operands (none, in this case) : "eax","edx" // clobbers: a list of registers changed by this asm code ); return temp &amp; (1&lt;&lt;29); } Which will work regardless of whether it is being compiled with `-masm=att` or `-masm=intel`. That said, yes it is cumbersome, yes it is non-portable (across compilers) and so on, and a standardised syntax would be quite frankly lovely. That said again, you write it so rarely, and you are already writing architecture specific code, that I doubt there is much interest.
Do you mean that GCC/Clang/MSVC provide high-level access to the \`cpuid\` instruction?
the hard part of programming is think loggically. if you do in Python you should be able to do en C++ C++ is a really beautiful language, but you need to take care about more things. this is not bad, just fine tunning that allow you really powerfull task. get A Tour of C++ and The C++ Programming Language (4th Edition) both books will teach you the basis and the references to write your program. get a good IDE (like Visual Studio Community) that will help you a lot (I use Eclipse C++ version) just a small tip with an error that I saw a lot with C++ begginers from others langs: when you you pass an objet to a function like: void funcion(TheClass myObject) this object will be passed by copy, not reference, you need to declare that will be passed as reference to avoid problems. void funcion(TheClass&amp; myObject)
`asm` _is_ [part of C++ standard](http://eel.is/c++draft/dcl.asm) (since C++98 IIUC), although it is "conditionally-supported with implementation-defined meaning".
I'm surprised that the ship time for Tour is so long on Amazon (the link here says 1-2 months: [https://smile.amazon.com/Tour-2nd-Depth-Bjarne-Stroustrup-dp-0134997832/dp/0134997832/ref=mt\_paperback?\_encoding=UTF8&amp;me=&amp;qid=1556289192](https://smile.amazon.com/Tour-2nd-Depth-Bjarne-Stroustrup-dp-0134997832/dp/0134997832/ref=mt_paperback?_encoding=UTF8&amp;me=&amp;qid=1556289192) ). Does anyone have a better place to buy it from, or is there a newer edition that caused this? I could always read it online I guess instead of buying the book but I like having physical programming books for some things.
Not just for embedded systems! Anyone who wants to avoid just handing off cycles for free can benefit. https://youtu.be/GPpD4BBtA1Y
Works in my GCC: https://stackoverflow.com/questions/14266772/how-do-i-call-cpuid-in-linux MSVC: https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex?view=vs-2019
Hot take: every example of how auto is "bad" will contain code with atrociously-named variables and functions.
&gt;Keep your code SIMPLE, imagine someone half as good as you having to read and work on it. If they wouldn't understand it, your code is probably not maintainable by the average developer and this IS important. In general I agree. However, I have found that sometimes a small, well-tested, complicated library (that other people don't understand how it's implemented) AND that greatly simplifies other code is often welcomed with great enthusiasm. Boost.mpl is sort of similar to this idea. Most users of it probably have no clue about the techniques used to implement it, but they are grateful for what it accomplishes. But even in these small, well-tested, but complicated libraries, you should keep things as simple as possible, documenting things well, and answering questions from other team members. Never obfuscate. Become a teacher on your team, someone who raises the game for all other developers.
Also code reviews are gems, sometimes I see tricks others uses that ends up as new patterns in my toolbox.
I'm a bit late to this party. I'm a C++ programmer looking for full time work from the Augusta, GA area. I'm willing to do remote work. And I'm a bit of a generalist. All technologies listed below are in no particular order. I've worked with the following in a professional environment and consider myself proficient: C++, Python, LaTeX, shell (bash, zsh, sh), various dialects of SQL (primarily MySQL and PostgreSQL), ARM assembly, Debian Linux, Windows, MacOSX, Git, vim, various office suites I've worked with the following in either a hobbyist or an educational environment and consider myself proficient: Rust, Java, NixOS, z80 assembly, mips assembly, 65816 assembly, Matlab, Mathematica, Logic Analyzers, Oscilloscopes, Soldering I've worked with the following technologies, but either due to the long time since I've last worked with them or lack of in-depth experience, I might need a few weeks to become comfortable: JavaScript, HTML, CSS, Typescript, SASS (and other CSS targeting languages), Ruby, Rails, Sinatra, Django, other Linux variants (Gentoo, RHEL, Slackware, Arch), NoSQL databases (Mongo), Verilog, VHDL, Fortran, Haskell, IDA, JTAG (hardware debugging interface), Basic, Pascal, Delphi While I am willing to consider to any position, I would prefer to work in any of the following areas: security, systems programming, firmware, electronic design, or anything that is nuclear adjacent. Additionally, I have two somewhat mismatched undergraduate engineering degrees (computer engineering and nuclear engineering). Please DM me if you think I might be an asset.
&gt;you can't ignore move semantics, STL uses it all the time. I don't implement the STL. I just use it. &gt;any non-trivial project will include code where \`unique\_ptr\` is the best choice, and you won't get \`unique\_ptr\`s to compile if you don't understand move semantics. unique\_ptr is probably the best example of what I meant by a *move-only type*. You don't need to know much about move semantics to use it. All you need to know is that you use std::move when you want to transfer the ownership of the object from one unique\_ptr to another.
The \`cpuid\` is just an example; my real goal is writing AVX-512 instructions. Figured everyone would cry if I wrote down 500 lines of AVX-512.
If `a=1; b=a; a=2`, then what is b? I'm not sure of your point on this one. `b=1` after a sequence like this in every language I can think of, and it's certainly as true in C++ as in Python.
Why not use your compiler's AVX-512 intrinsics?
You cannot write literals with that many digits. Literals must fit in some built in type. I don't know the boost mp library but it probably has a way to construct a big int from a string. You probably want to use that.
I think you misunderstood what I meant. `std::mutex` is specified to be not copyable and not movable, which I checked with `static_assert(!std::is_copy_constructible_v&lt;std::mutex&gt;)` etc..., yet the predicate `std::is_trivially_copyable_v&lt;std::mutex&gt;` returns true in gcc and clang, which doesn't make sense given the definition of [TriviallyCopyable](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable). I expected it to *not* be trivially copyable.
The *title* of the article mentions API, but half of the bullet points are about implementation, so this excuse doesn't fly.
&gt; Why not use your compiler's AVX-512 intrinsics? Possibly because many compilers have traditionally been rather braindead about optimizing intrinsics when it comes to pointless moves between registers and memory?
Ok, it is part of a standard in a very literal meaning. My comment would be better phrased differently, what I meant to say was that it's syntax will never be standardized.
I always do when I can.
Right; take a look at what actually happens to an intrinsic under \`perf\`. Intrinsics are better than nothing, but data movement is the enemy.
I thought so, but [cppreference](https://en.cppreference.com/w/cpp/algorithm/partial_sort) seems to indicate it came in C++17.
1. `std::mutex` is trivially copyable on libstdc++ 2. `std::experimental::net::buffer` as specified in N4771 accepts any trivially copyable type and wraps it with a copyable buffer 3. OP is asking whether that is a bug I don't see how OP "would like to throw all of that overboard".
Only the ExecutionPolicy overloads
 namespace foobar= foo::bar;
Ahh, misread the "until C++20" for notating that C++20 added `constexpr`. Thanks
According to [this](https://en.cppreference.com/w/cpp/thread/mutex) is neither movable nor copyable, so it must be a bug.
Rust can move faster due to a single compiler, but somehow things still get standardized in C++-some say too many things. In this case, every compiler supports it, and does it in a different way, which is the traditional reason for standardization, rather than the "standardize the addition of 1 million lines of this package because we don't have a good package manager" which has currently come into fashion. &amp;#x200B; As to MSVC's prohibition on inline asm, I was wondering why MSVC doesn't require a clobber list. Perhaps that's why they had to deprecate it?
If it's a unique ptr to a class you wrote you basically must implement a move constructor.
&gt; I expected it to not be trivially copyable. Yes, I probably mis-understood.
According to the standard, all trivial types are trivially copyable, and a trivial type can be non-copyable. So we have to conclude that a trivially copyable type can be non-copyable :/
Why?
Because you can't return it from a scope without the higher scope taking ownership, and that takes movement of the raw pointer.
What?! There are 25 points listed in the article and I don't see any that involve implementation other than some points about how to separate the implementation from the API. At any rate, there are 25 points and you're claiming half of them are about implementation, that means about 12... let's assume you're just being somewhat clumsy and exaggerating... can you list 6 points in the article that deal with implementation?
But moving a unique\_ptr will use the move constructor/move assignment operator of the unique\_ptr. It will not touch the object that is pointed to.
Try out pybind11 to make some python packages that are written in cpp. It is a good way to learn I think.
\`code samples in Python and C++ for a Student class with a fight method\` - mental note - avoid college you went to. :D
I have improved quite a lot by watching presentations from cppcon on the Youtubes.
&gt; The whole reason for the existence of reverse iterators is to avoid this pitfall It's surely a rare case to modify the container you're iterating over, but indices are stable in such situation whereas iterators are not.
\`70-80% of moving from python to cpp is just getting used to the syntax\` - nothing could be farther from truth.
Sorry, I was thinking of this: pass or assign a unique ptr, you'll be using &amp;&amp; and std::move. Your can't not understand what's happening. You're right that you generally don't need to implement it yourself unless wanted.
I don't know the reason behind the prohibition, sorry. As far as I know you have MASM when you install their toolchain, so you can always use extern functions in a header and an assembly source file, if you really need it. I suppose most people use intrinsics rather than inline assembly. For the C++ part, I'm still a student but many people that work with it say that the standard is adding many useless things and sometimes it's too metaprogramming biased.
‚Ä¶ which is why the general advice is to never modify containers while iterating over them. There are always (?) better solutions.
&gt; I'm implementing for a open source networking library parts of the API defined in the Networking TS Why? For fun/to learn? If not, just use the [already-implemented one by the author](https://github.com/chriskohlhoff/networking-ts-impl).
When I thought I had a pretty good grasp on C++, I read both of those books and learned how little I knew previously. I‚Äôd say I‚Äôm better with C++ than 99.9% of programmers, but I doubt I‚Äôll ever consider myself an expert.
&gt; dont forget the semicolon at every EOL. So while( i &lt; 10); { i++; } is correct??
Maybe I was lucky that the high school professor teached us Assembly and C. We also studied how microprocessors are made, not detailed as in university though. What I wanted to clarify is, that if you're targeting students, you need to believe that not everyone knows what a pointer is, what an address is, what's RAM, cache, registers, CPU and so on. What's passing by value? Reference? Pointers? You should add some theory, or at least link to resources that explain the concepts.
The linked site has a bullet point list: - Every copy constructor is trivial or deleted - Every move constructor is trivial or deleted - Every copy assignment operator is trivial or deleted - Every move assignment operator is trivial or deleted at least one copy constructor, move constructor, copy assignment operator, or move assignment operator is non-deleted - Trivial non-deleted destructor In libstdc++, mutex has deleted copy ctor and assignment, and trivial move ctor and move assignment and trivial dtor. It is thereby TriviallyCopyable. This concept basically means that you can use `std::memmove` / `std::memcpy` on the object safely (https://en.cppreference.com/w/cpp/types/is_trivially_copyable).
Coming from C++ this was really confusing for me, everything is a reference (sometimes) Even worse, something like this: list = [] for i in range(0, 100): row = {'c1' : i, 'c2' : i * 2} list.append(row) At the end, every single element in the list is the same, because it's a list of 100 references to the same object, which get's updated in the loop This is way worse than many of the ways I feel like I run into in C++. If I crash, great that's easy to track down and fix. If everything 'appears' to work but doesn't that's always a much bigger pain in the ass. Coming from a C++ background and working in a large Python project, I have almost no trust of code I look at. Variables maintain different types constantly, you have no idea if code could fail or not without actually just running it with all your possible use cases, since it's not type safe. If I look at 500 lines of C++ I can feel pretty confident about what it does, 500 lines of Python ... who the fuck knows.
Why not give constructive feedback and point to good resources, and maybe, just maybe explain *why* they're "garbage"? To someone that's more experienced these things may be obvious, but to someone that's a beginner and coming from python, it's not. So someone is going to find this thread and look at your toxicity be put off. For example, the person might not understand types and type traits. So you could explain the concept of type decay and that while arrays are arrays, they can and will [decay into pointers](https://en.cppreference.com/w/cpp/types/decay) in different contexts.
&gt; Every 'xxx' is trivial or deleted I'm lost, get me on board, please.
C++ is a general purpose code generation tool. First solve this by hand, and then implement that into code.
&gt; But I don't see why intrinsics are obviously superior to inline asm. Easier for compilers to understand and optimize.
In certain cases, the second assignment will cause Python to store a reference, which is altered for both a and b in the second statement.
&gt; In libstdc++ ... Seems like the wrong starting point.
"The syntax sucks" until you spend some quality time with it. Sure, it's not the prettiest on the world, but once you get the hang of it, it will work fine. And easier to maintain than trying to switch back and forth between AT&amp;T / Intel syntax imo...
Certainly the compiler can understand it better since it doesn't even attempt to parse inline asm, but I don't see how it can optimize it: You're telling the compiler *exactly* what instruction you want. How can it do any optimizing?
Teaching C++ and using adjectives as ‚Äúeasy‚Äù or ‚Äúquick‚Äù... well, sounds like Dunning-Krueger effect. The more I write C++, the more I feel humbled by its complexity.
Challenge accepted. API design is about class hierarchies and method signatures. How to convert this API into code is all about implementation. With this in mind: #2, #9, #14, #15, #16, #22.
Okay so presumably you agree that ```f``` does not throw then? If you agree that ```f``` does not throw, then does the following function ```g``` throw or not? void g() { try { // Some code that may or may not throw. } catch(...) { // Catch any exception. std::terminate(); } } And if you agree that ```g``` does not throw, then I have news for you... you can rewrite ```g``` in the following manner: void g() noexcept { // Some code. } At this point, you must conclude that functions marked as ```noexcept``` do not throw an exception.
Okay I generally follow libraries mostly, but I will throw some links at you and maybe they are helpful. https://old.reddit.com/r/cpp/comments/9lmfrv/some_examples_of_wellwritten_opensource_projects/ https://old.reddit.com/r/cpp/comments/b34s3c/json_for_modern_c_version_360_released/ https://old.reddit.com/r/cpp/comments/bh64f4/uvw_v1160_headeronly_libuv_wrapper_in_modern_c_is/ You could also look into Google's c++ codebase. I know they are not 100% modern c++ but I think they invest a lot into tooling to make up for that. Facebook may be in a similar way but idk for sure. Overall since modern c++ is really new (since 2011 at the earliest I guess) I will admit it may be hard to find a code base that's fully modern that's also been heavily battle tested.
To keep it minimalistic without dependencies since adding dependencies is not generally not been accepted. That implementation (based on asio) also has no restrictions on T, so there is some type-safety to be gained.
&gt; What many people don't realize is that move semantics can be seen as an optimization. Those people don't realise that because this is incorrect. Move semantics are about semantics, not optimisation.
Then I'm afraid you simply do not know what an API is. If to you all an API consists of are method signatures and class hierarchies, nothing to do with things like visibility, namespaces, binary compatibility, versioning, preconditions, post-conditions, then yeah, there's not much point in discussing this further and I wish you all the best.
Intrinsics should allow the compiler to make better decisions about register allocation and inlining. Presumably they should also allow writing better code, e.g. you use 2 separate intrinsics to better convey what you're doing and the compiler can optimize them into a single intrinsic/instruction, whereas in assembly you'd have to do that manually and add a comment or something. As for if compilers actually currently perform these optimizations is another story.
Please enlighten me, explain how "don't forward declare stl classes" is more relate to API design than "don't mark throwing methods noexcept"
one trivial solution: x = y = 0, z = 2019/17 in c++: template &lt;typename...args&gt; auto solve(args...) { return {0, 0, 2019./17}; }
&gt; Fast inline assembly is of no use if the function calls are very unoptimized. I don't understand that. Traditional assembly programming using AVX instructions (such as is found in BLAS) operates on large vectors; fetching the data from RAM dominates the cost of establishing a stack frame.
hint: set two of them to zero and see what happens
I agree that you can't learn something like c++ so quickly. My repo is intended for people who are good at python to point out how they can use that to their advantage while stepping into c++. For example both have classes with static and non static methods. Things like that.
Not all inline assembly fetches from memory. For such cases the overhead can be noticeable. Intrinsics solve this problem. Arguably intrinsics are also more readable and understandable. Plus they are probably easier to maintain for compiler authors.
No, and by many means. \- Where is the line `auto x=4;` in the c++ example? or `int x{4};` ? (Rust `let x=4`) Or Rust creates `x` in the heap? \- In the c++ example the error has nothing to do with the `shared_ptr` but with returning a lambda capturing a reference to the local variable `x` (no matter what is the type of `x`, exept if it is self a reference) - thus producing *explicitally* a dangling reference.
&gt; - Where is the line auto x=4; in the c++ example? Being said, I wrote it to be as close to C++ example as possible. If I don't do that then reference dies at the end of the statement and you just cannot initalize `y` with such a value. For example let's reference temporary heap variable ```rust error[E0716]: temporary value dropped while borrowed --&gt; src/main.rs:8:16 | 8 | y = f(&amp;Box::new(4)); | ^^^^^^^^^^^ - temporary value is freed at the end of this statement | | | creates a temporary which is freed while still in use ``` Oops. We can't. &gt; In the c++ example the error has nothing to do with the shared_ptr but with returning a lambda capturing a reference to the local variable x (no matter what is the type of x, exept if it is self a reference) - thus producing explicitally a dangling reference. So did I. I actually linked resulting lambda lifetime to the unput reference one. As long as reference is alive you can call lambda safely, when input reference is gone you cannot. In both C++ and Rust we explicitely captured the reference to the value via [&amp;] in C++ and `move` in Rust (it's move of the reference, not the value), so I don't get what wrong do you see here.
It inherits from `__mutex_base` which is non-trivial `~__mutex_base() noexcept { __gthread_mutex_destroy(&amp;_M_mutex); }`.
The reason to avoid forward declaring classes that are external to your API is to avoid creating a tight coupling between your API and a specific version of an external library. This is not about an implementation detail but rather about ensuring that your API is forward compatible with external libraries. The STL is singled out specifically because forward declaring STL classes is not allowed by the standard.
Thanks, I'm gonna learn it.
&gt;Nothing teaches you how a car works better than building a working car. Yea i agree it's a good learning experience, just not a good production code experience in our case. &gt;It was because there was not, and still is not to this day, anything like my stuff in the standard C++ world, which is a comprehensive, tightly integrated system from the ground up. So do you mean like no external dependencies at all, not even standard library? I'm curious to know, what are your main issues with STL. What was your main motivation for creating your own bool, string, etc. (besides just being completely independent) I haven't gone through all of your code but did you even do like an std::sort equivalent of your own?
&gt; that formatting only works with the new reddit layout. Heh, I thought this is maybe the time to have a look and used that big red "GET NEW REDDIT" button for the first time. Turns out it has no effect.
I didn't ask to explain why it's a good advice, I asked to explain why it has anything to do with API design.
I have read it, and this is the ideal book for that audience. You don‚Äôt need to read a comprehensive reference.
This. It never ceases to amazes me how I regularly learn new things about the language - even after years of professional development.
It has to do with designing an API that has forward compatibility in mind.
No, he say _every_ EOL, so: while( i &lt; 10); {; i++; };
IIRC movement of the raw pointer doesn't require the pointed object to have a move constructor
Because it was not a question, it was an attempt at teaching. So OP already posed themselves as an expert, at this is a bar they didn't meet. May be this toxicity would discourage OP and other very inexperienced people from teaching, and would steer them towards learning.
Stroustrup himself rated 7/10 on "how much do you know the language", so I wouldn't be too surprised ahah
It is extremely opinionated on some rather trivial things, but I‚Äôve gotten more learning use out of it than gripes
Well, I think there are conceptual differences between moving a unique\_ptr compared to moving in general. The way I see it: 1. At the heart of move semantics we have temporary objects (rvalues). Instead of just copying the whole object we could rip out some parts of it and give it to the new object because the temporary is about to be destroyed anyway. In this sense moving is just an optimized copy. Since this happens automatically it's something that people can take advantage of even without knowing about move semantics. 2. Sometimes we want to move objects that are not temporaries because we are finished using the object and we just want to make copying a faster. This has to be done explicitly and puts more responsibility on the programmer to know what he's doing but otherwise it's the same as #1. Moving *copyable* objects is still just an optimized copy. Writing code that relies on the move to happen would be very fragile because there are a lot of subtle things that could go wrong and you wouldn't get an error if it ended up copying the object. 3. Then, finally, there are *move-only types*, i.e. types that can be moved but not copied. These types you can, and must, rely on the move to happen. It's obvious when a move fails because you get an error telling you about it. In this case moving is no longer just an optimized copy. It's something else. It's a way to transfer some kind of state from one object to another, and often you know what state the moved-from object ends up with, something that is normally not the case for other types. If move semantics didn't exist as a language feature you could still have implemented the same behaviour in code but you wouldn't get the implicit moves that #1 gives you. So when it comes to unique\_ptr I don't think move semantics is essential. It could be implemented without it. That is why I think you don't need to know much about move semantics to use unique\_ptr. All you need to know is that you need to use std::move on the unique\_ptr before assigning it to another unique\_ptr or using it to initialize a new unique\_ptr, and that this will move the pointer value over to the other unique\_ptr leaving the moved-from unique\_ptr "empty". There are of course the exceptions that you don't need to use std::move if it's a temporary, or it's a local variable being returned from a function, but all this is just extra knowledge that you don't *need* to know in order to use unique\_ptr.
Out of curiousity, why do you want to learn c++
To sidestep your question: I've written high-performance C++ for quite some time now and never encountered a situation that really requires the use of inline assembly. In many cases you can rearrange your code, tweak compiler settings or use compiler intrinsics (if applicable). But I only worked in the games/graphics domain so far. I suppose inline assembly is a useful and crucial tool for embedded development as some platforms might have some exotic instructions that the compiler is unaware of.
Although...bringing that up in an interview, then rating myself a 5 in that context generally doesn't play well.
Just don't give an explicit number and say that you're a 6+, the plus means that you're always learning.
Do you think move semantics would have been added to the language if it didn't have a performance advantage? Quote from the [original move semantics proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Motivation): &gt;Move semantics is mostly about performance optimization: the ability to move an expensive object from one address in memory to another, while pilfering resources of the source in order to construct the target with minimum expense.
Unfortunate that people feel that way. I would like to believe that's due to bad managers. Maybe just having bad/unmotivating attitudes or maybe being too overly technical on the agile stuff. Personally I see a benefit to managing software production in a formal way. But imo you also have to realise that at the end of the day you need to give the devs lots of uninterrupted time to work and not convolute things with too many meetings/status updates. Also I think it helps when "managers" are developers themselves as they understand everyone's needs a bit better.
&gt;If I don't do that then reference dies at the end of the statement You can't create a value in the heap (4) and them share the ownwersrchip of that value using a reference counter in Rust?
It's a chicken and egg problem. Most people who need to write asm don't do it inline as the syntax is so bizarre. I'm thinking [BLAS](https://github.com/xianyi/OpenBLAS/blob/develop/kernel/x86_64/axpy_sse.S), LAPACK, which have a huge list of .asm files which are included in their builds. So there's a sense in which maybe a good syntax would allow people to better integrate their asm into their environment. But as to the claim that you don't have to write asm very often: I personally don't like to think of it in those terms. I'd prefer people thought of the total power consumed by the instructions. What fraction of your CPU power budget is spent decrypting AES? Lots of it. Well, [that's in asm](https://github.com/openssl/openssl/blob/master/crypto/aes/aes_x86core.c)
It's too template based because instead of adding language features, libraries are being added to the standard. Libraries that need to heavily use metaprogramming because of the lack of language features ¬Ø\\_(„ÉÑ)_/¬Ø
Of course not. It's `while( i &lt; 10);` `{;` `i++;` `};` ;-)
Nice (: also if you're interested in good modern c++ practices in general, check out the [cpp core guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md) if you haven't already
&gt;‚Ä¶ the newline/tab sequence... Just a tiny pointer, you can use raw string literals for multi-line strings in C++11 onwards: bool supports_fp16_conversions() { int temp; // N0R3P (or whatever you want) so ')"' anywhere won't break the string asm(R"N0R3P( .intel_syntax noprefix; mov eax, 1; cpuid; .att_syntax; )N0R3P" : "=c"(temp) // output operands, =c means copy from the ecx register. : // input operands (none, in this case) : "eax","edx" // clobbers: a list of registers changed by this asm code ); return temp &amp; (1&lt;&lt;29); }
&gt; Sorry, I was thinking of this: pass or assign a unique ptr, you'll be using &amp;&amp; and std::move. you just have to use std::move, not &amp;&amp; : void acquire_ownership(std::unique_ptr&lt;int&gt; x) { } int main() { std::unique_ptr&lt;int&gt; p; acquire_ownership(std::move(p)); } no `&amp;&amp;` needed here
&gt;Use `malloc` or `new` keyword to allocate new memory. Please don't advocate that. Both are code smells in C++. Please use std::array, std::vector, std::string, or another container. &amp;#x200B; There are tons of C++ best advice articles out there. I strongly recommend the author read many of those and then revisit how to help others transition.
As corollary to that, I always argue that you shouldn't vastly complicate code to satisfy the 5% crowd, i.e. the ones who have really significant requirements of some sort (capacity, speed, whatever...) Write code that is probably half as complex and serve the 95% with a system that is easier to understand (at least for you, probably for them) and much more likely to remain bug free over time. I say let the 5% fend for themselves using specialized tools for the job. I think almost any business person would tell you not to make your product harder to manufacturer or sell to the 95% market in order to satisfy the 5% market, unless of course you are getting a LOT more money from the 5 percenters, which isn't likely the case.
I am puzzled by people who've been in the industry for 1 year and than start posting teaching blogs.
What's wrong wit MIT OpenCourseWare? [https://ocw.mit.edu/courses/audio-video-courses/](https://ocw.mit.edu/courses/audio-video-courses/)
I don't think a tool is going to make much that much difference. You can't build X until you've built the stuff that X depends on, and the entire code base is an ever widening tree of dependencies, and each layer has to digest more and more underlying stuff. And it's also in two separate code bases as well, so the entire general purpose layer has to be built first, then the automation system layer. Some parallelism could be done by finding non-related chunks at the same level, but unless you have multiple systems to build on, the heaviness of the build process would just eat my hard drive alive if did that and probably end up not being that much of a gain. I am doing parallel builds at the file level, so it's doing 8 source files at a time within any given exe/library module. I gave up incremental builds in favor of the file level parallelism because the incremental builds just never worked well for me, and I did better time-wise with the file level stuff. Of course I'm not that unique wrt to build time issues. Plenty of folks deal with it in large code bases.
Neat, I like it. Do you think something like "safe" should be in std, or should we have only low-level stuff like mutex and lock?
&gt; At the end, every single element in the list is the same, because it's a list of 100 references to the same object, which get's updated in the loop. No. It does exactly what you want.
&gt; At the end, every single element in the list is the same, because it's a list of 100 references to the same object, which get's updated in the loop I'm not sure I understood that. I ran a test and got this: &gt;&gt;&gt; list = [] &gt;&gt;&gt; for i in range(0, 5): ... row = {'c1': i, 'c2': i*2} ... list.append(row) ... &gt;&gt;&gt; list [{'c1': 0, 'c2': 0}, {'c1': 1, 'c2': 2}, {'c1': 2, 'c2': 4}, {'c1': 3, 'c2': 6}, {'c1': 4, 'c2': 8}] &gt;&gt;&gt; [id(l) for l in list] [140194800177016, 140194799657320, 140194798491400, 140194798490320, 140194798490392] Which to me looks like those are not the same object.
As they say, $hit runs downhill, and most of us are on the top of that particular hill and so we don't put it as high on the list of concerns for the code that we ourselves are writing. If the question was what are the top ten things you want from a piece of third party code, then probably good docs would be near the top for everyone. Which of course is probably pretty hypocritical of us. But, as they say, a day without hypocrisy is a day where you probably never woke up.
Presumably he's a contractor, and so any work he does is based on a contract as to what exactly is to be delivered (hence not having one means that what is to be delivered can suddenly become a matter of opinion on the part of the folks who you have to get your money from.)
"70-80% of moving from python to cpp is just getting used to the syntax" Yeah, that's what I thought. I speak python &amp; C, how hard is it going to be to learn C++. Hint: hard. Python is much more dynamic: you can attach stuff at runtime to an object, and when you ask, it's there. In C++ the compiler has to know that that member is part of the object. "int \*ptr = \&amp;x;" Please. Stop writing C in C++.
How would you standardize something that is inherently platform specific (x86, arm, mops...)
Well, I did it because I didn't want to use one that is just some standalone bit of code. The thing people don't get with all of this is the huge advantages of using a comprehensive, tightly integrated system. All my code uses my logging system, my exceptions, my translatable text system, my text transcoding system, my streams, my collections, my strings, my smart enumerations, and on and on. There are HUGE benefits to this. I'm not saying everyone should do that themselves, obviously. But I do argue that C++ should have long ago developed such a thing. And that's why I've done it, because the C++ community has never gotten itself together sufficiently to tackle it for me. And now of course a lot of C++ people act like arguing for an elegant, integrated solution is somehow wrong, and that using a bunch of disjoint pieces and parts is actually the way it should be. To the point that they will, as they already have for this whole section, down-vote it to oblivion because God forbid we allow any ideas that we don't agree with be seen. &amp;#x200B; As to QT, I'm just going by what I was told by some of the many people who regularly tell me how horrible I am for not using the STL. If they use the STL for core stuff, then they inherently cannot build a tightly integrated system of their own, because they can't inject any of their infrastructure into the STL.
Fixed the example
Sorry, fixed the example.
I'm expressing my opinion just like everyone else. If you don't like it, I assume your keyboard has as many keys as mine, so try to take a break from running around and down-voting all my posts and make some coherent counter-arguments of your own.
It sometimes really feels as if the committee would add insanely complex features to the language, just so that libraries can implement functionality that could be provided by a trivial language feature. Not really true, but it sometimes feels like that.
Do exactly what Rust did by having a #cfg branch off the architecture. Of course the actual contents of the asm wouldn't be standardized, only the selection of the architecture and the binding of the C++ variables to registers.
I don't see any assembler in the file you linked.
A lot of people around here have me on auto-downvote.
It's in there. You can also search 'asm' in the project to find many more examples.
[For reference, this is what old.reddit sees](https://i.imgur.com/VOUKMV7.png)
If you are implying that that's what I meant above, you didn't read it very well. The point isn't what's on his list. The point is that I was specifically asking people to correlate their list with some basic info on what kind and size of software they create, and he didn't do it and still hasn't done it. And, as you can see from reading the other stuff here, I was completely correct that other people have vastly different concerns, which was what I was trying to get across to him. His list isn't universal, nor is mine. That's the whole point of this thread, as I said in the first line of my original post.
Locks in Rust are designed this way. IMO this approach has problems when trying to write critical sections for code that touches more than one variable at once. Say you have a class with 5 member variables and want to write a critical method that touches 3 of them. What's the best way here? Having all 5 of then wrapped into mutexes is introducing overhead because all three would need be locked first before touching? Here, having the "legacy" approach of a sixth member being a "empty" lock and locking that one before touching the three is probably better?
I don't know man, it seems like you're hamstringing yourself a lot on build times because things didn't work for you at some point, rather than fixing them. If incremental builds were having issues you should look at why, there are plenty of tools to figure it out, but it will take a bit of time I admit. If you're bottlenecking on slow hard drives you should try to convince your company to invest the couple of hundred dollars to add a NMVE drive. If you compare how much the company pays per hour to have you working (not your salary, but including everything else), it is very easy to justify those kinds of expenses quickly. I work on a code base that a few multiples larger than yours and I don't have any issues with build times. Incremental builds for my day to day are real slow if they take 2 minutes. Generally I'm looking at 30 second builds. Full builds are less than 10 minutes, but I only do those maybe once or twice a week. You're right that, as the only software dev at a company, you wouldn't see much of an improvement from a tool like incredibuild. I didn't realize that when I first wrote my reply (somehow missed it in my first read). I think that is an incredibly unique experience though. I do think that this makes you unique. Other people that have large code bases that have issues with build times is because they are not investing the time to fix it, which ultimately costs them more time.
I added something similar to the current C++ I work on, and I can share a much simpler way to lock: `.lock()`. That is, locking in the library is expressed through a `lock` method on the equivalent of the `Lockable` class: { auto fooAccess = foo.lock(); *fooAccess = "Hello, World!"; // access the value using pointer semantics: * and -&gt; } I also particularly appreciate the ability to use one liners; that is when writing a method on an object containing a "lockable" member, I often find myself writing the following: class Api { public: int call(int); private: class Storage { public: int call(int); private: int state = 0; }; Lockable&lt;Storage&gt; storage; }; int Api::call(int a) { return storage.lock()-&gt;call(a); } int Storage::call(int a) { return state += a; } At first, my colleagues found the code duplication strange: there are two `call` methods! Yes, there are two. It's a bit of boilerplate, with `Api::call` just forwarding stuff back and forth. The reason, however, is simple: re-entrancy. If you have ever used relatively more complex methods on objects with locks, then you've probably encountered the dreaded re-entrancy issue: - each public method must lock, - calling a public method from a public method therefore risks locking twice! I've worked with guidelines, such as lock then delegate work to a private `Impl` method, etc... although it's really easy to slip up and cause a deadlock. I've worked with re-entrant locks, exchanging run-time performance for convenience leaves a bad taste in the mouth. The above pattern, however, is foolproof: - It's easy to enforce that methods in `Api` only delegate, they have to delegate *anyway*, so ensuring they are one-liners is easy. - Methods in `Storage` cannot accidentally dead-lock: they are lock-neutral. This does not, of course, solve the issues of dead-locking between multiple objects; but it's a step in the right direction.
&gt;If they use the STL for core stuff, then they inherently cannot build a tightly integrated system of their own, because they can't inject any of their infrastructure into the STL. Define "tightly integrated".
Couldn't you put all 3 variables in a struct or a tuple and then use then template the Lockable on that?
Isn't that the issue? The same code does different things for objects vs integers, which can be confusing.
They have great lectures, but their MIT 6.096 course which covers what I'm looking for doesn't seem to have its video lectures available. On the other hand I do plan on using their MIT 6.006 course once I have a solid grasp of discrete mathematics. Otherwise I'm still on the look out
Part of the problem is that even incremental builds aren't going to help if I'm modifying fundamental headers/classes. And, for some time now I've been on a tear with implementing new language capabilities into the code base, which generally requires changing things either down low in the system or throughout the system. So a lot of builds I'm doing lately are the full monty or close to it. Because I do work hard to keep inline code to a minimum, I can change a lot of stuff without any real re-build at all. But when really monkeying with the heart of the machine, nothing is really likely to save me. And of course I AM the company, and I can't afford a lot of gear. I've dedicated my whole life to building an amazing product (meaning the automation system built on top of the CIDLib general purpose stuff) just to live in poverty (and at this point it looks like probably to die that way.)
A solution to this is the Pimpl idiom: https://en.cppreference.com/w/cpp/language/pimpl.
Just as I said. They have fundamental parts of the system to which they have no access and cannot make those parts utilize system wide functionality that would be part of the overall framework they are creating. As mentioned, I have a logging system, which every piece of code can use. It's a very flexible system and can be set up to log to a log server when implemented in a distributed system. If I used the STL, I could never get any of that code to use my logging system. And I can't tell you how powerful a tool that is for me in the field.
Everybody is a teacher, finding a true learner is a difficulty
You might have another method on that object that only touches one of the three for writing. Of reading the others can be done lock free you'd lock two of them unnecessarily I think. Not sure if this is a real use case though.
&gt;It flags errors [like a missing brace (1) or parenthesis] in code that compiles perfectly fine Yeah, that's because it's a static code analyzer and not a compiler. It gives you hints how to improve your code. It you disagree with a rule, you can easily disable it.
You might have another method on that object that only touches one of the three for writing. If reading the others can be done lock free you'd lock two of them unnecessarily I think. Not sure if this is a real use case though.
Yeh, that's exactly what I do. Well, that and various other tricks. But of course those tricks all preclude the use of templates because that requires that that code be inlined. That's why I was arguing for minimizing use of templates and pushing as much code out of line as possible. Even when I use templates, if there's any non-trivial bits of the code that can be pushed out of line and just called from the templated code, I'll usually do that as well. For dialog boxes and some utility style windows, of which there are plenty, I don't directly export those classes, I make them invokable via calls to the 'facility object' for the UI facility (a facility in my-speak is an exe or DLL type module.) So they are all internal details. For text transcoding, I have a handful of really common ones in the base facility and the rest are gen'ed up by name via calls to the text encoding facility so they remain internal details. Anyhoo, I do all of those pretty standard sorts of tricks to keep details details and minimize rebuild times.
I would also recommend "Exceptional C++" After reading "Effective C++|. Even though its not written for modern C++ . This book is still amazing to read. OP can pick up Herb Sutter's Guru Of The Week for C++11 Afterwards
That's an accurate description, however, the whole example with `sak::` namespace is unnecessary: a simple `std::cout &lt;&lt; 10` shows the need for ADL.
Use smart pointer to contain the memory so that you will never see memory leak in C++ again.
One issue is that lockability of an object really complicates things when they are copyable or movable. In my system, my collections are lockable, because it's so common to use collections to share information between threads in some way. But it really makes things complicated. If you move a lockable object to another object of that type, do you swap the locks? If you do, and the source was locked, now the source isn't locked anymore, and some code has a lock on an object that is going off somewhere into the ozone. If you don't, then the content that the source had locked is no longer locked, and he has a lock to thin air but any code that was using that object may still think it has something important locked. It can get messy. I took the approach that, in my limited scenario of just collections, that copy/assign is purely limited to that which makes the two collection have equal members in cursor iteration order. And moves never move the locks. I do that consistently, but it's still a complication that could bite at some point if I'm not careful. The ability to lock the collections is way more important to me, so I'm happy with that tradeoff, but everything has a cost. In particularly queues, which are often used as the basis for thread farming (where threads need to be able to block both waiting for data to get out, but also waiting for space to put in), it would be really a lot messier doing that from the outside.
A simple ```std::cout &lt;&lt; 10;``` would only demonstrate overloaded functions, it wouldn't demonstrate the use of ADL to resolve a specific overload.
I'd say anything that teaches C++ as an OOP language should be out of the running, honestly. And anything that doesn't start with RAII as the first principle.
Sure, but use std::make_unique&lt;&gt; or std::make_shared&lt;&gt;. Don't call new directly (unless you're designing your own container or smart pointer or something that really requires it).
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; but the Microsoft syntax for inline asm is different: ... Btw nobody uses intline asm in MSVC anymore. Because inline asm works only for 32-bit binaries. When compiler tagets x86_64 - inline asm is not supported in MSVC.
You don't have to pass `.intel_syntax`, you can just write AT&amp;T syntax. Instead of `"=c"(temp)`, you can also write `"=ecx"(temp)`. Microsoft's way seems easier until you consider that using register constraints means GNU can allocate registers for you and optimize across `asm`, which Microsoft can not. The syntax may not be the prettiest, but, honestly, `asm(something in parens)[something in brackets]{ thing in braces : another thing : another }` definitely isn't prettier and leaves questions open (what if asm contains colons? what if registers contain punctuation? how to express "pick any address register"?).
&gt; and trivial move ctor and move assignment Does it? Since there are user-declared copy ctor and assignment, move ctor and assignment will not be implicitly declared. It seems that before the resolution of [CWG 1734](https://wg21.link/cwg1734), the standard implies that a completely non-copyable class can be trivially-copyable, and GCC and Clang still follows the old rule.
You don't need Rc in such a case because it's literally "create a closure over the value reference" If you rewrite it then `Rc` collection will just live until the last reference gets dropped and the whole example will just work ``` use std::rc::Rc; fn f&lt;'a&gt;(x: Rc&lt;i32&gt;) -&gt; impl Fn() -&gt; i32 + 'a { move || *x } fn main() { let y; { y = f(Rc::new(4)); println!("{}", y()); } println!("{}", y()); } ``` Outputs ``` 4 4 ``` https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=1ec8ed4f3d2ffa7acb2c084c60998ecb --- You can't get dangling reference in safe Rust, no matter what are you trying to do.
You are wrong. `operator&lt;&lt;` lives in namespace `std`, and can only be found in this example through ADL.
Personally, I can't think of a real world scenario for that. If you're using one mutex to lock all of the variables in one place, then I'd think you'd want to use that same mutex to lock all of them in all places. Otherwise you're mixing and matching mutexes which sounds like a recipe for disaster. The way I've always thought of it is that a mutex conceptually owns the members it locks (which is why I called my version of this `owning_mutex`).
You are wrong. ```operator&lt;&lt;``` for ```std::cout``` and ```int``` is a member function belonging to the class template ```basic_ostream``` as documented in the link below and as such does not make use of ADL but is simply an example of function overloading. It's syntactically equivalent to the following: std::cout.operator &lt;&lt;(10); Which you are welcome to copy and paste into Godbolt to verify for yourself or review the link below: https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt
I had the opposite problemüòÇ C++ was my first computer language, and I would say I‚Äôm pretty good at it. Learning Python has been a difficulty just based upon the fact that it‚Äôs simpler
You are wrong. operator&lt;&lt; for std::cout and int is a member function belonging to the class template basic_ostream as documented in the link below and as such does not make use of ADL but is simply an example of function overloading. It's syntactically equivalent to the following: std::cout.operator &lt;&lt;(10); Which you are welcome to copy and paste into Godbolt to verify for yourself or review the link below: https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt
Anything that requires locking multiple objects is a mess :/ Personally, I subscribe to the notion that it is better to **Share by Communicating** than *Communicate by Sharing*, and the applications I work on follow this design principle, with only a very few classes with an internally lockable state. Instead, queues (of various kinds) are used to communicate asynchronously from one thread to another. I find that Share by Communicating leads to a more coarse-grained design (with few asynchronous operations around big blocks of synchronous operations) and results in better performance as well as less headaches: - Better performance from the big blocks of synchronous operations which do not wait on anything. - Less headaches as the reduced number of asynchronous jumps make it easier to understand where contention can happen, compared to a myriad locks sprinkled here and there. Indeed, the few locks remaining are generally sources of contention, and we are thinking on how to evolve the design to be able to avoid them... locks are easy to introduce and hard to remove, but they make you pay every day for their presence so at some points you need to bite the bullet :/
Some thoughts from my side: * shared\_mutex are theoretically a nice feature, but in the end the performance was in my tests worse than normal mutex. See here the paragraph 'Performance Warning' in Anthony Williams post [https://www.justsoftwaresolutions.co.uk/threading/new-concurrency-features-in-c++14.html](https://www.justsoftwaresolutions.co.uk/threading/new-concurrency-features-in-c++14.html) * I miss in the introduction or at the end a statement about the general problem of mutex: Each new mutex adds a synchronisation point into the game which leads either to performance issues or even to dead locks. See Sean Parent on Concurrency: [https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency](https://sean-parent.stlab.cc/papers-and-presentations/#better-code-concurrency) Or Sergey Ignatchenko in [https://accu.org/index.php/journals/2623](https://accu.org/index.php/journals/2623) * Someone said mutex should not be named mutex, but bottlenecks.
That is correct, I forgot that for `int` operator&lt;&lt; is a member function. I will edit my comment for `std::string`.
I use both as well, but the queue based scheme introduces its own set of complications. It can lead to really difficult to deal with race condition problems because there is inherently no direct synchronization between the threads. I.e. thread A sends a msg to thread B based on his current understanding of the state of the world. But, by the time thread B gets that msg, the state of the world has changed, and that might cause thread B to do the wrong thing. That's really why synchronization exists, because a lot of scenarios cannot be dealt with unless the state of their world can be prevented from changing behind their backs. I'd say that most such situations require such a thing. You could do a lot of fancy stuff to work around that, but by that time it probably would have just been simpler to provide them both with a lockable shared object that they can make calls against in a guaranteed atomic way.
I don't think calling people's work garbage is the optimal way to steer people in that direction. Clearly your goal was to insult and put down the OP, and an elitist response just doesn't seem like the optimal way to steer people towards learning more C++.
Huh? I like your list. I was just adding another entry to it that I thought got missed.
Quite sad for MSVC and x64. I used to have fun with all injections as a teenager. The inline asm feature is probably the only one that I would use and abuse as non standard C++.
Prefer `cmake_paths` and `cmake_find_package` conan generators to `cmake`, they allow you to write your `CMakeLists.txt` in a package manager agnostic way.
I find the hardest part about cpp is all the old shit that's mainly there only because of backward compatibility. I hate working on projects with developers that insist on using char arrays instead of std strings or insist on using raw pointers all over and newing up objects everywhere.
You can still use masm as it is installed along the Microsoft toolchain
&gt; What is ADL? Hell.
Just a heads up this is more cpp_questions material I think. Anyway I don't think will you want the const cast solution. Because what if someone passes you a const Foo? I don't know of any other solution besides making your wrapper hold a copy of Foo instead of a reference. Besides that imo your pointer solution is the only thing I can think of.
Thank you ! As you have seen these generators have been voluntarily hidden for simplicity, yes improvements are possible for generators, we present here one of the simplest methods. In the future maybe, i will speak about those generators to, that you can find more explication about in this youtube talk from Ropert: [https://www.youtube.com/watch?v=k99\_qbB2FvM](https://www.youtube.com/watch?v=k99_qbB2FvM)
A pile of garbage is a pile of garbage. This post does real harm - it contains very inaccurate statements, which could be dangerous to people who are learning the language. There is nothing elitist in correctly assessing quality of material. Also I did not insult OP in any way, I only referred to the material posted. The less materials like that we have, the better for all of us in the community.
The way I would do it is to make a `FooWrapper` a template, and than either use make_wrapper function or C++17 deduction guides to construct an appropriate type based on the arguments. I see `FooWrapper` of `const Foo` a different type from `FooWrapper` of `Foo`, same way as `const Foo` is different from `Foo`.
&gt; I don't want to ... make it a template. Complaining about how a arbitrary subset of the language doesn't make something easy seems ... well, pretty contrived as far as complaints go.
You can read any latest Stroustrup's book, but reading a book from cover to cover is really not that fun. I suggest you pick a project at the start and learn as you go. The basics are more or less the same, so you will be able to get started pretty quickly. However, do know that C++ is ugly to it's core, the more you'll learn about it the less you'll like it.
I knew that... I'm not stupid... much...
The solution to your problem is what the standard does with smart pointer classes like std::shared\_ptr and std::unique\_ptr. And yes, they both use templates and const specializations to maintain const correctness. That's the proper solution. If you don't wanna do the proper solution... well, that's a different discussion. :P
Thanks for the answer!
Yes, I agree -- this function does not throw any exceptions.
See also `iterator` vs `const_iterator` for all the standard containers.
Good job on making a thing! That is WAY too many thumb signs for a professional article. You should retitle these articles and then rearrange content around the titles as they're rambling.
ADLBoy
I don't think the reasons were technical. We had some MS people come to visit us at work around the time of the x64 transition, and lack of x64 inline assembler was something we moaned about - and the rationale as I recall was basically that the demand wasn't there to justify the staff to look after it. The x86 inline assembler was there because it had already been much, pretty much. At the time, this probably made good sense, as I suppose they would have been supporting Itanium, PowerPC, x86, and x64, though I wonder if they'd make the same decision if they knew how the Itanium and PPC bets would turn out? (As for why MSVC's x86 inline asm doesn't require a clobber list: turn the question around. Why does gcc require a clobber list? Is it impossible to statically determine an instruction's inputs and outputs?)
I meant that I do void LetsDoItWrapped(const Foo&amp; doer) { const FooWrapper wrapper(const_cast&lt;Foo&amp;&gt;(doer) ); LetsDoIt(wrapper); } I think that's valid, since my wrapper constructor never modifies the Foo instance, and none of the const methods do otherwise
Note that doing so currently doesn't check nor configure your project to match Conan settings. This could lead to ABI differences and the project not linking with your Conan deps
Yeah, makes sense. I just wish there was a way of qualifying a constructor so that it could only be called to create a const object (guess I could use a factory method)
I'll admit, I'm being lazy. The type only gets used in two places(and isn't public), so I think I'll stick with my const cast hack for now
Agreed about shared_mutex. The concept of being able to have many readers inside a critical section sounds great but due to the complexity of the lock, it's actually a pretty rare situation that it gets you a performance boost. You need lots of readers, because otherwise your contention is low enough where you might as well use a regular mutex. You need few writers, or else you're going to be bottlenecked by the unique locking mechanism anyway. And you really should only use it for situations where reads take a long time, in relation to the time it takes to acquire the lock, or else the extra complexity to acquire the lock is going to dominate the time you're spending in the critical section.
ADL is a group that works against freedom or speech, freedom of association, freedom of thought, freedom of opinion.
It's great to hear that it got better for you with 16.1 Preview 2! Was this with the folder where you copied LLVM 4 times? We'll take a look at #1. So, to make sure I understand correctly, 25% into those 10 mins (\~2-3 mins in) is when the first CMake configure operation started, right? \#2 is the default behavior, but you can tweak it from Tools &gt;Options &gt; CMake: "When cache is out of date: \[x\] Run configure step only if CMakeSettings.json exists" if you would rather see that only run for the CMake projects you manually configured in your folder rather than all.
If you know programming but don't know C++ this is probably fine to do. Plus, your company probably has a professional development policy that would likely cover something like this. Check with your company's HR department.
This is also true. Spread the word people.
C++17 gave us deduction guides, which accomplish a similar goal. Here's an example: https://godbolt.org/z/Immi_d
fn &lt; &gt; ‚Äò
You could make two different wrappers, one with const and one with non const. Using templates it will be easier, but without templates you just need to write a const wrapper for const functions and a non const for non const functions.
But that's not very helpful I think, if I would add or remove a brace, the code would cease to compile.
No. Here it is: use std::rc::Rc; fn f(x: Rc&lt;i32&gt;) -&gt; impl Fn() -&gt; i32 { || *x } fn main() { let y; { let x = Rc::new(4); y = f(x); println!("{}", y()); } println!("{}", y()); } correctly print: Compiling playground v0.0.1 (/playground) error[E0373]: closure may outlive the current function, but it borrows `x`, which is owned by the current function --&gt; src/main.rs:5:6 | 5 | || *x | ^^ - `x` is borrowed here | | | may outlive borrowed value `x` | note: closure is returned here --&gt; src/main.rs:5:6 | 5 | || *x | ^^^^^ help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword | 5 | move || *x | ^^^^^^^ error: aborting due to previous error For more information about this error, try `rustc --explain E0373`. error: Could not compile `playground`. To learn more, run the command again with --verbose. and this: use std::rc::Rc; fn f(x: Rc&lt;i32&gt;) -&gt; impl Fn() -&gt; i32 { move || *x } fn main() { let y; { let x = Rc::new(4); y = f(x); println!("{}", y()); } println!("{}", y()); }
Wow...
I'd say if you're going the OOP route, stick to Java. OOP-heavy is as obsolete a paradigm as procedural-heavy, and leads to as much of an architectural rat's nest.
What do you in this situation? Extern to global .asm files?
Well, if you don't learn OOP, then you aren't even going to have OOP extra-light. Given that OOP is one of the key aspects of C++, it makes absolutely no sense not to make it a key part of teaching C++. As to obsolete, that's purely a matter of opinion, as is 'heavy'.
Is this basically the template version? https://godbolt.org/z/q6RMs8
No, your comment had a lot of fluff. Learn to get to the point, and stick with the point.
The original post literally gives your example as an example (and yes, it was that way prior to being posted on Reddit). Quote: &gt; Notice that this is not a problem for the ‚Äústandard‚Äù stream insertion operators, such as the ones for primitive types. When you call `std::cout &lt;&lt; 42`, you‚Äôre not using ADL; you‚Äôre just calling the member function [`std::ostream::operator&lt;&lt;(int)`](https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt). https://quuxplusone.github.io/blog/2019/04/26/what-is-adl/#notice-that-this-is-not-a-proble
Then maybe you should have said that instead, though of course that's just your opinion and I don't share it.
I could be missing something, but if the original variable that `doer` references is declared const we have UB. To clarify, the following would be ok Foo f; LetsDoIt(f); But the following would be UB afaik. const Foo f; LetsDoIt(f);
Unfortunately C++ allows types to be trivially copyable even if they are not copyable or movable. This is surprising to most sensible people. Libstdc++ makes its mutex types no-copyable and non-movable, but that doesn't stop them being trivially copyable. That's a bug, see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67572
No, the majority of your comment comes across as saying that his list is wrong. What's so hard about phrasing the request simply? "Hey, please put your background and years of experience", rather than the sanctimonious "Your list isn't universal". Your comment, and subsequent replies, spent more time talking about how his list isn't universal, rather than addressing the missing bullet points.
Very interesting history. As to the clobber list, in this example, the `cpuid` instruction alters `eax`, `ebx` and `ecx`. I don't see any way the compiler could know that.
&gt; ... allows types to be trivially copyable even if they are not copyable or movable. I believe you, but, I just don't understand what that sentence means. Do you think you can explain it [to me]?
I'm assuming LetsDoIt() will not itself const_cast (as it has no way of knowing whether it was declared const, and is therefore allowed to), and in the implementation of the wrapper itself, there are no const_casts
I want the wrapper to have both const and non-const overloads (as both are needed in one scenario while only the const one is needed in the other scenario)
"Trivially copyable" is a very specific property, defined by the standard. It didn't just mean "you can copy it, easily", it means you can use `memcpy` to make a copy of the object representation, i.e. the underlying bytes of the object. But being copyable and/or movable means you can invoke a constructor to create a new object. These are two different properties, and they can vary independently. A type can have a deleted copy constructor and deleted move conductor, but still be "trivially copyable" with `memcpy`. But you're right that it makes no sense.
well i think im missing something, but it seems like you know the pitfalls of const cast. as long as you are not *modifying* memory that was originally declared const youre good.
I just had another idea, could use inheritance, with the const overload in the base class.
why does the wrapper need a non-const overload? Why do you care whether the wrapper is const or not?
It's my way of saying you should get everything in writing to cover your ass. If everything is verbal, that tends to lead to major feature creep, you end up maxing out your bandwidth really fast, and your product ends up being subpar. For example: * I was tasked with writing a server that talked to the GUI via strings over a socket. I had a well-defined system and message structure that everyone adhered to. Until a week before delivery when the team lead rolled out a new GUI with an expanded message system my server didn't understand. The lead swore up and down that he had told me about this months ago and that I was just going to have to cancel Easter to get the server compliant. I got it working with some midnight oil, but the only reason I didn't get grilled over cutting it so close is because I was super anal about getting tickets, so when there was no message update ticket the team lead ended up under the bus instead of me. * Another task at the job was to refactor some of our deployment product, which was a mountain of bash scripts choked full of greps, magic numbers, and flat out wrong comments. This was before I learned to love paper trails, so what ended up happening was this small refactor kept growing in size as the CTO kept deciding certain features should be added, and he only ever used future perfect tense for things he wanted *eventually* and things he wanted *now*. So I burned myself to fuck trying to deliver this random list of requirements way ahead or schedule. If I had made him write out exactly what he wanted and when he wanted it, then the product would have turned out a lot neater and a lot faster. Basically, your instructions and work history are only as good as the paper they're written on.
Anti-Defamation League.
OK, that's a surprising response. So, how does the compiler know that `mov ebx,eax` reads from `eax` and writes to `ebx`? That's easy: there's code in the compiler that parses x86 assembly language and figures out what's what based on the instructions. The x86 instruction `cpuid` affects `eax`, `ebx` and `ecx`. The code that figures out which registers are affected by the instruction will therefore have this case coded into it.
Yeah but unique_ptr before move semantics was auto_ptr, which was so bad that it is the entire reason for the existence of unique_ptr.
Just say that rating yourself involves judgement of others which you consider a violent and penetrative act, and against your personal beliefs.
OOP *was* one of the key aspects. Back in 2005. Unless your idiomatic dialect is Qt, that shouldn't really be true in the modern era. In modern C++, OOP is a minor footnote in a language that espouses an interplay of a dozen paradigms, with runtime polymorphism as a dispatch mechanism only really being central for a handful of scenarios, all of which should be well away from any tight loops or structured arrays of data. Even type erased polymorphism plays a more significant role at this point. I'm not saying there is no place for OO concepts anywhere in C++, but the statement "if you aren't learning C++ in in the context of OOP, don't even bother learning it" sounds troglodytic. It really is no different than "if you aren't learning C++ in the context of Procedural Programming, don't even bother learning it".
I think everything you just said is based more on fashion than actual real code in the field, but I'll leave it at that because I know where this conversation is going.
Why Walter's photo is cut out and put above a image of sky? It's just weird...
You either put functions in .asm files and use masm/yasm/nasm. Or switch to clang.
sometimes you have no choice. especially if you're (intentionally) doing something "naughty"
use a recursive mutex in the public member?
&gt; Mistake # 3: Ignoring the Rule of Three I can think of a snarky response to this statement, but for now I will say that C++11 has been out for long enough that the default should be to refer to the "Rule of 5" rather than "Rule of 3". &gt; Mistake # 7: Not marking read-only data/methods as const A couple of complaints that I have here about C++ (not the blog post) are: 1. if I have a member variable that is to complicated to set up in an initializer list, but will not be changed after the constructor has finished, I can't mark it as const. 2. (I have heard, not actually tried this) that when moving a class with const members, the const members themselves have to get copied, not moved. &gt;Mistake # 8: Returning the internals of your API via a const reference &gt; &gt;What is the client casts aways the constness of the object using a const cast and modifies it ? If the client code is going to break the contract, that is their problem. &gt;Mistake # 10: Not using explicit template instantiation when use cases are known &gt; &gt;**Step 3:** Tell the client that your API supports the three specializations for int, double and string by putting the following typedefs at the end your header file: I would add, you should use `static_assert` with `std::is_same` to enforce this. &gt;Mistake # 11: Exposing internal values in default function parameters (Directed at the blog) One of the criticisms listed here is that the client will have to recompile. The writer does not discuss whether the indicated solution to other issues actually addresses the recompile "problem". &amp;#x200B; &gt; Mistake # 23 : Not considering header only implementations for open source projects I think the writer ignored the discussion of template mistakes when writing this one (amongst other things). Also, I don't think any of the issues mentioned have to do header only files as much as they have to do with source only distributions (rather than source+binary).
a mistake
I work in a place where every developer has their own preference on which code editor to use and each developer will read code on multiple different servers that are not necessarily connected to each other. Assuming the existence of an IDE where I work is a non-starter.
well, in my actual scenario, it's more like struct Foo { void Set(int val); int Get() const; }; So maybe I simplified it too much.
&gt; auto n = 12571352561; // What type is this? Definitely not a number with less than 34 bits.
&gt; My bigger challenge is convincing my team that comments like these do not add value. I suspect that it is not so much the team as much as it is 1 or two people on the team that scream to high heaven about consistency.
I keep seeing this referenced but I‚Äôve never seen a concrete source for it.
Your sole example is one of the few examples that I have never seen argued against. I have almost always seen it accepted that `auto` is fine with iterators.
It doesn't matter. The constness of the *wrapper* doesn't matter. Only the constness of the thing being wrapped (which is only const if T is const)
&gt;int guaranteedExec() &gt; &gt;{ &gt; &gt;int numExecs; &gt; &gt;try { &gt; &gt;numExecs = fast\_but\_almost\_always\_safe\_exec(); &gt; &gt;} catch { &gt; &gt;numExeces = slow\_but\_safe\_exec(); &gt; &gt;} &gt; &gt;log&lt;&lt;"Thingy execed "&lt;&lt;numExecs&lt;&lt;" times."&lt;&lt;std::endl; &gt; &gt;return numExecs(); &gt; &gt;}
Compiler warnings are not part of the standard, your point is invalid, e.g., TuboBorland+++ Unicorn5 compiler doesn't warn about this. &amp;#x200B; ;)
From this thread, I have gotten the impression that professors universally believe that everyone in industry uses it.
&gt; It's syntactically equivalent to the following: `std::cout.operator &lt;&lt;(10);` While `std::cout &lt;&lt; 10;` would compile even without ADL, it still _performs_ ADL and selects `basic_ostream::operator&lt;&lt;(int)` as the best candidate, whereas `std::cout.operator&lt;&lt;(10)` does not perform ADL at all. So they are not entirely equivalent. [This godbolt](https://godbolt.org/z/z56Plz) shows the difference. The direct call `my_cout.operator&lt;&lt;(10)` compiles, but calling with the operator `my_cout &lt;&lt; 10` performs ADL, which sees the free function and fails with an ambiguous overload set.
Some books I'd recommend: A Tour Of C++ is a good intro/refresher. It covers everything the language itself offers in a "short-and-sweet" approach. If you want to skim the basics, this lets you do just that pretty well. Although any decent online tutorial will be about as effective. Scott Meyers' books in this order: - Effective C++ - More Effective C++ - Effective STL - Effective Modern C++ Why in that order? It's there release order, and stuff covered in the later books sometime refer to things that were taught in the previous ones. Obviously, if anything said in a later book contradicts something from a previous book, it becomes the new "standard" (i.e. iterators changed in modern C++ vs how they used to be when Effective STL was released). I'd also recommend you read them first as they give you a pretty good understanding of paradigms and idioms that online tutorials don't typically cover (and neither did most of my C++ classes, for that matter). They definitely strengthen your understanding of C++. Afterwards, I'd recommend Herb Sutter's: - Exceptional C++ - More Exceptional C++ - Exception C++ Style They're pretty good theory/problem-solving books that teach you some good approaches to problems in C++. "Accelerated C++" is another book that does this. The "C++ Coding Standard" book by Herb Sutter and Andrei Alexandrescu is also pretty good at giving guidelines and best practices. Finally, while it isn't directly C++-related, I'd recommend the "Linkers &amp; Loaders" book by John R. Levine. It definitely helps understand how those work, and since C++ uses them it can be pretty helpful for a deeper understanding of linkers and their errors.
Yes, C++ cant be learnt "quickly". My intention was to suggest how python experts can use their expertise to their advantage while moving to C++. I'd consider myself a beginner in C++ (\~3 months since I wrote my 1st C++ code, although I did learn C back in college). You can see here [https://github.com/piyush-kgp/Daily-Coding-Problems](https://github.com/piyush-kgp/Daily-Coding-Problems) that initially I used to do problems in Python, but now do it in C++. I remember Prof. Algorithms Roughgarden's lecture where he said focus on the solution (the algorithm) not the language. Languages are mere tools. I think that advice is very powerful and very comforting at the same time.
I suppose the confusion comes from the fact that the post I replied to has been deleted, but yes of course the example you wrote performs ADL because you declared a free function in the same namespace as one of the arguments. That's precisely what ADL does. There is no ADL performed in the case where no free function exists in any of the arguments namespaces, which was the example that I was replying to and which has since been deleted.
&gt; And just to be contrary, if we try to use C++2a Concepts requires-clauses to express our constraints, then Clangaccepts and GCC rejects! (I don‚Äôt know which one is more correct according to the C++2a draft standard.) Clang is correct. Would be a pretty extreme usability burden if you couldn't do that.
&gt; Is it impossible to statically determine an instruction's inputs and outputs? Yes, if you want a tight clobber list. Even a simple store inside of PUSH/POP will make static determination difficult as the compiler would have to track stack usage and pointer aliasing. Any CALL out to another routine would also make this difficult, both because of unknown register usage and because of `__stdcall`, which is a callee-pops convention. MSVC's register tracking around inline asm is conservative and easily unnecessarily determines registers as clobbered: https://gcc.godbolt.org/z/uD1P4M
ADL is still performed in the case that no free function exists, it just doesn't find anything to add to the overload set. The compiler doesn't know whether or not there are any free functions in the associated namespaces until it's already performed ADL! (This is an exceedingly minor quibble, I know.)
Thank you for that suggestion.
That's a fair point.
This only works if the instructions that you need are exposed as intrinsics. For a long time, inline assembly was the only way in VC++ to access the `ADC` instruction for extended precision arithmetic until `_addcarry_u32` was added. The x86 compiler was not and is still not good at deducing intended usage of this instruction from idioms.
My point was that because I need both methods to exist, it wouldn't be as simple as your example. I do actually understand the distinction you made in your previous comment. This wrapper is actually implementing an 'interface' (C-style, using a hand rolled vtable because I want a stable ABI for a plugin), I'm having the function pointers in the vtable call the wrapper's methods, and I wanted to use the same wrapper class for both scenarios, passing it as a const pointer, and a non const pointer (to the same 'interface')
I'm stuck in C++03 land unfortunate
... Except that wouldn't actually work for me (see response to xaxxon).
Thanks for that, that was an explanation [of something murky as poo] that was as clear as water. &gt; A type can have a deleted copy constructor and deleted move conductor, but still be "trivially copyable" with `memcpy`. But unless the code is utter garbage, there must be a good reason for deleting those constructors, no? Allowing `memcpy` seems like an error.
I take back the over-board thing.
should I correct it to "every end of statement"?
Millions (more than 10 million) of lines of production C++ across three companies' codebases, under my leadership, and well over a million written by me, dating back to a few years before outgrowing OOP was a widespread trend. I started really cracking down on overuse of class hierarchy based modeling of problem domains in favor of policy/structural/functional modeling sometime in early 2001, and it had a fairly quick and visible payoff in reduced technical debt.
I disabled every feature in msvc and don‚Äôt use any other side tools like reshaper. Visual studio is very laggy. Have not heard about intellicode. Thank you
Resharper makes my solution literally unusable with how slow it gets. It's total garbage if your solutions are somewhat large. I literally could write the code it prototypes for me in the time that some of the hangs take to resolve.
OOP was based on fashion and it just happened to be hot when you hit your stride. Jumping around in memory has been a dead end for decades. Excessive heap allocations as well. Those days are over for anyone who understands modern CPUs.
can you modify my example code to suit your actual use case so that my code is insufficient, please? I'd like to look at it.
https://en.wikipedia.org/wiki/Four_causes Namely: material cause, formal cause, efficient cause, and final cause. The bug's material cause was a memory leak. The formal cause was a lack of memory-safe abstractions. The efficient cause was the programmer(s) who wrote and reviewed the code. The final cause was (hmm...) an over-emphasis on shipping features rather than spending that time on building the underlying library infrastructure or on code review and training.
&gt;d don‚Äôt use any other side tools li intellicode is not a built in feature, it's new made by microsoft and still in preview, you install it from marketplace. as for visual studio, it's not lagging for me I have 3 instance running on my 3 years old laptop! every new release of visual studio had bugs but you can expect it to be fixed in future release
What does multidimensional array have to do with OOP?
See post edit
Utterly meaningless for the vast majority of applications. My automation system is very extensive with up to 10 servers doing lots of ongoing communications, and multiple clients, constant communications with many outboard devices and systems, lots of graphics, etc.. It doesn't even make a small system break a sweat.
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bhkhct/moving_from_python_to_c/elw6zqd/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
30gb... cache üòÅüòÅüòÅüòÅüòÅ
Turn off Roslyn full solution analysis. Almost all of the slowness in large solutions is in the, not R#
It's 1am and I'm not yet ready for spending a week staring at the wording for ADL. I've been putting it off for months.
Just disable the rule.
It's the cache I had since 2015 and I didnt do a lot of coding during this time expect since last year, I saw caches for every solution I have in AppData, we have to delete it manually.
This is a bit of a cheeky answer, but [Sean Parent's talk on inheritance](https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil) is one of my favorite OOP talks.
Resharper always been bad, the real question is how does this Intellicode compare to visual assist x?
By the way, do you know if `oclint` is dead, since there in no new release since [Sep 2017](http://oclint.org/news/2017/09/30/release-0-13.html) and the latest commits stop at Jul 2018 ?
Seriously? Shouldn't it [tidy] be able to deduce the code does not have a braces problem? If it [tidy] cannot say anything sensible about it, shut-up then.
You mean the Visual Studio baked in analyzer for C#? We're talking cpp here, but even if we were not, full solution analysis is off (that's the default too now). Plus, the slowness goes away instantly when the Resharper plugin is disabled. Unless there is some sort of extra analysis option in Resharper that you're talking about?
Note that [Intellicode is now part of the base install in 16.1 P2](https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-preview#16.1_Preview2).
Oh, my bad, forgot what sub I was in. I have no idea when it comes to C++ solutions in VS.
Thanks, it's good to know that they will add it to the next release
If you think there's a bug, it would make sense to file a bug report.
&gt;Modern C++ is a significantly better language than C++03, though, and still backwards compatible. as someone who liked C++ but then was forced to work exclusively in C for a decade ... I've grown to love the fact that my entire C project builds faster than a single C++ file that I now have to build because we are using some IP from a vendor who provides a C++11 standard library based driver. I like the idea of generic programming (templates) but the C++ implementation of templates pulls far too much implementation into headers which results in unnecessary recompilation of templates when nothing has changed. IMO, the compilation time penalty paid by C++ because of its evolutionary past is crushing. What I feel is missing is really clever template compilation that creates the smallest possible header files and separate source files. I.e. foo.template should compile to foo.hpp and foo.cpp. The fact that anyone finds unity build an acceptable approach is a clear indication that the language needs a major overhaul. I have no qualms with the C++ feature set and functionality, just with the excessive replication of effort when I change a single line of code in a C++ file (i.e. no change to template instantiation or even to a header that invokes a template). I've heard that modules in C++20 may improve things a bit but the gains I'm hearing about seem pretty weak. There has to be a way to do generic programming that does not cost SO MUCH TIME to process files that have not changed from one compile to another (i.e. template definitions and the headers that instantiate them).
This fits a general pattern with Visual Studio. I have 300K lines of code. That's good for 6GB of data in my .vs directory, which AFAIK is mostly Intellisense information. I have a lot of small executables that instantiate some big libraries, and I have the feeling every library has its symbols included in the intellisense info for each executable. The output for one build mode is another 1.5GB, so that adds up to 6GB for all four. It seems a bit much for 14.6MB of source...
From what I see IntelliCode is just a smart filter on top of IntelliSense so it has all the defects of IntelliSense. To me VAX is still the king in terms of accuracy and responsivness. Accuracy: VAX suggestions are context dependent based on the type expected which IntelliSense is not. Also unlike IntelliSense, VAX doesn't provide a list of every symbols found deep down the Windows headers that you will never ever use. VAX propose only user symbols first which is relevant in 90% of the time. Responsivness: VAX is still faster to show up suggestions. Coupled with accuracy VAX provides a better experience for writing code IHMO. Code navigation feels also better with VAX. Even if IntelliSense get better on each versions and IntelliCode is a nice to have, Microsoft must hears that their solution is just ok but third-parties like VAX perform just better since a long time.
&gt;Sure, but use std::make\_unique&lt;&gt; or std::make\_shared&lt;&gt;. Don't call new directly (unless you're designing your own container or smart pointer or something that really requires it). Why is it a bad choice to use the new keyword? Is it because I'm consuming extra memory or is it a good practice thing
Now, imagine an actual tool, like a hand saw. One has good experience with it, never had an injury or a problem with using it. So this person thinks "hm, and what if I got a circular power saw to make my sawing faster? It is known to be dangerous, but I‚Äôm an expert in using saws". So this guy hops on YouTube and watches a couple tutorials from people who say ‚Äúdon‚Äôt worry, using a circular saw is super easy, it is like a normal saw, just with a motor attached to it‚Äù. What do you think is going to happen when he tries to use the saw? I‚Äôd bet on screwing up the job, or a visit to the ER... It is very true that languages are tools, and the actual language-independent solution is more important. But you cannot circumvent the nitty-gritty details of actually coding an algorithm. Without correct usage of the tool you won‚Äôt get a correct program even if your plan was perfect and the algorithm rigorously proved on paper. So, "mere tools" are important too.
Sorry to disappoint you so terribly. The thing is I'm learning myself and my repo is not an attempt to teach, just a friendly nudge to someone who is good in python and wants to learn C++ saying "it's not that tough you know". I have Let's come to the points: 1 - debatable and shouldn't the job of the teacher/helper be to make it seem like it's easy even if it's not. 2 - I know that now. Specifically int \*ptr declares ptr as a pointer and int arr\[3\] declares arr as an array. The reason I got confused was because of \`int \*A = new int\[5\]\`. I thought the RHS is an array but the LHS is a pointer. Since we can say \`=\`; it must mean A is indeed an \`int\[5\]\` array. But now I know that it's not; A is a pointer pointing to A\[0\]. (PLEASE SOMEBODY CORRECT ME IF I'm WRONG). 3 - I've stopped doing that myself now but I see many people doing it in Stackoverflow answers. 4 - Are you talking about this? By default, all members of a class declared with the class declared with the class keyword have private access for all its members. Therefore, any member that is declared before any other access specifier has private access automatically. Why then is everybody writing \`private\` in their classes. Is there any difference between the default private members and the specifically declared private members. Also PLEASE tell me what's wrong with [https://github.com/piyush-kgp/python-to-cpp/blob/12ade999d5a46bf31be1a97201451ad0284b33c7/learnFast.cpp#L31](https://github.com/piyush-kgp/python-to-cpp/blob/12ade999d5a46bf31be1a97201451ad0284b33c7/learnFast.cpp#L31) 5 - Yes the getters and setters have no real use. It was just to show how they are used. 6 - I know now. I'll change. You can use attr directly outside too. But see, that is very confusing for someone with python background. In python, we have self.attr or self.method for any attribute or method of the class which is a clear indication of using something from the class. C++ has no such thing. You just say attr and the compiler knows what you're talking about. This leads to chaos. What if I define a variable called attr or worse yet what if I have a method with an argument called attr &amp;#x200B; Thank you so much for reading my code sir. I've just been writing in C++ for 3 months. I saw in your other comment that by uploading something like this, I'm attempting to teach wrong things. That was not my intention. It is just about helping each other in the end, and I feel the C++ community is a lot less welcoming to outsiders than the python community. That doesn't help anybody. My effort is to show what minimal things you need to keep in mind for switching from python to c++.
&gt; there's code in the compiler that parses x86 assembly language You seem to be using GCC, so no there isn't; the C++ compiler sees the inline assembly, does extremely basic token substitution, and dumps the result into the middle of the function. Later the assembler (a separate binary) parses the assembly and generates machine code, but by that point it's too late; the C++ compiler is done running. That's why you need to specify the assembly flavor twice; you're changing the assembler's parser on the fly, and then changing it back later.
&gt;Yeah, that's what I thought. I speak python &amp; C, how hard is it going to be to learn C++. Hint: hard. For starters, Python is much more dynamic: you can attach stuff at runtime to an object, and when you ask, it's there. In C++ the compiler has to know that that member is part of the object. The weirdest part to me was if you declared a std::map&lt;char, int&gt; H and then you std::cout&lt;&lt;H\['x'\], you are increasing H.size() to 1 and H\['x'\] becomes 0. Isn't that a wrong thing for the compiler to do? Shouldn't it throw a KeyError or something?
Yeah, you're right. Thanks for clarification! I automatically put `move` to the closure because compiler said, and seemed legit to have closure lifetime tied to the input reference instead of just fail with the error, but I forgot that the error was what we wanted on the first place.
That's a good question as I've posted an issue in the past week and haven't received a response.
Arthur sure can pump out blog posts, huh?
Would you say all that you wrote is still very much true today (April 2019)? I have exactly the same experience as you, so I'm glad to hear that confirmed. But I haven't tried ReSharperC++ or IntelliSense/IntelliCode for 1-2 years now. Perhaps things have changed in the meantime? Or not?
That‚Äôs specifically why I chose it. The purpose of the example is to establish a common basis to develop my argument from: ‚ÄúWe can all agree that `auto` *sometimes* improves readability (see ‚Äπexample‚Ä∫), here‚Äôs my argument for why it *always* does: 1. ‚Ä¶ 2. ‚Ä¶ 3.‚Äù
Yes, its his official goto image.
&gt; It can lead to really difficult to deal with race condition problems because there is inherently no direct synchronization between the threads. It also suffers from context loss: when you debug a method call in a "synchronous" part, you've lost all the "stack" of anything prior to the asynchronous call, which makes things more difficult. &gt; But, by the time thread B gets that msg, the state of the world has changed, and that might cause thread B to do the wrong thing. In my cases, I'm lucky enough that I can either simply pass all "world modifications" events in the same queue as the messages, which allows each thread to maintain its own sequential view of the world, and for messages to be synchronized with the world sequence, or that keeping the sequence with the state of the world doesn't matter as much. It probably helps that I am already evolving in the distributed architecture (Service-Oriented Architecture) which is strongly asynchronous by nature as all distributed systems are. &gt; Of course it also has to be said that such schemes themselves require synchronization of the underlying queuing mechanisms, so there's no free lunch. The big difference between a lock and a queue is the wait time: - Lock: any operation can be carried out while locked, so the potential wait time is infinite; it requires careful thinking to strike the right balance between frequency of acquiring the lock (too fine-grained is hurtful) and wait time (too coarse-grained is hurtful). - Queue: no arbitrary operation is carried while "locked", so the potential wait time has bounded complexity based only on the type of the queue. There's still contention, of course. SPSC queues are supposedly simple, but the naive and optimized version can differ by an order of magnitude performance-wise! Still, you can benchmark a queue in a variety of scenarios and have an extensive view of its performance characteristics; and once tuned it won't change. By comparison, the operations carried while a lock is locked evolve regularly as part of maintenance, and are more complex to analyze. This really makes queues easier to reason about, performance-wise.
I‚Äôm always wary of such uninitialised variables. For one thing, it prevents the variable from being `const`, and I prefer having *all* locals be `const`. It makes it clear that values aren‚Äôt touched once initialised. Instead, refactor the logic into an initialiser. You can use a proper function but given the naming of your example function a lambda is probably more appropriate (since the only thing the function does is initialise and log the value): int guaranteedExec() { int const numExecs = [] { try { return fast_but_almost_always_safe_exec(); } catch (...) { return slow_but_safe_exec(); } }(); log&lt;&lt;"Thingy execed "&lt;&lt;numExecs&lt;&lt;" times.\n"&lt;&lt;logns::flush; return numExecs; }
These past months I've tried to disable VAX to give a chance to IntelliSense from time to time. The first thing I miss is the navigation fluency. It's a bit more laggy. The "universal" navigation bar appeared in VS2017 is a good step forward. However it requires more keystrokes to achieve the same. As for the auto completion, the list of suggestion is polluted by too many symbols coming from nowhere making the list harder to read and so it takes longer to find the correct symbol. It's quite frustrating because I didn't experienced such trouble in C#. One of the few thing IntelliSense does better than VAX is the tokenization for syntax coloration. For example if a function and a value of an enum have the same name then every occurrence of the function will have the color of the enum. Intellisense is more accurate for that. That's why I turn on IntelliSense in addition to VAX. Also in few cases the syntax coloration from IntelliSense helped me figuring out where compilation errors happened.
Totally agree, most projects try to auto magic way to much. Basically they take the stance that "the user of this library has 0 knowledge of his environment, so let's make some educated guesses and search his file system to try and locate our dependencies &amp; compiler"
The more I look at platform abstractions being added to C++, the less it makes sense to actually use them.
I think this could be what you're looking for. https://github.com/hanickadot/compile-time-regular-expressions
I've started using Conan at work recently, mostly with CMake, and I've got to admit that so far it generally always had a solution when I had a problem packaging a specific library. Would recomment, but it will probably be better in a few years when more basic libraries will be available in conan-center.
I'm not sure if this is going to be popular opinion, but you could start with C (note missing ++). It's a relatively simple language due to the fact that there is simply not much stuff in the language, but it will teach you types, memory layout, memory copying, i/o, compile time vs run time, low-level threading and whatsnot. After that C++ concepts should come to you naturally, you'll get why C++ does move semantics and copy elision, etc. You know, some higher-level ideas might obfuscate and hurt your understanding of what's really there closer to the metal, but if you would get along with C when you might see through those ideas. Then i would say go with C++98, then move to C++11/14/17 to understand evolution of the language. Starting right away with C++17 is probably a bad idea because C++17 is, in a sense, a superset of C++14, C++14 is a superset of C++11 and so on, this comes down to superset of C++98 really. Yeah, C++98 is not going anywhere, it's a very big part of the C++. If you skip C++98 then you'll be missing a lot of stuff. On C++ reading, i think it would be a good idea to start with classics: Effective C++, More Effective C++, Alexandrescu, etc, it's all on Google. I would recommend to read it even if you can't understand it, that's fine, it takes time to digest. Be warned that as a side effect, you might also become a normal C++ developer who's usually says something like "How this different from what we already have?". P.S. But generally it's OK, i guess, to start with C++17 for quickie-C++, i don't know. In 10-15 years you'll get there anyway, whatever.
If you are talking about [P0424](http://wg21.link/p0424), then it didn't accepted yet www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/#mailing2017-11 However, there is also [P0732](https://wg21.link/P0732) which is accepted and implemented in gcc-9, though right now it is not much usable: https://godbolt.org/z/xV5MLt
What paradigms fits modern CPUs?
&gt;policy/structural/functional modeling How do you learn about that? I can only find vague descriptions of it.
I think they considered moving templates implementation out of headers, but came to the conclusion that it would be too complicated to implement in compilers and that proposal was rejected. See [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1426.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1426.pdf) \&gt;EDG‚Äôs implementation experience has also demonstrated that export is costly to implement; for example, the export feature alone required more effort to implement than it took the same team to create a new implementation of the complete Java language. It's about pre-C++11 \`export\` keyword that was later used for modules proposal. And, if i understand correctly, you still need to provide source code with headers because template still need to be instantiated, which is impossible w/o template body. So \`export template &lt;typename T&gt; ...\` in header is only partially possible, when you have the source code for that function/class. But it would speed-up compilation times, definitely. And it could be acceptable to partially provide source code too in some situations. If modules would do that and could mix source/binary distribution (which i have concerns of), then it would be really f. great.
Okay, thanks! And interesting to hear about the syntax coloration. I'm going to play around a bit with that.
String literals got pulled. See https://botondballo.wordpress.com/2018/03/28/trip-report-c-standards-meeting-in-jacksonville-march-2018/ The idea is that you can use a `FixedString` as a class-type NTTP (via P0732). For example: template&lt;unsigned N&gt; struct FixedString { char buf[N + 1]{}; constexpr FixedString(char const* s) { for (unsigned i = 0; i != N; ++i) buf[i] = s[i]; } constexpr operator char const*() const { return buf; } }; template&lt;unsigned N&gt; FixedString(char const (&amp;)[N]) -&gt; FixedString&lt;N - 1&gt;; template&lt;FixedString T&gt; class Foo { static constexpr char const* Name = T; public: void hello() const; }; int main() { Foo&lt;"Hello!"&gt; foo; foo.hello(); }
Anything that deals with large chunks of contiguous memory and accesses them in an order predictable to the CPU.
right! My bad, thanks.
Right, and that's my point: gcc requires a clobber list (etc.) because, of course, it doesn't parse the assembly language, and instead does exactly what you suggest. And I don't think this is a very good approach, and obviously so. Because instead of getting the computer to keep track of all the details, you're making the human do it. So why not have the computer track this stuff? And I suppose I'd just thought this would be quite an obvious train of thought, with an obvious conclusion, but... perhaps not?
why roll your own error code type instead of using std::error_code?
When juggling multiple error domains (possibly from multiple 3rd party libraries that don't know about each other), you'll get quite high mileage from using [https://en.cppreference.com/w/cpp/error/error\_code](https://en.cppreference.com/w/cpp/error/error_code). &amp;#x200B; There's no way to attach additional context to the error\_code, but in most cases it's not needed.
Thanks for uploading it and thanks for fixing the audio problem with the Anastasia Kazakova talk about the C++ Ecosystem so quickly, an amazing job
[removed]
Or you can return values which are either successful or errors, like `std::expected`, hence forcing you to deal with the possibility of an error.
Pretty much
Although not about C++, [Jez Higgins talk](https://www.youtube.com/watch?v=vw0H16rZW18) on the blockchain is very informative [in regards of the subject] and definitively entertaining.
Curious whether, as an alternative, you could have combined the test files into a unity build to pay for googletest headers once?
Those are three different paradigms. Policy modeling is used a little bit in the standard library (for example, allocator template parameters generalize against the fewest possible assumptions about allocation without sacrificing expressiveness or power), and there are entire languages built around functional programming (only some elements of which are particularly useful for performance oriented C++). The structural paradigm is much less widely documented, outside of memory/high concurrency research, and those fields don't really go into the ergonomics of structure oriented programming. The best way I can summarize it is, try to lay your data out the way your program will access it, and generalize your algorithms around the ways data layout can be variable. This often means, in practice, designing things that look like type-transforming iterators operating on parallel vectors of columnar data, because most performance critical operations are doing one thing to a lot of instances of the same thing.
&gt; For anything that acquires a resource, use RAII. It's a must. I do not want to see another manual Release() call. It's an uphill battle... 1) Spend a week crafting a nice, type-erased RAII framework for different use cases. 2) Use your new shiny classes to clean up other parts of your company's code base. 3) Six months later, realize another team has completely bastardized the code because they didn't bother to understand how your code works or ask you about it (could have just used git blame to see who wrote those classes). 4) Spend another week to hunt down who did it, lecture them about how to use RAII classes, code reviews, etc.
Yes! Complex code is okay, if using it is simple and it works as intended (testing is paramount).
If you save the readme as .txt it won't parse markdown syntax. Use .rst/.md or no extension at all.
Well, I think it does defeat the purpose of one use case: Exploiting machine instructions the compiler isn't aware of.
Great advice; just tested it and it works. One point of contention: Forcing users to specify a compiler flag generally makes libraries less usable, so I think \`-masm=intel\` isn't a solution for everyone.
Nothing really. Some courses combine some programming concepts with OOP. Thats why I added that but yeah let me adjust it.
Thank you, it's a bit ahead of what I know but I'll definitely keep it.
‚ÄúEffective Modern C++‚Äù by Scott Meyers
Tour of C++11 is intended for your situation. &gt; In ***A Tour of C++*** , Stroustrup excerpts the overview chapters from that complete reference, expanding and enhancing them to give an experienced programmer‚Äìin just a few hours‚Äìa clear idea of what constitutes modern C++. Effective Modern C++ is more of a tips and tricks/gotcha collection, I don't know why it's always suggested to devs new and/or coming back...
I‚Äôm curious about the reasoning behind doing a timed release of the videos? I don‚Äôt think I‚Äôve ever seen a conference to that before?
There has always been a lot of "Don't trust my coworkers, so I'm mandating plastic scissors" arguments in coding style guides. IMHO: Forcing plastic scissors is at least half of the motivation behind the widespread adoption of Java and a major contributor to why plain C or C++ as C-with-Classes is so popular in the games industry. A lot of it is PTSD. It only takes one really bad experience to make you want to say "we must prevent this from ever happening again." Bonus points if you are senior and therefore likely grew up in simpler times and are currently in a position of authority. So, yeah. A lot of anti-OOP arguments are strawmen. They are strawmen that occasionally do happen. But, are usually examples of bad practice (and including common bad teaching practices). OOP can be used well. Mixins for composition and policy-based design are great examples. Erlang is popularized as functional, but it is also OOP in Alan Kay's original objects-sending-messages intent. It can also be used poorly. Especially if you just came out of a school that taught bad practices and are excited to experiment with how far they can be pushed.
'Modern' C++ is so complex that I don't know if there could be a 'quick' guide to it. It might be kind of like a 'quick guide to organic chemistry' or something. And, if you think you are depressed now, wait till all of the modernists start telling you that OOP died ten years ago and that only fossils or satanists use it. I completely disagree but you will absolutely be told that repeatedly.
From a functional programming perspective, the deeply nested hierarchies I try to avoid are not interested hierarchies, but graphs of object compositions or references. In many oop systems I can't do much work or testing at all without instantiating 5 different objects and mocking 3 others. It takes great care, planning, and many counterintuitive design patterns to avoid these interconnected object graphs. The anti-oop argument that functional programmers make is that functional designs usually end up simpler in terms of the resulting runtime dependency graph, and it doesn't feel like you're fighting the language to keep it that way.
But of course the modern C++ position is that object composition is always to be preferred over inheritance, so it would almost by definition create a lot of object composition hierarchies.
Or precompiled headers
The fallacy you are making is that it is some sort of messy optimization or that anything faster must be more complicated. The reality here is that it is much clearer that doing the same thing with some sort of inheritance indirection, since the real work and meat of the program happens directly instead of having all sorts of indirection which does nothing but fragment where the real work is happening while also fragmenting the memory and destroying performance. (Also your anecdotes don't mean anything in this context, for many reasons, not the least of which is usage patterns, interactivity, latency and power consumption)
We'd appreciate if you could help us investigate the hangs you experience. DM me if you are interested.
Learn vector, unordered_map, the new 'for' syntax, constructors, destructors, move constructors, basic one argument templates, atomics and threads. Ignore inheritance and everything that depends on it. Don't use raw pointers for ownership. Use cppreference.com as a starting point and try some stuff out on godbolt.org Just these alone will get you a huge advantage over C and make the transition worth the effort.
Another option is [doctest](https://github.com/onqtam/doctest) which is comparable in features to Catch and is very fast to compile.
I love it, NDC, CppCon and others upload all the content at the same time and Jesus, the feed panel is a mess, you dont know what to look, so many choices in so little time means it is garanteed you will loose some videos behind that you may be interested Releasing a few each day makes sure i can choose rigth as i can only has to make the decision between 3 or 4 videos daily as much, so if i want to watch 2 and i cant today i can note it for tomorrow, it is great, i hope others confs do the same And they release in "direct" mode so you can talk with others viewers, i know it is rare and the chat it is not very well used but i like it, in cases where the speakers ask to the public you can put your opinion there if you want and see how others are doing or express yourself, [The speaker] "We will make C++ Great Again" [Me on the chat] "Yeah, better than ever" for example I love how they are doing and the audio problem was fixed in less than 24 hours so Bravo to them, 5 of 5 in my opinion
I‚Äôve worked on a 30+ year old C/C++ codebase which fell into object hell, and really showed me why people think that way about objects. A lot of it came about because adding even more virtual and implementation inheritance was the lowest effort way to get some new feature added yesterday, and over time the code got 10+ level deep multiple implementation inheritance hell since there was no time for refactoring. Well done OOO is much easier to accomplish with small teams who share a common goal, want to write sane code, and don‚Äôt have a lot of nontechnical management pressure to ‚Äúget this feature done yesterday, why would you waste time on this pointless refactoring or ‚Äògood code‚Äô thing‚Äù. It sounds like your situation is a lot like that, and you‚Äôre able to make good use of these features.
`.md` means markdow! I'm an idiot...
The example needs a defaulted `operator&lt;=&gt;` for `FixedString`, though GCC didn't support that part yet last I tried.
Question for all those who have moved away from GTest/GMock: What about matchers from GMock? Did you just write your own matchers (like `UnorderedElementsAre`)? I may have missed something, but I haven't seen any other testing framework with matchers that are as extensive as those available in GMock.
The last paragraph applies to any kind of programming really. My ideal team size is 3.
&gt;And, if i understand correctly, you still need to provide source code with headers because template still need to be instantiated, which is **impossible** w/o template body What is likely impossible is evolving in a backward compatible fashion and doing this. I don't claim that the standard committee made the wrong decision. Their job is to steer the evolution of the language that is C++. On the other hand, I do claim that a fucking ridiculous amount of redundant work is done every compile to process header files that have not changed. I want my genetics meta-programming **and** fast compile times! &amp;#x200B; I am pretty sure I won't get this from a C++ like language in my lifetime because I think (pure intuition here) that it would require starting from scratch with the goal of making a C/C++ like language that had the fastest possible compile times. In particular, the fastest possible generics compile times. I want a language where unity builds are clearly a very stupid idea rather than a reasonable response to very long compile times. Imagine a new language called C+=. It is a redesign of C++ that tries to preserve the spirit of functionality but has no concern for backward compatibility. One idea that both vanilla C+= and templates could benefit from is: 1. human coders do not make separate headers and source. They edit a single file and the compiler tool chain generates headers any any other intermediate files needed. e.g. you write aaa.src and the toolchain generates aaa.hh, aaa.o, and whatever else is needed. Should the toolchain generate one aaa.hh or multiple (e.g. one per class defined in aaa.src)? i.e. aaa/foo.hh for "class foo", aaa/bar.hh for "class bar"? A source file bbb.src needs to be able to refer to published interfaces of aaa.src but with the toolchain generating the interface description files and other files, published interface can be made as small as possible. E.g. there could be both * aaa.hh // human readable description for the benefit of the human writing bbb.src * aaa.hx // what the compile actually grabs when you say "#include &lt;aaa.hh&gt;" &amp;#x200B; furthermore, you can imagine that when bbb.src is compiled, the generated interface files (bbb.hh, et cetera) do not include anything from aaa.hh that is not necessary to describe the interface to bbb.hh. E.g. if bbb.src has &amp;#x200B; class Bish { public: transmute(const vector&lt;uint8_t&gt; &amp;lead); private: vector&lt;uint32_t&gt; _uiv; shared_ptr&lt;char&gt; _cp; // ... } you can imaging bbb.hh having the minimum information required to say that Bish::transmute() takes a vector&lt;uint8\_t&gt; type parameter but not a complete description of all the vector&lt;uint8\_t&gt; methods and implementation and no mention at all of type vector&lt;uint32\_t&gt; or shared\_ptr&lt;char&gt;. I.e. ccc.src that "#include &lt;bbb.hh&gt;" does implicitly #include * \#include &lt;vector&gt; * \#include &lt;memory&gt; instead, bbb.hh and bbb.hx include the bare minimum information about the type of the "lead" parameter of transmute() directly. C++ is a huge language and redesigning it from the ground up would be a herculean task, which is why I don't think this will happen. I love many things about C++. The APIs of C++ standard library is a thing of beauty. The power of the template system is great. It is wonderful to have Python language type data structures (maps, strings, smart pointers of various flavors) available in a language that runs much faster. OTOH, having tasted lightning fast compile times in the C realm, I want the best of both worlds.
In C++, composition isn't as bad as it is in Java, since the object is inside the bytes of the parent object rather than indirectly pointed to. Pointer-chasing is the real evil of OOP. Not that it doesn't also apply to non-OOP, but OOP strongly encourages it.
Both inheritance and composition create dependencies between multiple classes/objects, and using the resulting functionality requires understanding multiple classes at once. If those classes are stateful (likely) then the challenge to understand everything is that much more difficult.
I think UI represents probably one of the best (if not the best) fit for OOP. I think your approach is totally fine and I am always struggling to express UI in a non-OOP way offering the same promises to avoiding code duplication and easy to extend. Most of the OOP (well deserved IMO) critics come from how hierarchies are often forced to model problems that would be way better served by "flat" solutions.
Ironically , there's a vocal segment (here and on other forums) that's trying to do the same plastic scissors thing with "modern C++".
Some programming languages/frameworks enable a plethora of styles, while others are highly opinionated and herd programmers to one particular style. The latter will result in a more coherent codebase in the absence of a strong engineering culture within a team. This effect is particularly visible in c++ where so many programming styles are possible, and historically so many styles have been used. Knowing that someone programs in c++ doesn't tell you all that much about what their code will look like.
Personally "modern C++" is more about reducing cognitive load.
A Tour of C++ https://www.amazon.com/dp/9353068088/ref=cm_sw_r_cp_apa_i_pijXCb4CA57CY
Ideally people would go "Hey, we have these new features nowadays. You should see if they can simplify your code." What instead happens is arguments of the form "This is not Modern C++ and therefore it is bad."
Someone who has come to the city first time needs a tour first. He must not get missed in details. So https://www.amazon.com/dp/0134997832/ref=cm_sw_r_cp_awdb_t1_FjjXCbC9VH5HS should be a good choice to start with.
I totally agree. I think that‚Äôs why languages like Go have been so successful with large teams. They‚Äôre designed to force everyone to program in a particular way, even if it may not be the most elegant or clever.
As a relatively new developer (\~5 years in industry), I think it comes down to how people are exposed to OOP: &amp;#x200B; 1. OOP is taught in schools very conceptually and without much application to practical problems. For example, we learned basic algorithms like searching and sorting at the same time as structured programming, and functional programming was presented as an elegant way to implement interpreters. OOP was just toy hierarchies and design patterns without motivating applications. The Java AP test is a particularly egregious example. 2. Many of my peers have been asked to design these deeply nested hierarchies in interviews, like the classic "design a zoo" problem where candidates are expected to make each animal it's own class inheriting from shared features like Carnivore or Swimmable, then asked questions like "How would you model an amphibian?". Again, the hierarchy is the goal rather than solving an actual problem. 3. Real world codebases are messy, and since most new grads will be working on OOP codebases they conclude that OOP is messy. It's easy to feel that the grass is greener on the other side when the only functional or reactive or whatever code you see is in the form of short demos.
Recursive data structures are a good fit for class hierarchies, especially when the set of nodes needs to be readily extensible. UI is a good example. Structured data like XML or JSON, ASTs, ... same fit.
I believe the backlash against OOP is driven by three main factors: 1. The curriculum first teaches the basics of declaring variables, arrays and performing control flow (if, else, do, while, for); then the curriculum proceeds to teach OOP; finally it teaches some OOP-based design patterns 2. Because it's the main trick they've got up their sleeve to create a layer of indirection, programmers proceed to apply a subset of the OOP principles while violating another subset of the OOP principles. Namely, they rely on the dynamic dispatch to create the layer of indirection, but they violate the is-a relationship and they violate encapsulation. You end up in a situation where the logic in the hierarchy is tedious at best and you need to carefully invoke the classes's methods in the correct order to avoid corrupting poorly encapsulated objects. In the end, the spaghetti only makes sense to its original author and nobody likes inheriting a spaghetti codebase. 3. There are other ways to create layers of indirection. Some of them are older than OOP and some are more recent. Using the right tool for the job helps avoiding the creation of more spaghetti while delivering more performant and more robust code. This subreddit brings together a lot of people who know various such techniques and they are very critical of OOP because of how overused it is. Yet, they aren't saying OOP should never be used. Even though I am critical of OOP myself because of how misused it can be; I recently had a case where someone wanted to optimize a derived class that holds a collection of things for the case where the collection is only ever going to hold 1 item. Here are three versions of the code to summarize the story. ``` // Original unmodified code class D : public B { std::vector&lt;T&gt; elements; }; // First design to optimize the case with N = 1 class D : public B { union { T* a; std::vector&lt;T&gt;* b; }; unsigned short size; }; // Better design to optimize the case with N = 1 class D : public B { std::vector&lt;T&gt; elements; }; class E : public B { T element; };
Yes, they're still working on spaceship (Tim van Deurzen was working on it, though I'm not sure how close it is). AIUI from Jason Merrill's commit for P0732 support, g++ will add the check for defaulted spaceship once it's available, but for now is acting as if it was (recursively) defined as defaulted, so ... uh, don't shoot your own foot off I guess. The name mangling looks similar to how you'd separate out the data members into individual NTTPs currently, e.g. `3FooIXtl11FixedStringILj6EEtlA7_cLc72ELc101ELc108ELc108ELc111ELc33EEEEE`.
How can a programming language have a position? It‚Äôs a toolchain type thing, and that argument is like saying tunnels are always better than bridges. As with building architecture, the important thing is that the overalll structure is solid and self-consistent, and integrates well with its larger environment. Software architects should not have to conform to any kind of dogmatic norm, such as never using raw pointers and never using new and delete, even if smart pointers make more sense in most cases. Point being, if the overall structure is fundamentally flawed, changing the coding style isn‚Äôt going to fix it. Instead tear down and rebuild from scratch!
It sounds like you are using OOP responsibly. However, I would tend to argue that with concepts or with sfinae, it is possible to avoid most of OOP. An additional benefit of this is that you can move away from a reference / pointer access style and move towards a by value system. The template stuff adds a lot of complexity, but the benefits are pretty high.
https://youtu.be/2bLkxj6EVoM
\&gt; "Ignore inheritance and everything that depends on it. Don't use raw pointers for ownership." What do you mean by ignore inheritance? I understand the raw pointer arguments especially with how intuitive smart pointers are, but i'm lost on how the former statement is good advice I'm relatively new to C++, Just need some context
Inheritance is rarely, if ever a good way to design a program. It mostly obscures where work is being done. It could have been argued in the early 90s that it was a decent way to do more generic programming, but the reality is that it adds complexity, indirection, fragility and slows programs down all at the same time. Now with templated data structures, I think it is extremely rare for it to be a good architectural path to go down. If you want, you can give an example of where you would use it and I can describe what I would do differently. Basically instead of the base and child classes, I start with vectors of structs.
You will find lots of people around here who will argue to the death that doing a JSON value hierarchy via inheritance is evil and and abuse of OOP and various other things possibly involving impotence and hair loss and such. They will argue that 80s still switch statements (even if dressed up as templated variants) is the right thing to do. I will agree that either can be done, but I don't remotely agree that doing it as a class hierarchy is bad in any way.
When C++11 hit everybody on stack overflow was suddenly hostile towards people who used as much as a one `char*`
It's not a programming language of course, but a set of people who argue these things. It's becoming a bit of a cult.
That sounds like a good idea but my raspberry pi can't open markdown files natively. However I will make that file extension change as soon as posable by using Meson rename file keyword when the platform detected is ARM.
On r/cpp_questions, almost anytime someone asks about raw arrays, they are met with "this is not C++, this is C". I have to always correct them that it is indeed valid C++.
Isn't that just being pedantic? The idea is that you are using C++ and should be leveraging C++ to write strings, not that it literally wouldn't compile.
But it's all really somewhat of a hack, and has to be manually enforced. To me, if I were looking to use C++ in a completely different way from what is was originally designed for, I'd be looking at other languages that incorporated these features in a fundamental way, where there's a fraction of the complexity required to do these things and you can't not do them by mistake. A problem with SFINAE, to me, is that I bet few people actually understand either the detailed rules or the sequence of actual resolution events that makes their code work they way it does. Since the whole system is designed to try to automatically find something that works syntactically, it just seems like a bit of a house of cards to build a large system on. Not to mention you may get the Declaration of Independence as a compiler error message at some points.
I wasn't saying this. I was just saying C++ is much more than C with classes. That is the wrong way to look at C++.
If you are good with sfinae, you can actually direct your users to your own compiler errors. Concepts should really do a lot for the syntax. I think concepts takes the idea from a (powerful) hack like you said to a core language feature. Tooling support should follow. I really think concepts is a game changer.
Yes that the abbreviation for markdown and no your not an idiot.
Imho Erlang is a bad comparison. It‚Äôs sort of Actors Model based as I see it. And A.M. is very good at scaling and such; much of modern stuff seems to converge to it. In my young and short experience there was only one incident where someone suggested OOP to be bad practice due to being slow and it was in relation to it‚Äôs usage in Python.
 - Use a good book to learn this language - If you use exceptions, make exception safe code, or at least try so. - Validate the parameters of your functions - Learn `&lt;algorithms&gt;` and `&lt;cstring&gt;` - `this` is not needed everytime - `using namespace std;` **NO**
It's just a text file, as far as I know Linux doesn't care about file extensions
Done with changing the file extensions. If you see anything else out of order than I would love to know. And thanks for your feedback.
Python++
Did you try to open a markdown file natively on a raspberry without installing third party application(s)? Know raspberry has a PDF viewer but what about markdown.
Seems like clang segfaults on it: [https://godbolt.org/z/AUAW9J](https://godbolt.org/z/AUAW9J)
I'm very familiar with the "cult of the one true way". Anybody in this forum arguing absolutes is simply failing to understand the breadth of design choices offered by the language and their relative costs and benefits.
No I meant that you could open and edit it as a simple text file, like you already did.
Because you have to `delete` it manually. As your codebase grows, you are likely to get all tangled up in managing object lifetimes.
The martyr act is starting to get a bit old.
The problem is lamda in template.
doesn't run in C, and isn't quite the same
Sorry for the misunderstanding and yes I have Nano and Vim on both Mac and Raspberry Pi. My problem was that the end user wouldn't be able to open that markdown file by double clicking it. I guess I can't cover more than 99% of all problems.
At a company I've worked for we successfully used clang_cl to link against Qt on Windows. It was a bit of work, as we used qmake, but I figure it's simpler when you use CMake. We specifically needed it for minidump support so we could easier debug crashes that happened on client machines, and those worked pretty much perfectly.
It's equally pedantic to say that it's C, not C++. `char*` have their own place within C++.
Do you think that's what people intend to do with this, when they are just starting to learn C++ and ask about using arrays and strings? Maybe some of the time, but the vast majority I've seen aren't.
To be fair I'm responding to the idea that people would say "this is not C++, this is C", as opposed to "this is how you'd do it with `char` arrays, but this is how you'd (easily) do it with `std::string`". This is like a super personal chip on my shoulder but I just remember how frustrating it was a while back to look for things on stack overflow and to be met with a deluge of answers to questions that was "don't" rather than "this is how, but perhaps don't".
Nothing to do with being a martyr. He said he already knows OOP and is presumably assuming that that is a big part of 'modern' C++. I'm just giving him a fair warning of what he's likely to run into. I think that's a reasonable part of the overview process.
&gt;Don't use raw pointers for ownership. Vector and string have been using raw pointers for ownership for many years. And as Howard Hinnant [pointed out on StackOverflow](https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception), raw pointers can be used with delegating constructors for good news. I use unique\_ptr, but not very often.
Correct me if I'm wrong but those don't seem to replace OOP in the way that they doesn't make the code easier to read or write do they? It looks like a focus on how data is used but really it's about performance. I don't say that performance isn't important but OOP can make complex projects easy to use
Believe me, his position is not universally held. He's part of the 'OOP is bad' faction of the C++ world. Take it with a large grain of salt.
&gt; doesn't run in C 1. the article starts with arguments against exceptions, which don't run in C either 2. the example struct error_t doesn't compile as c either because of the is_error() member function &gt; and isn't quite the same agreed, but what are its advantages? a big disadvantage is that it can only represent one error code, -1.. or is the calling function supposed to parse the 'details' string to decide how to handle the error?
That‚Äôs part of the confusion. When people complain about OOP, they usually have Java in mind. They complainers include the inventor of the term, who had something much more like the Actor Model in mind.
I never heard the metaphor of "plastic scissors" before, but I love it. I have some trouble articulating my dislike of this culture in see in some teams
Shameless plug: https://github.com/AnthonyCalandra/modern-cpp-features
Don't care that much. If you care about build systems, managing repositories and developing projects, a simple README wouldn't bother you.
[https://godbolt.org/z/Pq9Iqi](https://godbolt.org/z/Pq9Iqi) But it's always good to segfault compiler, good job, clang still can't compile this. I think it's a sort of bug that compiler create a dedicated lambda for every template instantiation instead of squashing them into one. But it's not like anyone is going to fix this, maybe in C++89, \`static constexpr\` in template parameters, or \`inline\` in template parameters, idk.
Unless the rest of the logic is significantly different between D and E, this is exactly an example of the wrong use of OOP. A much better way would be to use something like boost::small_vector.
&gt; The type of the lambda-expression (which is also the type of the closure object) is a **unique**, unnamed non-union class **type** Each blackmagic() call gets its own call to fn with its own []{}, and since each lambda has a unique type, the decltype of each blackmagic() call result will be unique. If you only create 1 lambda, the static_assert passes constexpr auto X = []{}; template&lt;auto V = fn(X)&gt; constexpr decltype(V) blackmagic() { return {}; } or constexpr auto Y = fn([]{}); template&lt;auto V = Y&gt; constexpr decltype(V) blackmagic() { return {}; }
Can't wait for the day where I can click godbolt link on mobile and actually be able to read it.
Tell me how you would do [what Sean Parent does](https://youtu.be/QGcVXgEVMJg) differently.
A lot of the time "This is not C++" is said about any raw pointer, not just string handling. It's not like std::string is particularly new anyway.
Much more than C with classes, and also much more than an OOP language. Qt, as far as I'm concerned, isn't C++, it's another idiomatic language that happens to share the same linguistics origins and script, but has diverged to the point of lacking mutual intelligibility.
Code smell
From the creator of fmtlib.
Just get Whole Tomato's Visual Assist Plugin. VS + Visual Assist is pretty much the best IDE experience you will ever get.
I use VAX daily and can't praise it enough. Intellisense still hasn't caught up ( VS 2019 ). At this point, MS should buy VAX and call it quits.
lol, Windows alone takes 12 hours to compile from what I've read. you're talking about recompiling literally EVERYTHING.
I would never pull in a new external dependency just for a single optimization opportunity.
An additional concern is, that if your application is performance-sensitive, then you might want to avoid OOP, because it can be harder to make run fast. The reason is objects are rarely (ever?) data-oriented.
You can always roll your own, the point is that if the only difference between D and E is that you don't want a heap allocation for a single element, it should be abstracted at the container level, not the user class level.
It's entirely unsurprising that you don't think criticisms of overly complicated/convoluted structuring don't apply to your own code -- after all, you wrote it! Try seriously delving into a java codebase that has been worked on for 10 years by a dozen different people or more, and is full of beans, factories, providers, builders, injection, immutables, ...
I'm fine with that. If all the folks who come into all these threads saying OOP is bad and void it at all costs would qualify that by saying, "because I don't think you or my team or half the programmers on the planet have the skills to do it right or the ability to stand up to management" or something of that nature, I'd not say a thing.
It is. I understand what the commenter is trying to say, but the beginner doesn't. As others have mentioned I'd prefer: "the idiomatic, tried-and-tested, conventional way to solve this problem is X".
It is. I understand what the commenter is trying to say, but the beginner doesn't. As others have mentioned I'd prefer: "the idiomatic, tried-and-tested, conventional way to solve this problem is X".
While it's obviously the case that any higher level construct may be less performant to one degree or another, it's also the very well documented case that very little of your code typically contributes to the performance of your application. So arguing not to use OOP because it has performance penalties is one of those statements that is both true but ultimately not terribly important. Find the likely quite small percentage of your code that is causing performance issues and optimize that. You will get big benefits in return. For the rest it's not going to make any significant difference, and you are likely wasting time and effort to worry about the wee bit of performance difference and added complexity that doing some sort of data oriented approach would involve.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bi480m/looking_for_intro_to_c_book/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Clearly the next attempt at a high-quality library aimed at eventual inclusion in the standard.
&gt; Not to mention you may get the Declaration of Independence as a compiler error message at some points. I laughed because it is so true
We're not talking about "everything", we're talking about building all the dependencies for a specific project. In my case, Boost, Qt5, and a number of other open source libraries. For all three toolset combinations combined, it was about six hours of building from scratch. After that it's periodic incremental updates. It's much faster on Linux or BSD. You can rebuild the entirety of Debian in around 18 hours; much less if you have a beefy multi-core threadripper or Xeon. And a bit longer for the BSD ports (there are more of them). Both have tools to automate this, such as sbuild/schroot and poudriere. The BSD ports in particular make ABI changes easy to automate.
You need to make your array 1 bigger, or change `&lt;=` in your for loop to `&lt;`, because at present you are iterating `noHands+1` times
Well, as with all things, it's not that black and white. If you want, you can make a positive argument for just about anything, including e.g. using raw pointers or what have you. The 'you/your team are just not smart enough to deal with it' argument can be applied to just about anything. Seatbelts? Just don't crash your car. I don't think management is particularly relevant in this discussion -- management tends to throw a wrench into the gears by adding scope creep and tight deadlines, they won't tell you how to structure your code. But whether in practice something is wise to use, is another matter entirely. Just like with anything else, software is a product of circumstance. When I start projects these days, I enforce pretty rigorous guidelines -- e.g. no checkstyle violations, no error-prone violations, don't reduce testing coverage, everything is CI, etc. Knowing the projects will live on long after I've left them, and a menagerie of developers will work on it that all know, value and are ignorant of different things, it's important to set a solid set of ground structures that allow the project to still be navigable after a couple years of development. This is really important because 1) onboarding new people into the project is pretty important (especially when you know there's going to be a lot of rotation between projects, and 2) because the ability to cross-functionally improve code is very useful (kinda the same as 1) just with a different hat) and 3) maintaining flexibility and re-usability can be tactically important. When just looking at your own code or having a fixed team with no rotators, you will never suffer from these problems and possibly not even be conscious of them (which can be fine for some projects) -- but they are an extremely important part of making software development scalable (which will likely start to take on a larger and larger role in your career as you progress as software developer and become e.g. a tech lead of projects of increasing scope etc) With OOP of course it's even more ambiguous, because OOP is really a bag of principles (and what goes into that bag depends a bit depending on who you ask) -- some of those principles we unequivocally all agree on are actually pretty good, and others which are now often de-emphasized (e.g. inheritance -- now often composition is a preferred approach, or nominative typing -- now often structural typing is a preferred approach). Only very few people from the more radically opinionated end of e.g. FP communities I think will really claim that OOP is all bad, as with most things it's really another instance of KISS (keep it simple, stupid). Lastly, I think languages that emphasize OOP less are often simpler not necessarily because of OOP as such, but because they place bigger emphasis on a small number of easy to understand core types that can be composed rather than abstracted, such as tuples, lists, structs, strings etc. Take for instance python, go, typescript or similar. You got this function that converts a set of uuids to a set of usernames -- what do you pass into it? well, a list of strings, obviously. And then it returns a list of username tuples, probably. What would you pass into it in e.g. java? Perhaps a `FlexContainer` of `ImmutableUuidInstances` that is built through a `FlexContainerFactory`, which you cannot obtain unless you inject it. And then what does it return? A `Provider&lt;UuidToUsernameQueryResponse&gt;` perhaps. What's a provider do? you probably don't know, so you just call `get()` on it and hope it's not important. But now the surrounding code where you need all of this wants to give you an `ImmutableList` of `String`s rather than a `FlexContainer&lt;ImmutableUuidInstances&gt;` and it wants you to return to it the result as `AsyncPromise&lt;List&lt;Pair&lt;String, String&gt;&gt;&gt;` perhaps rather than as `Provider&lt;UuidToUsernameQueryResponse&gt;`. So now you end up spending most of your time writing adapter code (I guess that `Provider` thing did matter after all, but how do I turn it into a `Promise`?), wading through pretty deep hierachies (of course each of these classes is in their own file, so there's like a million) and half of these classes are really kinda impossible to understand because they're actually just interfaces or auto-generated code and it's difficult for you to figure out what the actual underlying implementation is. This kind of situation is definitely something I've wasted a lot of hours on. In go or python on the other hand, you'd probably get passed a list of relatively simple things, and you'd be expected to return a list of relatively simple things. It's not that it's impossible to write code the same way in other language, but it always comes down to the culture.
I understand your frustration with compilation times, especially compared to C. At my former workplace i had days when i had to spent 50% of work hours compiling source code. But i assure you that this was 5% language fault and 95% project management fault because i was able to solve similar problems in other projects with not that significant effort. Housekeeping on code base and optimizing includes for compilation time helps, but it's not always possible with third-party dependencies. I can definitely suggest to install \`ccache\` or analogue, it saved me many man-years. I can only hope that continuous improvements to the language will lead us somewhere where this problem is significantly mitigated because i don't see rewriting C++ as a viable option. I honestly don't think modules will help a lot in that field, but we'll see when they arrive. If you wouldn't think of modules in C++20 as of a finished work, but rather as of test-bench for further development, maybe you'll see my point. This is BTW exactly why C++ is conservative. Things are being added, removed and changed. Who could have thought that such great feature as template body in separated compilation module will be added in C++98, then removed in C++11 and then something else will happen.
Basically from the patriarchy and the notion that hard work is a justifiable enough means of discriminating people's values. The structure of culture works in a way to reproduce and sustain itself. This structure produces inequality as every structure is a means of discrimination, and for the existence of hierarchies we need to to discriminate one individual from the other. Furthermore, within our culture there are hierarchies within hierarchies, in a similar to octaves in a musical instrument, in which one needs to "level up" across each hierarchy degree within a super-hierarchy which contains it. There is always a hierarchy within another hierarchy. One could argue that the first and most high-level hierarchy is the sexual hierachy.
Accelerated C++ Barbara Moo is pretty good for that purpose.
It makes architecture easier to get right. And eliminating most inheritance hierarchies, and making membership by composition, with most interfaces being generic, rather than OO, does make application code much easier to read. It does, admittedly, sometimes make library implementations harder to read, but that's still better than trying to chase down inheritance soup.
Hi there germandiago, &amp;#x200B; Here is the link to my hexdump GitHub page: [https://github.com/tanveerasalim/TSCD](https://github.com/tanveerasalim/TSCD)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bi63tk/how_to_learn_qt/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That‚Äôs certainly true. I think it is seen a lot with objects since we‚Äôre still coming off of the glory days of java and big design patterns, where people cargo culted on java style OOO and did everything via inheritance, and these code bases now have really had time to rot.
\&gt; So it's always been possible to use OOP in C++ in a compositional way, and not create huge hierarchies There are some people here who vehemently argue that composition doesn't work and that inheritance hierarchies for convenience is the only way to go because they don't understand the tools the language gives you. I think the message got a bit lost in that it's not OOP that's the problem, but the abuse of inheritance for convenience when there are other tools to use. And I'm not talking about switch statements.
Oh, you won't get any argument from me that Java, C# and C++ are all way over-engineered at this point. I think that's partly an inevitable result of having them driven by many people who are interested in languages and abstractions for their own sake and not just looking at the language as a tool to make stuff blow up real good, and of course just old fashioned feature creep. And trying to Always Be Expanding so as to stave off any claims that the language is moribund, same as all products.
Thankfully I somehow managed to avoid ever working on that era of software. Either I worked at places where the software was too old, using C++ as a souped up C, or too new and people had learned about these problems.
Imagine what we did before stack overflow existed.
I remember learning C++.NET from a book, which makes me feel old in several ways :-\
I would argue that composition doesn't work that well just by itself. There are clearly lots of things that have a definite is-a relationship where it's extremely powerful to deal with them polymorphically. Then use mixin type inheritance for optional functionality where appropriate. So, if they were arguing that mixin interfaces alone don't work, I would sort of have to agree. Or at least argue that only using that style means leaving a significant weapon in the rack unused. If they are arguing that you shouldn't use mixin interfaces, I'd disagree. The main inheritance hierarchy in some family of classes really should be IsA type relationships. Stuff like Loggable or Streamable or or Hashable or other things like that are infrastructure slash housekeeping functionality that are not really intrinsic aspects of most the things you'd be modeling or representing by a hierarchy. In the cases where that's actually the case, just mix in the interface into the base class of that hierarchy and the whole thing supports it and those things can still be passed to any interfaces that expect a hashable or loggable or whatever interface.
&gt; "Is C a subset of C++? Is C compatible with C++? Do they get compiled differently? How do I know when I'm writing C and when I'm writing C++?" No. No. Yes. If you compile it with a C++ compiler, it's C++ [possibly it's also (valid) C, but since you compile with a C++ compiler, that's irrelevant].
Because the paradigm lends itself to deeply nested hierarchies. If my goal is to fix a problem or implement a new feature and adding another layer of abstraction solves this the most easily way then I'd consider it. If I don't care about the codebase because my job doesn't reward me caring about the code base then I'm going to take the easy route. Do this repeatedly over years and you end up with garbage.
I have done this in the past precisely because the logic was significantly different between D and E :)
I legit have no idea what a class hierarchy buys you for something like JSON. There's a very small and finite list of data types possible (which doesn't change), and these data types do not have a common interface. On both measures, it's a far better fit for variant or other sum type, than it is for inheritance. I say this as someone who, to be clear, is not as down on inheritance as many in the C++ community. There are many problems that I've seen solved with inheritance and I really thought it was the best way. I'm familiar with many of the benefits of inheritance, and I don't honestly see how it buys you anything at all in this case. Can you give an example of any benefit of an inheritance based approach to json data over a variant based one?
It's because there is basically no reason to use raw arrays in C++ (at least starting with 17 where they finally finished constexpr'ifying all of array). There are well understood problems with C arrays, many/most of which std::array solves automatically, with basically no downside. No doubt this is why people say that, although hopefully they are saying it in a more helpful way than that.
People who make those arguments should feel bad, but I really don't see people give those reasons very often; maybe they use it as a shorthand when they don't want to get into the bigger reasons, or maybe you just don't agree with the reasons they give and you interpret it that way. I don't think any of the mainstream "modern C++" advocates are trying to put plastic scissors on C++, so it's just bizarre to characterize them that way. In fact C++ has repeatedly chosen performance and expressiveness over safety, in "modern stuff" too, IME. Personally, if I am telling people to use std::array over a C array, or span over pointer + size, or std::byte over char, or scopeguard over god knows what, there are very specific technical reasons for all these things that I can explain. Not that modern C++ is something that magically deserves to be used for its own sake.
Nothing works well "by itself". The point is there are many things that aren't in a is-a relationship that people still want to use inheritance for because they don't want to learn anything better. Things that have a really well defined meaning of IS-A (such as Liskov) do really well with inheritance. Other things are just similar in some aspects under some operations but are otherwise unrelated. These cases inheritance aren't good for at all, and there are better language/library features to take care of that stuff.
The reason creating E was a good choice here was because a class hierarchy already existed with some base B, a derived class D, multiple other derived classes that were not mentioned. In short, polymorphism was already used to have a subclass with a collection of things. Adding a new layer, in this case the `union`, to optimize for the 1-element case was the wrong choice.
I quite like Exercism. There's a range of languages available and you can see how other people have implemented the same challenge. It also introduced me to Boost Test. https://exercism.io/
There are many websites you can use for such exercises which may or may not contain solutions to the problems. Just do a Google Search. Websites with solutions: leetcode hackerrank hackerearth geeksforgeeks (best) Websites without official solutions: (But you can see submissions by others) : codechef SPOJ topcoder UVA USACO And many many more ...
I really like project euler, its heavily math focused. no need for having a UI, just console outputs.
Personally I find it a lot simpler than std::error_code stuff.
I have absolutely seen object dependency hell, and it is very much not fun to work in. It was bad enough for me to reject basically all inheritance in my own code for a long time, and I still reach for alternatives to inheritance even today, except when the relationship is very clear there should be an IS-A relationship between two classes.
Does \`target\_compile\_features(client-test PRIVATE cxx\_std\_17)\` silently upgrade the standard of simply fails to build? If it silently upgrades, it's malicious because will introduce incompatibilities.
There are usually several ugly things arising from inheritance from a stateful base class. If you derive from a class you need to know the inner workings of the class you derive from. Some functionality might depend on a class member being set correctly. This completely violates the principle of [information hiding](https://en.wikipedia.org/wiki/Information_hiding) and brings us back to the time where to understand code you also need to understand a lot of code around it. And worse: If you change a base class you will most likely break derived classes. This is called the [fragile base class](https://en.m.wikipedia.org/wiki/Fragile_base_class) problem. In my opinion this isn‚Äôt about trust in my coworkers, as I know all those problems will arise even if I‚Äôm the only one working on the codebase.
And this is one of the reasons, why I said "might". It depends a lot on how your code is structured (especially for that 10% of the code that runs 90% of the time).
Totally agree with this. UI code always ends up being really messy because it has to deal with so many intricacies of the human psyche, and the end result has to look 'seemlessly sophisticated'. OOP is the best-fit paradigm, but it does mean that you have to work hard when making modifications to not lose track of the overarching architectural philosophy.
&gt; In certain cases, the second assignment will cause Python to store a reference. No, in *ALL* cases the second assignment will cause Python to store a reference. Python's object model does not allow assignment to be customised. In C++ language, there is no ability to overload the assignment operator. In Python language, there is no `__assign__` or similar. &gt; which is altered for both a and b in the second statement. I don't know what you mean by this exactly. But if you mean "the assignment to `a` changes the value of `b`", then that is incorrect, because `b` is guaranteed to continue referring to the old object while `a` refers to the new one. This applies even if you are using mutable objects like lists rather than immutable objects like strings and numbers. Perhaps you're thinking of statements like this: a[2] = 7 a.someattr = 8 This is fundamentally different in that it is not simply putting a reference to an object into a variable, but instead is modifying the value of an existing object. Statements like this *can* be customised by the class, by having an appropriate dunder method (`__set__` and `__setattr__` respectively).
Most of your list aren't formatted as such, making them very very hard to read.
Old reddit bug? I used markdown.
&gt; everything is a reference (sometimes) Everything is a reference *always*. You can just sometimes forget about the fact that some things are a reference because they're *immutable*. Take this example: a = "foo" b = a What if we modify `b` now? Will it affect `a`? Obviously if you just assign a new value to `b` it won't have an effect: b = "bar" Because this has just updated the variable b to reference a different object. But what if you modify the object that `b` refers to? b.reverseinplace() Yes, of course, this would effect `a` for the reasons we discussed. The same even applies to integer objects: a = 4 b = a b.negateinplace() # a and b are now both -4 There's one common problem with the above examples: the `.reverseinplace()` and `.negateinplace()` methods don't exist. In fact there are no methods on `string` and `int` objects that modify the object. Classes with this property are called *immutable*. You can treat them a bit like you're assigning by value, because if multiple variables are really referencing the same object then no possible harm can come of that. Another class with this property in Python is `tuple`, although beware that after `a=(0,[]);b=a`you will have `a[1]` and `b[1]` referring to the same mutable list. If you want to copy the actual object, rather than just update the reference, you use the [Python `copy` module](https://docs.python.org/3/library/copy.html). Both shallow and deep copy functions are available. For dictionaries and lists, you can also take advantage of the unpacking operators: a = [1, 2] b = [*a] # different list with same value b.append(3) c = [*a, 3] # different list again, but simpler than above two lines x = {'1': a, '2': b} y = {**x} # different dict y['3'] = c z = {**x, '3': c} # again, different to y, easier to write # beware that x['1'], y['1'] and z['1'] all refer to same object
Nope, integers are objects, and behave the same way that other objects do. They might appear to be assigned by value because they're immutable (see my reply to /u/rar_m's comment) but they're still references to objects and you could write your own custom class that behaves exactly the same way.
This is the proof that software engineers (including myself) suck at naming things. Launder and Bless are really unfortunate names
Old reddit markdown still works. You probably need double newlines before your list.
In my experience there is no practical problem to be solved. Rather, the solutions to the *formal* problems (like `launder`) seem to be designed to ease the life of compiler writers who want to implement snazzy optimizations that rarely if ever are needed, at the cost of application programmers having to work harder at working around the silly obstacles. Result: more time wasted by programmers worldwide on writing more verbose and impenetrable code that's neither faster nor safer than what one would have with more practical rules. I guess as a result there will be a migration to C. It's just more practical, even if it doesn't generally support abstraction.
You need a newline before a list in Markdown. New Reddit doesn't seem to deviate Markdown in this respect.
According to https://cmake.org/cmake/help/v3.14/command/target_compile_features.html an error will be reported if the feature is not available.
Uh, it says "If the use of the feature requires an additional compiler flag, such as -std=gnu++11, the flag will be added automatically." That's bothersome.
It's the goal of this option, because it's will automatically add this feature on all the available platform (for MSVC it's an other flags for example). You think it's too much intrusive ?
What if you set your package manager to C++14 but CMake silently upgrades to C++17? I think this will lead to nasty linker errors eventually.
Edited the post. Does it display correctly now?
Conan is aware of the c++ standard, and will report an error if there is a mismatch with compiler settings detected by CMake and your Conan configuration.
This proposal solves a class of bugs where incorrect pointers are passed around and result into UB.
Works now, thanks. You can always change the domain from `www.reddit.com`/`new.reddit.com` to `old.reddit.com` to see for yourself.
Since CMake is run after (or inside) Conan, how can Conan check this?
For example you can have multiple compiler in your system, let's say \`gcc-4\`, \`gcc-8\` and \`clang-5\` and in your \`conan profile\` you set your compiler to \`gcc-4\`. Then you run CMake and CMake detect \`gcc-8\`, since you include \`conanbuildinfo.cmake\` an error message will appear and say that the compiler version detected is not the same between CMake and Conan
I've never experienced that, since the early 1990's.
exercism.io
I've just tested. I've made a test library that uses `std::byte`, set c++17 via target_compile_features and built it using `conan create . -s cppstd=14 User/Channel`. It was built in C++17 mode but was added to Conan local cache as C++14. So `target_compile_features` breaks packages and should never be used.
I'm probably not experienced enough to judge the ideas on their merits, so don't take any of this too harshly, but: &gt; This proposal solves a class of bugs Does it _solve_ them, or introduce new things you could use or switch to using if you don't want to have them? Why would switching to your new ideas be better, easier, or faster than just doing the rework to avoid raw pointers at all wherever possible?
UB doesn't have to crash and burn your program immediately. Most codebases with raw pointers have a ton of UB in them yet they still seem to work.
I know.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bi7u6s/pybind11_python_to_c_datatype_conversion_not/elyxfgb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bi7w1i/where_can_i_find_programming_exercises_with/elyxfuq/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Users end up try-catching exceptions everywhere, and it devolves to more or less error codes. If that is the case, you're codebase is seriously broken.
There are many things in the standard library that can replace raw pointers but some low-level areas (mostly related to memory management) are still not covered. This proposal covers those areas.
That's mostly a misconception. OOP is and always was a good tool for managing complexity. The issue is that it gets conflated with 90s Java style OOP, which represents a poor understanding of how OOP works and what problem it solves. One of the hotshots of that was that people started abusing inheritance for absolutely everything. And (in C++) ignored rigorous lifetime management in favour of passing owning pointers around for absolutely everything. If you understand OOP properly then you realise that advice such as ‚Äúfavour composition over inheritance‚Äù or ‚Äúimplement value semantics for public interface objects‚Äù is perfectly in line with OOP best practice, and algorithms based generic programming works hand in hand with OOP.
&gt; User code now will look mostly like this excerpt. error_t err = do_something(params); if (err.is_error()) { handle_error(err.details); } I'd really like to see a couple of realistic examples not just foo bar dummy code. Arguing about things like readability and simplicity based on trivial, made up examples is rarely a good idea. Presumably your function is going to return some value. What exactly do you expect handle_error to do and how does this compose, if you have a lot of functions like that? I'm not saying exceptions are in general superior (although I prefer them). Just that I'd prefer discussions based on actual use cases, not made up toy code, that can be tuned to support any argument.
&gt; Handling an error in a centralized location is rarely useful, which is often the motivation for exceptions. Considering that lots of error "handling" just consists of cleanup, logging and retry/cancel, I don't think that is true in general. That's why I was asking, what exactly handl_error is supposed to do. Most of the time, the logic to handle various errors at various places looks very similar.
At least they are better than `new` and `delete` in the sense that they don't clash with commonly used names.
I love OOP and all I can really tell you is that inheritance is ***cancer***. Why? Because not everyone has a brain to stop for a moment, and realize that using it for code reuse or simply having 50 levels of inheritance is retarded. Everything you can do with inheritance you can do better with composition. And when some class that was part of the object breaks... You don't need to look through those 50 base classes, you know what and where broke, and then you either fix it or you make your own. Goodluck doing same thing with 36th level of inheritance class that is broken and cannot be fixed :)
Are these new pointer types nullable? Can you have two pointing to the same object? If I have two pointers of type 3, `a` and `b`, pointing at the same object, and then I use `a.~T()` to destruct the object (but not free the memory, as one might do for a container like vector), isn't `b` now of the wrong type?
There's a subset of people in the cpp community that think OOP is an universally bad approach to any problem. He's one of those people. OOP has a place and time, whether or not that place is your project should be decided by the requirements of the project, not any paranoid "all OOP is bad" sentiment.
How else do you think they will hold onto the malloc'd data? Do you realize that unique_ptr is just a wrapper around raw pointer too? Why don't you use that for your argument? You're missing entire point. std::vector and std::string and whatever else really... They were built and left in the wild for a while now, all bugs that could have existed in them most likely have been found, I don't know about you, but I'd rather use std::vector over `int *p = (int *)malloc(sizeof(int) * 5);`. You know what's even better than that? `new` but in fact, what's even the point of `new`, it's just syntax sugar over malloc. It's not that hard to construct objects on your own after you malloc the memory. That's how real programmers do it!
Can we agree not to mix the 50 levels of inheritance with the rest of OOP which is probably the best thing about C++, after the fact that it uses RAII, of course? I simply cannot imagine a competent C++ programmer that also thinks that OOP is bad. If they truly did, they would be busy showing off how big their dick is by doing their job in assembly, as abstractions would simply hurt their imploding ego a little bit too much.
So this is (feature wise) a more restricted version of gtest, tailored to a specific test suite. Does it surprise anyone that it is faster? That isn't to say it wasn't the right choice to do so. Just want to put the results in the right context.
So, everything that teaches C++ as OOP language should be outed, but everything that teaches C++ as OOP language shouldn't be outed? Interesting. Imagine if we could be less elitist and realize that C++ is OOP language but it's OOP is based on RAII and isn't the same as in other languages...
As more and more things are added to the language, it soon will become unusable. Why every problem have to be solved by adding more stuff, instead of fixing things, that could easily be considered broken from the start? As long, as I understand the need for std::launder, as const optimizations could be useful in some cases, I don't believe std::bless should have ever be created. Right now there are many restrictions on the pointer arithmetic: - you can't compare pointers to elements that are not in the same array - you can't perform arithmetic on pointers, if underlying storage has no constructed elements in it I don't believe ANYONE has ever benefited from those rules. I'm sure, that if compiler optimises those cases making use of UB, it's almost never what the programmer intended, and results in bugs in the code. (If you have even once used one of those "features" designedly, please let me know). What is the problem with relaxing current rules? What would be a downside of the following rules: - you can perform pointer arithmetic on pointers no matter if they point to constructed objects or not, - you can compare pointers of the same type as long, as they point to properly aligned memory, that a) has objects of correct type constructed b) can have object of correct type constructed in the memory it points to; but the result of comparing two elements not in the same array is runtime defined. Comparison of pointers of the same type, if valid, is a strict total ordering What are potential problems with those new rules? Are there any real cases, where the old rules are better? I know, that one could say the drawback is loosing compatibility with C, but with different rules about objects existence, in this manner compatibility was never there to begin with.
Why not ? It would make your code smaller and the overall thing cleaner
&gt; What are potential problems with those new rules? They assume linear address space. There still exist segmented architectures. Like x86 in segmented protected mode or (if I'm not mistaken) also current mainframes.
 int main() { int x, y; if (&amp;x &lt; &amp;y) return 1; } The reason this is UB is because the compiler is allowed to reorder your declarations. Code reordering does allow substantial subsequent optimizations. So we have all benefited from the rules you are trying to relax.
If this could return 0 or 1 depending on what the compiler happens to do, that would be *implementation-defined behaviour* rather than *undefined behaviour*. Say you wanted to put pointers in a data structure that required the ability to use `operator&lt;`: int x, y; std::map&lt;int*, std::string&gt; foo = { {&amp;x, "x"}, {&amp;y, "y"} }; With implementation-defined beaviour for `&amp;x&lt;&amp;y`, it would not be guaranteed which of those two entries would be first. It could change between different compilers, different runs of the same compiler or even between different runs of the same binary executable. But `foo` would contain the two pointers in some order. This all still allows code reordering and all other reasonable optimizations. With undefined behaviour, anything could happen at the point that you use `&amp;x &lt; &amp;y`. They could compare equal (so the map ends up with just a single entry), or `&amp;x&lt;&amp;y` and `&amp;y&lt;&amp;x` could both be true, or the operation could crash, or make a 10GB file on your hard drive, etc.. This is not really about optimizations. (In fact the above snippet will work with implementation-defined behaviour, because `std::map&lt;int*, ...&gt;` will use `std::less&lt;int*&gt;`, which is guaranteed to be a total ordering even if `&lt;` on `int*` is not. But you get the idea.)
`std::less&lt;int*&gt;` somehow manages a strict total ordering, so it must be possible for a compiler to make `&lt;` on `int*` behave the same way, even on segmented architectures. The reason it's not required a slight performance bonus: if you assume that the pointers are within the same allocated array, then you can assume that they're in the same segment, so you don't need to compare the segment part of the pointer, just the offset. What if the pointer is only an offset, with no mention of the segment? (I believe this is called a "near" pointer in old-school Intel speak.) Well, I don't believe that standard C++ or C allows these (or at least the segment must always be unambiguous from the context), so comparisons involving these would be outside the standard.
Ouch, I expected something like this existed, didn't know how to name it to google it though. In this case comparison is indeed problematic
That‚Äôs simply untrue. It‚Äôs just that ‚Äî especially on Stack Overflow ‚Äî there‚Äôs a set of common problems in C++ that, especially for beginners, are solved easily and efficiently using modern C++, and which have more convoluted solutions using pre-C++11. Modern C++ solutions are advocated because they are objectively simpler. I‚Äôve ***never*** seen anybody advocate against the use of `char*`. Except when it‚Äôs used to own memory. In which case, duh. That‚Äôs bad.
In that case, VSCode recently became a quite competent VS alternative for c++ development, it has a debugger, and with two additional extensions (_Microsoft/vscode-cpptools_, _vector-of-bool/vscode-cmake-tools_), I've been using it at my day-to-day job. Of course, some more advanced features are indeed missing (while VS has them, such as profiling), but I pretty much relied on external tools for that anyway.
I'm not sure, but aren't far pointers outside of standard? And aren't they a different type than classic \* pointers? They were declared with "far" non-standard keyword, and were different size, so I guess they were distinguishable on the type layer. If it is true , then standard pointer rules just wouldn't apply to them, and the problem is non-existing
I thought about this. This is why the wording is "should", not "must". I'm not sure how to make C++ even more memory safe without breaking more pointer semantics. For example, I would love `std::destroy` to remove the pointer from scope so even trying to use its name will be a compile time error but I have no idea how to standardize this.
&gt;implementation-defined (also known as "unspecified"). Unspecified is a different category than implementation defined. Implementation defined behavior is deterministic behavior that is documented by the implementation, for example \`\`\`sizeof(int)\`\`\` is implementation defined. Unspecified behavior is non-deterministic behavior that does not have to be documented but which is constrained to some extent, for example order of evaluation of function arguments. &amp;#x200B; As for pointer comparisons, raw pointer comparisons are unspecified behavior, and while it's technically true that the Standard requires that \`\`\`std::less&lt;T\*&gt;\`\`\` provide a total ordering on pointers, in reality libc++ and libstdc++ only provide such an ordering if raw pointer comparisons provide such an ordering and so technically violate the Standard on segmented memory architectures. &amp;#x200B; In practice, no one cares.
&gt;you can't compare pointers to elements that are not in the same array &gt; &gt;you can't perform arithmetic on pointers, if underlying storage has no constructed elements in it &gt; &gt;I don't believe ANYONE has ever benefited from those rules. I don't think the second one is true, otherwise STL algorithms don't work. eg, `size=last-first` requires that `last` can point to uninitialized memory one past the end.
So: &gt; * you can't compare pointers to elements that are not in the same array &gt; * you can't perform arithmetic on pointers, if underlying storage has no constructed elements in it &gt; I don't believe ANYONE has ever benefited from those rules. I believe you have benefited from those rules. for(int i=0; i&lt;20; ++i) { int tmp=7; foo(&amp;tmp); } the ability to reason about the fact the above loop runs 20 times requires those rules. Because without it, modifying `i` through `&amp;tmp` is legal. There are similar cases with `struct Foo{int x,y;}` being able to know when `x` is or isn't modified through `foo.y`, thus eliminating piles of reloading from memory or preventing combining steps in math. Without being able to know what your code does at a level more abstract than "compile to naive assembly, that is what it does" compilers have to produce really crappy assembly. Every access to `foo-&gt;y` has to do another memory load. `foo-&gt;x += foo-&gt;x * times2(foo-&gt;y)` has to load `foo-&gt;x`, load `foo-&gt;y`, run `times2`, reload `foo-&gt;x`, then write back to `foo-&gt;x` before proceeding to the next statement. "Clever" and illegal pointer fiddling is rare and makes optimizing the remaining 99.9% of code implausible.
&gt;I don't think the second one is true, otherwise STL algorithms don't work. eg, &gt; &gt;size=last-first requires that last can point to uninitialized memory one past the end. Yes, past-the-end pointer pointing after an uninitialized array is also valid for pointer arithmetic. It's just an edge case, not really important in this problem, so I didn't mention that. Still, some STL parts can't be implemented using C++17 language rules, and need some special compiler support, std::vector being a good example. Look at [wg21.link/p0593r2](http://wg21.link/p0593r2) for more informations
`last` is a special case. "One passed the end" is allowed.
The problem there is not pointer arithmetic itself, but dereferencing the pointers after performed arithmetic operations - it should be UB, no doubt, and I don't want to make it valid. Maybe I didn't express myself clearly enough. Also, my idea: &gt; you can perform pointer arithmetic on pointers no matter if they point to constructed objects or not is not about allowing any pointer arithmetic, but only those that can't produce overflow (specifics needs to be formulated, but it would allow std::vector to be almost trivially implemented)
Well one of the warnings is every if statement needs to have braces, so if you lack braces in an if statement or will earn you. By default all checks are on. You need to either manually say turn off a rule when you run it, or create a .clang-tidy config file. You can dump a default config file and tweak it the way you want. Every single rule is documented.
I've seen that video, but it has been a while, so you'll have to describe how data actually gets manipulated.
Firstly, I'm the guy who gave the 'Elsewhere Memory' talk at the ACCU conference referencing. You can watch it at https://www.youtube.com/watch?v=Djw6aY0VhwI. Please note the errata, I have never yet given a talk where I didn't speak utter falsehoods. Secondly, you've pretty much summarised my strategy in its totality for getting this stuff into the standard, albeit with a bit of renaming: - Pointer to allocated but indeterminate memory: P1031 `map_handle::address()` - Pointer to allocated memory with valid (blessed) objects: P1031 `mapped&lt;T&gt;` or `map_view&lt;T&gt;` The reason we push this stuff into the library is because the abstract machine is already hideously complex. And, besides, it doesn't really need to know this stuff. I'm currently sitting in Cork airport heading to Heathrow to attend the WG14 (C) meeting all next week where we will *literally* be discussing whether and how to change the C memory model's conceptualisation of indeterminacy. I'm looking for a model which fits better to how MMUs have worked for the past twenty years. Others want ... not that. But that's standards committee work for you. As for reforming allocators, I think there is now a majority on WG21 who agree that some profound changes are needed. In that, John Lakos has been successful in his campaign pushing on two decades plus now. But there is zero consensus on what those changes should be. Herb, being the tour-de-force that he is, has been doing a ton of work behind the scenes to prove that almost no code out there is OOM safe despite having OOM handling code. He's already amassed a fairly shocking amount of OOM hard failure in all sorts of places nobody expected apart from maybe me and Marshall. Whether he can persuade DG, and create a consensus at WG21, remains to be seen. So basically, we're on it, but baby steps please. First the abstract machine needs some as-minor-as-possible changes to support not all memory being equally reachable and identical. Once we achieve that, everything else can follow. I appreciate that this is twenty-year change stuff. But getting this stuff wrong is **profoundly** bad. Every C-based system on the planet could break. That's most of all computing. So the bar is quite rightly extremely high to passing any changes ever to this sort of stuff. Still, I hope by this time next week to return from London with some notches under the belt. Here's hoping!
Why? You said: &gt; If you want, you can give an example of where you would use it and I can describe what I would do differently. Now describe how you would accomplish the same thing without inheritance.
google no true scotsman
No, it was saying that I had one (as in 1) brace too many.
Interesting, that definitely sounds like a big. You should create an issue. Clang-tidy is a fantastic tool, so hopefully that doesn't deter you from using it. Especially when it comes to giving hints about move semantics, and so much more. Personally I have it integrated with vim as a vim plugin through a plugin called Ale. It's fantastic, I can't say enough good things about it.
No, you are fundamentally wrong again. In c++ we have pointers and references which are temporal "views" or aliases to an existing object (like `string_view` too). The c++ standard explicitally calls pointers or references or `string_view` to non existing objects - ill formed. To idiomatically express ownership we have in c++ others means, for example unique and shared pointers (or `string`). &gt; the first iteration was the closest one by spirit. It didn't do the same thing but it did what dev intended to have, a closure over the reference. No. The honest intention was to have a closure of a shared ownership, and the `&amp;` was just an accidental mistake, a typo, which unfortunatelly may not be diagnosticated by the compiler, and your job was to show that Rust will correctly diagnost that typo.
We just need borrow checker to prevent such things :P
Don't know where Herb's been looking but in a previous job of mine dealing with a mobile phone OS we would regularly brute force OOM situations to make sure things didn't fall over and failed gracefully. Also, bad_alloc can be expected to happen when dealing with fixed size shared memory segments.
The C++ union ist named std::variant.
Well `std::variant` is great if you're in C++17 and newer (`absl::variant` if you're in C++11/14), but it isn't the same thing as union. It's easier to use, but you end up paying for it in memory cost because every instance has it's own tag data.
Mainly in networking where various protocols (I work with 3gpp stuff) are built around them. In the "regular" code, we have some optional/delayed construction built by using them, but that's rather legacy parts. As for discriminator, well, usually we just have some number next to it, sometimes managed by some generated, wrapper code.
C or C++ is running under the hood in almost all of these scientific and numeric libraries. The Python code that runs on top to tape the pieces together takes a negligible amount of time to run in comparison to the algorithms doing the bulk of the work. So parallelism really is the only option at that point to get any additional speed up at all. Take Numpy for instance, it is written in C and can use high performance linear algebra libraries under the hood to do matrix opperations. In Python, the cost of making a Numpy function call like a dot product between two large matrices and then wrapping the result to return to Python is trivial in comparison to the matrix operations themselves. So it would be nonsensical to switch fully to C or C++ to gain an unimportant speed boost to non-bottlenecking code at the price of high development and prototyping times. Especially so when enormous gains can be made at almost no cost in dev time by leveraging parallelism for algorithms that are highly ammenable to it.
I remember how terrible mailing lists were compared to SO. There might be a thread 30 questions long, but you don't know if #1 or #30 are the best answers. If there even is an answer.
&gt; I work with 3gpp stuff Oh snap! Thank you for your hard work :) I ditched wired internet a few years ago thanks for the marvel that is mobile networks (and unlimited data). &gt; In the "regular" code, we have some optional/delayed construction built by using them, but that's rather legacy parts. Can you provide some example code? I want to make sure I understand what you mean. &gt; As for discriminator, well, usually we just have some number next to it, sometimes managed by some generated, wrapper code. Oh that's interesting! Generated as a macro or some utility for generating C++ code?
Mostly type punning between `double x, y;` and `double v[2];`.
Haha that's funny. I honestly hadn't even thought about doing that. So basically you store two doubles side by side and then access the correct one based on runtime data (the index)? Perhaps a boolean?
As if the number of lines was meaningful to evaluate some piece of code. So the real question is more "what kind of checks are not checked or errors not catched compared to googletest" (or the opposite eventually). After we can compare build time, speed and so forth
&gt; `std::less&lt;int*&gt;` somehow manages a strict total ordering Oh, sure, comparing pointers as a bitwise pattern is of little concern. However, you would expect that if `pa &lt; pb` then the loop `while (++pa != pb);` will eventually end. This is not the case given segmented pointers. &gt; What if the pointer is only an offset, with no mention of the segment? Totally irrelevant. The architecture could operate only with "far" pointers, i.e., there's no way of having a pointer without the segment part.
why but why \`shared\_ptr\` where it is supposed to be monothreaded....
you pay for what you use dude; if you implemented a typesafe, tagged union; it woud be the same same size and performace (if not worse) than `std::variant`
Well it depends on how many bits you need for the tag. For example, if each union only has two members, you can tag it with a single bit. If you have a lot of these unions, you can have a master bitset that tracks the tags of every instance packed together. (I believe this is called Data Oriented Design but don't quote me on that.)
Looks kinda similar to Taywee/args
No, the js environment is monothreaded. It doesn't mean that the underlying engine is so as well. In fact, V8 isn't monothreaded nor libuv.
On the planet but what about the universe?
Something like: union Optional { MyClass m; int unused; } So you have storage for MyClass in-place (which helps in some performance critical places) but you can create it later (or never). std::optional is today's cleanest solution for such things but again, you might have this very few use cases when you need to squeeze a little more performance out of it - e.g. having the "initialized" flag embedded in some other place or something like that.
but you cannot tag it with a single bit; unless you a bit fiddling with the low bits of a pointer or something. Smallest size you can deal with is a byte. If you only have two things; then potentially use a normal union and a boolean. And yes, that is a common use of DoD. (SoA vs AoS style, would be a that union style vs a variant) In general; variants are amazing and you should use them everywhere you'd use a union; unless you need a custom union type for a small bottleneck/perforcance critcal section in the hot path especially for static polymorphism; if you know all the types in advance, encode it with a variant.
I can't watch an hour long video just to reply to a comment. I'm not sure what it is he's doing. If you can describe what the video is about I can talk about how I would approach the same thing.
Unless `MyClass` is trivially default constructible and trivially destructible, this actually wont compile. Which is what got me thinking about unions in the first place haha. It's hard to use them without user defined constructors and destructors (which is syntactically ugly, imo).
Well that's why I mentioned a bitset, which handles the bit twiddling for you. I agree for the general case you should use a variant!
Anything specific you think should be in the library?
It's pretty common in networking. A simplified example with an anonymous union: struct Message { enum class MessageType : uint8_t { TYPE1, TYPE2, TYPE3 }; MessageType type; union { Type1 t1; Type2 t2; Type3 t3; } u; }; int onRecv(const char* data) { auto* msg = reinterpret_cast&lt;const Message*&gt;(data); switch(msg-&gt;type) { case Message::MessageType::TYPE1: doSomething(msg-&gt;u.t1); break; case Message::MessageType::TYPE2: doSomething(msg-&gt;u.t2); break; case Message::MessageType::TYPE3: doSomething(msg-&gt;u.t3); break; } }
You can pass \`double v\[2\]\` to some API by pointer but still have every individual member accessible by name. Additionally you might have two sets of names for individual members, e.g. x, y, z and r, g, b. Take a look at GLM for example.
Awesome! Thanks for sharing. So the tag is sent over the wire as an enum and just read directly on the other end. This is very C-like code. Is that intentional? Also, is there a case where you might have a nontrivially constructible/destructible type as one of the union members such that a simple `reinterpret_cast` wouldn't be enough?
unsure if its specified in the standard; but a quick look into libc++, the tag is `std::size_t`; which mean paying 8 bytes, which isn't much; and the same as a pointer; thus small. If you *need* smaller, sure; go for it; use an `unsigned char`, `std::byte`, or `std::bitset`.
if i am not wrong it is technically undefined behaviour
Ah so it's mostly about giving each member a name. Makes sense! By GLM do you mean OpenGL Mathematics? I'll take a look at it, I've never used it before. Thanks!
Well I work on Abseil so it's my job to think about these things. :) Thanks for the input!
What he is doing is type-erasure through the runtime concept idiom. [Keynote file of the presentation](https://sean-parent.stlab.cc/presentations/2017-01-18-runtime-polymorphism/2017-01-18-runtime-polymorphism.key) [Same thing in PDF format](https://sean-parent.stlab.cc/presentations/2017-01-18-runtime-polymorphism/2017-01-18-runtime-polymorphism.pdf)
thats cool; continue the good work on that project
GCC explicitly supports type puning.
Not really accurate in this case. This is more akin to what is currently happening in the JavaScript world with frameworks like React, where someone who is trained only in that framework is not necessarily able to work in other dialects of the same language. I've interviewed people with a decade of Qt experience. They do not have a decade of C++ experience, any more than someone who has only ever worked in a C-with-objects codebase does.
Not me but the main developer of an OS project I helped with for a little while. Coupled with a `Union` It was used as one would use a variant for a [Property](https://github.com/chemfiles/chemfiles/blob/master/include/chemfiles/Property.hpp) class. I think the upside of this approach was C++11 compatibility and ease of binding to other scripting languages (unlike a solution involving a templated class).
There are lots if extensions to JSON, so there is a good case to be made for extensibility -- if you want it. That's the main benefit. Differentiating integers from reals, for example. Dates, times, references... Depending on how you implement individual value types and how the variant is layed out, you might also be wasting bytes. The footprint of strings, arrays and objects is larger than numbers, books, and null. It's also worth pointing out that using inheritance does not imply the use of virtual functions. Just put a tag in the base class. You can also use allocators to improve locality (which would apply to recursive variants too). Of course at the point that you do all that, your implementation isn't really so different from a variant, which is kind of my point.
I think the third type of pointer you're proposing is indeed going to be implemented as std::observer_ptr&lt;T&gt;
in embedded code (and C mainly) they are very prevalent.
What benefits does using a union have in a context like this over, say: `using F32 = float;` `struct V3f {` `F32 data[3] {},` `&amp;x=data[0],` `&amp;y=data[1],` `&amp;z=data[2],` `&amp;r=data[0],` `&amp;g=data[1],` `&amp;b=data[2];` `};`
Oh! Thank you so much, this is actually super interesting. The union has a `std::string` member in it, which is neither trivially constructible nor trivially destructible. Off the top of my head I'm not even sure how this compiles, but obviously my mental model must be incorrect. I'll have to poke around with this once I'm home (out and about right now). Much appreciated :D
Anything going over the wire has to be kept simple enough that you're guaranteed someone on the other end, possibly using a different compiler and processor, will be able to interpret it in exactly the same way it was sent. I tried to keep the example as simple as possible to show how the union is used without complicating things, but in reality you'd also do things like use #pragma pack to ensure each compiler doesn't add padding between fields in a possibly-inconsistent way, probably have a size field you can check against, among other things. Unions have special rules about containing types with nontrivial special member functions (see [here](https://en.cppreference.com/w/cpp/language/union)), but generally in the networking case you're just going to be sending over plain-old-data.
That surprises me. I see the std says that index returns a size_t, but that doesn't mean that variant uses that as the tag type. I wouldn't be surprised if some implementations tried to deduce the minimal tag size, adjusted for alignment if needed
That makes sense, especially the bit packing part. Thanks And thanks for reminding me to check CppRef again. I'll be sure to re-read that page.
Have you written such code yourself? If so, what for? I'd love to hear more :)
I did something similar to this but for a pubsub messaging system in a game engine. &amp;#x200B; &amp; SFML uses Unions for Input Events iirc
Considering that C ++ is little known outside of our planet, few aliens will write a competing algorithm on it ..
Yes, you're right, good catch. If I'm not wrong, it should compile although it could leave memory uncleaned and eventually crash. That's why, if you scroll down to line 125, you'll see it has a defined destructor which checks if the stored type is a string, and in that case, it calls the string destructor.
It would be interesting to know how the WG14 meeting goes.
Ya looking at this code, it seems like because the containing type has nontrivial constructor and destructor, it isn't needed in the union itself. (Versus instantiating the union by itself which wouldn't compile, I'm guessing.)
The size of the object will be 3 numbers, rather than 3 numbers, 6 pointers, and some padding: https://gcc.godbolt.org/z/xuwcy3
sizeof says..?
 union timer { uint32 val; // Timer Register 32-bit-long struct { uint8 Three; uint8 Two; uint8 One; uint8 Zero; } Bytes; } TMR; now you an say TMR.val = 7; and/or TMS.Bytes.One=1; Why do you do that? For a more convenient and easier individual bytes access and setting. instead of floffing around with masks and byte operators and manipulation (which you could do as well), you have everything laid out for you in a nice structure that the compiler takes care of.
I have started yet another JSON parsing/serializing library. I take the approach that we know what kind of data we are working with and do not use a tree of variant like types. One provides one or two methods that describe their data structure and map it to the JSON members. Also, it is constexpr, because all things need to be :) With that, each mapped type has it's own custom JSON parser.
Ahh I see. So you give each byte a name for readability but you can still operate on the whole 32bit word for efficiency. Neat and thanks for showing me!
I'm speaking from my experience. I tried parallelizing Python my self and it was a waste of time. As I said simply calling Python functions doesn't scale! I once tried to fit curves pixelwise on image data. The curve fitting was done by scipy which calls minpack a fast library writte Fortran. The python layer turned out to be so much of a bottleneck I rewrote the whole thing in C++, called minpack from C++ and it was 100 times faster. No joke. 100 times faster for sending the whole image to a C++ module, calling minpack in parallel, and then sending the results back to Python. Parallelization speedup was on top of the x100 speedup. As I said, Python simply does not scale.
exactly. no, do be careful with this though, as sometimes the compiler can pad the structure and you will not get what you think you should get. https://stackoverflow.com/questions/4306186/structure-padding-and-packing
i use them a fair bit in leaders/parsers (though i am using `std::variant` in newer projects). i typically use an anonymous union in a struct with an enum as the tag, then i‚Äôll provide ‚Äúsmart‚Äù constructors that set the tag and value for the most common cases. i really wish we could have ml/rust style sum types as a first class thing (variant doesn‚Äôt quite get you all the niceties).
I really don't know much about Rust. What is a "sum type" exactly?
But sometimes you don't need a tagged union. Not too long ago, I've implemented a data structure that is basically a vector of unions and the contents of an element tell you what type the next N elements hold. The first element in the vector always holds the same type.
Anonymous unions are the only way to introduce an anonymous type with constexpr member functions before C++17 in a block scope. Lambdas could not be made constexpr at the time. It permits you to pass pseudo-constexpr value parameters in C++11, which is convenient if you want to parse string literals at compile-time for instance. For more details, have a look here: https://mpark.github.io/programming/2017/05/26/constexpr-function-parameters/
on further investigation of the source code; you are right [__choose_index_type](https://github.com/llvm-mirror/libcxx/blob/57c2f5da6715d15efda2cd8a8f35cca51509ed09/include/variant#L292) is optionally used in [__variant_index_t](https://github.com/llvm-mirror/libcxx/blob/57c2f5da6715d15efda2cd8a8f35cca51509ed09/include/variant#L300) whether or not `_LIBCPP_ABI_VARIANT_INDEX_TYPE_OPTIMIZATION` is set. Thus is the size of `unsigned char`, `unsigned short`, or `unsigned int`; thus (most likely) 1B, 2B, or 4B respectivtly.
I use it to store GLSL shader uniforms. Depending on the uniform's type (which is an enum in my project), I'll cast it to the uniform's type when updating the union's value. Simplified version of the struct: &amp;#x200B; struct UniformAttr { private: union { bool boolean; int integer; float floating; glm::vec2 vec2; glm::vec3 vec3; glm::vec4 vec4; glm::mat2 mat2; glm::mat3 mat3; glm::mat4 mat4; }; public: // Retrieve the value of the uniform by specifying it's type from the Shader. template &lt;class T&gt; inline T Cast() { return *((T*)&amp;boolean); } // Updates the value of the specified uniform. template &lt;class T&gt; bool UpdateValue(const T &amp;Value) { if (Cast&lt;T&gt;() == Value) return false; *((T*)&amp;boolean) = Value; return true; } };
Thanks for the link! That's really interesting stuff, I'll play around with that this evening.
I see, cheers. I always figured the compiler would optimize it in a situation like this,
on mobile so i can‚Äôt get too in depth. [wikipedia](https://en.m.wikipedia.org/wiki/Tagged_union) has a good overview. basically from a type theory perspective we have a notion of ‚Äúalgebraic‚Äù data types. one kind is a ‚Äúproduct‚Äù type, eg a struct or tuple, so called because it is a type that is the product of several other types. the alternative is a sum type, eg a discriminated union. it is a disjoint set of other possible types, with only one of the possible options being inhabited at any given time. the technique is fairly common in c and c++ but the language doesn‚Äôt really provide first class support for them the same way that the ML family of languages do (rust takes a fair bit of inspiration from the ML family so it doesn‚Äôt well). with features like pattern matching you have syntax to easily consider each possible variant of the sum type and decompose it into local bindings. the wikipedia page i linked should give you some examples.
Interesting usecase! But is `Cast` not undefined behavior?
The C++17 version would be this: http://playfulprogramming.blogspot.se/2016/08/strings-as-types-with-c17-constexpr.html And C++20 extended the usage of value types in templates.
Gotcha. Thanks!!
To access it via r, you'd have to do V3f2.c.r, right? How would you make it so that you can do just V3f2.r instead?
&gt; designated initializers &gt; These are not available in C++ [P0329R4](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf) begs to differ. Would've liked to notify the author about this, but his email address is nowhere to be found.
only for T != bool
&gt; C++ doesn‚Äôt have support for \[flexible array\] members, but there are higher-level C++ constructs that can provide similar functionality with greater safety. What are these constructs?
Haha yes! I should have specified :)
For the "dimensionless array as the last field of a struct" I don't think C++ provides an alternative. Something missing and used extensively is variable length arrays. Typically, multidimensional VLA: void foo(int width, int arr[][width]) { arr[x][y] = 5; } Where quite useful.
It is basically an std::variant. In Rust it is built-in in the core language. It's called a sum type because the number of states a value can take is the sum of those of each member types. Likewise, a struct is a "product type". What is nice when sum types are in the core language is that it typically allows convenient pattern matching syntaxes.
Seems like adding an accessor would accomplish the same without UB. double x() { return data[0]; }
It's not quite as flexible in C++ as it is in C: &gt; In C++, designators for non-static data members must be specified in declaration order, designators for array elements and nested designators are not supported, and designated and non-designated initializers cannot be mixed in the same initializer list. Was this PR accepted?
https://en.wikipedia.org/wiki/Tagged_union is a very common idiom across many languages. It's used practically everywhere in Erlang.
Only situation where I used them extensively is pure C programming. Currently building my own C compiler in C and many of the necessary data structures are nested structs and unions with enums to distinguish.
&gt; Well std::variant is great if you're in C++17 and newer (absl::variant if you're in C++11/14) boost::variant
Is it open source? I'd love to check out the code.
Hey I work on Abseil. Gotta evangelize :P
Except in C, as C11 explicitly supports it.
A use I don't see elsewhere in this thread is for fixed point numbers (basically, a poor man's floating point) on embedded platforms. In my case I have used something like this: union FixedPoint { uint32_t val; struct { uint16_t i; uint16_t f; } parts; }; Here, the i contains the value left of the decimal point (i.e. whole numbers), and d contains the value right of the decimal point (i.e. fractions). If you want to do addition or subtraction on two of these numbers, you can just use the val element (e.g. `c.val = a.val + b.val;`). If you want to do multiplication you can take the i of the first number and the val of the second (e.g. `c.val = a.i * b.val;`), and then if you want more precision you can do it once more with the f of the first number with some additional shifting (iirc it was something like `c.val += (a.f * b.val) &gt;&gt; 16;`). I don't think this is actually that common, I came up with it myself when I was unhappy with the floating point performance on a particular platform, in an application where most of the used variables would always have a value within the range of 0-65535. I think this was in C, probably in C++ I would have written a somewhat nicer interface around it (e.g. operator overloading). Note that this is not very portable, as a change in endianness will break it entirely (I think the version above is for little endian, but I am not certain).
In my opinion, it is more practical to just use the appropriate type even if the STL got it wrong. It shouldn't be `std::ptrdiff_t` though. `size_t` is more appropriate but you can also use `std::vector&lt;int&gt;::size_type` if you want to be pedantic. Of course in your example it should have been for (auto&amp; number: v) { number = 1; }
It is a good question. I think the standardization committee realized that using unsigned for containers was a bad idea, but they are kinda locked in now since changing that would cause a lot of problems. I'm not sure what to do. Perhaps the committee could add svector, smap, and others which would gradually replace the current form? I don't know. They are in a tough place because so much legacy code is out there. If it were up to me, I'd just switch everything to signed and say screw it. But it isn't up to me.
Haha this is so fun! Very scary, as you mentioned, from a portability perspective. But the idea is awesome
Yep in practice it's rarely a problem and you side-step the whole issue if you use range-based for loops and algorithms. And with ranges it's even easier
I'm curious ... why do you say it's undefined behavior?
What's so bad about unsigned indices? There's a definite benefit when checking whether it is in bounds, yeah? if ( i &lt; container.size() ) VS if ( i &gt;= 0 &amp;&amp; i &lt; container.size() ) and in the few cases where you'd want a negative index (e.g. for use as an offset) can't you convert it? What are the pros and cons of each that make unsigned a superior choice?
I wish the committee would bite the bullet and do a breaking-change release of some new standard a-la Python 3. This was admittedly not handled well, but the lessons learned are plentiful and we could arguably avoid some pain. There are enough people out there still writing C++ like it‚Äôs 1998 that drawing a line in the sand now is not going to piss off the whole universe of C++ devs. Bjarne has stated that inside the language there is a simpler / smaller / more expressive language waiting to come out. There‚Äôs a reason why, outside of programming, it‚Äôs often denigrating to say that something looks like it was ‚Äúdesigned by committee.‚Äù Modern C++ epitomizes this...
You can use an anonymous struct inside the union, part of the C11 standard but a very common extension for pre-C11 compilers. struct V3f { float data[3]; struct {float x,y,z;}; struct {float r,g,b;}; }; (I don't generally use them myself, which is why I didn't think to put that in my compiler explorer code.)
Until C++17, unions were the only way to add sum types for your code, if you want to avoid hierarchy problems. The problem with unions is that they are not considered to be safe in modern C++ standards. Requesting the wrong type may easily lead to undefined behaviour. Luckily, we now have std::variant that solves most problems that unions have. Since C++ still lacks proper pattern matching, they are not as useful as they are in Haskell for example, but usually std::visit is quite sufficient. Some common use cases of sum types are: * state discrimination (e.g. a music track may be playing, paused or stopped, where each state is represented by a type) * functions that may give you a different return type based on its input (e.g. the intersection of two lines may be a line, a point or nothing) * tokens for parsers * integrated domain specific languages For more examples, I recommend reading up on functional programming, where sum types are being used extensively.
I'm probably wrong :) [This thread](https://stackoverflow.com/questions/33056403/is-it-legal-to-use-address-of-one-field-of-a-union-to-access-another-field), from the way I read it, suggests that as long as you aren't reading the value of the inactive member, taking its address and casting it to the right type is legal. In my mind taking the address was similar/the same as reading, but I actually don't think that's the case, on second thought.
Not yet, but I plan on open sourcing it eventually. I only started late last year and have little time besides my day job and life. Currently grammar parsing into AST is complete-ish (not using any generators, all manual work), preprocessor works for the most part (except some macro and variadic bugs) and early code generation looks good. This week I built the foundations of my own C standard library which comes embedded with it (so if you #include &lt;stdio.h&gt; etc., you'll get my implementation right now). My aim is for the compiler to be able to compile itself, and be easily embeddable and portable as far as possible. But at current pace, it will take a few more months until it is complete enough for release ;-)
Nice! Cheers
Careful with any recomendations to use gsl. It's not a stable, mature library. It has a LOT of big gaps and they will change API without any notice or even putting any significant thought into it.
That's not really always true. You are thinking of inheritance hierarchies always being driven from the most derived downwards. But framework style inheritance is umm... inherently highly stateful because it's it's driven from the inside out. The derived classes may not even provide any public functionality, it may only provide extensions for the framework to operate within some specific environment on some particular type of thing. It might provide a little public functionality perhaps, but mostly it would exist to apply logic that exists in the base framework class. Sometimes of course those are done as a concrete base class with pluggable interfaces, but if there's only a single interface it's often safer and easier to do it via a derived class. &amp;#x200B; Then obviously you can have the other inversion where there's very little in the base class other than interface. But, even then, it may serve the very important purpose of imposing constraints on the derived classes, i.e. it provides public non-virtuals which call virtuals in the derived class. And it may provide common data storage and impose constraints on that as well.
They were almost there with std2, but then got cold feet unfortunately :(
Yep, this is why this is only kind of legacy code. :)
That requires an extra pair of parentheses in calling code, which is *annoying*.
Sounds like some performance improvement possibility due to cache misses caused by union paddings.
Forwarding a class over and over that has 50 complex methods and only one level of inheritance would just be busy work that gains you nothing. And of course it forces you further and further down the 'one giant template' path that some of us don't much care for.
`std::vector` comes close.
There's also **_Generic**, which doesn't make much sense in C++, and **restrict**, which would actually be nice to have in low level code (and at least g++ and clang++ support __restrict as a language extension in C++ afaik).
What if that restriction was removed? Do you think you'd make use of the ability to have a trivial union with nontrivial members?
But it also gives you a nice "hook" in case the underlying type changed. You won't need to update the users, just the implementation of the accessor function.
Returning everything from public interfaces by value would be utterly impractical. It might be something to be aware of and do where it's reasonable, but not any sort of rule to follow blindly. As to composition over inheritance, we have to remember that 95% of even the most rabid hierarchy guy's code is still composition over inheritance. Every class that just has members and provides methods to manipulate them and enforce constraints is composition based design. We all do it the vast majority of the time as a matter of course. Personally, I'm not sure I would really 'favor' anything. I'd look at each situation and use what I feel is best.
If the underlying type changes now you have a problem because I don't know what format the data is in to send it to the GPU.
There's an extra pointer in the vector. I don't consider that close.
Pretty sure all mainstream compilers actually support it anyways. Or at least doing foo[0]
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bi0lvq/quick_guide_to_modern_cpp/em018l1/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
MSVC also supports it (if not explicitly, they do it in the windows headers so you can expect it to work as long as they haven't changed those).
50 complex methods? Why not just write everything in main and copy paste code for reuse? Will be simpler than keeping track of 50 complex methods lmao.
As I've worked on C++ over the years seeing "it's undefined behavior" has gone from "oh, so how should I do it?" to "I don't care, if it works that's good enough for me". The C++ standard is a nice starting point but when all 3 of the major compilers we use explicitly go against the standard and support a thing anyway something is clearly off.
To be honest, the real reason why I didn't use std::variant is because I forgot about std::variant when I was implementing that. std::variant would add an extra layer of safety that would detect a broken structure when accessing the wrong type.
I'm not sure, it sounds like something that can be already done by some library: variant, optional, aligned\_storage, etc.
I guess I'd expect that level of maturity, and that level of ability to deal with debate, from someone with your user name. Try a graphics system. Some classes in a graphics system have a lot of methods and plenty of them will have complex sets of parameters, and they will have various derivatives for targeting different things, but likely not much hierarchy at all, maybe just one layer. Windowing systems are another candidate where such things might happen, and UI frameworks. There is a lot of common functionality that all, say, Windows will respond to and so it's perfectly legitimate to put it in a base window class. Again, probably not a lot of hierarchy necessarily, but a lot of specific derivatives that you would have to do the forwarding for over and over again. These methods may not be as complex parameter-wise as the graphics system scenario, but there are likely even more of them. You should perhaps get a broader experience before going straight to the insult drawer.
vectors contain 3 pointers.
Nooooo... Don't do anything resembling Python 3 breaking changes! Python 3 is 10 years old and the number of python 3 package installs using `pip` is at a WHOOPING 30%! C++ is older, coveres much more wider variety of architectures, doesn't run in a VM etc etc etc... Bottom line is, there's no way C++ would survive such a, and there's no other way of saying it, fork. &amp;nbsp; Python3 and Python2 are different languages and the python community has never recovered. Let's learn from it instead of repeat it.
From what he was saying, it's more a case that common system library functions which everybody would think return `ENOMEM` or throw `bad_alloc` actually terminate the process, either sometimes, or all of the time. And moreover, it's often a surprise to the maintainers of said libraries that this is the case, because they didn't know that was the case.
optional and variant are both nontrivially constructible, sadly. You can do it with aligned_storage, but you should check out [my paper](https://wg21.link/p1413) on why aligned_storage is the worst thing ever haha
std::vector seems close until the day where you start benchmarking what those heap allocations actually cost
Neat! I was looking at Scalar Evolution just this week, and trying to figure out what this 12,000 lines of code were actually doing, and here it is, neatly laid down in this article.
&gt; This is very C-like code. Is that intentional? hav fun serializing and deserializing vtables and `typeinfo` objects across the network :p
\#1 I checked the running tasks in Visual Studio (the button bottom left) and there it showed a progress bar for indexing folder. It was only progressing very slowly and after \~8 mins when at 25% the configure step started. \#2 thanks for letting me know, I will try it out
I'm also interested, why option "always use \`size\_t\` for index variables" isn't even discussed in the core guidelines...
&gt;Returning everything from public interfaces by value would be utterly impractical. Noone said that, if you read the quote again &gt;&gt;implement value semantics for public interface objects This means your public classes should be concrete value types; while any abstract base classes and inheritance heirarchies should be hidden away as an implementation detail. A good example would be `std::function`. It's a value type that has different (but related) behavior for function pointers, PMFs and function objects. One sensible implementation might have different classes for each type, each of which inherits from an abstract base class. However, the interface object (`std::function`) doesn't need to expose that inheritance to the user.
But, given that one of the core reasons you'd use an inheritance hierarchy is so that users of that code can create objects from that hierarchy and manage them polymorphically, that also is only something you would or could do in specific cases. Of course anything that is really an internal detail of a class, no matter what it is, should be hidden away.
https://github.com/KhronosGroup/OpenCL-Headers/blob/master/CL/cl_platform.h#L1213
Next step, geoimperial sums. ;)
That's not what I mean; I mean the vectors data is stored elsewhere. With the flexible array member it is right next to the struct; there is no extra pointer.
How many different C++‚Äôs are out there now though? OP‚Äôs question is a masterful exposition on how truly scattershot the last several years have been. Python 3 and 2 are indeed different languages and they managed that poorly. C++ could do better. I agree it would be a fork and I think that‚Äôs what we actually need.
 &gt;go against the standard It's not going against the standard, they're still conforming to it but just giving stronger guarantees than necessary.
I'm pretty sure type punning via union is UB in C++
Because it's pretty well established at this point that `size_t` isn't a good choice. It's been debated to death already.
I have seen the following use of Unions, bit-fields for accessing bits by position in a easier way; discriminated union, aka sum type or variant in C; and in Windows IDispatch interface from COM API; and Excel XLL API. The Windows IDispatch uses union for type erasure that allows calling any method of an object implementing the IDispatch interface with an array containing the same types (Variant union). A problem of unions for bit-fields is that it lead to incorrect results due to endianess that depends on the processor. Another issue is that unions only work with POD types (C-compatible types) which are integers, chars, char pointer, pointer to any type and so on. Some of few legitimate use case of unions are interfacing legacy C libraries or to build C-interfaces (extern "C") to C++ libraries with type erasure.
&gt; Another issue is that unions only work with POD types (C-compatible types) which are integers, chars, char pointer, pointer to any type and so on. Do you think adding the ability to easily use them with any C++ type would be a beneficial language change? What might you do with that feature?
SO does not simply recomment things in C++ that are objectively complete replacements for C objects, but instead objects that have unused features with significant performance overheads. For example, I see people on StackOverflow telling OPs to replace C arrays with `std::vector` much more than they mention `std::array`.
There is nothing inherently wrong with them. The problem is that an unsigned number does not behave like a normal number. I frequently do mathematical operations on indices, and using the unsigned indexes frequently causes bugs. I see it happen a lot when I am doing boundary checks. Conversions work fine, but new users of the language fall into the trap all the time, and even experienced devs make the same mistake. I am sure there are other reasons as well. I just don't know a lot of them. I do know that the standardization committee has recognized it as a problem however. So even if my explanation is too limited I guarantee you will find more on the subject if you dig.
I guess (haven't tried it yet) you can write your own smart pointer, though at the price of some memory overhead? Assuming your class is of type *T*, and it contains a member *flex* of type *pointer to S* as its last member, you could create a smartpointer, which works as follows: 1. Constructor takes a size_t n for the count of flexible members + a variadic template argument which gets later forwarded to T 1. Allocate a char buffer of size sizeof(T) + alignof(T) + n*sizeof(S) + alignof(S). This buffer should be a member of the smart pointer, so that you can free it in the destructor 1. Use std::align to get a correctly aligned pointer, *aligned_ptr*, into the buffer, use placement new to construct T there. 1. Cast *aligned_ptr* to char, add sizeof(S) to get a pointer to the still free area of the buffer. Use std::align to get the corresponding aligned pointer for S. Use placement new to construct a S[n] there. 5. Set *flex* to the aligned pointer which you got in the last step. Overhead compared to the C flex array: Probably sizeof(S*) for the flex member, + potentially alignof(S). However you still only do one single dynamic allocation.
The latter being true hints at the former being not. It's pretty well established among the "use signed types where possible" crowed though.
Unsigned types for sizes in C++ was a mistake, but now it is too late and it can't be helped, and it is an *even worse* mistake to try to fight against if the standard is targeted. So I would just plainly disregard any point of any coding guide that is at odd with the standard. If a library level dialect is targeted instead (in which case I mean a code base which *does not* uses std::vector, some std algorithms, etc) -- which is btw. *also* now considered a bad idea, it might be possible to attempt to avoid unsigned types for sizes. Although I'm undecided of the long term effect because if not previously done that would render even more hard any attempt of a migration toward standard C++.
Isn't it better to just tackle that with mixed signedness warnings during compilation and static analysis? Or opt for some other paradigms like generators, ranges etc?
Webscale.
Modern cpp is just a style of programming taking advantage of the new C++ standard features for simplifying the code. The core guidelines available at [https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) provides pretty good guidance about who to use this style. Another good source is [https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp](https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=vs-2017) &amp;#x200B; I would say that some of those modern features are: 1. Move semantics - that allows returning by value without the copy constructor overhead 2. Smart Pointers - provides safe heap allocation, instead of the dangerous new, delete 3. Vanilla containers, std::vector, std::list, std::map, std::unordered\_map. The most important one is vector that already warps heap-allocated arrays such as: Type\* ptr = new Type\[10\]; 4. Lambda expression, aka lambda ~~functions~~ objects, provides an easier way to implement callbacks, event handling, observer patterns 5. Uniform initialization and initialization list: struct Point{int x, int y;}; std::vector&lt;Point&gt; xs = {{3, 5}, {6, 10}, ...} 6. auto keyword for type deduction 7. for-range based loop 8. trailing return type: auto computePayoff(double x) -&gt; double 9. and more ...
Well, strongly-typed enums were designed exactly to make this code invalid: ```cpp enum FooEnum { A=0, B, C }; void enum_cast() { int x = A; // (1) enum FooEnum foo = 2; // (2) } ```
&gt; Large amounts of inline code is bad in large scale software, due to rebuild time. So minimize templates and do a lot of work to keep as much non-trivial code out of line as possible. This is only an issue if you don't know how to split template code. Doing that does have the drawback that you will have a "migraine" with three files: 1. Declaration 2. Definition 3. Instantiation as opposed to the "headache^(TM)" of having two files.
All things pass. I think it may be past time that something radical was done, like freeze the current language where it is, leave it for those who need it with only fixes moving forward, and start over with a reasonably fresh slate after a massive cleaning of the attic. At some point mass and inertia won't be enough to protect C++ any longer against more modern competitors (meaning ones that could actually compete in the same broad space.) If the C++ world doesn't do it itself, someone else may.
&gt; How many different C++‚Äôs are out there now though? One. There's only one standard C++. The way you choose to use that standard doesn't matter. It doesn't matter if you choose to deviate from the standard by turning off exceptions. &amp;nbsp; Back to python, there's two pythons (at least currently supported). And I'm not just talking about simple things like `unicode` by default. CPython is a huge mess just because of the fork. &gt; Python 3 and 2 are indeed different languages and they managed that poorly. C++ could do better. I honestly doubt any language could ever introduce a fork and not split a community for god knows how many years to come. It hinders adoption, it means many projects won't ever move to the fork and the worst of all it means you're leaving behind a non-zero piece of community. &gt; I agree it would be a fork and I think that‚Äôs what we actually need. D... D is really close to a clean fork of C++. How popular it is? &amp;nbsp; &amp;nbsp; Another reason why forking a language is a bad idea is, well, good luck getting people to agree what should be thrown away. - Raw pointer? - Well, my project has a TU that's almost impossible to compile if I use anything but raw pointers in one place. - `new` and `delete` should return `unique_ptr`? - Sure, I won't argue. - Move by default? - Yikes, that sounds dangerous and can be trivially demonstrated why. We can keep arguing what does a C++ fork mean and we will neve reach a consensus, because for different people it means a different thing.
Or, another possible alternative is that you could just use a lot less templated code. Then you don't have to jump through those hoops, you tend to get far more understandable errors, more possibilities for ABI, and likely more debuggable code, and of course the ability to keep the code for exposed proprietary.
Ya, completely unclear. Still is, because my naive mapping of your statements helps the vector impossibility problem not one iota.
for the std containers, couldnt the standard library just introduce additional overloads which take signed integers for indexing? so we can get rid of the warnings and wont have breaking changes?
In mine I use a simple hierarchy, and there's more to it than just the JSON stuff. There's parsing and formatting and such and of course containment in the case of arrays and objects. In my case it's sort of a hybrid, in that there are are only three node derivatives, arrays, objects, and values. The values class just deals with all of the basic value types and you can just check the type via enum. The array and object classes deal with containment and iteration and searching.
It is not beneficial to use unions, unless you want to interface C APIs or to build a C API for your library tha can be called from C or some foreign function interface. You don't need to use unions in C++, in C++ 17 you can use std::variant or its predecessor which is Boost.Variant if you are not allowed to use C++17. You can also use the container std::any that can store anything from C++17 or its predecessor Boost.Variant. &amp;#x200B; One of the few use cases I can see is this &amp;#x200B; union Variant { int VInt; double VDouble; char VChar; char* VPChar, void* VPVoid} ; extern "C" void callLibraryFunction(const char* fun_ame, Variant* args, Variant* result) { std::string name = fun_name; if(name == "function1"){ result-&gt;VInt = MyNamespace::function1(args[0].VInt, args[0].VDouble, ...); return; } if(name == "createObject") { result-&gt;VPVoid = new Shape(args[0].VInt, args[1].VChar); return; } if(name == "computeRoot") { result-&gt;VDouble = MyNamespace::root(args[0].VInt, args[1].VDouble); } .... ... ... } It is a type of type erarsure and allows a C code or foreign-function interface such as Python FFI (Foreign Function Interface) to call any function of my code indirectly using the same interface. Unfortunately, the only way to call C++ code from any other language is by providing a C interface to it because C++ lacks a stable ABI Application Binary Interface. The C interface is also one of the few ways to a C++ call another C++ code as shared library, but built with a different compiler. This technique is used by Microsft IDispatch COM Interface allow calling any class method implementing this interface with the same function.
Geocustomary.
The article incorrectly claims the following code is valid C: &gt; const int x = 100; &gt; int* x_ptr = &amp;x; It's actually a constraint violation and if you don't see an error message then you aren't invoking your compiler in standard mode. Also the whole discussion of malloc is rather questionable.
You can't forbid `memcpy`; it's a free function that requires nothing but a source, destination, and size. That said, if you expect anything reasonable from the result of side-stepping the API for a type in that way, you're going to be disappointed.