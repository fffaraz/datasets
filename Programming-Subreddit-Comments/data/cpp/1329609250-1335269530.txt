I've used them all, and personally I prefer Antlr. However, it doesn't do a good job of generating C++ parsers (if it works at all). I'm using the C# parser (which isn't perfect, but I've managed to fix the issues). Other options are C and Java. One option would be to use Antlr, then use C or Java to serialize the AST tree, and use C++ to do the heavy lifting. 
Debian has it's place I don't dispute that. But to the end user debian being constantly behind the times is just a bit dull, for example (I use Debain at work) I have chromium-browser, it is version 6 in debian squeeze which is still pretty new and that ins't going to change util 7, on my arch box I have version &gt;17 Yes you can get newer stuff from backports or whatever but it is a lot better not having to fight your distro fro the updates.
tl;dr is that I and probably some other programmers would be better off prototyping their applications in Python. Disclaimer: I'm far from both [a] C++ and [a] Python expert. :)
Classes, yes. Inheritance and class hierarchies, not so much. Is there any virtual function in the STL?
&gt; no garbage collector, making it difficult to manage a Derived object though a Base* How does garbage collection help this? In C++, you're expected to clean up after yourself regardless; I don't see how this is some special case.
Personally I think you should only deal with C++ if you need to care about things like memory layout of your objects and IO. C++ allows you to code in an OO manner if you need to, while still allowing you to carefully manage the actual interaction between the representation of the data and it's storage. If you don't care about how your data structures are actually implemented, then I really see no reason to use a language like C++. As a corollary typically you choose C++ because you want to fine tune your data structures for maximum performance, which typically means designing your data structures so that they are well suited for whatever architecture you're targeting. If you don't care for such control over how well your code performs (i.e., beyond picking a suitable yet 'fast' algorithm) then a scripting language would be the way to go IMO.
Object-oriented: you end up with code like `Base* ptr= new Derived;`, and you move your pointer around. If you need several of them, you need a `vector&lt;Base*&gt;`, and you need to manage their life span. (Of course, that was before C++11.) ------- Not object-oriented: The static type being the same as the dynamic type, you can move objects around. They can live on the stack. You can copy them as necessary. If you need several of them, you can put them in a `vector&lt;MyClass&gt;`. You can let the compiler handle their life span; there's no need to ever call `delete`. 
The documentation thing is a bit of an issue. I found a website that has a number of pretty good examples... for spirit v1.
What do you mean "moderately complex" ? I've played with spirit, I'm pretty sure that my project is considered small but after the first week of "WTF?!?" you start speaking spirit fluently.
Can you give us a code snip of your DSL? Maybe we will have even a better solution according to your needs.
Another option would be Lua, a scripting language whose whole purpose in life is to be used through a C interface to add scripting capabilities to native programs. I haven't used it in a project yet, but I was strongly considering it right before I changed jobs last. 
&gt; What do you mean "moderately complex" ? I mean a grammar that has a fairly wide mix of production rules and semantic actions. Something that begins to exercise the complexity and power of the library. I've written parsers in spirit that have probably over a 100 or so production rules, a fairly large number of semantic actions, etc. I would consider these moderately complex. It's not that the library is difficult to learn. It's actually pretty straight forward if you're familiar with boost style. I've just found that at a certain level of complexity you find yourself fighting against the library, and what I said about compile times exploding is no joke. If you asked me *"How would you like your parser generator to communicate grammar definition errors?"*. I would have to admit that 100-level deep compile-time template expansion error traces would be pretty low on my list. Again, this is only my personal experience and I want to stress that I still use spirit as I find it incredibly useful for smaller grammars, I just think that it has its limits as a general-purpose parser generator. 
Yeah i checked that out and changed it up. Still no dice
thanks for your help, it was a problem with my include files.
This is sort of what I was hoping would be the case, I have never had to use Spirit for anything big enough to force me to have it engrained but I couldn't see at that point if that would ever be the case. One thing I would say is that I wish they would ditch pheonix and relay on C++11 lambdas, pheonix just makes the learning curve brutal.
I think he meant to say &gt;There's no casting going on. void ** isn't castable to a (const void *) *, it simply is a (void *) *.
Why isn't i ta void ** though?
One hint: You need dynamic memory. And now get out of here and do you own homework! This is not a please-do-my-homework-for-me kind of forum. Hence downvote.
You could have a running total of the GPA with a counter adding up how many grades you've added. Then just divide total by the number of grades then you have your average GPA. Or is there another reason why you need to store all of the grades? Hope that helps. 
This is C, what is it doing in C++? you haven't even used `cstdio`
Step away from the code for a moment, and think about what you're trying to accomplish. Programming is as much about planning as it is about hacking out the code. There are a lot of ways to do this assignment. You need to decide how YOU want to do it. Here's how I would think of the problem ... maybe it will help you out here. GOAL: Calculate GPA Input: Grades The program will have 3 parts that I can see: 1) Ask for grades (Input) 2) Calculate GPA (Process) 3) Print GPA (Output) By the time we get to step 2, the program should have all the data it needs to complete its run. So, what does it need? GPA = (sum of grades) / (number of grades) So, at minimum the program needs 2 pieces of data (sum of the grades and the number of grades). You need to store this data somehow during part 1, when your program is gathering all the data it needs. In part 1, you will be gathering data repetitively, so you'll likely need a loop of some sort. Give it another shot, and see if you can get any further with these bits of advice.
I downvoted you for the following reasons * philosophical: answering homework questions * bad code: style: mixing braces/no braces in if/else * bad code: practice: doing math on offset ASCII values of characters * bad code: casts: static_cast changing fundamental type * bad code: declaration: "unsigned" without specifier is ambiguous * bad code: iostreams: while(cin) considered dubious * bad code: style: inconsistent whitespace usage
&gt; in the STL, look at the i/ostream components OK, now I'm confused. What's your definition of "STL" exactly? Did you mean the SL? Something else? http://en.wikipedia.org/wiki/Standard_Template_Library
What do you know already? Functions? Casting? Classes? Templates?
[projecteuler.net](http://projecteuler.net/)
/r/dailyprogrammer has quite a few challenges, with 3 difficulty levels. 
You won't learn anything if you don't find it interesting so try to think up a project you think is interesting! It doesn't matter if you think you can't do it, because than you'll learn things. Try to challenge yourself to do stuff you think is too hard. Some ideas: * Image generation (png, jpg, bmp) * ID3 tag reading * CGI programming
You're calling [`read`](http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html).
You might start toying around with image processing libraries like OpenCV. They have good tutorials to get you started and you get the satisfaction of having a "tangible" result rather quickly. A simple project would be face detection in a webcam image. The advantage of working with tutorials is that you can pick up many concepts just by seeing them used. I was always puzzled by iterators and similar advanced concepts until I saw them used in a tutorial. And once you have mastered the tutorial stuff, you can easily move on to other stuff. If you have a Kinect lying around, the Point Cloud Library would be another good start. Excellent tutorials, active community and fun to toy around with. Scan your desk and use it as a Level for a shooter! :-) Also: cplusplus.com is a comprehensive resource for good tutorials and reference. Highly recommended!
Why? One of C++'s features is its ability to interact nigh-seamlessly with C. It's not like there's a POSIX C++ API that should be used instead, and avoiding POSIX entirely isn't a good workaround.
In two words: dependent name(s). Source: http://eigen.tuxfamily.org/dox-devel/TopicTemplateKeyword.html 
Don't know if you would consider this a good reason, but in the Bullet Physics engine, void* are used to store arbitrary pointers to user objects in collision objects. Basically they know that you'll need to know more about the object involved in a collision then the pure physics, but allow you the freedom to chose what the more will be.
Who is making the decision about what compiler / version you are using? If it's the Lead Developer, can you not suggest GCC 4.7+ w/ Code::Blocks?
You're awesome, thank you so much.
Fantastic! Subscribed to that subreddit. :) &lt;3
This actually helps out.. a lot, I never really thought about it like this and you're right. I'll put more of a thought into my desired route to go down! Thanks a ton! &lt;3
Thank you! :)
This is nothing new to some here. I see it mentioned a few times in comments, but no direct submitted links found. I just thought more people should know about it. :-)
Your linked page doesn't say much. Is it an alternative to libcurl or something?
So, it's actually an alternative to Boost?
I have tried almost all parsers that could be used in C/C++ including Antlr, Yacc, spirit, etc and the best one I have found till date is [Lemon](http://www.hwaci.com/sw/lemon/). It is developed by D Richard Hipp of Sqlite fame, it is somewhat Yacc compatible and extremely lightweight and easy to use. It does not use any global variables/functions. 
Thanks for the responses; I can see how a parser could get confused, in the situations presented. But what about the specific situation that was bugging me: the need for "typename" *immediately after* "typedef"? WTF *but* a type name could appear there? If the parser is *ever* to know, that it must now parse a definition of a type, it should know it after scanning the keyword "typedef". 
This is what I've been waiting. Maybe it's time to throw GCC away and switch to Clang.
About damn time.
Interesting...my thoughts on lamba support is that it gets rid of irritating boilerplate code but doesn't really bring much new otherwise, not enough to abandon older compilers yet. But it does open up more choice with being another major compiler with support. Now the rvalue ref stuff...
Clang crashes with a segfault here when using lambdas (Mac OS X Lion, latest clang from SVN). Can anyone reproduce that?
Cool, something to play with instead of doing real work!
&gt; complete C++11 standard library Read this again.
Pls give an example? Just curious.
Apparently, [executables built with VC++ 11 won't run on Windows XP](https://connect.microsoft.com/VisualStudio/feedback/details/690617/bug-apps-created-with-crt-and-mfc-vnext-11-cannot-be-used-on-windows-xp-sp3). I wonder how limiting this will be to its adoption.
Does anyone know the status of g++ vis-Ã -vis C++11?
This is what you get when you depend on arbitrary decisions of a single vendor.
I think it's the furthest along: http://gcc.gnu.org/projects/cxx0x.html It's bizarre to me that they standardize on feature's that nobody has implemented. Why isn't there a reference implementation in one of the open source compilers?
What he means is that in order to claim that they have the complete C++11 standard library, they need initializer lists, variadic templates and other features upon which the new C++11 standard library depends upon.
Yes you could if you statically linked to the runtime dependencies.
As two points: * You can still use older versions of VC++ to compile for XP * Unless *you* write/contribute to the your compiler of your choice you are still at the mercy of someone else's arbitrary decisions
&gt;given how much of a pain VC++10 has been. Can you elaborate a bit on that? It would be interesting for those of us who don't have any experience with VC++.
I'm trying to understand counters, I've been reading around but my brain isn't getting it. One of the problems is that I need to store the grade (A=4, B=3, C=2, D=1, F=0), multiple each grade by the *unit* worth and then divide all that by the total grades. ex: I got an A in a 2-unit course, a B in a 4-unit course, and an A in a 4-unit course. (4x2 + 3x4 + 4x4) / 11 = GPA
Thank you! The logic is throwing me a bit, but after working on it some more I'm having trouble figuring out the syntax/how to write the program and how to calculate the GPA using numbers I don't have yet. 
boost::spirit can generate template function names that are over a kilobyte long. Our spirit grammar is pretty much arithmetic operations. True story.
The answer is yes: I do it today with commercial builds on arch linux. I build a custom glibc that has the proper kernel version configured, add a compile flag to bypass some recent buffer overflow guards and link what I can statically. I also I have to override the memcpy symbol but that's easy to do and easy to find using searches. People are running our software with c++11 features on redhat7 amd64 systems, although things like "ldd" are broken on those systems.
You can use older versions of VC++ to compile your C++03 programs for XP. That's not exactly the same thing. And I don't see a very convincing reason for this decision apart from that they want to push everyone away from xp and buy a newer windows.
Probably not his same issue, but code I had compiling and running fine with msvc8, msvc9, clang, gcc and borland now crashes at runtime with msvc10. I had to turn down the optimization levels to stop the crashing (or rewrite a bunch of perfectly good constructors to get around the bug).
Writing a c++ compiler is incredibly hard. It's a nightmare for parsing and resolving.
It's more than just trying to push a new version of windows on people. One of the big announcements they made for this beta was that its running on top of the new Concurrency runtime and exploiting options that only the new OS offers. If you're going to target an aging OS, one that will stop being supported altogether by microsoft during the lifecycle of the Visual Studio 11 product, then it only makes sense you have to build software with the appropriate tools of that platform. Mainstream support for XP ended in 2009 and extended support ends in 2014. People who are just now starting new projects: why would you target a platform that won't even be receiving security patches in the next couple of years?
Yeah, I'm aware of this. The object code that spirit generated for one of my parsers was well over a gigabyte if I remember correctly.
Gtk is written in C. [Gtkmm](http://www.gtkmm.org/) is the wrapper for C++. Do you still need to use moc with Qt? That always weirded me out. Also, the thing that previously drove me away from it was that until recently (2009), Qt couldn't be used in closed source applications unless you bought their commercial license (It was GPL, not LGPL).
The biggest decision to make here is the platforms you are planning on shipping to. If your target is Linux, then GTK+ or Qt is probably a good idea. OS X uses Cocoa, and Windows uses their own GUI libraries. In general, you're able to run code from Qt and GTK+ on all of these systems. However, they don't necessarily look like native applications.
Using libraries has nothing to do with being able to run from CD without having to install something. On windows, the directory of the executable is part of the search path for DLLs, so as long as you just put everything in one dir you can use whatever libraries you like. On linux you can write a wrapper script that adds the appropriate directory to LD_LIBRARY_PATH. Or in both cases, you can statically link.
My criticism is strictly at VS 2010. VS 2008 had a much much better compiler and VS 2010 is still a really good IDE. But my criticism at a high level is that the VC++10 compiler implemented an incomplete standard as if it was ready for production and in doing so introduced a lot of compiler related bugs, bugs which result in run time crashes or produce code which is simply non conforming. Reasonably speaking all C++ compilers have bugs in them, but usually they're obscure or minor. Like typically if your program crashes, you can be more than 99.999% certain it's a result of your own programming, with VC++10 it's more like 95% certain it's a result of your own programming, 5% certain it's a result of Microsoft screwing something up. You'd think that wouldn't be a big deal, but that 5% is enough to make you always second guess everything you program and get paranoid just enough that you lack the kind of trust you normally expect to have with your compiler. Now whenever your code breaks, even though it's still overwhelmingly likely it's because you messed up, you still have that nagging suspicion it's due to the compiler, and you'll find on far too many occasions that your paranoia is justified. There are issues with lambda expressions, with STL containers and the use of emplace or the use of the standard library and move semantics, and these issues result in run time crashes. And the worst thing is, you are forced to use Microsoft's buggy interpretation of what was at the time an incomplete draft of the C++ standard. It's not like GCC where you can enable it using a flag, you're forced to use C++11 with VC++10. My opinion is just avoid it. Stick to 2008 and then get 2012 if you really don't need Windows XP support. Visual Studio is an amazing IDE in my opinion, probably the best IDE for C++ development, and that's why it really sucks that the compiler itself is such a piece of crap. My hope is that a clang or Mingw plug-in for Visual Studio 2012 comes along, now that would be awesome and I'd pay good money for it.
&gt; Do you still need to use moc with Qt? Yes, I think so still - [this](http://developer.qt.nokia.com/doc/qt-4.8/signalsandslots.html#using-qt-with-3rd-party-signals-and-slots) talks about replacing the Qt keywords, but not the mechanism so, yeah. Qt has been bought by Nokia and completely opened up; you can use it any way, even commercially, for free now. 
This is one of the key things to think about. And you will also need to make sure the library and dependencies can be statically linked in to make the app self contained.
Let me clarify, I mean install from cd. Also, I have no experience with c++ gui frameworks, but I have experience with tkinter in python and swing in java.
No love at all here for wxWidgets right now. I have no idea what you mean by "run from a CD", but GUI applications built with wxWidgets are portable (at least you can compile them for other operating systems), don't require any external library DLL crap (on Windows), have a native look and feel, and it has a permissive license (GPL but you can distribute any wxWidgets application on your own terms, even commercially). I don't love the everything about it, but it's mostly an all-around winner for me.
I'll throw my vote down for wxWidgets as well. It's a great library, good documentation, and it's easy to get your head around.
I understand XP is still in use, hence the "build software with the appropriate tools for that platform". In 2 short years XP won't even have security updates coming down for it... any corporation still running XP at that time is irresponsible at best (especially if those machines are connected to the web). At what point do you drop support for XP? Also, the concurrency runtime is a big deal for the STL on Windows, it is powering futures and async which IS C++11. I'm not saying politics don't play a role but you statement is unfair as there are very clearly technical reasons for the move (especially given how close XP is to EOL).
&gt; my professor. Oh, OK, it's a school thing. That explains a lot. It's a very important point, that you should have mentioned from the start. 
Seriously? You didn't even bother to address any of cabbageturnip's valid points. Also, they've effectively done what you've stated. They implemented the standard library and they very clearly stated that initializer lists and variadic templates are not in this release, so what more is it they were suppose to do? If you are going to claim they haven't implemented the complete library then please... point out for me a single class or function from the new standard that isn't in VS11.
We'll drop support when not enough customers want it. However, our software is supposed to run on XP and older, so what is the appropriate tools for the platform? And if they intermingled a Windows7+ OS feature with their C++11 implementation that is still a political move. 
Actually, not true; the side-by-side mechanism makes it *really* fucking difficult/insane/stupid to deploy stuff that uses MSVCRT unless you have a full install. Static link is your best choice, unless you can completely control the entire build of all the dlls you are going to use.
Okay, so you ALSO need to learn to use an installer. I recommend Inno Setup - works great, easy, free. If you haven't done so already, go to the library and check out some Qt programming books (I think one or two are avail online for free). C++ Gui Programming with Qt 4 is a decent one.
It now supports VC11
As the main developer of Minetest and knowing MarkTraceur, I find this discussion amusing.
Thats kind of like the map_keys and map_values range adaptors from boost
I completely understand that moc is implementing things that are not possible in standard c++. The big difference to me between bison (or tblgen or yacc) and moc is that the former items produce a .c (or .cc) file whereas moc is producing a .h file. It's just weird to me that the interface to my objects is not static. The other difference is that if you build a library that uses Bison, the consumers of your library never need to use Bison themselves (other than to build the one .c file). All consumers of the Qt libraries need to use moc to build their systems. I don't have anything big against it. It's just something that I found quite unexpected when I was last investigating GUI stuff.
&gt; I completely understand that moc is implementing things that are not possible in standard c++. I think I see what you mean, but `moc` *is* implementing things possible in standard C++. It just does it for you, correctly, instead of making you hard-code it in yourself. &gt; The big difference to me between bison (or tblgen or yacc) and moc is that the former items produce a .c (or .cc) file whereas moc is producing a .h file. Well a .h file is the same as a .cpp or .c file (depending on the language), it's only by convention that we end it in .h to indicate that it's interface/API information instead of implementation code. As far as `moc` goes, it generates implementation code, not interface code (and so by your example it's generating .cpp, not .h). It is true that during the Qt 2/3 timeframe the recommended way to include `moc` output into the build system was to do something like: #include "foo.moc" at the end of your class implementation's .cpp file, but that was just a build system implementation detail (it made it easier for the build system to figure out which .h file the moc output needed to be generated from, without `#include`ing the moc output multiple times). Nowadays build systems simply "automoc" the source code and you don't even have to add `#include` lines (although they still work). In the absence of manual inclusion automocs simply make a moc_foo.cpp for each foo.h and compile that .cpp separately and link it in with the rest of the object code (and this is all transparent to the developer). &gt; The other difference is that if you build a library that uses Bison, the consumers of your library never need to use Bison themselves (other than to build the one .c file). All consumers of the Qt libraries need to use moc to build their systems. You only *need* `moc` to use features that require it. Mind, that's a lot of different features but if you make e.g. a very simple application that just constructed some `QWidget`s and connected pre-defined signals to pre-defined slots you wouldn't need to run `moc` at all at any point while building the application (I encourage you to try this). One thing you can do with `bison` that you can't with `moc` is to pre-generate the resultant .c/.cpp code and include that with your sources (the reason you can't being that moc-generated code is versioned to the Qt being used at the time of the build, it would work fine if you didn't mind the risk of incompatible versions breaking the build). Even here though the idea with `bison` is you'd be making it easier for end-devs to build your code even without Bison, but that's not a concern with building Qt since by definition you should have `moc` available. &gt; It's just something that I found quite unexpected when I was last investigating GUI stuff. There's even more unexpected stuff one could do with code generation during a build... you can significantly reduce code text size for example by packing `const char*` strings into a single character array, a task that would be made more maintainable by having a separate script to do it at build-time (although Ulrich Drepper's excellent DSO-writing guide gives an example how to do this without external tools). On that note, C and C++ use the `cpp` tool to great effect (it's also a code generator, but it's specified by the standard and so presumably you're used to it.... but it's not a part of the language proper beyond that). Another popular example (especially for GUIs!) is including binary data inline into a compiled executable (Microsoft's venerable resource compiler for instance, and Qt supports resource inclusion as well). Sure you /could/ transcribe each byte by hand, but this is the kind of thing that a computer *should* be doing anyways.
Based on the original request regarding library bloat I would definitly suggest fltk. You can easily configure it to turn off even more features if need be. The callback mechanism is primitive but still effective and you have a level of directness and control you don't seem to have with Qt. Oh yeah, I also cooked up some basic automatic layout classes which allow you to not have to hard specify locations (for fltk2, i should port to fltk3).
Well.. then don't make any mistakes :P Yeah template errors are the main errors that annoy me when building C++ code. And also code that includes unnecessary header files slowing down the entire build. 
Xcode does a really nice job organizing backtraces from errors in the ide. It makes visual studio look like the stone ages.(its not even color coded). If you are just using the command line, you can try clang, its cleaner than gcc, and its in color.
Get Clang.
Thanks, it really makes a difference!
I run using the qtcreator ide on Fedora 16, it makes reading errors somewhat easier since you can step through them directly in your code. Not perfect, but what is?
Filed/found bug with fedora?
The language says you can't do that because `this` is not a constant expression, so all things dependant on `this` (like members) cannot be constant expressions. Even if it compiled, your implementation is flawed: constexpr _Tp* _v; That would declare that _v is a non-constant pointer to constant data. Your constructor: constexpr explicit nullable(_Tp v) : _v(&amp;v) { } Saves the address of a temporary... So my question is: What are you *trying* to accomplish here? C++ doesn't need "Nullable&lt;T&gt;" like C# does, since pointers are first-class citizens. If you're looking for an optional type, check out [Boost.Optional](http://www.boost.org/doc/libs/1_49_0/libs/optional/doc/html/index.html). This is what it looks like without all the pesky cross-platform code and funny macros: template &lt;typename T&gt; class optional { public: optional() : _has_value(false) { } optional(const T&amp; t) : _has_value(false) { new((void*)_storage) T(t); _has_value = true; } ~optional() { if (_has_value) get().~T(); } T&amp; get() { assert(_has_value); return *reinterpret_cast&lt;T*&gt;(_storage); } private: bool _has_value; typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type _storage[sizeof(T)]; };
I believe the Google Clang developers are working on this.
Don't feel bad, They weren't dropped only postponed. There is still hope :)
http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys is the URL you should have posted. You don't need a link shortener to post a link like [this](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys). Good video and discussion anyway.
There is one issue with this implementation of optional: Alignment. Fortunately, the C++11 standard includes a nice template called aligned_storage which can be used instead of the raw char array: typename aligned_storage&lt;sizeof(T),alignof(T)&gt;::type storage_; 
Did you build it from source or install from rawhide? I can't find RPM for 3.0 in F16 repos.
Damn, my eyes hurt when looking at that. Either switch to clang or install [colorgcc](http://schlueters.de/colorgcc.html).
Why not? This was of course done as an exercise to learn C++11, not because there wasn't something like it already :)
Clang is wonderful, but templates can defeat even the best. :) http://807be77a274c5138.paste.se/
The effects of getting rid of boiler plate are greater than saving keystrokes. Because it is less effort to introduce a functor, you are more likely to use the std algorithms like std::transform or std::remove_if etc... This means a greater percentage of your code is standard library stuff, which reduces the chance for bugs and makes reading code easier. (hopefully).
Not sure what you a replying to with your first sentence. Sure, gcc breaks compatibility frequently, so it seems fair to allow one for MS. I still think that comparing to gcc and Linux systems in this regard is not a really good comparison. It is one of the areas that MS does (did) right and FOSS systems did wrong (binary compatibility). Microsoft, up until this point, was very careful about not breaking compatibility. You have a very good chance of successfully running 20-30+ years old windows applications even on a Win7 box. I'm not sure of your last sentence either. Not everyone has the same problem, so the discussion is pointless? 
There are more issues than that one -- my use of reinterpret_cast breaks strict aliasing, which can lead to funny issues when optimization happens. Luckily, aligned_storage fixes both of these issues. I've updated my implementation to include it.
You've shown in a simple case that you can do the assertion at compile time, but it really isn't possible to do in the general case. Consider this function: void print_it(const nullable&lt;int&gt;&amp; i) { std::cout &lt;&lt; *i &lt;&lt; std::endl; } The `i` in that function *could have come from anywhere*. The compiler can't prove anything about the contents of `i`, even if you mark it as constexpr (because constexpr functions can still be executed at run-time). Or perhaps this: void foo(bool set) { nullable&lt;int&gt; a; if (set) a = nullable&lt;int&gt;(4); std::cout &lt;&lt; *a; } It is impossible to know if that should be a static assertion or not because the value of `a` is based on a non constexpr value. The compiler would have to make sure that `foo` is only called with `true`, which is [a difficult problem to solve](http://en.wikipedia.org/wiki/Halting_Problem). It really depends what you're trying to do here. If you're trying to do it for optimization purposes, just take the check out, as the compiler is allowed to assume you will never dereference null. If you're trying to get an error when you dereference null, and you would have gotten a segfault with the next operation anyway, so preempting that isn't buying you much. If you're trying to make sure you're not using null at compile time, then don't use nullable types in the first place.
I'm in no way trying to rain on your parade but there is only one (maybe two) features here that are C++11. The new function notation and decltype and both are not necessary at all. (Oh, well std::get for pair). 
No worries, and yeah, I'm still getting the hang of the new stuff in C++11. So far though, as far as the language features go, the new stuff in C++11 aside from R-value references mostly seem to simplify things that could already be done in more elaborate ways. This was posted more in the vein of 'lets figure out these new features together' than attempting to replace boost or anything like that. I have some other little programs in that github repo that use more C++11 features, like an implementation of scheme complete with macros and call/cc based on Peter Norvigs lispy.py.
Thank you for explanation. It makes more sense now.
But clang can print it out in color, and shortens a lot of the types, when it prints the error. Of course, clang still prints out the backtrace(how else can you debug without the backtrace?) But I think in your case, the error messages could be improved in boost, by using some more enable_if and static_asserts, but may require using sfinae for expressions(which clang and gcc support, but since vc doesn't yet I believe boost doesn't use it yet). If I were to take a guess I would assume the error is from missing a "case" in the visitor, but I could be totally wrong.
Come on. You call that template barf? You know something is wrong when the Emacs *compilation* window is reporting stack overflows because it cannot parse the error output. All you have here is a mismatched argument in a call to the trie_iterator constructor because you are trying to copy construct it from a trie. You even get a decent list of alternatives. Step up your game. 
Yeah, I agree that clang is miles ahead of gcc even when it produces 500 line errors. The real issue to me in this case is the implementation of boost::variant which always results in a huge typename since it puts void placeholders in its 15 or so template arguments. Hopefully it should be possible to make the variant implementation a bit cleaner with unrestricted unions and variadic templates in C++11.
http://www.catb.org/~esr/deheader/deheader.html Haven't used it, though. 
The record in our lab is around 68 pages printed.
Enjoy your 4GB address space. I'll be over here with my 16 GB of memory.
I only use it about once a month, but there's no substitute. Here's hoping there's a Kindle version. 
&gt; "Either way, I entirely understand why you felt we were going in the wrong direction before - the nuances of our position weren't public, because of the way we work on these issues - ..." Arguing that your public view is going in one direction, whilst "nuances" were privately leading in apparently completely the opposite direction seems a bit facile.
That's the spirit. Now get out boost::variant, boost::mpl and boost::parameters. Hours of fun are guaranteed. And I don't mean the hours you will spent fencing on chairs with your colleagues.
We used VC10 in production code and found the compiler very good but the IDE very bad.
I don't like the "matter of fact" tone of this post when the things it covers are obviously questionable. Just one example: &gt; The world migrated from native to managed languages over 10 years ago and never looked back because their performance is more than adequate. The author obviously hasn't paid attention to "the most valuable company in the world" news lately and that said company uses zero managed code on its platforms.
I was wondering about when unordered_map iterators would be invalid (if ever), and found this: http://www.cplusplus.com/reference/stl/unordered_map/insert/ &gt; On most cases, all iterators in the container remain valid after the insertion. The only exception being when the growth of the container forces a rehash. In this case, all iterators in the container are invalidated. &gt; A rehash is forced if the new container size after the insertion operation would increase above its capacity threshold (calculated as the container's bucket_count multiplied by its max_load_factor). &gt; References to elements in the unordered_map container remain valid in all cases, even after a rehash. ~~So, a container with new iterator invalidation rules!~~ They can become invalid after any insertion, unless you're keeping track. ~~That will take some getting used to.~~ 
&gt; I don't like the "matter of fact" tone of this post when the things it covers are obviously questionable. I couldn't agree more. I am so tired of all the C++ bashing by managed language self-proclaimed experts. I'm sure there *are* some particular optimisations that managed languages make easier, but there are other things that are inherently slower and always will be. I would be happy to see a new compiled language come in to replace C++. Something that is way easier to parse, with much stronger meta-programming support, Fortran level speed for arrays etc. I could even see 'D' being that language if garbage collection wasn't so embeded (even the standard library relies on it).
My personal experience with making large scale software in managed languages is that it starts out easier since you can effectively ignore memory management. Eventually memory management will become an issue, though. The software will be using too much memory, the GC stops the world for seconds at a time, it becomes extremely difficult to give any time guarantees for operations. At that point having it be managed is nothing but a pain, and ultimately you are stuck with a memory management system that you can't control and that doesn't do what you need and that you are forced to hack around, spending a lot more time and effort than you would have if you'd had a proper memory management plan from the beginning. With C++ or C, you pay the price of thinking about memory usage from the start, which makes it seem more complicated and more difficult. Sometimes, maybe, you never get to the point where memory usage becomes an issue, in which case using a managed language may be fine. There are plenty of situations where memory is not freely available though, and to hand control of it over to an automated system seems reckless at best.
&gt; Boost provides most (if not all) posix features, with added portability to non posix systems. With additional 104MB of header files and bloated compile times. Not that I'm against Boost (I use it myself), but it ain't magic pixie dust that should be sprinkled on every project.
Thanks for this assessment. Glanced at U++ a while back but this has encouraged me to look deeper, especially in view of recent grief trying to get stuff working in MFC after a long time away from it.
If your application is successful, a time will come when even 10% extra that the immutability or garbage collection cost you in processing resources will be unacceptable. That's why all the big guys (Google, Facebook, Amazon, etc) run C++ on their servers. 
It's possible, Haskell is definitely very interesting. I really need to get around to taking a closer look at it one of these days. There are many different aspects to consider, security is definitely a major one. I do think that modern C++ style helps to avoid most of the major security issues - RAII and templates enable strict typing and lets you avoid raw pointers and lost type information in many places where it wasn't possible before. Even good old printf can be made safe(r) with variadic templates these days. "Old-style" C++ with object oriented class hierarchies, news and deletes all over the place and pointers passed around willy nilly is not much better than plain C when it comes to security issues, I'll certainly agree about that.
1) `secondInteger-firstInteger` would return a difference in `ints`, not in bytes. Use `sizeof` or cast pointers to `(*char)` before doing arithmetic. 2) Allocating twice with `new` does not guarantee that the objects will be even remotely close in memory. Use a struct with two `int` members. 60 obviously makes no sense, try to find something sensible: http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86
So, to have a completely correct solution you would have to guarantee the struct is aligned to the biggest possible alignment. Assuming you do that when would the offset differ from the types alignment?
So, if he fixed all his errors he would get: struct align_helper { int m_a; int m_b; }; int main() { align_helper foo; int alignment = (int)((uint8_t*)(&amp;foo.m_b)-(uint8_t*)(&amp;foo.m_a)); } That doesn't work, for very many types... probably just 4 byte types. btmorex's solution is more correct.
But for some things that are 4 byte aligned the test for 8 byte alignment will pass. So then the aglorithm has to find the largest value that always seems to work. This kind of approach can never 'prove' that a type has a certain alignment, just do a large number of iterations and say that with a high level of statistical certainty the alignment is ___.
That will give you sizeof(T). What if your type was a structure of 4 ints? Or is simply 8 bytes on an architecture/compiler that only requires 4 byte alignment.
You're right. I was thinking arrays could be padded, and completely neglected the possibility that the alignment was smaller than the type size &gt;.&lt;
Assuming that you don't have any bizarre alignment requirements (If you arent using special alignment tricks, then you don't have the alignment requirements), then "sizeof(type)" will return what you want. For example "cout &lt;&lt; sizeof(int) &lt;&lt; endl;" prints "4" on my machine.
How did you access the C++11 material on cplusplus.com. I didn't think they were you going to update them. I generally prefer cppreference these days as it is more accurate, however I do like code examples.
Wow, stoneage... Just use your IDE (two mouseclicks in mine).
Alt+G in my setup, but yeah. I don't get the animosity towards tools that help (be it an IDE or just scripts for emacs or vi (for example) that can do that too).
Virtual functions will make this tricky. That is, in general case, you don't know until runtime which overriding function is going to be called.
That's true, though in practice I haven't had trouble with this at all back when I did Wii development (Visual Studio as IDE, with a custom set of Makefiles a colleague and I wrote that interfaced with the Metrowerks compiler for Wii).
By the way, you wouldn't actually need the array for this, since you could do something like: int* p0 = 0; int diff = (int)((char*)(p0+1));
Would return sizeof(test)-sizeof(T); work, too?
That's not a bad trick. My favorite way to do a function-rename is to: 1) create new function 2) keep the old function around, but change its return type Recompile. This will find all subclasses that override that method (since an overload is not allowed to change the return type -- nitpick: gotta pick something that isnt 'covariant', but just pick something unrelated to the original). After renaming all child overloads, remove the old function and recompile; that will force you to fix the callers. 
No, it's not guaranteed. The compiler is free to use whatever kind of alignment it determines is best for the struct. Normally, that alignment is a fixed width, regardless of type, unless it encounters a type narrower than system alignment. On x86, x86-64, PowerPC, and SPARC, I would expect this sample to always print 4. (I don't know what systems would print 8, but I know 68k would print 2.) That's largely inherent to the architecture, but dependent on compiler; but the types involved are mostly irrelevant. I say "mostly" because `get_alignment`&lt;`char`&gt; and `get_alignment`&lt;`short`&gt; should print 1 and 1 or 2 respectively on most platforms.
&gt;if GNU makes horrible decisions, everyone can and someone will fork it, for the benefit of everybody. And unless you're the person to do the fork, you're still at the mercy of someone else's decisions on how to do it. 
You can also use the `__attribute__ ((error("Fixme")))` in GCC and clang to print out error messages for when they are called.
Ever tried to statically link to glibc?
&gt; Well that sure sounds easy... /s It's not terribly hard if you provide the linker with the correct flags telling it where your libraries will be. I've done it for a NAS box that I was cross-compiling binaries for. I found out that the libc was very old and missing some features I wanted so I built my own libc and compiled everything against it. Seems to be working just fine. EDIT: Full disclosure: I use eglibc. GNU libc is a pain in the ass.
The clang guys are working on that. I find it kind of silly that we don't have one, yet. But I guess the difficulty of parsing C++ code could be a factor. 
I'll clarify this a little further and say that compilation of GNU libc for non-x86 targets is a pain in the ass. eglibc specifically targets ease of compilation on every platform they support. That includes x86 (since as far as I know Ubuntu is using eglibc). 
Is this one of Saty's classes?
I used [ccm](http://blunck.se/ccm.html). simple as cake. 
sloccount does some basic analysis
open source ??
sloccount for really simple stuff. I am a big fan of CppDepend which is not open source
I tend to agree. The whole notion of copyright has gone in the wrong direction in the last few years. It was one thing to have a copyright on something for 20 or so years but now authors can maintain a copy right 70 years AFTER THEIR DEATH!! This should bother anybody with a sense of reason. So from my standpoint the system was borked before SOPA was even imagined. 
I would like to see a library for programming with SI units. Now that we have the ability to write custom literals, it should be trivial to add a library for doing stuff like auto length = 200_cm; auto height = 3_m; auto area = length * height; // Do the conversion under the hood, // return the correct unit. 
Maybe I should submit my proposal for [std::buffer](http://codesynthesis.com/~boris/blog/2011/08/09/do-we-need-std-buffer/). Though people seem to hate the idea for some reason...
This has lots of interesting things. It wouldn't be too crazy to extend this with the custom literals. * http://www.boost.org/doc/libs/1_49_0/doc/html/boost_units/Examples.html#boost_units.Examples.KitchenSinkExample * http://stackoverflow.com/questions/9257826/physical-boost-units-user-defined-literals
Yep, I saw it. I guess it doesn't need proposing then. Still it's something that really needs to be in there.
You will be sad to learn this will not be added. It was either herb sutter or Stroustrup himself that said at [going native](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012). Linear algebra is considered too narrow a field. They are looking for broadly useful libraries instead.
I wouldn't consider this linear algebra, but eh. If it's too narrow then I guess I'll have to roll my own, or wrap boost's units library with operator literals. Yay I have a new side project! :)
I guess I am missing something very obvious here, but what's the point of make_unique()? make_shared() is there to place both the counter and the object in the same memory block thus reducing the number of allocations required (thought at the expense of creating an extra vtable, one must remember; see [here](http://www.codesynthesis.com/~boris/blog/2010/05/24/smart-pointers-in-boost-tr1-cxx-x0/) for details). What would make_unique() add to unique_ptr&lt;T&gt; x (new T (...))?
I never really thought of it more than a convenience function, similar to how std::make_tuple, std::make_pair, and std::make_shared make life a bit easier.
It would enable: auto x = make_unique&lt;T&gt;(...)
By default Qt is built with RTTI and exceptions disabled. The introspection that Qt uses is enabled by the preprocessing that moc does, so the runtime cost of using introspection is pretty minimal. So your Qt-related part of your comment doesn't seem to be based on anything factual. Just saying. When it comes to problems with relative runtime costs in Qt versus modern idiomatic C++ there are much bigger targets in Qt :)
My example was a bit contrived. But literals are still useful for describing the constants that you do use. Though they should be avoided as much as they can, sometimes you do have to sprinkle a constant value somewhere into your code. There, literals can be useful. Consider rotating shapes or something, instead of having 3.1415's or 180.0's lying around, you can express them as what they really are: radians or degrees.
That always puzzled me a bit. It appears that there is almost universal consensus that C++ RTTI is slow or otherwise lacking. clang implements its own, Qt implements its own. Now im not sure how Qt uses this now, but clang pretty much uses it for down-casts. Are standard implementations of RTTI really that bad? Serious question. Didn't have much use for the feature myself, other then occasional code that does some debug logging. 
I don't think asking for a boost_units-like library is the same as asking for a linear algebra library. It *seems* like a straight-forward implementation of the [SI](http://en.wikipedia.org/wiki/International_System_of_Units). &gt;Linear algebra is considered too narrow a field. And things like Hyperbolic functions and Error and Gamma functions aren't?!? Linear algebra is used in so may fields such as statistics, optimization, EE, etc. having a basic set of classes (matrix with all the usual operations: *, +, etc.) and operations (dot_product, inverse, etc.) would be a nice common infrastructure that each field could base their specialized matrix algorithms on.
I'm not arguing with you. I'd also like to see a Linear Algebra library in the standard. Just passing on what I heard. (You can find the source if you spend some time looking at the vids in the link above)
It's a convenience function. Calling a factory function like make_pair allows the language to perform template type deduction - which isn't possible for a constructor call. It allows you to condense this: return std::pair&lt;std::map&lt;int, std::string&gt;::iterator, std::vector&lt;double&gt;::const_iterator&gt;&gt;(a, b); To this: return std::make_pair(a, b);
I think make_shared exists mainly because of a possible optimization. Instead of two allocations (new T and new RefCounter) implementers will probably write a make_shared that gets away with a single dynamic allocation only. Exception safety is another advantage because a function call introduces sequence points.
I think the Lockheed-Martin engineering team that lost the $125M Mars Orbiter might disagree with you on that ;-) . [Metric mishap caused loss of NASA orbiter](http://articles.cnn.com/1999-09-30/tech/9909_30_mars.metric.02_1_climate-orbiter-spacecraft-team-metric-system?_s=PM:TECH) Of course I don't know the exact nature of the bug that caused the problem, but maybe user-defined literal constants might have shown the problem as a syntax error instead of a run-time error.
The asio library has several buffer classes in it that might provide the same/similar functionality. I'd really like to see something like asio added to the C++ standard library so we have a high-performance network I/O library. Maybe you could influence an asio proposal to include your buffer library.
Note that a separate study group for networking has been set up at the Kona meeting, see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3374.htm
for tokenisation we already have regex ...
Conversion is one usage scenario that would benefit from it. You often see "magic" floating point constants in production code, and it can be hard to follow that sometimes. Especially distinguishing between coefficients and conversion constants is tricky.
Sorry for the snark, I'd just woken up. I'll head over to stackoverflow 
As far as i know with Qt, the meta data is generated at compile time, but is only available at run time(I think through QObject). 
Qt signals and slots do more than Boost.Signals and other similar signal implementations. First, Qt slots can be invoked dynamically, which adds a little reflection to C++. Second, they are part of the QObject metamodel, which means (among other things) that they map to scripts automatically (no "registration" code needed which associates strings with functions). Third, they can be used for cross-thread communication without any trouble. How would you achieve the first and second points in Boost.Signals? You would probably make a `std::map&lt;std::string, std::function&gt;` to find your functions, but then you would have a really hard time with marshalling your parameters in a generic fashion (this is runtime stuff, templates won't be an easy way out). Also, what happens in your implementation if you emit your signal but one of your receivers were destroyed in the meantime?
Who cares anymore? Use C++ and there's no problem with C-Pointers. std::unique_ptr&lt;int&gt; a, b, c; std::shared_ptr&lt;float&gt; d, e, f;
Reflection has no runtime cost in any language. It is just a bunch of data detailing the internals of data structures. Using reflection to do work has a runtime cost, but that's another thing, completely irrelevant.
What I'd like to see is: * proper unicode support. * recursive descent parser support. * signals and slots. 
Wrong, reflect has a big cost, Bjarne Stroustrup said that as is a C++ binary is approximately 80% code 20% data and in a experimental implementation of C++ with reflection a binary was 80% data 20% code. Given that there isn't going to be less code with relfection the size of binaries are going to sky rocket. That isn't acceptable when C++ is heavily used in embedded application and high performance applications. I really don't like the idea of features that can be turn off at the compilation stage, because then you end up with fragmentation in the code base. As is 95% of C++ is used by all it's users (exceptions are perhaps an example of that 5%). .
But this is already possible with type traits, I am all for improving type traits and adding more std provided traits (is_container, is_fwd_iterator sort of thing would be nice) using the existing language. Runtime reflection is what I want to avoid, that sort of "Method missing" and object has method. It would just make more bad code.
Reflection isn't a library, nor is it like inheritance or exceptions things you can just 'not use' the problem is that it is added to your binary whether you use it or not, like RTTI (which is bad enough), enough people (myseld inc) turn that off. The problem with that is you end up segregating the community into different styles of C++ (like we don't have enough of that already) those who use it and those who don't
Oh course it could be optional, like RTTI is. However that sort of "well this is C++ w/reflection and is in compatible with C++ wo/reflection" is not good, take for example a shared object, should that have reflection or not? Will it work if it doesn't and my code does (and visa versa). Having it 'per type' is a bit daft, you can already do this your self really easily, I do it for complex tree and graphs. Having it as a part of language will just make the language bigger and more complex. 
&gt; However that sort of "well this is C++ w/reflection and is in compatible with C++ wo/reflection" is not good I do not see any problems for code with reflection and code without reflection. If you wanted to use the reflection APIs, you could. If the information wasn't there, an exception would be thrown at run-time. What problem exactly do you have in mind? an example perhaps would help clarify the situation. &gt; take for example a shared object, should that have reflection or not? The reflection information could be in a different object file, optionally linked. &gt; Having it as a part of language will just make the language bigger and more complex. No language support is needed for reflection. Just compiler support (i.e. a flag to turn reflection on-off), and perhaps a #pragma directive. 
Your problem are the lines if (Temp&lt;Least) Temp=Least; Think about what happens the second time through your `while` statement. The value entered by the user is going to get clobbered. Step through this in your debugger: it should become pretty obvious what's happening. p.s. This belongs in /r/cpp_questions or on stackoverflow. 
Once you have the data at compile time you can generate the run-time data structures. The metadata generated by Qt can be generated by the preprocessor. That is, the preprocessor generates the metadata as templates. Then a base class(using CRTP) would override the virtual functions of the abstract base class, thus making the metadata available at runtime. This is the same technique i use to send messages(or rather objects) across a network. It could be further extended for signals and slots. The parameters can be marshalled across the function the same way the objects are marshalled across the network.
I'll spoil the fun. Part 5. Avoid threads, mutexes, joins, and promise. Its all too low level. Just use async and future.
I would report a bug upstream. Development is very active and I use the `HEAD` version daily without issues on a 10Mloc codebase.
~~ http://www.boost.org/doc/libs/1_41_0/libs/math/doc/sf_and_dist/html/math_toolkit/dist/dist_ref/dists/weibull.html ~~
It's not a bad idea. Boost.MathTookit/Statistical Distributions and Functions is not (not directly, that is, you can always use various methods like, say, CDF-inversion with it) for (P)RNG generation (that's in Boost.Random). You can use it to access the PDF (Probability Density Function): http://www.boost.org/doc/libs/release/libs/math/doc/sf_and_dist/html/math_toolkit/dist/dist_ref/nmp.html#math.dist.cdf Given access to the PDF, fitting the parameters is just a matter of using maximum likelihood estimation (MLE): http://en.wikipedia.org/wiki/Maximum_likelihood_estimation#Principles And to do MLE in C++ you simply need a (multivariate, since Weibull distribution has two parameters -- shape and scale -- that you're going to optimize over) non-linear optimization algorithm. One C++ library that is particularly easy to set-up and use (and uses the same license as Boost) is dlib: http://dlib.net/optimization.html Look here for examples: http://dlib.net/optimization_ex.cpp.html In your case, you need to replace the objective function ("rosen" in one of the above examples -- and possibly its derivative unless you choose to use finite differences for numerical approximation) with your (log)likelihood function (which is just a product of PDFs -- and recall you can obtain the PDF for Weibull from the above-mentioned Boost library). HTH! 
Do they not teach how to use a debugger in programming classes/labs any more?
yuck.
Wow, thanks. That was my thought, but in the end I decided to go with a much simpler solution if anyone is interested: 1) write data to a file data.dat. 2) write an r script which reads the data.dat, performs the fit, and writes the result to output.dat 3) in c++ make a system call to run R with the script as an input 4) read the result from output.dat :) 
In this case I obviously meant unique_ptr, which incurs absolutely no overhead and makes writing robust code a lot more feasible in the presence of exceptions. You should know to always use the correct shared pointer in regards to ownership semantics. If your situation requires sharing of ownership among any number of objects, you are bound to do some reference counting anyway. Why not leave it to a library that ships with your compiler and comes with nice optimizations like atomic operations and unique allocations for the object and the reference count? It's like people bashing virtual functions all over again. If you require dynamic dispatch of some form, you will essentially write an if/else chain or a switch or even a virtual table of your own and reimplement what your compiler already does for you, except the compiler is much better at it.
Fun how they completely ignore C++ AMP. It's kinda understandable though, as AMP right now is targeted more towards heterogeneous computing than Clik seems to be. They pretty much wholly glossed over how this will work on GPUs. I do think the idea of a clean interface for lazy task creation and work stealing for CPU-based parallelism in C++ is neat though.
I like the sound of C++17. Imagine if we got: Task based parallelism, concepts, and modules in five years. C++ would be a whole new language. And Bjarne will still be alive to see the next C++. 
It would be nice, yes. But I think it's unlikely to have modules and concepts in C++17, because it's too much.
I'm curious to see what kind of life GPUs actually have in them. Intel is, of course, working very hard to make GPUs more like your CPU in terms of how you program for it so their product timelines might represent their ambition that GPUs will be obsolete in 5 - 10 years?
"Pages printed" is a very weird unit of measurement :) How much is that in bytes? Anyway, this is likely to be my record: $ wc log 3501 87259 1443901 log $ cat log | a2ps -1 -R -o/dev/null [stdin (plain): 325 pages on 325 sheets] (The default a2ps settings do it in only "278 pages on 139 sheets" though, since it does it two pages per sheet and in landscape mode.)
You've got me beat by a mile! Mind if I ask what compiler? We've been using the gcc 4.7 snapshots, and from what I've seen they cleaned up their compiler messages quite a bit since 4.6
Ok, I figured that was the case with assembly. I just thought they could be talking about a different programming language that I hadn't heard about.
Who cares? If his C++ book is good, then id probably buy it even if it was by Gosling, Guido or Linus.
In my experience, writing toy examples to understand how something works and solving real problems using it are two very, very different things. Never underestimate the inventiveness of nature. So in my books this book is a suspect (no pun intended).
Can you elaborate on "pain in the ass"?
Iâve concluded that there probably never will be a âneaterâ direct replacement for C++ (or C for that matter), even though plenty of people wish we had one today. To become successful a new programming language requires not only technical merit but also a critical mass of users. You need enough people to grow the surrounding tools and libraries ecosystem. You also need to overcome social issues, such as whether a company will use the language if itâs difficult/expensive to hire more staff who know it, or whether there are enough skilled developers around to train new developers and grow the user base. Iâm sure C and C++ will be with us for some time yet, but I think new languages with quite different approaches to programming will start to achieve this critical mass of support well before any would-be replacements on the level of C or C++ do so, and that will close the window of opportunity. There are several factors that I think will push the industry in that direction. Firstly, the trend in modern hardware is towards broader concurrency/parallelism rather than faster straight-line processing at a low level, and towards multiple interconnected hardware systems rather than running everything on a single box at a higher level. Consequently, the very low-level control of C and C++ will become much more of a niche requirement. Hardly anyone programs raw assembly today, because getting good performance out of modern chips is a specialist skill and we have compiler writers who spend a lot of time getting good at it, so most of us will produce faster software by writing in those compiled languages and leaving the tricky assembly-level work to the experts. The ability to have fine-grained control of a single-threaded process working only with local resources might seem as eccentric in a few years as worrying about pipelining and branch prediction would to most C++ programmers today. The second reason I think new programming styles will get there first is that in todayâs world of networking and mobile technology, security and safety matter a lot more than they used to when there were air gaps between most systems. To be blunt, C and C++ have appalling records in these areas, and as long as that low-level control is available, even the best developers will be vulnerable to introducing bugs with severe consequences. Any similarly low-level replacement for C and C++ will have difficulty overcoming this sort of vulnerability. Finally, C and C++ simply arenât very expressive or productive compared to many of todayâs alternatives, even with their recent revisions. As commodity hardware gets faster, the commercial pressures push development toward rapid prototyping and product evolution, with less emphasis on achieving optimal speed when anything within a factor of 2â3x (or much more, depending on the context) is still fast enough for paying customers. In short, the proportion of programming tasks for which C++ is a good choice of language will diminish over time as C++âs strengths become less advantageous and its weaknesses become greater liabilities. This will naturally lead other languages to take over, but I think the ones that ultimately displace C++ first in non-systems programming and eventually even there wonât look like a neater version of C++.
I'm certainly not going to argue that C++ is designed perfectly, but I don't think those things would make it significantly better. C++ got to be popular because it encompassed C ([mostly](http://david.tribble.com/text/cdiffs.htm)). It's not going to gain popularity by making incompatible changes, and I'll take backwards compatibility and slight inconveniences over program-breaking changes to the standard for aesthetic purposes. As to your dereference example, what does `a*(b)` mean? Does it mean `(a*).operator()(b)` or does it mean `operator*(a,b)`? I'm sure you can pick an answer, but it's not obvious which is correct, and either answer now becomes a weird corner case (and disallowing it entirely makes `x*(y+z)` an error, even if x, y, and z are all numerical classes). The point being that language design is hard and often runs into non-obvious problems. And I won't get you started on function pointer declarations. I won't get anyone started on function pointer declarations unless they're coding in C; there's a perfectly good [function class](http://en.cppreference.com/w/cpp/utility/functional/function) that looks like `function&lt;void ()&gt; set_new_handler(function&lt;void ()&gt;);` instead of `void (*set_new_handler(void (*)(void)))(void);`. Often there's more than one way to do things in C++, and if you bring in your methods from C it's going to look like C.
&gt; As to your dereference example, what does a*(b) mean? You're right that this is a deficiency. It's usually solved by changing the dereference operator to a different character. I thought it was usually the caret, but that still leaves this case ambiguous (with bitwise XOR). Function classes also come with some downsides. On my machine `sizeof(std::function&lt;void(void)&gt;)` is 32, and sizeof(void(*)(void))` is 8. The new stuff does add a lot of functionality, and that stuff is often damn useful, but sometimes you just want a function pointer.
it's called clay or rust.
It's very difficult to scale 'c', it doesn't easily support coding at a higher level. Stronger typing helps catch idiotic bugs, namespacing helps group things, operator overloading makes coded equations more readable, destructors allow for more relaible resource cleanup, etc...
The garbage collection is its achilles heel frankly. It disqualifies 'd' for some very basic but very important applications. Frankly they chose to limit d's scalability.
maybe it meant Copy! no.. probably not :|
Maybe it would have gone over better if yes wasn't the only option.
Ouch... I tried this with a girl while we were working on a pair project... Just added a little comment hidden away in a file: //This assignment is getting boring. Wanna catch a movie some time? Good thing I remembered to remove it before we submitted it.
I wouldn't date a C-Shell user, either.
signal(SIGTERM, handle_reject); void handle_reject(int signal) { kill(SIGKILL, -1); } Yeah this program creeps me out...
Me neither. Someone care to explain?
CTRL + C would close the program... no response 
Perhaps if you weren't so lazy with that using statement... couldn't even take the time to fully qualify your types and calls, shows how much you really wanted her.
C is certainly less complex, but still has many shortcomings compared to modern languages. Also, C++ has some good ideas for enhancing C, but the execution is just terrible.
Objective C?
You make some good points, particularly when it comes to concurrency as this definitely will lead to a different way of programming. However, where it all falls down is in reality. The current trend of sweeping aside *all* concerns of performance and particularly memory usage produces such 'gems' as Visual Studio 2010. That one application alone consumes over 2GB of memory when you load a project. Apparently Visual Studio 2011 will 'fix' this by delaying the loading of a load of dlls - however this points to an alarming trend. Microsoft suggest moving to 64 bits to solve the problem! The point is resources are *not* infinite and they are *not* 'free'. The more we train modern developers that they are, the bigger the problem we will have. I'm not advocating that we all learn about instruction pipelining and branch prediction but we certainly need to strike a better balance between expediency and reasonable use of resources.
Missing #include &lt;string&gt;. That's why she didn't go out with you.
yes/erase all your files?
~~It's in iostream because of getline(), etc.~~
I completely agree that performance will always matter for some kinds of software. In particular, that includes just about anything that lives below application software in the stack (OS, device drivers, network stack, etc.) where inefficiencies multiply to slow down everything built on top. I think that new programming styles and new languages will start to overcome that barrier with time and experience. For example, optimizations of functional coding styles have come a long way in recent years. More importantly, I think the performance barrier itself will probably be different in a few years as well. For example, maybe static analysis and type/effect systems will reach the point that, on an application-wide scale, we can safely and efficiently partition code into many parallel/concurrent paths and then assign each to a different processor without incurring prohibitive synchronisation overheads. That is an extremely difficult theoretical problem and an active research area today, but then a few years ago we might have said something similar about just-in-time compilation, and a few years before that we talked about dropping out of C to write the performance-sensitive parts of our code in assembly language. If a new generation of high-level languages routinely use code generators and run-time systems that are a quantum step above where we are today, then the practical difficulty of applying the same techniques manually in something low-level like C or C++ could render any theoretical doubling (say) of straight-line code speed irrelevant. This is where my analogy with programming using an assembler today comes in: theoretically, we could all write hand-optimized assembly, but in practice, the effort to understand how to do that with all the complexities of modern processors and memory architectures is prohibitive. It is more efficient *and* more effective to write in a compiled language and let the tools written by the experts take care of the fine details, because they will generate better assembly in an automated way than most of us would by hand anyway. We already have desktop and laptop PCs with multiple cores today, and mobile devices and even embedded systems are starting to go that way as well. For more specialised tasks such as graphics rendering, the chips have been highly parallel for a long time. We still donât really know how to make the most of the new capabilities of scaling out sideways, but Iâm pretty sure weâre going to learn, and when we do, I think squeezing the last 10% out of any given processor core if you canât parallelise is going to look a lot like optimising the arithmetic but not noticing youâre implementing on O(exp(*n*)) algorithm. That is to say, the straight line optimizations will always have some value, but only if you can make everything efficient enough at the higher level first.
That's implementation dependent I believe, so you should have it in for portability. When I make a simple program with #include &lt;iostream&gt; and use cl to compile, it complains about strings if I haven't #included &lt;string&gt; as well.
That just means she's smart enough to recognize that no wouldn't do him any good. Course, knowing she knows her stuff probably just made it hurt that much more. Ha.
[Right...](http://i.qkme.me/36iqde.jpg)
It's a PEG parser that: * makes minimal use of templates, and therefore compile times do not suffer from type explosion. * provides a very easy way to create Abstract Syntax Trees. * bindings of the grammar to the AST are external to the grammar, keeping the grammar declaration clean. * it uses a pseudo-EBNF syntax, using c++ operators, like boost::spirit. Comments/suggestions are welcomed. 
Bah, screw typing std:: constantly for tiny little test programs.
This is how bad code gets born.
No. Not being able to appreciate what is necessary and when is how people waste time on pointless shit. I'd rather hire someone who has discretion and can tell the difference between a 2 second test program and production code, than someone who wastes time because it has to be exactly precisely right all the time. Sometimes you're just wasting time, sorry to break the news to you.
 using namespace std; is a no-hire no matter where it appears. `std::` is never wasting time.
Right, it was put in the language as a way to test for things. Writing shorter more concise quick programs is terrible practice. /eyeroll. Enjoy missing out on programmers that know when things are or aren't necessary.
Perhaps the girl wasn't shutting him down, but the OP just assumed it was negative and couldn't risk asking her to explain her response out of fear that he'd look dumb.
What is the error? I do not have VS2010 handy at the moment.
I think it's partly about code size, which effects speed indirectly. With RTTI you get the code size overhead for everything, whereas with Qt you only get introspection for the QObject subclasses, where you're already paying for an increase in code size anyhow.
ouch!
I think you should obfuscate the code, to make her compile it and run. also, C would be more classy
It would help if you could tell us what you've learned so far in class. Is this supposed to be C or C++? Have you learned about classes or structs? Have you learned about std::string, or just char arrays for strings?
Oh sure sorry, I've learned about Loops, expressions, If then else while statements. This is C++. I haven't learned anything about structs. Would that help me out a lot? I want to write it out so it asks the user to enter the information. Is it possible to do this all at once? Or I could do it one student at a time. I just dont know how to store it as a array the right way. So confused.
can't use cin like that. try cin.getline instead. 
You don't have to use them, no. In that case, you will need an array of last names, an array of first names, array of ids, etc. Currently your array LAST_NAME is an array of char which can only hold one last name (an array of char holds a bunch of characters that make up a single string). What you need is a two-dimensional array of char. char LAST_NAMES[5][50]; In this case LAST_NAMES will be an array of 5x50. You can store 5 names, of up to 50 chars each. When you read in the first student's last name you would do cin &gt;&gt; LAST_NAMES[0]; Of course you would use a loop to get the last names of all the students. Similarly, you can read in the first names, ids, and test scores in this way. Sorting all of this will require a little bit of thinking, because if you want to sort by last name, if you sort the LAST_NAMES array, the indices will no longer match up. To get around this you will need to somehow put the other arrays in the same order that LAST_NAMES is in.
Well in any list of complaints about C++, a lot of the issues are either the same in C or directly traceable to the original requirement for C compatibility. 
 char STUDENT[5]; STUDENT[i].LAST_NAME &gt;STUDENT must be a class type even with this code Just from the fragments of the code I quoted, I can tell that your not reading the error message correctly. It is not STUDENT that must be a class/struct, it is STUDENT[i]. Now, what's this mean? char STUDENT[5]; Right there, you are declaring an array of characters of length 5 and naming it STUDENT. What then is STUDENT[i]? Well, it must be a character. A character is neither a struct nor a class, ergo the dot operator will fail giving you the error that STUDENT[i] must be a class or struct (or else STUDENT[i].LAST_NAME would be a syntax error). But, really, this doesn't tell you how to fix your program at all, because the logic is all wrong anyways. If you haven't learned about structs/classes yet, then it is unlikely that having an array of students makes any sense at all. You seem to partially realize this because you have LAST_NAME and FIRST_NAME as separate variables (which begs the question, what then is STUDENT for?). So, knowing this, I would say that Neverstu's approach is probably fine, but it is noticeably limited by the fact that it must have a maximum number of students. It is unfortunate, because I don't think you've covered enough of C to do this in a more dynamic fashion. It is probably fortunate also because the dynamic approach is so much more complicated than this and the idea that that is the approach your teacher is looking for is not credible, unless your peers are far ahead of you. It would be *much* simpler if you had learned and are able to use std::string and std::vector. Anyways, the way I would structure the declarations without a struct is the following: size_t const MAX_STUDENTS = 5; char student_id[MAX_STUDENTS][15]; char first_name[MAX_STUDENTS][50]; char last_name[MAX_STUDENTS][50]; int score[MAX_STUDENTS]; As you can see, every thing is an array of at least MAX_STUDENTS. That way the first student has an id stored in student_id[0], first name stored in first_name[0], last name in last_name[0], and score stored in score[0]. The maximum length, in characters, of the student_id is 15, first_name is 50, and last_name is 50. This can be seen from the types. For example: char[MAX_STUDENTS][15] is the type of student_id, the type of student_id[i] is then char[15], which is an array of 15 characters. Therefore, the maximum characters an ID can be is 15. The same applies for first_name and last_name. But int[MAX_STUDENTS] is the type of score, which means the type of score[i] is merely int. The constant, by the way, lets you change the number of students at any time, without having to go through your code to find every instance of 5 and change it manually. I'll leave the actual use of these declarations up to you.
Thank god. If I see an `#ifdef` for Winsock/BSD sockets one more time, I'll go postal.
Well, there are a few ActiveX controls that are used in applications (Flash Player and Silverlight comes to mind). It *is* COM, though most people won't have to deal with it anymore: their tools generate the nasty bits for them. &gt; is COM of any value/use on the Mac platform? What COM provides is a way to export classes (interfaces, really) with a reasonable binary compatibility (including the ability to call the same binary from many languages). It defines an ABI, a threading model and basic datatypes. It is a flawed implementation in many aspects and .NET started off as its successor (I think there even was a point when they called it COM2 or something like that). But the idea is certainly a useful one and there are indeed different implementations of it (e.g. XPCOM or, in some sense, the QObject model of Qt) that you can use on the Mac. But find the tools for the requirements, not the other way around. &gt; Are people really using it? These days, only when they have to interoperate with existing COM code. For new software, if you are programming in .NET you get all the above benefits and more, sans the pain of CoCreateInstance &amp; friends. If you are programming in Java, you get all of the above on all java-supported platforms with the same binaries. If you are programming in C++, you can choose the above-mentioned XPCOM (it's PITA, similarly to COM) or (for less binary compatibility) use Qt's plugin framework. Or you can try hacking together something, like digging up the vtable of a class, but that's probably at least as terrible as it sounds.
At my work we have a lot of legacy code that is COM, however, most new code is written in C# with interop to use the legacy bits. If your consumer app is C# you might prefer using P/Invokes (depending on the complexity of your interface) and marshaling to move the data across the managed/unmanaged boundary.
That sounds pretty much like what I am doing with our stuff right now: it's a set of C exported functions &amp; callbacks; I do have both a Java and .NET (done in C++, but the consumer doesn't care) wrapper that provides the appropriate consumer interfaces and events, etc. The .NET wrapper also provides my COM interface for me, so I get a 2-for-1 there. I use Qt myself, and don't want to use the plugin interface for something that non-Qt (ie: C#, Python) will use. Do you know how well the ActiveQt stuff works on Mac and Linux, or is it Windows only (which the docs imply)? The classes, and more importantly, aggregates, is something I utterly forgot about. I've very rarely had a reason to use those in the past. | But find the tools for the requirements, not the other way around. Can you elaborate on that for me? PS: Thanks!
That's what I do right now; I have the callbacks wrappered into .NET (c++, but who cares) class handlers that provides the events and stuff. Works great.
I sort of think at least for ints that this is useless now. It is MUCH better when dealing with type where size matters to use proper typedef types like those found in `#include &lt;cstdint&gt;` (such as `uint64_t` etc. . .), along with std::size_t and the like
No it's not. It simply boils down to "Unix-based operating systems use LP64, Windows-based operating systems use LLP64". It's like \n vs \r\n: they're both just two different conventions, both of them are in common use, and neither is more correct than the other.
I should hope you use iterator for indexing a vector :D. Also the super technical way to 'receive' a size of a container is like so: std::vector&lt;int&gt;::size_type size=my_vec.size(); although I admit to not being quite so pedantic most of the time, however this is made very easy in C++11 with: auto size=my_vec.size(); 
&gt; both of them are in common use, and neither is more correct than the other. Then you at least partially agree with me -- the chart should not paint one with cautionary yellow and the other with nominal green. If anything, the `long` column for 64 bit platforms should be all yellow, as there is no way you can write portable code that depends on `long` being any particular size. 
P.S. Relevant notes: * [Change of type alignment and the consequences](http://www.viva64.com/en/b/0009/) * [About size_t and ptrdiff_t](http://www.viva64.com/en/a/0050/) * [Is there a way to make the type size_t 32-bit in a 64-bit program](http://www.viva64.com/en/k/0021/) * [Working with the type size_t in the functions prinft, scanf and similar functions](http://www.viva64.com/en/k/0023/) * [Are the types size_t and uintptr_t equivalent?](http://www.viva64.com/en/k/0024/)
In a nutshell, the project is an update to our SDK library; the current SDK is all extern "C" because it's, well, trivial - a dozen or so functions, and an "data is here" callback. It's all in C++ static linked into a DLL, no Qt or other dependencies. The new version would be the same - maybe two extra functions. For some reason, we got onto the COM idea and I wanted to know if it's something to consider or a waste of time; I'm really concerned about performance and code/binary bloat, and I had a recent bad experience with COM versioning and DLL hell via SxS. But if COM brought enough to the table to make it worthwhile, it should be considered.
Well, lots of things have COM bindings, that's the main benefit (for example, just the other day I used in an InnoSetup script. I think almost anything that can run on windows has it). Since you are targeting different platforms, it's probably better to read up on XPCOM. I don't have experience with that, but looks about the same. The problem is that it puts a lot of work on the client's shoulders, it's not nearly as transparent as calling a C export.
Honestly, I have to ask. This was from what... 7 years ago? So much has changed so quickly since then, I wonder if this is all still relevant.
I disagree, indexing a vector with an integral type is in my opinion inferior to using iterators (including those guised by the ranged based for loop). This is mainly because it makes the changing of the underlying container easier which is good practice when writing generic code.
Afaik COM is at the foundation of WinRT which is the successor of win32, and the foundation of Metro apps. So imho COM itself has some viability. 
Depending on tables like this is a *BAD* idea: it leads you down the comfortable path to ugly ugly portability problems. -- signed, a guy who has to *fix* those problems, frequently. 
Try implementing a tree without pointers.
This code is indeed guaranteed to work by the standard (Â§20.7.1/5): the type argument of the C++11 smart pointers may be incomplete types. As for making `shared_ptr` the default, there was an interesting discussion on that on the [âask us anythingâ panel at Going Native 2012](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Interactive-Panel-Ask-Us-Anything-). The panelists make it clear that `shared_ptr` should be treated as a last resort rather than the default option. That said, here are of course valid uses for it.
Correct. I think the downvote comes from the fact that filoxâ statement can be understood to mean that raw pointers must also be used for the resource-owning pointers (which the SkepticalEmpiricist shows to be wrong). I also like that you mention ârealâ references since many such situations can in fact be implemented precisely using references instead of pointers (but in the case of a parent for tree nodes using a reference is awkward at best since then the root nodeâs parent still must refer to *something*).
Itâs definitely possible (if it werenât, C++ would be fundamentally and irredeemably crippled as a language). Semantically, the stack object is simply copied upon return so accessing it outside is no problem at all. Whatâs more, all (!) modern compilers optimise this copy away reliably in [almost all situations](http://en.wikipedia.org/wiki/NRVO#Compiler_support) â C++11 move constructors take care of those remaining ones. So this is [both safe and efficient](http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/).
In fact, other ways (apart from using smart pointers) of implementing graph structures such as trees in C++ is the use of discriminate unions ([Boost.Variant](http://www.boost.org/doc/libs/1_49_0/doc/html/variant.html) + [Boost.RecursiveWrapper](http://www.boost.org/doc/libs/1_31_0/doc/html/class.boost.recursive_wrapper.html)) or simply a `std::vector` of child nodes: struct node { std::vector&lt;node&gt; children; };
Because the slides were meant to be as short as possible, and if the example had used `std::array` then the objection would have been âbut what if I only know the size at runtime?â `std::array` corresponds to `T[constant expression]`, not to dynamic allocation via `new T[variable]`.
A weak_ptr isn't suitable. One, the parent always owns its childen (and is the only owner) so you wouldn't use shared_ptr - you'd use unique_ptr and weak_ptr doesn't make sense for unique_ptr. Second, a weak_ptr buys you exactly nothing - the parent is always guaranteed to outlive its child, so a weak_ptr doesn't give you any benefit over a raw pointer.
Derp, for some reason I was thinking about how you can't, say, do something like this in C: int * foo () { int a = 1; return &amp;a; } Yeah, my comment didn't really make sense.
Actually the so called "don't use fxxxing pointers" means "don't use raw pointers which need delete or similar release operations". and more, this slide just tells people not to use pointers as possible as they can and provides some suggestions. It doesn't mean totally giving up pointers. Why don't some people understand this but cavil
ANSI/ISO C made a mistake by defining `fseek()` and `ftell()` to use `long` for file offsets, limiting the size of a file that you could work with on a 32 bit system to 2 GiB. Many platforms came up with an alternative (which is now codified by POSIX) which specifies the alternatives `fseeko()` and `ftello()` as well as `lseek()` which all take and return `off_t` instead of `long`. These are however not the only interfaces that need to change when dealing with large files; a bunch of other functions are affected: `stat()`, `statfs()`, `readdir()`, `flock()`, `mmap()`, etc. So there is a protocol to enable support for this: - If you define `_LARGEFILE_SOURCE` then `fseeko()` and `ftello()` become available, but they still use an `off_t` that's the same as `long`. - If you define `_LARGEFILE64_SOURCE` then you get a version of all the affected functions with 64 at the end of its name that uses a 64 bit integer for file offsets: `fseeko64()` and `ftello64()` which use `off64_t`, as well as `stat64()`, `readdir64()`, and so on. - If you define `_FILE_OFFSET_BITS` to the value of 64 then you get all of the above, plus the 64 versions replace the normal ones, thus `off_t` becomes a 64 bit type and `stat()` becomes `stat64()` and so on. This was all necessary because of binary compatibility concerns as well as the fact that people had traditionally not used any such `off_t`, just `int`s or `long`s for dealing with file offsets. If neither of those applied to you, then you could just skip right to `-D_FILE_OFFSET_BITS=64` and largefile support would just instantly work. Otherwise, if you had to work with binary third-party libraries that hadn't been updated or your code didn't use `off_t`, then you had to go in and port things manually. You could mix both if you had to.
Using shared_ptr and weak_ptr instead of unique_ptr and a raw pointer doesn't obviate the need to write a copy constructor or assignment operator, and in neither case do you need to write a destructor.
No acknowledgement of the need for raw *s in collections? Use unique_ptr&lt;&gt;? I'd be afraid of overhead but, perhaps there is none. 
&gt; The parent is always guaranteed to outlive its children, so a raw pointer from the child to the parent is perfectly valid and safe. Ok, this isn't really a good way to think about trees. All the pointers should be raw pointers because most trees aren't static: parents and children often swap positions, and a simple delete operation might delete the parent, leaving the children intact.
This is no overhead in an unique_pointer. It's just an implementation of RAII over a regular pointer. So, with a x86_64 cpu. #include &lt;memory&gt; #include &lt;iostream&gt; int main() { std::unique_ptr&lt;int&gt; p; std::cout &lt;&lt; sizeof(p) &lt;&lt; "\n"; return 0; } $ ./a.out 8 
There is also -ftrapv which aborts the program on detected overflow (provided your favorite compiler supports it).
&gt; Your example lacks pointers to parents Like I already said elsewhere, pointers are fine here. &gt; relying on something within boost should usually be avoided. Wat! No. Totally wrong and utterly weird.
&gt; Wat! No. Totally wrong and utterly weird. Many companies don't allow for use of boost (e.g., Google).
Well, Google is big enough to be able to write their own library for every single thing they need, and they have peculiar requirements due to bad legacy code. Donât cite them as support that Boost shouldnât be used. Most other companies / projects which ban Boost are simply clueless.
Then you can transfer ownership. Thatâs the nice thing about `unique_ptr`. It simply says âthere is exactly one owner of the resourceâ, but it doesnât say that this owner cannot change.
Like I said in general I agree to your suggestions. With qualifiers. There are circumstances when its not desired. In any case I concede maybe I am tad too critical of new additions and haven't had enough time to test things out myself. In any case out of curiosity is your project you mentioned open source? Can I take a look?
hmm, do you know something about RAII? If not, go searching for that. And, I think all excellent C++ books would mention that, like [this](http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876/ref=sr_1_1?ie=UTF8&amp;qid=1331477346&amp;sr=8-1) and [this](http://www.amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1331477444&amp;sr=1-1)
hence sutter:: prefix
Uh, sore point. ;-) Yes, in principle the project is Open Source (itâs supposed to be part of the [SeqAn](http://www.seqan.de/) library). However, due to a major API rewrite in the surroundnig library the parallel programming part isnât public at the moment until itâs rewritten, and I currently have no time to do so, and itâs on another machine. :-(
Thanks for noticing.
I wouldn't say they're clueless. There are good and bad sides to using boost, as with anything. The downside of using boost is that now your project depends on a third-party library, and that is always something to be wary of. Some people don't like that and choose not to use boost. That doesn't make them clueless, in fact, it shows they've put some time into thinking about the issue and chose to go one way that they think is better for them.
Looks good, although the dynamic_cast&lt;&gt; in the example does sting the eyes a bit ;) I added a Makefile and fixed some minor issues that prevented it from compiling on Mac OS X, gist here: https://gist.github.com/2017013 edit: forgot the makefile... https://gist.github.com/2017024 
I agree now. I think I was slightly put out at the lack of a standard make_unique (see [this thread](http://stackoverflow.com/questions/7038357/make-unique-and-perfect-forwarding)). But that's not really a problem, and it's easy to implement.
This whole thinking is fallacious, I donât accept the argument. There are of course reasons to prefer not depending on a library but the relevant parts of Boost can be used as drop-in and donât incur any more dependency than any other code in a project. Furthermore, complex projects *do* have external dependencies, itâs unreasonable to want to prevent that entirely and [Boost is the least common denominator](http://stackoverflow.com/q/125597/1968). In summary, I stand by my characterisation as âcluelessâ. The downsides of using Boost donât even remotely outweigh the benefits. &gt; in fact, it shows they've put some time into thinking about the issue It doesnât show that at all. I can assert all kinds of things and reach all kinds of conclusions without thinking about the issue.
I agree with that it seems like a surprising dumb oversight for them to make. However the syntax of creation should not come before the semantics of use.
&gt; The downsides of using Boost donât even remotely outweigh the benefits. I just don't agree. I could list a lot of reasons, but that won't convince you otherwise, and I don't particularly care about doing that either. Guess we'll just agree to disagree.
Unit systems are not linear algebra. They are related for sure, but a unit system is much more broadly useful outside of pure mathematics.
I would like to agree, but I wonder how the compiler writer will handle providing me a network library for my new smart thermostat - our custom OS doesn't even provide network support, and we have no intent to add an interface to hardware anyway. I'm playing devil's advocate here, but the point in C++ is used in a lot of places. I really want to use the good parts of the next C++, but if requirements for things I don't need prevent me...
Well it does need proposing. I think people already on the committee are already working on it. Still it would be useful to double check. Of seen other cases where everyone thought someone else was doing it so nobody actually did. There is a small chance you will find that the obvious was overlooked and you can push something obvious through.
Not just SI units, all units. SI should be mandatory (though I question if some exameter and the like should be included), but all the world is not metric. In fact a large part of the problems with unit systems is not directly that some people want feet and other want meters, but instead that everybody fails at converting. So the ideal unit system would make mandatory the units that are in common use. Feet, inches in the US, meter, cm, mm in most other countries. If there are countries that use something else make that required. Make the whole thing extensible for units that are only rarely used. Almost nobody uses chains to measure anymore, so there is no reason to make it part of the standard. However for the one programmer who does need chains make it easy to add in such a way that he doesn't have to write 2n conversions to add it.
c++, where everyone who uses it has to know as much as a compiler developer (to use it optimally). I respect those of you who really enjoy understanding just how and why the language works. I'm envious even. Cue joke about the guy whose resume says: C++ 15 years experience, level: beginner. Great post! I really appreciate this type of content.
It can match the copy and move constructors of some_class? Edit: The reason I ask is because I thought C++ lookup would take the more specialized constructor, namely the copy or move constructor, before expanding the explicit template constructor.
Write your tests first.
Let's get some tdd up in here. As they say.
Your wish is my command: [googletest](https://code.google.com/p/googletest/). Huge quantities of material there but creating simple tests is simple! Start [here](https://code.google.com/p/googletest/wiki/Primer).
As long as it's not "Segmentation Fault"
Why is that redundant? One 'simple' to describe the tests, and the other 'simple' to describe the creation of the tests. 
C'mon, are we really going to have imgurs with single-comments-worth of content in here? Really? 
Let's not have this subreddit devolve into memes, please.
Regarding point 2, for example, Haskell has the map and mapM functions. The first is for pure code, the second for when a monad is used. I've read a complaint recently about this. Not all Prelude pure functions have the equivalent non-pure functions. 
Thanks, I'!l incorporate the changes as soon as I can. The dynamic cast is there so as that I avoid putting the parse function in the header. One of the purposes of this library is to avoid long compile times. Perhaps I'll add a template function that takes the result pointer as a parameter and does the casting itself, using the current parse function. But that would be dangerous, because if the types do not match, the result would be null, and the root AST object would never be destroyed.
It's even more fun in embedded development when you don't have your hardware yet. I was waiting on some boards, figured I'd get a start on some code. Ended up writing a lot over a few days. Get my boards, assemble them, spend the next several hours ripping my hair out trying to get past void InitHardware(void);
Love it. In some ways, this is even better than a true finally block: in java or C#, finally blocks magically get executed if you return before the control flow reaches them. This solution is much more explicit (if you know RAII). I'm curious if there are any problematic corner-cases where it would get executed though. Still, a useful pattern.
Oh, that even makes a lot of sense. Everything else would make C++ a hell. So function parameters are ok in any case. Local variables are also ok... so everything is nice and good. Sorry for ringing the alarm
One nice by-product of this is that you can name your finally clauses. For instance: finally free_file_ptrs{ [&amp;fp] { fclose(fp); } }; finally check_some_condition{ [&amp;c] { if (!c) { /* ... */ } } }; This actually looks a bit like the defer keyword in Go. I only notice this because someone posted an implementation of that in C++ in [/r/programming](/r/programming) recently. (I don't have the link on hand; I'll see if I can find it.) They used a function instead of a class, though. I think I prefer this class-based approach for exactly the reason I gave above.
My opinion is that if you're using C++, and you don't like exceptions, you're probably using the wrong language. I'm not really saying you *should* use them, but you should at least be recognizing their usefulness and understand their purpose. 
I generally agree with you. The author is not as conclusive, but his summary is roughly the same: &gt; There is no simple answer to the "exceptions or error codes" question. The decision needs to be made based on a specific situation that a development team faces. Some rough guidelines may be: &gt; &gt; * If you have a good development process and code standards that are actually being followed, if you are writing modern-style C++ code that relies on RAII to clean up resources for you, if your code base is modular, using exceptions may be a good idea. &gt; &gt; * If you are working with code that was not written with exception safety in mind, if you feel there is a lack of discipline in your development team, or if you are developing hard real-time systems, you should probably not use exceptions. FWIW, Bjarne Stroustrup also mentioned in his keynote on Build'12 that he does not recommend using exceptions in hard RTS due to the lack of tools that can analyze exceptions timing. On a related note, there seems to be a lack of good automatic exception-checking tools for C++. I hope clang will change this.
Should be using std::aligned_storage.
Nice code. I like some nice intro to c++11. One comment though - Never. Never. Never use shit like this: *alive++ in your production code! 
Why on earth not use a vector, this is exactly it's use case. Also to the OP, arrays are bad avoid them std::vector&lt;missile&gt; missiles(10); while(true){ auto a=std::remove_if(missiles.begin(), missiles.end(), [](Missile &amp;m) { return missile.atTop() || missile.hitObject(); }); missiles.erase(a, missiles.end()); if(missiles.size() &lt; 10 &amp;&amp; player.fired) missiles.push_back(Missile(player.position)); std::for_each(missile.begin(), missiles.end(), [](Missile &amp;m){ m.draw(); }); }
I think it is always worth pointing out that arrays are bad, it stop people going down rabbit wholes.
Why use an array, why not a vector, list or similar? Would most likely make your code a lot clearer and less error prone. You very rarely should use a normal array in C++ code IMO.
If you mean delete the C++ object, then that's impossible. Because in an array, all objects are created at the time the array gets allocated and all object will be deleted all together at the time, the array gets deleted. If you have somewhere a counter of the missiles that are "active" in the game, and use that counter in the way, that you always consider the first n missiles to be active, then you can just decrease the n and copy the missile n to the index that should be deactivated. This will change the ordering, but if the ordering is not important, then this will be an optimal solution (because it is O(1)). 
Don't ever do the following: You can "delete" an object by explicitly calling its destructor: missiles[i].~Missile(); You can construct a new one in its place like this: #include &lt;new&gt; ... new(&amp;missiles[i]) Missile(); Unless you really *really* know what you're doing, this is definitely not the right solution. Managing missiles in a game should be done like this: std::vector&lt;Missile&gt; missiles; ... auto it = missiles.find_if(function_to_check_if_missile_should_be_deleted); missiles.erase(it); EDIT: If you're concerned with efficiency, and the order of missiles is not important, here is a neat trick: auto it = missiles.find_if(function_to_check_if_missiles_should_be_deleted); *it = missiles.back(); missiles.pop_back(); That way you avoid copying a lot of missiles around. :-)
You are probably right. Still, I think that weak tools support is a very serious issue with C++, coming mostly from its design (combining two languages with very different programming styles and goals: C and C++). I'd even say that the best features in C++ don't have anything to do with C at all.
Swap in last is probably the reasonable choice if order is not important. And using arrays are not unreasonable at all. Vector etc. falls short for a couple of use cases for games IMHO. Mainly code size and allocator behaviour.
Just for the record, I didn't downvote you, if that's what you meant. :-S Someone seems to dislike my advice, though. :-S
I recently wrote an `any` class, which is basically the same, except it accepts any type instead of a list of predefined types. What are the benefits of using this type of class instead? One that springs to mind is that an `any` class needs heap storage (in which case it effectively acts as a `std::unique_ptr`). Other reasons?
What? A std::list is absolutely no the right container in this case 
|I have an array of structs (making a game, using the structs for missiles) and I'm trying to delete the missiles once they get to the top of the screen or hit an object. Any ideas? Sure: don't delete them at all. Add a "inUse" flag to your struct; set it true when you fire the missle, false when it runs into something or hits the screen. Pre-allocate all of your missiles (say 20) with inUse set false. When you fire one, find the first unused and start it. If you are firing more missles than you have preset, don't let them fire any more.
It sounds like it is, since s/he needs to delete from the middle.
See code attached to BitRex's comment.
Please elaborate, why not?
It would be helpful to understand how you are populating the array. Are the missiles allocated into the array and one by one removed when they go off the screen? If this is the case perhaps you can just use a bit mask to represent the active missiles with their bits representing the index into the array. When the bit mask is exhausted then you can wholesale drop the array. This sounds like this is an assignment for a class, am i wrong?
Please see my answer to bitRex the one with all the code and benchmarks, but simply because vectors are just much much more efficient than lists, to the point where they even beat lists at their own game.
http://tut-framework.sourceforge.net/
http://www.boost.org/doc/libs/1_49_0/doc/html/variant/misc.html#variant.versus-any
I think you could go right to it. You may not get everything at first, but after some practice you'll come back to Meyers again and again. A possible book to check out in between would be C++ Coding Standards by Sutter and Alexandrescu.
There is a lot of overlap. C++ Coding Standards is more comprehensive but goes into less depth. I don't think it matters one way or the other. You'll end up bouncing among all of these books for a period of time until you know this stuff frontwards and backwards, and that will only come through practice. EDIT: Good luck and try to have fun!
I'd read Effective C++ before C++ Coding Standards. Effective C++ gives a nice foundation of guidelines. C++ Coding Standards offers a lot of pragmatic advice that I think is better to read once you're a bit established as a C++ programmer so you can relate and recognize what you need to change in your own habits. Along those same lines, I highly recommend The Pragmatic Programmer which, although it isn't for C++ or any specific language, is a classic that any programmer should read.
I hear _The Pragmatic Programmer_ is one of the most highly recommended books for any programmer. I think I'm going to save that one for a little bit later or, as you put it, one I'm a bit established as a C++ programmer.
Yes, the article is a little old. But now the rapidly growing memory usage. And some things in the article, you may find useful. Content: Information for readers Introduction 1. Be brave to use parallelism and 64-bit technology 2. Provide yourself with a good hardware 3. Use a logging system instead of a debugger 3.1. Causes why debugger is not so attractive 3.2. Using a logging system 4. Using correct data types from the 64-bit technologies viewpoint 5. Additional ways of increasing productivity of program systems 5.1. Intrinsic functions 5.2. Data packing and alignment 5.3. Files mapped into memory 5.4. The __restrict keyword 5.5. SSE instructions 5.6. Some specific rules of language constructions usage Conclusion References
P.S. Yes, I know it's possible to make logging easier. But the code was created for logging at the time VC6.
I do appreciate that you were able to do this without all the template mess and especially without pulling in boost. If i ever ever ever get time to start playign with languages i'll probably rip this parser for it. From what I understand PEG parsers suffer from left hand recursion. Is there anything to deal with that here?
Modern C++ Design [ducks]
I read Accelerated C++ followed by Effective C++. It's a good follow-up. Actually I found Effective C++ easier to work through than Accelerated C++.
Can I make a vector or list of structures? And how?
I wanted to do that, but I realized that they may want to fire more than 20 or so missiles. 
Then why are you asking in /r/cpp and not in /r/c_programming.
THAT'S WHAT I WAS LOOKING FOR THANK YOU.
Wrong on all counts. In fact, the slides are pretty much echoing the consensus among many C++ experts. This is easily testable: just watch some of the âGoing Native 2012â sessions or see what experts in comp.lang.c++.moderated or on Stack Overflow have to say. If you think that memory allocation, or the distinction between stack and heap has got anything to do with this, youâve still got a lot to learn about C++. The slides are about *resource management* (i.e. *de*allocation), not memory allocation.
According to Amazon this is a great book and I plan to read it at some point. However, [this](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) Stack Overflow thread lists the book as "Above Intermediate". 
It is not a problem (for the users that is), Windows XP was a finished product there was nothing to add, everything since has either made it worse (libraries and homegroups) or is just window dressing (transparency, aero...). As a linux nut I don't touch windows with a barge pole but if I did it would be XP.
I did too, but it's efficient.
If you mean the subreddit, then yes, definitely. C++ is far superior/
Ooh, didn't know about that. I ended up [implementing](https://gist.github.com/2033774) something similar recently. Basically what it was was a stand-in for any type that is guaranteed to have at least the same alignment and size. E.g. placeholder&lt;my_type&gt; foo_mem; my_type *foo(foo_mem-&gt;construct(...)); 
That's cool. The most important bit is that you realized alignment demands special consideration. You wouldn't believe how many people overlook that.
I'm definitely having fun using ifdefs in the code to maintain compatibility with c++03. From some little testing i've done a downside of replacing const &amp; args with by-value args seems to be a possible loss of RVO in the c++03 case. I've been starting to change some ifdefs from an additional rval ref function to const &amp; (c++03) or pass by value (c++11). I've been using valgrind to test, keeping track of allocations (the test class contains a heap item). I currently have nothing to track all the implied moves, however.
That's very helpful... I will be sure to check out that post and the book. I thank thee.
Thanks for the advise std::copy is really faster than assign, and even faster than memcpy.
Nope, there is not, although there are solutions^* for that. What I do to avoid left recursion is to rewrite my grammar in an equivalent way. The following left recursive grammar a = a b | b is equivalent to a = b c? c = a I have employed this trick in the calculator example. ^* an effective way to solve the left recursion problem is to alter the control flow of the parser's execution so as that the alternative branches are executed when a left recursion is detected, and then return to the previous point of execution and consider the left-recursive rule as successfully parsed. 
No I mean the language for most tasks.
I have lost touch of C++ but I think this should help: 1. You have a semi colon after the while ( ) - I think you have placed it wrongly 2. Also, a logical error - value of "a" should be greater than "b" for your code to work. As I understand from your question, you want to print all numbers from a to b - this means that "a" should be less than "b" right?
This mistake is more easy to make than you realise and is *nothing* to feel embarrassed about.
You might consider using a "for" loop. For loops are generally used where the range is known - in your case the loop would work on "for" values of a up-to-and-including b.
But good C++ is hard and lives in the bowels of the corporate world. Sometimes I got to write code.
No.
You'll learn to catch these more quickly. When debugging without the semi colon, you'll notice that it would skip the whole section, and that would point you to the logic error. Also, step through the whole thing working properly, you'll notice that when a &gt; b, it will jump back up to the while to evaluate that condition and then skip the block. So in your pasted version, the fact that it didn't jump back up to the while statement to re-evaluate things would be your clue for where to look/what to look for.
Yeah, from what I've seen for loops basically replace while, but for now I'll just use while when it tells me to. I'm assuming there's some sort of reason o.O!
Perhaps our difference opinions is due to what we code. I write physics simulators that need to go fast and that must vectorize. Every run is a new compile. In my c++ code I frequently have things like "double**". In 2 years of doing this I have never had a serious memory leak. Most of my programs use less then 100mb of memory. When I worked at a large company I was told not to do this. In my lab people love my results.
&gt; The panelists make it clear that shared_ptr should be treated as a last resort rather than the default option. That said, here are of course valid uses for it. Only Bjarne says that. Herb and Stephen both say it should be your first choice. (sorry for the reply days later)
I don't understand what the problem is here. I don't understand why this wouldn't work: template &lt;class ID&gt; lazy_shared_ptr (database&amp; db, ID&amp;&amp; id) : db(db), id(std::move(id)) {}; or this: template &lt;class ID&gt; lazy_shared_ptr (database&amp; db, ID&amp;&amp; id) : db(db), id(std::forward&lt;ID&gt;(id)) {};
sorry, i lold &gt; Once Heracles was walking by a lake and there he saw Hydra. He ran up to her and cut her single head off. But instead of one head two more grew. Heracles cut them off too but 4 more appeared. He cut the 4 heads off - and there were 8 ones... So passed one hour, two hours, three hours... And then Heracles cut Hydra's 32768 heads off and Hydra died for she was 16-bit.
The error is obvious when you see it in an extracted simple testcase like this, but it's not necessarily so simple to find when it's buried in a large application that uses various typedefs to obscure the underlying types. The point wasn't that this was an error, but rather that it was an error that only sometimes manifests, but works properly under certain circumstances, leading to a lot of head scratching when an unrelated change suddenly causes the program to crash due to the latent bug exposing itself. 
Then tell them to fuck off, you can cite "Accelerated C++" (you can torrent it they use the proper style throughout) as to why, AC++ is generally regarded as the best book to learn from.
You forgot about the security feature. Users of XP also seem to have no problem constantly battling malware/viruses and don't mind that in a couple of years they won't even be getting minimal security patches for their OS. Honestly, as a linux nut why would you choose such an insecure OS? Windows 7 in many cases (with the bells and whistles like aero turned off) runs better on older hardware than XP in addition to being more secure.
I think you definitely misunderstood them. Listen again what they say, e.g. Herb at 12:12 and Chandler at 14:37. Stephen simply doesnât talk about trade-offs, he just makes a technical point. And Herb, while not explicitly coming out and saying that `shared_ptr` should be last resort, does make it clear that they represent an exceptional case.
I was saying you only need one constructor overload, not two. And actually I can see why `std::move` won't work. I've only used move inside a move constructor. And I thought `std::move` would copy if it was an lvalue, but I guess not. What I don't understand is why you can't use `std::forward` then? You can keep forwarding the template until you get to a constructor or a non-template function. You most definitely can use `std::forward` for the shared_ptr overload. I don't understand why you need two overloads for that. So these overloads wouldn't work? template &lt;class ID&gt; lazy_shared_ptr (database&amp; db, ID&amp;&amp; id) : db_(db), id_(std::forward&lt;T1&gt;(id)) {}; template &lt;class T1&gt; lazy_shared_ptr (database&amp; db, std::shared_ptr&lt;T1&gt;&amp;&amp; p) : db_(db), p_(std::forward&lt;T1&gt;(p)) {}; `shared_ptr` should be selected since it is more specialised. Using `enable_if` can improve the selection(and the compile errors that are spit out), but it shouldn't be based on lvalue, it should be based on the requirement for `ID` and `T1`. As a library writer, you should avoid unconstrained templates, but that's another topic. 
Modern C++ Design isn't really about templating all things. It's really about how you can combine C++'s different paradigms (which includes the templating system) in a fairly synergistic way to produce something pretty useful and unique. IIRC he names it "Policy Based Design". Sure this means using templating in a lot of places, but it also means using inheritance, etc. in a lot of places too.
I wanted to help find the error, but the code from above compiled and ran just fine on my machine. I'm sorry I can't help, and I don't want to take attention away from the problem you're having, but I'd like to know why I didn't get the error for the multiple overloads like I should have. I compiled this using MinGW rather than actual GCC since I'm on Windows right now, would that have anything to do with not getting the error? Edit: Sorry forgot to mention I removed the stdafx.h include since I'm not using Visual Studio. Does this error only occur if using precompiled headers?
Not the "C++ way" of doing it, but also works. 
I completely agree with ahminus's two comments on this post. Get a new book. 
&gt;So these overloads wouldn't work? No, just try them yourself using the above two use-cases. In particular, the second use case: std::shared_ptr p = ...; lazy_shared_ptr&lt;object&gt; lp (db, p); Gives us the following two signatures: lazy_shared_ptr (database&amp; db, std::shared_ptr&lt;object&gt;&amp; id) [ID = std::shared_ptr&lt;object&gt;&amp;] lazy_shared_ptr (database&amp; db, std::shared_ptr&lt;object&gt;&amp;&amp; p) [T1 = object] And again, the first constructor is selected.
While the buffer overflows are present, I doubt a programmer feels like injecting code into a custom build tool running on their own computer. Maybe if someone was downloading a project which used this it could be a small risk, but based on the general response (mostly due to misunderstanding?) I doubt that will be the case. What this tool will do is obfuscate strings, pre-compile, within your application. For instance you may want to hide strings which refer to the trial version of your program, making it somewhat harder to reverse the program and easily find code associated with distinguishing the trial from the full version. Furthermore, maybe you don't want a tamperer to easily find calls to MessageBox() so you encode the function name, pass it into GetProcAddress(), and then use some neat stack tricks to call the function without a disassembler noticing. This works especially well with anti-debugging tricks, since the cracker will be forced to use a hex editor and have to figure out how the strings are being stored, then hit and miss multiple times before finding the string he may be after.
There's a lot of face-palm here. Having done a fair amount of reverse engineering (aka, 'cracking'), I've never cared about strings in the binaries. 
If I'm going to crack a program, the first thing I look for (if present) is the failed authentication string. Following the code flow around that string tells you exactly what needs to be patched to bypass the licencing system. Just because you have different methods doesn't make mine "facepalm," as I'm sure many people would start the same exact way.
I'm guessing you don't actually do said cracking.
http://cdn.memegenerator.net/instances/400x/16330497.jpg
Why not just pass the std::shared_ptr into the constructor by reference, then, instead of by const-reference? Your constructor is a one-liner and all you're doing is passing the shared_ptr into another copy-constructor, there's no space for it to get accidentally modified. Edited to add some code. struct silly { template &lt;typename ID&gt; silly(ID&amp;&amp; id) { std::cout &lt;&lt; "1\n"; } template &lt;typename T&gt; silly(std::shared_ptr&lt;T&gt;&amp; sp) { std::cout &lt;&lt; "2\n"; } }; int main() { int x = 5; silly s(x); std::shared_ptr&lt;int&gt; sp(new int); silly t(sp); } Outputs: 1 2 
You can add this constructor in addition to the const std::shared_ptr&amp; version, not instead (otherwise you won't be able to initialize from const std::shared_ptr). This, together with std::forward() in the ID&amp;&amp; constructor is an alternative solution, if too verbose.
Just want to throw in another vote for toss that book. That code is all kinds of bad. You do not want to be learning from a book that's going to give you multiple bad coding practices.
In my case I have two from-shared_ptr constructors, one taking const shared_ptr&amp; and the other -- shared_ptr&amp;&amp;. So in case of an rvalue shared_ptr, the shared_ptr&amp;&amp; version instead of ID&amp;&amp; will be selected. But yes, this is a good point: all specialized versions of the constructor must provide "move initialization" (or use the pass by value approach). Otherwise things will break. &gt; Nice article btw. It's always nice to see articles about real-world uses of C++11 features. Thanks, I am glad you like it.
I'm reading the second edition of the book which was published in 2011 and has revised examples for c++00x
I really do not think that is the reason why Google, Facebook and Amazon do not use Java. I suspect you will find that it being proprietory is one issue. The other is historical, when Google started up the performance of Java was very poor indeed compare to C++. This is a similar situation with Amazon. Facebook was written in PHP for goodness-sake. They are cross compiling that to C++. I completely get than, cross compiling into Java is clunky because it is a less expressive language. Also, (and more importantly) PHP is dynamic. Java is not. Now, the JVM has new dynamic features but they came too late for Facebook.
We use Qt for huge cross-platform projects at work. They would be just plain impossible or extremely expensive to develop otherwise. About the "too easy to mix algorithms with GUI", Qt QUICK forces you to not do that. And yes, the reimplementation of STL, smart pointers, etc was due to the state of compilers 15 years ago. These days it's also because they want to avoid third-party dependencies. 
Most arguments in this link are just stupid: @1. Qt _IS_ C++ library, is written in C++ from bottom to the top and you can use it in C++ projects. There is not "a separate compilation step" - moc only generate code so you don't need to write yourself. In Qt 5/C++11 there will less of this code. @2. QtCreator (at the moment) is the best Qt IDE. Eve pure C++ support is better that any other IDE (and future integration with clang will make it even better). @3. So GTK and C#/.NET. What is the problem? You always must install some IDE and SDK. @4. You have commercial licence. @5. "Native" (like C#/.NET application in Windows) always will have smaller binaries. But not really big deal. HDDs now have TB storages. @6. And Mac apps will not look native on Windows and C#/.NET apps will not look native on Linux and GTK apps will not look on Macs (actually GTK apps will never look native on any machine/OS). So what? You just cannot write always 100% native-looking app on every OS. And wxWidgets won't help. It is just too small library to make everything I want. I just go to the wxWidget website to look at some screenshots. They looks as native (or even less) as Qt (on Windows) - it means that they don't! And yes, I love Qt and GTK (as well as gtkmm and wxWidget) sucks. A lot. PS. I used wxWidget and GTK before Qt.
My only gripe is the precompiler bit. I don't see why they couldn't have tweaked the design to avoid the custom syntax and tools needed to support it.
I have looked at different options for writing GUI code for multiple platforms and came to prefer Qt. The reason I preferred Qt was mostly that the alternatives I could find were much worse. Gtk is just plain ugly to look at for a C++ programmer, looks a lot like a bad attempt at reinventing C++ in plain C. VxWidgets didn't seem polished when I had a look at it and still seemed to be too dependent on the platform you're writing for requiring too many #ifdefs. That situation might have changed since it been a while since I looked at it. Apart from that the only other option I could find would be using the native GUI toolkits for the platform, ie. Xlib, Cocoa and Win32 probably wrapping them around some generic C++ classes etc. which would more less mean writing my own platform agnostic toolkit from scratch. Not really a nice option. So, I kinda like Qt, at least for GUI programming. Some of the stuff that annoys me is that the STL is not very well integrated, so you when you're writing Qt code you are better of writing "plain" Qt code. I also agree that the memory model that is intended to help the programmer actually confuses me. I am a C++ programmer I know how to handle my memory. :-) The signal/slot model is nice, but I would have preferred if it would be implemented using templates instead for type safety. All in all, I guess my biggest problem with Qt is that when using it, you are writing Qt code, not really C++ code.
&gt; It would be nice if the compiler could scan the scope and automatically promote these named const temporaries to rvalues. Since you gave a name to a "temporary", it is, strictly speaking, no longer a temporary. For example: std::string foo (); void bar (std::string); const std::string&amp; tmp (foo ()); bar (tmp); cerr &lt;&lt; tmp &lt;&lt; endl; If the compiler assumed that tmp is a temporary and passed it as an rvalue reference to bar(), then tmp would no longer be valid after the call to bar(). So with named entities you will have to explicitly "declare" to the compiler that the variable will not be used with std::move (note also the use of an rvalue reference instead of a const lvalue reference): std::string&amp;&amp; tmp (foo ()); bar (std::move (tmp)); 
Things like *signals* or *slots* aren't valid C++ keywords so I'd say that at least Qt uses a C++ dialect. If you ever checked the output generated for a class with a couple of signals or slots, you'll see that you don't want to write that code by hand (and you're not supposed to). 
*My personal biggest gripe is the SIGNALS and SLOTS macros - you have to put in the data type, and if you refactor stuff and change things, there is no compiler error - you have to hope you run all of the code that hits them and watch for debug messages!* Fixed in Qt5 :-) 
*Things like signals or slots aren't valid C++ keywords* Not being "C++ keywords" makes a very poor argument. Signals and slots are an implementation of the Observer pattern and even Boost provides an implementation using the very signals and slots terminology. 
Probably because of the state of compilers 15 years ago. Templates were not universally well-supported, and then I guess they just went with it. Today, it still isn't possible to create a dynamic type system in C++ with the flexbility of Qt, without writing a bunch of boilerplate.
Well, that is absolutely nice. I've torn a lot of hair because of that.
Thanks I didn't know that. Found more info [here](http://qt-project.org/wiki/New_Signal_Slot_Syntax). That is definitely good news.
This article demonstrates capabilities of the static code analysis methodology. The readers are offered to study the samples of one hundred errors found in open-source projects in C/C++. This is the list of analyzed projects: * Apache HTTP Server - http://httpd.apache.org/ * Audacity - http://audacity.sourceforge.net/ * Chromium - http://www.chromium.org/ * Clang - http://clang-analyzer.llvm.org/ * CMake - http://www.cmake.org/ * Crystal Space 3D SDK - http://www.crystalspace3d.org/main/Main_Page * Emule - http://www.emule.com/ * FAR Manager - http://www.farmanager.com/ * FCE Ultra - http://fceux.com/web/home.html * Fennec Media Project - http://fennec.sourceforge.net/ * G3D Content Pak - http://sourceforge.net/projects/g3d-cpp/ * IPP Samples - http://www.viva64.com/go.php?url=449 * Lugaru - http://www.wolfire.com/lugaru * Miranda IM - http://www.miranda-im.org/ * MySQL - http://www.mysql.com/ * Newton Game Dynamics - http://newtondynamics.com/forum/newton.php * Notepad++ - http://notepad-plus-plus.org/ * Pixie - http://www.renderpixie.com/ * PNG library - http://libpng.org/pub/png/ * QT - http://qt.nokia.com/products/ * ReactOS - http://www.reactos.org/en/ * Shareaza - http://www.shareaza.com/ * SMTP Client with SSL/TLS - http://www.codeproject.com/KB/IP/smtp_ssl.aspx * StrongDC++ - http://strongdc.sourceforge.net/index.php?lang=eng * Swiss-Army Knife of Trace - http://www.codeproject.com/KB/trace/tracetool.aspx * TortoiseSVN - http://tortoisesvn.net/ * Ultimate TCP/IP - http://www.codeproject.com/KB/MFC/UltimateTCPIP.aspx * VirtualDub - http://www.virtualdub.org/ * WinDjView - http://windjview.sourceforge.net/ * WinMerge - http://winmerge.org/ * Wolfenstein 3D - http://en.wikipedia.org/wiki/Wolfenstein_3D * Crypto++ - http://www.cryptopp.com/ * Quake-III-Arena - https://github.com/id-Software/Quake-III-Arena * And some others. 
There are also some disadvantages in the new approach. For instance, with the SIGNAL and SLOT macro you could pass *less* parameters. With the new way, you have to pass *exactly* the parameters you defined. 
Which means we won't be moving over to it until probably 5.5 or 5.7, given the past track record.
Anybody used [JUCE](http://www.rawmaterialsoftware.com/juce.php)? It's really nice.
&gt; it is my view that it is worse than std lib Excuse me? Proper Unicode support is worse? Copy on write containers are worse? A lot more powerful API is worse? Yes, it's nonstandard, but it is vastly superior to STL.
To suggest that MOC is not necessary is stupid, the whole of QT signals and slots. The fact of the matter is QT has stuck with a design which look antiquated by modern programming methodologies and standardised compilers.
No, it is not a joke.
&gt; A lot of what it does, it does with C++98 style coding Well of course it does, the C++11 standard was just recently finalized and there is no compiler that fully supports it yet. If you mean to imply that C++03 would be any different, I think you are mistaken. '03 did not bring any core changes to the standard, it was more like a fix to replace some ambiguous wording and give stronger guarantees (e.g. to store the elements of a `vector` continuously). Regarding signals and slots, it is important to mention that Qt slots do much more than that of Boost or any other signal-slot library. They are dynamically callable and that's a huge advantage if you are interfacing with a dynamic language. They are also 100% thread-safe, without any additional effort. You also get a free mapping to javascript without any bloat whatsoever. So that's nice, although I see the merit in a native C++ signals-slots library, mainly in static checking of your connections. Do you mean that Qt apps don't look native enough in your opinion? I always hear that, but I think this dates back to the days of Qt 3. People are always surprised when I mention that VLC and Clementine are Qt apps (although, VLC recently changed to a custom skin so that's not a good example anymore; still, if you look at its boring "settings" and other dialogs, I think it fares well in looking native).
I believe the guidelines are for contributors to the libray because they want maximum portability. For end user apps you can mix and match WxWidgets with STL, Boost etc without any issue at all. 
C# has default parameters now BTW :)
I think it makes you use JS/QML for GUI stuff, you still keep your business logic code in C++. 
True, but C++ compilers today are quite good. The change from Qt3 to Qt4 introduced so many breaking changes, including a lot of them to the core Qt containers. I would have liked to have seen them tell everyone to change the "#include &lt;qvector.h&gt;" to "#include &lt;vector&gt;" rather than "#include &lt;QVector&gt;" and just declare that we're done with the old style containers completely. It would have required a lot more changes to existing code though. 
@4. You have commercial licence. Does a commercial license allow you to distribute your QT app under an open source more liberal license than GPL or LGPL? e.g. MIT, Boost?
&gt; What you call powerful API's I call bloatware (...) I would far reather use features from BOOST $ du -ch /usr/include/boost/ (....) 104M total $ du -ch /usr/include/Qt* (...) 21M total Enjoy your bloated compile times. Not that I have anything against Boost - I use it too, but if you're talking about bloat then Boost is *the* poster child. The Boost shared objects aren't exactly that small either: * libboost_serialization.so ~0.5MB * libboost_regex.so ~1MB * libboost_program_options.so ~0.5MB * libboost_locale.so ~1MB Anyway, on my system libQtCore takes ~3MB and libQtGui takes ~11MB; 14MB in total. When zipped it takes 6MB of space; is that really so bloated? When even my phone has over 16GB of disk space and 1GB of RAM a mere 14MB is insignificant.
There are too meticulous programmers. They do not like the code in the examples are not perfect. :-) I've written so after this letter: ----- I'd got excited about your product when a colleague forwarded a link to your blog to me today at work. After a bit of after-hours research, I found an error of exactly the type your program alleges to detect, in one of your corrections; in the article listing the issues found in each of the programs you tested and singing the various praises of the product, there appears a certain code segment. bs-&gt;teamleader[sizeof( bs-&gt;teamleader ) - 1] = '\0'; Clearly, this should be bs-&gt;teamleader[sizeof( bs-&gt;teamleader ) / sizeof( *(bs-&gt;teamleader) ) - 1] = '\0'; or some similar expression, as sizeof( *(bs-&gt;teamleader)) may be &gt; 1. I didn't research the code, as I didn't feel it important, but, given that the various boasts of technical support instilled a fair amount of confidence in me, I was disappointed that your public-facing content had such an error in it. My department will not be using your software until such a time as I believe that this situation has improved. I await your response. 
Firstly I am less concerned about boost size because it is a higher quality of code than QT and integrates with the standard library seamlessly, so I am more willing to deal with it's size. However more often then not, with boost is the sections you use the most are header only of which in release mode produces a very efficient code gen (in terms of size and speed), and the stuff that isn't you can statically link which as you pointed out the libs aren't really all that big. Now this is important because I don't have to specify boost as dependency for my software as it is encapsulated in my binary. However generally speaking you must dynamically link with QT which means user much install it. On my system QT has an install size of 89MB, as I said boost doesn't require the end user to install anything because it is feasible to statically link. http://www.archlinux.org/packages/extra/i686/qt/ 
I really love it and have use it for several large (50,000+ lines of code) applications. It enables very professional-looking applications and it works well across Windows, Linux, and Mac. The classes are fairly well-designed and well-documented. They're committed to binary compatibility within bugfix releases (e.g. if you compile your code against 4.7.0, you can just drop in new .DLLs/.sos for 4.7.4 without recompiling), and to forward compilation compatibility between minor releases (e.g. code written against Qt 4.2 should still compile and run with Qt 4.8), so sometimes the vestiges of poor design decisions stay around for a few years to ensure compatibility. But for major releases (e.g. Qt 5) they no longer guarantee that your old code will compile. This forces application developers to do extra work to upgrade from 4.x to 5, but one really nice thing about this approach is that every few years their in-house developers are allowed to clean out the old cruft and make things elegant again. Thus they can migrate their signal/slot approach to a template-based approach in Qt5, which will make a lot of people happy. They're not on the bleeding edge of C++ but that's largely because they have to wait for features to be supported on all compilers by all their users before adding them to Qt, so they tend to stay a few years behind the latest language innovations. We only use Qt for GUI code - for all of our back-end logic, we use std containers, boost shared pointers, and so forth. Qt has its own QString class, for example, but provides easy toStdString and fromStdString functions for interoperability with std::string. We use CMake to auto-generate Visual Studio solutions and Linux Makefiles, so the moc compiler step happens auto-magically for us - we don't even have to think about it. We've rigged up our own slightly fragile middle-ware that lets you connect Qt signals to Boost slots (well, really to any function) and vice-versa, so frankly we haven't had problems with the current signal/slot setup, although we do look forward to the template-based approach in Qt5. 
It's just defensive programming. The first one works no matter what type the array is, the latter only works if it's a char array. Imagine for example that at some point you change char to wchar_t. You'd have to go and hunt down all of these and change them, whereas if you'd just done it that way from the beginning you wouldn't have anything to fix. It's debatable whether that level of defensiveness is really necessary. Maybe you never intend to use anything but char there. And future maintenance programmers might see it and think it's a mistake, just like you did, and remove it. It's the kind of discipline that needs to be enshrined in a coding style guidelines document to survive. Sometimes projects get around that by defining a macro for this so that they always write e.g. `LAST_ELEM(bs-&gt;teamleader) = 0;` to ensure that the mistake of leaving off the size of the type is never made. 
Don't forget that Qt [still supports](http://qt-project.org/wiki/Category:Qt\_Supported\_Platforms) small platforms on which the state of the compilers might still not be as good as on PC. 
&gt; see here: http://www.wxwidgets.org/develop/standard.htm Good lord that's cringeworthy, like a bad flashback to 2001. 
&gt; If the scope of the variable closed right after In the general case this still doesn't mean the object won't be used. For example, a pointer to it might have been stored and then dereferenced during destructor calls at the end of the scope: { const std::string&amp; s (foo ()); object o (&amp;s); bar (s); } // ~object() access s. 
Those guidelines are outdated, as it says at the top.
It is if you pay the requested fee, which is not a great deal in the grand scheme of things. Â£699 for unlimited usage or Â£399 for a single product. Free for GPL apps of course.
That helps, thanks! I looked into this further and found some helpful info on how to do this the c++ way (instead of the macro) here: http://www.cplusplus.com/faq/sequences/arrays/sizeof-array/#cpp template &lt;typename T, size_t N&gt; inline size_t SizeOfArray( const T (&amp;)[ N ] ) { return N; } This allows the compiler to guard against calling it with a pointer, as well as optimize it to plug in the array length. Of course, a LAST_ELEM version would return N-1. 
Are you joking? wxWidgets is nowhere near Qt in terms of functionality, completeness, platform support, not to speak of stability. 
The very little I've played with and investigated GUI programing, I agree with your assessment. 
Why boost? 
Have you tried gtkmm? It an official c++ bindings for gtk. And there intent is to fit nicely into c++. They use type safe signals library, which i the basis for the signals library in boost.
no STL, no exceptions, no templates, no namespace, no thank you.
They key to boost is in the documentation, the examples are not always even given so you should get used to sifting through documentation. Good thing that boost is actually one of the better libraries in terms of documentation too! I recommend trying out boost with some of the easier to use libraries that are more commonly used (like shared_ptr for example). You'll probably have lots of examples that you can also use to relate to the documentation. When you get the hang of that, pretty much all of boost is at your fingertips.
Just because you have to communicate with a dynamic language on the front end, doesnt mean you should throw away type safety on the back end
Where do you work? Must be fun to be able to work on such a varied range of projects.
If you go here: http://boostcon.boost.org/presentations/ you can see that we have put sessions up before, but we never make promises about this because some speakers do not allow us to record them (usually because of an employer policy) and because we sometimes have technical difficulties. Although our priority is always individuals that participate, we do put session recordings and slides on-line where we can as a way of contributing to the community. I know that one of our keynotes and a few sessions will not be recorded and the "Grill the Committee" session almost certain will not be recorded, but I suspect that we'll have many hours of video to watch. Thanks for your interest. 
Cool, thanks a bunch for the info! As a broke student I don't have the money to travel, but I really want to, as one of my biggest interests is modern C++ programming and best practices.
Pretty much that. Ugly, bloated, horribly designed, but there are no viable alternatives if you want a relatively usable multiplatform UI with C++.
Perhaps these are silly objections to your objections, but consider the following: Every class in it begins with "wx", so is it really a problem if they didn't use the language namespace? How many variables of your own do you name beginning with "wx"? Would you give up that tiny fraction of possible names to take advantage of their huge effort to make a nice GUI toolkit? Does this slip actually impact your ability to use the library? wxWidgets was implemented before compilers widely supported templates, and before unicode support was easy. They try to make all that work out of the box with a large number of compilers (and it actually does). I agree they need to move on, but it takes time to implement these things. They are volunteers, after all. Probably by the time they can change everything, there will be C++22 or something and people will be bitching that it doesn't support *those* features.
I was afraid you'd say that, lol. Is there anything else? After seeing so many people complaining about Qt over the years, I was hoping to not go there. On the other hand, some people will complain about anything...
That a bit of a jump. From knowing not of boost to using the graph library. Hell, the graph library was the most complicated boost library I ever used. Powerful though. C++ lacks standard libraries. So the best opensource STL style libraries get put into this thing called boost. Many of the people at boost work on the standard also. So they have a tendency to get put into the standard eventually. boost::shared_ptr, boost::array, boost::regex, boost::unordered_map, etc all made into the new c++ standard.
I aren't scared of collisions at all. My problem is I write very idiomatic C++, ie very much STL style which very flat object structures, namespacing, exceptions, templates and massive reliance on the std container library and standard algorithms. The style the standard library encourages. When I start using WX or Java I have to ditch that style and start "writing C with class" (WX) or "native Java" (QT) and it just doesn't sit right. For example I rarely use pointers in my code (or at least not owning pointers) and then when you start using QT, I have new, new, new, new...
That's right, but is there an implementation that does both?
Cool, thanks. Yeah, the BGL was pretty complicated, but worse still, the documentation was (probably still is) buggy.
You don't need to specify the methods as virtual in ACrypt unless you're expecting to subclass that as well.
I know. I kinda like that style though, as you always know which functions you can expect to have virtual behaviour at a first glance.
Well, once a method is marked virtual in a parent class, that method will be virtual in every child class, not just immediate children classes. Although not required, adding the redundant `virtual` keyword is useful to make it clear that the polymorphic overload is actually desired, and to make it clear for subclasses of AClass later that the method is virtual without them having to go all the way to the base class to verify.
True. Sorry about that.
I can see how it might break your flow, but I guess it wouldn't bother me as much if only the GUI parts don't use templates. You can still write code in that heavily templated style even if the library doesn't. As for me, I like the concept of STL but I really have mixed feelings about using it. On one hand, it's safe and efficient. On the other hand, it always seems harder to debug even the simplest and most common usage errors. It doesn't seem to even throw informative exceptions to let you know what's wrong... My biggest issue with wx is that it's sometimes hard to deal with strings, and I find all the duplication and conversion to be a hassle. You can build non-GUI parts of your software with wxCore, but who wants to introduce more dependencies? What library do you use? It doesn't sound like Qt or wx are very great, but we need something free and with a nice license and tools to use it easier.
I don't find the STL hard to debug at all, mainly because it is so simple IE the containers don't have 100 functions each just a clean interface for interaction with the data. That said I do not use a graphical debugger but I can imagine that it doesn't look to pretty in one. I would encourage it's use because the more you use it the more intuitive it becomes.
I'm not talking about the design of STL either, I agree that it's simple and that's a good property for understanding, and therefore debugging, code. I just think sometimes it should throw more meaningful exceptions. Maybe my gdb skills are too lacking, lol.
IIRC both the SIGNAL/SLOT macros and the member function way will be available in Qt 5
Qt can also be statically linked. In fact, static linking in commercial applications is one of the top reasons to purchase commercial licenses. 
Prolly should have a virtual CryptProcessor::~CryptProcessor() in there too...
If your compiler supports it, try to get used to using the "override" keyword in the virtual function declarations in your derived classes. If you start playing around with the parameters of a virtual function in the base, it will save you a lot of time tracking down errors later in case you forget to make all derived classes correctly match the same signature.
That might depend on the crypto-algorithms. Suppose your CryptProcessor uses a simple xor with a one-time-pad, you want to update the offset. (And in case you want to suggest "mutable" instead, IMNSHO "mutable" should have been abolished since multi-threading went mainstream; beginners shouldn't even know about it any more.) 
Is your problem with the STL the specification/standard or the STL implementation you were using?
No, but, you're not content with LGPL? (wasn't me who downvoted you.)
Qt 5 is already more or less in feature freeze, although I think the goal is to get a major version released under the Open Governance process for Qt 5. I can't quite remember the mailing list discussion, but I think the plan might be to get Qt 6 a bit sooner than people are used to for Qt major versions - which should be a little easier given that QML imports can be versioned, so there is one less thing to worry about on the compatibility front. Since the -no-stl configure option is being deprecated / C++98 support is becoming mandatory for Qt 5 it'll be a lot easier for Qt to make use of STL on the inside, although in the mailing list discussion on that topic the developers were a bit wary of exposing STL constructs through the public Qt API.
What???? That's one if the primary use cases!!! You have to mark your mutex as mutable!!
I believe the word you were looking for was pedantic :-) 
Fair enough. I thought I was too much on your case and deleted my comment anyway (before seeing your reply), as you can see. I'm too full of aggro anymore. 
It's the internet, everyone is entitled to their opinions and comments. And you were correct anyway, you just did not understand my situation entirely is all. Thanks for you consideration though :)
Who's the pedantic jerk now, eh?
A mutex perhaps, but not your state. 
&gt; Your implicit assumption that doing multithreaded manipulation of 'const' objects is safe doesn't hold in general anyways (in C++), so you still have to know where and when to properly stage your critical sections, even in absence of 'mutable'. No, it doesn't hold in general, but if I strictly don't use `mutable` in my code base, and keep to some other basic code-sanity-rules, I can be sure that a const-instance of my object can be accessed from multiple threads without locking. C++ allows some pretty weird and stupid stuff, but it's not too hard to keep at least *your* house clean. 
Mutable allows you to be "logically const" as opposed to "bit wise const". Logically const means that users of the class's interface can poke and prod all that they want and they'll never detect a change after a const method is called. Basically what you said, your state hasn't changed. The thing is, you often can't be bitwise const, thus you NEED the mutable keyword. Locking a member mutex to be thread safe modifies the mutex. Thing is, the mutex is an implementation detail, so declaring it mutable and modifying it doesn't violate the logical constness of the class. Same for reference counts, logging objects, etc, etc. So, why did you suggest that they should get rid of the keyword in light of multithreaded programs when modifying the member mutex is one of the primary, and correct, uses of the keyword?
cool!
Why?!
Wow that worked. Thank you! But, shouldn't it be ||(OR) because userInput2 can be either yes OR no. Hopefully someone can lend an explanation.
Besides fixing the logic error (i.e., using &amp;&amp; instead of ||), you should also be sure you read in some input! For example: cout &lt;&lt; "Are there anymore counties? [yes/no]" &lt;&lt; endl; if (cin &gt;&gt; userInput2) while (userInput2 != "yes" &amp;&amp; userInput2 != "no") { cout &lt;&lt; "Please enter either 'yes' or 'no'" &lt;&lt; endl; if (!(cin &gt;&gt; userInput2)) break; } but that is ugly. This is less ugly and shorter: cout &lt;&lt; "Are there anymore counties? [yes/no]" &lt;&lt; endl; while ((is &gt;&gt; user) &amp;&amp; (user != "yes" &amp;&amp; user != "no")) cout &lt;&lt; "Please enter either 'yes' or 'no'" &lt;&lt; endl; Even better wrap it into a function: // ... std::istream&amp; yes_no_prompt( std::istream&amp; is, std::ostream&amp; os, std::string const&amp; question, std::string&amp; answer) { std::string user; os &lt;&lt; question &lt;&lt; " [yes/no]" &lt;&lt; std::endl; while ((is &gt;&gt; user) &amp;&amp; (user != "yes" &amp;&amp; user != "no")) os &lt;&lt; "Please enter either 'yes' or 'no'" &lt;&lt; std::endl; if (is) answer = user; return is; } // ... so you can use it in more than one location and hide any ugly things in the function! :-) Further, in each of the above cases if there is an error on the input stream, it stops looping. The function nicely does not set answer unless it was successfully read in. :-)
Thanks. Ignore the downvotes. Maybe your question seemed a bit too basic to people talking about rvalue references and variadic templates? But everyone starts somewhere, we learn by doing and asking good questions. And in case you're interested, here's the [Wikipedia link for De Morgan's Laws](http://en.wikipedia.org/wiki/De_Morgan's_laws)
How in the hell have I only now learned about this? I mean, &amp;&amp; and || are completely natural to me, but 'and' and 'or' just make the code a bit nicer to look at, I think. But really, why did no one tell me this? =p
The downvotes may be because this topic might be better suited for /r/cpp_questions. Don't worry too much about it, though. After all, /r/cpp doesn't see too many posts anyway, so there's no chance of questions like yours drowning out news or other stuff.
You should memorize this. (A != x || A != y) type expressions are always true and almost always a bug.
I suggest you read [this](http://www.cplusplus.com/reference/string/operators/) and stop confusing people. You can compare a std::string to a literal using operator==.
I have to call it everytime the measured value changes to move the guage pointer to the appropriate value being measured. However, I only want to draw the background (hash marks, green values, yellow values and red values, and hash labels) one time. Would putting a bool var that changes from true to false on the first call stay like it's supposed to?
&gt; ATL (..) I am very new to programming If so then may I suggest switching to a toolkit that doesn't suck that much?
Have to use it for a Siemens Automation project getting info from a PLC, outputting to HMI using Windows CE.
&gt; Windows CE My condolences. Carry on then.
I shed a tear for you, no should have to use CE
You'll probably get a better answer on stackoverflow than here. The problem with not redrawing the background is that the foreground of your gauge is ostensibly changing, meaning different parts of your background are occluded at any given time. My recommendation would be to find a way to draw your gauge to an off-screen buffer, then blit that to wherever it's supposed to be on-screen. Any halfway-decent UI package should be doing this for you already. I have no experience with ATL, so I don't know if it supports off-screen buffering or not.
For those interested, I've completed two examples: * programming language example. * XML example. You can find it [here](https://github.com/axilmar/parserlib).
The OP on Stackoverflow thinks QT has a restrictive license that does not make it easy to statically link, mathewpl counters that you have a commercial license which does not really address the OP's concern
My ATL is rusty, are you using 2 controls? One for the background and another for the needle?
Been a while since I did C but do you need to initialize them first since they are arrays?
You should initialize your array; items not specified in an init list get set to zero, so double countyTotal[100] = {0}; Of course as this is c++, you should really be using a vector or other data structure and using push_back or insert etc to populate a variable-length collection. 
I suppose double countyTotal[100] = {0.0}; is correct actually. 
firstly don't use arrays they are considered depricated for uses: use a vector. std::cout &lt;&lt; "How man stores" &lt;&lt; std::endl; std::size_t size; std::cin &gt;&gt; size; /* ** If you prefer you can use two vectors or a vector of a struct it doesn't really matter **/ std::vector&lt;std::pair&lt;double, double&gt; &gt; country; country.reserve(size); double average, total; for(std::size_t i=0; i!=size; ++i) { do{ std::cin.clear(); //don't specific new line unless that is what you mean (its not) cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max()); std::cout &lt;&lt; " What is the total sales amount for store " &lt;&lt; i &lt;&lt; std::endl; } while(!(std::cin &gt;&gt;total)); average=total/pos; country.push_back(std::make_pair(total, average)); } This will do the same thing but safer. http://en.cppreference.com/w/cpp/container/vector 
&gt; firstly don't use arrays they are considered depricated for uses I don't follow. How are arrays deprecated?
Because they offer no advantages over using `std::array&lt;&gt;` and `std::vector` which have plenty of advantages over a plain C array. C arrays should be used for interoperability with C and that is about it. 
I could tell you what is exactly wrong with your code, but spend a little time in the debugger and if it doesn't hit you come back here. You will smack yourself in the head when you see it.
while everything you have said is true here, this is the problem with c++ courses in school. Instead of teaching the correct way to use stl containers they avoid stl like the plague. Sadly this class assignment probably does not allow for using stl containers. I wish my c++ courses weren't spent implementing our own stl containers, but rather making use of the stl and and exploring it deeper. It would have been nice to spend time making synchronized versions of stl containers by simply inheriting and overriding.
Your point about vectors is valid, but that's not what deprecated means. Deprecated means that the feature has been marked for removal in future versions. Arrays are fundamental and will never be removed from the C++ spec.
It's actually part of the standard that the integral type's default value is 0. I had to reference it recently for an argument at work. The binary was already using a zero initializing allocator so the argument was moot, but worth understanding.
Thank you this worked as well!
Thank you for your help. The last line of code helped solved my next problem that arose. But, why wouldn't the following code work? countyAverage[countyNum] = countyTotal[countyNum] / storeNum; When the loop would finish storeNum would have the same number as userInput1 anyway? Hmm can't seem to figure it out.
I know schools and universities have a lot to answer for. The problem is the path people take to become lectures. student -&gt; post grad -&gt; doc -&gt; post doc ... at no stage do they learn how to code properly, and you end up with institutions (like the uni I went to) who taught everything wrong. That doesn't however mean I aren't going to complain when I see people perpetuate these ideas just because their school taught them too. What is worse is people leave uni thinking that is what C++ and are scared off for life with the fear of the owning void*. :(
Yeah it works but it still doesn't provide any benefit over using std::array or std::vector. However it doesn't have a default value method, and it has inconstant passing semantics than other C++ data type (that makes up a good chunk of the questions on SO and the like). Where as std::vector and std::array have .clear() .size() .empty() const_iterators, and (at least in the case of std::array) it is basically free (ie no over head).
countyNum is used later in the program. 
^ winner. Typecasting ftw. 
Thankyou, but shouldn't the int/int convert to a double? I feel like it shouldn't matter since int/int is a whole number.
For such a small program, what's the difference?
What does this get you? Also, what does that template turn into?
It's impossible to tell, without RES, whether OP understood, say, the `#include` syntax, and therefore it's unclear what the OP is asking about. Even with RES, you only get to see the source in a tiny little box that you can't see much of at once. It's just a pain in the ass; people are going to hate you for it.
It's not even close to unclear what the OP is asking about.
http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used should answer your question.
Actually, no, because if height is 72, there's a line in there that squares it, so it becomes 140 / 5184, which is a very round zero.
Wrong. Vectors introduce many concepts that have no place in an introductory programming class. Arrays are simple, that is their advantage. It's not just a simplicity of usage but a simplicity of concepts. You can completely describe arrays with a few sentences. You'd need several paragraphs to completely describe a std::vector.
Others have already pointed out the error, but why not declare all your variables as doubles? IMO it makes your program clearer, you have the benefit that the user can input doubles and you get rid of casts (which is always a good thing). Of course you should be aware of the pitfalls of floating point calculations, but that is hardly relevant in this case.
It's not really a template, that's just how you distinguish between different types of casting in C++. The C style cast is all-or-nothing, one size fits all. It can be used to do benign as well as extremely dangerous things. C++ decided that it would be better to split the cast up into several different kinds, for more fine-grained control. A `static_cast` for example generally only converts things that are normally convertible, like ints to doubles. But you can't `static_cast` a pointer to an int, for example; you'd have to use a `reinterpret_cast` for that. It's encouraged in C++ to use the right cast for the job, which signals intent to everyone that reads the code and prevents you from doing something dangerous accidentally without explicitly asking for it. 
&gt; but it's important to note that the T(something) syntax is equivalent to (T)something and should be avoided (more on that later). A T(something, something_else) is safe, however, and guaranteed to call the constructor. Did not expect any better from C++. A damned syntax if there ever was one. 
Since we're talking C++11, I'd rewrite typedef foo&lt;bar&gt; foo_bar; as using foo_bar = foo&lt;bar&gt;; It's much more straighforward, expecially for function pointers : // Returns whether the face is still on typedef bool (*rock_fn_t) (Face rockThis); becomes // Returns whether the face is still on using rock_fn_t = face_state (*) (Face rockThis); And with templates // Can't do this in legacy C++ becomes template&lt;typename Person&gt; using posse_t = std::vector&lt;Person&gt;;
Yes, it would (T::id_type&amp;&amp; will always be an rvalue reference). An added bonus.
When I'm programming in C and C++, I usually `#include &lt;stdint.h&gt;` and go with `int32_t`, `int64_t`, etc., so that there can be no doubt. And of course, offsets/indexes and pointer differences should be `size_t` and `ptrdiff_t`, but with those, you should never have to rely on the width.
Don't ever take a look at the source code for Avahi then.
I believe there is a way to format tables as well, and I occasionally see chess games played with the ascii characters in tables.
&gt;the feature has been marked for removal in future versions I dont think it works like that in C++. auto_ptr and strstream will be with us forever. Backward compatibility is one of C++ biggest assets (and burdens).
Andrei Alexandrescu had a policy-based candidate for Boost's smart_ptr, which would have allowed parameterization by threading, reference counting, owning, all sorts - but it was shot down in favor of the simplest thing that could work, single-purpose shared_ptr. From there, to the standard. I think it's abominable if you can't turn thread-safety off in shared_ptr; what happened to "You don't pay for it if you don't use it"? That kind of makes it useless. 
Your recommendations are good. I would also suggest publicly inheriting from enable_shared_from_this&lt;T&gt; if you intend a class to be used extensively (and primarily) via a shared_ptr&lt;T&gt; (assuming, of course you control the class being pointed to). It's primary purpose, of course, is to enable an instance to return a shared_ptr to itself. Although an implementation detail, a typical side-effect is the elimination of the extra dynamic allocation to handle the reference counting (IIRC, at least in boost, it also results in shared_ptr instances to have the same size as a raw pointer). With the combination of these two side-effects, you should also see a some performance speedups. To what degree, I cannot say - I've not measured.
Is sqlite on your list of projects to check out?
make_shared is also useful for avoiding two allocations.
...and there's no way to specify an allocator for the reference counts.
sounds like iostreams as well, you can't get away from thread locking (stupid locales tied to streambuf).
that's actually a bad mistake. However considering the allocator weaknesses pointed out by the eastl writers you may want to use a smarter version of stl anyways.
Stop passing them by value and you can stop caring about the atomic increment penalty. It's only when you need to transfer ownership that the reference count matters. If you're passing a smart pointer to a function that only needs to use the object (observe or modify) as opposed to owning it, then pass a reference and there is no overhead compared to a standard pointer. 
I also like the recommendations. But the original does not have multiple threads accessing counted_ptr. The timing happens inside each thread and the counted_ptr instances do not escape the threads.
Yeah. :( While I have great respect for C++, every time the standard has created a library it has been horrible. Even seemingly simple classes like std::map have unexpected performance costs: just declaring one, even if you never put anything into it, causes a heap allocation (the "end of map" is implemented as a heap allocated marker; I am not 100% certain the standard requires this, but all of the implementations I've used had this strange behavior)... there is no good reason for that. :( The idea that they are now saying they are going to concentrate on more rapidly adding to STL (something they aren't good at) instead of continuing to spend their time on language improvements (which they have been generally good at) is downright distressing. :(
It is not always possible to know ownership at compile time. Interpretors being the classic example. Not that the author took the simple counted_ptr implementation from an interpretor in the first place!
Using exceptions with code that isn't designed with them in mind is a disaster waiting to happen, just as using threads with code that wasn't designed with *them* in mind. But in a code base that was started with exception safety (i.e. RAII) in mind from day one, they have always been a very good thing, leading to clean code with few places explicitly caring about them. And not to forget, consistently using RAII not just covers many/most exception safety issues, but also solves most resource management questions, too. PS: This might be hard to understand for people used to other languages: In C++ the destructor is the most important thing to achieve exception safety, not the try/catch/finally. PPS: That's also a reason why I don't like C++ and Java to be grouped together too much, the object model, in particular regarding the object life cycle, is very different, and C++'s deterministic destructor is a main part of this difference (yes, C++ and Java can be "more" grouped together when comparing to something more different like Haskell or OCaml, but they shouldn't be thrown in the same pot in the context of OO languages). 
To allow shared ownership between multiple objects where thread-safety is guaranteed via some other mechanism (i.e. all owners are guaranteed to never execute concurrently), use boost::intrusive_ptr.
not a bad idea, but it requires more work. How about just making a version of counted_ptr which uses intrusive_ptr.
Why?
... If you care enough to complain about the performance of shared_ptr, deriving from a thin wrapper to provide reference counting shouldn't be a big deal. Furthermore, the intrusive count will improve cache performance as opposed to the separately managed count that your counted_ptr inevitably uses.
Yes, there is a templated conversion constructor. While shared_ptr&lt;T&gt; and shared_ptr&lt;const T&gt; are not reference-compatible, the former is convertible to the latter.
would std::allocate_shared solve that issue?
That is what I siad so I guess I agree with you.
As an extension to your post, the Standard Library has the functions std::static_pointer_cast&lt;U&gt; std::dynamic_pointer_cast&lt;U&gt; and std::const_pointer_cast&lt;U&gt; That are designed to convert a std::shared_ptr&lt;T&gt; into a std::shared_ptr&lt;U&gt;. So converting to a const T under the hood can be done with auto cptr = std::static_pointer_cast&lt;T const&gt;(ptr);
If you're already using C++, why not use the bool type? It's not like that code will ever work in C.
You are right except that the code comes from a bigger project where all types which were legal in the implementation of the dsl were typedef so it was consistent and thus easier to code.
...But implementation of weak pointers is not so easy. I myself don't think they are very useful and prefer "safe" pointer (which are weak pointer invalidated only in debug build, without public validation interface), but it can be an issue.
Well, thatâs what I said in the last paragraph, I guess.
That is done by implementing the last constructor on the .h file. String(char []). 
With just that code it looks like Cap and Len will not be initialized to a logical value. Is this all of the code you have in the constructor? You would want to set Len and Cap to the length of the char array you are given. That way when you do copy using your I variable it will actually iterate and copy, right now I see it as doing nothing as I will always be =&gt; Len.
the OO approach would be for each node to decend from a shared based, and you store a `std::unique_ptr&lt;base&gt;` rather than a union. Another approach it to use a library like boost Utree which deals with variants which is sort of the modern day union.
The one I described in the inside text.
Why not use polymorphism. A NodeBase class. And a class derived from NodeBase for each type.
Seems more of the obvious approach. Why would you even go to unions first?
Because I have far more experience with C than with C++ which is why I asked.
I wasn't trying to be condescending (although it probably came off like that). Yea use a common base type :)
Absolutely! The key to type safety in such cases is [`dynamic_cast`](https://en.wikipedia.org/wiki/Dynamic_cast). It tries to upcast your pointer from a base type to a derived type, or returns `NULL` if it fails to do so. class NodeBase { public: virtual ~NodeBase() {} // See note 1. }; class FooNode : public NodeBase { /* ... */ }; class BarNode : public NodeBase { /* ... */ }; // etc. void processNode(Node* node) { if (FooNode* foo = dynamic_cast&lt;FooNode*&gt;(node)) { /* Process a FooNode. */ } else if (BarNode* bar = dynamic_cast&lt;FooNode*&gt;(node)) { /* Process a BarNode. */ } /* ... more else if statements here */ } You might still want to use the enum for the sake of efficiency, particularly if there are more than a couple of different derived types, because `dynamic_cast` isn't quite as cheap as, say, `static_cast` or `reinterpret_cast` (which you should almost never use unless you really, really understand all the cast operators and know for sure you can only use `reinterpret_cast`). But if you go this route, _always check to see the result of the dynamic_cast is not `NULL`_, even if the enumerated type tells you that you should be correct. Note 1: It's important that your base class Node have a virtual destructor so that when your Node is destroyed, it also destroys the elements of the derived class; additionally, `dynamic_cast` just won't work unless the base class has a vtable.
Big hammer in what regard?
Expecting everyone to be able to use c++11 is pretty ridiculous at this point. In a production environment it's not at all uncommon to not get to upgrade or rely on the latest standard that quickly. You're basically doing the programming language equivalent of a year after vista came out saying "oh, your company uses XP still? Well too bad, I only help with the latest thing." edit: way to foster discussion on this oh-so-large community, cpp. Really helping us grow!
I don't expect people to use it, however my answers will gravitate towards the new standard. Here the problem as like you say, people still use XP, XP is going anywere in the next 10 years (and probably more!) industry is hooked on. Do you think it is reasonable to still be giving out C++98 answers in 10 years. If my answer doesn't help someone then they can ignore it. 
10 years, probably not without a specific reason. 5? Yep.
Passing the *contents* of an `std::shared_ptr` by reference, as you suggest, is a sound plan, but you have to be able to make two guarantees: * The pointer must never be NULL. * Nobody down the call chain will need to take part in the shared ownership (i.e. store a reference to the object). This can be circumvented with `std::enable_shared_from_this`, but frankly isn't very intuitive. If what you have is a pointer, and your code needs to think of it as a pointer, it's best to acknowledge that, and a const-ref, while verbose, serves that purpose. The issue arises when your call chain is deep, and you don't know at the top what happens at the bottom. For a deep call chain, passing `std::shared_ptr` by value is the worst thing you can do, unless you're using `std::move` every step of the way.
Well, this'll be my last response since apparently cpp is offended by the suggestion that people might not be able to use the newest things and is downvote brigading harder than when I was linked on SRS. I can see your point, it was mostly that it seemed like there was a kinda condescending attitude that bothered me. I'm also biased, because I don't get to use c++11 at work (which bothers the shit out of me, for the record.) 
I am implementing a forth right now, and using a variant from boost for the list. 
: ) one day
I agree to some extent - but that's not what he was asking, though perhaps that's what he wanted. He was asking for a drop-in replacement for unions. Sometimes you really just do need to store multiple _data_ types, not classes, in the same slot. Sometimes you really can't do it with virtual methods because each data type is quite different.
First, discriminate unions are fairly difficult to understand and use correctly, as you yourself point out. Boost is a huge system, and it's really not obvious what parts you can take and not take. My Boost code directory is much larger than all my other code directories put together! _If_ you were already using Boost, then it would make sense, but otherwise that's a lot of mechanism for a fairly simple task that can be done with polymorphism or `dynamic_cast`.
I have almost stopped evangelising this point but I have yet to hear a compelling argument against using (parts of!) Boost, even for small tasks. Boost is effortless to install nowadays, and the fact that itâs huge *doesnât matter*. After all, the .NET framework and the JRE are both huge but people have given up complaining about this fact.
Using `dynamic_cast` the compiler can't check that all your cases are handled. And using virtual functions requires putting all your logic into your nodes, which requires you to change all your nodes when you add a new functions. Using `boost::variant` is the best approach. &gt;My Boost code directory is much larger than all my other code directories put together! Who cares.
Unions don't have to break type safety, but I have to think what you really want is a class hierarchy, probably with a fair set of virtual functions, and probably with a working visitor pattern. Is there a reason you don't just go that way?
You would need to use a curses library for that. I'm guessing from your screen shot that you're using Windows, where curses libraries are traditionally not available. You might give PDCurses a try, as it claims to support Win32. The curses API is not the most pleasant thing in the world to work with. You might consider just making the program a GUI instead. 
I saw it was open sourced recently and heard that it performed well on some benchmarks. I figured I'd see if my code worked on it, and it wasn't too much trouble (though they get a dependency on Boost::tr1 because I'm using function objects.) Might be worth dropping support for it if nobody uses it, though. It doesn't generate faster code for me than either g++ or clang, and I wouldn't say no to the new bits in C++11.
I would ditch it them, there is great merit in using a commonly used compiler like gcc or clang (or icc if you really need vectorisation); mainly because there is a lot of support for it and they get new features quicker. 
It's is an external dependency and it doesn't come with MSVC or most linux distros. That's not a *compelling* reason not to use it, but it's a reason to think twice. My hobby project was just using `boost::timer`, and it was definitely worth spending 20 minutes and 20 LOC writing a replacement instead of telling users to download 50 megs of libraries. The best solution in that sort of case is probably to drop in the needed header from boost when distributing the code - it's already written, small, well-tested, and permissively licensed, after all. I'm not sure if people do that, though.
oh I see, is it a comcercial product that you are supporting (in which case you have some duty to continue to support) if it isn't then I wouldn't hesitate to drop it.
When learning a new programming language I like to make a game like Tetris or Breakout.
I disgree with using an OO approach without good language support for multiple dynamic dispatch and even then you'll end up with overkill wtf code. Go with the boost::variant with static visitors approach or use a proper parser framework.
It really depends on how familiar you already are with c++, if you want to train basic stuff like functions, returns etc. you could write a simple calculator, or a string reverser that reverses a string typed by the user. It really depends on your skill level and also on what direction you want to go after the basics, do you want to do something with a GUI (windows with buttons etc.) or games? Either way you have to learn something additionally to c++ like Qt for GUI or OpenGL/DirectX for Games. If you like to do something with Art you could pickup something like SFML or a similar lib and create some nice Animations. We could give you a ton of ideas, but if you want something that you'll like you should give us some more input.
reimplement a couple of unix utilities: echo, cat, ...
I have a friend who's written snake (maybe not pure snake, but a snakelike game) about 8 times in 5 different languages (if I remember right). QuickBasic, Turbo Pascal, C++, Python and Visual Basic... I think.
SFML is goddamn beautiful. Would highly recommend to anyone who wants to visualise things (which opens a massive world of ideas).
[/r/dailyprogrammer](/r/dailyprogrammer) might suit your needs.
In what regard is it an afterthought? Personally, I would either use PhoneGap or bite the bullet and port to each platform in their "native" language until the lighthouse project is completely mature.
Is it reasonable to use this version for production, or is it advisable to wait for 4.7.1? 
Well, I've not used it (hence the question!), but it doesn't seem to be part of the core product, but instead is a consumer written add-on. Maybe I'm wrong - I'm really putting feelers out for information here.
try giving this a read [when to use virtual inheritance](http://www.parashift.com/c++-faq-lite/multiple-inheritance.html#faq-25.9)
Casting a void pointer to any type other than the one you cast it from, a character pointer, or an unsigned character pointer is undefined behavior. There's no guarantee that your memory is laid out in any sane way, and you shouldn't rely on derived pointers being the same as base pointers. IIRC, there's nothing stopping an implementation from doing things like putting the derived class' members before the base class', which would make nearly every pointer cast change the value of the pointer. This is not a problem with inheritance, it's a problem with your casts. Don't cast pointers to `void *` unless you know they'll be cast back to the original type before they're used, and won't instead be cast to a derived or base type (although it's fine to do the base/derived cast *after* casting back to the initial type).
It depends on what you're producing.
I hate having to argue with other programmers about this. It's undefined behavior, I don't give a crap if it happens to work for your current class hierarchy.
They do have a large testsuite - you could look at their regressions + bugs, and judge. Or, run the testsuite yourself. Usually though there are a few bugs with .0 releases. 
Yes, this is the answer. To implement virtual inheritance, there are multiple vtables. And this also requires thunks to adjust the `self` argument to point to the correct vtable when calling methods, so that each method sees the vtable that's appropriate for it. Using casting tricks to make the compiler forget everything it knows about a pointer discards all this information, and bad things end up happening. 
www.projecteuler.net
You would have to convert them to strings, concatenate them and then convert the concatenation back into an int. Use the string.h header for string manipulation.
You mean like this #include &lt;vector&gt; template&lt;typename IT&gt; int range_to_int(IT first, IT last) { int i=0; while(first!=last) { i*=10; i+=*first++; } return i; } int main() { std::vector&lt;int&gt; a { 1 , 2 }; int i=range_to_int(a.begin(), a.end()); } This might not work as you expect if you have greater than 1 digit number in the array, that is easy to fix by getting the magnitude of the value in the array and multiply i by that instead of just 10.
Thanks for different input! I'm very unsure with what I want to do in the future, and currently just learning it as a hobby. But I have been thinking about joining some open source project to do just that. Thanks for the advice.
An alternative in case OP actually wants to assign the result to *int a* as he describes (base 10): int array[5] = {1,3,5,7,9}; int a = 0; const int arraySize = sizeof(array) / sizeof(int); for(int i = 0; i &lt; arraySize; i++) a = (a * 10) + array[i]; Take note OP that you won't be able to have more than 9 digits (32-bit) or 19 digits (64-bit) otherwise you'll get strange results.
Actually some people learn better by challenging themselves and being forced to look things up as they go, this is probably closer to OJT than writing anything from the ground up. That being said, this is something that should be done after having completed some basic course to understand the language and how to program. The challenge could also help spark an interest and direction for other courses to take for a deeper dive on learning.
This exactly, you are dealing with numbers so use math. Otherwise convert them to strings and deal with them like chars.
Ah, I missed that part. Well OP has a non-stringstream version if he wants.
c array is perfectly fine and has much less overhead. for other tasks dynamic data structures can be better but we have no idea what the arrays are used for (other than digit storage) 
How sure you have to be about your tools is directly related to what you're making. Bugs in a phone app aren't as big a deal as bugs in a program that assists in brain surgery. Also, YMMV based on: * How much control you have over your deployed environment * How easy bug fixes will be to push * If current regressions and bugs in GCC are in areas critical to you program * How hard it would be to switch compilers or compiler versions if that becomes necessary * How disasterous a bug could possibly be (death? bankruptcy? lawsuits?) * Which new or experimental features of the compiler are you planning on using? ... and I'm sure there are other considerations. Anyway, it's hard to give advice on this sort of thing without knowing more details.
I have been using this for C++11 features for a few months now. I am just waiting for debian experimental to update from rc2 :-).
When you say you're working in binary do you mean your array is full of 1s and 0s? Or do you mean binary as in raw data? * If the former is the case: a = (a &lt;&lt; 1) + array[i]; * If the latter is the case then consecutive zeros won't turn into one zero. If your array began with consecutive zeros then they would not be counted, but that's supposed to happen. * If you want prepended 0s to "show" then you're implicitly talking about int to string conversion. So it's really just a formatting issue: std::cout &lt;&lt; setfill('0') &lt;&lt; setw(arraySize) &lt;&lt; a; That will display your number including any beginning 0s in your array.
`std::array` has no space overhead compared to a static C array. A vectorâs only overhead compared to a dynamic C array is its capacity; not even worth mentioning. Neither of them has any runtime overhead.
they dont incur runtime penalties unless you use the functionality that makes them different than c arrays, and if you're not doing that then it really doesnt matter what you use.
That is why there are at least three examples of how to do this in response.
Nonsense. They still offer memory management at no cost to you. That *is* a feature not offered by C arrays. Furthermore, the âotherâ features they offer (automatic resizing, reserving memory, back inserter iterators) would cost just as much when implemented with C arrays so once again they donât have any overhead compared to code which doesnât use `std::vector`.
how does int a[5] not get managed? if you manually allocate then yes, you need to free or delete, but there is definate overhead for the others, and while its not much because they are essentially wrappers, it is noticable in certain cases (eg server with only a few hundred mghz) which brings back the case by case point i originally mentioned.
I was obviously talking about dynamic memory management. For a fixed-size array youâd use `std::array`, not `std::vector`. You are wrong about there being an overhead in other cases. There simply isnât. Iâd be interested to know which overhead specifically youâre talking about so that we can agree on whether it exists or not.
You forgot one point. In general there is *no* reason to pass shared_ptr by value to functions. Its an expensive to copy object so should be passed by const reference like usual. Herb Sutter said this in one of his talks ... 
That's actually what I meant by the first of my points. :) &gt; * In most use cases, incrementing and decrementing the refcount on an std::shared_ptr&lt;T&gt; is actually pretty rare, if you make sure to pass const-references when calling a function That said, it comes for free if it is passed by-value through `std::move`, which can obviously only happen in tail calls.
Good, I missed that. Carry on.
Scott Meyers doesn't actually write anything in C++, as he himself admitted. He is a theoretical C++ developer, so to speak ;-)
I'm so glad you asked this, as I was about to ask this myself. Some of these games sound like good ideas.
I read recently that Josuttis doesn't either. It can't be sign of a healthy community when the people teaching a technology don't actually use it.
I think I'll wait for the next issue of Effective C++. That PDF is just a collection of presentation notes, not really useful unless you attend the course.
That PDF is 364 slides of the new C++11 features teased apart with tons of example code. It is not written for beginners, but if you have a handle on C++98/03, I strongly suggest it as a great starting point until the 4th edition of "The C++ Programming Language" is available. I purchased it to better understand variadic templates, but I find myself returning to it again and again.
Zero-cost? I would think templates have quite a high cost. Consider that in the good 'ol days of C a template version would use "ugly" and certainly unsafe void* semantics. It would have a single implementation though! Now a template is instantiated multiple times literally multiplying compiled code size. If code is heavily templated and uses multiple types for say a numeric library, float, double, and long double... it will be 3 times as big. A flat tax on abstraction. Now this cost is not without benefits, especially to the optimizer, however it is probably also not the only size cost c++ induces. Edit: A C void* abstracted floating point library is not doable, it is with INT, LONG, LONG LONG, etc... sorry about that... Instead think template&lt;typename food&gt; class foodprocessor {...}; as having void* semantics
Not all problems require classes. Remember, C++ is a multi-paradigm language and sometimes plain old function is all that one needs. In fact, if I needed this functionality, the interface would look something along these lines in C++: std::pair&lt;double, double&gt; find_roots (double a, double b, double c); No classes, tuples, or any of that nonsense. Nice and simple. 
&gt; I find it interesting because one of the main goals for C++ is to have zero-cost abstractions No, they were supposed to be zero-cost *if you didn't use them*, and they pretty much are. It's "pay as you go", not "go for free".
Yeah, `-O4 -s` improves code size by almost 50%. Not to 692 bytes, though. That seems low unless there is some sort of compile-time evaluation happening.
Templates have a cost in code size but there's a tradeoff with execution speed. Templates can often be faster than the equivalent code using void*. For instance, qsort requires an actual function call for every comparison but the comparison for std::sort can often be inlined which avoids the overhead of many, many function calls.
I was curious too. #include &lt;cstdio&gt; #include &lt;cmath&gt; template&lt;typename T&gt; struct Roots { T root1; T root2; }; template&lt;typename T&gt; Roots&lt;T&gt; findRoots(T a, T b, T c) { static const Roots&lt;T&gt; BAD_ROOTS = { NAN, NAN }; if (a == T(0.0)) return BAD_ROOTS; T root1 = ((-b) + (sqrt((b* b) - (T(4) * a * c)))) / (T(2)*a); T root2 = ((-b) - (sqrt((b* b) - (T(4) * a * c)))) / (T(2)*a); return {root1, root2}; } int main() { auto roots = findRoots(1.0, 6.0, 8.0); if (std::isnan(roots.root1) || std::isnan(roots.root2) ) { fprintf(stderr, "Error: Could not find roots with the given values.\n"); return -1; } fprintf(stdout, "Root1 : %lf\n", roots.root1); fprintf(stdout, "Root2 : %lf\n", roots.root2); return 0; } With g++ 4.6.1 I compared your version with the templated version and the templated version was smaller. -O2: 7717 vs 6739 -Os: 7612 vs 6723 -Os + strip: 5216 vs 4496 
In the comments someone brought up that reporting an error on for instance 0 *x * x + b * x + c = 0 is a little harsh. I dunno, sounds like a good point to me.
It's the ` / (2 * a)` in the quadratic formula that's the issue, not the math per se. But, yes, he could return `-1 * c / b` when a is zero. However, if we're picking nits, I would consider using `==` with floating point types to be a bigger concern.
&gt; Size comparisons are only significant when you're comparing to void* code That's what I was comparing them to. Copy/paste or fancy macros are effectively the same thing as templates.
Cool. My comment is for the benefit of the lurkers, then. My point was that qsort does its polymorphism at runtime and std::sort does its polymorphism at compile time, which is why std::sort is almost always faster. Comparing apples to apples would be comparing qsort to something that uses virtual functions since both are runtime polymorphism.
My thoughts in general, too. I'd like to see the iostream replaced with something close to stdio but typesafe and using variadic templates (assuming that doesn't have huge costs). Writing: std::out("Your number equals ", someInteger, "."); ...or something similar would be a big improvement.
Sorry, that was the source file, I forgot to fix it.
Wow, so it seems that in my c++ class we're learning an older style. Lots of the modern stuff looks really cool but I haven't seen it yet. Is it normal to teach a more classical-style use of a programming language and let the students figure out modern conventions on their own?
Yeah I suppose so. My programming teacher also taught us a 'C+' coding style. C++ classes with no use of the STL or strings. Just char* and iostream. I guess this was to teach us how things worked under the hood.
Try `-Os` to produce a small executable. And leave off `-g` or add `-s`.
I do think using tuples is better, since a pair can mean different things in C++(such as a range). Futhermore, tuples add no more complexity to the problem.
No problems =], I'm starting to really enjoy it =].
Unless you are running on a really stripped down platform, binary size doesn't really matter as much any more (if you're writing code for those kinds of platforms you really should just use C or assembly :p). What really makes a difference nowadays is how cache-friendly your code is. Templates can be faster than using void pointers because, as you stated, the compiler can turbo-inline your stuff. A good example of this is comparing C's qsort() routine that uses void pointers and function pointers, to C++'s std::sort.
Hmm, it's specifically a c++ class, and the teacher definitely knows his shit (he's the head of the CS department), but he's also pretty old so maybe he's stopped caring about being up to date? He did specifically tell us that we could use older versions of the textbook so I doubt we'll be learning all this cool modern stuff. Is "void main(void)" considered bad because you could just write "void main()" and accomplish the same thing?
Okay, it may be a class "specifically for C++", but, being in college right now, that could also translate as a class "specifically to do intro to programming which just happens to use C++", which is completely different.
In C, if you don't specify any parameters, it plugs in an in parameter for you. That is, `void foo()` and `void foo(int) {}` are equivalent in C. In C++, if you don't specify any parameters, it assumes you don't have any, so `void foo() {}` and `void foo(void) {}` are equivalen in C++. So `void main(void)` is technically OK, but its a bit of a tell that the developer cut his teeth on C. There are other idiosyncracies you can watch for, too, like : * `#define SOME_CONSTANT 1` instead of `static const unsigned SOME_CONSTANT = 1;` * `typedef struct { ... } mystruct_t;` instead of just `struct mystruct_t {...};` * ditto for enums * `int x = (int) someFloat;` instead of `int x = static_cast&lt;int&gt;(someFloat);` * using Initialize and Destroy methods where constructors and destructors would do just as well * using switch statements with enums where some kind of baked-in polymorphism (templates or virtual functions) would do just as well * failure to use virtual destructors But back to `void main(void)`. Beyond the "this guy never quite took to C++" style, you should really return an `int` from main in both languages. This is how the program communicates its status to the program that executed it (usually a shell or the OS). 0 indicates success. Any other number is considered an error code.
&gt;Error 404 - Not Found [Google Cache](http://webcache.googleusercontent.com/search?q=cache:4RDTsEXgTAMJ:blog.feabhas.com/2012/03/on-the-evolution-of-programming-style/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=de)
This conversation should be about tooling. If tooling was good enough to give an idea of what code caused what executable size then one could write in C++ and late optimize for size those bits of code which created bloat. As it is, we (the community) go around discussing what we think might be the case in much the same way as one might discuss the number of fairies which can stand on the head of a pin.
I find it funny that in a video about making variables threadlocal, his example routine has calls to srand() and rand() which are not threadsafe. &gt;The function rand() is not reentrant or thread-safe, since it uses hidden state that is modified on each call. This might just be the seed value to be used by the next call, or it might be something more elaborate. In order to get reproducible behavior in a threaded application, this state must be made explicit; this can be done using the reentrant function rand_r().
Yeah, my professor has us returning int too. I have been forgetful and returned void and he didn't complain about it, but he did teach us to return int at least. He's got a couple of those idiosyncracies from your list. I actually haven't learned struct, enum, or virtual destructors yet though, so I'll keep a watch for those when they come up. Alright, just one more question since I'm a bit of a noob. I see nearly everyone calls their functions "foo()" when they make examples. Is there a reason for this name?
main always returns int back to the operating system.
It turns out that you are wrong in this case. The video is clearly using Visual Studio and rand is thread safe on windows because its state is thread local. If the code were on Linux you would be correct.
I am not sure I like the association ;-). Hibernate is bloated, convoluted, and slow. ODB is (hopefully) nothing like this. Anecdotal evidence: one of the users migrated from Hibernate to ODB and got *two orders of magnitude* speedup (they are using SQLite). Needless to say, they were pleasantly surprised. You can also check what others think of ODB in the [User Quotes](http://codesynthesis.com/company/quotes.xhtml) page.
I do prefer you stdio solution the problem is whilst it looks great for std out how do you implement the input equivalent, personally I believe scan is a horrid tool to use. you could continue to use cin (which I think is pretty good) but the you have asymmetric IO functions. 
Maybe: `auto userInput = std::in&lt;unsigned&gt;();`
It's hard to pin down origins of memes for sure, but `foo` and `bar` are generally seen as puns on the acronym FUBAR, which stands for Fucked Up Beyond All Recognition/Repair/Reason. http://en.wikipedia.org/wiki/Foo_bar
how would you know that it failed? exceptions? I think that would add a lot more boiler plate. And a complete while loop and try catch to get the right input. I see the argument for a new out but I don't think it is enough of an issue to actually leave iostreams.
I think there is a reasonable amount of my work freely available online. I gave two talks at last year's ACCU conference, and both are available online. My only-barely-advertising [blog post here](http://scottmeyers.blogspot.com/2011/05/videos-from-accu-talks-now-available.html) has links to the videos, and the followup non-advertising [blog post here](http://scottmeyers.blogspot.com/2011/05/presentation-materials-from-accu-talks.html) has links to the corresponding handouts. Videos from sessions that Andrei Alexandrescu and Herb Sutter and I did at last year's [C++ and Beyond](http://cppandbeyond.com/) are available [here](http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2011-C11-Panel-Scott-Meyers-Andrei-Alexandrescu-and-Herb-Sutter) and [here](http://channel9.msdn.com/Shows/Going+Deep/CB-2011-Panel-Herb-Sutter-Andrei-Alexandrescu-and-Scott-Meyers-Concurrency-and-Parallelism) and [here](http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2011-Scott-Andrei-and-Herb-Ask-Us-Anything) and [here](http://channel9.msdn.com/posts/Scott-Meyers-Andrei-Alexandrescu-and-Herb-Sutter-C-and-Beyond). Links to my written articles, including last year's [Appearing and Disappearing consts in C++](http://cpp-next.com/archive/2011/04/appearing-and-disappearing-consts-in-c/) are available at my [articles and interviews page](http://www.aristeia.com/publications.html). (Now that I think about it, I should probably set up a page to link to videos of stuff I've done. Sigh. So much to do, so little time.) Scott PS - This is my first post to reddit, and there does not seem to be a preview capability, so I hope this comes out looking reasonable. 
I would have loved to participate, but I had committed to a client visit several months before GoingNative 2012 was conceived, so by the time Microsoft asked me to give a talk, I was unavailable. They've asked and I've given them a commitment to appear next year, provided it does not conflict with an existing obligation at the time they determine the dates for the conference. FWIW, I will be participating in a different C++ event in the not-too-distant future, though I can't say what it is, because it has not been announced yet. My understanding is that talks from that event will stream live for free and, presumably, be archived and available for free viewing thereafter. Scott 
To shed a little light on where my frustration comes from, and what I meant when I said advertisement: the linked [post](http://wp.me/pLlHC-m6) produces very interesting questions, for which no answers are provided (understandably, since it is meant to make the event interesting). I would very much like to attend these conferences, but I live on the other side of the world and for the time being I can't afford to just fly to the US to conferences or courses. So that's frustrating and hence my rant.
No reason other than this was a piece of demo code and the random thing had nothing what so ever to do with what was being demonstrated!
I really dislike iostreams used in this manner. better to use std::getline #include &lt;iostream&gt; #include &lt;string&gt; int main (int, char*[]) { std::string str; while (std::getline (std::cin, str)) { std::cout &lt;&lt; str &lt;&lt; std::endl; str.clear(); } return 0; } 
I was wondering that, myself. For those of us unable to make it to their sessions, I guess we'll have to wait for a blogger to sum it up for us afterwards. --I just noticed Sutter's comment on returning initializer lists. That's a pretty cool feature I haven't yet stumbled across.
Yeah, returning `{15, "str"}` is a lot nicer than returning `std::make_pair(15, std::string("str"))`, and just as obvious when reading it.
Probably static and volatile. And I'm willing to bet that despite making this seem like such a grand change with revolutionary consequences... it really won't make much of a difference.
He says it's not 'auto' and 'register', but does that mean it's not either? 'auto' has changed completely in C++11. The only other ones I can think of are 'using', which has new functionality (for declaring type aliases), and 'default' and 'delete', which can explicitly declare the default generated special member functions, or disallow them (without declaring them private). But all of those keep their original meanings as well, unless I've missed something.
Yeah. I'm aware of `sync_with_stdio`. What I said was "**if** iostream is not acceptable for your uses". It's fine for 99% of cases out there, especially when you know which tweaks to make. That being said, using the bit shift operator for serialization is funky and doesn't mesh with the rest of the language like a variadic function would. What's more, it doesn't mesh with the programming community in general. Most languages either use something like `toString` or do implicit string conversions. I'm having a hard time coming up with another language that uses `&lt;&lt;` to serialize. From what I can tell, the goal of `iostreams` and its use of `&lt;&lt;` was to provide type-safe IO and separation of formatting from buffering. We can do that now with variadic templates and user-defined literals. There may not be enough of a need to move on to something better, but I'm not seeing a great case for `iostreams` being the best standard IO implementation possible.
Personal shot, dude. I believe he's entitled to a free pass to make fun of your moms now.
I dunno, his Mom's hairstyle has probably changed since the 80's. 
I don't understand why you say that's scary? People explain the new features in the context of C++03 because people have been programming things a particular way for almost a decade. Now those tasks can be simplified using C++11, and so the idiomatic C++03 code is contrasted with C++11 code.
Well, since he mentioned multi threading, this could be it. Static function locals now are guaranteed to be initialized in a thread-safe manner. And volatile? I dunno. What about volatile?
or you can try.... char* __cxa_demangle(const char* __mangled_name, char* __output_buffer, size_t* __length, int* __status) in gcc.
As far as I can tell, it's actually not simplified. The new features don't necessarily play well with C++03 so you have to not know only how the new feature works, and the old feature, but about how they interact. Take something simple like lambdas. It's meant to look like a function, but it only is a function under a particular set of conditions. The new features of C++11 aren't replacing the old C++03 features and making our lives easier, they are adding to them making the mental burden even larger. This is scary because I can only keep so much about the language and the system I'm working on in my head any given point, so my chances of making a mistake increases. I think C++ is impressive, but the complexity of the language is only increases and it's hitting a point where it will just be too much for a programmer, I think. The features simply aren't encapsulated enough, they all interact with each other in interesting and surprising ways, which is not a good thing.
 template&lt;class T&gt; string str(T s) { stringstream ss; string res; ss &lt;&lt; s; ss &gt;&gt; res; return res; } int x = 5; my_string += "Some" + str(x+5) + "text"; This just uses the stringstream class in the standard c++ library. You can pass nearly anything into that function and convert it to a string. 
that's called a function.
hurr durr Still, what's the point of the wrapper *function*?
More generic version: #include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; template&lt;class U = std::string, class T&gt; U lex_cast(T s) { std::stringstream ss; U res; ss &lt;&lt; s; ss &gt;&gt; res; return res; } int main(int,char**) { int x = 5; std::string my_string = "Some" + lex_cast(x+5) + "text"; x = lex_cast&lt;int&gt;("42"); std::cout &lt;&lt; my_string &lt;&lt; x &lt;&lt; std::endl; } see also www.boost.org/libs/conversion/lexical_cast.htm
This is less convenient than doing this in the cli. 
The `std::move` isn't necessary, the string value return from the `ss.str()` is already an R value, all you are doing is reducing chance that the compiler will apply copy ellision by increase indirection. 
Kind of hard to take Sutter too seriously when the first paragraph contains: &gt; ... why modern C++ is clean, safe, and fast â as âclean and safeâ as any other modern language, and still the king of âfast.â The only one of these I can concede is that yes, C++ code tend to be quite fast.
I think you're confusing not having a move constructor and having a deleted move constructor. Not having a move constructor will make `type a(move(b))` use the copy constructor, whereas having a deleted move constructor will make that resolve to the type of the move constructor, and then fail because the move constructor doesn't exist. I read the quote as saying that move constructors aren't always faster than copies, sometimes they're the same cost, and then you shouldn't implement move because what's the point? What you shouldn't do is delete the move constructor, since that makes type resolution fail even though you have a copyable type. And no, you shouldn't try to move when there would be bad side effects, but you should try to move whenever you can without breaking your program. In the worst case (assuming a non-broken type) it'll just do a copy instead of a move, and everything will be fine since you don't interact with the object you were trying to move from after that. And with the concrete example, you can just use `move_if_noexcept` if you're not sure how to deal with exceptions. That way, if there is an exception, you know you copied instead of moved, and can still use the old container, but it works correctly with types that are movable (and don't throw) but not copyable. If you have types that throw on move and can't be copied, then the best thing to do IMO would be to just use the old container if they ever throw; those elements should be in a valid state. But really, there's no good answer to this question, you'll lose data any way you try it. And in case you're not convinced that having a deleted move constructor but a working copy constructor isn't idiotic, here's some code that doesn't work: class foo { public: foo() = default; foo(const foo&amp;) = default; foo(foo&amp;&amp;) = delete; }; foo bar() { return foo(); } int main() { foo n1(bar()); } If you just removed the deleted move constructor, the code would work fine.
I agree, but I welcome any cli tool available on the web. You never know when you suddenly need it.
ty reposted. if a mod wants to delete this?
&gt; The build scripts assume that they can use C:\Temp\gcc as a working directory and that they do not live directly within it `%TEMP%` would be better. 
No. I'm keeping an eye on [mingw-w64](http://mingw-w64.sourceforge.net/), but they're still stuck on code-based SJLJ (setjmp-longjmp) exception handling, which is not efficient. Their [FAQ entry](http://sourceforge.net/apps/trac/mingw-w64/wiki/Exception%20Handling) indicates that they may be moving to table-based EH.
I guess I can't ask you to redo all your work, but if I have to choose between having efficient exceptions with extreme memory limits, or full access to my memory with slightly slower exceptions, I'll take the slower exceptions any day. The point of exceptions are that they are exceptional: if I write some code where performance bottleneck is in exception handling, then I've done something fundamentally wrong in my code. Is there any chance you could package in TDM-mingw's code or something or have a 64-bit version of the distro with all the 64-bit libraries as a download option with a big-honking disclaimer "SLOW EXCEPTIONS WARNING" so that I have the freedom to choose?
As far as I can see, portable Msysgit provides a full working version of MSYS (along with Git). You would have to create an 'fstab' file in C:\MinGW\git\etc and edit it to read 'C:\MinGW\ /mingw' (for some reason, this is missing in the portable version). 
The truth is that C++11 is pretty new. There aren't a whole lot of resources that incorporate C++11 features yet. Your best bet is to use existing books and then glean what you can from the C++11 FAQ, various videos from conferences, and questions from StackOverflow. [Here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) is a StackOverflow question on good c++ books. It's probably a good starting point. Anyway, check out [this comment thread](http://www.reddit.com/r/programming/comments/q7yd2/bjarne_stroustrup_c11_style_video/c3vn00r) too. Someone else had a similar question.
I remember checking your mingw page a while back, and seeing a 404 error. I was afraid you had decided to stop. :) Have you thought about including clang? I know others have compiled it for mingw, but I've not had any luck finding a recent build of it.
&gt; I have yet to see a compiler that gives a damn I would actually love to see a compiler that offered a debug option of asserting or something if you tried to dereference null.
x64 is more than just memory: you get 8 extra integer registers, 8 extra FP registers and a more efficient calling convention.
By the looks of it, iostreams benchmarks are done with `std::stringstream`, so actual IO performance shouldn't matter. 
Be afraid? Compiler vendors are allowed to define UB, and I'm pretty much sure that MS/gcc/Intel/etc would lose a bunch of their users if they suddenly decided to redefine "useful" cases of UB (e.g., "invalid" pointer arithmetic) to do something useless.
&gt; Compiler vendors are allowed to define UB That's fine *if* you also test for being on one of those platforms. 
It's pretty easy to build on Windows with [Mingw](http://nuwen.net/mingw.html) (gcc 4.7). * You have "C:\fastformat" * You have "C:\stlsoft" * set "FASTFORMAT_ROOT=C:\fastformat" * set "STLSOFT=C:\stlsoft" * cd "C:\fastformat\build\gcc34.win32" * make build (Get stlsoft from &lt;http://www.stlsoft.org/&gt;) Then, in the "C:\fastformat\lib" directory, rename: fastformat.0.core.gcc34.debug.lib fastformat.0.core.gcc34.lib fastformat.0.core.gcc34.mt.debug.lib fastformat.0.core.gcc34.mt.lib shwild.0.ff.gcc34.debug.lib shwild.0.ff.gcc34.lib shwild.0.ff.gcc34.mt.debug.lib shwild.0.ff.gcc34.mt.lib xtests.0.ff.gcc34.debug.lib xtests.0.ff.gcc34.lib xtests.0.ff.gcc34.mt.debug.lib xtests.0.ff.gcc34.mt.lib to: libfastformat.0.core.gcc47.debug.a libfastformat.0.core.gcc47.lib libfastformat.0.core.gcc47.mt.debug.a libfastformat.0.core.gcc47.mt.a libshwild.0.ff.gcc47.debug.a libshwild.0.ff.gcc47.a libshwild.0.ff.gcc47.mt.debug.a libshwild.0.ff.gcc47.mt.a libxtests.0.ff.gcc47.debug.a libxtests.0.ff.gcc47.a libxtests.0.ff.gcc47.mt.debug.a libxtests.0.ff.gcc47.mt.a or something cleaner like: libfastformat.debug.a libfastformat.a libfastformat.mt.debug.a libfastformat.mt.a libshwild.debug.a libshwild.a libshwild.mt.debug.a libshwild.mt.a libxtests.debug.a libxtests.a libxtests.mt.debug.a libxtests.mt.a and place them in the mingw "lib" directory. Then, put the folders that are in "C:\fastformat\include" in your mingw "include" directory. Then, put the folders that are in "C:\stlsoft\include" in your mingw "include" directory. Then, with tester.cc: #include &lt;iostream&gt; #include &lt;fastformat/fastformat.hpp&gt; #include &lt;fastformat/sinks/ostream.hpp&gt; using namespace std; using namespace fastformat; int main() { fmt(cout, "{1}zam{0} {2}\n", "bam", "zip", 8675309); } g++ -Wall -Wextra tester.cc -o tester -O3 -s -lfastformat See &lt;http://www.fastformat.org/documentation/index.html&gt;.
Pointers and size_ts are also twice as large, consuming twice as much memory (and more importantly, cache). In general, x64 doesn't significantly affect performance.
I have no interest in such things (i.e. simulating a Unix environment on Windows). You're welcome to use my distro as a starting point for your own modifications, though.
Computationally demanding tasks are faster, e.g. H264 (~10%). Cryptography is WAY faster. Pointer size is relevant if you use lists or trees, but they thrash the cache anyway.
I remember reading about a bug once where it was something like int* x = &amp;p-&gt;a; if (p) int y = *x; The optimiser got rid of the check, because according to the standard once you've dereferenced a point it can't be null. This caused a hard-to-find security bug. But I'm not sure: does reading from a near-null address cause access violation?
What this guy said ^^^. Changing it to an "int" works, but likely returns garbage--it didn't crash because an "int" doesn't give a shit about its own internal state, but a string very well might. 
I'm pretty sure what he's trying to do is pass the arrays back, and the 3 is there to tell the size. OP, it doesn't work like that. If you're passing back an array you can pass back a pointer. If you want to pass back 2 arrays, well... you don't. You can only return one thing. As bloodandiron mentioned, you can return a pair or something to that effect. This probably isn't the best way to do it. Maybe you should pass the arrays into the function instead of trying to create them there and pass them out. Yea, looking a bit more, this has a lot of errors in it. Can you perhaps describe why you're doing it so we can provide some guided answers?
Do you have any interests? It might help guide people to better sources for you. I'd say just start making whatever it is you want to make. When you get stuck, ask for help. Try to read articles or look at other code so you can see where you might be doing things inefficiently. Reading design books can really help you make good design decisions. Edit: sorry for posting twice. I didn't have time to give a very elaborate post earlier, and I wanted to make sure you didn't miss the added info.
I'm amused most by the assertion that an objectively better piece of software will become more popular. I assume that this is in some theoretical world, of the sort inhabited by spherical horses and isomorphic point sources, as the history of this world repeatedly demonstrates that being first to market with crap and marketing it ferociously wins. But as to a disproof: "Facebook". Despite my personal abhorrence, it counts as "software that matters" by the standards set forth and is not written in C++. 
Actually, while Facebook is written in PHP, for production this PHP code is translated to C++ and then compiled to native code. So while strictly speaking you are correct (it is originally written in PHP), what people are using was re-written to C++.
Programs written in assembler can be faster, that stands, but most of the time it isn't. Writing assebler code that is faster than what the compiler with all optimizations is able to do requires *a lot* of knowledge which differs for every platform. People with that ammount of knowledge are usually not in your company, but have a very nice living of making compilers :) One rule of thumb for performance computing is write in C/C++, optimize bottlenecks by going lower *if* you know what to do.
Use vectors instead of arrays when writing C++. Will help you fix this crash and make you a more happy C++ programmer in general. :-)
Like I said, a debug option. In fact, initially I would imagine it would be an option you would have to explicitly enable, even for debug builds.
A lot of higher level languages compile down to C or C++. You can't count them as being "written in C++." They were not, they were *compiled* with C/C++ as an intermediary. This is a HUGE different.
The argument is the same. You can forgo the domain knowledge needed to write efficient C/C++ code by writing in a higher level language. At some point in time it will be the case that only extreme experts can consistently write C code that is faster than a compilers. That time may not be now, but it is still the case that the time saved using a higher order language can outweigh the performance gains of using C. People working in higher level languages use the exact same rule of thumb you just described: they write bottlenecks in C if they know how.
Dude, I love C++, but this was bullshit. Why -I- write something in C++ is that it seems, to me, to have gotten the balance between the high-level and low-level ideas of programming just about right. You can drop down and squeeze out performance when you really need to, you can't structure and compose your programs on a very high level when you need to. And mix and match that as necessary. That and the fact that it is well-supported on all platforms and has a lot of people with at least some familiarity with it makes it a solid choice.
This, sir, is why 90% of all systems today are plain shit or have unbearable speed problems. People tend to prefer the "easy" software but forgot that speed DOES matter as clients tend to get grumpy when that system is taking 10 seconds to respond a simple request. C++ is harder to develop, yes, but this doesn't mean that it won't be maintainable. Shitty programmers make unmaintainable code, not the language. Alas, you can break even python when a bad programmer start messing around. Ps: I'm sure that the slow software you do on your financial institution is not that important. Otherwise it would be done taking performance as one of it's main goals. Period. Ps2: If it is that important, you guys are screwed
Thanks for your help
&gt; how awesome the F# programming language was the the language's creator What?
It's the "oh I really want to learn c++ but don't really have the time to, so I'll subscribe to c++ feeds to remind myself of it" syndrome? PS: I had time to learn c++ about 15 years ago so please don't kill the messenger.
Sure enough, [HipHop](http://developers.facebook.com/blog/post/358/) is a PHP to C++ translator. TIL, thanks. 
The problem is that the people on your team don't know the language well enough to work with it? Well, what if you have a bunch of Ruby coders on staff? They'll be completely lost when it comes to C++, so their code might be slower unless they use Ruby.
You have two main problems: 1. You are using while loops when you should be using if statements. 2. You are misunderstanding the syntax for comparison operators. Think about what you're trying to do. If you want to look at each character in a string and do some check on it, then you only need to have one loop. The loop will travel along the string checking each character at a time. You are attempting to do a comparison like: x == 1 || 2 || 3 This doesn't do what you think it does. You're reading it as "x equals (1 or 2 or 3)" when it's actually more like "(x equals 1) or (2) or (3)". The expressions "2" and "3" will always evaluate to true, so that above statement will always be true. What you're actually looking for is: x == 1 || x == 2 || x == 3 So change those 4 inner while loops to be if statements and think about what the comparisons should do. Also consider using an if...else statement, like so: if (counter == 3 || counter == 7) { ... } else { ... } Also recognise that a char is really just an integral type like a short or an int. The characters for '0' through '9' are guaranteed to have consecutive values. You could therefore check for a digit character by doing: if (character &gt;= '0' &amp;&amp; character &lt;= '9')
Our code is as fast as it needs to be, without sacrificing too much maintainability. Of course, we also have super-duper critical components that also need to run very fast, and those components ARE written in C and C++ (most notably, our transaction kernel, which is responsible for maintaining checking account balances in real-time synchronization with our payment transfer providers) It's that golden middle way, ya'know. That's also what I'm trying to point out; that making a blanket statement like this (only write critical software in C++, EVER) is a fucking retarded statement to make. &gt; I'm sure that the slow software you do on your financial institution is not that important. Otherwise it would be done taking performance as one of it's main goals. Period. Wrong, no fucking period! Code and data correctness are usually infinitely superior demands to "make it fast". Making sure your system is easy to understand and simply CORRECT is worth more money that saving an employee half a second of waiting time when he's working on a billion dollar deal. If shaving half a second off some operation means creating 2x the code, or making the code hard to understand... unless you have to make that operation a million times a day, is not worth it, **you must realize that?!** PS: since you mock my work it might cheer you up to know this: we also have some really fucking shitty code that is still responsible for about 250 million USD of revenue every year. It's 20 years old, partly written in C, partly in Delphi (the "newer" parts :), and that shit is a disaster waiting to happen.
&gt; Besides which modern C++ is a high level language. It's the one where you never write "delete", never call "operator[]", and always write "&amp;&amp;" in every function prototype.
I dunno, I like D. Ignoring Fortran, of course. Because I ran out of brain bleach.
No a language has a syntax and a grammer.
Also that is a stupid argument that a good python programmer can write faster code than a bad C++ programmer. A good native programmer should always be able to write faster code, the exceptions to this when object boundaries are crossed in the inner part of a loop, however Link Time Optimisation significantly reduced this problem.
Yes, and that applies to binary as well. You do realize that binary isn't just ones and zeros, it's the specific combinations you use to create instructions. There is a very specific syntax/gramm*_a_*r to binary, so it is definitely a language. Learn to use the "edit" button, by the way.
Many of them do use C as compile target, although not all of them: http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler &gt;The C-- code can then take one of three routes: it is either printed as C code for compilation with GCC, converted directly into native machine code (the traditional "code generation" phase), or converted to LLVM virtual machine code for compilation with LLVM. " http://en.wikipedia.org/wiki/Common_Lisp#Compiler_and_interpreter &gt;Depending on the implementation, the file compiler generates byte-code (for example for the Java Virtual Machine), C language code (which then is compiled with a C compiler) or, directly, native code. As for parallels for the rest of the argument, look at scientific python. All the core high performance parts are C libraries and python itself is mostly used for data pre and post processing. I've seen the same sorts of setups with languages on the JVM using C libraries for core routines.
You are assuming I was making a blanket absolute no-where-in-the-universe-such-a-thing-happens statement. I was not. In day to day practical terms, what I said continues to be true. &gt;I've seen the same sorts of setups with languages on the JVM using C libraries for core routines. The thread was about dropping to asm level in C++ if you need to - Because asm is what C++ basically compiles to. This is not the case with other high level languages. They do not compile down C or C++. Thus "lower" or "higher" in the abstraction chain here doesn't make any sense because the languages would be completely different. 
This article gives dangerous advice. Chris Lattner, from llvm/Clang, wrote a really great 3 part article on undefined behavior. The short of it is, the optimizer is allowed to assume that the code never ventures into undefined behavior, which is important for generating fast code. This can make it do really crazy and unintuitive things that look like compiler bugs. There are a couple examples in the article that speak to what kinds of issues could be caused by having null references. http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html
Yeah, the guy ( Josuttis ) doesn't think much of c++ these days. I pre-ordered the book anyway because I think he is a pretty good author. I find his books ( despite being translations ) more readable than Stroustrup's. 
 // derived.cxx // derived::~derived () = default; That's cute, but... why not, in the CPP, do derived::~derived() {} ? Maybe they're trying to make C++ more readable.
I believe = default is intended mainly for using with the other operations, e.g. copy constructor. [Link](http://www2.research.att.com/~bs/C++0xFAQ.html#default) BTW, defining with the declaration implies inline.
There is [std::advance](http://msdn.microsoft.com/en-us/library/yw08h3s8%28v=vs.71%29.aspx), but it looks like you specifically want to go byte by byte, so that won't help. Since the STL is all about type-safety, I'd guess that you won't find a standard helper-function that will do what you want.
I can't think of *any* type-safe way to do what you're trying to do. Unless `n` is a multiple of `sizeof(T)`, there's no guarantee that the resulting pointer can safely be cast to a `T`-pointer. And if `n` *is* multiple of `sizeof(T)`, why not just say return p + (n / sizeof(T)); There's no need to reinvent pointer arithmetic. One thing I can recommend is using C++ style casts, if only just to drive home that what you're doing is potentially unsafe: return reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;unsigned char *&gt;(p) + n); Using a reinterpret cast makes it clear that you're casting between unrelated pointer types.
Currently slated for end of the summer, but I'm sure [Lippman's 5th edition of "C++ Primer"](http://www.amazon.com/Primer-5th-Edition-Stanley-Lippman/dp/0321714113) (not to be confused with Prata's "C++ Primer Plus") will be very good. Looks like it's scheduled for end of the summer. I was hoping Lippman *et. al.* would put out a new version for C++11, but I wasn't sure until I saw it mentioned recently here on reddit.
What makes you think your code is any better than the original one? You are allowed to alias any data with a char pointer, so I don't think there is any aliasing violation in the original code. Even if there were, doing the cast from T* to char* using bitwise_cast wouldn't solve anything.
Technically, assigning to one union member then accessing a second (without first assigning to that second one) is undefined behavior (with exception if the union contains POD-structs with common initial sequences, one of which is "active" and you are accessing only other such struct members). Granted, pretty much every implementation handles it "correctly," but that doesn't mean it's valid.
In order to believe C++ code is as safe as any modern language one basically has to make to word so ambiguous to lack useful meaning. It's just so easy to write unsafe code. You don't even need to use "unsafe" language constructs, consider a class holding a const reference to something that turns out to be a temporary. Simple mistake to make. 
Qt is a monolithic framework. It is just their style to have their own implementation of *everything*.
What you are saying is different from what Sutter said. He said "modern C++ is safe ... as any other modern language"
I completely agree on using the proper casts it would make this code easier to read for sure.
I agree about pointer manipulation in C++, however it is still needer for handling binary files where the data is loaded into a char buffer of some sort.
And that is precisely why I hate it!
This is relevant to my interests. For a while I've been thinking about rolling my own logging framework, with the following features: * Filters on severity, anything not requested is compiled out * Provides profiling functionality * Logs on a per-process.per-thread basis, to avoid multi-threading issues * Capable of piping logging info to a separate process responsible for the "heavy" lifting (e.g. disk IO, timers, etc.) This would be an attempt to keep logging from slowing the main application down.
Yeah I was thinking about being able to log to some kind of off-the-shelf in-memory DB or something -- mostly because of the kinds of profiling statistics I want to be able to gather from the logs. After-the-fact parsing is probably too slow with text files.
[John Torjo loves logging](http://torjo.com/). Boost Log v2 is his project.
I dont think that cleanup belongs in a logger. That's a batch job. Log rotate is a great idea (I have written a logger before) and make sure to have support for both small and large files (larger than 2G). Have you looked into [log4c](http://log4c.sourceforge.net/) ? I haven't used it but I have used log4j as well as slf4j.
It seems to depend on the implementation. I've run a few servers that maintain and roll their own logs (Nagios for example will roll it's records based on the configuration settings). On the other hand apache relies on the logrotate functionality of syslog, at least in redhat systems.
Ha, fair enough. I wouldn't have known at all but they both came up in my initial searches for atomic loggers. I assume both are fairly capable loggers overall, it looks like the Semashev one has a 'trivial' mode which might be a good place to start at the least.
Oh, look. It's Marius Bancila.
Too bad the IDE interface look like hammered shit. Whomever MS has hired on to revamp their product UI needs to be fired.
For a whole three sentences in a two and a half thousand word article. Wow.
In that case, the people who hired a few dozen people across multiple committees to design this shit should also be sacked.
Not all applications are CPU bound, my friend. Believe it or not, there's more to software than games, video encoders/decoders, drivers, OS's and embedded applications. A large, large portion of software is I/O bound - waiting for the database, the network, etc. This "OMG SPEED IS EVERYTHING" mentality that is the disease of C/C++ programmers, is *precisely* why they're being ignored and why so much software is now written in Ruby/Python/Java/C# and yes, even PHP. The right tool for the right job. I pity those who only know/use one tool. I'm sorry, but to me, there's no such thing as C++ in the real world. Real C++ exists in textbooks. The real world is a vomit pile of raw pointers, "Johnny's dynamic array class cause he didn't know about std::vector", "exceptions are weird", "what is RAII", "Just use Qt, it re-implements everything", "We are not sure how this new-fangled Unicode stuff works, std::string is good enough for everyone" and other nonsense. What *century* is this again? There is C++ the way it's evangelized by Herb/Bjarne/etc, and then there's C++ the way it's written by amateurs. And I'm sorry, but, combining multiple schizophrenic pieces of said amateur C++ libraries into something useful is a waste of my time when my client needs something delivered *fast*, *and* when Java/C# performance is more than sufficient. 
There's not a single C++/CLI specific line of code in the entire article.
strongly typed enums are so welcome! having to write namespaces for my enums is so annoying and ugly. it isnt the biggest feature in c++11 but its a very welcome change.
If the cpu doesnt support atomic operations for that size(or atomic operations period), then it will use a spin lock instead.
No, there's a specific "grammer" to an instruction set. Binary is a number (or numeral) system. It's not a language, because you don't know what it is meant to represent unless you are given another context, which is "this is a binary encoding *for* instructions for the FooBaz instruction set implemented by the BarGlok CPU". 
They might. But, an equally brilliant C++ programmer should be able to write a faster implementation in C++. It matters in very few cases, but when it matters, it can matter a lot. 
I read and write binary *every day* that has nothing to do with instruction sets. If you're writing even a modest C/C+ app., chances are you're using bit-flags somewhere. 
Well pretty clearly, that doesn't fit in our definition of language; you're simply using a different form of integer to do your job. That doesn't change the fact that people who write in binary to program are using a language.
Also see a discussion thread on Hacker News: http://news.ycombinator.com/item?id=3815451
You need to review what the comma operator does.
P.S. For find such errors, and many others, I recommend using static code analyzer tools. I suggest to try PVS-Studio :) http://www.viva64.com/en/pvs-studio/
Thanks, I had my suspicions about the commas. I was just going out on a whim and guessing what they would do.
[/r/reviewmycode](/r/reviewmycode) is perfect for this :)
As a rule, don't guess what operators or any other language constructs do.
One more that I've seen a few times, probably done myself in the past and is incredible hard to find because it might even work for very long: Keeping references to std::vector elements and not realizing that even adding elements behind the referenced element can wreck your reference due to reallocations. 
 void multiply(int x, int y) { using namespace std; cout &lt;&lt; x * y &lt;&lt; endl; } int main() { int x = 5; std::cout &lt;&lt; multiply(x, ++x); } It should catch this one ;)
I know I've looked before, but I can't remember: does this run on Linux? If not, any plans to? Also, how does it compare to Coverity?
1) You don't really want to track those cells distinctly. Arrays let you say "I need nine of these" and then reference them by number. 2) You then don't need those big hand-drawn blocks of "if it's this then this". nChoice becomes the cell index in the array.
Do you have any idea what I'm supposed to use instead of the commas?
Yep, -Weffc++ is extremely valuable. It won't directly catch uninitialised members, but it will force you to always initialize them, so you can never end up with an uninitialised one. Only downside to it is that you will need to fix your code a bit before you can get a clean compile with -Weffc++, as it will enforce "best practices" even in places where they wouldn't be needed. My recommendation, start with: -ansi -pedantic -Wall Once code is clean for that, add: -Weffc++ -Wshadow Also worth a try is: -Wconversion But that forces a lot of casting, so might not be to everybodies tast, but it does catch a bunch of bugs. Also worth to note: -Wno-unused-parameter That disables a bunch of useless warnings caused by -Wall. And if that isn't enough, use valgrind and stop using delete, with scoped/smart pointer there is almost no reason to ever use a manual delete.
1. Applicable to C as well, with GCC use -Wuninitialized to catch these 2. Applicable to C, with more recent GCC use -Wconversion, MSVC had them for a long time, enabled by default ("warning: loss of precision") 3. GCC definitely warns about this one ("Warning: suggest parentheses around assignment used as truth value"). Forgot what warning option is needed. 4. Use -Wconversion 5. Yep, this one is valid, as there is no way for the compiler to tell what the pointer represents without knowing the context it was allocated in. But if you use raw arrays for memory management and shoot yourself in the foot, you get what you deserve. 6. This is a nasty one, some static analyzers catch it, not sure if compilers do. 7. No objection here. 8. This "feature" (and #7 as well) is done exactly by the C++ spec. I guess if you are the language lawyer, you can say "aha, it's your own damn fault for not reading the standard", but a compiler probably ought to have a warning for this similar to MSVC's "using `this` in initialization list". TLDR: modern compilers catch most of these just fine. Did I miss anything?
I believe clang will catch most of those errors with -Wall
These are the second worst (worst are multithreading bugs). C++11 will add more of them ([example](http://stackoverflow.com/q/7764564/23643)). Good luck debugging a crash caused by a dodgy move assignment operator when you sort a vector of objects!
I don't even see that as a problem. Forcibly discouraging deep class hierarchies is a good thing. Composition is a better solution. 
Novice c++ guy here, can you clear up for me: is holding on to a particular entry in a vector, if you're modifying the length of the vector, unsafe? Just making sure I understood what you said... Edit: grammar
&gt; I know I've looked before, but I can't remember: does this run on Linux? No. &gt; If not, any plans to? In the nearest time - no. FAQ: [1](http://www.viva64.com/en/b/0132/#ID0EOFAE), [2](http://www.viva64.com/en/b/0132/#ID0ENTAE). &gt; Also, how does it compare to Coverity? We can not make such a comparison. They do not give trial. :) I can tell you one thing. We are simpler, but much cheaper.
Correct. If the vector grows past the size of its internal array, it will allocate a new (larger) array and move the contents over. This means any references and iterators will no longer be valid.
hello, string flip(string s) { reverse(s.begin(), s.end()); return s; } int main(int argc, char** argv) { vector future string v; //no &lt; and &gt; because reddit cant type them v.push_back(async([]{ return flip("olleh"); })); v.push_back(async([]{ return flip("dlrow"); })); v.push_back(async([]{ return flip("pu stahw"); })); for(auto&amp; s : v) cout &lt;&lt; s.get(); cout &lt;&lt; endl; return 0; } i can compile that code just fine on mingw builds with gcc 4.7 but with your distro it gives me std::__async_sfinae and std::future as incomplete types, is there something im missing? EDIT: the builds i use that compile this code fine are from here: http://code.google.com/p/mingw-builds/ but i would much rather use your distro since it includes boost already.
you might want to try rewriting statements like if(cSquare1, cSquare2, cSquare3 == "O" || cSquare1, cSquare4, cSquare7 == "O" || cSquare1, cSquare5, cSquare9 == "O" || cSquare3, cSquare6, cSquare9 == "O" || cSquare7, cSquare8, cSquare9 == "O" || cSquare7, cSquare5, cSquare3 == "O" || cSquare4, cSquare5, cSquare6 == "O" || cSquare2, cSquare5, cSquare8 == "O") like this: if((cSquare1=="O" &amp;&amp; cSquare2=="O" &amp;&amp; cSquare3 == "O") || (cSquare1=="O" &amp;&amp; cSquare4=="O" &amp;&amp; cSquare7 == "O") || (cSquare1=="O" &amp;&amp; cSquare5=="O" &amp;&amp; cSquare9 == "O") || (cSquare3=="O" &amp;&amp; cSquare6=="O" &amp;&amp; cSquare9 == "O") || (cSquare7=="O" &amp;&amp; cSquare8=="O" &amp;&amp; cSquare9 == "O") || (cSquare7=="O" &amp;&amp; cSquare5=="O" &amp;&amp; cSquare3 == "O") || (cSquare4=="O" &amp;&amp; cSquare5=="O" &amp;&amp; cSquare6 == "O") || (cSquare2=="O" &amp;&amp; cSquare5=="O" &amp;&amp; cSquare8 == "O")) 
I can see your web designer was highly inspired by apple :/
For a open source alternative, the Clang static analyser is actively improving its C++ analysis support. http://clang.llvm.org/ http://clang-analyzer.llvm.org/
&gt;any references and iterators *may* no longer be valid. The real issue with this bug is that the reallocation isn't always in a different spot, so the problem sometimes never shows itself and your program will go along happily working for a time.
&gt; Qt Quick allows developers to construct distinctive interfaces with arbitrary graphical assets, fluid animations, **advanced touchscreen support**, and greater interactivity. Browsers need these features, not the damn desktop. &gt; A new canvas module provides a generic painting surface in Qt Quick with JavaScript APIs that are modeled after the ones associated with the HTML5 Canvas element. There is also a module for drawing 2D particle graphics. Motherfucker. Why not USE canvas? I guess it's time to meet Krapi, your new cross platform javascript rendering toolkit. Ninja edit: Krapi (K-desktop rendering API)... But good luck, Qt guys, this is a meritocracy after all. May the least fucked up shit win.
Your post, clearly worded, with each sentence crafted for MAXIMUM impact, was appreciated by me. This being reddit, you can expect the downvotes to commence shortly.
Coincidentally why many prefer to iterate over an `std::vector` using an index instead of iterators.
Are commas supposed to mean "and"? The correct syntax for that is &amp;&amp;. Also, you have to write the other side of the condition for every single variable, for example "if(cSquare1, cSquare2, cSquare3 == "O" || ...) should be "if (cSquare1 == "O" &amp;&amp; cSquare2 == "O" &amp;&amp; "cSquare3 == "O" || ...)" Secondly, the "else" statement can be used after an "if" statement for code that should run if the condition inside your if is false. For example, "if ( &lt; x has three in a row &gt; ) { &lt; say player 1 wins game &gt; } else { &lt; say player 2 wins game &gt; }" with the words inside the &lt; &gt;'s written as code.
If you post a link to an article, please keep the original title. There is no point in being journalistic to the point of being completely wrong. Qt is and always will be a C++ library. The fact that you can create UIs in QML (instead of .ui XML files) and to write QML+JavaScript (instead of being limited to defining simple signal/slot connections in the .ui file) doesn't mean C++ is going away. It means that you can (and should) write main application logic in C++ to achieve the performance, and to wrap that up with QML if it is your cup of tea. If not, you can stick to pure C++/Qt.
You probably want to use `stable_vector` instead: http://www.boost.org/doc/libs/1_49_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector
I was writing a constraint solver in C++ a couple years ago, and this tripped me up for the longest time. My parser would fail half the time and succeed the other half. After tons of debugging, I finally tracked it down to a vector issue and did some substantial googling. Luckily, my implementation allowed me to use std::deque without any adverse side effects to complexity, so I just had to switch a couple of declarations, but the days spent tracking that down were a total PITA.
std::deque might also work, pending on how you typically use the container (i.e., limited random access).
thanks that's quite clear
mis leading title. its not moving away from C++.
Probably the biggest one I still see is people using pointers, new, delete and pointer arithmetic. It's not the 80s people!
Send me [email](http://www.viva64.com/en/about-feedback/) and we discuss it. Practice shows that 90% of people who speak about the discount, then do not buy, when we offer him the price. :)
Tumbleweeds....
Yeah but a vector of pointers is an even worse hell. 
You are a true modern journalist, hideously wrong, yet you defend your position as one part absolutly correct, and one part opinion. Have you considered cable news?
From commercial pov, Qt Project doesn't have enough influence (like some other companies mentioned in the comments below) to make people jump around from technology to technology. From a developer pov (a long time KDE dev here :) ): QML and JavaScript are the new cool way of doing UIs. Qt is *much* more than an UI library. You will not write data models, networking code, etc. in JS, you will write it in C++. Heck, you are not even advised to write more complex QtQuick components in QML/JS but in C++. The fact that QML widgets are private classes is unfortunate, but there is a technical reason behind that - no need to maintain ABI for them, and Qt's introspection is sufficient for managing (and creating) instances of those classes from C++ code. Not a pretty way, but you could always write a binder class for that. One of the reasons why Qt5 happened in the first place was that a few things needed to be done, which needed to break ABI do be done right. QWidget library is in the maintenance mode, at least if it don't get a maintainer that wants to continue to develop new things for it. Maintenance doesn't mean 'dead'. QWidgets are quite powerfull as they are now, which is proven by the sheer amount of applications using them. Cheerio! p.s. Qt5 will even support some C++11 feats.
Have you ever worked on an architecture which requires data alignment? You can treat memory as a dumb array of bytes, but you can't treat arbitrary subsets of that array as other types.
C++ applications (Graphical or otherwise) are always more responsive than there managed counter parts (like .net )WPF/winforms) and java swing and are a whole lot less bloated in terms of memory consumption. The question that interests me is whether a UI that relies heavily on JS for it's UI glue will have performance characteristics closer to native code or managed code. Given that most of the JS I imagine will just hook the C++ QT backend. I imagine it will be somewhere in between.
I disagree, that extension from Apple to C seems mainly to exist because Apple doesn't like C++ at all. C should be super simple language made out of primitive constructs. Stuff like lambdas is firmly in C++ territory.
There is a difference between "not liking C++" and "liking C". Pretty much all of Apple's OS code is written in C (with ObjC kits on top). It makes sense for them to want to extend C, especially in the context of Grand Central Dispatch/libdispatch.
No I think Apple don't like C++, and why would they it was really MS's hobby horse especially it the 90s and again now. They also inherited a big ObjC code base from next step so it made sense to keep it and back a different horse to differentiate themselves. I am glad that lambda's aren't in C, I like C because it is so simple and quick to learn, yet is arguably one of lightest weight languages to use. I don't see the huge interest in giving every language the same feature set it just seem to water down the differences in languages. Finally whilst most major compilers haven't even finished implementing C99 I don't think they should be added any new major features to the language, personally if I am writing C it is usually because I want really really good cross platform support in which case I will just use C89. If that isn't such an important requirement then I will use C++11.
Fix the design, unless you are very late in the development process and about to release. The problem with these flaws is that they will keep biting you and anyone else that works on the code, resulting in a lot of wasted time. 
It isn't Microsoft language, as you know, but it was the language of choice for MS both for internal use and as the primary systems programming language they encouraged in the 90's, they own and maintain the primary C++ compiler and IDE for windows. In the 90's it was that or VB (and you sure as hell didn't want to sue VBmicrosofts6). I dislike MS's extensions to C++ every bit as much as I dislike apples extensions to C. And I dislike both companies in equal quantities. Incidentally this has nothing to do with the fact I am glad lambda's aren't in C.
Yeah, I agree that iterators are a great invention, and should be preferred, especially with the new C++11 foreach syntax. :) In the case of `std::vector`, I guess the real problem is the fact that iterators are invalidated by `push_back`/`insert`. Instead of a pointer to the direct data, it would be just as fast to implement them in terms of a pointer to the `std::vector` and an index, and that would make them stable across `insert`. I.e., instead of: struct iterator { data_type* current; }; it could just as well have been: struct iterator { container_type* v; size_t current; }; That could also potentially raise an error if iterators from different collections are compared, which is always a bug in the case of `std::vector`.
Curious, I get these results with Clang 3.1 (x86-64, -Os -std=c++11 -stdlib=libc++): * original iterators: 0.488 seconds * new iterators: 0.610 seconds Even more curious, if I rewrite the code to not use this weird `end_iterator` thing you introduced, I actually get *slightly better* results, and I'd say my code is simpler. [Here's the code](https://gist.github.com/ef296936266deb4633f7). * original iterator: 0.488 seconds * new iterators: 0.448 seconds I would be interested to know if you see the same difference in performance using MSVC. I'm still confident that I wouldn't lose money here. ;)
I see your point. Coincidentally, though, this design has the drawback that it can't easily represent a "nil" iterator, so algorithms like `std::find` don't work.
These were very entertaining exercises. I had no problem following through all of the parts. Thanks for sharing!
Assignments yes, but you can't nest declarations inside expressions like that. The predicate can either be an expression (e.g. A &amp;&amp; B) or a declaration (e.g. "Type Id = Exp"). 
Damn, okay thx. The best thing I could come up with was a goto: if (CallInst *Call = dyn_cast&lt;CallInst&gt;(&amp;*I)) { Function *CalledFunction = Call-&gt;getCalledFunction(); if (!CalledFunction) { goto no_call_or_no_called_function; } ... continue; // We are inside of a loop and don't want to execute the no_call_or_called_function code. } no_call_or_called_function: ... If anyone knows a better way please let me know. EDIT: Wait I think I didn't read your answer. You mean I can declare Call and CalledFunction first and then assign them both in the predicate expression? EDIT2: Wow, it works! Great! Thank you very much!
Been a while since I MFC'd but the general explanation of how they work is as such: When you create something that is to receive messages (a window, typically), you register it with the operating system. You give it the address of a function to get called whenever a message is sent to that window, and it gives you a handle to serve as an identifier for the window (the HWND). This is straight Win32, no MFC yet. Since you just have a normal C-style call-back, making it object-oriented is a little more of a challenge. So MFC builds the call back function for you, out of a bunch of macros that the various Wizards helpful fill out for you. All that magic going on can be done manually, but using the wizard saves a lot of typing. The message maps really are map data structures that, instead of using a big bunch of switch or if statements in the message handling function, Look up method pointers in a map data structure. So whenever a message is passed to your window, the message handling function looks up who should receive it via the message map, and the proper function is called. One important thing to know is that if you post a message, the message you post goes at the end of a queue of posted messages, and waits its turn to get processed. But if you send a message, the message map is gone to immediately, and the sender waits till the recipient finishes before continuing (like a regular function call).
Why not perform the declarations and assignments outside of the if statement? It's less compact, but much easier to read and definitely possible.
i was hoping more details. "One reason Facebook is shifting more work to C++ is to reduce operating costs such as power consumption per user." thats only one reason and it doesnt even go into detail about it :\
"Oh my gosh, they mentioned our language in this blog post you guys." It's *five sentences long*. The mention in the video is maybe *two sentences*. This isn't relevant!
From http://www.webtoolkit.eu/wt/blog/2009/12/17/facebook__php__is_not_very_kopenhagen it seems I was way off: according to Facebook benchmarks, C++ performance is 50:1 versus PHP :-O 
To me it's the first hard evidence that I've seen, that Herb Sutter's (&amp; Microsoft's) idea that a C++ renaissance is coming, for this very reason of energy consumption (&amp; maybe others). It does remain to be seen how much smaller installations, ie the rest of the world, will be affected though. 
much cleaner in my opinion: if (CallInst *Call = dyn_cast&lt;CallInst&gt;(&amp;*I)) { Function *CalledFunction = Call-&gt;getCalledFunction(); if (CalledFunction) { ... } else { ... } }
i know power consumption is lower, but i was expecting actual data to back it up, and to see real world numbers for comparison, thats why i made my previous comment. also more reasons, he says "one reason was for power consumption" fine. what about other reasons? not only reasons but actual details about those reasons. the same thing you dont go to your boss and say "we should change our infrastructure to c++ because theres several good reason and it lowers power consumption". you need actual data to back it up, especially on facebook case where the change should cost thousands if not millions of dollars, its not a change you take lightly without enought study to see if its actually worth it. that was the data i was looking for.
The problem with your solution is that you would have to replicate the code in the else block twice because in the case Call is NULL it should be executed too.
The problem was that Call could possibly be NULL. In this case you couldn't call getCalledFunction() to perform the second assignment.
I believe you're looking for std::plus&lt;T&gt;, std::multiplies&lt;T&gt;, etc. in &lt;functional&gt;. Additionally, your foldr() is a less general version of std::accumulate() in &lt;numeric&gt;. (It's one of a few "generalized numeric operations" that are hiding in that header instead of &lt;algorithm&gt;.)
Well this would also do the trick. The rest is just a matter of style. &gt; Also, what's the deal with dereferencing and then taking the address of I? You are right, it looks like it isn't necessary to do this here. I've just done it this way because it was necessary when casting an llvm::Function::iterator to int64_t and I assumed it would also be necessary when dyncasting an llvm::BasicBlock::iterator to CallInst. It worked so I didn't hesitate to go on. 
You should be a novelty accountâ¦
You are right about accumulate, I was thinking about allowing different types of structures, but I ended up deciding to go with only vectors. This and not passing iterators lets me enforce a functional style. I think that &lt;functional&gt; is slightly different from what I need. For example, suppose I have defined `Matrix operator* (const Matrix&amp; A, const Vector&amp; x)`. It would be ideal to be able to apply a multiplication to each Vector in a list like this: out_vectors = Functional::map(bind(operator*, some_matrix, _1), in_vectors); Here, the two arguments of `operator*` are of different types and it is conceivable for the output to be of a third type as well.
You can't *not* use pointers. Pointer arithmetic is also irreplaceable. The fastest in place sorting algorithms use them. Smart pointers remove the requirement for delete, not new, so you still have to do that.
Where is the 50:1 figure from? I can't watch the talk right now, but the [linked talk summary](http://idleprocess.wordpress.com/2009/11/24/presentation-summary-high-performance-at-massive-scale-lessons-learned-at-facebook/) doesn't mention it either.
Ah, I remember this [from over a year ago](http://www.reddit.com/r/programming/comments/dujlm/mozy_releases_mordor_a_c_library_for/) when I went for the easy jokes. I'm glad to be reminded as I may actually have use for it with an upcoming project.
I can't present a benchmark, but in my experimenting, QtQuick was pretty darn fast. It is also evolving to rely on the GPU if present, there are demos out there that utilize shaders with an amazing performance.
It's just a typedefed shared_ptr
Why hide the actual type name?
Thank you very much for taking the time to write this up. This was very helpful. I will be referring to this as I decipher the 24 year old program that has no documentation I am just beginning to work on.
 &gt;Iterators are a way of traversing a data type linearly. There are many different types of iterators. The ForwardIterator and BidirectionalIterator concepts work as you say. The RandomAccess iterators allow offsetting similar to pointer arithmetic. Vector iterators are RandomAccess. &gt; They aren't comparable to pointers. For instance, I think it would be hard to rewrite this code to not use a pointer: You should use std::max_element to find best_card. No pointers necessary, and much clearer what you're trying to do. (incidentally, you also probably should be checking that m_hand is not empty, that code will crash in that case) Any time you're manually iterating over a collection, there's almost always a better STL algorithm for it. &gt;If I use a smart pointer it will free the thing it points to when the function goes out of scope... Yes. You generally shouldn't use shared_ptr unless you need logically share ownership of Ann object. Polymorphic objects can also sometimes make then necessary. Most of the time, though, stack semantics are typically far superior. &gt; If I used a vector&lt;&gt; the only difference is I'm holding an `int` not an `Card*`. In this case, `int` is _less_ descriptive that it aught to be so should not be preferred for example over the use of a pointer. Not quite sure what this is referring to, I'm sorry.
I tried to read your code but it looks like you accidentally left your opening brackets on the incorrect line.
I see you're trying to start a style war. 
haha yeah, I'm bored :)
Thanks for your help. The reason my code didn't work is because the compiler couldn't determine which version of the function was being called at the time of template instantiation. To solve this, I had to cast the function pointer to it's appropriate type. So for my previous example: out_vectors = Functional::map(bind(Vector (*)(const Matrix&amp;, const Vector&amp;) operator*, some_matrix, _1), in_vectors); Also, you can call non-static functions just as you do static functions. Non-static functions have an implicit (this) parameter which you need to pass in addition to other parameters though. 
If your project is slowing down because of virtual calls, you might be doing it wrong. 
Well, seems I have a new trick to use if the need ever comes up. This is one of those things you arn't going to find documented so my conclusion was based off a series of tests I did, but I never tried that. Thanks for letting me know.
SDL, it's a C library but it does all these things.
SDL is pretty good, but it's rather low-level. For example, you have to code your own set/getpixel functions, although it's not too hard. It was also programmed in C, which is of course usable in C++, but it doesn't take advantage of any new C++ features. Although some projects like SDL++ provide a C++ layer for SDL. I would recommend SFML. It makes things a little easier and was designed with C++ in mind.
I would go with Allegro since it's simple to use. Although I don't know about displaying thousands of objects on screen (haven't tried it), It will let you do all the things you've listed. The forums are also pretty active, so you can get help for it pretty easily.
Why not Qt? It is straight forward ( though quite large ), cross platform and has full core libraries for networking, threading, etc. Also doing the image drawing using an openGL QPainter would likely be faster than in 2D. 
&gt;SDL is slow. It is? I've never heard that and several games are written using SDL. Not that I don't believe you (seriously) but could you either elaborate that or provide some links? Thanks.
SFML is quite similar to pygame.
I suggest this guy is a bit out of touch if he thinks it's a new idea to write device drivers in high level languages. I've been writing drivers for 20 years in c &amp; C++. The last assembly driver I wrote was for DOS in 1991 ! Linux kernel drivers? C Windows drivers? C &amp; C++ Embedded (RTOS &amp; non RTOS) drivers? C Most of the time these days, the compiler will generate much better assembly than can be hand coded (do you know which instructions will be paralleled and pipeline orders?). OK, maybe you need a bit of assembly in the interrupt routine to get you inter your C/C++ code, but that's maybe half a dozen instructions at either end. 
He mentions CFront as *the* C++ compiler. He recommends 20+ years old books. Any chance that the article itself is from ~1990?
As sourced by peebsd below, it was written in 1990.
Why on earth does this cost money? If it's a standard, shouldn't it be free?
This is generated from the code I used to prepare for my C++ interview. The questions will usually lack a proper explanation, but the code is solid and most often comes with test-cases that certify that it is a proper solution. If there are requests, I will provide the full question and an explanation of the answer.
Because QT is for GUIs, not graphics. AFAIK, any game-style graphics in QT are just on a regular OpenGL surface. The extra features of QT are just not needed.
Look for precompiled example, found Introjucer.exe. Turns out to be some sort of IDE or something (just a quick look). However, the option in the new project menu to create an audio plugin intrigues the Ableton user in me. I like where this is going. I'll have to look into JUCE further.
Congrats!
There is a lot of code here that operates on C-strings. For that reason, this link would be a good review for folks that want a C refresher as well.
Why is this in cpp specifically? Does google also suffer stack exhaustion in light of such tail recursion?
30$ for a PDF. Sounds about right.
Comments from a C++ pedant...hopefully, you will find them helpful. NullTerminationOddness: The output is undefined for `str_1` and `str_4`, but in all probability it will be true, since the typical x86 implementation will fill in the last byte of the word with a 0 (I'm guessing you're using MSVC on a debug build, which fills the contents of uninitialized memory with special non-zero values, so you will consistently see your expected output). StackImplementation: You should use the initialization lists in constructors, not assignment (http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.6). And consider templates, containers are an easy place to get a grip on them. I also don't understand the return of delete_node...perhaps a `bool`? BytePadding: Class0 and Class1 are implementation-defined (they must be &gt;0, but are not necessarily 1). `ClassA` is the size of the pointer (still compiling with only 32-bits?). `ClassB` and `ClassC` are implementation-defined as well, although this should be `2*sizeof(void*)` on every C++ compiler (since they all use vtables). ShowTwosComplement: char's signed-ness is unspecified, but most implementations are signed. TelephoneWords: There is an arithmetic solution to keypadLookup, but your solution is way more readable. You don't delete `phoneChars` (C++ has a class called `std::string` which is pretty good at containing sequences of characters). QuicksortMergesort: No need to do complexity analysis. Quicksort is O(n log n) performance and O(log n) space in average case if you do it in-place. So you should do it in-place, since it is optimal. RemoveSpecifiedCharacters: The contents should be close to a replica of the `std::remove_if` (see the example in http://www.cplusplus.com/reference/algorithm/remove_if)...you provide an "InPlace" version, but that still allocates remTable (and doesn't free it). DetectCycleInSLL: `isCycle` won't work beyond the simple test cases you've provided. The for loop will infinitely loop if you have something like A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C. If you have your `addNext` call return a pointer to the node you just added, you can make chains more easily: `head.addNext(1)-&gt;addNext(2)-&gt;addNext(3)`. I could keep going, but I'm tired. More global things: * There are a lot of places where you call new without delete. Memory leaks are bad. * The print member functions are a bad idea. There are many reasons why C++ uses `operator &lt;&lt;`. For example, if you make a `HashTable&lt;SomeUnprintableType&gt;` your code won't survive template instantiation, even if nobody tries to print it. Another reason is that all other C++ code uses `operator &lt;&lt;`. * Virtual destructors are not needed unless you are creating subclasses. If you use them, it automatically makes people like me look for derived classes. It adds pointless complexity. **EDIT**: Made my comment not suck as much.
It used to be more like $300.
FirstNonRepeat: why not use a string iterator? NullTerminationOddness: if I saw this in an interview you would *not* get the job. In some cases you are accessing beyond the end of the array which is *undefined*. If you used sizeof(str_X) in main(), then tested str[size-1] it should do what you want. StackImplementation: Why don't you use the normal new that throws exceptions? I could keep going but I have work to do even though it is Sunday 
It would be appreciated if you could cite examples of what you mean. This is meant to be a review of basic algorithms and data-type, as close to the metal as possible. Of course, I know that std::something covers most of the cases -- but it is not the point of this review. If there are things that could be done with in a more elegant way, please do point out. I will probably write more comments, adjust code if necessary. However, I specifically reviewed C-type (data structures implemented with no stdlib in most cases) questions because that is usually what you get in interviews. (For example, when asked to implement a double linked list, "#include &lt;list&gt;" would not be considered a proper answer). 
Send me a pull request on GitHub and I'll see what I can do! :)
&gt; FirstNonRepeat: why not use a string iterator? There are a lot of reasons not to like the solution - but that isn't one of them. The main issue is that the solution is simply wrong! Characters are _not_ "a number from 0 to 255" - in the real world, it all has to be Unicode, unless you want to tell your boss, "Sorry, we can't deal with Russian, Chinese or Japanese and we're going to do a bad job on French and German too." And there's another error - which is that in STL strings, you absolutely aren't guaranteed that s[s.size()] is even defined, let alone that it's 0. Yes, the result of c_str() does guarantee null termination, but in some implementations, the code goes to extra work when you call c_str() to put a null at the end. This is true even in some well-known implementations of STL strings - where short strings are packed into the string itself rather than having a secondary pointer every time (which tends to work out quite a lot more efficiently, particularly on 64-bit systems). You might find, for example, that your code worked fine on all strings except those of length 8 or 16. Yes, a string iterator would guarantee that that wouldn't happen, but you can do it correctly without a string iterator. I personally think a string iterator is better, and in some cases it might be a tiny, tiny bit more efficient, but it's really a quibble - the main issue is that the program doesn't actually work. There's actually a third problem - for short strings, it might be a lot more work to clear those 256 bytes of memory than any other part. I've done hundreds, perhaps over a thousand, interviews for C++ programmers. The candidates who have worked out well are the ones who start by writing a simple, non-trick, obviously correct solution. I'd expect a good candidate to start with something like this: char firstNonRepeating(const string&amp; s) { string s; std::map&lt;char, int&gt; charCounter; for (int i = 0; i &lt; s.size(); ++i) charCounter[s[i]]++; for (int i = 0; i &lt; s.size(); ++i) { if (charCounter[s[i]] == 1) return s[i]; } return '\0'; } If I saw this, I'd already be expecting to give a good report - because I can look at this code and just know it's correct, it's short, and it's easily expanded. Your byte-map is a trick. It doesn't expand to more characters. It isn't even optimal - if you must do it that way, you should use a bit map, not a byte map, so you only have to clear 32 bytes. Now, my next question would be, "But are characters really represented by C++ char?" and see how that went - but that solution is easily adapted into one that uses codepoints instead of chars. (Mind you, if a candidate did present the byte-map solution, it's very likely they're a decent programmer! I wouldn't mark them down for it, but then they'd end up having to pick another solution when we expanded to Unicode code points...) EDIT: looking at the question again, I'm realizing that "repeating" might be ambiguous - it might mean "occurs elsewhere in the string" or "occurs again as the next character in the string. My answer is intended to solve the first of these questions... 
Overall, these are pretty decent coding questions, though many of the objections elsewhere on this page are solid. I've discussed some of them, but I have an overall problem, and that's that your formatting is extremely sloppy. For example, you use the same formatting for if statements as you do with function calls: if(foo == bar) f(foo == bar) It confuses the eye as to the meaning of a statement. And you have lines like this cout&lt;&lt;"POP!: "&lt;&lt;stack.pop()&lt;&lt;endl; which are ultra-difficult to read, particularly if they get longer. Space are cheap and really help readability, use them! You have _three_ different comment styles: //like this // Like this. /* and like this. */ Just pick one and stick with it! (I recommend the second one, personally...) You have a limited line length on your chosen display mechanism - and your lines run over, making again for difficult reading. Some of your comments are just truncated: like //Warning: do not fail to keep the rest of the li These are all quibbles, true - but remember the very important fact that code is written one but read ten times (actually, in large organizations the ratio is often considerably greater than that!)
&gt; Of course, I know that std::something covers most of the cases I'm all for avoiding STL classes to show you know what you're doing (in example code, mind you)...people should know how the libraries they're using work or they risk becoming *magic*, which is bad in systems programming (my favorite interview question is basically to implement `std::random_shuffle`). That said, if you're going to replace something from the STL, you better make sure it works (algorithms work to specification, no undefined behavior, no memory leaks...). &gt; For example, when asked to implement a double linked list, "#include &lt;deque&gt;" would not be considered a proper answer Of course not, `std::deque` is not a doubly-linked list. `std::list` is the STL's doubly-linked list.
Now for some reason i liked dinkumware's online reference very much. Too bad they have taken it down.
I use google search with site:en.cppreference.com
&gt; For C++ questions, answers, help and advice see /r/cpp_questions. To start: You should probably read/write in binary mode, so you don't need to convert as much between C++ objects and text. Just an idea. Also, if you have `using namespace std;` you don't need to write `std::cout`, you just write `cout`.
OKay sorry I'll try there. Also, I tried the cout &lt;&lt; way, it kept telling me it was overloaded. So i just used std::.
I'm doing a 25+ page paper on C++11. Thank you THANK YOU
The sanctity and purity of C is guarded by a sentient Internet presence known as CNU (C is Not Ugly). All those you suggest superfluous extensions to the language will be downvoted and otherwise harassed by CNU until they relent.
uhm... just a question, but wouldn't std::vector&lt;std::string&gt; be a better choice to all those char attendanceN[ATTEN_SIZE] ?
&gt; templates were next on the list You can digest lambdas much more easily (if you intend to go beyond the simple generic container stuff that is barely the surface of what templates are capable of). 
&gt; Your "good candidate" code seems to have grown an extra line. :-) I'm not sure what you mean? I haven't edited it, and aside from blank lines, there are no extra lines that could be deleted...? Yes, there are two similar loops - but you need them both. &gt; However, since we're talking about C++ and not C, throwing an exception might be more appropriate, depending on context. I would think that's a bad idea. Exceptions should only be used for exceptional cases - where the incoming data is malformed or represents a programmer error. Suppose the string is specified UTF-8 encoding - but when you try to iterate through the codepoints, you find it's malformed. That would be a good reason to throw an exception. The case where the string is perfectly well-formed but simply doesn't have any repeating characters is not a good reason to throw an exception - IMHO!
Windows Runtime http://en.wikipedia.org/wiki/Windows_Runtime
Ok, so WinRT is a Microsoft [run-time library](http://en.wikipedia.org/wiki/Windows_Runtime) for Metro. &gt; C#, VB, C++ (using C++/CX ) and JavaScript are all first class citizens on WinRT What do you think it means to be a "first class citizen" in WinRT? Does it change the way the languages are implemented and optimized for your target platform? Probably not, in my opinion. Javascript and VB are still (i think) interpreted languages, C# (pretty sure) compiles into bytecode for the .NET CLR. C++, though should be compiling into native code for the target platform. &gt; Does this mean performancesise C++ would not have particular advantage over other supported languages since they all call and use the same WinRT API? In as much as they call the WinRT runtime, they should perform the same. However, your program will be doing more than simply calling into the WinRT run-time. You will have program logic implemented in the language of choice and that logic will have performance difference based on that choice. If that logic benefits from being compiled into direct native code, then your C++ implementation will likely perform better than the alternatives.
&gt; Because of its COM-like basis, WinRT allows relatively easy interfacing from multiple languages, just as COM does, but it's essentially an unmanaged, native API. It seems WinRT works with lower level bindings than the CLR, and as such does not depend on its virtual machine. So the short answer is 'yes', a C++ program targeting WinRT could be considered "native". The long answer involves asking these questions: * What do you mean by 'native'? * Why is it important?
I'm not sure what you mean by "native". After reading the first paragraph of your link its pretty clear the WinRT is a going to have a COM interface, which will be supported by a load of languages. After that its business as usual, and the C++ app would be compiled while others would be running in a VM.
&gt; Growler is in alpha release and latest release in 2008. And the documentation seems very lacking. Kinda sad.
&gt;Using bitwise operations and shifts was earlier considered as a token of programmer's skill and allowed you to write fast code. Now it has almost no relevance. It's much more important that the code is understandable. I advise that you play with bits only when it is really necessary. Embedded developer, here, writing all sorts of code on 8 and 16-bit micros, where cycles are precious and if I can save 5 clock cycles, I'll often jump into inline assembly. This is nonsense. If you want to write guaranteed safe code, you have two choices: understand exactly what you're doing, and don't wade into undefined territory, or use a language that won't let you pull these stunts.
seems to be a replacement for win32. although it makes calls to user32 so crss would seem to still be involved. significant implications really, but i think when they say "first class citizen" they just mean that the API is accessibly directly via the language.
I don't know when the program started using MFC but I think I heard it was created in 1988. I think sometime around version 8 they rebuilt it partially.
Neat article, but &gt;multiple inheritance, and virtual inheritance in particular â which modern languages eschew and is considered (I hope) a painful legacy by all current C++ professionals Sometimes multiple inheritance can save the day. Same with virtual inheritance. There's nothing wrong with using these features when they actually solve the problem at hand. How often that problem arises is a topic for another day.
There is a difference between multiple inheritance and virtual inheritance. Virtual inheritance is particular attempt to solve the diamond base class problem. It isn't an easy feature to use, and it really does make a lot of things that you thought you understood how they work turn into a real mess in C++. Do you think a member function pointer should be as simple as two pointers, one to the instance, one to the function? Do you think you could probably tell if two classes are the same by seeing if the V-table pointer points to the same location? If so, you're wrong, because virtual inheritance.
Hey Andrey_Karpov_N, are we ever going to see some results for the suggested projects?
Hmm... there might be run-time costs associated with marshaling data from the chosen language to WinRT, as calls are made into WinRT. It has been a long time since I've done COM work, but I do recall a lot of generated code needed in order to call objects from C++. It's possible that one of these languages incurs less overhead in the translation.
The stable version, unless it's using DirectX as it's backend, is slow. The unstable (SDL 1.3) version however has hardware acceleration on all platforms and is considerably faster; not to mention has much more features. Though SDL 1.2 (stable) has OpenGL blitting support, this is deprecated and not recommended for use. OpenGL programming works fine with SDL 1.2 however with no performance loss for using it.
Looks like the friendly competition has benefited gcc. 
I can't help but notice how defensively worded that article is. :-P This really goes to show how damaging a monopoly is, even in a non-economy like Open Source. I haven't used GCC seriously since 4.2, but I'm thrilled that it is actually improving drastically in these areas as a direct result of the competition.
It should be a lesson familiar to the GCCers; the current GCC was once egcs and similarly overran the at-the-time 'cathedral'-style GCC. 
about the c++11 std library: 2nd edition here: http://www.cppstdlib.com/
Nice(er) diagnostics is only useful when you can actually compile your code with Clang. I am working on a [project](http://codesynthesis.com/products/xsd/) on which latest stable Clang (3.1) blows up with segfault. At the same time I can compile it with GCC anywhere from 3.4 to 4.7. It always surprised me how Clang devs seem to concentrate on eye candy at the expense of actually compiling stuff reliably and correctly.
You don't even have to be an embedded developer to consider that statement nonsense. The rest of the article is good, though. I was once bit by assuming that ((uint32_t)i &lt;&lt; 32) == 0. Took a little while to work out what was happening.
This is great. I've been looking for a summary of the new generalised attributes for a while now.
There is nothing to debug here. You are misunderstanding what the word 'debug' means. What you're asking us is basically to write your homework for you, without any effort on your part - this isn't going to happen.
I think what you are after is a good way of parsing a file into object and data types in a loop, I do it all the time as it is very idiomatic and safe. std::ifstream file("my_file"); //parse an object from file while(file &gt;&gt; my_object) { //do what every with object } In this case the file stream object will evaluate to false once the EOF has been met, ending the loop.
Well.. Several times I hear a proposal to write an article about the internal of PVS-Studio. Perhaps I'll do it soon.
Why don't you offer them a single license for free? Even better offer to show up at their office and do a complete analysis of their software for free. That would seem like the best way to get a foot in the door unless they are actually using something else for their static analysis (klockwork for instance).
I am a big free software fan, and I like GPL programs, but for a library it just isn't going to gain any traction. I think I will stick with boost.asio.
I lol'd at this, but checked out the page anyway. I stopped reading when a fullscreen ad took over the page with no obvious way to get back to the article.
It's interesting to see how the two sides approach this. GCC started with a better backend with almost a complete disregard for the front end, while Clang started with its main focus on the frontend. In the end though, they'll probably all converge the way browsers are.
this is also an interesting way of doing it.. std::vector&lt;MyObject&gt; ( std::istream_iterator (file), std::istream_iterator()); 
Yup that is a personal favourite of mine too, although I am not sure how efficient it is because the `istream_iterators` cant specify the distance between start and end so each element has it's own realloc. That said it works with `deque`which will be efficient. I also like it's counter part. std::copy(v.cbegin(), v.cend(), std::ostream_iterator&lt;my_type&gt;(std::cout, "\n"));
You've got the program. You can run it for different size arrays of random data, and actually measure.
N squared is my guess 
&gt; What would you recommend instead? Just send the three bytes. Or if you want a textual protocol, send an ASCII integer and extract the bytes from it, or send each byte in ASCII. &gt; what would you recommend instead for storing game info SQLite 
So, how's oregonstate? Happy there? Paper was due already. Did you solve it? Also: [Do your own goddamn homework!](http://classes.engr.oregonstate.edu/eecs/spring2012/cs261/HW/HW3/HW3.pdf)
[Boost::Asio](http://www.boost.org/doc/libs/1_49_0/doc/html/boost_asio.html) for the networking would be my recommendation. It's pretty easy to use and quite flexible. Also [Cxx-xsd](http://www.codesynthesis.com/products/xsd/) can be a handy way to make data into XML, which can be a handy way to pass data around. You could do that, or any number of serialization techniques. That float idea was, as others have said, not good. Sending 1 byte costs about as much, latency-wise, as sending 1000 (a packet is a packet), so I wouldn't really worry about that. Just design a clean communication protocol and you'll be fine. For data storage, I'd recommend maybe sqlite3 or BDB. It should take care of many of your concurrency issues and stuff.
Boost::asio is really powerful, but rather hard for a beginner to pick up. Look up SFML. It has simple networking classes besides having audio and graphics ones.
Rhomboid's suggestion is good for your final version, but for whatever version you make in testing, I recommend using full strings, instead of 0xe8c or something for some attack, send the full "Attack 3". This will make debugging so much easier. For the networking portion, I second [snarkhunter](http://www.reddit.com/r/cpp/comments/sj7a8/recommended_networking_for_textbased_rpg/c4eisxf)'s suggestion of [Boost::Asio](http://www.boost.org/doc/libs/1_49_0/doc/html/boost_asio.html). I just started networking myself and I was able to set up my own chat server within a week.
It has everything needed as seen here: http://www.sfml-dev.org/documentation/2.0/group__network.php It's also kind of neat how you can very easily put values of different types into a sf::Packet like into a stream. And read values out like from a stream too.
Thanks for this. Having no network experience, I'm looking for the simplest, reliable package to get the job done. I'll check out SFML before looking over Boost.
It's the last ten points of the assignment, and i needed someone to talk it through with me. All you successfully did was creep enough to look up my university and be an asshole. Also, it isn't due yet, think time zone bud.
[Link to the Interview](http://www.informit.com/articles/article.aspx?p=1846582)
thanks!
This is pretty useful. C++'s function notation is confusing to me.
If you're using C++11 you can write `function&lt;function&lt;double* (double**, char)&gt;* (int)&gt; p` which, while still not the most readable declaration, is easier to read than this. My question is what the hell is this function doing? What could it possibly be using that `char for?
No idea why you would ever do this. One of my coworkers is an instructor at the university across from our office and this was in a list of examples of crazy declarations used during the first day he was teaching an advanced networking class. I don't think it really had any point other than to walk through it with students. Nobody in our lab knew what it was doing (including the instructor) and I happened to stumble across this link. Edit: The consensus in our lab was that if we ever saw this IRL we would find the author and punch them in the face. Edit2: Every thing above in this comment where I use pronouns I'm not referring to your suggestion. Rather I'm referring to the crazy declaration in the title. This was also technically for straight C, but the above notation for C++ could be useful.
If you're not using C++11 you can still do exactly that using boost::function instead...
From the linked article: &gt; Initialization of fundamental types. The initialization of fundamental types uses the equal sign (=): This syntax is actually called *copy-initialization* and it is *not* restricted to fundamental types. Also, fundamental types can be initialized using the *direct-initialization* syntax, see below. &gt; Classes with a user-defined constructor require a constructor's member initialization list (mem-init for short) for their data members. Nope. They don't! But it is encouraged to use member initializer lists and one has to initialize a data member like this, if its type has no default constructor. &gt; You can use parentheses to initialize fundamental types as well. Then why did you contradict yourself above? Actually, this kind of initialization is called *direct-initialization*. &gt; The universal initializer is called a brace-init. [...] Notice that unlike the traditional aggregate initializer of C and C++03, which uses braces after an equal sign (={}), the C++11 brace-init consists of a pair of braces (without the equal sign) in which the initializer(s) will be enclosed. Well, one should probably mention that it's also possible to use the equals sign here! It's just like direct- and copy-initialization where for the "direct form" explicit constructors are also considered. One is actually called *direct-list-initialization* and the other one is called *copy-list-initialization*, see 8.5.4 of the current ISO C++ standard. &gt; C++11 furnishes every STL container with a new constructor type called a sequence constructor. I can't find that term in the ISO standard. 
Good question! Yes, I believe that it actually makes a difference. See void some_function(S1); int main() { some_function({23,42}); } only works if the constructor is implicit because this kind of initialization would be a copy-list-initialization and only non-explicit constructors are considered for this kind of initialization. Though, I havn't tested it nor am I very confident about what I just said. ;-)
For those keeping score at home: &gt; declare p as pointer to function (int) returning pointer to function (pointer to pointer to double, char) returning pointer to double
Good call. I had intended to post that, but it slipped my mind. 
This is what I ultimately did, thank you for the help. Not some smartass comments like the guy above. 
Honesty means you don't cheat. When I catch my students cheating, I fail them. That's something I mention at the the first lecture. You get credit for this, so do it yourself. When you cheat, you're out. So, if you want to be honest, at least include in the post that this is your assignment and you want a hint, not a solution. That's something people do in /r/compsci sometimes and they usually get really good help.
If it wasn't for GPL3 I don't honestly believe Apple would have pushed Clang and LLVM as hard as they did. GPL3 stinks like a pig barn cleaning in the spring. I seriously lost respect for the Free Software Foundation with the release of GPL3. The fact that it made organizations like Apple stand up and take notice and in fact active avoid the license is no surprise. Apple has done a lot of good in the free software world by providing a real alternative to the madness of the GCC crowd. 
Why? It is certainly a bug but it is better to seg fault than to generate bad code I would think. Speaking of which no compiler is perfect. However considering just how new CLANG is I'm still impressed by it every time I use it. Considering how open Clang development is I expect it to be pretty damn good when it has as many years under its belt as GCC has. 
Sure, but the choice isn't between segfaulting and emitting incorrect code, it's between segfaulting and emitting a diagnostic message. And in that case, the second option should be chosen every time. A segfault means your program had some undefined behavior, which compiler writers should be especially careful to avoid.
I didn't explain it, because I'm not *your* teacher and there was already a helping comment (Rhomboid). Why should I tell you the same again? But let me tell you something about the internet. It's full of jerks. Perhaps people are really helping you out, but it's equally likely that they tell you bullshit (deliberately or by not knowing better). If you want to learn, go to people you know. Ask your TA, other students or consult a textbook.
Pre-C++11 shared_ptr was often used as a way to pass around expensive-to-copy objects (std::auto_ptr also does the trick, but everyone seem to hate it). With C++11, std::unique_ptr can be used instead. Interestingly, with C++11 we can often go one step further and instead of using dynamic memory allocation with std::unique_ptr, we can make our objects movable and simply pass them around by value.
Good point! Thinking about it, in terms of allocations and move semantics, there isn't actually a lot of difference between an `std::unique_ptr` and an `std::vector` with a single element, except a few extra data members. :-P
Isn't it a bit strange to let weak pointer's outlive the thing pointed to, anyway? That would seem to be begging for trouble.
Not really. Imagine an Observer pattern where you want to access an object through a pointer but you have no desire to control its lifetime. With a weak pointer you can express that relationship. It's just like using a raw pointer, except that you can actually check to see if an object is still alive, and even lock the object to use it without having it deleted under you (since the only way to actually access the pointer is to convert it to a real shared_ptr).
Jerks like you, I'm glad you aren't my teacher. Have a nice day! :D
I've gone through half of Effective C++ and seen Sutter speak at Going Native and read a few of his articles. I'll check out some of those other books. Thanks. I have no idea how hard this job will be yet programming wise.
It covers "all" of C++11 in the same way the previous edition covered "all" of C++03 (or whichever it was...). In other words, some topics are only briefly mentioned, and its coverage varies from superficial to moderately detailed, but it's a damned good reference if you're not comfortable working directly with the Standard or if you see something in the Standard and don't understand why it's there.
I'd guess the interviewer meant that virtual functions cannot generally be inlined. The penalty of a virtual function call vs a non-virtual function call is typically much lighter compared to a inline call vs. regular call.
I'd agree with KrzaQ2. Standardized name mangling would be great. Also, getting rid of header files somehow (while retaining inline functions and templates, of course).
I would think of how to make it more portable?
So what were your answers?
I hate compiler error messages on template. I know STL is not C++ but does anyone ever got any clue to the error by reading STL related compile errors?
&gt; If you could change one thing about the C++ language, what would you change and why? What are some limitations of c++? Only one thing? Hmmm .. that's tough. Make it into D is the short answer! As a shortlist, though: * remove the preprocessor * remove #include mechanism, replace with symbolic #import (or something that's not a textual include) * make `typename` the default, and member access explicit (god damn how often do you ever *not* want typename) * in fact, just clean up the template system - add concepts, add better metaprogramming constructs like simple `if` statements, allow type manipulation such as adding/removing members at compile-time, etc. * all functions become template functions, though you can restrict the template parameters based on type with concepts if you absolutely have to * unqualified types become equivalent to `const T&amp;` - copies and mutable references now require explicit keywords to make these relatively uncommon (and potentially dangerous) operations far more obvious than the safe `const T&amp;` &gt; Could you explain to me how virtual functions work? and why you would use them? Creates a function pointer table, and sub-classes are allowed to replace entries in that table. Used for allowing polymorphic behaviour. I personally wouldn't really use them much if at all. &gt; What is the overhead of calling a virtual function? One pointer addition, almost always prevents inlining. &gt; Are there any situations when this overhead is larger or smaller? If you explicitly call a specific class' virtual function, it becomes a standard function call &gt; When should you make a destructor virtual? When you want to keep references to objects through a base class &gt; Could you explain to me the difference between static_cast and dynamic_cast? dynamic_cast checks that the cast is valid at run-time, static_cast does not. &gt; How would you implement a class that opens two files if you could not use exceptions? Work for a company with sane restrictions? I imagine with the old-fashioned, relying-on-caller if (File* a = fopen(x)) { if (File* b = fopen(y)) { ... fclose(b); } else { error = true; } fclose(a); } else { error = true; } return error; &gt; How would you implement that class with two files using exceptions? Use a RAII file class, throwing an exception in the constructor if it fails to open, and the wrapper class contains two file classes. &gt; How would you handle one of the files failing to open in the case where you have exceptions? Exception thrown, if any file objects have been constructed they are automatically destructed &gt; Could your constructor throw an exception after one of the files had been opened and the 2nd one failed? Which destructors would be called in this case? (assumes use of RAII for file handling (which is how I answered the previous questions)) First destructor called &gt; How would you find the 10 most used words used in a large text file (which was a novel)? Word counts stored in an `unordered_map`, to pull out the first 10 using namespace boost::range::adaptors; auto words = word_counts | sliced(0, 10) | map_values;
STL is a very ambiguous term. But if you're referring to the template part of standard library then this is very much C++, just not a C++ problem, since clang has shown us that template errors don't have to be scary.
Welcome aboard!
&gt; Only one thing? Hmmm .. that's tough. Make it into D is the short answer! Haha! Amen to that.
&gt;I personally wouldn't really use [virtual functions] much if at all. Why not?