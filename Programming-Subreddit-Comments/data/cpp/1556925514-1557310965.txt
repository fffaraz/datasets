That all makes sense, thanks! I must say I'm somewhat surprised to see the lack of standards when it comes to such trivial things like using/managing libraries in C++. It must be hard to work on someone else code due to the big flexibility C++, that person could have whatever the wants however he wants wherever... maybe I got used to the comfort of frameworks. Thanks again, I'll try to go the Cmake way since it's what I see around the most
Open Source? I'm not aware of a ton, really. A few of the Rust ECS do really well, fwiw (e.g., specs); I'm not actually aware of any _C++_ ECS open source implementations that hit all the right points, though I'm sure they exist. Closed Source there are more. I'll re-mention Unity ECS has being a (well documented) exemplar. A few proprietary game companies have invested heavily in ECS-based engines and there's various GDC talks these days about solid ECS approaches that are battle-tested with shipping AAA games. Not a one of them is available publicly, to my knowledge.
Ah yes, the alias usage is how I found the bug in the first place. The segfault is the bigger issue though and that is not captured in the first godbolt , [https://godbolt.org/z/NOzTsd](https://godbolt.org/z/NOzTsd). Thanks for the tips though. Will know how to report better next time.
He's right.
Because the "cost" is negligible.
I didn't know about sparse sets, I will check it out thank you
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bk6i0q/im_somewhat_new_to_c_programming_any_tips_or/emgbisx/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I just learned about std::rotate from Kate Gregory's "Beautiful STL: Algorithms" couse. She's also a big fan.
Stay tuned for my C++Now 2019 talk "Algorithm Intuition." I have video clips and quotes from her as well :)This is just a preview
There is no sense.
An index is almost the same as an iterator. It's a kind of iterator that needs the container to get the value. Negative iterators make no sense what so ever. So, I agree with you.
In my view, what is really needed, is another for loop that does check before the step: dfor( size_t i = v. size( ); --i; i ) { std::cout &lt;&lt; v[i] &lt;&lt; "\n"; } means size_t i = v. size( ); while(i) { -- i; std::cout &lt;&lt; v[i] &lt;&lt; "\n"; }
I always have trouble remembering what the STL algorithms do. Do people really remember each one or do people usually have a reference on hand?
I don't think I understand your point here. This code (modula the namespace for malloc and free) is just fine in C++. It may be poor style, but I don't understand how you can say "It cannot be made to work."
Bookmark this: https://en.cppreference.com/w/
It isn't legal in C++ to implicitly convert a void* (which malloc returns) to another pointer (such as Foo*) so that this error can be caught. Do C headers have inline functions?
Hi, Visual Studio Cross Plat (CMake, Linux etc) dev lead at Microsoft here. If you invoke Conan from CMake, CMake should have all the information, and you shouldn't need to store anything in CMakeSettings.json. For launch.vs.json, could an option be to edit the launch.vs.json directly from within CMake, then VS will just pick the changes?
Things you need to know, from an enterprise deb's perspective: * Almost all cases are covered with vector and unordered_map (or map if you prefer rb-tree to hash map). If you think you need something else, ask a senior dev how he suggests approaching your specific problem * for-each (`for (auto&amp;&amp; member : collection)`) is godly. Understand what its doing and why it is wonderful (creating a hidden iterator, going from `begin()` to `end()`) * smart pointers are wonderful, especially for communicating ownership of heap-based instances of objects. Use `unique_ptr` far more than `shared_ptr`; `shared_ptr` is for cases where multiple objects need to keep a specific instance of an object alive for their duration, and have no knowledge of the other objects keeping that instance alive. `weak_ptr` is also a very useful tool if you want to kick off a long process and might not be around to hear it complete, but if you are, want to react. * always pass `shared_ptr` as a const-ref to a function, or you're just hitting a couple atomic increment/decrements for no reason. * remember that const-correctness is very important for templates. `vector&lt;const Foo*&gt;` is a different type from `vector&lt;Foo*&gt;`, and the compiler will notice if you try to mix these, and throw enough angle brackets at you to resurrect Baphomet.
&gt; I must say I'm somewhat surprised to see the lack of standards when it comes to such trivial things like using/managing libraries in C++. C++ just doesn't have its own package manager/build system/etc. There's no C++ equivalent of Cargo. C++ is also not unique in this. Java also has ant, maven, gradle, etc. CMake is a reasonable choice. It works with IDEs, it's portable, widely available, etc.
Go through Bjarne's book, A Tour of C++; it's just 150 pages, and half of it is STL.
It's crazy that has fallen through the cracks for so long.
i can't wait to rotate optimize legacy code.
Thanks for the reply! I've heard this book is for people with no prior exposure to programming, Is this really a good buy? I'll have a look now at some pre-purchase pages. Also if you can recommend some more good books and resources, would honestly appreciate it, Summer's around the corner and I can deep dive into this.
These all look like solid advice. Question In your second bullet point, I've seen some crazy implementations using for-each, granted this is some really powerful stuff especially if your working with user-defined types and you've overloaded operators, but it's extremely confusing to follow, using functors(i'm still very iffy on how they work) and lambda's in your for each statement, Is this actually used in the professional world? In the last point, I'm really not sure I understand
Is there a particular reason, why you don't suggest using find_package, which should be the default way of resolving dependencies in cmake?
Download docker and start using GCC there
Can somebody explain to me the first chart? It has no axis labels and the caption doesn’t help either.
I had stopped using `find_package()` a few years back with CMake 2.8 so maybe it's better now. The problem was when `find_package()` would invoke a "CMake Find Module" that would essentially include/source this `Find&lt;package&gt;.cmake` file and delegate that to finding the "package". I ran into a few of these `Find&lt;package&gt;.cmake` files that would 1) pollute my project's environment by doing things like forcefully setting (or even resetting!) things like `CMAKE_CXX_FLAGS` and 2) explicitly ignore or disable searching via idiomatic paths like `CMAKE_PREFIX_PATH`. The problem was that these `Find&lt;package&gt;.cmake` files were usually hand written and thus their quality varied drastically. I think `find_package()` in non-module mode where it looks for an *automatically generated and exported* `&lt;package&gt;Config.cmake` with "modern" CMake targets (with INTERFACE/PUBLIC properties) is probably fine and great. It's too bad these two behaviors are overloaded under `find_package()`.
Perhaps the following can be of some use: * Building GCC from source - http://www.hanshq.net/building-gcc.html * build-tools-gcc: GCC toolchain build script - https://github.com/USBhost/build-tools-gcc * gcc-build: Scripts for rebuilding gcc - https://github.com/davidmalcolm/gcc-build For completeness (although I wouldn't recommend [snapshots](https://gcc.gnu.org/snapshots.html) outside testing or GCC development): * Binary packages for GCC snapshots: https://jwakely.github.io/pkg-gcc-latest/ * Scripts to build binary packages of GCC snapshots https://github.com/jwakely/pkg-gcc-latest
&gt;I've heard this book is for people with no prior exposure to programming, Is this really a good buy? I'll have a look now at some pre-purchase pages. It's meant for "less experienced" C++14 programmers, not necessarily beginner's; in fact I'd wager a novice would have a hard time with the brevity and terseness of the book. Also there are PDFs all over the internet, you could always "try before you buy". &gt;Also if you can recommend some more good books and resources, would honestly appreciate it, Summer's around the corner and I can deep dive into this. Honestly that's the best C++ book I can recommend by orders of magnitude. I recently learnt that Herb Sutter shares that sentiment, and felt quite nice about it. You should definitely check out his talk on the modern C++ memory model, it's on YouTube. People also seem to recommend Scott Myers' Effective C++ a lot, though I've not read it myself.
***Do not ship your own copy of Qt.*** If you're statically linking, use an installed Qt through CMake. And if your program isn't LGPL / GPL, you may need a commercial Qt license if you're statically linking, so consider dynamically linking if it's possible (probably only if your users are on Linux / BSD). The structure you have is how you would install into /usr. There's no reason to have a bin or lib directory since you should be building out of tree. If you *do* decide to bundle external libraries (which you should only do with header only or very small ones) use an extern directory.
This is absolutely used in the real world. It is not just for\_each. Proper use of the algorithms library makes for very easy to understand code. For example: &gt;auto it = std::find\_if(std::begin(my\_vector), std::end(my\_vector), \[&amp;val\] (auto &amp;item) { &gt; &gt; return item.prop1 == val.prop1; &gt; &gt;}); strictly speaking is more complicated than &gt;for (auto &amp;item: my\_vector) { &gt; &gt; if (item.prop1 == val.prop1) { &gt; &gt;out = \&amp;item; &gt; &gt;break; &gt; &gt; } &gt; &gt;} in the sense that there is a lot more syntax and language features involved in understanding what it does. But all of that stuff provides an experienced dev with information so that eventually it is much easier to read. The great thing about language features is that generally you only need to learn them once and then you reap the benefits forever.
I use `function` a lot and lambdas even more, but `bind` never. What am I missing?
I completely agree with you and I've complained like this before, but unfortunately, I'm feeling it's a lost battle for anyone except specialists. For working programmers, currying and partial application are "basically the same" and I feel we won't be able to put the cat back in the bag on this one... :-/
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bkir36/beginner_stuck_on_chaining/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; I never trust names to begin with so I have a habit of looking at what a thing does rather than what it's called. OK, but if a thing has a name which inaccurately describes what it does, then that's a feature deficiency. Particularly when reading code, particularly with very large codebases, you cannot look up each and every symbol each and every time you read it. Yes, when I'm debugging, once I figure out the area the bug is in, I'm going to start reading every method or function that's involved, but I've worked in codebases with millions of symbols. When you're reading to try to figure out what's happening, you have to assume that most of the time, people aren't lying to you - that 'finalize_transaction` doesn't in fact start a new transaction or `read_config` doesn't in fact delete the config - because there just aren't that many hours in the day. And when I do find a name that's misleading, I fix it if it's at all possible _because it's a trap._
interesting anagram for your last name
Instead of delegate.Register([&amp;]() { this-&gt;Foo(); }); You can use delegate.Register(bind(&amp;Bar::Foo, this));
1. It's not "more complex" - indeed, it clarifies your intention better. 2. And there is a chance that you will get the wrong answer! Let's compare these two: for (int i = 0; i &lt; 100; ++i) { auto angle = 0.2f * i; for (float angle = -3.14; angle &lt; 3.14; angle += 0.2) How many iterations in these loops? The answer is that the first loop runs exactly 100 times, whereas the second loop runs either 100 times, or conceivably 101 times with roundoff. Now, my best _guess_ is that round-off almost certainly won't be a problem here. But to prove it to myself, I'd have to write some tests - actually look at the computation itself. And if the loop were `for (float angle = -x; angle &lt; x; angle += delta)`, I would _know_ that there were values of `x` and `delta` that would make this do something unexpected. Please note - this is not hypothetical. I have run into this bug in code I have written in the past, _and_ I have run into this code in other people's code. Save yourself and some other person in the future trouble and unnecessary trouble in the future. Never ever use loops with `float` or `double` indices - you're opening up the possibility of bugs with no corresponding reward.
Honestly that took me a some time to understand what was happening, I've seen that naming convention very often **auto it1 = vec.begin();** for example, Isn't that less readable even to a seasoned dev? Also in the first part of the what is the difference between std::begin(vec), std::end(vec) and vec.begin(), vec.end()? Is this just a preference or are there hidden benefits?
&gt; Particularly when reading code, particularly with very large codebases, you cannot look up each and every symbol each and every time you read it. There's a reason why humans have evolved with memory. In codebases, large or small, there are only two reasons to read the code: 1) While developing it. 2) When fixing it. Working code never gets read. So, OBVIOUSLY you don't read up every symbol every time. You only need to read up the once, for when you get to that part of the code that has that symbol. Then your brain's short term memory does its magic. You REMEMBER what that symbol implies without having to look it up all the time. Once that code is done with, it doesn't get looked at again. You can forget about it (not like you have a choice) over time. There literally is no issue because human brains are amazing at keeping things in memory when needed.
Bought the kindle copy, looked like a solid book with a lot of great reviews. Will try to read and understand it this week, Thanks Extra questions sorry 1. When would you say is a good/great time to learn about multithreading? Even just the basic stuff? 2. It is very hard to use the algorithms library instead of implementing my own, because at university, we are consistently drilled about complexities and at some points, that is all we think of. I know it's important to produce results first and optimise later, but it's extremely hard, any tips?
I'm pretty sure std::bind is deprecated now that we have lambdas.
You can force config mode in find_package if you want. I had very few problems in recent years and I'd wager that it is "good enough" for a c++ beginner. Bad scripts are definitely a problem though. Imho the problem is the lack of an authoritative source of what qualifies as a good script.
Just saying: c++ does have package managers like conan, vcpkg and some build tools even integrate a package manager.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Only `int main` conforms to the C++ standard.
I've always considered Effective STL by Scott Meyer a must read for any serious cpp dev. It's a great book and can get your mind working not only on the STL but cpp class design in general. A good thing to know is that many large development studios will implement their own container classes for various reasons. However, understanding the STL in detail provides a solid base for understanding any custom implementations.
The point of LGPL is that you can link against proprietary code. It is also entirely unrelated to static linking - you can staticslly link against proprietary code.
If you do that you have to ship everything necessary for your user to relink against their own Qt. [https://www.qt.io/faq/#\_Toc\_3\_7](https://www.qt.io/faq/#_Toc_3_7)
&gt; There's a reason why humans have evolved with memory. I have worked on codebases with tens of millions of symbols. Relying on your memory to get code right is how bugs are created. &gt; Working code never gets read. This is not true in real-world projects. First, working code gets changed constantly as you add new features and needs to be re-read each time. On the other hand, "core" code which gets finalized quite early in a project still gets read over and over again: by each new developer, and by experienced developers wanting to check on the subtle details. For example, there are parts of the Python standard library I have read a dozen times. It's not because I "forget" - indeed, I have a "trick memory" that's better than almost anyone I ever met - it's because I'm trying to learn more about this complex machine I am working with. I have a proverb that says, "Successful code is written once but read a thousand times." In fact, there are famous and successful pieces of code that have been read hundreds of thousands of times - the Python Standard Library, the DOOM source code, that sort of thing.
Do you want to ship a self-contained binary or a self contained source code package?
I don't see the need for the internal lambda functions in his examples. Maybe it's just because it is a toy one but why not just call directly into the drawAt function from drawOnLine?
It was very clear I was talking about short term memory. You don't remember everything. But that doesn't mean you have to look up every time you see a symbol while you're working on that section of code, as though the definition of the symbol somehow changes every minute. If you read my previous comment more carefully, you'd see that I already addressed "your" proverb: code is not read more often than it is read. I guarantee you the amount of times the Python library is read is dwarfed by the amount of times it ISN'T read, because it works. Like I said already, code only gets read when it's being developed, or when it doesn't work. And when that code doesn't work, assuming things from the names is the easiest way to waste time missing where the bug is.
&gt; always pass shared_ptr as a const-ref I don't like the always here. The [core guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-sharedptrparam-owner) state the following: &gt; R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner &gt; R.34: Take a shared_ptr&lt;widget&gt; parameter to express that a function is part owner So when the callee is having explicit ownership passing by value is recommended. (Imagine a function starting a thread and passing the sp in there) &gt; for (auto&amp;&amp; member : collection)) Is there any reason you recommend forwarding references here? In most cases `(const) auto&amp;` Is sufficient. &gt; ⁠remember that const-correctness is very important for templates. This advice seems rather weird. Anything that is part of the type (and is not deduced away) is important for templates. Sorry for the nits, great summary though.
Take a look at the [Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) to find some great advice.
free function begin and end are only realy neccessary in very generic code, as they can handle c-arrays (and you should prefer std::array over those, precisely because it has all the expected member functions). In case you need that, you probably want to do using std::begin; using std::end; auto it = begin(foo); So that you can also ADL-find free functions in the same namespace as Foo, or in-class defined friend functions.
I already wrote that one above though? for ( auto i=verts.size(); i--; ) {...}
&gt; I guarantee you the amount of times the Python library is read is dwarfed by the amount of times it ISN'T read, because it works. As I explained to you, I personally have read this code many times, not because it didn't work, but because I was interested in how it _did_ work.
sure, but you do not need a commercial license in any case. &gt; everything necessary for your user to relink against their own Qt. is basically shipping your .o's and a build script.
Plus you have to host (or distribute) the Qt source you built the static libraries from. In short, it's possible to statically link proprietary code to LGPL libraries, but you have to be careful. Dynamic linking is just easier, though it does mean your users need to have Qt installed already, which is why it's only really an option for Linux and BSD, where the idea of installing dependencies is common.
I would love to know more about this as well. I'm struggling through PPP by Stroustrup at the moment and the FLTK section seems a bit... niche. More material is always appreciated.
And I guarantee you, that CANNOT make up for the amount of times it isn't read. Are you seriously telling me the time you have spent reading some code accounts for more than the amount of time NOT reading that code?
&gt;I believe making it work with exceptions would be really hard. Why you think so, can you add documentation links about this - or more information what you know ?
you can write both int main and main both are valid by Cpp standards . Using void main is not.
I'd also like to know. I remember my books were specifically the 98 standard, with minimal C++14,
On Windows, you just bundle DLLs with the app.
I'm not aware of any books for C++2a. Even C++17 is thin on the ground.
Good nits! 100% right on the shared_ptr parameter statement. I've just almost never run into that scenario, to the point that I've forgotten the case. I use universal reference declarations with auto in loops, simply because it's the least characters. You're right regarding templates, const is just the thing that I most commonly see cause template compile errors.
This c++17 book is good - http://www.cppstd17.com
There are two things for each could mean. What I referred to is also known as range-for, which is the most commonly appropriate way to iterate. There are also functions on many collection wrappers called `ForEach`. For example, if a class owns a collection, and that collection is a private member to which the creator has good reason not to expose as accessories, he might make a `ForEach` method which takes a functor (a lambda is a type of functor) as a parameter. The usual implementation of ForEach would be template &lt;typename FunctorType&gt; void Foo::ForEachBar(FunctorType&amp;&amp; function) const { for (auto&amp;&amp; bar : m_bars) { function(bar); } } A functor is any object which has an `operator() ()`. You might also call it a "callable object." What it means is basically, you can use it semantically as a function, if you have reference to it. Lambdas are a type of functor, which are defined and used in exactly one place, so they don't need a name like a class or structure which defines `operator () ()`would need. The last point is just the most common error I see people make (myself included) that causes compile errors in libraries using templates.
&gt; Plus you have to host (or distribute) the Qt source you built the static libraries from. you also have to do this for the dynamic libraries. Nobody ever bothers with that but to properly comply with the LGPL you must keep a backup of the Qt sources used to build the Qt dlls shipped with your software and provide them along with build instructions - else you would not be able to comply with the LGPL if e.g. tomorrow TQTC closed and removed all the Qt source from their servers.
&gt; is basically shipping your .o's and a build script. Or use partial linking (`ld -r`)
&gt; ld -r did not know about that one, nice !
I taught c++ in the past, and for new programmers I suggest they don't need the latest compiler technology, just the basics are going to be more than they can retain. #1 make sure they can set up their development environment and compile hello world. I taught how the language worked. Start out with just normal logic constructs, function definition, variable definition. Expand structs to add functions that operate on the struct. If you want to teach inheritance, you can show how a struct inside a struct is actually the way inheritance works. By now you have probably covered more material than students can retain in a week long class, but you can then go on. Where functions allow reuse of a piece of logic that operates on a specific type, templates allow you to reuse logic, without dependency on type. If was me, next I'd cover boost, or some collection library that you will use as that is the next thing they will need to know. After about 6 months of experience, then your new c++ programmers would be ready to absorb the newer features.
You should almost never be passing shared pointers into free functions to start with, whether by reference or value. It should almost always be a reference to the object itself.
There are “Thinking in C++” books, which are nicely written and teach everything solid C++ beginner needs. C++11 and higher(and stl) is a different kind of C++ and should be taught when the student is solid in basic C++. And TMP is absolutely advanced topic, which I think like 60% I’d C++ developers need to know only on a very basic level...
I genuinely feel like the more I learn the more I have to learn, It seems from your explanations functors are used in exceptional circumstances, but the way I've seen them with github code everyone just spams then out. It gets really hard to follow. Question lol sorry When we use &amp;&amp; we're expecting an r-value reference, This is more efficient since the compiler doesn't have to do the creating and storing of the temporary object and then transfer it over I think? So having said that, Should we also at every point we see fit, to &amp;&amp; most functions and member methods which require an r-value? Ah, I hear Boost is a very impressive library as well and most of the Boost features have been implemented into the standard, Is it worth getting my feet wet with Boost or is that something you only concern yourself with if you have a certain focus? Thanks for the post, Appreciate you spending your time to explain, Looks like I have a lot of grinding to do
I guess it is assumed that '//do something' may throw. However, using C you can just as easily have a memory leak in a similar snippet.
You can skip that part (FLTK), and revisit later (if you like). If I remember correctly, that part teaches you about FLTK (GUI) and OOP - tbh I don't really like mixing topics; and you can learn OOP from other sources.
zybooks I using them at the university I teach at. Fully online textbooks. short on the reading, high on the interactive activities.
When a parameter or the value of a range for is declared with &amp;&amp;, its actually a universal reference specifier, so it will take either an rvalue reference, or an lvalue reference without complaint. The savings aren't really at runtime, just in code writing time (if it happens that you have an explicit rvalue you want to pass, the compiler won't complain like it sometimes would if the function were declare with const&amp;). It's something I only do for templated non-constructor functions, and in range-fors. Personally, I've never used Boost in a 6 year career, though that's likely because most of the useful bits have entered the standard, and I'm in game development so every company has their own container libraries (Blizzard, in the codebase in which I used to work, had 4 separate container libs; good times). So my guess is, only check out Boost if you need a specific thing which only it has. Programming in general is a progressive ramp up of finding out how little you know. I love it for that. Happy to answer your questions!
Take a look at boost [https://www.boost.org/](https://www.boost.org/) as well.
Thanks for the feedback! I'm definitely interested in the GUI stuff but utilizing FLTK feels less like I'm learning about GUIs and more about how to use FLTK which, due to my inexperience, feels very incomplete and has left me feeling like I've jumped out of sequence. At your recommendation I'll probably just read these chapters for a brief conceptual understanding and move on. Thanks again!
Modern C++ (C++11 or later) books are not nearly as plentiful as those for Classic C++, but there are a few notables. Bjarne's college text may be what you are looking for: Programming: Principles and Practice Using C++ https://www.amazon.com/Programming-Principles-Practice-Using-2nd/dp/0321992784/ref=pd_sim_14_2/144-7765085-0122037 It is aimed at engineers, which makes it less general, but might be good for you. Of course his general intro is also updated to C++11. The C++ Programming Language https://www.amazon.com/C-Programming-Language-4th/dp/0321563840/ref=pd_sim_14_2/144-7765085-0122037 This is aimed at experienced systems programmers, so it may be a bit heavy for students, which makes the Primer (that you mentioned attractive). C++ Primer https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113/ref=pd_bxgy_14_img_2/144-7765085-0122037 Be certain to get the 5th edition. Of Scott's books only the latest is Modern. Effective Modern C++ https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=pd_sim_14_2/144-7765085-0122037?_encoding=UTF8 This is less an introduction for students than for Journeymen (Journeypeople?) programmers. For just plain good programming style consider Ivan's book. Functional Programming in C++ https://www.amazon.com/gp/product/1617293814 Don't be put off by "Functional." This style of programming will make your students excellent programmers. There are some modern books of high quality that are niche. The ultimate guide to templates: C++ Templates https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121/ref=pd_sim_14_1/144-7765085-0122037 The ultimate guide to concurrency: C++ Concurrency in Action https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/ref=pd_sim_14_1/144-7765085-0122037 Some library options: Despite its name, this is mostly reference. A very good reference. The C++ Standard Library: A Tutorial and Reference (2nd Edition) https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215/ref=pd_sim_14_2/144-7765085-0122037 Arthur's book covers C++17, which makes it one of the most modern on this list: Mastering the C++17 STL: Make full use of the standard library components in C++17 https://www.amazon.com/Mastering-17-STL-standard-components-ebook/dp/B076CQ1RFF/ref=sr_1_fkmrnull_1 To what extent are you teaching C++ and to what extent are you teaching programing? Good luck and have fun!
you can check this blog if you wish to [https://www.hackerearth.com/blog/algorithms/list-top-c-c-books-programming-enthusiasts/](https://www.hackerearth.com/blog/algorithms/list-top-c-c-books-programming-enthusiasts/)
Yep, C++ is the wild west. But there have been efforts recently to try to standardize packaging, at least layout-wise. I'm surprised no one has yet mentioned @vector-of-bool's excellent work here: https://github.com/vector-of-bool/pitchfork
I would be cautious about the use of capturing return values with auto&amp;&amp; outside of templates. Even more so when iterating containers. When you get a value you either want to modify it (auto&amp;) or capture/use it (auto&amp;&amp; or l-value). The problem is that if the function returning the value changes the reference on the return type, your code could end up not modifying a value it should or even modifying a value it shouldn't!! Use of auto&amp;&amp; in cases where you will not treat the reference types differently (templates) often results in fragile code that when it breaks causes very hard to identify bugs. I find a much better solution is to use the reference type to enforce the requirements of the usage. auto&amp; - this value will be directly modified but never moved. const auto&amp; - this value will only be read. I don't care if it's l-value or reference. auto - this value belongs to me and is either a pod or I will move it. It also does not save you any typing. Likely 99.9% of the time your auto&amp;&amp; on containers resolves to an auto&amp;. In the cases it doesn't a simple auto suffices. Both are fewer characters. Only thing it saves you is having to think about your usage of the type. Save auto&amp;&amp; for cases of truely generic code in templates.
What experience do the people you're teaching have in C++? If they're new to the language (or are unfamiliar with the post C++11 standard) I think the best resource is without a doubt the second edition of [A Tour of C++](http://www.stroustrup.com/tour2.html). It gives a very concise overview of the modern language, including introduction to concepts &amp; modules. If they are brand new to C++ I would not recommend the Scott Meyers book, I think it is more targeted at people with intermediate C++ experience.
This is a great and very useful answer to the question, thanks for that, I had no clue. I'm now having second(ary) thoughts, though, `C` wasn't so bad after all, at least you know what's what [and yes, it's fuckin' dangerous , but I can quite easily live with that kind of danger, it's contained 'know your pointers, nothing scary about them'].
&gt;1. When would you say is a good/great time to learn about multithreading? Even just the basic stuff? Sooner than later; till then all your programs will use exactly one CPU core, which seems like a waste of the rest on a system. Start with the fundamentals: * How to start a new thread, how to wait for it to complete * How to exchange data (variables) between running threads * How to design an "interrupt" such that the other thread will continue working until something is true/false The core concepts behind multithreading are the same: write sequentially consistent code with no race conditions; it's just that modern C++ provides many built-in facilities to aid in all that. &gt;2. It is very hard to use the algorithms library instead of implementing my own, because at university, we are consistently drilled about complexities and at some points, that is all we think of. I know it's important to produce results first and optimise later, but it's extremely hard, any tips? Writing your own `sort` is hardly what any professional would call "complex" - it's just pedantic, and nobody does it in production code because why reinvent a wheel with a whole new set of bugs and inferior performance... Of course it's fun and educating to embark on such "learning" projects, and partly what school is even for, so don't worry too much about it right now. Most responses here are from professionals and with that kind of context (which is already quite a bit more advanced than school-level C++), in case you weren't aware.
C++11 is a different kind of C++ but kind of alternative. I suggest to start from this different k8nd of C++ and learn the oldest stylr only if needed.
That would be even better. More modern I would say:)
I'm a student, and I learned c++ as second language (after already learning java and oo design) . This was when c++14 was just out. You can ask me specific questions about my learning experience if you want. But one thing that got me very confused in the beginning was references, move sementics, pointers and smart pointers. My two cents based on that experience: teach your students reference early on. And let them practice a but with the difference between pass by value and pass by reference. If they have some more experience in the language (teach them something else in between) , teach them raw pointers. Then if they've practiced with it a bit, learn them valgrind or something and teach about memory leaks. Then teach them shared pointers. Make shure to get to smart pointers fast enough that raw pointers don't become a habit, but not so fast that the don't even understand raw pointers before throwing smart pointers at them. If you have the time, teach them move semantics and only after they get that, teach them unique pointers. Using unique pointers without understanding move semantics is a very frustrating experience.
You can, but really shouldn't. It's less readable, less debugable, less performant. All around worse choice.
Also watch Kate Gregory's talk "Stop Teaching C."
good thing C++20 simplifies this to: \`std::find(my\_vector, item.prop1, &amp;ItemClass::prop1)\`
Yeah. Especially considering that the final C++2a standard hasn't even been published yet. Sounds a bit weird to publish a book about it before the standard has been published imo.
There is already quite some C++17 material out there. I try to keep a list at [https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B17/books.md](https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B17/books.md)
https://www.cjdb.com.au/sg20-and-videos A Study Group under the ISO C++ Standards Committee is being formed just for this purpose. LOTS of good information there.
I can't possibly begin to understand what you are saying.
Self-contained binary
Oh, missed that reference. You deserve the silver more than me, I guess
&gt;Please note - this is not hypothetical. I have run into this causing bugs in code I have written in the past, and I have run into this causing bugs in other people's code. Same here. You live and learn : )
&gt; I've seen that naming convention very often `auto it = vec.begin();` for example, Isn't that less readable even to a seasoned dev? Calling an iterator `it` is a super common idiom, so it ends up being intuitive (along with other common names for things, like `hdl`, `ctx`, `idx`, etc). For a lot of raw iterator use cases, outside of within plain for loops that should be for range loops, you can still get rid of the iterator and use the `&lt;functional&gt;` header: auto it = vec.begin(); while ( it != vec.end() ) { if ( should_remove( *it ) ) { it = vec.erase( it ); } else { ++it } } could instead be written as vec.erase( std::remove_if( vec.begin(), vec.end(), []( const auto&amp; item ) { return should_remove( item ); } ) );
Then I'd use a package manager - at least for big dependencies like qt(but check licensing). For smaller (easy and quick to compile) libraries it may make in deed make sense to put a copy of them into `libs`, but initially, I'd just use a package manager. Putting libraries into `libs` makes sense if you want to compile them as part of your project, which in turn may make sense, if you are using a lot of different and or non-standard build types (cross compilation, compilation with certain sanitizers enabled, nonstandard exception settings etc.)
bind() isn't officially deprecated, but it should be avoided. Source: reimplemented bind().
I think, trying to teach c++2a content doesn't make sense because a) the students can't use most of it yet (certainly not with easy to use, of the shelve toolchains) and b) there is little experience in the community how to best use many of those features in practice. An exception to this might be concepts. C++14 and 17 don't really change the way c++ programs are written, so while up to date source material is always good, it should not be so important for determining "how" to teach c++.
Only if you ship the libraries themselves. On Linux, you generally wouldn't do this, and just require the user to have Qt installed (which is generally not a problem, because the system package manager makes this easy). &amp;#x200B; If you're distributing your application on a platform that has no package manager, and decide to ship the libraries, then yes, you also need to ship the source.
As jcelerier pointed out above, this would somewhat defeat the point, since you would still have to ship the Qt source.
Just my 2c on how I would teach C++. I've been a dev for about 20 years, and what I see lacking in most green programmers is basic understanding about how a computer works. IMO you need to have a healthy understanding of C to really understand C++. If you're sticking only to high level abstractions like RAII and smart pointers, you may as well just go all the way and use an actual high level language like Java or GO as that will be more efficient when used naively. Instead, I think C and "modern C++" should be taught like usafe / safe code in Rust. Where everything internally uses C concepts, but you wrap them in 'safe' abstractions. All of the best programmers I have worked with have all started with C first, then learned C++. You need to understand how the C++ internals work so you can construct actual performant code or debug an optimized release build. And programmers with an understanding of C generally have a better mindset to approach a problem, they try to solve it in terms of what the CPU can do, not in terms of how you could use OOP and smart pointers, which are just tools that cause more harm than good when applied incorrectly.
You want to check SG20 website with all the latest content
Add reference is not the right thing. That is for adding dependencies like libraries and assemblies. Right click on the project and look for create file or new file something like that. It might be buried in one of the sub menus but it’s in there. You’ll get a new file box that will ask you to select the type of file and you’ll want to select either C++ header or source file depending on what you are trying to add. Probably a a source file.
https://isocpp.org/tour
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bkohdl/my_reference_manager_is_basically_empty_and_i/emieast/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I would highly recommend skimming through A Tour of C++ for starters then work your way through Accelerated C++ which dives into templates as soon as the second chapter.
My b
Maybe “Thinking in C++” by Bruce Eckel would come in handy? The first volume is about simpler stuff if the language and OOP, but the second could be interesting. There is also “Modern C++ cookbook” which is somewhere in intermediate-advanced levels.
It was a good book... But it is a bit outdated
Teach C. Not C++. You should only be teaching C++ after they know how to read disassembly output and after they have a strong grasp of systems programming in general. Honestly, C++ is the last language that should be taught in a typical undergrad curriculum. Racket or ML, C, Java,and assembly language are enough. Learning C++ before learning C is almost damaging, and it distracts from the point, which is for students to learn fundamental concepts that are necessary to produce good programmers. You can only be competent with C++ if you *already know* these things before choosing to learn the side of C++ which is actually C++ and not just C + some "go faster" sugar.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;OK, but I was asking if you remembered the Bugzilla ticket or GitLab issue and had a link to it you could post…?
Supplying "Minimal Corresponding Source" does not apply if you: &gt;Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and (b) will operate properly with a modified version of the Library that is interface-compatible with the Linked Version. https://opensource.org/licenses/LGPL-3.0 There is a dependency on GPL section 6, but choosing section (d) only requires "offering access", not bundling. https://opensource.org/licenses/LGPL-3.0 The point I think /u/jcelerier was making was related to the final sentence in that clause: "Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements."
Here's the [fragment of the particular lecture](https://www.youtube.com/watch?v=IzNtM038JuI&amp;start=1715&amp;stop=1800) with the inside story with the "nobody knows what `rotate` does" quote.
There's no way I would remember - that was 10 years ago.
Duplication of effort, wasted time and energy among thousands of people building the same thing the same way. That's why PPAs are so popular.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Eh, fair enough.
Thank you for the suggestion
Thanks. Provably the accelerated c++ will be a better fit, already have some basic knowledge in c++
You should add khash, I found khash to take less memory and have faster find and emplace calls, and significantly faster iteration. I tried with uint8,uint64 and strings as keys. Ktprime and your map are both interesting as well. Was tested with O3 on msvc 142.
There is a real metaclasses proposal by Herb Sutter aimed for C++26 https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/
I hope the standards committee prioritise whatever additions to annotations etc this needs. Maybe an opt-in `[[nondestructive]]` for declarations of move for non-typical use.
&gt; If this qualifies as minimal example though, I'd be glad to do so! If you have a bit of time on your hands then minimising your test case using [creduce](https://embed.cs.utah.edu/creduce/) can be an interesting task. I've used it to reduce a few multi-megabyte segfaults down to half a dozen lines. But if not, it's better to have a large testcase than no testcase. :)
Legit, gonna check it out. Currently on my phone so can't get all the details clear, but is there a flat multiset?
Hi! I’ll add flat multiset and multimap in next update :)
Ok awesome, will be following this. Thank you very much for this work.
Ok awesome, will be following this. Thank you very much for this work.
Cool, a tour of cpp is a nice complement to get an introduction to some of the newer features that c++ has to offer. It's only about 200 pages so should be a breeze to read through
&gt; 1. Create parser for a fixed grammar. &gt; 2. Claim it's generic and extensible. Hmm...
Hi! I don't really get the syntax. Perhaps it would help if you added a simple practical example to the readme. How would for example a basic YAML or JSON parser look like?
Look at the examples on the website. http://jeebox.org/user/introduction
Also, do not talk to me with that kind of attitude. I just don't have the time for it. Don't come at me with accusations that I'm "just claiming" things. You are accusing me of being a liar right off the bat with your first reply. I'm just blocking you.
Any reason to use this instead of boost::flat\_map, etc?
It's a single header library so it may be worth it if you aren't using boost for anything else
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Whoa, a little piece of Smalltalk in C++! Nicely done! P. S.: Any chance of this coming to other platforms besides Windows&amp;thinsp;—&amp;thinsp;say, macOS, for instance?
Examples at: http://jeebox.org/user/introduction OK, so jeebox doesn't parse other languages, like YAML or JSON. Jeebox is just Jeebox. Its there to express concepts. So any concept, or data-structure in JSON can be expressed in Jeebox. But the syntax will be different. Also, can you express a concept like this: `while (a&lt;b) { if (a.Func1) { a++ } else { b++ } ` in JSON? Because that is valid Jeebox code. It parses this into an AST. When you parse C, or C++, or Java, or python, or anything, the compiler creates an AST for that language. Jeebox does the same. Except it doesn't care what language the AST is being parsed for. As far as Jeebox is concerned, it's just data. Yes I was right. People find the idea of combining extensibility to "describing code" to be very new to them and hard to understand.
I did read the "introduction" and "learn more" parts. You basically parse a token tree. with some amount of token customization. I mean, as far as I can see it's not even possible to do a basic things like use "&lt;"/"&gt;" or "begin"/"end" for bracketing or specify a custom token like a [2019-05-04T19:50:11Z](https://en.m.wikipedia.org/wiki/ISO_8601). Yet you spend the entire readme waxing poetic how awesome this thing is without even giving any non-trivial usage example. So yes, you are baselessly claiming things.
[removed]
&gt; People find the idea of combining extensibility to "describing code" to be very new to them and hard to understand. Ever heard of LISP?
It would be interesting to see a comparison between these, boost's, and EASTL's
Honestly the C++2a standard is so insane. Ranges and concept at least are in... That's a new language practically
from my website: [http://jeebox.org/user/introduction](http://jeebox.org/user/introduction) An interesting, and exciting thing, is that Jeebox's abstract syntax tree (AST) is defined purely in terms of strings, and lists. Nothing else. This makes Jeebox easy to understand, process, and generate. In Jeebox, an AST for "a=(b+c)" would look like: (rel: (thg: "a") (sopp: "=") (bra: (rel: (thg: "b") (sopp: "+") (thg: "c") ) ) ) That AST is also valid Jeebox, meaning we could parse that and turn it back into "a=(b+c)"
I mean, look at this gem: x = a - b - c - d x = (a - (b - (c - d))) // same order as above! And it's not configurable! It is even claimed that: &gt; With no predefined operators, precedence is impossible. Which is simply false. Haskell [does it](https://wiki.haskell.org/Keywords#infix.2C_infixl.2C_infixr) for example.
In my opinion you don't need a book these these as they get outdated way to quickly, they are basically outdated once they are printed.. I have learned php back in the day with a book and almos half the assignments didn't work anymore (the solutions) as it was already to old. which I did use a lot ( I did come from another language) and i believe it is still relevant as it is being updated is learncpp.com I hope you can review and if applicable make use of it, as it helped me a lot when starting out cpp and still use it as a reference sometimes!
As u/xeroage notes I mean that //do something will almost certainly throw. Even if it does not throw now, sooner or later someone will add code that does throw. When I say cannot be made to work I mean that essentially you have to limit yourself to C code between the malloc and the free. I explain this, not for you, but so the original poster knows what I mean. I learned about this problem originally many, many years ago from your training materials. In fact whenever a new programmer joins my team with a background mainly in C. I make them watch your videos on exception safe code specifically so I am sure that they understand why they should not use that perfectly valid C idiom in C++. So, thank you for posting those.
I had seen that. Thanks for posting about it. I'll have to try it out on a new project. Should've mentioned it in my op
Yes, but in C if you are really careful you can remove the memory leak with that pattern. Which is to say that the pattern, in C, works in the general case. In C++, in the general case this pattern results in a memory leak in the error path. In my experience working with C programmers, in general they know that they are supposed to use destructors and smart pointers, but they see it as a convenience thing. Thus when they are in a hurry for some reason they will throw in a naked new/delete thinking, "it is only one more line of code. No reason to fix that right now". 2 years later and you are in a mess where you are having to consider turning off exceptions.
There is only one reason. It's minimizing dependencies from huge libraries like boost. Not everyone can include the boost to their projects.
Hah, yeah. The example is a toy, but I will be glad for that change as well.
I actually have a need for this, and was hesitant about including all of boost; will be looking into using this!
It is not surprising that it took you a while to figure it out. It takes many years to learn C++. If you stick with it you will find that things that seem dumb to you right now will make perfect sense when you have more experience. Not everything, the language is not perfect by any means, but a lot of the things that seem dumb now will some day be obviously the way that you do things. The thing to realize is that right now you communicate in C++ about as well as a 4 year old does in their native tongue. When you read code written by someone that is fluent, it seems complicated and you have to look things up just like a kid would have to if they really wanted to understand what their parents were saying. Children are not frustrated in this stage because the adults around them are capable and willing to talk down to them when they need to understand something. Codebases do not work this way. In general it is a bad thing when half a codebase is stylistically immature. Some programming languages have tried to solve this problem by making the language so simple that there is no difference between mature and immature style. This has its pros and its cons, but C++ is the polar opposite of those languages.
If you want to use Qt, the simplest solution is to download it through digia's website and install it that way. Installing qt creator will give you qmake as well, which is a good build system. Qt Creator as an IDE is actually good for non-QT programming as well.
It's very simple. Is "time reading code" &gt; "time not reading code"? You seem to be trying very hard to argue that you spend more time reading code than not reading it. Here's a simple test demonstrating the principle. How many hours did you sleep last night? And how many hours have you looked at a certain source file? And you still want to argue that code is read more often than is not read? Seriously?
Doesn't make sense to me to deprecate bind, since it is far more compatible than lambdas, it works from C++03 onwards. And maybe it's just me, but since code is supposed to explain what is going on, seeing that I'm binding a foo, a bar and a booz is _far_ more comprehensible to me than a bunch of ``{}()[]`` brackets that take my mind back to Common Lisp puns.
Thank you. One observation. Your readme could do with a change in focus. Perhaps move the reference API stuff and instead put some examples and or benchmarks or tips in the readme?
The FLTK section is easy once you get it working. It teaches you how to work with third party libraries. It took me ages to get it working with Visual Studio originally, but I did post on Stack Overflow that should help anyone else with similar problems. Worth doing if you are not too pushed for time.
A complementary set of containers for flexible arrays etc. https://magnum.graphics/corrade/
C is not C++. You don't learn to play the drums so you can learn the piano.
True, there are some things updated for C++17, for C++20 the best things is to read the proposals/technical specifications for features that have been approved for inclusion into C++20 and will be supported by GCC 9.
Where's the kaboom? I was expecting an earth-shattering kaboom!
What is the reason behind functions like insert having two versions: one taking `value_type&amp;&amp;` and the other taking `const value_type&amp;` rather than having one templated function taking a universal/forwarding reference and then calling std::forward inside the function? I'm sure I've seen this in other places like std map insert overloads or (can't remember precisely, may be wrong) boost's flat map (so I'm not trying to point out that I think you're doing something wrong) but I'd love to know why? Are there upsides/downsides to doing it either way?
Is there any good reason for that, bind is so useful to pass class member function pointers to callbacks and as arguments to function and also for passing functions with partial arguments? So, what should be used instead of std::bind, I know that, it is possible to use lambdas. However, they are more verbose than just using std::bind.
Boost is one of best tutorials about new C++ containers such as smart pointers and std::function as most of them come from Boost.
Very short summary: * You have to learn a weird mini-language to read and write bind expressions. In contrast, lambda syntax is much easier to learn, and lambda bodies are ordinary C++. * The way that bound arguments are captured and passed (as lvalues) is not always intuitive. * The time at which bound arguments are evaluated is not always intuitive. * bind() can inhibit optimizers by storing function pointers/PMFs as data members, whereas in a lambda, they are ordinary candidates for inlining. I believe that Effective Modern C++ has a good explanation (as I exchanged emails with Scott Meyers, finding bugs in several of his early draft's bind expressions). Now that lambdas are generic, have init captures, are constexpr, etc. they really do supersede bind. Don't be tempted by bind's apparently shorter amount of typing - it has far more cognitive load. (And I say that as a Standard Library developer who usually recommends library machinery over core machinery.)
Ok, thanks for the insightful explanation.
&gt;C is not C++. Where do I contradict this statement? &gt;You don't learn to play the drums so you can learn the piano. No, but you often learn to play the piano before moving to an organ. Or a snare drum before moving to a complete set. &gt;To expand, this is the prevailing advice from C++ experts and advocates, not just my own opinion. "Experts" have also made ludicrously wrong statements in the past. Appeal to authority alone is rarely ever sufficient. ___ Yes, yes: we all know C++ is not C. The point is that C++ still has aspects of C inside of it. Yes, the standards are vastly different now. Yes, the paradigms supported by C++ are insanely larger than what C provides. The ABIs are not the same. That is not what I'm saying. What I'm saying is that C++ at its core is a language that relies on a much more complicated model of thinking than C does. Because of this fact, using C++ as a vehicle to teach systems programming is far from optimal. I *like* C++. And I mean real, modern C++. But I know that C has its place, and it serves as an excellent mechanism for teaching low level basics. C++ makes the process exceptionally more complicated. Newcomers without a C and asm background won't be able to reason about how the compiler translates the C++ code, which you *must* have in order to effectively use the language.
This project structure mentioned in the post is mostly used in programs for Unix-like systems and may not work if you want to build and port your app for Windows. &amp;#x200B; The project structure is optional and there is no standard one. I would place all headers into ./src directory without sub-directories for an small project as it makes easier to switch between headers and sources. For consuming and using libraries the best deals are Cmake building system and Conan package manager which requires a Python installation. Conan fetches the library source code from remote repositories, builds and caches them for your project. In the old days, the libraries were compiled and installed manually in the system. A good CMake template with conan integration is [https://github.com/conan-io/cmake-conan](https://github.com/conan-io/cmake-conan) * Or clone/download compile the libs manually and put them in the lib/ directory and include the headers relatively With git clone, curl ... and so on, or using nuget if using Windows with Visual Studio, but you shouldn't, better let Conan, the brave package manager do it. &amp;#x200B; * Other ways? my background is pip/python and NPM/js. I'm aware the situation with package managers in C++ is... unique and I'm not looking for a package manager but then why does my project structure have a directory for libraries? isn't that like node\_modules? &amp;#x200B; You don't need a directory for libraries, in C++ hardly you will find pre-compiled libraries as in Java due to compiled-code built by different compilers are not compatible binary compatible. &amp;#x200B; * When I say libraries I am referring to static libraries because I intend to deliver a self-contained tool that needs no external dependencies from the user. It is not always it is possible due to license requirements, for instance, QT that has LGPL v3 license that does not allow you to static link QT dependencies, unless you disclose you source, so static linking in this case requires a commercial license. To deliver a self-contained Application just deliver it with all DLLs or shared libraries you need. &amp;#x200B; So a CMake skeleton for starting a new project with external libraries fetched with Conan can be: &amp;#x200B; cmake_minimum_required(VERSION 3.9) project(myproject CXX) set(CMAKE_CXX_STANDARD 17) # Download automatically, you can also just copy the conan.cmake file if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake") message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan") file(DOWNLOAD "https://github.com/conan-io/cmake-conan/raw/v0.13/conan.cmake" "${CMAKE_BINARY_DIR}/conan.cmake") endif() include(${CMAKE_BINARY_DIR}/conan.cmake) # Add dependencies here: conan_cmake_run(REQUIRES # Ranges to be added to C++20 range-v3/0.5.0@ericniebler/stable # Fmt format library fmt/5.3.0@bincrafters/stable BASIC_SETUP BUILD missing) add_executable(executable1 src/main.cpp src/src2.cpp src/src3.cpp) # Assumes that all headers are in src/ target_include_directories(executable1 ./src) target_link_libraries(executable1 ${CONAN_LIBS}) INSTALL(TARGETS executable bin) Some libraries such as QT, Gtk and others has to be fetched manually.
Cool :) I recently wrote a `set_adaptor` pretty much same as your `flat_set`. After a quick look at yours, I came up with following comments: Issues: * As far as I can tell, your range and initialiser list insert / construction have O(n^(2)) complexity unless the input is sorted. If you were to insert to end and then sort and remove duplicates, O(n log n) should be achievable. Suggestions: * Add `contains` that's going to be in C++20. * Your `emplace` doesn't construct the element in place. It creates a temporary and inserts. You could instead `data_.emplace` to end and rotate to correct position (or erase if it turns out to be a duplicate). This is a bit tricky, but doable. Questions: * Why not rely on implicit copy and move operators / constructors? * What is the point of `uber_comparer_type` instead of using object of `Compare` type?
If you really wants a self-contained binary, take a look at Lazarus Pascal IDE, it is similar to Delphi and allows building statically linked apps almost without any dependencies. Lazarus has a drag and drop UI designer. In this link there are lots of apps built with Lazarus: [http://wiki.freepascal.org/Lazarus\_Application\_Gallery](http://wiki.freepascal.org/Lazarus_Application_Gallery)
Sorry, I missed it. But what about iterators? &amp;#x200B; dfor( auto i = lst. end( ); --i; i != lst. begin( ) ) std::cout &lt;&lt; \*i &lt;&lt; "\\n"; &amp;#x200B; &amp;#x200B; I view an index as a special type of iterator that needs the container for retrieval.
I've had trouble getting `boost::flat_set` to work with `std::inserter`.
Thanks for your brilliant comment! All your issues are already in progress :-) Answers: &gt;Why not rely on implicit copy and move operators / constructors? You're right. I'll remove custom implementation and make it as default. &gt;What is the point of uber\_comparer\_type instead of using object of Compare type? It's convenient for lower\_bound/upper\_bound/equal\_range functions where value pairs are compared by their keys.
I honestly don't understand the aversion to boost. Downloading the library doesn't take long, and you only need to do it once, and only for development. You don't need to compile anything. Most of boost is header-only, including flat_map.
Thank you for the comment. &gt;Perhaps move the reference API stuff and instead put some examples and or benchmarks or tips in the readme? You're right. I'll do it a little later.
It has more similarity with Lisp macros, templates are type-safe limited code generators. For instance, function templates generates object-code for overloaded functions. Concepts are just for making types requirements constrained, explicit and more readable. But, there is already lots of compile-time DSLs built with templates such as expression templates for optimizing loops in linear algebra code at compile-time, Boost.Python, and so on. It would be good if C++ had a lisp-like macros for generating arbitrary code at compile-time and also defining new control structures and reducing boilerplate.
&gt;It has more similarity with Lisp macros, templates are type-safe limited code generators. For instance, function templates generates object-code for overloaded functions. Concepts are just for making types requirements constrained, explicit and more readable. But, there is already lots of compile-time DSLs built with templates such as expression templates for optimizing loops in linear algebra code at compile-time, Boost.Python, and so on. It would be good if C++ had a lisp-like macros for generating arbitrary code at compile-time and also defining new control structures and reducing boilerplate. You're right on the lisp macros. The reason I was referring to ML is because even though templates are more in line with lisp macros in terms of their purpose, the type safety draws a stronger parallel to ML. The pattern matching equivalent to template specialization is also more ML like than lisp like. At least, that's how I see it. ML's union types in templates can be emulated with concepts, for example. My understanding of Scheme isn't advanced by any means, so as far as ML like type systems are concerned I don't know how to achieve that. I've only actually used Racket when it comes to lisp.
What is the difference with the recent google flat tables?
I tried to look for "google flat tables", but I didn't find anything. Which google library do you mean?
Or in C++20, `std::erase_if(vec, lambda);`
It is in their abseil open source package. Here is a mini wrapper on their implementation that is a bit slower but does not spike in memory. https://github.com/greg7mdp/parallel-hashmap
&gt;oh wait is this not an unordered map? Thank you for the link. It's an interesting library! But yes, it doesn't have flat\_map (like a sorted vector for example), only flat\_hash\_map but it's the different container for other purposes.
That’s a beautiful library you wrote. Great job!
Thank you, sir! :-)
As c++ is almost a superset of C, I don't think there are any fundamentals that you can teach easier in C than C++. On the other hand, a) there is no advantage to first teach students e.g. typical c-habits that are redundant in c++ (little things like type defing structs just to avoid writing struct everywhere, strcmp instead of using "==", and bigger things like generic programming with macros) and b) c++ makes writing the scaffolding around the part that you want to explain in a particular exercise much easier. Btw. Have you seen Kate Gregory's Talk about stop teaching C? Don't you find her arguments convincing in general or just not in the context of an explicit systems programming course?
Since I srarted learning C++ recently, this presentation looks like a helpful source to me: https://www.youtube.com/watch?v=2olsGf6JIkU
One reason for `std::map` might be ABI-compatibility. The const ref overload was the only one before C++11.
Making them templated would allow passing other than value_type (if value_types constructor allows it) which is often undesirable. If you pass wrong type parameter, you wont get nice, easy to read, error message because of the additional layer of template function. Limiting types allowed by the template with enable_if will just cause long error messages. IMO implementation without templates is nicer to use.
I've been using these for some time, would be interesting to have a benchmark : https://github.com/pubby/flat
What the hell is with that font? I didn’t even try to read it.
Most aversion to boost is it's affect on compile times; so many complex templates need instantiating for the simplest of modules.
What's the problem?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bkvhco/need_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Do you have some code/project examples somewhere on the site?
The very curly font that most of the text is in is incredibly difficult to read. I tried for a paragraph or so but it hurt my head so I backed out.
It’s very unpleasant to read.
&gt;For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.
True, but there's not even a question here…
Thank you. Will delete this and repost there!
`enum`s are designed to do **enum**eration. They do what they say on the tin. They only support integer values, and mainly consecutive ones at that, whereas in web and database parlance "enumeration" would encompass any closed set of values — and best practice IMHO is to avoid consecutive integers unless there's a clear benefit. But either way, it's a computer concept which is common to all programming languages, and even other technical tasks outside programming, so you probably don't need to restrict your background research to only C++.
Please don't.
Thanks for the reply. I appreciate the time taken. I feel a bit silly for not realizing it should be common and not just a c++ concept, will settle down and do some more in depth reading now. Thanks again.
One of my favourite talks which inspired this post.
&gt;For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow.
Appreciate all the information, it clears up many things. Why wouldn't this project structure build for windows? does it have anything do with the libs inside `/libs` being precompiled? I am not sure I need to use CMake + conan. because unlike python or js I will probably not need more than 10 libs in total.
font-family: "Comic Sans MS", cursive, sans-serif;
Another reason is that you can construct the type with list initialization : `std::vector&lt;Point&gt;{}.push_back({1, 2})`
How does this work? Is it using link seam (mocking at compile time) ?
What is catch.hpp any why does it have 14k lines.
doesn't look too bad to me ? https://i.imgur.com/A9ybvMr.png
&gt; the type safety draws a stronger parallel to ML the types in C++(17) templates are akin to values in LISP. And from that point of view, they almost don't have any "meta-type" safety since the only possible "meta-types" are `typename` and integral types.
It's a framework for unit-tests: [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)
If I understand correctly, this implements an associative container with totally ordered keys on top of a sequential container and relies on binary search for item location. I am wondering however, what would be the practical application for such a container? For scenarios where you don't need ordered keys, a modern hash map is going to be much faster. For scenarios where you need ordered keys, a B-Tree (or alternative) is going to be much faster. The only situation where you implementation is better is if you frequently need to iterate over all items in the container in order...
The problem with teaching people C is you are teaching people the wrong way to do things from the start. You should not have naked new and delete dotted all over your code. You shouldn't need to worry about null references and pointers all over the place. People shouldn't be using printf or scan. They should be using your, vector, references, shared ptr etc. But, this all depends why you are teaching cpp. If you are teaching o/s designers with a background machine code, teaching C first might make sense.
Very hard to read due to the font :(
I wrote an article based on recent code. Will be glad to hear from you. :) You can simply comment here, but feel free to mail me ([luncliff@gmail.com](mailto:luncliff@gmail.com))
After searching for examples my impression is that this falls into the same trap that most mocking seems to fall into: &gt; ASSERT_WAS_CALLED(t-&gt;Forward()); is not a useful test. DO NOT test how something is implemented! Doing so removes the by far largest advantage that unittests offer: The ability to change the implementation without fear of breaking something. If you change code and that breaks a test without introducing an actual bug your test is garbage and you are best of deleting it entirely. The same is true for &gt; private methods For the purpose of unit-testing those do not exist and therefore should not be mocked or tested. Ask yourself whether you would consider this a reasonable request: &gt; “I want functionality $F and I want it to be implemented via a private method that is called `foo`.” If you don't think that it is, don't test the part that you don't think is a reasonable requirement. For more details see [this talk by Ian Cooper](https://www.youtube.com/watch?v=EZ05e7EMOLM) that I cannot recommend enough (yes, it's about TDD, but much of what he says is entirely applicable to testing in general). Mr. Cooper goes as far as recommending against mocks in most cases with his exceptions being stuff that is hard to do in tests or prohibitively slow (like talking to a full production database with queries that take long). After watching his talk for the first time I actually went to delete some tests and understood why I had never felt the need for mocking (because laziness had me do it correctly from the start).
No probs. :) Well, the issue with that one is that it only accesses the element of i, not the index. The problem the guy was having was that he had two containers with the same length and he wanted to iterate both in parallel without having to risk messing up with the index underflowing. Otherwise that's fine (although personally I'd prefer something like for ( auto const &amp;e : list ) { ... } just for brevity. But in the case at hand this won't really do, since he'd have to do something like: auto i = it - vertices.begin(); /* do something with normals[i] */ in the body, which he didn't seem to want to do. IMO, the absolute cleanest solution would be the first thing I recommeneded (although it requires the programmer to implement or include a third party zip-function): for ( auto &amp;[v, n] : zip(vertices, normals) ) { // do something with v and n } or the more traditional (and likely better performing): assert( vertices.size() &gt;= normals.size() ); for ( size_t i=0, end=vertices.end(); i&lt;end; ++i ) { // do something with vertices[i] and normals[i] }
Yeah the fact that the whole page reads like an infomercial without any example code or even technical details feels dubious
\&gt; Why wouldn't this project structure build for windows? does it have anything do with the libs inside /libs being precompiled? &amp;#x200B; One reason is that it is not a good idea to mix binary with source files, another is that hardly you will find per-compiled C++ libraries because C++ compilers does not have a standard ABI Application Binary Interface, so if the library vendor build it with GCC, users would not be able to use it with Visual C++, aka VC++ compiler. To make a pre-compiled library, the vendor would have to pre-compile it to every possible compiler. Only C libraries can be distributed in pre-compiled way such as C# dll's or Java jar packages. But if you want do it, you can, it is just the following procedure which is cumbersome: &amp;#x200B; cd project mkdir -p ~/build git clone library.... # Download source # Install with configure if it has it. ./configure --prefix=REPOSITORY_INSTALL_PATH &amp;&amp; make install # Or cmake -Bbuild -H. -DCMAKE_PREFIX_PATH=&lt;PATH to PROEJECT LIB&gt; cmake --build build --target install \&gt; I am not sure I need to use CMake + conan. because unlike python or js I will probably not need more than 10 libs in total. &amp;#x200B; Because CMake and Conan handles the dependencies automatically and makes the build reproducible as you use only specific versions of the library. Conan downloads, builds and caches the library only once. Anohter reason to use CMake is that is it makes easier to build the same code everywhere and it is supported by many IDEs such as CLion, Visual Studion on Windows, QT Creator everywhere, KDevelop and so on. All you need to do to open and build a project with Cmake is to open it with any supported IDE. Unlike Cmake, Linux's Makefiles are not supported on Windows by Visual Studio and they only work with GNU Make; Visual Studio Solutions project files only works with Visual studio. &amp;#x200B; Moreover, lots of libraries are packaged with CMake. In the case of header-only libraries, nothing needs to be pre compiled, they can copied to the project freely and all it is need is to add them to the include path, however even in this case using CMake and Conan or only CMake is a better deal.
I would note that, like all sorted-vector associative containers, there are some differences with the standard containers. They are *near* drop-in replacements in a compile-time sense, however there are run-time differences: - No memory stability: any insert may invalidate all iterators and references, any erase invalidates iterators and references to any element sorted after the erased one. - O(N) complexity of any insert/erase operation: not in the number of comparisons, but in the number of copies/moves. The latter points out why they are not *quite* drop-in replacements for the standard containers: they do not support elements that can neither be copied nor moved. This does not detract from using the library, of course; I just feel that a note in the documentation to remind would-be users of the differences would be useful. --- On another note, I was wondering if you had experimented with other memory layouts. One of the issue of the sorted layout is that a binary search on such a layout is not cache-friendly: - Each "jump" leads to another cache-line. - Worse, each "jump" leads to one of two other cache-lines, and it is hard to predict which. This is in contrast with the Eytzinger layout, for example, in which the children of a node are adjacent: - Each "jump" leads to one cache-line, which can be pre-fetched before the comparison is even made. - The root and first few levels are spread around fewer cache lines, and thus more likely to be in cache. And, while harder to implement, it also benefits from fewer copies/moves when inserting/erasing in general... unless you need to rebalance the tree.
I don't think it reads as an infomercial, it's flat out an advertisement for the product. And honestly: Since it is on topic and some people may consider it to be potentially useful (see my other post for why I argue that it probably isn't), I don't think that posting this here upon the initial release is something that should be banned. We have similar posts for lots of other projects on a regular basis. Of course that doesn't change the fact that there really should be code-samples on that page.
&gt; &gt; &gt; Mr. Cooper goes as far as recommending against mocks in most cases with his exceptions being stuff that would break the isolation between tests or is prohibitively slow As the author of a different mocking framework, I completely agree with him on this. I mentioned as much in my C++Now talk in 2017. Most of the time your code should be structured such that you have classes that do things that need tests, but that don't have dependents, and classes that pass information back and forward, but that don't do anything so they don't become better from testing.
Good bot. You are right.
It all depends on where you draw the boundaries of your codebase. Too small chunks will result in primitive tests that doesn't serve any purpose while too big will make it too complex to bring sane logic coverage. That's one thing, other it that there are things that you have to mock in order to get stable and deterministic runs, for instance: network, time and date, random numbers or external hardware - I work in mobile networking and and cannot set-up some electromagnetic field generator every time I run unit tests. ;)
I find that Microsoft EDX courses in C++ are quite nice for interns.
As far as I could read from the docs, it requires `-O0` (probably to turn off inliner and passes that generate additional symbols, like constprop), debug symbols and that mocked functions has to be at least 5 or so bytes long. This makes me almost certain that this library takes the name which you give in the FAKE macro, finds all the symbols that belong to it and overwrites their code so that it calls some of their routines instead. I think `uprobes` work in similar way.
https://designforhackers.com/blog/comic-sans-hate/
We had some places where boost::flat things gave some cheap performance improvements. - iterations - like you said - building from some existing sequence of known size - you can preallocate/reserve, insert elements and sort it once at the end - copying - one allocation and possibility to optimize to memcpy by the compiler
I did manage to get it working after searching various "how to" articles. I agree that the examples are very easy (so far) it just feels cumbersome to start each solution with copying all of the .h/.cpp files and changing some of the Linker settings. Maybe I shouldn't be so focused on making separate solutions for each exercise and just set it up once and do all the exercises in one. I think party of my problem was using Code::blocks for a while before finally using Visual Studio. Thanks for the response!
The C++ Nanodegree is very new. I believe the first sessions started in mid-life April.
It's interesting but I'm wondering what's the example application of such event pooling with coroutine ? and benefits compared to using threads ?
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bkoxcr/c_course_for_experienced_developer/emk1mbi/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bkhe2d/critical_things_i_need_to_know_about_stl/emk1nlf/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bkd1x2/how_should_i_add_dependencieslibraries_to_my_c/emk1o8v/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
My understanding is that he is actually going further in that depending on other functionality (that should of course be tested as well) is perfectly fine. His example for isolation-problems is with a database that might be modified by different tests so that the order in which the tests are run could break something. One solution he mentions for that are in-memory databases that are fast to set up and tear down. He makes a great deal out of the *unit* of isolation not being the class (or whatever else is applicable) but the test. If the test ends up calling methods of 20 different classes that's not too much of an issue since that is an implementation-detail.
Terrible font and full of bad memes. No thanks
All those who are finding problems with the website Read it here https://dev.to/bhupesh/30-seconds-of-c-4egn
In short, I was just curious about the look and feel of the code. The benefit of such a event based code is that we can have an alternative of future-promise pattern. future-promise is simple for one time value transmission, but becomes complex as we add loop or branching condition. In contrast, co_await statement is simple and delivers clear code in same situation.(at least its syntax does, in my opinion). Also the implementation doesn’t require that much cost of shared state management.
Compilation times.
Take the `emplace` suggestion with a grain of salt. I've been thinking it over, and I don't think anymore that rotating into place is any better than moving the temporary into place.
It's more about blocking vs non-blocking IO. With coroutines, you can still use multiple threads. I am sure that there are many articles about the benefits of non-blocking IO on the internet.
Indeed we can use threads with coroutines. But I think we should avoid if possible since the multi-threaded code is usually annoying to debug :)
The way CPUs pre-fetch and cache memory, it can be more performant if your container values are contiguous in memory. See https://channel9.msdn.com/Events/Build/2014/2-661 @ 23:30
Sams should stop trying to teach C++ "in one hour a day"
Threads do not scale to tens of thousands!
&gt;Take the emplace suggestion with a grain of salt. OK. But I'll think about it too :) &gt;But in a set, the values are keys :) Oh, I thought I removed it from a set, thanks again!
If the keys of the map / set are long such as strings may be, then hash function reads all of it to calculate the hash. Sure, you could use a custom hash function that doesn't, but you must manually figure out how much is enough and risk bad performance if you guess wrong. Binary search also has a worst case: If keys have very long common initial substrings. These are usually rare, but not always. If the map / set isn't very big, then the difference in *asymptotic* performance of lookup is irrelevant. If there are many lookups, the absolute performance may still be relevant. Also for a small map / set, binary search into a vector shouldn't have many cache misses. A search tree is going to have cache misses since the nodes are somewhere else. So, to conclude: If the map / set is small, and the keys are long with no long common initial substrings, and lookups are frequent, then an ordered vector may be better than either flat hash map or a search tree. Possible real world use case: Storing headers of a HTTP request.
Does ABI-compatibility matter at all unless you're going to modify your standard library to implement `std::map` using this? Which has bigger problems since this doesn't meet the requirements of `std::map`.
I mean `std:: map` has two overloads because of ABI-compatibility.
Oh, the guy asked about this in general, not just in case of the linked library. Now I get it :)
Thanks - I'll check it out.
&gt; For the purpose of unit-testing those do not exist and therefore should not be mocked or tested. Ask yourself whether you would consider this a reasonable request: This reasoning which I've heard many software engineers espouse, is really flawed, and is a great example of thinking in terms of black-and-white in terms of engineering trade-offs. Yes, it is *preferable* to avoid testing private methods because if you change the implementation only, some of your tests will break or need to be changed, even if the new implementation is correct. However, that's all it is, a pro vs a con. The goal of unit tests isn't just to inform you whether your code is correct. It's to inform you of it in a sufficiently fine grained way that you can track down the problem as fast as possible. Sometimes you have classes that are fairly complex, but have a relative limited API that doesn't allow querying many details. This is often a good software engineering choice because it encapsulates well, but it can make it hard to get sufficiently fine grained tests. Languages like Java have explicit support for this because they have a "package only" access control. C++ doesn't so you are more likely to be in a situation where you do actually need to test via private methods. A good generic example that I like to use is writing open address hash tables. They have fairly complex invariants, which certainly cannot be verified using the public API. If you are doing unit testing of the public API only, tracking down bugs is hard because in many cases an invariant variation can occur long before you actually see the observable problem in the public API through your test data. So having a private method, used only in the unit tests, that verifies the invariant, can make your unit tests much more usable in practice. I do agree with your main point about over-mocking though. It's a lot of work and in most cases aside from the feeling that your unit tests are more isolated, it doesn't improve the tests at all in terms of the information they give you when a bug is detected. I mostly only mock things that require external resources as well (writing things to sockets, database queries, etc).
This was something I always had on my list of things to do. Thought was that it would be faster because of prefetching. Is it?
What's wrong with EnTT?
Hmm I know what AST and parsers are in general. I'd say that YAML and JSON are also languages - they have a grammar (a notation), but of course not things like control flow, so they're very simple languages (actually the grammar of YAML is not that simple...). So it would be great if one could take the grammar rules of YAML or JSON, put it in your parser, and then your parser can parse it accordingly. At least that's what I'd expect from a parser library? In your other comment it seems like you've invented a new custom format to describe grammars. Why did you not use existing notation like e.g. EBNF? In that way one could take the EBNF of existing languages or formats (YAML/JSON) or write an EBNF for a custom language and then use your library to parse it. It would be a hassle if one also has to learn your custom grammar notation. Sorry in case I am still just misunderstanding. :-)
Instead of another "Wow! Coroutines!" article, I'd much prefer to read one of these two (hypothetical) articles: * Tricks and traps in coroutines: best practices for use * When to use coroutines instead of explicitly keeping the state of the computation in a class It seems to me that a coroutine is essentially a thread of execution and a context that holds variables. So you always have two solutions - the coroutine, or an explicit state class that keeps track of the state and where you are in the calculation (aka "What we do now do get the effect of coroutines"). Now, the explicit state class is more work, but seems to have a lot of advantages. You can move it, copy it, potentially even serialize it or pass it across threads or even processes. Since you completely control the "context switch" you can easily instrument it, or add run statistics. And coroutines have problems. Context switches are expensive. There's the question of how much stack to allocate. In the production project I saw it used in, two different engineers, neither of them fools, made the same class of error in two different ways - capturing a variable by reference in a coroutine and then (occasionally!) executing that coroutine later after that variable had been freed. When I use a C++ coroutine, I know somewhere there's this weird invisible "context state object" floating around and a lot of magic keeping track of where I am, and I get nervous. On the other hand, it's easy to come up with computations that seem shorter and clearer when implemented using coroutines. In many ways, coroutines correspond better to the actual structure of the computations. So this is why I want these two hypothetical articles - so I can actually figure out when to use coroutines, and how to do it without shooting myself in the foot.
On line 34, is it necessary to call std::move() on the result of co\_await? Doesn't co\_await produce an r-value?
I try to get up early and work on my private stuff before I go to work. Not super easy to focus on programming at 5:30am but that is the only way for me to do something. Even if only do just 30m or 1h of actual work, its better than nothing. I also try to read during my commute.
Another approach to verifying invariants, which I think D encourages with its `invariant` construct, is to treat them as what they are: pre- and post-conditions of your member functions. Hopefully this will become more common in C++ as well now that we're finally getting contracts.
Life is important even outside C++. If you feel you don't wanna develop private project don't di them!
You're right on about hand-written state machine objects- they can move/copy/serialize/etc. I'm not sure about the rest though. C++ coroutines aren't stackful, so context switching is (or should be) about as expensive as a normal (non-inlined) function call, and their stacks have a fixed size. State machine objects can also hold onto references too long (though maybe it's more obvious when they do so?). I agree it would be great (maybe when there's more implementation experience) to have some rules of thumb around how to think about that "context state object." When its allocation is elided, what goes into it exactly, what you can do with it, etc. (I still wish coroutines could have been standardized *without* that implicit maybe-probably-we-promise-elided allocation...)
give it some time. trying to force it will just burn you out
Hi. Yes, you are still misunderstanding. There's no grammars in Jeebox. Its just Jeebox. &gt; So it would be great if one could take the grammar rules of YAML or JSON No... As I said, jeebox is just Jeebox. It's not JSON, or YAML. I take it you didn't download it yet or try compile it? Actually I'm in the middle of a bug-fix. And I don't know that it works for Linux/Windows, just MacOSX. But the examples should work assuming you have a mac. I can walk you through them if you are interested and can get it compiled. Assuming you have a Mac its quite easy, or I can just send you the files. Then you can see the parse-tree yourself. It is extensible. And there are no grammars. XML also is extensible and has no grammars, so... yeah.
&gt; `ASSERT_WAS_CALLED(t-&gt;Forward());` is not a useful test. _Most_ of the time it isn't. Sometimes it is. For example, a recent project of mine controlled a large number of LEDs through a serial port. For tests, all the hardware IO is mocked out. At the end, we collect all the calls and values and see if we're getting the frames we expected. Also, sometimes you really want to test edge cases in your code, or conditions that are impossible to achieve in "real" objects - for example, to emulate software components behaving badly, network or disk issues. ---- &gt; For the purpose of unit-testing those [private methods] do not exist and therefore should not be mocked or tested. Again, I agree with you _most_ of the time, but not all the time. Here's the most common use case for me. I am creating a new function or method, and 80% of it is straightforward code that's hard to get wrong. Now, I'm going to test all of it anyway, but I can write good tests that will cover that 80% nicely in a fairly short time and any bugs will be obvious. However, there's 20% that's hard - has complex logic, a lot of edge cases or a lot of possible cases in general - several dozen lines of code that makes me sweat and will be hard to debug. Inside the implementation of the module, I pull out the difficult 20% as (hopefully only) one function, and carefully implement it - then I write a battery of tests for just the difficult 20%, edge cases, large collections, anything I can think of. I inevitably find something! Long experience has shown me that investing the time in this "white box testing" of short, logically complex, hard-to-reason-about sections has made for much more reliable systems overall. Now, I don't want to make that code public - because I don't want to document it, and I want the ability to change its interface at will. But I _do_ want to test it exhaustively. Testing the key part only within the context of the whole is not a good way to go. Often I want to try edge cases that might not appear to be possible in the context of the whole module. I want to beat on _just this part_ until it is perfect (as well as, of course, testing the whole module). --- I upvoted you anyway, because your heart is in the right place. You're quite right that you should test for important things you need to be true, not arbitrary boring conditions - but you should also be testing to try to _break_ your code, and sometimes that means mocks, and sometimes that means testing private behavior! Once I understood that testing should be hostile, should be me aggressively trying to reveal problems in my own code, and not a feelgood to pat myself on the back, I changed dramatically how I tested.
&gt; C++ coroutines aren't stackful, so context switching is (or should be) about as expensive as a normal (non-inlined) function call, Ah, interesting. I was using the original Boost coroutines, and they definitely had a fixed stack size. I seem to remember the Boost coroutines version 2 had some way to set the stack size? Anyway, I wasn't so excited to keep up with it after that. ---- So wait. If C++ coroutines aren't stackful, then where do my stack variables go when I call `co_yield`?
Its better on the desktop, but on the iPhone its very very hard to read because its cursive.
You don't have to. I don't code outside of work. I would only do some fun learning coding challenge from time to time to practice other languages or to learn something new. Just keeping up with tech is enough for me.
&gt; So wait. If C++ coroutines aren't stackful, then where do my stack variables go when I call `co_yield`? They go in that context state object, which is basically the coroutine's single fixed-size stack *frame*. Or more specifically, just the parts of it that live across yield points- so, exactly what you'd put in a hand-written state machine object. If you `co_await` another coroutine, your state object just stores a coroutine_handle to its state object, which is a separate allocation. So Boost's fixed-size stack is replaced with a linked stack. Ideally these allocations can be elided and placed in the caller's state object, effectively computing the maximum needed stack size automatically, though I'm not sure how often this happens in practice today.
Coroutines are essentially like lambdas with multiple entry/suspention points. Your stack is stored in a hidden struct that is passed around to the coroutine block. So switches are cheap and the code can potentially even be inlined. The major issue I see is that the way how coroutines are proposed in C++20 may involve unpredictable heap allocations.
&gt; I fear that a direct source for this is an illusion and that I will have to continue slowly gathering all these informations by myself simply by just using C++, reading alot, Stackoverflow, r/cpp - just like I've been doing. I do it this way, works alright.
&gt; There's dozens of great open-source projects developed I'm working on a code generator that blends open and closed source. One of the strengths of the closed source part of my project is it doesn't have to be portable. Portability is great, but it takes a lot of work to get there/maintain it. With my closed source programs, I'm able for example, to take advantage of compiler extensions like #import. I can also use the newest language features.
Same here. I started about 6 months ago and by the time I've done 8 hours at work the last thing I want to do when I get home is more programming. Maybe if I think about moving jobs I'll start doing more things at home again but right now i just can be arsed, there's other stuff I'd rather be doing. If that puts me behind other people professionally then so be it
[https://www.reddit.com/r/theXeffect/](https://www.reddit.com/r/theXeffect/)
Try a different language at home. C++ had lots of benefits, but can be a bit exhausting. Try Rust, D, or a functional language.
&gt;The problem with teaching people C is you are teaching people the wrong way to do things from the start. You should not have naked new and delete dotted all over your code. You shouldn't need to worry about null references and pointers all over the place. People shouldn't be using printf or scan. They should be using cout, vector, references, shared ptr etc. New and delete are superior to malloc and free, yes. What happens when you need to overload operator new? Or write your own allocation system altogether? How about actually debugging sources of memory leaks or seg faults? C++ programmers who aren't already familiar with that will have a tough time from the get go, and in C++ they are less likely to happen but they *do* still happen. &gt;But, this all depends why you are teaching cpp. If you are teaching o/s designers with a background machine code, teaching C first might make sense. Not "might" makes sense. Kernels are usually written in C for a good reason. You have no idea what you're talking about. I'm speaking to someone who *thinks* they are correct but just offers the same trivially refutable arguments. You keep arguing that C++ is a better language. That's not even close to what I'm debating.
&gt;&gt; the type safety draws a stronger parallel to ML &gt; &gt;the types in C++(17) templates are akin to values in LISP. And from that point of view, they almost don't have any "meta-type" safety since the only possible "meta-types" are `typename` and integral types. I'm obviously referring to constraints imposed by concepts here. Try again.
Don't force it! Do other things. Some problem or monotonous task in the other thing may inspire you, and THEN you actually have a need, a goal, and can figure out how programming will fix it. Just wait for inspiration to come along :)
Thanks for the suggestion, looks like a good starting point. I still think it's a shame, though. So much knowledge out there and everyone's learning isolated on their own.
`epoll` is so last decade. Should be using `uring` these days.
wat
This is a good read on the fundamentals of coroutines: https://lewissbaker.github.io/2017/09/25/coroutine-theory
One sentence on what exactly is distortos wouldn't hurt
I was watching a video of John Lakos recently. He said something like: There's what they tell you and then, you know, the truth. I got a kick out of that and agree. I find that there's a fair amount of both truth and distortions here. Figuring out what's what isn't always easy. I think my software is between intermediate and advanced. I've been working on it for a number of years and have gotten a lot of advice on how to improve it on comp.lang.c++, here and other forums. It isn't real heavy though on your 2 big items. It might be of interest from an engineering/architectural perspective.
This is a general programming topic, not specific to C++. I recommend posting on another subreddit.
Thanks for your insights. That's also one beautiful quote explaining why this situation even exists in the first place.
Mhm, yeah. I decided to post here, because I'm really just interested in the C++ community and not the general programming "crowd". I think C++ is different in this subject to, say, Python because it requires more effort (complexity of the language, the lack of tooling and the often quite "low-level" domain) to keep projects running let alone start them. So if you want I can remove the post...?
But you can add either link or text (; distortos is an object-oriented C++ RTOS for microcontrollers, currently supporting some STM32 chip families (F0, F1, F4, F7, L0 and L4). so basically ARM Cortex-M core, ARMv6-M and ARMv7-M architecture. The most significant difference from other RTOSes is that it is written **entirely** in C++ (and obviously some assembly where this is required - for example context switching or stuff like that). Therefore it has first-class support for objects and C++ features which are hard/impossible to do with a C-only RTOS - you can have a thread made out of a lambda or of a member function from a class, or a function taking 10 arguments of concrete, non-trivial types, you can pass non-trivial objects (think sth like `std::list`) via queues, with no special hacks or tricks which would be required when doing it in C++ wrappers for C functions. It's just that it is way easier to have a C++ implementation with all the features and then having C wrappers for that with limited functionality instead of doing it the way most other projects are doing - a C-only implementation with limited functionality (thread which takes a single `void*` argument, queues which can only do a bit-wise copy of the passed items, synchronization objects which will never be `constexpr` because they require explicit creation by a function, ...) and building some C++ wrappers on top of that. Such wrappers will just never have full functionality and there are always some hidden limitations. In embedded field, especially when dealing with microcontrollers (so chips which usually have maybe a few hundred kB of ROM and a few dozen kB to maybe a few hundred kB of RAM), there's this long standing "truth" that almost no-one tries to back-up with hard evidence, that using C++ is almost impossible or at least a very, VERY bad idea - because the application will be unpredictable, unreliable, will use hundreds of kB of RAM, be slow as hell, will surely crash sooner than later, will fragment the heap and stop working, be bloated, or just all of that at the same time. So basically in some fields it is almost a virtue to use only C, this has to be C89, absolutely no dynamic allocation (even if it is a one-time allocation at the start), usually there are other "strange" "truths" which you must obey (like "there must be only one point of return from a function", "never use function xxx()", "define your own fixed-width types", ...), using anything "fancy" or "convenient" is forbidden ("it's bloated" or "it's too slow") and so on and so on. Almost no one tries to break this "magic circle" (; So this project is about proving that such beliefs are just wrong, but also to get the job done, as it works pretty well in real-life embedded applications.
&gt; even if it is a one-time allocation at the start To be fair, that one should probably be a static variable.
We've been using Coroutines TS for all our AI and game logic ticks. I'll see about putting together a talk/blogpost about it.
Frames are allocated independently.
See https://www.airs.com/blog/archives/460, this explains roughly how the exception handling is done using DWARF. The asm parts don't supply any of that information, so you'd have to code it yourself. Perhaps you could fake it by jumping across the callgate, but problems might arise when multiple threads are in play or if you cross the callgate more than once. This is not something I have experience with, only repeat the words of others, so do your research too. I'm not saying it's impossible to do, just that it's hard and of rather limited appeal. Then again, we do have [libbfd](https://en.wikipedia.org/wiki/Binary_File_Descriptor_library#History)
Is there a resource for the changes/additions to &lt;functional&gt; that have been standardised for C++20?
Just wanted to chime in to agree: the boom is wonderful.
Ohhh it's a RTOS! Why didn't you just say it was a RTOS!? It's a RTOS guys. ... What's a RTOS? I'm going to take awhile guess its a ROS but with a T in it. Luckily for me I know what ROS stands for but there are those who don't... It's not a good idea to use abbreviations when explaining something like an introduction... Especially when it's probably not even a ROS.
https://libcxx.llvm.org/cxx2a_status.html has a list of the library papers that have been voted into the C++20 working paper, although not filtered by header.
No need, I've already removed it (which doesn't stop ongoing discussion, just makes it inaccessible from the subreddit's main page).
Don't get me wrong, but if you don't know what is a RTOS then you don't need one (; Even if I would say explicitly that it is a "real-time operating system", would you then complain about me not explaining what "real-time" is and how is that different from Linux or Windows? I know that some desktop-guys just cannot understand that the world of programming doesn't end on PCs, but that's the truth &lt;:
I think that the thing to understand is that programming languages exist to write programs, not to be studied. You can spend all your time digging ever deeper into a language lawyer hole, particularly with C++ which is grossly over complicated at this point. But most of the things you probably really need to learn now are not all that language specific but just experience with approaching a problem and solving it, not in an academic way but in a real, deliverable way. You can start on that with what you have and when you run into things that you don't feel like you have a good tool to use against, ask around. You'll get plenty of suggestions and you can try to apply those, and pick up plenty of language bits and pieces in the process. I imagine most companies out there could give a crap if you know the C++20 spec by heart because they aren't using anything close to that anyway. Real companies have to choose a tool set and use it over time. Their customers don't care if they use the very latest language features, because they don't make money from being language lawyers, they make it from writing software. They are likely to value real experience creating challenging software, whatever the tools you used, more than whether you can recite chapter and verse of the C++ bible. And the things you'll learn doing that will be generally applicable in other languages and problem domains. Of course you will need to read this quickly, since it'll probably get down-voted into oblivion.
Mind if i ask how you can define you own level? Like, how can you say I'm ready for advance techniques? Legit question for my own learning :]
I’m reading the pdf and seems interesting. Thanks for letting me know that. I will try that after study.
It can be different based on `await_resume`. In this case, the author's functions return `unique_ptr` so it has to be moved.
I've never heard of uring, and google is turning up nothing. Do you have a link?
New programmers don't need new and delete. The need Myclass myclass; Once they are more experienced, they can learn new and delete in cpp. There really is no point in learning c.
https://lwn.net/Articles/776230/
Maybe we should go back a step. What concepts can you teach in c that you can't teach in cpp? If you want new programmers to be fully versed in memory management from the start, there's nothing stopping you from teaching this from th start in cpp rather than going the indirect route.
&gt;New programmers don't need new and delete. &gt; &gt;The need Myclass myclass &gt;Once they are more experienced, they can learn new and delete in cpp &gt;There really is no point in learning c. You're laughably wrong. New and delete are features coupled with other language constructs. C++'s so called "opt in" claim is bullshit. It's also important to consider that properties of the AST in C++ are fundamentally different than that of C. Device drivers and embedded systems are still better suited to the C ecosystem, with few exceptions. I mean at this point you're sounding like a parrot or you're trolling.
thanks for your insight especially, I appreciate it. I have to clarify that I do know that what I know is probably sufficient. But this is not the motivation for this post - I want to study C++ - as I have specific goals that are not defined in a working environment. It goes in hand that I do really enjoy the challenge C++ offers and I highly enjoy every last complicated bit. It seems that this attitude either didn't find roots here or (more likely) that I just didn't communicated them well enough.
Thanks for asking, that's a good spark for a discussion. By now I have written well more than 100 000 lines of code with hundreds of 2D and 3D graphical applications, dozens of algorithm implementations (aes, rgb to xyz, matrix, bignum..). Doing all of this enforces a lot of C++ knowledge. std::regex, all std:: containers, most of &lt;algorithm&gt;, &lt;utility&gt;, &lt;memory&gt;, std::filesystem. That list is a bit incomplete and I will improve this reply but my laptop is out of power :)
&gt;Maybe we should go back a step. What concepts can you teach in c that you can't teach in cpp? If you want new programmers to be fully versed in memory management from the start, there's nothing stopping you from teaching this from th start in cpp rather than going the indirect route. Right. Let's introduce the concept of name mangling and the bloaty ABI that C++ is required to have. Let's also teach them about the difference between glvalues, xvalues, and rvalues. Did you know that memory layout for classes in C++ is totally undefined? That includes layout of trivial fields. You shouldn't begin teaching C++ without introducing those concepts first and foremost, regardless of what you're doing with it. Let's not forget the fact that the amount of automatic code generation performed by C++ is insane enough to bite you if you aren't aware of it, and obviously people who aren't exposed to systems level work have zero reason to even think about that. In C, you don't have any of those kinds of gotchas. It's much more simple to map lines of C to actual assembler, in which case you *understand* what's happening and you develop a mental model that you can take with you when you learn C++.. You also can learn how inheritance is implemented - doing this manually in C++ is retarded and potentially violates the spec given the lack of guarantees regarding memory layout.
Well, I'm certainly not one to ding anyone about doing something for the challenge, since that's mostly what I've been doing all along.
So you're saying it produces lvalues then? If it were an rvalue, it wouldn't matter that the type is move-only.
Try to not be a POS with your rationalizations and just edit your comment or something.
I've long thought of a project like this, but I don't use C++ day to day, so I never even thought of actually starting it. One idea I had for cross-compatibility was to make a CMake generator that generates CMakeSL, which would then inject itself into the CMake environment. That may be too many layers of Inception though. I didn't watch the video, but I'd write up a dream CMakeSL syntax for a complicated CMakeList first so that you know where you want to end up. Adding stuff as you need it is what gave us CMake syntax in the first place :-D
&gt;But you can add either link or text (; Your text can be formatted with Markdown, so toss in a link with the description and the release notes. :)
&gt; ... but I'd write up a dream CMakeSL syntax for a complicated CMakeList first so that you know where you want to end up. Building a modular Boost [directly from the repo] is possibly a good candidate, having a go at gcc and/or gmp could be fun too.
Text editor—vim—and a compiler
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
As you said, normally the value category of the `co_await`'s left side follows its operand. like the code below. ```c++ class await_with_lvalue{ bool await_ready(); void await_suspend(coroutine_handle&lt;void&gt;); string&amp; await_resume(); // string&amp; txt = co_await await_with_lvalue{}; }; class await_with_rvalue{ bool await_ready(); void await_suspend(coroutine_handle&lt;void&gt;); unique_ptr&lt;byte[]&gt; await_resume(); // like make_unique, returns rvalue // unique_ptr&lt;byte[]&gt; uptr = co_await await_with_rvalue{}; }; ``` However, **if cppcoro's `when_all` has its own memory space to save those r-values**, and expose it using reference(l-value therefore), they have to be moved into those tied objects like the author's code. &gt; I'm a bit confused since I stopped following up the cppcoro more than an year ago, so I'm not sure it works just like I explained. :(
&gt;uring Would you have any example on how to replace epoll with uring by any chance?
I'm not sure that's necessary. You don't teach children Latin, French, and Spanish before teaching them English. Once they have a good understanding of English, they can look into the other languages if they need to. To be honest, this conversation might be better served with input from others. Perhaps creating a new post specifically for this question would give better answers. It is an interesting topic, and you raise a lot of interesting point. Thank you for taking the time to type out your thoughts. It does make me think.
&gt;I'm not sure that's necessary. You don't teach children Latin, French, and Spanish before teaching them English. Once they have a good understanding of English, they can look into the other languages if they need to. 1) Spoken languages are not programming languages. They are fundamentally different and cannot be compared in this context 2) Kids learn whichever language they are most exposed to when they are between the ages if **0 and 4**. Do you even realize that the only reason why this works us because their brains at that age range is *supposed* to be able to quickly learn how to communicate? That learning flexibility quickly goes and isn't constant. Honestly, and I say this with respect: that's fairly audacious of you to make that argument. It's almost insulting. &gt; &gt;To be honest, this conversation might be better served with input from others. Perhaps creating a new post specifically for this question would give better answers. It is an interesting topic, and you raise a lot of interesting point. Thank you for taking the time to type out your thoughts. It does make me think. We'll see. Tbh die hard fanaticism is counter productive. Industry figures like Bjarne have their own biased agendas, which is why they advocate for complete replacement of C. C is obsolete for most areas of computing, but it's never going completely away and teaching programmers systems programming requires that they actually know what the fuck they are doing, down from the CPU cache to the OS scheduler to the compiler to the assembly. All of that is best done using interfaces that don't distract from the learning process.
In order to avoid making people learn yet another syntax, why not build on Skylark? There are Java, Go, and Rust implementations already to use as a reference for a C++ one.
Not relating to that post per se, but as a student who got reasonably far as these things go into learning c++, I decided I needed to learn c. It just felt like there were so many gotchas and things going on under the surface that weren’t clear in c++, but were a result in many ways of C. So I’m now focusing on C, and I think definitely to my benefit. I could probably switch back now and and find c++ to be a much smoother experience, but I’m sticking with c for a while for a variety or reasons, mostly to do with understanding really what the computer is doing. But that’s a separate goal. Just my two cents 🙂
I'd rather go in the opposite direction: use something that is either not a script, eg completely descriptive of the build or functional. Having no mutation allowed would make build much simpler. Imperative stuff could still be allowed inside function scope, but not outside.
I wanted to add khash, but it's interface was not C++ standard enough for my benchmark
If your goal is to learn C++ but you go C first, you are actually delaying learning C++ ,and you will need to eventually change your mindset and unlearn C in order to write good C++. If your goal is to learn C++ and you just go learn contemporary C++, by definition you are learning C++. You will eventually need to learn C in order to truly understand C++, but you just don't need to do so on day 1.
IMO learning C before C++ just leads to plethora of bad habits that are difficult to get rid of. I even think most C++ courses teach too much C to start with. I feel same way about programmers that come to C++ after getting used to C than with programmers that come to C++ after getting used to Java. They have learnt how to do things a certain way, and they need to actively unlearn some of those things in order to improve. Even worse when they teach those bad habits forward. That said, like with real languages, learning one language makes it easier to learn others. So it's not all bad.
I've never really looked at EnTT, couldn't tell you. A quick perusal makes it seem pretty promising. It's a big library, but it's a lot more than just the ECS framework, it seems. It's used in real shipping non-toy games, so it's got that leg up over its FOSS competition. I'm pretty skeptical of its general approach (judging from a *very* quick perusal). The sparse-set approach, the need to _sort groups_ for fast iteration, the inability to use SIMD update functions, and the sheer size/complexity of the library (even excluding the non-ECS portions) all concern me.
I am split on this depending if we are talking pre-/post-C++11. In a modern C++ environment I think C reinforces bad habits that you will need to unlearn to use the language in an effective and idiomatic way. For C++03 and earlier, the language did build heavily on C style in many regards and so I think there is less impedance mismatch and risk of forming obviously bad habits. &amp;#x200B; That said, I would hope that people are learning modern-style C++ in 2019.
Or have a look at Meson.
What is another dialect of something if not another syntax/language?
Yes, that only made sense until the mid-90's, when C++ wasn't widespread and many people were coming from C background. Learning C first will just make you use Cisms that are considered bad practice in C++, specially in what concerns writing safe code.
Missed the chance to call it distortoise! Just kidding, looks very cool.
Recently I thought about it and now I think that the only "right" name which fits current trends would be SmaRTOS. I have yet to come up with something that includes both "IoT" and "blockchain" (;
I learned C++ first, and then went back to learn C. Learning C was essential for deepening the understanding of C++ for me. It made understand why certain C++ features exist and appreciate them. However, looking at that post, I definitely do not know how to read disassembly output. I don't think it would be a particularly fun path to take for a beginner, nor would that knowledge be of any practical use for building simple programs. These things interest you more later on. So I would say C++ first, then go as deep as you want to go (C, Assembly etc.).
If you already know Python, almost everything you know applies to Skylark. The differences are small. If you roll your own new language, the differences will likely be large. I don't have time to learn every special snowflake way of writing a for loop that only exists because one guy thought braces were cool and another guy thought brackets were cool. Don't invent a new syntax unless you're really doing something different, or you'll just make life harder for your users.
&gt; The differences are small. And then &gt; Don't invent a new syntax Kind of contradict each other. Even smallest of differences make language incompatible with the rest of python ecosystem (most importantly IDEs and debuggers). I fully agree with you that existing established language should be used, but even minor tweaking of it results in a new language with all the bads that come with it.
&gt; but even minor tweaking of it results in a new language with all the bads that come with it. No, not at all. I can agree that using Python as is with no modifications would be even easier to pick up, but to say that as soon as there is one tiny difference all the similarity that my brain already knows and will recognize will somehow disappear is just factually wrong. I can immediately pick up Skylark as a Python user and know how to do control flow, functions, lists/sets/dictionaries, etc even though there are differences in other areas (mostly that Skylark 'freezes' definitions after some time). There can be a spectrum of difference, and if you're really close to something people already know, even if it's not exact, that's an advantage. C#/Java/C++ have much more significant differences, but a programmer familiar with one of them is still going to have an easier time moving between them than jumping to say Haskell or Common Lisp.
It is not about humans picking up the language, but tools. There is no reason to take already established imperative programming language and modify it other than making oneself feel better about themselves. Even if those modifications are good in general sense - they do more harm than good.
Unfortunately, I'm not going to click on that link. (EDIT: OK, I did click on the link, so sue me.) Why not embed an existing language instead? Lua was literally designed for just this sort of thing, but embedding Python into binaries works really well, too - or for that matter, I get the impression it's fairly easy to embed Javascript or Ruby? My preference would be Python, but any existing language would be fine. (_Everyone_ knows Javascript!) I just finished giving up on a whole technology because they, too, had their own language - a particularly bone-headed and stupid one, "almost Yaml but about 10% of the documents would fail in a Yaml parser, and there are embedded snippets of almost-Python in the fields, and oh, we also include vitally important information in what look like comments too". Languages like Python or Javascript have been developed over decades and have had the sharp edges either buffed out, or at least marked by warnings and blog posts from others who have cut themselves. If I were to commit to your system, I'd be committing to a decade of you working out little details with your language. I'd be committing some of my headspace to learning yet-another-programming-language-god-please-no. I'm going to have to make a whole new set of mistakes with this language - because you only learn by making mistakes - and some of those mistakes are going to be _your_ language design mistakes!
This is interesting, clearly a passion project. I've some questions: * I understand that CMakeSL's advantages would be static typing (is null valid? are array indexing operations statically checked?) and that user probably already knows C++ (but exactly how different CMakeSL is?). What else would you add? * I'm not sure that clang-based tools would be (fully) compatible because looking at your 'CMakeLists.cmsl' example, there're no #include's hence unknown types. * What can be changed in vanilla CMake to alleviate some of the problems that CMakeSL solves?
Amen. Either give me "Python 3.6.6" or some other specific version of a language I have an exact and complete spec for - or give me nothing. I ran into exactly this the other day - a language that allowed you to embed "single lines of Python that didn't use certain characters" in one place, and "multiple lines of Python with different character restrictions and no indentation allowed(!)" in another place. So two different contexts in the language that had "broken Python", each broken slightly differently. I wish I were joking... https://kivy.org/doc/stable/api-kivy.lang.html
Why not go ahead and just use Bazel then?
"I know English, how hard can Pidgin English be? The words are [mostly the same](https://en.wikipedia.org/wiki/Tok_Pisin#Example_of_Tok_Pisin)!" &gt; There can be a spectrum of difference, and if you're really close to something people already know, even if it's not exact, that's an advantage. It's an advantage for people who are playing around with computer programs. For a software engineer, someone trying to write extremely reliable systems that will work every single time no matter what, it's a disadvantage. If you cannot give me a specific version of Python or whatever language it is for me to use, then I'm not interested. I don't want to have to learn the differences between your broken Python and the real Python, and then switch back and forth. I already spend a lot of mindspace switching between Python, C++, bash, elisp, and that's just in the last week.
&gt; If possible, yes it is preferable to have all parties agree on endianness. However, it is faster to use the native endianness for encoding. Between taking longer to encode, and longer to decode, I choose taking longer to decode. Sometimes you might want the opposite decision anyway, so it makes sense for a library to give you options. That is orthogonal to when the decision about endianess should be made. I.e. it may be decided that the endianess is big or little, and that the endianess swapping shall happen in one part of the network and not the other, but that doesn't stop anyone from implementing the decision before compilation.
Depends if you’re interested in systems/embedded programming or higher level application programming. Ideally you’d understand the full stack but that takes a long time.
Thanks for the long reply. I am cool with your library, as long as it allows for sane choices and the defaults are the sane choices. Some comments over your reply: &gt; It is better to have built-in limited required units retrieval facility than not to have it at all and use boilerplate code to do the manual units conversions. Built-in is not required. It can be a separate library. &gt; My solution allows compile-time configuration of your polymorphic interfaces. Does your solution allow the automatic creation of big switch statements? &gt; Let's agree to disagree. Struct based design leads to other bad decisions and having significant amount of boilerplate integration code. No, it does not. There is absolutely zero proof about that.
Ideally endianness requirements would be spelled out in detail before you start work. However, I maintain that a library for this should give you options to decode all common byte arrangements.
While writing modern C++ is very different than writing C, you still need to understand the common subset/concepts, since they are a core part of C++. So, in the end, if you keep using C++, you will have learnt almost all of C sooner or later, regardless of the approach you take.
Two differences that I have found are `boost::filesystem::weakly_canonical()` being broken for some kinds of paths that are valid on Windows and `std::filesystem::unique_path()` being unavailable because the `boost::filesystem::unique_path()` is deemed insecure.
You can create command line option gramma in similar BNF form and use [BNFlite](https://github.com/r35382/bnflite) header library for parsing of command line arguments. The benefit of this tool is error performing.
I dare to suggest a slower perusal, though. Fortunately you don't have to *sort* groups for fast iterations, otherwise they would be pointless, I agree. Moreover, the sheer size/complexity of the library shouldn't be a problem per-se, being all the parts more or less independent from each other (eg the ECS part depends only on the signalling stuff to send notification on component creation/destruction/... to the users). That said, if you'll ever decide to go in depth with your analysis of [EnTT](https://github.com/skypjack/entt), I'd be really interested to have your feedback (and to answer your questions ofc, if any). Feel free to ping me (also privately if you prefer). I think your experience and your suggestions can be invaluable to improve the library (or to decide to shut down the project eventually :).
A non-data oriented ECS would be like taking Unity GameObjects as starting point, taking the business logic out of the GameObject components, and create systems that keep track of a list of matched entities. Each entity is essentially a class with a collection of component instances. A data oriented ECS would store its components in arrays (AoS or SoA). There are various ways in which this can be implemented. Amongst the fastest approaches (as implemented by [Unity DOTS](https://unity.com/dots), [EnTT](https://github.com/skypjack/entt) and [Flecs](https://github.com/SanderMertens/flecs)) allow applications to iterate over raw packed component arrays, which is ideal for caching (a lot of good material can be found on the pros/cons of these approaches). The advantage of a data-oriented ECS is that a compiler can generate very efficient instructions for a system, and in some cases can even run multiple instructions in a single clocktick (search for SIMD). Additionally, since data is being streamed from RAM to CPU cache in contiguous arrays where each byte is relevant (if done well) you have very few cache misses, which boosts performance of applications.
You should first learn "The C part of C++" but not the C itself. The C language has many conventions which are antipatterns in C++ - so do learn how pointers etc work but do not learn C from C courses.
&gt; It's much more simple to map lines of C to actual assembler, in which case you *understand* what's happening You *think* you understand what's happening. &amp;#x200B; &gt; C is obsolete for most areas of computing, but it's never going completely away and teaching programmers systems programming requires that they actually know what the fuck they are doing &amp;#x200B; You *think* you actually know what you are doing. [C Is Not a Low-level Language](https://queue.acm.org/detail.cfm?id=3212479).
&gt; As a result, are getting to a point where we might even be able to create different syntaxes that could be used for embedding compile-time DSLs into the language? I don't think so as: - allowing to add/overloads non-existing operators and/or create user defined syntax is a very risky move from language design point of view (significantly expands use space (with many potential unwanted abuses) and significantly limits future design space) - it's just tons of work and a lot of corner cases - we already can overload operators Also, we have already this: https://en.wikipedia.org/wiki/Spirit_Parser_Framework ___ Regarding actual metaprogramming features, we do not have (yet) and would like to have: - `for (each member of T)` - something to ease variadic templates - there is no thing like `using types = Ts...`, you must use `template &lt;typename...&gt; struct type_list {};` and pass instances of it - you can not easily refer to arbitrary type in a parameter pack (something like `Ts...[N]`) - is private/protected/public traits (?) - function/lambda traits - some saner syntax for stuff that right now is/has to be workaround by recursion (improvements like fold expressions, `if constexpr` and proposed `for...`). New syntax not only significantly reduces code boilerplate, but also has much better compile times - maybe improve perfect forwarding and backwarding (dunno what to do here, but both are quite unintuitive) - improve template compiler errors (concepts and static assert helped a lot here)
Does it conform to standard proposal [P0429 "A Standard flat_map"](http://wg21.link/p0429) and [P1222 "A standard flat_set"](http://wg21.link/p1222)?
[ I'm a CMake developer, but these are personal thoughts and opinions here, nothing official (as is anything I put here anyways, but I feel this probably needs an explicit disclaimer). ] Using an existing language would definitely be preferred. However, there are semantics in CMake that correspond with approximately no languages out there. There are at least 3 different kinds of scoping (directory, function/variable, policy). Some are lexical, others not so much. They're also sorta kinda tied together depending on the function call. Python would be unsuitable because CMake has *much* stronger backwards compatibility constraints than Python. Lua might work, but would probably end up requiring Lua code to declare the version it is expected to use since even it breaks compat pretty regularly. Perl 5 may have worked (because of their `use` compat statements), but I, personally, don't think that'd be *easier* to work with. Maybe a Lisp would work? I don't know that an extant Lisp would suffice though. As for embedding, the problem comes with distribution. Building and distributing Python on Windows is annoying at best nevermind other platforms CMake targets. Not sure about Ruby, but it probably has similar problems. JavaScript is hard because pretty much everything that implements it is gigantic (v8). MozJs looks pretty big too from a cursory glance.
&gt; I fear that a direct source for this is an illusion and that I will have to continue slowly gathering all these informations by myself simply by just using C++, reading alot, Stackoverflow, r/cpp - just like I've been doing. Yes, this is the sad truth for a lot of about C++, still. You know how I did learn templates? By reading cppreference. Really. And no, it was not easy - it was like learning English by reading a dictionary. All the stuff is in there, but articles are not ordered for step-by-step learning and very often have circular references. You just have to have a big "stack" in your own memory and be able to track down "references" (terms) you don't know. You can learn from documentation but it is slow, painful and most importantly: it just teaches you the language - it won't teach you good practices or list pros/cons of any given feature. Now, look at my flair. I'm going to change that situation (and it will be a very long term project). Imagine website like learncpp.com but updated to C++20, with added language feature usage recommendations, core guidelines, good practices, examples, exerices, links to cppcon vids (where applicable) and other stuff. If you really want to improve the situation of C++ learning accesibility, you can help me (in any form, web-tech, writing, testing, article review or whatever else) just message me.
CMake is already a scripting language
Boost really isn't that complicated. Half of boost already has CMakeLists.txt, and the other half is easy to write, especially if you can understand the Jamfile syntax. Admittedly that's from the tarball, directly from the repo could be more interesting with submodules and code generation.
&gt; ... directly from the repo could be more interesting with submodules and code generation. I'm sure the Boost devs will be looking forward to your PR's.
In enterprise context, you don't care too much about writing cross-platform software anyway. And C# has better GUI building tools than Qt and is in general a lot easier to work with, which is why companies opt to build their internal tools with it.
You can always read the C++ standard as published by ISO directly. It's the ultimate document if you want to know everything about C++.
Thx. Nice article
Off the top of my head: University of Waterloo, Georgia Tech, Louisiana State University, and many Polish universities.
`boost::filesystem::unique_path()` being gone is unfortunate. I used that a lot in unit testing for writing temporary files.
Thanks for doing the work on this! &gt; However, there are semantics in CMake that correspond with approximately no languages out there. That seems like a really bad thing, though?
That is [QBS](https://doc.qt.io/qbs/overview.html): // helloworld.qbs Application { name: "helloworld" files: "main.cpp" Depends { name: "cpp" } } // helpers.js function planetsCorrectlyAligned() { // implementation }
I'm not. Currently as I understand it, the policy is that CMake support is tolerated but not encouraged. There's no point submitting patches if they won't be accepted along with the maintenance burden of two lists of source files, etc.
I made a [new thread](https://www.reddit.com/r/cpp/comments/bl7qso/teach_c_to_c_programmers_first/) where you can go in to the details of this with people who know a lot more than myself.
Would you agree that a list of those would make sense ? Well with contact emails ? This could open up the dialogue and bring maybe more interested students to meetings conferences etc . Who can give input from a learner perspective which would be great to have I think at least.
Did you check Cairo? [https://www.cairographics.org/](https://www.cairographics.org/)
&gt;&gt; It's much more simple to map lines of C to actual assembler, in which case you *understand* what's happening &gt; &gt;You *think* you understand what's happening. You *do* understand what's happening, if you understand the architecture. Obviously microcode updates can happen at any time, and obviously there is a layer of abstraction that a) we do not think about and b) we cannot measure directly. *But* CPUs do have deterministic behaviors that are supposed to happen given arbitrary inputs. These behaviors can be measured against by application code, and the behaviors themselves *do* have influence over performance. &gt;&amp;#x200B; &gt; &gt;&gt; C is obsolete for most areas of computing, but it's never going completely away and teaching programmers systems programming requires that they actually know what the fuck they are doing &gt; &gt;&amp;#x200B; &gt; &gt;You *think* you actually know what you are doing. &gt; &gt;[C Is Not a Low-level Language](https://queue.acm.org/detail.cfm?id=3212479). I honestly love it when people assume my advocacy of C as a tool for learning implies that *I must not be aware* that we no longer use PDP 11s and that unless we're targeting 12 mhz CPU chips we rarely need to count clock cycles. *Yes*, I am aware that C is limited in its ability to explicitly control various features of modern CPUs. So is C++. That isn't my point. Programmers do need to know assembly language. They also need to know how the CPU utilizes the instructions themselves (yes, out of order execution, caching, all that shit). C++ is a complex language. C is dead simple. The point of studying systems programming is to have a grasp of the von neumann memory model and to understand how operating systems work. These people are *learning*. They don't need to be bogged down by C++ features. STL bloat when learning how to use tools like objdump and dealing with name mangling or confusion about things like move semantics vs copy elision vs forwarding are all irrelevant when it comes to learning computer architecture/systems, but need to be taught in a course that uses C++.
I was thinking the same. What about code like: try{ auto f = make_unique&lt;int[]&gt;(large); auto g = make_unique&lt;int&gt;(); }catch(...) First thing the exception handler does is freeing the large memory block making space for "normal code" to execute normally. Or what about a try-enclosed block using a fast, but memory-intensive algo with a slower algo as fallback?
The implementation hasn't been altogether speedy, but they [officially made the decision to switch for real a few years ago.](https://lists.boost.org/boost-interest/2017/07/0162.php) Hopefully they make it.
QT would be another place you would go for this sort of thing.
I started learning programming with C, I can read and write assembly on multiple platforms with ease, I work with performance critical code (graphics programming for games on mobile devices) and I'm super happy that relatively modern C++ does most of the heavy lifting for me so I can concentrate on the actually important bits. The practical use cases for such low-level skills are rare and limited.
&gt; I mean, that seems like a really bad thing, doesn't it? I don't think it's entirely surprising for a domain-specific language. Especially for one which has grown organically for almost 20 years in a milieu rife with things like broken compilers, broken platforms, obscure compiler/linker behaviors, incompatibilities galore, etc. that is the C/C++ compiler and target platform ecosystem. &gt; we want the build system to do the right thing Yes, and CMake aims to do that (at the level of abstraction it provides). This is where the vast majority of the complications and intricacies come from in CMake itself. Sometimes old decisions are warts, but with the backwards compatibility guarantees, it means that policies are a thing (which end up needing their own scope0. Directory and variable scoping not being exactly the same is sensible because directories shouldn't be the only way to scope variables and calling a function shouldn't change the directory you're working on. `find_package` has some weird interaction with these, but I suspect that's because imported targets weren't a thing from the start. If CMake were to be started from scratch today, there are *many* lessons that have been learned and we'd be able to remove all kinds of oddities. But, that's not something any CMake developer can take the time to do because the language and the platforms are never standing still. &gt; and get out of our way. Well, C/C++ is not the place where that can really be done because so much is defined in terms of the target platform rather than the language specification.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/blccpz/need_help_with_assignment/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is a question for /r/cpp_questions Most likely answer is that however your printing your array has an overload for char* and shows all of the characters.
COBOL is already a programming language ;-)
[This is how shitty this website is on mobile](https://imgur.com/a/8U3hEuZ) And yes, [it moves when you scroll, to make 100% sure that you cannot read the content in landscape](https://imgur.com/rSV0EhS)
Strongly disagree. When you teach C, you don't first teach assembly. You go straight to C. Teach the higher level concepts and abstractions first, then you can start teaching what it is that is being abstracted.
"I would rather learn completely new syntax instead of something that is 99% the same, because I don't have time to learn something new!" Do you see how nonsensical this is? This discussion started in the context of OP making a new language and me suggesting that he build on something that already exists instead.
There are a ton of other differences between CMake and bazel. If you read the readme OP makes it very clear he is only changing the syntax of the language, not anything else about how CMake works. Using Skylark basically just means choosing to use python syntax, it doesn't say anything about the API that is made available to users.
Asked the question there, thanks!
Everyone describes this as an ideal, everybody thinks it's a great idea for every build system, and it's totally and completely wrong. Every "declarative" build system (i.e. one that deliberately avoids Turing completeness) ends up adding a ton of special case features built directly into the build system because the build system is implemented in an Turing complete language so that becomes a way to get desired behavior. In simple examples declarative stuff looks great, but on a really large monstrous project, you end up needing to write serious code testing things the authors of the build system never anticipated to determine what your dependencies are on different platforms. You need to generate code that depends on other generated code to arbitrary depth. You don't know parts of the build graph until other parts of the build are finished, so there is no way to specify them in advance. You end up having tools that output a variable number of files that can't always be anticipated based on what the input files are without running the job.
So, in data-oriented ECS, entities are reduced to being IDs. These IDs then group components logically together. The component data however is stored in big AoS/SoA structures. Non-data oriented means that components and entities are fully-featured OOP objects.
This is a good talk from someone with a great deal of experience teaching C++ who thinks teaching C first(to C++ programmers) is a mistake [https://www.youtube.com/watch?v=YnWhqhNdYyk](https://www.youtube.com/watch?v=YnWhqhNdYyk)
Very WIP but [2D graphics TS](https://github.com/cpp-io2d/P0267\_RefImpl) shows a lot of promise.
&gt;I'm not some naive student I'm not saying *you* are, no offense intended. I'm saying that "learn C first because it's close to the metal" is not quite true. One can read the K&amp;R book and whisper "I know Kung Fu", but the world is complex and that's not really air we're breathing now. &gt; C++ is a complex language. C is dead simple. Indeed, C++ is complex. Can't agree that C is "dead simple" though. &gt;These people are *learning*. They don't need to be bogged down by C++ features. So don't use them? They're optional and can be introduced later as you go. However, do they still need to be bogged by "dead simple C" features? Preprocessor, include files, include guards, macros, array-to-pointer decay, most vexing parse, variadic functions, manual resource management, integer overflow, null pointer dereference, UB all over the place, you name it? Note: unlike C++ features, those are unavoidable.
Yes, as /u/NotUniqueOrSpecial says, policy change.
Good TMP challenge is to write console command parser that allows adding new commands by simply: cli.add_command("new_commanf", [&amp;](int param1, float param2, string param3) { ... }) That requires variadic templates and lots of common TMP patterns.
Sadly, as far as I know - QT is backing out from QBS. Maybe that's an argument that declarative language doesn't work for 100% cases we need.
Certainly, I'll take a closer look when I can. The biggest things would be if EnTT makes snapshotting/restoring state fast and easy, and allows running multiple "worlds" simultaneous (registries in EnTT parlance, iiuc).
this is the first time I hear anyone referring to java.awt as "really great". it's very nice if your state-of-the-art is from 1995...
I'd be **really** glad if it happened. Thank you. Snapshotting is already supported actually, both one shot and continuous (with a map to rebind eg locale/remote ids). Quite easy to use, but I'm pretty sure I can arrange something that is faster at the end of the day, now that I master the project. I'm open to suggestion here too!! :-) Something on which I'm working on literally *right now* is a way to take a whole entity with all its components from a source registry and put it in destination registry (not necessarily the same). This should be at the base of both cloning and moving towards a shadow registry. So, the current direction is that of easing the use of multiple registries in parallel, that is what I do for my own in a project (it remembers me of the concept of *spaces*, you know).
QBS works perfectly: QBS itself and QtCreator are good examples of big real life projects which can be built with it. QtCompany chose CMake for Qt6 because some big customers invested too much into CMake.
&gt; &gt; Maybe that's an argument that declarative language doesn't work for 100% cases we need. yes, as soon as you need to build non-trivial projects, which need to do code generation, install stuff at various places, etc... purely declarative just doesn't cut it. e.g. look at the kind of imperative JS that OpenFrameworks (one of the largest projects using QBS) has to provide : - https://github.com/openframeworks/openFrameworks/blob/e6e4ee1da88f507f36bad503cd329b31eaadccac/libs/openFrameworksCompiled/project/qtcreator/modules/of/of.qbs - https://github.com/openframeworks/openFrameworks/blob/e6e4ee1da88f507f36bad503cd329b31eaadccac/libs/openFrameworksCompiled/project/qtcreator/openFrameworks.qbs
I don't have these issues on my mobile browser (using Firefox), the bar is at the bottom for me
There is also the fact that `std::filesystem` hasn't shown up on Mac at all yet in either experimental or stable versions. This means it's a complete no-go for me.
Definitely look into SFML.
&gt;It is not about humans picking up the language, but tools. There is no reason to take already established imperative programming language and modify it other than making oneself feel better about themselves. Do you know any of the reasons why Skylark has different semantics? They are pretty fundamental to what bazel is trying to do.
Well, it is great for being included right out of the box... I guess there's that... But enough with my snark. &amp;#x200B; Then again, I think most of the other graphics libraries date from at least that far back, at least under the covers. Win32 and X11 certainly do. I think the Mac/iOS ones actually date back even further to the NeXT days, but they may have been updated since then.
&gt;&gt;I'm not some naive student &gt; &gt;I'm not saying *you* are, no offense intended. &gt; &gt;I'm saying that "learn C first because it's close to the metal" is not quite true. &gt; &gt;One can read the K&amp;R book and whisper "I know Kung Fu", but the world is complex and that's not really air we're breathing now. &gt; &gt;&gt; C++ is a complex language. C is dead simple. &gt; &gt;Indeed, C++ is complex. Can't agree that C is "dead simple" though. &gt; &gt;&gt;These people are *learning*. They don't need to be bogged down by C++ features. &gt; &gt;So don't use them? They're optional and can be introduced later as you go. &gt; &gt;However, do they still need to be bogged by "dead simple C" features? &gt; &gt;Preprocessor, include files, include guards, macros, &gt;array-to-pointer decay, most vexing parse, variadic functions, manual resource management, integer overflow, null pointer dereference, UB all over the place, you name it? &gt; &gt;Note: unlike C++ features, those are unavoidable. C++ features which *are* unavoidable: * name mangling * undefined class memory layout * code generation - much more than C performs * complications imposed by the STL - bloat, objdump explosion * references vs pointers - the point of learning systems programming is to not hide these things * *coupling* of features, for example: new and delete are necessary for heap allocation and invoking constructors. You have to learn how to use malloc and implement your own allocation scheme. Yet again another thing to bolt on. * Completely distracting and irrelevant semantics wrt the language's AST. * Less intuitive and significantly more complex assembly output. And *again* my point is to use C as a learning vehicle. Then C++ can be effectively learned. I am not against C++. I honestly don't understand why C++ fanatics insist that shoving so much baggage down a beginner's throat is justifiable. It isn't. *Most* C++ that's in production also deals heavily with the preprocessor. Most C++ in production uses pointers. plenty I'm sure is either still 03 or just barely scraping off a pinch of modernity with auto_ptr. In order to be a good C++ programmer you have to understand how C works. That means knowing all the low level details. C++ itself is constructed off of all that. It isn't a replacement, but a good choice for many domains because of the extra features. Using the extra features requires significant study, and that study distracts from learning systems programming. If you are "teaching C++" you shouldn't be teaching C in a C++ compiler. That also causes more problems and creates confusion. So the "opt out of feature X" argument isn't valid. It's those features that make C++ worth bothering with in the first place. You cannot refute this.
Ah yes, I was about to mention Kate Gregory and all her talks and opinions on the subject. Good stuff there.
Yeah, this is a good one. I linked this on the other thread but it's good to have it here as well.
Yep, that’s on iOS.
I say great in that it provides a whole suite of graphics functionality out of the box - drawing of all the basic shapes plus custom ones using things like using the Polygon class, full text support using installed fonts or provided font files, etc. The 2D drawing is very capable and comprehensive. There's built in buffer strategies, AffineTransformations, gradient support, etc.
In general I agree, though I can think of one counterexample: ninja. The language is intentionally minimal, to encourage users to generate build files in higher-level languages. So far I've tried this approach with one small project, and found it refreshing. Other than speed, the killer feature that distinguishes it from its predecessors (e.g. make) is generator rules: ninja knows about the build file generator, so it knows how to reinvoke it when something changes. https://ninja-build.org/manual.html#_philosophical_overview
I'm looking more into SFML and it does seem to have much of what I was looking for. I hadn't dug through the class hierarchy before to find things like the sf::Shape. Need to look deeper. Thanks
Maybe I'm a programming dinosaur now, but has C++ really come to the point one should call "distance" instead of just using the index of a classical for loop?
You want declarative at the higher level. That's usually the best for any codebase that can achieve it. Platform specific dependencies can be done in a declarative way too (look at select() in Bazel documentation). And you want to be able to define your own building blocks too using a reasonable imperative language, for example to describe how to use your code generators. It's been done for a lot of complex projects already and complex codebases too.
IMO, modern C++ is pretty far removed from C. I don't know that learning C first is any longer very helpful. That said, I think C is simple to learn, and an adroit C++ will have no problem learning it. I learned C, 3B2 assembly, Forth, Prolog, some Lisp, and then C++. I did a lot of commercial C++ work, then Java, and some Python. And PHP, sadly. Modern C++ is by far the most complicated of those languages. And I don't think learning C is substantially helpful (any more) for learning C++. There's not enough crossover to be hugely useful.
I would love to see this same post for boost::asio -&gt; std::experimental::network
Why write a loop when it has already been written for you? The great thing about using \`std::find\` and \`std::distance\` is that you don't need to know the type of the container. It works with all standard containers as well as most custom containers that you've not even seen yet.
let's wait till it's renamed/merged as std::network :)
This uses Vector functionality to find the position
Because it's just as quick to code and can be read by basically anyone as it uses simpler concepts. Also we're talking about vectors here.
Why is the code so needlessly verbose, and incorrect? &amp;#x200B; \#include &lt;iostream&gt; \#include &lt;vector&gt; \#include &lt;algorithm&gt; &amp;#x200B; int main(){ std::vector&lt;int&gt; vec = {4,3,6,2,8,9,1,5}; &amp;#x200B; int target = -1; std::cout &lt;&lt; "Enter a number to find: "; std::cin &gt;&gt; target; &amp;#x200B; auto iter = std::find(vec.begin(), vec.end(), target); &amp;#x200B; if (iter != vec.end()){ std::cout &lt;&lt; "Found at index: " &lt;&lt; iter - vec.begin() &lt;&lt; "\\n"; } else{ std::cout &lt;&lt; "Not Found.\\n"; } &amp;#x200B; return 0; }
I primarily use SublimeText with Clang, Meson, and Git on both Linux and MacOS. With some minor configuration it does just about everything I need it to do. As a stack, this is definitely on the faster/lightweight side of things. It is a little unclear what your requirements are, so I don't know if this helps.
Interesting. For those curious, [the blog announcement is here](https://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/).
Thank you, I will take your response into acount.
But real world problems don't come in the form "Do X using vectors". They come in the form "Do X". It is not always obvious which container to use. And even when it seems obvious, it may later turn out to not have been so. As such, it is more useful to learn how to find the position of an element in any container, even when using particular container as an example, rather than how to find the position of an element but in a way that only works with a subset of containers. I would dispute your claim about simpler concepts. This is just a few function calls and a conditional statement. If the idea is to learn how to write an algorithm to implement linear search, then writing a loop would certainly be the way to go.
I was not aware that it is possible to analyze the performance on sub instruction level like this
Visual studio code, clang/GCC, that’s about it. Maybe CMake if you’re getting fancy. VSC has amazing intellisense autocomplete and such with its C/C++ extension. It’s also completely free and supports many other languages, allowing you to seamlessly swap between them, even within the same project.
Vscode for me, despite being a die-hard Linux/open source person for over 20 years! It's really quite good, really flexible etc. Shame it's Electron based, because it might be a bit of a memory and CPU hog for you. YMMV
But the autogeneration of the .vscode folder can be disabled or is there any way to put some global configuration that prevent the generation of it ?
"If you build it, they will come..." Then write one. Come up with some sample code the demonstrate library abilities then compare and contrast.
It reaches 600 mb easely with just the C++ plugin installed
At our local ACCU group conference retrospective meetup everyone else (I coudn’t go this year) had really complimentary things to say about Kate’s talks. Definitely catch them on the ACCU YouTube channel if you have a chance.
Try looking at Codeblocks? It's dedicated to C++. I always thought it was quite nice.
I tried it, but the completition system is a knock off. There is so much potential in that IDE, but is still unmaintened.
Do you use homebrew? [https://formulae.brew.sh/formula/gcc](https://formulae.brew.sh/formula/gcc) [https://formulae.brew.sh/formula/llvm](https://formulae.brew.sh/formula/llvm) Both of these have latest versions w/ std::filesystem. &amp;#x200B; Not sure what version if LLVM/Clang is used in XCode. I'm seeing Google search results that it is less than 5 (or no C++17). Anyone else have a more up to date results?
I'm usually developing with KDevelop and GCC + CMake. I really like the autocompletion and the rainbow highlighting of variables.
Yeah I've known it's existed in homebrew for a while, but that's annoying to try to set up on something like a Travis instance (esp when I don't have a mac locally). I will probably end up buying something like a mac-mini and using that as a apple build server for jenkins. That way I don't have to install llvm every single time. It's just annoying as fuck to deal with. I believe it's AppleClang 10 which is something like LLVM 4 but because they string strip out the original version, you can't tell. It's frankly rediculous that they are branding it as their own when it's just an ancient version of upstream LLVM.
Vim with completor, scripts to update my tags and include paths, fzf for file searching and other fuzzy matching (for example fuzzy searching tags), and AsyncRun for running builds asynchronously. I work in a game studio, so my project is actually pretty large. My work flow is pretty straightforward. I code away until I need to look at a definition of a function or class. I can use \[i to find a declaration of a function I need the prototype for, :Tags (from the fzf plugin) or plain &lt;C-\]&gt; to find a definition of a symbol, gf when over a #include to find a header, and a custom keybinding to run various different builds. Errors from my build are put into the quickfix list which I can select to visit and fix each error. My favorite thing about vim is that I can open huge files that I've seen crash various other text editors without issue. Vim can be as lightweight or fully featured as you want at the cost of a steep learning curve. I gotta say though, once you learn to properly use vim, you'll hardly ever touch your mouse and become an incredibly efficient text editor.
\&gt; I want an IDE/text editor for fast c++ programming, I am a student, just learning new stuff, algorithms, nothing complex &amp;#x200B; The most lightweight "IDE" or quasi-IDE I know about is QTCreator, it runs on Linux, Windows, MacOSX and so on. However, it only works if you create a project that is just a CMake file like the following code. Then all you need to do is open it this CmakeLists.txt file from QTCreator, Visual Studio or Clion and you are ready to go. QT Creator has a checkbox option in the Design button that allows you to set the current executable to run in terminal. QT Creator has a button that allows selecting which target to run where is possible to set app1 or app2. &amp;#x200B; # File: CMakeLists.txt cmake_minimum_required(VERSION 3.9) set(CMAKE_CXX_STANDARD 17) project(MySuperProject) add_executable(app1 app1.cpp lib1.cpp lib2.cpp) add_executable(app2 src/app2.cpp src/src1.cpp src2.cpp) target_include_directories(app2 ./src) Another alternative is Emacs, in this editor is possible to compile any file with any compile with just the command &amp;#x200B; M-x compile g++ main1.cpp -o main.bin -std=c++1z &amp;&amp; ./main.bin The program main.bin can be run inside of Emacs with: &amp;#x200B; M-x asnync-shell-command ./main.bin However, Emacs is a text editor powered by Lisp and has pretty limited completion and no IDE intelisense. QTCreator + CMake is the best deal because it makes the compilation reproducible everywhere and also on any operating system.
&gt; A suitable mechanism is one that (a) uses at run time a copy of the Library already present on the user's computer system, and
I like [juci](https://gitlab.com/cppit/jucipp). It uses cmake or meson for its projects and depends on clang for its C++ related features. It has also snippets, split windows and support for debugging.
...and yet borrow HEAVILY from BSD. I feel your pain.
I must admit, I'm not too worried about 600MB of RAM. It's usually Firefox I've got to keep an eye on, using over 10GB on some occasions! I need to close some tabs occasionally, lol!
I must admit, I'm not sure I get much from vscode+vscodevim that I couldn't do in vim itself!
It's just as quick to code, for one container type, but not as quick to read, not as flexible, and where's the virtue in hand coding something that's already done in the STL?
It really depends on how much you want to dampen the learning curve of vim (I imagine it's a lot easier to install and manage plugins in vscode) and which community of plugin developers you prefer.
I've found the source of this error on my end, it appears to have something to do with Resharper in VS2019. So I've been dealing with this in my game engine, intellisense has been telling me quite inconsistently that GLM types are incomplete. Even in the same line, for example `Vec3 points[2]{Vec3{0.f}, Vec3{0.f}};` tells me that that the first use of Vec3 is incomplete, but the other two are fine. It's like that in every single file in the project using GLM. **The ONLY solution I've found was to completely disable the resharper extension and restart VS.** Worked like a charm. What's odd is that I use a few different boost modules and they're not light weight, yet intellisense seems to have no problem with them. Cheers.
May I ask you why you initialise with -1?
On Linux, rtags + emacs works really well.
I guess I don't have to worry about the learning curve of vim itself. I used vim for a long time before vscode existed. I use vscode for python mainly at work, but also for f#sharp, rust, javascript and typescript, haskell, and of course c++. Installing plugins for all of those was indeed very easy. I'm well acquainted with gdb, pdb and others, but the integrated debugging is nice and easy too. The vscodevim plugin is one of the best vim emulations I've used. Other ones I've tried have been missing fundamental things like operations on text objects (delete inner word, diw, change inner quotes, ci", yank inner parentheses, yi(, and the like)
Both of them are heavily in flux and what's getting standardized will only be a subset of asio anyway, so I don't know how useful that would be.
So it’s easy to tell when the program didn’t find the position
I initialize it because of the reasons here: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-always) Otherwise, target could be uninitialized if the user did something like press Ctrl+D when prompted for the number. \-1 is arbitrary in this scenario. In this case, it signals that there was no input given. If we had negative numbers in our array, we would need to find a different way to signal that there was no input given.
&gt;at run time
Yeah, that's one IDE feature I haven't seen in vim yet. I use Visual Studio (the full IDE) to debug and otherwise use vim for development. I've heard a lot of good things about vscodevim. I imagine the biggest sacrifice between the two is memory usage.
The code is not incorrect . Yeah but there are more fine tuning that can be done to optimize it.
No, it is wrong: * The includes are missing #'s * "vector V;" is missing the template arguments * The iterator declaration(vector::iterator iter;) is missing template arguments * It is missing a closing bracket after return 0;
Didnt even know thats possible. Thank you
One thing that gets somewhat mixed up in those discussions is learning C versus learning the low level subset of c++ first. You have to teach a lot of low level stuff pretty soon (not from the start though) but even then, you don't have to teach C.
The position isnt stored in target. Its the target to search for. - 1 would be totally valid
neovim master/nightly + coc.nvim + ccls as basic start.
CMake is used mostly by C++ crowd, and CMakeSL is supposedly a lot like C++. Also, it's statically typed and compatible with clang syntax highlighting and formatting tools that are available for C++. Ideally, you don't have to learn or setup anything new. I'm not trying to advocate for CMakeSL here (I'm fine with modern CMake as is), but I don't get why people are so adamant on mentioning alternative languages of their choice here. The biggest hurdle would still be learning CMake API with its hundreds of functions, built-in variables and properties, its weird scopes (that make sense in retrospect), target interfacing and dependency mechanics, generator expressions, etc etc. Trying to translate it to something not domain-specific like Python, Lua or even Skylark (last time I heard it wasn't Turing complete?) will only make it more painful IMO.
QtCreator is pretty nice. It is pretty responsive, has good highlighting, code completion, inline errors/warnings, etc. It sets up a project file for you, so you don't really have to worry about that at all (this is going to be the case for pretty much every IDE).
I would say that the comment probably points out to SUN/Oracle supporting Swing and then Java FX more as the go to choice for 2D graphics and GUI development in Java.
I’m on iOS and not having problems either
I wouldn't be so optimistic. Response from some [core](https://lists.boost.org/Archives/boost/2017/07/237250.php) [members](https://lists.boost.org/Archives/boost/2017/07/237435.php) has been less than enthusiastic and it looks like the decision was left up in the air to avoid alienating the main workforce behind Boost.
And a nice thing about VSC also is that it is essentially the same under both Windows and Linux, so it's a pretty good choice for cross platform work.
Emacs with ccls for completion and other ide features.
I use Notepad++ with NppExec plugin. NppExec lets you run commands and scripts from console window in Notepad. I wrote this scrip wich runs C++ compiler on current source file and if there were no errors during compilation it launches the executable. Output goes to notepad console window. g++ -std=c++0x -static -Wall $(FULL_CURRENT_PATH) -o $(NAME_PART).exe if $(EXITCODE) == 1 then exit endif $(NAME_PART).exe exit You can save scripts and then choose them from drop-down list. Run script from the list for the first time and after that just use shortcut to run the previous script. If you spend a couple minutes configuring the plugin you can make it highlight the errors and warnings produced by a compiler and jump to line by double clicking on them. Read the answer [here](https://stackoverflow.com/questions/13931641/can-notepad-be-configured-to-recognize-compiler-error-messages-and-jump-to-the) to see how it is done. Notepad++ itself is very lightweight, launches in a second, usually takes about 20 mb. of ram. It also has syntax highlighting and auto completion of text you have previously entered.
I am using CLion in Linux(and macOS), usually have like 4 to 8 open CLion windows, never had issues with ram(16g on board - HP laptop). I am satisfied with CLion, but if your project is not based in CMake - you’ll end up losing 50% of functionality. I used to code in VSCode, but I seriously lacked C++ analysis done by CLion...
&gt;And again my point is to use C as a learning vehicle. Then C++ can be effectively learned. There are two problems with that: * Idiomatic C code != idiomatic C++ code. * Old habits die hard. It is hard to stop writing macros / stop clearing structs with memset / stop copying with memcpy / stop using printf / stop doing manual resource management / stop using void\* / etc. because all that is legitimate, valid and idiomatic C and it still *compiles*. And at the same time all that is a can of worms in C++ world, waiting to explode in your face. &amp;#x200B; &gt;I honestly don't understand why C++ fanatics insist that shoving so much baggage down a beginner's throat is justifiable. People that you're calling "fanatics" have seen way to many horrible bugs and too much abominable C++ code written by experienced C programmers. &amp;#x200B; &gt;I am not against C++. I don't think anyone here is against C. It has its uses. Being a good learning vehicle is hardly one of them though.
I use CodeLite, GCC ([MinGW Distro - nuwen.net](https://nuwen.net/mingw.html)). Notepad++ for GLSL. At the moment I only program in Windows.
I always have problems compiling using Visual Studio Code. The default way that it's handled using json files isn't the best. I'd love it if it had cmake or makefile support.
I have always been a fan of Visual Studio and have been using 2017 and have been developing for linux in it using the cross platform development stuff. [https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/](https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/)
Gunplay, maybe: http://www.gnuplot.info/links.html
Even for systems/embedded stuff there isn't a real reason to prefer C, it is just used by Linux for legacy reasons.
That function was indeed a race condition. However, `std::filesystem::temp_directory_path()` is still valid, so if you can generate a random string, you can reproduce `unique_path()`.
If you distribute the library, the point is usually to use it. Not to mention you are in fact *distributing the library* (not just a derived work) so you have to follow the rules of the LGPL in doing so.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/blhgqt/hi_need_help_with_grayscale_converting/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Have a look at [VisIt](https://wci.llnl.gov/simulation/computer-codes/visit/) and its associated libraries - file I/O is via C interfaces to the [Silo](https://wci.llnl.gov/simulation/computer-codes/silo) library.
Have a look at VTK: https://vtk.org/
Emacs has loads of completion options. It's not the easiest to set up but works quite well.
There are existing visualization apps which you could use, you’ll just need to output your results (e.g. nodal disps or whatever) in the format the apps expect. I would take a look at what the Deal.II library uses for visualizing results - you could also look at their code for converting to the correct output formats. (On mobile or Id give more links / info)
Why does the configuration folder matter?
* I'm using neovim together with neovim-qt and with YouCompleteMe (a plugin for clang-based code analysis and completion) * I use CMake for all my projects, it has a steep learning curve but otherwise it's great * I use VCPKG to manage dependencies on Windows (when necessary) * In the past I've also used QtCreator and it's quite ok
&gt;CMake is used mostly by C++ crowd, and CMakeSL is supposedly a lot like C++. Also, it's statically typed and compatible with clang syntax highlighting and formatting tools that are available for C++. Ideally, you don't have to learn or setup anything new. Ah, that greatly mitigates my concern. Copying C++ is good too.
Visual Studio &amp; Windows. Otherwise g++ and Linux for small projects or Linux only projects. I can't be asked to program large projects in Linux since the command line gets pretty tedious compared a single button in VS.
thank you.
thank you.
thank you.
thank you.
I use Sublime+ClangComplete with CMake.
On mac I used CLion but I ended up switching to Xcode as it is just *so much faster*
Hmm, good point. I've only dabbled with Java graphics, so I'm not fully knowledgeable with all they had to offer. It does sound like it has a very rich set of functionality though -- richer than what the underlying OS natively has built-in, anyway.
Isn't Swing based on top of AWT though, at least to an extent? I could be wrong.
Due to vehement opposition, the 2D graphics library is very unlikely to make it into the standard anytime soon, at least not in its past form.
I've been very happy with VStudio forever. But, I'm wanting to try out VSCode+Clang+WinDbg soon.
Oh... I just assumed it to be the position after I saw -1
It has CMake support through an extension, I've been using it for a couple of weeks and it works great
It sure is, Swing wasn't direct replacement to AWT , every container in Swing extends a top level AWT container. I do recall importing AWT modules to use with Swing some 6-7 years ago when I wrote Java 6.
I think your question is a bit vague because you say you want a "IDE/text editor" . Those two pieces of software are poles apart in terms of functionality. If you're going to be writing 1-2 pages worth of code, really its not that big of a deal.. just use any text editor. I know others may disagree, but I'd personally advise against investing your time in vi or emacs or other such editors. I have spent countless hours getting proficient in vi when I was still learning how to code. I finally came to the conclusion that I spend the vast vast majority of my time just thinking about/read code and/or debugging it. Getting efficient at text-entry has no net benefit for me. Visual Studio has a very easy to use C++ debugger, so thats probably a good option while you're still learning. You can edit your files elsewhere (I can suggest Notepad++) and debug them in Visual Studio. You can ofcourse learn to use other tools, but at some point you'll have to choose whether your time is best spent learning new tools or learning how to code. Good luck!
opengl
We'll have to agree to disagree here I'm afraid, my understanding is that the following two steps are compliant: 1 - Distributing object code without source as per GPLv3 6(d) 2 - Distributing a Combined Work that links dynamically to aforementioned object code under LGPL 4(d)(1) And that (1) being available *at run time* of the Combined Work really is key here; it's not "at install time", which may have made your case.
Landscape orientation? This was on an XS, so maybe it is the notch... I’ll try upside down tomorrow.
It's closer to 6 in ore language things and really depends on the libc++ things. I have a tool that outputs the status of all the feature flags and it is a mixed bag for C++ 17 and on
temp files was a real pain to do cross platform. I think I got it correct, but it's a race... https://github.com/beached/libtemp_file/
I think I read somewhere that TLS won't be. But that was a layer above anyways so people can implement or use boost with std::network and it's implementation
That is truly bizzare. I wish they just shipped LLVM proper.
You can take a look at Qwt: https://qwt.sourceforge.io/
https://skia.org/
Not to mention the lack of identation, the inconsistent case of the first characters in identifiers and the hideous global "using namespace std;" ... while none of these are technically wrong, they are morally reprehensible.
True, but I feel like there’s a greater focus on memory/resource/process management in early material, compared to C++ where it’s easier to just use the STL and not consider the low level details/costs.
If you go with a common file format (xdmf/vtk/hdf5) you can choose between ParaView / VisIt or any other tool that is based on VTK.
&gt; Of course you will need to read this quickly, since it'll probably get down-voted into oblivion. Please don't complain about potential downvotes; that's contrary to [reddiquette](https://www.reddit.com/wiki/reddiquette).
This is cool and why I browse Reddit.. Saved. Thanks.
I recommend C++ Templates: The Complete Guide (I learned from the first edition; you'd want the second edition). I found it to be highly readable, yet highly precise - an uncommon combination. Effective STL and Effective Modern C++ are also quite important. I don't recommend Modern C++ Design. Its techniques are outdated.
std::nullptr\_t ?
A TS implementation can prove useful even if it doesn't end up being standardized. ;-]
every time I come accross a thread like this I suggest my own personal favourite, kdevelop: [www.kdevelop.org](https://www.kdevelop.org) available on linux and windows, and much lighter weight than something like CLion though with plenty of features. I've noticed in recent versions occasionally there are some problems with the background parsing/ suggestions in terms of performance, but the latest version appears to be fine.
Or, they could remove the down-vote mechanism so a-holes can't use it and the problem, along with a whole raft of toxicity that exists here, would just go poof. It's just a form of passive aggressive censorship used to suppress anything that doesn't toe the current dogmatic line.
You'd be wrong. I've spent the last two weeks seriously digging through openwrt's system programs, namely procd, ubus, uci, rpcd, and so on. These projects claim to focus on memory / resource/ process management, but really they're just an unreadable mess that, once you decode everything and mentally translate things into the appropriate c++ idiom, are roughly the equivalent of oddly-written c++ code in terms of outcome. But they use 50+ lines to do simple things like iterating over a list (which, as we all know, is a 1-liner in c++). Or global variables. EVERYWHERE. I would be perfectly comfortable wagering that if these projects were rewritten in modern c++, the performance would compare very closely.
The biggest difference I’ve had to program around is how absolute paths concatenate. A trailing absolute path replaces the leading path in std::filesystem and is appended to the leading path in boost::filesystem. Some surprising behavior results if you aren’t thorough.
POSIX defers to the standards committee, just not to random people writing programs.
https://github.com/memononen/nanovg ?
The problem is more a lot of cargo culting and people who absolutely want to use C when the device can definitely support much more than a simple short program. If you have a very small chip with &lt;1MB of total memory, you definitely want to be careful if you ever use C++ cause there is some bloat there if you include the wrong headers. If you have a few MB of memory, unless you do terrible C++ code you'll be fine.
..."random people writing programs..." and following cargo cults know jack sch!tt about standards.
Have a look at this. [https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/](https://devblogs.microsoft.com/cppblog/linux-development-with-c-in-visual-studio/) &amp;#x200B; Its what i use for linux development on my windows machine.
Thanks for the share!
Are you using a proper vscode project? I don't get any pollution when I use it to open a non-vscode project's top directory on linux.
I really don't understand what point you're trying to make, by citing types that are part of POSIX.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bll70q/looking_for_a_good_book_to_learn_c_for_someone/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I thought for sure the behavior you described couldn't be right, but it is: namespace fs = std::filesystem; fs::path p1 = "/a/b/c", p2 = "/x/y/z"; assert( p1 / p2 == "/x/y/z" ); and Boost: namespace fs = boost::filesystem; fs::path p1 = "/a/b/c", p2 = "/x/y/z"; assert( p1 / p2 == "/a/b/c/x/y/z" ); I'm not sure what the logic there was, but I think the Boost behavior is far more intuitive.
Checkout root https://root.cern.ch/
I use std::filesystem on every platform including apple with Travis support without any problem: https://github.com/Milerius/nephtys
I don't see how this proves me wrong. If anything it backs it up. The C++ idioms and 1-liners being mentioned would probably be from the STL, in which case the user would not see the low level details, as your describing. This sounds more like a complaint about the verbosity and duplicated work in C code, rather than an argument that C is worse or on par with bringing low-level details to the forefront.
My work project is quite large and has special runtime requirements for a dev setup, so here's one of the dev machines that each engineer gets: Hardware: 8c/16t cpu, 48 GB of RAM, 4x 4k monitors, CentOS Linux. Version Control: Git/Gitlab Build System and Tooling: CMake, Conan, and Python 3.7 IDE: CLion, although other team members use Eclipse CDT or Emacs. Toolchain: GCC 8.2.1 and Clang 8.0.0
Wow she's so cool!!! Everything she does is so cool!!!
My wife did similar work in her master degree. She did the computational physics experiment but were unfamiliar with data visualization. I taught her to use [matplotlib](https://matplotlib.org/)(in python). Her supervisor liked it a lot and showed her thesis around. If you are just looking for plotting library, I think matplotlib is really a good choice.
Noooo :D Root is powerful but most people who had to work with it hate it
Is there a reason why you are coding this yourself instead of using a mainstream fem library? As other people said, don't waste too much time with graphics, just output to a format that you can use in another program to make the plot you need, for example paraview.
As a side note, maybe you can use already existing C++ FEM codes. For example [deal.II](https://dealii.org) (already mentioned) or [Dune](https://dune-project.org/) can take care of the heavy lifting, i.e. assembling, linear algebra, parallelization, io, etc. Additionally there are also python based FEM codes with good scaling capabilities, like [firedrake](https://www.firedrakeproject.org) and [fenics](https://fenicsproject.org).
Deal.II can write to quite a few formats. They recommend writing VTUs, and the using Paraview or visIt to visualize the results. You can find more info [here](https://dealii.org/developer/doxygen/deal.II/classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc) and [here](https://dealii.org/developer/doxygen/deal.II/classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f).
I seem to be saying this a lot, but take a look at AngelCode. It's a scripting language that shares a large part of the C++ syntax, which seems particularly appropriate for this case given that it is intended as a cornerstone of the C++ ecosystem. I've been using it quite a bit recently and found it pleasant to integrate and work with.
It's perfectly possible to use QtCreator without cmake. Do `File &gt; New file or project &gt; Import existing` and browse to the folder containing your files. Then open the "Projects" tab and set commands for building and running. This is what I do for my meson projects, works like a charm.
This is the behaviour Python's `os.path.join()` has as well. The reasoning is, provided `base` and `path` variables, `fs::absolute( base / path )` should return `path` if `path` was already absolute.
In addition to the short and long layouts, their representation includes a "raw" layout that gives access to the representation as a sequence of words (I guess clang allows them to do this). Does this help?
@scatters -&gt; "raw" layout gives access to the representation of sequence of characters
Need some feedbacks! This project was a toy project developped after an interview where I was asked to develop a small interpreter in C++. I was bored to develop all the machinery for such a small and dummy instruction set thus I developed mvm... It is a toy project and, as for now, I don't think it is useful in anyway. However, I would be glad to have some feedbacks if it could be useful in some manner even if it means to bring some major modifications to it...
For me it has uberfeature. QtCreator can provide code navigation even if a project is not buildable on your system. It's super helpful.
If you haven’t seen it, you may be interested in [this video](https://m.youtube.com/watch?v=kPR8h4-qZdk)
Thank you very much. really interesting. I'm creating my own FEM code because the geometry is simple, cylinder, but is not isotropic and also depends on the geometry. Mainly, each element is different, and proprieties vary with the direction. I want to perform a modal reduction of this model and then perform some dynamic simulations. The thing is that if I have my own code I can do everything with out an external software (that I must to learn). I've everything done in MATLAB, but is really slow, so I want to port it to C++. I think that Armadillo is want I need, but i don't know how to plot the results. I'll keep an eye on deal.II, it looks good.
@F54280, I have already watched this video. It's really a good one and anyhow thanks for sharing
Yes there is, from my previous message: I'm creating my own FEM code because the geometry is simple, cylinder, but is not isotropic and also depends on the geometry. Mainly, each element is different, and proprieties vary with the direction. I want to perform a modal reduction of this model and then perform some dynamic simulations. The thing is that if I have my own code I can do everything with out an external software (that I must to learn).
In \_\_short, if \_\_lx is the active union member, the implementation can treat it as the 0 index of \_\_data, since they are contiguous, effectively adding an extra character to the SSO buffer (i.e. \_\_short stores \_\_n\_words +1 of value\_type). This is just a guess.
Machine words, the natural size for processing data, typically the size of a pointer. So 64 bits on most modern architectures.
Understood. Do you know any advantages(basically uses) that we gain with this "raw" representation?
Thanks, I didn't read the whole thread. I'll keep writing only because you specifically asked for opinions. The characteristic feature of your problem is not a deal breaker for software like fenics, feel++, deal.ii or similar. I strongly recommend using one of these high level frameworks: they are open source and they don't take long to learn. They natively support a lot of stuff like elements of arbitrary order from a variety of families, and if tomorrow you want to try something different you can without wasting time implementing it. Concerning Armadillo, reading through the feature list it doesn't seem to support distributed memory parallelism, which means it's pretty limited for 3D problems. Again I'd use something mainstream like PETSc or Trilinos (usually integrated in the above-mentioned frameworks).
&gt; I'm creating my own FEM code because the geometry is simple, cylinder, but is not isotropic and also depends on the geometry. Mainly, each element is different, and proprieties vary with the direction. That looks quite interesting! I am doing something similar (dynamical + inhomogenious). Deal.II does not really care about the isotropy or homogeneity of the system. It is "just" a FEM library. &gt; I think that Armadillo is want I need, Possibly. Armadillo is a Linear Algebra library, not a FEM library. This means that it will be quite good at the linear algebra parts (for instance, the solving of the mass and stiffness matrices), but will not help you further. In addition to the linear algebra bits, a full FEM library will also help you with assembly, DoF numbering, meshing, etc. If you want to use a full FEM lib or write those things youself, it is up to you. Whatever makes sense to the problem at hand. Keep in mind that Armadillo is only parallelized with OpenMP, so no MPI there. Two famous linear algebra libraries that *can* deal with MPI are PETSc and Trillinos. However, they are harder to use than Armadillo. If easy to use is your focus, go Armadillo or Eigen. If, on the other hand, you want speed and parallelism, check PETSc or Trilinos. &gt; but i don't know how to plot the results. As people said before, VTK is commonly used to write meshes/data on meshes, but can be a bit daunting. There are number of easier file formats out there that can work with really good renderers. A few examples are STL and PLY. What I would strongly recommend against is to make your own file format. That way, you lose on the interoperability with these great programs (ParaView/VisIt) that **really, really** help. I cannot overstate how amazing Paraview is.
Agree about compile time, most likely tests are build by some continues integration on background, or if by hand only some filtered subset of them, hence compile time shall not be a issue. Yet on the other hand, runtime overhead can be a burden. If one is running very specific set of tests which might be somehow connected with each other, then runtime might be a key. Long time ago, I had a problem with googletests that my tests were failing if some order was taking place, let say if test A was run before test B. I guess that it was some problem on mine implementation, yet runtime overhead can be an issue i guess.
depending on what you are trying to do, processing 8 characters (assuming ascii or other 8-bit characters) at a time is a heck of a lot faster than 1. an example of the above would be a hashing algorithm... especially if you are hashing half a billion strings.
&gt; If you co_await another coroutine, your state object just stores a coroutine_handle to its state object, which is a separate allocation. Bummer. &gt; Ideally these allocations can be elided and placed in the caller's state object, effectively computing the maximum needed stack size automatically, though I'm not sure how often this happens in practice today. Is there a way to enforce this, or query whether this is happening and get a warning if it isn't?
I can see that libcxx uses the "raw" representation in zeroing (clearing) the string, and in the copy and move constructors and assignment operators. I'd guess the advantage would be better performance in debug builds, since the release (and RelWithDebInfo) codegen should be identical.
Thank for your response. A couple of questions, * Can Deal.II give me the stiffness and mass matrices? If yes, how? which format? * Can I add different material properties to each element based on its position? As I said, my code, made on MATLAB, works. I can mesh, number dofs, add constrains and forces. I can get the needed matrices and work with them. the only problem is that is slow if element number is big. Another problem is that i'm trying to add geometric nonlinealities and I don't know how. But i'm on it.
I have installed deal.ii and I'll test it, let's see.
I admit I never used the precompiled deal.ii. I always compiled it myself, so, take care which version you are using.
@krista\_ &amp; @scatters: Can you point me in the direction where I can read more on this?
&gt; Can Deal.II give me the stiffness and mass matrices? It can help you build it. Of course, the matrices are going to depend on the specific problem at hand, so you have to do some elbow work as well. I really recommend you read steps 1 to 6 in the [tutorial section of deal.II](https://www.dealii.org/current/doxygen/deal.II/Tutorial.html). They give a really good overview on the basic steps on how to solve a FEM sytem. &gt; If yes, how? which format? That is configurable, but normally you don't need to deal with the format, as it can also solve. &gt; Can I add different material properties to each element based on its position? Yes! In the end, it just depends on how *you* build the stiffness matrix. &gt; the only problem is that is slow if element number is big. Well, it is kinda expected. Any system is going to slow down when going to high number of dofs. Further, it is possible that the blame lies on the specific solver you use, rather than on matlab itself, but that is quite a deep topic. BTW, Deal.ii has been shown to scale really well for system with up to 1 billion DoFs when solving Poisson's equation, supposing you have enough processors. &gt; Another problem is that i'm trying to add geometric nonlinealities and I don't know how. But i'm on it. What do you call geometric nonlinearities?
Have a look at [cpp-io2d](https://github.com/cpp-io2d/P0267_RefImpl), which may become a standard C++ API for 2D graphics. It most likely doesn't match the functionality of Java equivalent, though.
Upvoting this because it probably is just easier to make code in c++ that does computations for you which you just save to a file and read from python or even matlab.
I was using VSCode. It has the C/C++ extension but apparently it runs another backend extension instance for every text files you open. It uses at least 1 GB RAM for so little feature (as expected from a text editor). I would say just use CLion and i3wm if you're short on resource. I use it now just fine and I only have 4 GB RAM. Otherwise, QtCreator. It doesn't click with me but you can try and see if you like it. These are the only real option for you. There's also other minor project like Code::Blocks or KDevelop but I figure you probably can't stand using it because you've tried modern IDEs and are accustomed to that level of user experience. Hope this helps.
What compiler versions and options are you using?
I'm using clang for both, unfortunately I'm away from work so I can't give you the exact version. Both are in debug mode with no optimisations. The code is exactly the same minus some directory creation code.
I'm using clang for both, unfortunately I'm away from work so I can't give you the exact version. Both are in debug mode with no optimisations. The code is exactly the same minus some directory creation code.
LuaJIT would be a really nice option imo. Blazing fast and stable, no multiple version breakage to speak of at this point. Tiny and easy to embed and integrate, particularly with FFI.
Also how are you profiling? So you have any function sampling on to show that the allocations themselves are what’s taking longer? Are you using something aside from the builtin allocator (like jemalloc or tcmalloc or something)
BTW, this looks quite good, I mean the solution of the same task in CMake would be much harder to read.
On windows I'm using visual studio 2017's profiler and on MacOSX xcode + instruments's time profiler. I ran the source with a large geometry input and profiled each code segments time to execute. I have each compute function labelled and profiled and noticed that compute functions with matrices resizing had a much longer run time on windows Vs MacOSX. As for the allocator it is tied to Eigen C++ internal allocator. I did not have a good look at it but I believe it has some custom memory alignment and management.
Why profile in debug? &amp;#x200B; MSVC uses a different runtime when you are in debug, it is slower by necessity. Perhaps Clang is also using it. &amp;#x200B; Anyway profiling in debug is really pointless.
&gt; Both are in debug mode with no optimisations. &gt; &gt; Yeah, then this is useless. Sorry, performance profiling without optimization is just not useful, you're going to be hitting red herring after a red herring. Is there even a difference in performance with optimized build?
What was the difference in perf when compiled in release mode with no profiler attached?
Hmm I did profile in release mode but the debug symbols made it impossible to properly view the parallel stacks properly. As for MSVC I swapped it out for Clang in visual studios 2017 to remove any compiler related issues. Just to be clear I did not run a diagnostic session but used the run time profiler. I am not sure how much the overhead difference is for the different tools provided for visual studios Vs MacOSX instruments so I opted for the lightest profiler
&gt; What do you call geometric nonlinearities? Big deformations. nonlinearities can be due to material, forces or geometrical. In this case, big deformations, better, not small deformations.
I'm compiling it. Precompiled version for my machine (ubuntu 18.04) does not work with all examples
I've been using KDevelop many years ago, but for the last 6 years I'm using Qt Creator almost exclusively, and Visual Studio when I'm forced to (which is mostly for when I need to deal with C# projects.) I use Creator for both C and C++. For projects that actually use Qt I use qmake as the build system. For non-Qt projects I use CMake or the GNU Autotools, both of which are fully supported by Creator. Built-in support for clang-tidy and clazy static analysis, and support for "live" clang-format code formatting and indentation make Creator quite a joy to work with. My main environment is Linux, and I have several VMs set up using VMware Workstation to test and deploy for the three currently supported macOS versions, Windows 7, 8 and 10, and some key Linux distros (like Ubuntu LTS.) The macOS VM also allows me to target iOS.
AWT was written around the concept of OS specific 'peer' classes. An AWT window was tied to local OS window, and AWT button had a local OS peer button. AWT apps could not be themed or styled because the rendering was handled by the peers. If you look at java.awt.Toolkit you'll see a number of functions like **createCheckbox** or **createButton** that return peers. Swing was a project started by James Gosling after they moved him out of the leadership of Java when McNealy was pushing hard to commercialize it. Gosling took a number of ideas from the [NeWS](https://en.wikipedia.org/wiki/NeWS) windowing system that he was primary author on and was based on Postscript. Swing has the concept of heavy and light components, where heavy ones are still tied to native peers, but light ones are basically draw commands on a canvas like component. The Swing heavyweight components are JWindow, JDialog, JApplet and JFrame. So the java.awt.Graphics &amp; java.awt.Graphics2D functions are used in the Swing components to render themselves utilizing the large collection of draw functions those two classes provide. Using these drawing functions for the widgets versus letting the OS peers do the drawing is why Swing can have a pluggable look and feel.
Performance difference between win10 and Mac is the same relatively. The actual timings off the top of my head in release mode are Windows 10: 2hrs~ MacOS: 7mins
I'm not sure what profiler you are referring to. I'm hoping you mean the one available at: Analyze-&gt;Performance Profiler, then run the CPU Usage profiler? &amp;#x200B; I'm not sure why you are having issues with symbols, perhaps this is related to switching to Clang instead of MSVC? I use this profiler in optimized builds all the time, and the symbols show up just fine.
Yes there are. The performance in release mode have the same relative time differences. I'm looking at the windows build being slower 20x than on MacOSX
Yes, that is the profiler I'm talking about. As for the debug symbols I believe all I need are the .pdb and .obj files from the build? For some reason even when those are configured in the linker in release I do not get debug symbols. Just the cryptic .dll traces
Ah, yes. You can handle nonlinear elasticity just fine. You mention you are doing the dynamical version. In that case, it is relatively straight forward; you just use the FEM part to calculate the forces and then iterate the system using Runge-Kutta, or some other classical ODE solver. I don't think deal.II has any examples on how to do nonlinear elasticity + dynamics. But at least for the former, you can check step-44.
Great. I also use Ubuntu 18.04 on my machine. Are you using the deal.II candi installer? It makes the whole process much easier: https://github.com/koecher/candi
thank you, i'm running it
I'll investigate. I want to perform a modal reduction. If I can do that with deal.II, the dynamic part will be done on MATLAB
If you want to mention people use u/ and not @.
What you should do and what one normally does is create a build with optimizations (and with the MS release CRT), i.e. release mode, but \*with\* debug information. The debug information will actually not slow down your build (or not more than an insignificant bit) but will give the profiler all needed information. CMake has a pre-defined mode for this called "RelWithDebugInfo". Comparing performance, particularly of matrix multiplications or resizing, is pretty pointless in debug mode (unless you're the author of Eigen and want to make your library fast for people that have to use it in debug mode, for reasons \*\*other\*\* than profiling).
It cant be real, i got around 10% faster code on Linux vs Windows but it is based on the final product These differences migth be because it is not the final compilation and take advantages about all the tricks OSX do in order to offer a smother experience, clever tricks in my opinion And as has been told once you get the final product is when you start to do optimizations, in debug things works in other ways, debug works if you want to know things related to the algorithm like changing one thing for another and see if it is significantly faster. Other things like that has to be when proper compiled, the compiler will do many things that will not happen when debuging
Resizing matrices should not be a frequent operation. If it is, maybe you should refactor your code anyway. Could you post a code snippet where you call resizing?
Can you develop the code in C++ but keep plotting in MATLAB? MATLAB is incredibly good at plotting, no C++ library comes close, no other library/tool whatsoever actually, not even matplotlib (Python).
See also the follow up posts \[[1](https://concurrencyfreaks.blogspot.com/2019/04/onefile-and-tail-latency.html), [2](https://concurrencyfreaks.blogspot.com/2019/05/onefile-and-wait-free-balanced-trees.html)\]
Just from a quick glance, exposing C++'s data types wouldn't be something I think we'd want. Build scripts need integers rarely to begin with and most of that is probably in service to things like version number comparison/extraction. We also almost certainly don't need to handle reference/value semantic differences in a build script. It looks useful for other domains however, just different ones than CMake works in.
u/lordphysix Oh thats good. Thank you
Thanks. I will give this a try tomorrow and update.
If that's true then we still haven't found the solution to make build tasks easy. :) I know that there are lot of factors to consider and you can only make build scripts small and easy to certain degree but... The fight is not over :)
I believe these OSX tricks have a huge role to play in how Eigen and TBB interact with mallocs and multithreading. I've been suspicious of the tbb::parallel_for since it is not guaranteed to be executed in parallel and is dependant on the bandwidth of the current resources. Do you happen to know of any links for these compilation differences? I think I would need to dig deeper for these just to identify the default behaviours and the edge cases for those.
I do not have access to the snippet now but to briefly describe the algorithm, I am pruning a 3d mesh and calculating a herustic for each vertex on the mesh. If the herustic value exceeds a threshold that vertex is flagged to be concatenated after the loop finishes to another matrix to compute a second herustic. There is no way to determine the dynamic size required prior to computation. (E.g. compute closed list size in A*) I will try to make a small example of the code snippet when I get access to a desktop.
I mostly use visual studio as my primary c++ IDE and atom as my editor. I think there’s way better applications but these two are pretty good for me. Simple but efficient
You can look up for common optimizations that compilers does but dont expect a miracle, the compiler will do it best but it is not GOD, it cant make perfection if not helped For example one of that is replacing i++ for ++i as the second one is faster allowing you put the suboptimal in the code for visual reasons and latter on it will changed when compiled. It works as long as the compiler it sure that would not break the code, if it finds [i++] it will not change it most probably or any cumber case, if it doubts it will leave as it is I suggest that you start eliminating variables of the list, dont use more than one core and see if it still happens, maybe you has data races or locks that arises on Windows making it slower, who knows, it could be. Definitely will be the first thing i will change in order to check what it is happening. If not i will try a quick fix like telling the vector to get more capacity (capacity and elements inside are not the same thing) and if forced use a custom allocator, it doesnt to be perfect, we are only looking at what it is the matter. Once it is clear is when one moves ahead and solves it If the code is well coded you can bet that Linux/OSX are going to be faster than Windows but not 20 times faster, maybe a 50% and i dont know if it is even posible, Windows is not the best OS but it is not bad
It and it seems a very nice IDE. I will try using on some weekend project, thanks for the suggestion.
This seems to be the consensus. It's a shame the original guy I was discussing this with didn't weigh in. Thank you all for your comments.
&gt; tbb::parallel_for since it is not guaranteed to be executed in parallel wat
Nice solution, but this hack won't work sadly because you need a full CMake project description. Just use a simple CMakeLists.txt, such as cmake_minimum_required(VERSION 2.8.4) project(assignment1) add_executable(moep src/arguments.cpp src/assignment1.cpp ) and then you should be able to debug through CLion.
Some of it matters, like which include paths you want to add so that intellisense can help you with auto completion and linting checks. There’s loads of stuff you can put in to make some configuration project specific rather than global. I believe if you don’t want it you can just delete it.
I don't know, but I suspect it is because they modify a lot to build the swift front end and maybe the Mac back end. I don't know though
For C/C++ projects it’s basically for adding include paths other than the standard includes to aid with auto completion and other intellisense features. If you don’t care about this you can delete it.
Also, if you're replying to someone they already get notified, you don't need to "ping" people to get in their message box. A simple reply works just well for the person you're replying to
However when I think about it that way it should be possible to debug the executable, but you need to manually configure the debug configuration in CLion but I do not know exactly how. Also you would need to edit your CXXFLAGS: CXXFLAGS+=-Wall -Wextra -fdiagnostics-color=auto -ggdb
How large are the matrices, are they exactly the same on both systems, and what are the both system specs? Essentially, can you rule out that this is caused by a different processor, larger cache, better memory bandwidth?
Maybe you can pre-allocate the second matrix by using the maximum number of vertices that can be added?
Neovim, vim-lsp, clangd
The run times between windows and MacOSX differ as the input size increases. Here are some stats from the release mode builds to give you an idea: Inputs: Sphere.obj - 36mb - float[800 x 3] Car.obj - 1280mb~ - float[20000~ x 3] (~ is a rounded down estimated value) Windows: Sphere.obj --&gt; 80~ seconds runtime Car.obj --&gt; 2hrs 7mins runtime MacOSX: Sphere.obj --&gt; 60 seconds runtime Car.obj --&gt; 7mins~ runtime Smaller inputs have smaller differences between the two different operating systems. As for the hardware specs: Windows - 3.6ghz + 32gb ram MacOSX 3.2ghz + 16gb ram It is a mac mini and I could be wrong with the specs. But the windows is definitely a more powerful (specwise) machine than the Mac mini. Processor wise I am not familiar enough to rule it out completely but the windows is using an Intel processor.
This is something I might try to do as a test to see the speed differences to a os resource call for malloc. Unfortunately it is not a practical long term solution because I will be tripling or quadrupling the memory usage. Some of the larger input sets are upto 800mb and some getting as large as 2gb.
Hi guys, are there any tickets left?
Exactly
In my experience, C *can* be used to teach C++, however this should be done only as an explicit stepping stone. C++ is massive, and can get very confusing very quickly, C on the other hand has much fewer constructs, and extremely advanced features aren't baked into its most basic constructs. If someone is approaching C++ without a background in dynamic memory management, I might consider teaching them C first to introduce them to that world before dropping C++ on them. C as a gateway can be used to teach simple concepts like how to write a procedural function, what macros are ^(1), and most importantly "what is memory management". C++ features &amp; patterns like RAII can then be taught as a *replacement,* ***not a superset*** of C features, giving the student a clearer understanding of the underlying principles for some of the language features they will be expected to use. Notes: 1) Yes, macros are meh, but unfortunately necessary for a good C++ programmer to understand
When `sizeof(value_type) &gt; 1`, the union with `__lx` forces where the padding goes in `__short`: Always right after `__size_`. If I recall, this helps in keeping the long/short flag bit in the same spot both in the long and short formats. If the long/short flag moves to different locations when in long and short modes, then there is no way to ask the string if it is long or short. Having `__n_words`, and subsequently `__raw` allows some parts of the implementation to just shovel words (8 bytes at a time on a 64 bit platform) from one spot to another without caring whether it is a long or short string. The most important example of "shoveling words" is the move constructor. This function does nothing but copy the 3 words from the source to the destination and then zero the 3 words of the source. No branches, no access to far away memory, very fast: movq 16(%rsi), %rax movq %rax, 16(%rdi) movq (%rsi), %rax movq 8(%rsi), %rcx movq %rcx, 8(%rdi) movq %rax, (%rdi) movq $0, 16(%rsi) movq $0, 8(%rsi) movq $0, (%rsi) Indeed, it is fair to say that this string design centers around optimizing the string's move constructor. It was the first string implementation to be designed specifically with move semantics in mind.
How are you increasing the output matrix size, in which steps? Make sure you don‘t accidentally increase it it fixed step sizes, that leads to a quadratic runtime. Use a factor (1.5 or 2) whenever you reallocate, then shrink to the final size after you are done.
**ENGINE PROGRAMMER – eSports** **Company:** [Beenox](https://beenox.com/en/) **Type:** Full time **Description:** Beenox is a video game development studio created in 2000. Located in beautiful Quebec City, Canada, Beenox is a wholly owned subsidiary of Activision Publishing Inc., one of the world’s top game developers. The studio is proud to contribute to the development of the Call of Duty video game franchise. Beenox has also contributed to the resounding success of the Skylanders, Spider-Man, and Guitar Hero franchises. You could say that video games are in our blood! eSports is gaining rapid momentum and Activision owns suitable franchises for that form of entertainment. Over the years, Beenox has developed an expertise on eSports components and will innovate by making competitions even more attractive to spectators and by ensuring their long-term engagement. We have a lot of new ideas to implement and we need people like you to be part of this project. This is a unique opportunity to contribute to this emerging field of expertise! **Responsibilities:** The Engine Programmer will have different objectives related to the game engine. The first objective of the Engine Programmer will be to develop the necessary systems to transfer data between the game client and the various other services related to eSports; The second objective of the Engine Programmer will be to support the Art team and drive the development of features and tools related to the Art team needs (shaders, textures, etc.); The third objective of the Engine Programmer role will be related to the stability and performance of the multiplayer aspect of the game; Finally, the Engine Programmer will provide technological watch for the programming team for current projects and future projects; **MAIN TASKS** **•** Ensure the constant evolution of technology associated with different game platforms; **•** Develop functionalities of the game engine: networking, optimization, APIs; **•** Ensure the quality and performance of functionalities that were developed; **•** Support users on developed functionalities. **REQUIREMENTS** • Strong knowledge of C++ and real-time engines; • Development experience for console and PC; • Good analytical skills; • Autonomy in fulfilments of tasks; • Capacity to adapt to internal tools and a changing environment; • Positive attitude and desire to work on a team; • Passion for video games; • eSports interest; • Asset: Knowledge of other languages like C#, Lua and Python; • Asset: Online programming knowledge; • Asset: Knowledge or interest in Video game streaming. **Location:** Quebec City, Canada. Our workplace languages are French and English. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We are looking for someone who is proficient with C++ 98/03, but also has knowledge of a few key features of the later additions to the C++ language. We are using Windows with Visual Studio for most of our development, and while C++ is a must-have, proficiency in other languages such a C#, Python, or Powershell are nice skills to have. Engine programmers will also have to deal with graphics code, so knowledge of a modern graphics API such as DirectX or OpenGL is a nice plus. **Contact:** You may apply [here.](https://activision.referrals.selectminds.com/beenox/jobs/engine-programmer-esports-beenox-3792)
You could maybe set up a custom allocator for the coroutines and then just error if it gets used? I don't think the compilers have even caught up with what got standardized yet, though.
Not seeing low level details saves a lot of mental health.
 **UI PROGRAMMER – eSports** **Company:** [Beenox](https://beenox.com/en/) **Type:** Full time **Description:** Beenox is a video game development studio created in 2000. Located in beautiful Quebec City, Canada, Beenox is a wholly owned subsidiary of Activision Publishing Inc., one of the world’s top game publishers. The studio is proud to contribute to the development of the Call of Duty and Crash Bandicoot video game franchise. Beenox has also contributed to the resounding success of the Skylanders, Spider-Man, and Guitar Hero franchises. You could say that video games are in our blood! eSports is gaining rapid momentum and Activision owns suitable franchises for that form of entertainment. Over the years, Beenox has developed an expertise on eSports components and will innovate by making competitions even more attractive to spectators and by ensuring their long-term engagement. We have a lot of new ideas to implement and we need people like you to be part of this project. This is a unique opportunity to contribute to this emerging field of expertise! **MAIN TASKS** As a UI Programmer, you will work on different mandates related to eSports. For this role, you will have to: · Efficiently write and test the Lua code that controls the frontend, in-game UI and flow; · Use the internal tools to build menu structures and implement the creative vision for the UI; · Fix bugs in all aspects of UI development with the help of QA and production; · Develop an expert understanding of the UI development tools; · Develop tools and components for use by other members of the UI team; · Be an active participant in the UI design of the game as the technical side of the UI team. **REQUIREMENTS** · College Diploma or Bachelor Degree in Computer Science, Programming, Multimedia Integration or any relevant field; · Prior professional experience in Programming; · Interest in everything related to eSports and competitive game modes; · Experience with languages such as C, C++, Lua, Python and C #; · Interest in expanding knowledge of different game technologies and systems; · Ability and interest to work alongside a team of creative individuals to create compelling and engaging interfaces; · Excel working under the pressure of deadlines while maintaining focus on shipping the product; · Good communication skills in English and in French; · Passion for video games. · Asset: Experience with any game engine; · Asset: Graphic design skills and artistic sense; · Asset: Solid working knowledge of Lua. **Location:** Quebec City, Canada. Our workplace languages are French and English. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We are looking for someone who is proficient with C++ 98/03, but also has knowledge of a few key features of the later additions to the C++ language. We are using Windows with Visual Studio for most of our development, and while C++ is a must-have, proficiency in other languages such a C#, Python, or Powershell are nice skills to have. Engine programmers will also have to deal with graphics code, so knowledge of a modern graphics API such as DirectX or OpenGL is a nice plus. **Contact:** You may apply [here.](https://activision.referrals.selectminds.com/beenox/jobs/ui-programmer-esports-beenox-3791)
Which version of Windows 10 are you running? This could be a huge factor all by itself. I’m basing this on experience as a user of Windows10 early in 2018 on new hardware. The OS was simply terrible, sluggish and would seemingly hang at random times. Mid 2018 I deleted Windows 10 completely and installed Fedora Linux. The operational difference was massive even with a few lingering driver bugs. I should note that Windows 10 got better with time but performance was still crap 6 months after getting the machine. Mind you I’m comparing with Fedora which isn’t really a highly optimized distro. It is hard to describe the difference but the feel was that of a much faster machine with Linux installed. Now that is a users point of view. Most of the limited programming I do is in Python so I can’t help a lot here. I do have to wonder at what state in the development you are, because I have this sense that you are too early into looking at performance. By the way I use to be a Mac OS user up to late 2017. Apple got greedy and screwed up some repairs so I said good bye or awhile. Given that, I wouldn’t doubt that I’d see the same feel performance wise like I see between Linux and Windows 10. Mac OS is just more optimized in my opinion (as long as we are not talking GPU performance here). One way to see the difference is to run a crap piece of software like Eclipse side by side on Windows 10 hardware and Mac OS or Linux. Eclipse is much worse on Windows.
The problem is that if it might or might not get used depending on the optimization level, compiler version, etc. which is kind of brittle. Also, wouldn't a custom allocator prevent the optimizations in the first place? Technically it could have any kind of logic (think side-effects), so I don't know how the compiler could elide allocations through it.
First of all, this looks really cool. Wait-free memory reclamation in particular is something dreams are made of! &gt; Despite these limitations, when you take into consideration that the alternative is to make your own hand-made wait-free data structure, **the choice becomes obvious**. Unless performance matters? Looking at the benchmarks on page 10, for example, it seems RomLR is *much* faster.
If there were a zero- or even low-overhead scheme for lock-free concurrency it would rock our worlds! &gt; Replace calls to `new T` with `tmNew&lt;T&gt;();` Say... what? Who sprinkles their code with calls to `new T`? And more important - what needs to change if you use smart pointers like `std::unique_ptr`? I see all these little wrappers, but no mention of the word "overhead". I'd love to know more about that.
Pop open the [OBS](https://github.com/obsproject/obs-studio) source &amp; do whatever they're doing.
If you are running Windows 8 or later your best bet at doing this is by using the Desktop Duplication API in DirectX. It is very low overhead and at the same time it will make you able to do your downsampling of pixel data on the GPU which will be extremley fast. &amp;#x200B; Doing the downsampling on GPU will mean that you only have to transfer a small amount of data back to CPU for forwarding to your receiver. This is way cheaper than transfering each frame to CPU and then doing the processing there. &amp;#x200B; I would recomend you look into learing just enough DirectX 11 and start working from there. There is enough resources on the internet to get you started and figure out how to implement this. &amp;#x200B; Implementing this as I describe will get you 60Hz no problem at all even when processing all four sides of your screen. &amp;#x200B; [https://docs.microsoft.com/en-us/windows/desktop/direct3ddxgi/desktop-dup-api](https://docs.microsoft.com/en-us/windows/desktop/direct3ddxgi/desktop-dup-api)
If you call tbb::parallel\_for naively, the way data is divided up is left to the implementation. If you're only passing in a very small number of values the overhead of parallelization might be more than the serial computation time, so it could choose to just do it in a single thread. I think the default grain size is 1 though, so it should always do something unless that is changed. TBB algorithms also use an internal thread pool for processing, so if only 1 thread is allocated there is no concurrency.
I do think it would be nice to provide an allocator that uses these special allocation and deallocation functions, as well as some type aliases that include the allocator. `unique_ptr` should at least still work with `std::unique_ptr p{tmNew&lt;T&gt;{}};`.
For me QtCreator has the ubermisfeature that if it can't prove that a macro is #defined in your build, it assumes that it is not and treats all code behind #ifdefs as commented out. It's an infuriating bug for which I can't find a workaround, and it completely negates the "works if project is not buildable" feature.
I've been a web developer for the past five years. I've been developing previously with C#, Java and PHP and now I finally started working on some PC games with C++. I've been learning the language while this program and mostly used my previous skill and knowledge. So I'd actually appreciate all the feedback from people who know C++ better. I'd like to know the C++ stuff which I don't know from higher level languages. Thanks in advance! Next I'm gonna work on a render engine and then impelement this detector to it.
20x difference can't possibly due to the OS or the libraries port. My first guess: you used a debug build on Windows. My second guess: you didn't run the same code on both sides, or the same data. My third guess: you have "something" on your Windows. Otherwise, show profiler results.
Visual Studio is fine and a 32-bit program =&gt; it just can't use a lot of memory.
&gt; The problem is that if it might or might not get used depending on the optimization level, compiler version, etc. which is kind of brittle. Yep, this is why I wish the feature were designed differently. You can at best make it a link error in release builds and then go adjust the program to try to work around it, I guess. &gt; Also, wouldn't a custom allocator prevent the optimizations in the first place? Technically it could have any kind of logic (think side-effects), so I don't know how the compiler could elide allocations through it. Fortunately it's not that bad. As of C++14, `new` expressions can elide and combine allocations even for custom allocators, and coroutines can take advantage of that: * https://en.cppreference.com/w/cpp/language/new#Allocation * https://en.cppreference.com/w/cpp/language/coroutines#Heap_allocation Since it's too late to get rid of the allocation altogether, I'm hoping the bullet point requirements in that second link can eventually become a guarantee, along the same lines as guaranteed copy elision. That would reduce allocations to a) cases where the callee is "spawned" (to use Rust terminology) and outlives the caller, or b) cases where the coroutine is in another TU.
Thanks Xeverous! Yes, en.cppeference is like the best reference site, but I never thought it about that way. That's very exciting, actually. And the site you're trying to develop - awesome stuff! I hope people see this and support you, more power to you!
You should know what is pass by value, pass by reference and const-correctness. You should pass by ref when object size is bigger than sizeof (void\*) or it's container i.e. all Vector objects should be passed by ref, also when you don't plan to change the object it should a const ref. Also functions that not change the object (a.k.a this) should be marked as const also. Meta-programming is also can be notable in gaming dev.
Yes, that's true. I did gave it some tries already but it seemed to dry to fully give it a good read. It might be great once I improved so much that I can read it intuitively.
&gt; Fortunately it's not that bad. As of C++14, new expressions can elide and combine allocations even for custom allocators, and coroutines can take advantage of that I'm not sure I follow. I supposed I should somehow use a `std::allocator` for these, but the mention of `new` expressions suggest that I should, instead, replace the global allocator. I can't do that, because some parts of my application need to allocate. Some parts that use coroutines just cannot allocate in some places (e.g. before the global allocator has been initialized).
Well, right now I'm mostly "accumulating" that stuff that is scattered around the web, about 500+ TODO list right now (mostly links). I have some articles written already but many are unordered and have holes. I have a plan and all the tech (will host on GitHub pages) so currently I don't see any bigger problems. Looks like it is only a matter of time. Working on a different project right now though, was supposed to be an enchanced parser/generator for sort of game configs but it already hit 9000 lines and looks like will reach ~20k when finished.
I am not aware of such a library, and I know that I would not want one. Making those decisions at run-time will be both slow and confusing, and will make the program harder to reason about.
One top-level comment per employer. I’ve removed this one; please add this posting to your other one (either via an edit, or a reply to your comment).
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bltfne/i_created_my_first_c_program_a_2d_collision/emrb1xo/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/blqq9o/debug_in_clionhow_to_debug_with_single_makefile/emrb3vp/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Sounds like you're talking about custom deleters and custom allocators, which shared_ptr and unique_ptr support. The shared/unique-ness is about ownership responsibility, not memory management.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/blsr4s/windows_capture_region_of_screen_quickly/emrbbqk/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Random comment: `using namespace std;` in header files is a big no-no.
Completely agree. I think on the top of an editor tab you can define specific defines. But it never worked for me.
It "proves" you wrong by demonstrating that in a real-world project used by countless companies, the super-low-level focus on details results in doing things like global variables everywhere (at best, sacrificing maintainability in exchange for minuscule performance improvement, but probably not, really), or 50 line loop iteration boilerplate (maintainability / minor performance), or constructing vtables / switch-case idioms at runtime using arrays (wtf shit is that?) My point is that the focus on "performance at all costs", or "Omg the stl uses so much memory" doesn't actually help with the stated problems (perf, memory), but absolutely does make your code a nightmare, ensuring that it's write-only, just like perl. And again, I'm highly skeptical that C projects can get the level of performance they claim compared to equivalently idiomatic C++ code unless they invest a huge amount of time to tweak their algorithms with a microscope.
I've found that identify if template type fits range base operations not a trivial task
You could even skip the part where you read/write to a file: https://github.com/lava/matplotlib-cpp
ADL
And the limits of it.
I noticed that the Condon-Shortley phase term is not included in C++'s std::assoc\_legendre, even though it is there in boost::math::legendre\_p
I didn't think about the fact that C++ does not auto generate comparison operators for POD types. Even when it can generate copy and move constructors automatically. Upon reading up, I was disappointed that it won't even be possible in C++20. Who knows, maybe C++23 will have it?
I only learned that you can put the `default` case first in a switch statement about a year ago. Been coding since the 90's ...
isn't the spaceship operator going to give you the same as comparison operators?
Is the 'shovel words' optimization properly protected from fancy pointers?
Once again, you seem to be arguing a separate point. As I previously stated, my point is that early C material has a greater focus on low level programming compared to early C++ material. You seem to keep arguing a separate point about the value of that ya on performance, readability, and maintainability, which I never made any comment on.
I thought you could put it anywhere inside the switch
Everything you do with filesystem is prone to race conditions, it's silly to just single out the creation of temporary files. For all the warnings you hear, I'd be interested to see if anybody ever ran into an actual `mktemp --dry-run`-style race.
it's not auto-generated. I believe what /u/olmusky wants is Bjarne's 2014 proposal [Default Comparisons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4175.pdf)
The article says: &gt; OneFile has its limitations tough. Mutative operations are serialized, i.e. only one is executed at time. How is this wait-free?
If you create a directory-based project in QtCreator, then symbols can be defined in proj\_name.config file. The project template includes a sample file.
Yes, if the compiler can generate copy and move constructors for a specific type, then it should be able to generate the comparison as well.
Try misspelling "default:" as "deflaut:" in a switch statement. It still compiles, because it's a valid label, but now your switch statement lacks a default case.
I think he meant sort of polymorphic move, copy, destructor, etc. of the pointer itself so he can decide at runtime if e.g. you do reference-counting or behave like unique_ptr.
The projects I work on have *way* too many defines for this to be plausible to do.
".template" https://stackoverflow.com/questions/8463368/template-dot-template-construction-usage
Let's say a Person struct has 3 members, firstName, last name, givenName defined in that order. Could a compiler come up with something sensible? I feel like this could lead to subtle bugs.
function/constructor level try/catch block. Not the latest, but the most "oh, I didn't know about this" recently.
Oh yeah sorry I wasn't clear about that- custom coroutine allocation is done by overloading `operator new` for the promise type.
Huh, TIL.
Nothing special about the dot. The keyword 'template' can be used as a disambiguator for dependent names. https://en.cppreference.com/w/cpp/language/dependent_name
URLs in your code are legal... &amp;#x200B; void fn() { [https://www.google.com](https://www.google.com) cout &lt;&lt; "Look no error!\\n"; }
That could work!
Yeah, I knew about ADL for quite some time, but I never bother learning the rules. Sometimes I look them up, but forget them right awaY
If the members are of types which have a defined comparison operation, then comparing each member is what will get you the default comparison operator. What kind of bugs could it lead to in the example you suggested?
What a coincidence, I read about that just yesterday.
Well, the order that you evaluate the members surely completely changes the comparison. Doing it based on the order of member definition is probably the only sane way of doing that, but in the example I gave it would be natural to list them as __firstName__, __lastName__ which is probably the opposite to how you'd want them compared for something like a sort collection of People objects. I agree it's a pain to have to manually define these, but automatically generating subtly wrong code seems worse to me. Someone can refactor the order that members are defined in and break algorithmic stuff? Yikes!
This is valid C++ code: template &lt;typename&gt; struct A { int f(); struct B {}; struct C : B { int g() { return f(); } }; }; template &lt;&gt; struct A&lt;int&gt;::B : A {}; int a = A&lt;int&gt;::C().f(); Found in Clang's regression test. Don't know whether anyone's actually using this feature.
When the types are string for example, does the developer consider the order of the auto generated copy constructor? You can definitely auto generate equality and inequality automatically, without considering the order. If what you're worried about it's the greater and less than operator, then that's another matter. Then you would have to consider the order. But we do that already for the order of construction of the members, as it's a given that they are constructed in the order they are defined. In any case, if the developer wants custom behavior, they write a custom operator anyway, even for copy and moves. This is no different. Also, check out the proposal, it has these considerations. The link is in an earlier comment.
This looks like something to be discussed with your teacher, rather than folks on reddit who have no idea what your assignment is and what is expected of you.
I learned that a double to int cast rounds up for negative numbers. That was a fun bug to find.
Keep.New.Modules.Good. :)
Not quite, it must be used after one of: ```::```, ```.```, or ```-&gt;```. Any other use of it is not permitted, so there is something special about the ```.```.
Switch without curly brackets. switch (x) case 2: case 5: std::cout &lt;&lt; "one"; Same as: if (x == 2 || x == 5) std::cout &lt;&lt; "one";
what the fuck is this fuckery
Wait... what? Why...?
damn, was just going to post this :)
It makes sense being able to do it but I have never actually seen it used anywhere.
It all makes perfect sense when you understand how it's being parsed. See if you can work it out!
Lmao you're right. That's hilarious.
Probably combination of a label followed by a comment.
`http:` is a label. `//www.google.com` is a comment.
A few months ago I learned you can define or even specialize template classes initially (forward)declared inside other, even template classes, in any scope.
I looked once time, and found a few constructor-level try blocks * [https://github.com/mongodb/mongo/blob/master/src/mongo/stdx/thread.h#L81-L85](https://github.com/mongodb/mongo/blob/master/src/mongo/stdx/thread.h#L81-L85) \- using it to suicide on exception * [https://github.com/performous/performous/blob/ce14aa71f229ae17554b717e83158f0b07825748/game/songparser.cc#L44](https://github.com/performous/performous/blob/ce14aa71f229ae17554b717e83158f0b07825748/game/songparser.cc#L44) \- using it to convert exception from one type to another * [https://github.com/nordugrid/arc/blob/master/src/hed/dmc/srm/srmclient/SRMURL.cpp#L11](https://github.com/nordugrid/arc/blob/master/src/hed/dmc/srm/srmclient/SRMURL.cpp#L11) \- bug
That bitfield specifiers are ignored when they are big. For example in this case, where I try to fit 3 relatively big but not huge numbers in a struct with the size of 16 bytes: struct S { signed long long a : 42; signed long long b : 42; signed long long c : 42; }; It will actually take the same 24 bytes it would even without the bitfield specifiers both on gcc and msvc.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/blv896/difference_between_stdin_and_argument/emrr8lb/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
goto label [https:] comment [//www.google.com]
Or another way of saying it: it converts to int by truncating.
Exactly
&gt; This is no different. It is hugely different. The order in which members are defined and initialized is an implementation detail, while the order which they are compared affects the semantics of the class. Only default `==` and `!=` would make any sense.
A class can have a static member of incomplete class type
I also wasn't aware about the rationale.
My understanding is that you will be able to define &lt;=&gt; as *defaulted* and it will generate ==, !=, &lt;, &gt;, &lt;= and &gt;= for you.
Will it still be relevant with introduction of Concepts?
It's not "ignored", compilers are simply allowed to use padding. Use the packed attribute if you specifically do not want padding.
You can have one in each function.
How does that work out? Granted labels are one of the things in C/C++ I'm least experienced with tbh and I could very well be wrong, but I thought that they were local to the TU, not the actual scope?
You know, I was into my second six pack the other day, while watching my favorite monster truck pull show, and that suddenly struck me as well. Weird how that happens.
Labels are local to the function. You cannot use `goto` to jump from one function to another.
How poorly everything in the standard library is to set up to deal with allocators. I tried to move to using allocators, but with a non-polymorphic allocator being the default, it is basically impossible to interface with any other library that uses containers without having incompatible allocators and needing to copy things around. A related problem with that is the inability to pass containers between shared libraries without coming across a cross-module allocation issue. If one shared library overrides operator new, if you pass a container to another shared library, when that container is destroyed it will call the wrong delete. This wouldn't be an issue if the allocator was polymorphic by default. I have bailed to EASTL for most things that it offers, but it also has the same problem where the default allocator is non-polymorphic.
Huh, I was under the impression you could and that was a large part of why they are generally considered so dirty. TIL.
And maybe not even those. Shallow or deep compare? Case-sensitive or -insensitive? &amp;c.
This is an ABI issue. The layout of bitfields and structs in general is not specified by the standard anf is almost certainly not going to be packed in most implementations.
The main goal I want to achieve is to make CMakeLists (and CMake-code, in general) writters' easier. That's why I decided to make it C++-like (imperative, with the same syntax and design (not all design, of course)). Also, that's why I wrote CMakeSL with tooling in mind - even at this point, you have an interface to index source or complete syntax at some position. That makes IDE creator's lifes easier =&gt; tools are faster integrated into your favourite IDE (the interface is written in C, so it can be used pretty much everywhere). &amp;#x200B; Like /u/sat0ri said, CMake is used mostly in C/C++ world, where you have clang-format and similar tools already in the project, so you get a lot of features (like formatting, syntax highlight) for free. &amp;#x200B; Another goal is (if the CMakeSL will get off the ground) to make CMake developers' life easier by not adding any library dependencies, not mentioning adding different language dependencies.
&gt;CMake is used mostly by C++ crowd, and CMakeSL is supposedly a lot like C++. Also, it's statically typed and compatible with clang syntax highlighting and formatting tools that are available for C++. Ideally, you don't have to learn or setup anything new. &amp;#x200B; Wery well explained. Should have explained my intents in a such way at the very beginning.
It's auto generated, but opt in. You have to = default spaceship explicitly but if you do you don't need to mention each member variable. I think this is exactly as it should be.
That nonvoid functions don't actually need a return statement and will happily fly off the end, without so much a compilation warning if you don't have wall on.
For APIs that dont require huge call volume and data throughput, I have started using a dispatch layer that uses MSGPACK to marshall function parameters and return values across DLL boundaries. It not that much overhead, allows for better forward and backward compatibility with API changes and avoids the ABI incompatibilities when using different build settings (eg. debug vs release) between modules.
Also did you guys know about return type covariance for virtual functions? https://en.m.wikibooks.org/wiki/More_C%2B%2B_Idioms/Covariant_Return_Types I didn't know about this insanely useful feature.
I found out that object pointer is not exactly the same as pointer-to-object.
The gotos in "Go To Statement Considered Harmful" were capable of jumping between subroutines. That's part of why they were so harmful. C++ is newer than that paper.
Non-void functions don't need a return statement *if they are never invoked* or *never reach the end*. Hitting the end of a non-void function without returning a value is *undefined behaviour*.
Non-void functions do actually need a return statement (except `main`, which has implicit return). Both GCC and Clang that I tested produced a warning without `-wall`.
###also ##much ##going #great big #thank
What is the difference?
I didn't know but I suspected it because it's the same in Java.
According to ISO/IEC 14882:2011(E) [stmt.label] 6.1.1: “...The scope of a label is the function in which it appears. ... Labels have their own name space and do not interfere with other identifiers.”
Some people saw a C++ leetcode solution I did, and were shocked. "I had no idea that C++ had auto", for example (VERY nice for iterators)
Thanks for asking :) Pointer-to-object is a pointer to an object type. Crucially, `void` is not an object type, so `void*` is not a pointer-to-object. Object pointer is either pointer to `void` or a pointer to object type. Another subtle detail: `nullptr` does not have a pointer type.
msvc complains with an error on this case. one of the reasons, why I prefer -Wall with gcc
Thank you (: * I'm not sure whether I'd like to implement \`null\` per se. I thought more of \`optional&lt;T&gt;\`, but that's a design decision that I'd want to discuss with the community. * I'd not want to implement statically-size-fixed arrays. I think \`list&lt;T&gt;\` is fine (the name can be changed) which has variable size, so static checks are not possible. * CMakeSL vs C++ is actually a big topic which needs discussion with the community. I think the main difference would be that all STL-like types (list, map, set) would be builtin into the language. About adding more that there is in C++ - I'm not sure. I have some ideas but nothing fancy. But I can tell that there is a lot of things and concepts from C++ that I would not want to see in CMakeSL like templates, pointers, macros, includes (I'd rather see modules in CMakeSL) and more.. &amp;#x200B; &gt;I'm not sure that clang-based tools would be (fully) compatible.. I'm fully aware that not all of the tools are going to work. I know that indexer, completer won't work because e.g. CMakeSL's fundamental types are semantically different that the ones from C++. That's why I want to provide similar tools directly from CMakeSL. On the other hand, CMakeSL would not add any new syntax, so e.g. clang-format should work fairly well. &amp;#x200B; &gt; What can be changed in vanilla CMake to alleviate some of the problems that CMakeSL solves? I'm not sure if we're on the same page here. The only thing that CMakeSL would change in CMake is the scripting language. I don't want to change/add new or remove any of the current CMake's concepts like targets, subdirectories, packages etc, I just want the layer, that human uses to interact with these concepts, to be more user-friendly. I think that there is not much we can do in the current scripting language. I think that if it would be changed in a way to address current problems, we'd end up with a new language anyway.
That object suicide is legal. So `delete this` is not illegal and may even be useful if you are absolutely certain no one else is using the object or any more calls will be made. Ah certainty... I ended up changing the memory allocation strategy instead though. I am getting more risk adverse in my middle age.
No it is not. It will only work for pointers with a trivial move constructor, and a data layout such that all zero bits represent `nullptr`.
Just because the compiler can't guess the exact comparison semantics you want for your special type doesn't mean a default isn't useful. Strings have a comparison operator. It's utter always the comparison you want ? Certainly not (often you actually want unicode comparison). That doesn't mean the default behavior isn't useful.
Another layers of generation and similar work is something I wanted to avoid - that's why CMakeSL is supposed to be directly in the CMake codebase and scripts executed by the CMake core. &amp;#x200B; &gt;I'd write up a dream CMakeSL syntax for a complicated CMakeList first so that you know where you want to end up. That's actually a great idea! Not sure why I didn't think of it earlier. That'll be the next task just after Travis integration and Windows build fix.
In 2017 [google code jam](https://codingcompetitions.withgoogle.com/codejam), 79% of the 3000 best participants used C++. All the top entries are in C++. I learnt C++ with cfront. I’m flabbergasted at how popular C++ still is.
I knew about it and it is extremely annoying that it doesn't work with smart pointers
Yes. If you interact with concepts, you'll still need to understand advanced template things. (Certain SFINAE techniques may become less used due to concept constraints.)
I like how "C" is the most common word in all of the questions with word counts.
Sounds like something that could use a proposal.
Ah, the less popular YIL :-)
It's sort of fundamental to Microsoft's COM system, where objects reference count themselves and destroy themselves when the last reference is released.
this is so right and wrong at the same time
Well, `this` is just a pointer, so you can delete it. Not really that surprising ;)
Yeah that seems like a good solution if you're going for full compatibility and low throughput libraries. I might look into something like that too. It's just disappointing that I can't use containers like normal across boundaries without futzing with the allocator and causing issues with container types.
Both instances of "just because you can doesn't mean you should"
The ability of a goto statement to teleport both into and out of any other structure destroys Edward Dijkstra's methods for proving a program as mathematically and provably correct given his inductive based reasoning. Do Dijkstra, probably while high, sent the nastygram that goto statements were of the devil. Any use of a goto statements renders the entire program immune to provability. Teleportation ruins the flow control diagrams and makes program provability impossible. Because there's no way of knowing that a surprise left jab goto statement teleports you away to some distant part of the code, which fails. This is why code obfuscating people translate their code into codes with a goto teleport on every other line.
If you take the sizeof() of an empty class/struct, it returns 1 instead of 0. Threw a coworker and me for a loop until we googled it. The reason makes sense, but I hadn't thought of it: if it was 0, two different objects could occupy the same memory address.
Yeah, in C++ we get `[[no_unique_address]]` for that purpose
operator&lt;()
I don't think it's implementation detail for pod types. The data layout is public.
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/blu0a4/what_was_your_latest_discovery_about_c/ems21yt/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
What will that do? Allow 0-size structs? Also, what's the use case? We found out about the size 1 thing because my coworker had some static assert that he was trying to write and it failed on an empty struct because he assumed it would be size 0. I wonder what the use case for a legit empty struct is.
The solution is quite simple: don't use `new`, like ever. Use `unique_ptr`; that will help you track down ownership and lifetime problems.
Yep, you can use any label in a switch statement, and there's no stipulation on where the labels occur. That leads to fun things like Duff's device. switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n &gt; 0);
Oh it's because it came here from high schools, high school competitions, then through university competitions...
Yep, `switch`, `if`, `for`, and `while` all apply to a single statement -- it's just that a block `{}` is treated as one *compound* statement. That also means you can do things like if (foo) if (bar) for (;;++bar) if (bar == 4) break; else if (!bar) switch(bar) default: return 1;
In general, that doesn't make sense. There are a couple of other ideas that *do* make sense, however: * dynamically choosing whether a given reference is owning or not, i.e. `shared_ptr` with `weak_ptr`. This is easy enough by sticking another bit in there somewhere to discriminate, although you obviously have to *have* somewhere to stick the bit. Maybe do more stuff through the typical vtable logic. * allowing tracking the death of a `unique_ptr`. This is trivial by wrapping `shared_ptr` in a class that doesn't provide copy ctor/assign, only move, then using existing `weak_ptr`s. * writing template-like code that can deal with multiple ownership policies. You probably shouldn't be doing this, although *technically* it's possible to wrap a shared_ptr inside a unique_ptr with a custom deleter as well as the obvious vice versa.
Or to phrase this even differently: it rounds towards zero.
AFAIK it's fine when two members have the same address unless you take pointers to one of the member (violates against strict aliasing rules) EBO (https://en.cppreference.com/w/cpp/language/ebo) is often used to get rid of the size overhead, the upcoming attribute is just making that easier without the need for inheritance.
I'm new af to the language but, I discovered mutable lambda's legit blew my mind lmfao
comma operator `std::vector&lt;int&gt; a = {1, 2, 3};` `if ((a[0]=0, a[0]==0))` `std::cout &lt;&lt; "!";` prints "!"
operator&lt;=&gt;() = default; creates a lexicographical comparison in the order of declaration of its member variables.
The issue here isn't with templates. The issue is that nested classes don't inherit the outer classes, just get special permissions to members. B can't inherit from A, yet, because it isn't a complete type. An alternative is to defer B's declaration until later, and works without having to specialize. This applies for non-template classes and structs, as well. If you want a nested class to inherit from its outer class, that inheritance must always come after the outer is defined. The specialization is a definition after A is defined, but confuses the issue since B is defined inline in the generic version of the class. template &lt;typename&gt; struct A { int f(); struct B; struct C : B { int g() { return f(); } }; }; template&lt;typename T&gt; struct A&lt;T&gt;::B : A&lt;T&gt; {}; int a = A&lt;int&gt;::C().g();
thanks, i hate it
Okay, it's fast. Now make it actually work ... that pesky "multiple threads exist" thing is a real performance killer. Then start making tradeoffs to support real-world applications. Be sure to test against `jemalloc` and `tcmalloc` since they are usually more efficient than the OS default malloc (and `glibc` is pretty good compared to others; are you sure OSX malloc isn't just being slow?). But they do that by making tradeoffs that are unsuitable for certain use-cases. Note that the cost of zeroing memory is hard to directly associate with the actual malloc/free call sites.
&gt; Tested on MacOSX only. Single-threaded only. 32-bit only. &gt; Tested well! [...] good allocator This doesn't seem very compelling. You should at least provide reproducible benchmarks, and compare against `std::pmr`'s specialized memory resources.
Right, I'm a big fan of the spaceship operator, but in that case you are explicitly opting in to that behaviour. To me that seems better than it being implicit for a simple type, but not intuitive in the case that someone refactors the code and changes the order or adds a new member in the wrong place. Feels like to me that too much implicit behaviour gets us into trouble, time and time again.
&gt; I will beat you to death in your cubicle As you should. That else statement is a prime example of why braces should be mandatory, even for one liners.
9/10 programmers will write a Person struct as firstName, lastName. That's simply the natural way of expressing it. Having to reverse that to get something to sort correctly seems off to me. That's liable to be "corrected" by someone for whom it "reads funny". And now you've got a bad bug. This really shouldn't be the basis for any logic.
Yes, but I didn’t knew that, I guessed people would be using python or Haskell. I am fluent in both python and C++, and it is incredibly easier to compete with C++(in general). It is a huge win for C++. I was wondering “where all the twisted brillant C++ loving people are coming from? why are they even interested in C++?”. Look no further, imo, this is a tremendous marketing win for the language.
\*pats head\* very good, good job
Just for information sake, what would I do if it were just raw pointers?
Adding alphadetical ordering to a struct makes it less of a "tuple" and more of an OOP object, with semantics dependent on domain, etc. You can do that, but you're going off the standard way of doing things. The standard way for such POD/tuple type would be IMO to have a comparator object/function defined outside, and passed as a comparator to maps, or called explicitly if you need.
But std::string's comparison is not default. It was deliberately chosen with specific semantics. It's not clear at all what "reasonable" semantics would be for some arbitrary POD type.
less things that can break is always preferable isnt it?
&gt; This is why code obfuscating programs translate code into codes with a goto teleport on every other line. I never thought about this, that's a very logical thing once you explain it like that.
&gt; I will beat you to death in your cubicle. I'd rather die in a cubicle than set foot in an open workplace.
I quite consistently do this, to me it makes a lot of sense to see first what happens at the 'if not any of the cases' below case. But I know like all conventions that is contentious.
I miss when typing `delete this` felt slightly naughty.
Everything below my comment
I have been using a python script for updating through pip and npm. Basically after pulling the repo the user runs the 'fresh' script and it will call lots of functions so I know dependencies are installed. It's been on my to-do list to also include the repos I reference (at the correct commit, even!) and (if applicable) call the right make files, VS build commands, etc.
Never knew about the _other_ arrow operator `--&gt;` https://stackoverflow.com/questions/1642028/what-is-the-operator-in-c heh
The remainder/modulo difference is also a major pain.
Use Rust :)
Use a proper dependency manager like conan, and package all the libs you need for it. Then users can build download and build everything in a couple of shell commands, provided all required build systems are installed.
I mean Rust does it, in order of declaration, if you ask for the default implementation using a `derive` attribute.
Line return before a code block.
Depends on where you got these pointers from. Do they own the Data? Do they merely observe it?
I recently discovered a similar problem with nested template parameters, except there you can just spaces between the brackets.
From what I've seen, most compilers seem to keep to the struct alignment rules of the underlying datatype, regardless of what you set the bitfield widths to. For instance in the following example, the sizeof X is 4 because it is aligned as uint32\_t, but the sizeof Y is 1, as it is aligned to uint8\_t: \`\`\` struct X { uint32\_t a : 2; uint32\_t b : 2; uint32\_t c : 2; }; struct Y { uint8\_t a : 2; uint8\_t b : 2; uint8\_t c : 2; }; \`\`\`
Also, init/cleanup is an anti-pattern in C++. Generally, everything you would put in init should go in C's constructor and everything you would put in cleanup goes in C's destructor.
I think it's a good idea to learn C first, to the extent that you have an idea of some of its weaknesses (memory leaks, lack of expressiveness) that C++ tries to solve.
hot damn, this dude needs a statue erected right in the middle of this subreddit
It’s not a hidden implementation detail, though. C++ has never been agnostic about class layout, so I really don’t see the big deal.
this is such a wholesome coincidence.
I can rule out the first guess as I have tested on windows the debug and release version. I use -o2 optimization for release. On inputs around 700mb I am seeing a significant speed increase so I can confirm it's not a debug mode(right?). The second guess is difficult to say imo. There are definitely code differences on Mac and Windows but I am adamant the computation related code are all the same as they rely on Eigen. I'm not sure what to look out for in your their guess. Do you mean to check for other processes hogging CPU bandwidth? If so, I have used the task manager to observe the threads. I am hovering at 8% total CPU usage in non multithreading segments and almost always 90-100% CPU usage in multithreading segments. Admittedly the profiling is not a full program run. I am only testing the first 2 mins of the runtime / first 8 iterations of the compute loop and benchmarking it. The visual studios profiler runs out of memory if I let the program run through entirely.
I can rule out windows being slow as I have other algorithms that I have tested on the same machine being competitively performant with their Mac counterparts. Those algorithms were implemented in BLAS with some other threading library. But I haven't seen conclusive evidence that those libraries being "superior" to what I have in Eigen and TBB.
Thats what I thought. I am actually the one who decided to go this route for my team, and it works fine for the last two years. The only downsides are 1) huge repo, 2) in the figure if we want to upgrade the OS version, let say from ubuntu 18.04 to 20.04, we have to recompile every one of the dependency (30+ now), which is possible but can take up to weeks. (we carefully custom built each of the dependency to maximize the performance and minimize the size, not just use all default).
The overview here is for a given 3D mesh, calculate the stress for each point. If a point exceeds a herustic calculate a set of other heruisitcs and perform either a split on the vertex or a merge with another vertex. The question now becomes why is MacOSX more performant with the memory allocation than windows. The memory allocation should be a factor but I don't believe it is the root of the problem. At least not for the results I'm seeing.
I am not familiar with conan, do you know by any change if it is capable of providing custom build? because we carefully custom built each of the dependency to maximize the performance and minimize the size, not just use all default. Just took a look at conan, it seems powerful but I see some difficulties in our team. \- need python skills, no one in our team has enough python skill to set it up quickly. \- we use embedded compiler that requires a lot of environment setup, not sure conan can do it correctly. &amp;#x200B; But thanks for mention it.
Most likely a "spinlock" on compare-exchange (I haven't had a chance to confirm yet). Technically this would not qualify as a wait because it incurs neither a syscall nor a yield.
Omitting curly braces on simple one line if statements is more readable.
Explicit template specialization. I did a couple hundred loves of code in many files with templates for doing a bunch of math operations and algorithms. The templates are to support float and double. I used static_assert to only support floating point. But all my code is header because if templates. Even though it is supposed to be a library. Later I found out explicit template specialization. Then you can compile ahead and remove all code from header. :)
&gt; C++ has never been agnostic about class layout That's not entirely true. Sure the class layout has an impact on other internals of the class, on size, and on performance. But at no point does it have any impact on semantics.
Sure it does, it controls the order n which the member initializers are run.
Going to have to disagree with you on this, curly braces let me see scope blocks instantly as I scroll, one line if statements do not. Curly braces also allow for easier and less error prone modification later. I could be wrong, but wasn't the recent Mac OS login bug caused by someone trying to add a line to an if statement body and not noticing it did have curly braces?
It works for pair and tuple because their members are semantically defined as sequential. That's not the case for the majority of classes nor structs.
That's an implementation detail, it doesn't affect the semantics of the class. You *could* technically design a class that relies on it, but then you have only yourself to blame.
Brace initialization defines that sequence in one place already. I don't see downsides to assuming that this is a default ordering, and allowing it to change by defining operators explicitly.
Tie for the win
How about `variant&lt;T*, unique_ptr&lt;T&gt;, shared_ptr&lt;T&gt;, weak_ptr&lt;T&gt;&gt;`?
if (!cin) die(); You can pepper checks like this throughout your code without causing cognitive load from all the extra scopes you open and close, and it prevents spacing your code out unwisely. I feel like the alternative is oftentimes people do no sanity checking at all.
You can definitely go the package manager route (spack or Conan or other package managers) like others have suggested. This is probably the best way but also requires learning those package managers and maintaining that integration. Definitely worth it but sometimes you just can’t do the best thing because of time/resources/etc. So what to do? I would suggest a different approach. When using git, I always have a “binaries” repo that I have as a git submodule. That way your main source repo is only source (as it should be) and relies on the submodule for all binaries. Then when you get a new lib, add it to the binaries repo and update your main repo to use and point to the new commit hash for the binary repo. This also gets you back to having a fast, small repo that holds your main source and all the binaries stored somewhere else. And everything stays in git. Just have to read up on and understand submodules (or subtrees, either works).
Or you could not do that, because basically nobody in the industry does, and writing code that follows common conventions is highly preferable.
*shrug*, I really don't think I'm arguing a separate point. C programmers think they're focusing on performance, but they're not gaining anything for all the attention they put into performance. Whether that focus happens early in the learning process, or not, they're still mistaken.
First thing first. Does the class hierarchy make sense? Why does `B` inherits `A` but `D` uses `B` directly?
As long as you format it properly it's perfectly readable. I like Python-style C++.
That's why you use clang format.
Why are you profiling a debug build? That makes no sense.
if you profile debug builds you are going to end up "optimizing" for things like lines of code and unrolling your own loops, etc. That just makes your code worse and does nothing for your final optimized code. You should *ONLY* profile optimized code unless your code gets so slow you can no longer debug it properly - at which point then it makes sense to look at optimizing the debug code (but make sure you don't mess up the optimized code while you're at it)
If it is empty, it has no state, thus needs no address in the first place. You can cast anything to it and it will work, because it never uses the address anyway. The main case where you'd use it if for templates, for example an allocator or deleter with smart pointers and containers. You may need stateful ones, so you need to make them a member in that case. If you only support stateless allocators, there is no need for making them a member in the first place and you should probably have some `using MyAlloc=T`.
You're not using it in a fun way. if(foo) return bar++, foo+bar;
You don't have to put the binaries in Git, it is usually not recommended because it doesn't compress well and bloats the repo. One way to go with it is to make a repo for each dependency (fork of the original + build scripts for your platforms), with artifacts associated with each version (stored outside of git). Then your main repo can use submodules to point to the dependencies you need. When building you can either pull the submodules and build from scratch or get the artifacts and build from that. I managed to set this up for a small project in Gitlab and while it was a bit painful it seems to work well, continuous integration works perfectly now. You can pull the binaries of your dependencies easily enough.
I agree. Readability is better without braces on single line statements, though obviously, as with all things, you have to be careful. Of course I use aligned braces, so using them on single lines is worse for me. But I find that, when do use braces, having them vertically aligned makes them do what they are supposed to do (visually anyway) better.
I've been reading the book [C++17 The Complete Guide](https://leanpub.com/cpp17) by Nicolai Josuttis and in one of the opening sections he presents structured bindings which I had never seen before. I guess I was out of the loop on that one. It almost seemed weird to me at first because it was almost python-like. A small example: std::map&lt;int, std::string&gt; the_map = {{1, "one"}, {2, "two"}}; for(auto&amp; [key, str]: the_map) { std::cout &lt;&lt; key &lt;&lt; ", " &lt;&lt; str &lt;&lt; std::endl; }
&gt;basically nobody in the industry does I find statements about the entire industry dubious. I think they more reflect personal preferences. Just to test your theory, I clicked on a random source code file from the Linux kernel, and sure enough they omit curly braces on one liners: https://github.com/torvalds/linux/blob/master/kernel/sched/core.c
&gt; Single-threaded only Honestly, achieving much better performance compared to default `new` and `delete` should not be that difficult with this constraint. Lots of people use suballocation patterns that are not threadsafe to speed up such patterns. Pooling objects gets you even more performance because of locality and lack of heap fragmentation. Also, without an actual description of your actual use pattern, the claims of improved perf are literally useless. There are all sorts of bad allocation patterns that can create pathological performance/memory issues in the wild that mature allocators handle. What does "10x faster on average" mean? Looking at the code, I honestly find the claim pretty dubious unless you have a particular pattern your code excels at. In such a case, it's better to be upfront about what that pattern is then throw out a blanket claim without data to back it up. The other thing that is sort of grinding my gears is that there's no explanation as to the plausibility of the claim here. What's the algorithm? Free lists usage? Buddy allocator? New tricks?
This article may assume that you already know more about CMake and build systems in general, but it may help: https://pabloariasal.github.io/2018/02/19/its-time-to-do-cmake-right/
Thanks. I can pick some basics from the cmake documentation site. This is more along the lines of what I was looking for.
The curve of years of experience isn't encouraging. Over a third of the participants have been coding with C++ since the beginning (1998) and a meager 2.46% have just started in the last couple years? As a language, this should be a wakeup call in terms of improving the ergonomics a bit. People that were there from the beginning take things like linker hell, compile times, crazy build tools, arcane flags and incantations, and years of backwards compatible cruft for granted, but if I force myself to look at the language with fresh eyes, it's hard to ignore how behind the times we are in other ways. I will always be a proponent for keeping ABI compatibility but deprecating syntax (over some fixed timeline), the language is just too hard to extend and learn, with too many mistakes of the past (even recent past) being ossified in and making things harder. Divorcing the language from the tools was great in a world where compiler competition to steal users to a platform was a thing, but in this day and age, I'd be happy to see at least a standard interface to said compilers. The good parts of the language are there. The infrastructure is there. The applications that need low-level performance (safety sometimes be damned, i.e. multimedia applications, games, visual editing programs, etc) are there. But I'm not bullish on a language that relies on the permanence of legacy code to sustain itself.
:(
Named constructor.
I am going to use this in tomorrow's code. ... defualt: do_this(); defautl: do_that(); default: do_the_other_thing(); dfeault: do_something(); deafult: do_whatever(); which are fall throughs from the previous and which are default? Sweet.
When I show C++ veterans auto they get a sour expression on their face and start trying to formulate arguments about how the world will end if auto is ever used.
GCC accepts that, but Clang rejects it.
I mostly don't use auto out of habit, but there's a few cases like iterators where I prefer them.
You can also goto a case label, so if you need two cases to fallthrough a third you can do: switch(x) { case 0: foo(); break; case 1: bar(); goto case 3; case 2: baz(); goto case 3; case 3: barbaz(); break; }
Reddit has code blocks for me!
That doesn't come for free. if X{x: 1} == y { ... } doesn't parse, because Rust doesn't know which pair of braces start the body of the if. You still need parens sometimes...
Not an expert by any stretch, but I’ll answer your question with a question: Why do you need to learn cmake? If you’re trying to get started working on an existing project with a cmake build, I’d say let it be a black box until you can’t any more. When you need to add something new, learn what you need to learn. Rinse, repeat. If you’re starting a project from scratch, just get the absolute bare minimum in place and go from there. Compiling a c++ program with no dependencies is not too bad. If you’re trying to migrate an existing project with a complex cross-platform build to cmake with no prior knowledge, good luck. It is a world of arcane torture, and nobody really seems to agree on best practices. When you get it working, pat yourself on the back. If your solution suits your needs, I’d call it “correct” and move on. When it needs changing, change it. If you’re just trying to learn it for it’s own sake, it’ll be hard. That’s the thing about build systems: they need something to build. It’s like saying “how do I learn to use the gnu linker?” Do the basic thing you _have to do_ in order to accomplish your immediate goal. Eventually, you’ll have to do some wacky thing and you’ll understand it better. Your mileage may vary 🙂
I've encountered a few (and come up with two original) patterns involving zero-size structs in Rust. I'm quite looking forward to using some of them in C++. Among other things, being able to bind a concrete zero-size type (that can be used in compile-time calculations) to a template type binding in situations where the empty base optimization is inconvenient...
I was trying to figure out how to do this today and I couldn't. Now I know.
We need some of those twisted brilliant people... unfortunately, we're hiring them to work in Rust, but we're desperately trying to find some of them that aren't as old as me and the one other guy we've managed to acquire who really groks memory and cache and stream layout and so on... and all of the younger people we're getting from Stanford and Berkeley and USC and so on are more interested in learning frameworks and existing platforms than the underlying systems.
Ah, but I bet you didn't expect the `else` statement to associate with the inner nested `if`. And of course, this only works if the body of each control statement is a single line, or a nested control statement.
Concepts are the biggest game changer in any language I have seen. Yes, they should have allowed the simplified syntax. Concepts alone could move us into the future. But wait there is more!
You. Go stand next to the "url is valid C++" guy. Face the wall and think about what you've done. ^^^^^*snerk*
I think if you can readably fit the entire `if` on a single line, then that's fine -- guard conditions for example. If you can't, then there's no reason not to put the braces unless you're using a style with a lot of newlines.
I've actually used that to my advantage with boundary-converting operators that transformed container&lt;allocatorA&gt; -&gt; container&lt;allocatorB&gt; where my allocator had a kernel-allocation-incompatible address range.
Your formatting is evil I'll give you that.
Well I guess based off your question and mine I don't really understand the concept of observer or owner. Does the owner mean it is the source of the block of memory being allocated by way of new, and does the observer mean a reference to a pointer that just created the block?
Nah, some of us are perfectly fine with it. Though, I guess you could argue that we're not veterans if we upped for an (fourth or fifth) additional tour of duty.
There's no difference between remainder and modulo -- "x modulo y" is just another term for "the remainder of x divided by y". There is no other implication there of the kind of remainder done, except in Haskell, where rem means the common "round division towards zero" method, while mod means the less common "euclidean remainder".
Well I there's a reason why the headachy is so. Is it a mistake if D does not contain the values but pointers?
Mathematical modulo is usually positive
So you would have it automatically copy to a user's allocator? I'm not sure I fully understand.
Wasnt paying attention, just saw curried. Me: "Ooh, currying in C++!" *click* &gt;mutable curried objects Me: "wut."
Well that is absolutely ugly, but thanks for the heads up.
No, it isn't. Mathematical modulo is an equivalence relation for which the common obvious representative is the least positive remainder; however, that's only because the least positive remainder is usually the most useful to use for algebra. You also often use the negative remainders, since they're very useful for some other algebra, e.g., 4 = -1 (mod 5).
 struct really_empty { char nothing[0]; }; has worked for decades.
That's a UB, friend
It will take a while ; can only dedicate one thread to it.
I wouldn't read too much into this. When I was in ICPC, C++, Java, and Python were our only options IIRC. You're not about to give up 100x performance with Python. Additionally, the provided compiler did not have C++11 support (this was in like 2015).
&gt; If you’re trying to get started working on an existing project with a cmake build, I’d say let it be a black box until you can’t any more. Yeesh. I want to like cmake but I thought I was the only one that took this strategy.
For such an algorithm, memory allocation should never be a bottelneck. It should be so infrequent that even if window‘s allocator would be 10 times slower, you should not notice it. Which is why I‘d double check how those lists are enlarged.
Woah. And it makes sense. "Instantiation" is done by the compiler/linker, and so you can think of it as just a pointer to the area of memory the for the static variable created by the compiler/linker.
https://cgold.readthedocs.io/en/latest/ https://github.com/onqtam/awesome-cmake
I've used [Modern CMake](https://cliutils.gitlab.io/modern-cmake/) before.
By far the best and comprehensive resource I have come across is [Professional CMake: A Practical Guide](https://crascit.com/professional-cmake/). Highly recommended!
We use some heavy libs like opencv on Windows, and for the some historical reasons we have different toolchain compare to other departments. Not crossplatform, just different toolchains. So it's not an option to share prebuilt libs. In that situation we use cmake. Most of our deps have it's own cmake build script. We include them with an externalproject_add() function. It allows to download sources from remote repo, or pick up them from your file system. Last option is preferred for us because of proxy, but you always can mix them together with some conditional, and by default something like `cmake --build . --config Release` will upload and build your dependencies. External project allows utilise almost all possibilities to customize build in terms of basic tweaks and complex configuration prepared by library devs. Like find_package(). There is some minor problems with two stage build in cmake, but few hacs can mask it from you. *Not good doc page to start learning cmake* https://cmake.org/cmake/help/latest/module/ExternalProject.html
&gt; they hard-code the memory management strategy into the types. Not always.
How would you ever reason about anything if you didn't tie the behavior to the lifetime of variables. At that point you may as well just call new/delete - that's essentially what you're suggesting.
That C++11 implicitly adds `noexcept` to destructors, so if you let an exception out from one it _will_ `std::terminate` your program. You have to explicitly mark a destructor `noexcept(false)` to be able to do it. I've been using C++11 or higher for 5 years and had just never tried throwing in a destructor before (for obvious reasons). I just happened to have a reasonable use-case for it. I was also surprised because as far as I know, this is a backwards-compatibility breaking change, relative to pre-C++11.
It could also mean that more experienced people tend to participate in such surveys. Juniors usually don't bother themselves as much with what's happening behind the scenes.
Braces aren't mandatory because language expects a statement, and compound statement is a statement too. else can be written like that because it is literally just a token that tells parser that those if statements are related, the only gain is optimization by default. What I mean is that if x if y is exactly same thing whether you put an else before second if or not. Of course, their uses can be different, you might want to use x and y individually, but even if you don't, this usage is sufficient, else just makes intent more clear. Not trying to say that code written like this is acceptable...
&gt; I am not familiar with conan, do you know by any change if it is capable of providing custom build? Yes.
Why wouldn't you? else expects a statement (Why else {} works), and if statement... It's in the name. lol
The owner is the object that you can say the memory does not need to live longer than.
No I considered that but you should look at the spread for other programming languages. Even if the bias is there, the delta from the mainstream languages is pretty astounding. If nothing else, you could say it speaks to the availability and opaqueness of the C++ material.
I don't have enough information too judge. Here's some considerations: - If `D` [is composed of](https://stackoverflow.com/a/10394722) (owns) `B`s, it makes more sense to contain them by value or by `unique_ptr`. - If `D` only owns `B`s, not other derived classes of `A` nor anything derived from `B`, by-value is more preferable than by-`unique_ptr`. - But if `D` does not own `B`s at all (i.e. association or aggregation relationship), a raw pointer `B*` as non-owning pointer makes sense.
There is more than one side to a smart pointer. There is what it does internally; shared lifetime, unique ownership, etc. It would be pretty easy to write a "virtual" smart pointer that changed what it did. But there is also how it is supposed to be used. A shared otr can be copied and guarantees copues are equally valid. A unique ptr cannot be copued, but can be moved; when moved the old one is invalid. A hypothetical non-move non-copy ptr could also exist. Now you can type erase those and the LSP works. A non-copy ptr, a non-move ptr - a scoped ptr. While it makes zero sense to store a unique ptr in a type that claims to support copy, it does make sense to have your api say "I want a smart ptr, and all I demand is that I can move it. I will not copy it." That demand can be met by both shared and unique ptrs. And the action-on-final-destroy is type erased, which means it supports all kinds of unique ptrs. While shared type erases destruction, it cannot store intrusively inplemented smart pointers, nor does it support value ptrs. So a "can copy and move" type erasing smart ptr is also viable. The scoped ptr is a bit harder; for the most part, the can-move (as a reyurn value) or raw ptr (as an argument, with caller destroying) works in its place. But that still gives us 2 smart erasing pointer types.
Python also uses Euclidean remainder. They both are useful and should be in every language in one way or another though.
To people who want goto's removed: this would be removed too.
The possibility to write Internal Headers to greatly improve separation of concerns.
No, they're dirty, because functions are mainly where we hide all the complexity, it's like a rug where you hide all your dust under. Then we copy paste the label that is a function name acting like everything is fine. Adding gotos, in almost every case is like letting bullet ants, scorpions and whatever other cancer live under it. Stop.
I just looked it up and that's definitely what I want! Thanks so much.
IIRC, it is also the case in C, I use them for clean-up in functions, and they're useful, never found a reason to do that in C++ though.
If you're an evil person, you'll be pleased to know C++ still suppports [alternative tokens](https://en.cppreference.com/w/cpp/language/operator_alternative). Not just the ones you would expect, like the boolean operators, but even brackets, braces and hashtags. There are even some tokens that are parsed **inside comment blocks** (which have been removed since c++17, but considering last week I had to use GCC 3.3...). https://godbolt.org/z/zEUF0t
Alice borrows a book from the library. Alice is now the quote-and-quote "owner" of the book. She is responsible for returning the book. Then, Bob borrows the book from Alice. Bob does not own the book. He is just an quote-and-quote "observer" of the book. Alice is still the owner of the book. Alice is still responsible for the book. Now, imagine Alice and Bob are not people but pointers. Swap out "a book" with "a piece of memory" (or more generally "a session of resource"), and "library" with "the heap".
I'd have to see an example to believe, because if you were to follow gotos, you'll just figure out the sequence of instructions fairly quickly.
But should in fact be a compile time error. I guess it's because of C's legacy why it's not.
Rust solves this problem by having comparison traits that can be derived (auto implemented by compiler if all types in struct also have that trait), in C++ this would be so much messier though... Especially when you DONT want them to be implemented. Are there any ideas how it could be done without inheritance with some compiler magic?
It's very weird that it's a warning that's not on by default, and yet, just a warning ... UB should be a hard error.
This. My introductory programming classes in highschool were C with iostream.
cmake is a widely used tool in software and there is nothing wrong with learning a tool like cmake for the sake of learning. As of c++now 2017 there are informal idioms - see the talk by Daniel pfieffer titled Effective cmake. The following link includes several good resources for learning cmake: [modern cmake](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1) I just recently watched the following talk which I thought had some great advice as well but it isn’t cmake specific: [packaging do’s and don’ts](https://youtu.be/sBP17HQAQjk)
Not gonna lie, it's hard to miss C++ after using Rust. Unless you're writing unsafe {} in every line, C++ won't do it better than Rust. I have that bitwise not is `!` and everything you ask someone about is just "yeah, download x crate", does nobody just sit down and do things anymore?
Namespaces can recursively refer to themselves. You can also nest this recursion as deep as you want when referring to members of the namespace: namespace A { namespace A = A; int b(void); }; int A::A::A::b(void) { return 5; } int main() { return A::A::A::A::A::A::A::A::A::A::A::b(); }
Stack Overflow has enough of good examples showing how not to use auto, so just fyi, it's already ending.
Your comment already says that you have learned nothing, but it's hilarious to see that your comment is the very bottom one, further pushing that nail into the coffin.
Ah yes, the Fonzie antipattern.
Lol it was a gamble for how it would play out. I did it more to see what would happen. The rest of the thread is full of gems though and I made sure to at least throw in something to contribute to it when I posted this.
The "Curiously Recurring Template Pattern". A way to extend a common base-class statically, for when you don't need dynamic dispatching. https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/
std::apply for unpacking tuples into function args. I had to write my own implementation to support some legacy system and couldn't use c++17 :(
Oh, it was not surprising in the sense that it was a syntactically legal construct but rather that there were situations where it was sane to do something as weird as `delete this`.
 #define DELET delete #define THIS this
I'm sorry I started a discussion about the use of curly brackets. Normally I always use them. I just didn't want to use them here because then it would no longer be a "switch without curly brackets".
I find that delete feels slightly naughty all of the time since C++11. But I have a slight obsession about avoiding dealing with new / delete / malloc / free except in special performance related situations.
Is that something you have to do by hand? I have diligently avoided directly using COM my entire C++ career (not C# but that is a very different support situation).
Why not use the same memory management techniques in tests? I do not see any benefit in what you suggest.
&gt;**template&lt;typename T&gt;** using NiceVector = std::vector&lt;T&gt;;
By god, you're right.
Maybe but then they would have to agree on the exact rules for when it should be an error and when it should not. No matter how they do it it would always lead to some false-positives. Right now it's up to the compiler whether or not it will generate a warning which can even be affected by optimization flags.
It's not UB unless you *call the function* and *reach the end of the function*.
And MSVC? (Asking coz of your flair!)
Probably it was because I had a short circuit return earlier in the function but it was msvc that didn't even complain and happily mangled my stack instead.
This doesn't seem to work.
Void function can return result of other void function. ``` void foo() { } void bar() { return foo(); } ```
&gt; wasn't the recent Mac OS login bug caused by someone trying to add a line to an if statement body and not noticing it didn't have curly braces? Not really, no. It was caused by a badly resolved merge conflict. Braces might make this less likely because the patch algorithm has more context but fundamentally something similar could have happened with braces (and has, to me, except I lucky caught it).
Does this mean we should mark all our members \[\[no\_unique\_address\]\] in the future? (unless we need them to have a unique address of course)
GCC says: &gt;warning: ISO C++ forbids zero-size array ‘nothing’ \[-Wpedantic\]
Well, if you don't want to have size overhead for empty Structs it can certainly help
It accepts.
Looking at some examples online is also a good way to learn.
the alloc\_speed executable gives reproducible benchmarks.
Or some common-decency and kindness. Something Whooster and yourself seem incapable of.
`E_MISLEADING_INDENTATION`
Aahhh... It does actually work for real-world applications already. I may not have time to test against jemalloc because I'm trying to do job hunting. And I'm not sure I should spend my time doing work for free, for a community, if they are hostile towards me (not yourself but the thread is voted to zero). Of course multi-threading will slow it down. But its nice to have the option of a single-threaded allocator? I assume it will only be 8x faster than malloc on average once the MT thing is fixed.
 &gt;else expects a statement (Why else {} works), and if statement... It's in the name. That's not the surprising part, it's the misleading indentation, leading the reader to think the control flow was different. The worst part is, I've fixed bugs due to this specific issue because people were writing nested single-line if statements and just weren't thinking. The same code with braces would (obviously) flow as expected.
He meant that the else statement became an else if statement instead of an if within an else like probably intended. Which provides the same end result but is confusing.
Everything has to start somewhere. The idea is, you have a good idea, you start work on it, you prove it's good... and then if you get enough interest you can push the thing further. So... I'm testing for interest and... there's none. I was right. People just don't care. No matter what I do it's never good enough.
It's kinda sad all of the answers so far are old news for me. Luckily c++20 is coming with quite some new stuff to learn :)
Personally, I would have expected `delete this` to be undefined behavior. At the very least, if you access any instance variables after that point, you definitely are.
This: &gt; Ideally endianness requirements would be spelled out in detail before you start work is not related to this: &gt; I maintain that a library for this should give you options to decode all common byte arrangements. You can't say 'however' between two things that are not mutually exclusive. &gt; If you need to handle data in multiple formats you just have to encode byte order information then use it on the other end This is only needed if the same messages are sent by different sources in different endianess at runtime.
It is UB to have function names starting with "is" or "to". [https://en.cppreference.com/w/c/language/identifier#Reserved\_identifiers](https://en.cppreference.com/w/c/language/identifier#Reserved_identifiers)
The burden of proving that your thing is superior is on you, to be paid up front. If you are only trying to outcompete single-threaded allocators, compare it with something like std::pmr::unsynchronized_pool_resource or another specialized single-threaded allocator.
Watcom?
I'm a fan of tomorrow.
Monsters. We should add a `comefrom` operator.
&gt;Conan just breaks version to version, recently with VS2019 Can you elaborate on this?
Impressive in scope, I don't like some of the names, but the most important thing is 'why?' doesn't stl/boost cover all this and more?
Tabs also work.
I think value equality is a very reasonable **default** semantic. If a type is a POD type (or rather if all it's members are public), it's value is the combination of the values of its member variables, so I really don't see, why defining equality recursively shouldn't be a good default.
... followed by a miniscule letter
And how do you set a breakpoint on that condition without resorting to (extremely slow) conditional breakpoints?
Agreed, any call, field access or the like would be UB (and likely to cause problems).
I guess I should have said, "Legacy code swamp monsters."
Something to cite on auto doing anything but get wildly adopted like any modern part of C++ as used by people who are aware it is 2019?
Unless your class is trivially destructible and you have an overloaded `operator delete` which does not actually free the memory.
Still weird that names such as tokenize() or isolate() are illegal.
2 votes for, 1 against, must be legit?
An important side node, RelWithDebugInfo only uses /Ob1 (only inline functions marked with inline, or in a header file), not /Ob2 (inline any suitable functions). So there can be quite significant performance differences. It's a really unfortunate default.
It's not permitted. In fact, some stl implementations of `std::array` will create an array of one element even when size argument is zero, so `std::array&lt;NonDefaultConstructible, 0&gt;` refuses to compile (example: https://godbolt.org/z/B-8oAU).
Oh that's handy, I'll have to remember that. Just because it's C++, does float round down?
I think it's more because it doesn't affect the size of the class, so knowing its size is not needed.
Most people don't care for 99.9% of other's lives. It's normal. But you set the tone here. What people see first is not your code and not your benchmarks, but your post. And if the post basically says "I did something for free so bend your knees, ungrateful peasants" - ummm, it will probably be downvoted indeed, no matter how good or fast your code might be. If you like something - do it and don't wait for appreciation.
Thanks for the explanation. That statement just seemed counter-intuitive but taking into consideration the data size, it makes sense.
cppreference claims that &gt; As is the case with typename, the template prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template Unless I'm missing something, Clang is wrong to reject this.
Ah yes. The Pauli exclusion principle also applies to C++.
Variable templates, though they're limited to being global or static.
Haha, that's what I'm going to call it from now on.
no because similar surveys for other languages show a completely different picture : e.g. in the stack overflow survey, more than half of the respondants have less than 10 years experience of programming : https://insights.stackoverflow.com/survey/2019
&gt; Yet when I do the same... I'm held to a higher standard. Why? Because you ignore the advice people give you time and time again. You think it's personal? If you're being treated like this in every new community that you join in, it's obviously something to do with your behavior. And it is. People have told you why. Stop dismissing people's advice as personal vendettas and you'll be much better received.
Not true. At all. IN fact it's 100% reversed.
Haven't checked Evo C++ yet (will have that covered soon) but generally speaking: no. Folly, EASTL and other big-corporation in-house libraries seem to signal the idea that there is room for improvement in the one-size-fits-all standard libraries. Just a while ago I wrote replacement for something as trivial as std::vector for critical path performance optimization. The throughput doubled. The standard is fine, until it isn't. A great starting point for sure, don't optimize prematurely, right? Look at std::vector implementation in common compilers; it's literal shit ton of code for a fundamentally trivial thing. The standard puts a lot of requirements in how it should behave, okay, cool. Then a lot of optimizations are written like is type pod, movable, yada yada yada and the crap keeps piling up. Then someone specializes it for bool and suddenly you access the bools through a proxy class so that a reference to a bool-in-a-vector is a discrete object, not a bit in array of bits internally.. and so on and on. No wonder the headers are bloated as F. I get the reasons why that is .. but at the end of the day, all these specializations and optimizations can still be beaten with very idiomatic code that doesn't do anything extra special just because the code is straightforward and simple and does nothing extra, just what you want and no more. In general, the C++ has blown up to a major mess.. what we (old school C++ developers, on 2nd or 3rd decade of using it!) is a variant, like C++2.0, or C+++, or Cool++ where corner cases and some UB are deprecated (or don't exist to begin with). Tons of UB exist just so that C++ could have been ported to some fucked up 1's complement machines, machines with weird word sizes and behaviours on unsigned integers and so on and on.. eliminate as much UB as possible with certain sensible limits on what is needed form the hardware and we would have much saner foundation to build on. Second, make syntax that invokes UB too easily illegal.. oh, there is sequence point in wrong place, FUCK IT, LET'S GO UB!!! &lt;-- that kind of shit should be harder to write with legal syntax.. and so on.. I don't really need or want Rust, Kotlin, C#, Yada yada.. C++ could be fixed but it wouldn't be C++ anymore, of course. D? There is tons of GOOD SHIT on C++ but all these warts and sick UB invoking convolutions fuck it all up. Oh no; another language.. just what we need... I didn't yet mention aliasing and how it is broken in C++ either... :D Went ballistic with off-topic, huh?
This is an insane "feature". If the &lt; is parsed as less than which normally returns a bool, then it would be compared with a &gt; greater than operator which shouldn't be permitted. I wonder if there's one single user code around the globe using thing like that. C++20 spent sometimes to remove the need to use typename keyword in some cases, I wish it did the same for template keyword too.
Oh, and whose brilliant idea it was to have at() bounds check and [] not? Why not just check [] on debug build and not check on release? Who actually ever used at() or seen anyone use it? OK, so there is that one guy who seen it used.. *party* ..
As a programmer, I found it surprising that the position args are not zero-based, e.g. in HEDLEY_NON_NULL(1,2).
[Duff's device](https://en.wikipedia.org/wiki/Duff's_device). I owe a colleague a cup of coffee for claiming that this will trigger an error. Bastard code compiles without warning.