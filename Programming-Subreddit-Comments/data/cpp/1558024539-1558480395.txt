Erhm what? Stop the site to recompile, are you serious? &amp;#x200B; There is such a thing as versionable dynamic plugin loading and reddit would not even need that. They would compile the new version (probably there are several smaller services involved), deploy it to their machines or a group of their machines. Then just as they would do with any multi-machine website they'd either do a reload of the C++ plugin / service for the application, do some sort of internal machine routing (port swapping), restart the web application if it is a static compile, but they would do it one machine at a time or a group of machines at a time. It would work just like any other continuous deployment / integration system. And there is a tonne more ways to do this. But none of them would be to take the site offline, recompile and then turn it back on. That makes no sense.
AAA -&gt; great C++ AAA -&gt; not so great software development
OK - reflection can give you the list of member variables for a class. But how is it going to determine which member variables should be serialized and which should not be?
 auto xs = std::vector&lt;double&gt;{3, 10, 15, 20}; I may be wrong but wouldn't this trigger a copy or move? Isn't this less efficient than the equivalent typed initialization below, or is it elided by the compiler?
*Part* of it is on track for being merged into c++2a IIRC. So no idea if and when we get the full package as part of a standard library which you can actually use in production.
Groups allways have a sparse set of what entities they contain. For the strong-owned component, is all based on ordering enforced by the library. Each component has exactly 1 sparse-set for itself. The trick with the groups is that the sparse set for each of the owned component is ordered in a way that the "start" of it is the components owned by the group. So for example, if you have A,B,C components, and you have 100 entities with both A and B, but only 50 with C, if you have a strong group that owns A,B but also wants C (weak owned), in both the A and B sparse sets, the first 50 elements will be the group ones.
&gt;Why is C++ never used for web applications? The premise of your question is faulty. C++ is used for web apps. &gt;Why are there no C++ web frameworks? Same as above. Thare are C++ web frameworks. Here is one at random: [https://www.cppwebframework.com/](https://www.cppwebframework.com/) A better question to ask is why is C++ not used as much for web apps as some other languages. As far as I can tell, it's at least partly because the strengths and weaknesses of C++ do not match with priorities of most web applications. C++ *development* is relatively slow and expensive. The bottleneck of most web apps is not (only) on the server. It's in the development process and the budget.
Have you read the TS? Like I mentioned it's full of magic types. For example: enum X{ A }; using x_reflex = relfexpr(X); using x_enum_values = std::reflection::get_values_t&lt;x_refex&gt;; Here, `x_reflex` is a magic type, not an enum and `x_enum_values` isn't an array, it's a magic type. What "magic type really means? It is essentially a pointer to an AST type representing something. On the other hand, now that `std::vector` and `std::string` are `constexpr`, if we switch to `constexpr` reflections, there won't be so much magic going on: enum X{ A }; constexpr auto enum_reflex = reflexpr(X); // still magic constexpr auto enum_values = std::reflection::get_values_t(enum_reflex); // std::array or maybe even std::vector The reason why TS was published even if they are going to change the synax is because they want to see "have we got the API right, even though we didn't get the syntax right".
&gt; Values are implicitly using params, based on bitshift order operations. Yes, don't bind anything or bind wrong data type and you get a runtime exception. Any error handling is done at runtime. &gt; Queries can fire by themselves from destructors ?! Yes. This is a weird design, apparently some problems with object lifetime management. &gt; I'm not clear on the use of db. It appears to conflate: 1] Create a DB connection 2] query creation, 3] calling actual query , 4] query results, 5] table declaration / creation, and 6] prepared statements Yes. It's almost for everything. And the type does not reflect the actual query. All queries have the same type.
Depends on how you want it to do it, you could do it using types, using annotations (if the reflection system comes with them), using names, or whatever.
Within the owning group of `A` and `B`, say I wanted to iterate over every entity that had both components `A` and `B`. Am I correct in my understanding that this is how the process would yield entities? for each entity ID within the group&lt;A, B&gt;: map the entity ID to dense index i_a in sparse set A map the entity ID to dense index i_b in sparse set B process(dense&lt;A&gt;[i_a], dense&lt;B&gt;[i_b]) Particularly, to produce pairs (or triplets, etc.) requires an entity ID lookup in each sparse set from entity ID to packed index?
&gt;When I make a change on a cpp or an h file the system knows that it has to recompile everything thay depends on those. Wouldn't it be easy for the build system to remember which files modules are defined in and do the same? But how does it "remember" something that it doesn't know until it compiles *every* source file?
If the components are strong owned, there is no mapping. It will just run like the for loop i posted above with direct array accesing. No indirection. The indirection is only on the weak-owned components. Say the example above, where A and B are strong owned, and C is weak-owned for(int i = 0; i &lt; entities_in_this_group.size(); i++){ //direct array acceses A&amp; AComp = direct_to_A[i]; B&amp; BComp = direct_to_B[i]; EntityID entity = entities_in_this_group[i]; //indirect access C&amp; CComp = registry.get&lt;C&gt;(entity); Process(AComp,BComp,CComp,Entity); }
The latest revision was just under a year ago https://wg21.link/p0323r7 thats all I know
I typically use what makes things look the most simple. Complex types and long namespaced templates get very noisy very fast. I want to be able to look at the logic and execution first and types separately. If complicated types can be hidden a bit with auto, I'll use auto and annotate anything that might not be clear in the comments. Short type names or aliased types that now have short names can stay because it increases clarity without increasing verbosity much. This has typically been a very worthwhile approach for me. When making a new class there are usually a few aliases to complex stl types.
Ah okay, so you can retrieve the entity ID using the index of the pairing, that was the piece I was missing. Thank you!
Another problem other than the one that are already discussed is that C++ doesn't have a standard package manager: for JavaScript you have npm, for Python pip, for Ruby gem, for Rust you have Cargo, etc. That is a problem for web development because you tend to use many different libraries. There isn't even a standard build system, but rather a number of different build systems, plain makefiles, automake, cmake, meson, etc. That not only makes complicated to manage the software (you have to learn not only the language but also the build system) but also makes it complicated to deploy in the cloud: if you have a server written with Node.js in a couple of seconds you deploy on AWS, because all the server has to do is run `npm start` and done, with C++ is more complicated, you have to build, you have to install shared libraries in the system, you have to have the right version of the compiler, of the build system, etc.
It triggers the move constructor is the type is moveable, in other words, it has a move constructor. It seems that it can also be elided. But initialization overhead would not be significant in non performance critical part of the code such as loop.
I may be wrong, but even using Plugins, it would become harder than using Python. Another advantage of Python and other scripting language is that during the development, all someone needs to do is to edit some script and reload the page. In C++, during development, the flow would be: edit the files, compile and restart the server process or reload the plugin. Web companies also would have trouble hiring C++ developers. Learning any scripting language web framework is way easier and faster than learning C++, so it gives them a much bigger talent pool. &amp;#x200B; C++ Plugins also have another drawback, as C++ lacks a standard ABI, if the site compiled with GCC and someone compiles the plugin with another compatible compiler or incompatible version of GCC, the site will fail to load the plugin.
People might give you a hundred reasons but ultimately it's because doing it in Java or .NET is infinitely easier regardless of your experience in C++
Since C++17 it is guaranteed to be elided and the type doesn't even need to be copyable or movable for it to work.
https://godbolt.org/z/VMqBSf Same exact thing
Now that you mention maybe but i think it is because i use TDD in my way, that it is i create some code and when i am happy with it (two classes or one big usually) i do the tests of them so i can keep less bugs as i can in the code, misspelling will be catch so thats why i dont taked big care and attention about this back then and dont remenber as it was yesterday The example of the iterator is another history, it left me a big impression and i tried to remenber it as it is important. I always try to remenber that kind of things as make me a better developer
_Generic is a C11 feature that basically provides a template like system for type based function selection at compile time. Example: #define Abs(Value) _Generic(Value, float:AbsF, double:AbsD)(Value) Abs is a macro that will call AbsF is the type of Value is float, or AbsD if Value is a double, at the end the (Value) is then submitted to the function as a parameter. You can use it with a variable number of parameters, I only used 1 parameter here for simplicity
If you're already passing around context objects such as the logger then taking the same approach with your metric counters seems perfectly reasonable.
I think it is possible to run do the formatting on each single commit with some git magic, so the history looks like it was always used. That way you do not get one single commit that changes all the formatting. That is at least what my colleagues told me they did when they started using clang format.
This only works if you have some concept in the first place. It is not a real alternative.
Compiling clang takes bare minimum 3 hours... so yes, compile times are absolutely a problem.
Please elaborate.
For those (like me) who didn't know what _uv_ was - http://libuv.org/ &gt; libuv is a multi-platform support library with a focus on asynchronous I/O (That link should probably replace the first _libuv_ reference in that `README.md`)
I'm really surprised when people say this. Compiling clang on my Gentoo machine is like half an hour. Don't get me wrong, I've seen insanity-mode build times with other stuff. Just not clang. Chromium, for example, takes bloody forever.
[Relevant xkcd :)](https://xkcd.com/303/)
How frequently do you have to do a full recompile?
Assume you are using Java and the Tomcat application server. You have your IDE setup to recompile the files with the output directory being the webapps/myapplication directory in Tomcat. You change a source file, the IDE recompiles it, that takes an amount of time, then places the new .class file into the webapps directory. Tomcat will within 10-15 seconds see the update file then it has to unload and reload the changed classes. That takes some amount of time. So the overall turnaround time from changing a Java source file to being able to invoke it via a web test in the application server is still in the 1-2 minute range on average.
I am not much of a web developer, but with Django the change is usually live by the time I alt+tab to the browser. Of course this is with the development server not a real server.
One thing you can do is use filter the entire git repo ([https://git-scm.com/docs/git-filter-branch](https://git-scm.com/docs/git-filter-branch)) and apply formatting by rewriting history. You will need to make sure everyone reclones since it's effectively a new repo, tho. After that if you make everyone set up pre-commit hooks that do the formatting then you don't run into these problems with messed up diffs. &amp;#x200B; Personally I find manually formatting code kind of soothing so I tend to just do it myself...
None of these things are wrong. Yes C++ does not have a standard ABI (but there are mitigations to this nvm that atm). Yes C++ developers are more expensive at the moment. The build cycle is also different, but I am not sure that is necessarily as different anymore because more sites that would need C++ (either being embedded or hardcore large ala facebook/google) would have unit and UI unit tests to run against changes and the entire "just edit a script" things goes as much out the window as it should do anyway. My personal opinion is that I don't think C++ belongs at the outer most UI layer defined in WASM (fuck JS) but I do believe everything that is contacted by said UI should really be done in C++ even if it is a higher barrier. I do not want to think about how much CO2 could already have been saved by eliminating all server-side JS, PHP, Python, Rails, Java and C#. Do not mistake I like those languages I am just sad about the additional energy they use, because yes I know the entire "it is all I/O waiting" argument but when you see that even doing equivalent tasks C/C++/rust or even go code uses so much less CPU and power and so could sustain more user leading to less machines needed in the cloud leading to less power being used for computing.
Same is true for Golang if we want to compare apples to apples.
Thanks! That's really interesting, I even tried not using auto and just doing: std::vector&lt;double&gt; xs = std::vector&lt;double&gt;{3, 10, 15, 20}; and it was the same thing too between GCC, Clang, and MSVC. Well shoot, I've been programming C++ for years now and always just assumed that that form of initialization always involved a temporary. Is it defined in the standard somewhere that if we're initializing with a temporary of the same type that it just doesn't do the temporary step and initializes the object directly? TIL!
Boost.Beast is probably what you're thinking of, it's a very nice http client/server based on Boost.Asio. I still don't know why anyone would want to build a web app using it, however. You're not going to see any advantage whatsoever from using C++ in a piece of software that spends most of its time waiting for HTTP requests or waiting for database responses. You'd still pay all of the costs, though, starting with longer development time and ending with remotely exploitable memory errors. In my opinion, it's not a small mistake, it's a colossal one. The kind that could end up killing your business as soon as you get even one competitor that uses a language better suited to the task. See also http://www.paulgraham.com/avg.html
Isn't Django a Python framework? Do you compile Python code or let the script interpreter read it as it changes and potentially JIT it?
**ALWAYS AUTO!** The cases that were exempt from the rule have been resolved in c++17. At this point you can write auto rd = std::random_device{}; without it causing any issues. I use it, since it makes it much more obvious which lines define variables and which just change stuff.
The latter, but I thought we were discussing speed of iteration in programming languages used for web development.
Not sure about this given /u/ricco19's example. Seems like a special case is made here.
Typedef and replace later?
https://en.cppreference.com/w/cpp/language/copy_elision
Once upon a time we had ISAPI Filters that were made in C++ and it turned out that they were cancer the whole time so everyone stopped. Every so often, a long running legacy web app breaks and when it's discovered the culprit is an ISAPI filter the solution is to just build a new web app or shut down the site. The end.
You'd be well-served by investing in better hardware. I was curious and just did a clean build, and it only took 23min in my build VM.
Most interpreted languages will update virtually instantly when a file is modified and saved. Maybe you have to restart the server process to see the changes in the worst case. I prefer using Clojure, where I can
It's totaly possible, but you will re-write the whole history, witch is probably not what you want do.
Because even programmers have a limit to the amount of pain they will inflict upon themselves.
Thanks! That clears things right up. So just to recap: * Before C++17, it was permitted, but not required that copy elision happened in the case of object initialization with a same-typed temporary. However, most major compilers did it. * C++17 basically says that it is required as part of the language and no longer considered copy elision. That makes `auto xs = std::vector&lt;double&gt;{3, 10, 15, 20};` effectively the exact same thing as `std::vector&lt;double&gt; xs {3, 10, 15, 20};` Nice!
Really interesting. Ofc I've still to add support for custom allocators on pools level, but I didn't need it so far and therefore I postponed it. I'm pretty sure it could bring in benefits. At the moment, users can only specialize pools if required, that gives already a good level of flexibility. In EnTT I've added const/non-const types of components on views and groups (similar to what you did apparently) so as to design something in the field of mt sooner or later. However, I'm not there yet with the second part. It would be really interesting to chat about the similarities, problems and differences between the two solutions. I think both could benefit from this. Feel free to ping me if you're ever interested in discussing it. ;-) Thanks for your answer also. Really appreciated.
The URL is broken, but the content is available from [https://github.com/cjdb/cjdb.github.io/blob/master/sg20-and-videos.md](https://github.com/cjdb/cjdb.github.io/blob/master/sg20-and-videos.md)
(Btw try searching “format string” instead of “template string”)
Yes, though keep in mind that return value optimization, especially named return value optimization, can't always be achieved. I'm mentioning (N)RVO because it is a related optimization.
It depends on whether it's your first language or not. If not, perhaps a few months. But plenty of places would be willing to take on a C programmer who is keen to learn C++.
First programming langauge for me, I hope to get a job with it
Can you explain what kind of resources the web app is using that makes it viable to use c++?
Thank you very much. I'm really glad when people take it not only as an ECS lib to use but also as a C++ lib to look into.
What would be bad with rewriting the history in this case? I have never used the git blame -w or hyper-blame, but I feel like doing the formatting in one commit would lead to a lot of people thinking that that person that did that commit will be responsible for basically all the code. A team I worked with got emails all the time about code that it looked that they had made, but they really only did the move from svn to git.
Good point that of adding a direct link into the README. Shame on me for not having it yet. Thanks.
Compiling can be offloaded to a build cluster with icecc, linking can take a while on its own, especially for debug builds. I've seen executables upwards of 300MB, which my poor computer takes a few minutes to regurgitate.
beacause web developers can't get strongly typed languages
When you do that kind of commit, don't use your "normal git account" (ie, change your username/mail in your .gitconfig) to not have this issue, or use sudo to switch to a robotic account if you have one). The issue with rebasing shared history is that everyone has to rebase. It's a big "stop the world". It will also break any external tool like ticket system that may have references to git commit hash (all hashes will have changed).
Its basically mixing and processing video and audio feeds based on parameters modified by the user in real time. So, you have a GUI with several audio feeds plus a few video feeds being mixed together and played back while the user scrubs around and applies DSP algorithms and tweaks the settings of those algorithms during playback. The C++ code is constructing the video and audio in realtime by taking all the source material and applying the requested transformations while streaming it to the client.
Are you using ccache or anything fancy like that, or just straight up cmake + make.
I feel that it's worthwhile to mention that auto-use doesn't obviate the need to pay attention to type categories, particularly in the use of range-for constructs. For all the details I can do no better than to refer to Arthur's blog [https://quuxplusone.github.io/blog/2018/12/15/autorefref-always-works/](https://quuxplusone.github.io/blog/2018/12/15/autorefref-always-works/) , and before that, Scott Meyer's CppCon 2014 keynote "Type Deduction, and why you care" - [https://youtu.be/wQxj20X-tIU](https://youtu.be/wQxj20X-tIU) &amp;#x200B; In closing I'll state my opinion that using auto without a full type specification visible in the line imposes an unacceptable cognitive burden on anyone reading the code. This is C++, we always care about types.
Considering I very rarely compile it, every time.
Modules would make my code much cleaner, but I am afraid that it will be at least a year until support for them is stable enough. I did put my project on hiatus waiting for Concepts to be implemented in Clang though. They are a true game changer and they kind of fix most of the practical issues I had with C++.
Just CMake + Ninja.
I was responding to the comment from /u/bugrit that lists slow compilation times as the first bullet point since the OP question was about using C++ for web apps which would require compilation.
Yet both Google Webmaster and Amazon Seller Central can’t handle a spreadsheet/JSON payload over 50MB
My bad, I thought it was a discussion on speed of development regardless of whether it is compiled or not.
I'd refer to it as type deduction, rather than type inference. Notably references, pointers, etc may not act as expected under what I'd call type inference rules.
I personally think the tide is slowly going that way. Besides being often discussed at major talks/events. I've recently been on two training courses related to Advanced and Modern C++ coding. Both not only strongly pushed for it, but the entire 5 day training course (both) had all their slides, discussions, exercises designed with auto everywhere. &amp;nbsp; Besides what /u/kalmoc and /u/eniacsparc2xyz said here, the idea can go a lot farther. It's usually described as "Auto to Stick" or "Left to Right" reading. As in, pretty much every single bit of code can flow in a left to right reading format thanks to auto. Besides variable initialisation being left to right, you also have; * **range loops** for (auto item : list) * **STL functions are easier to use** auto myWidget = std::make_unique&lt;Widget&gt;(42); auto found = std::find(myContainer); * **using keyword** using Length = decltype(strContainer.size()); * **lambdas** auto myLambda = [&amp;context](type argument){ ... }; * **user defined literals** using namespace Distance::Unit; auto commuteDistance = 63.0_km; * **Even classes can be designed this way** class Widget { public: auto getValue(int index) -&gt; Value; auto getValueWithString(int index) -&gt; std::pair&lt;Value, std::string&gt;; auto print() -&gt; std::string&gt;; private: std::vector&lt;Value&gt; v = { 1, 2, 3, 4, 5} } I really want to code like this in my job but I doubt i'll be changing my bosses mind anytime soon.
Try reading someone else's complex code base with AAA and let me know if you like it. Personally I find it very difficult to parse through.
Why use C++ instead of [x]? Well, i use PHP and it is not pretty fast to code with it, is something better than C++ because it doesnt has to deal with build systems and the other overhead that C++ ecosystem has but it is far from perfect or quick Todays webpages are more and more complex in both sides, front and back which draws more resources, the front "who cares" as it is the client who will waste them (I do but it is a form of telling that it is not that big deal) but the back are important as i am who will pay for that. With PHP i could but it will be a nightmare a cache for the database, in C++ it can be done, i can create an allocator and leave the data in a form of cache, keeping an eye on updates on that data. It could be a huge improvement, instant search, we can put fancy gifs when we use the search to "mitigate" the time but it takes seconds, a few caches with the most common searches will not take that much RAM and will decrease to almost 0 the waiting time Or maybe in C++ check the resolution of the client and instead of provinding it whith the whole CSS files with all the media that it has only provide the one needed and instead of making it a separate file that will use one of the 10 concurrent connections the browser will has with you put it in the html itself, the same with the JS, that way you can start reducing connections and reduce the loading time of the page, something that in PHP i will not do for any reason, in C++ you can have the debug/developer mode in which the files are separated as tehy are in the file system for you and the "release" mode in which they are compacted, offuscated and integrated I dont think it will increase that much the development cost while boosting the performance and letting you many more options, for example doesnt having to has the PHP interpreter installed meaning more free resources or huge/complex databases, SQLite as said in their doc can work well in mediun pages like this one. I konw it is not for everybody, not as least in the CMS world we live today with WP, Joomla and Drupal but it can has it share too. I want to try something new and maybe better, it could be fun
_shrug_ - it’s been useful to me as a substitute for google ‘s (closed source) in-memory tracing library. Haven’t got numbers to hand but time stamped event recording is ~50-100ns. The locking is only used when grabbing a hunk of event storage then a thread runs out of its allocation so not generally contended. I’d certainly be interested in other open source alternatives.
There is no elision. There is nothing to elide since C++17.
Don't at all worry about time. Worry about learning and practicing new things. There is plenty of time, just work and before you know it you'll have it.
Thats for the boost &lt;3
Why would you use this instead, say, simple overloading?
Haha, that's actually really cool that you can never know everything
I can do a full build on our (6+ MLoC) codebase in about 2-3 minutes, 45s of which is linking the final executable. But that is because we have a distributed build system with
You're right to focus on iteration speed. That's the main reason web developers might care about compilation times. If a language compiles slowly but you can sidestep compilation with an interpreter while you're developing, then the compilation speed doesn't really matter. For a language like c++ where there is no viable alternative to compilation that takes minutes, cognitive flow is unavoidably disrupted.
I certainly wouldn't suggest writing anything in php. There are plenty of other choices ranging from Python to Go, and any one of them is strictly superior to C++ for this type of application.
lack of skill != problem of a language
I was similar to you in that I started my adventure in learning C++ at age 14 when I convinced my parents to buy me Visual C++ 1.0. Back then dev software used to come with a lot of printed books and manuals. I got my first job programming C++ for during summers and weekends when I was 17, so about 3 years later. &amp;#x200B; I suspect that this could be significantly faster now given that there is a lot more material, videos, websites, forums about C++ now than they were there.
This is true! But when you bring it up to their specialists you get some copy/pasted bullshit about limitations with the “stack”. Gee, thanks Amazon for all your help.
It is. There are. Some of them are good, some bad, they’re mostly quite pleasant to use.
It feels good that there was someone in my shoes, what is the current best way to learn in your opinion? What kind of programming did you used to do and how much did you earn?
What I am reminded of by this is a comment from Linus about Git, which (paraphrased and probably hugely mangled) is that speed can change the way you do things; it's not about doing the same things faster, it's about adding new ways of working that would be prohibitively expensive with other tools. Where I think this shows up in *this* discussion is in the context of TDD. If you watch Gary Bernhardt's Destroy All Software screencasts for example, in many of them he is using a deeply TDD workflow. If you have something that takes a minute or two compile, you just *can't work that way*; it takes too long. Some of his screencasts would probably be ten times longer if he had to wait a minute for every compilation. (His are usually in Ruby, so there's no compilation step, but here I mean each time he switches over to and runs the tests.) Now that's obviously an extreme example -- his screencasts are well-rehearsed and a slick, planned demo of what he is trying to illustrate; there's no pausing for 30 minutes trying to think through something or anything like that. And maybe you don't even *want* to go that far. But I think the overall idea holds -- you just *can't work that way* in C++ if you start using anything at all that stresses the compiler.
The popularity of TypeScript would counter that assertion.
Java is replacing C++, the JVM is close to the same speed these days. Even in HFT, many C++ algos are being re-written in Java
&gt; Highly complex language that few people know well I would highlight this as a strongest reason.
The word “inference” puts Hindley-Milner in mind which is not required for C++ at all — there is no finding the best type given a set of constraints, `auto` is just a placeholder for the unambiguously determined type of the initialiser expression.
.NET Web Developers would beg to differ.
I'm really looking forward for modules. I do not possess enough C++ knowledge to point out what's wrong with the proposals, but as far as I've read, I'm afraid and disappointed... because I think it would be great (if done right).
Yeah, I heard that since 2k. There's another one: Cobol and Mainframes are dying.
Wait I thought since C++17, RVO is mandatory. NRVO I know is permitted but not always possible.
Godot needs to be added: [https://godotengine.org/](https://godotengine.org/) Even thus it's not pure C++ - mostly GDScript, but it's possible to cherry pick UI parts from it as well.
Microsoft, with all their ecosystem power, can't force people to move from C++ to C# - which is a language that manages to avoid the major performance pitfalls of Java.
Tradeoffs. Python(as the slowest reasonable alternative) is something like 30-100x slower. But development is almost 30-100x faster. That seems terrible for speed, but with machines blazing fast, even 100x times slower might still be in the blink of an eye fast. Scaling done right is not that hard, so adding many machines to a large number of hits is potentially still cheaper and effectively as fast. The faster dev time means getting the feature to market earlier and unless you have a worthless website, faster is almost always better. Next you have services like AWS which aren't typically all that friendly to C++. Then there are ways to speed up even slow python. Also, you can go with good ole web backends like PHP or nodejs which are plenty fast. Next is what is the bottleneck? Often it is the data back end. This is where yards of optimization that are more architectural make a huge difference such as proper caching. Then you have other bottlenecks like a poor choice of front end framework where you turned on every plugin ever written and it doesn't matter if you have a hand-calculator for a back end the front end is the pain point. That all said, where C++ can rock is that you don't just do what you would normally do but faster, you do things that no other language can do fast enough. You might have a query that any DB would take 10 seconds to process and any other language with an in memory structure would be no faster. Maybe this can be done in C++ in under 1 second and thus make a whole new feature doable that is otherwise going to have to not be included. Then, there is as many other people pointed out, those cases where you have so much traffic that using C++ as an optimization is worth the time and effort. If it costs you $100k to port some PHP to C++ but it saves you $200k per year in servers, that is potentially a no-brainer; just as long as the same developer working away in PHP(or whatever) couldn't create $300k in new features.
Write good C not trash C++
You can still not use auto for data members of a class.
Right... RVO is mandatory. NRVO is sometimes not possible. Though I think there's a paper for C++20 that will allow for more copy elisions to happen.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bpextb/where_to_define_counters_gauges_and_other_metrics/entciuc/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yeah, in general we went that route as we already had a solution for memory allocation available for free, otherwise we wouldn't likely have invested time in it unless profiling showed us possibilities to improve. The most interesting problems we faced were with "how to make an API that avoided data races", stuff like dynamically querying and modifying the ECS state (and container) is possible, but you have to explicitly shoot yourself in the foot to do it (keeping references to the state around and storing it in systems). Systems only get const access to the state regardless of single context execution or not. So in gross feature-set I think your solution leaves a lot more freedom to the end user on how to make the ECS flow, something we can't due to the scheduling of tasks. In general dynamic/immediate querying is a second class citizen for us, in contrast to lots of ECS's out there because of dealing with MT code. We expect people to mostly interact only through systems with the ECS state (so that the ECS can anticipate and pre-fill your filtered operations, guard the appropriate memory regions, and hopefully share it with other systems for free as a form of batching), or lock the ECS externally themselves so you wouldn't accidentally interact with the state as it is executing a tick. Nothing in the ECS knows about locking mechanisms like mutexes because that would just be costly for little gain. Internally we have a sorta "mini ecs" state that gets created per thread (with their own smaller caches), where modifications go to first, before being merged into the big state at the end of a tick. Lots of room for improvement there with relation to memory consumption, but it allows us to protect the user from situations where a system would get different data depending on the order of execution, or where systems would not get certain events due to chronology. The latter was very apparent when we let the ECS generate drawcalls, as we'd have ghost draw calls. The other part was "safety first", so every system is expected to be single context, no concurrency, unless you explicitly tell it otherwise. We'd rather have a performance drop, than a hard to track data race, as the end user might not even be fully capable of dealing with multithreading skill level wise. Basically a "you know better, you do better" approach to designing the API. There's some more complex heuristics calculations we do, to decide when to schedule what (to avoid gaps, or dead threads), but there's only pretty minimal effort in that part, and won't handle spikes. I'd be happy to discuss internals, and hear more about some of your design challenges! I saw a blog article of yours pass by my feed a while back and had it saved but hadn't checked it out yet. We're currently busy on revamping some of our stuff unrelated to the ECS (the ECS is a minor part really, and ended up being a happy good fit), and then hopefully gearing up for making the code public, so I'll drop you a ping then when that time finally comes, hopefully sooner rather than later.
Concepts are amazing
Seems like the consensus is: - they’re notably complicated to implement - this is because the proposal keeps the “how does a compiler find a module” purposefully generic - community is scared that there won’t be a convention behind how modules are found, similar to the buildsystem fragmentation in the c++ community - if there isn’t a convention, source code could become dependent on compiler brand - it’s a big departure from typical c++ structure. .h files would no longer be necessary for new code - they’re different from other languages in the sense that they provide no namespacing, only encapsulation I think this is fine. These are problems with solutions, it’s just that none of this is easy.
I'd love to see some data on the speed comparison between Java and c++. What benchmark are you referring to?
I develop on asp.net core with the built in webserver, Kestrel. It's extremely easy to develop on, and very fast in production. Since Kestrel is also production ready, I have CI builds that create a docker containers of the app on git tag, then deploy it to production. Deployment takes no time at all and is relatively painless. Plus most actual frontend work in asp.net core just requires refreshing the page. I'm not familiar with the java ecosystem, but it's very easy on .net. And if you go to interpreted languages like php, you literally just refresh the page.
I run asp.net core, but if my only options were php or JS, I'd be very tempted to at least take a serious look at CppCMS or something like it.
Full Unreal 4 engine build takes well over an hour (probably more like 2-3 actually) on my 6 core CPU at work.. and it is a very widely used framework for game dev. Also absolutely massive, but big things take massive code.
Ok I assumed it had something to do with DSP and some kind of audio, that’s awesome !
I'm using qmake, should I invest time into switching? CMake seems very daunting with its huge pile of required files and arcane makefile output. ( I use GNU Make for non-QT projects)
Well just as /u/mathstuf was telling me, first build from scratch would be slower than h/cpp combo since it would need to do that pre-parse step. He thinks incremental builds would be faster though thanks to tree-pruning being more available (?). If that is the case I would definitely take that deal.
Haven't seen this mentioned yet but there is a reasonable amount of web development using Microsoft ASP.NET which can be coded using a variety of languages including MS C++.
Thank you very much. It seems you know quite a lot on this topic and your in-depth description of the challenges you faced is really interesting. I've a completely different idea in mind to solve the problems with mt and automatic scheduling (tbh I took the inspiration from an open source project of a friend of mine and tried to gear it to fits the model of EnTT). Your answer helped me to put it at a test in a sense. &gt; I'd be happy to discuss internals, and hear more about some of your design challenges! On GitHub you can find my contacts. Feel free to contact me. I'd be happy as well. As I said, I think both the projects could benefit from such a discussion, so why not? ;-) I'd be also glad if you decided to ping me when something goes public. As you can imagine, I'm keen on this field.
Some C++ projects have some amount of central deps. You touched the cursed header? Boom: full build.
&gt; How many projects are so big/complicated that a compile takes more than a minute or two? Full release build of the (game) engine code I work with is more than enough time to get coffee from a machine which grinds actual beans. Though it's the first time in my life I got back at my desk and it was still compiling. That might not actually be C++'s fault, though, and have something to do with the codebase.
It's kind-of weird once you get amongst C++ programmers how badly they know *other* languages. Its super isolationist.
Can I add, ‘We’re only five years away from true AI.’?
Hope after VS2019 Q2 can make it work well.
For example?
LOL, one place I worked at had to get the toolchain vendor involved because the executable reached 4GB at which point the linker threw its hands up and said "I quit."
- Introduction to C++ - The C++ Programming Language 4th Edition - Effective C++ - Effective Modern C++
It looks like a bug to me. According to the standard (N4659 AKA C++17 final draft) &gt; 8.3.1.7 The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the result is the value of the argument. Integral promotion is performed on integral or enumeration operands. The type of the result is the type of the promoted operand. Integral promotion shouldn't add any qualifiers to the type (and `int` shouldn't be promoted anyway).
I've been AAA for a couple of years now and I really like it. I like that I don't have to repeat myself when declaring variables, that it prevents from inadvertently converting a function return to another type, and usually makes refactoring easier. I don't think the code is more difficult to read. On the contrary, it helps me focus more on what the code does, especially during code reviews. I have yet to find real-world bugs related to auto whereas I encountered quite a few related to un-expected type conversion (e.g float to int).
Looking forward to what you come up with, I'm really interested in seeing this approach you have in mind. And yeah by no means is our approach the best, and you should definitely implement something that fits your style, use case, and API best. So far you've done really well, so no sense in changing that :D &gt; I'd be also glad if you decided to ping me when something goes public. Will definitely do that!
ccache is pretty good tool to reduce the compile times. I work with decently sized Linux/CMake C++ project, it slashed our build time by over 80% in most cases.
\[java vs c++\]([https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/java-gpp.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/java-gpp.html)). Really you should just do benchmarks for yourself in the domain specific you are going with and pick like that, general benchmarks just give a guide.
The operand is a `const int` though, so is this behaviour not correct?
I would not write a class with auto like that. People get used to the way things are, and besides that putting auto there makes it more verbose.
This removes the difference between implicit and explicit conversion. &amp;#x200B; ie I don't know what \`foo()\` returns today, but if it is some day changed to return \`HeavyString\` which happens to have a conversion to \`std::string\`, this code still works. Yay!(?) &amp;#x200B; Unfortunately, it turns out HeavyString's conversion is slow. So we made it explicit! So you need to ask for the conversion explicitly. Oh, wait, you already were. Just not \_intentionally\_. &amp;#x200B; If this doesn't bother people, maybe we should just remove the \`explicit\` keyword from C++?
Public consensus on modern C++ mostly consists of a bunch of hobbyists/parrots, not people actually using this stuff for industrial work. It will take years for all the pitfalls and pain points of new language features to be fully known by a majority of C++ programmers.
Are JVM implementations written in Java too?
For C interop, presumably. C doesn't have overloading, so this is the closest it gets.
Best C++ tutorial, free! https://rust-lang.org
It is there under the old name (C++ Format).
I've used other languages in the past, but I'm happy with C++ for most things. I'm working on a C++ code generator though so I may be biased.
There is work on getting the compilers to provide exact dependency information about modules (and headers while we're at it). The four major implementations have said the plan is workable. The strategy is documented in &lt;https://mathstuf.fedorapeople.org/fortran-modules/fortran-modules.html&gt;. The "scan" and "collate" steps are parallelism bottlenecks in the initial build. But (given a good enough compiler implementation), can also prove that recompilation is not necessary (e.g., theoretically, the BMI wouldn't change for comment updates, but the header consumption method sees "something changed, let's recompile").
It's much more complex. There are no streams, regex and other stuff for `char8_t`. You can't even `std::cout` UTF-8 text. So migrating to `char8_t` is a huge problem. Thankfully, I already wrote some Unicode code that is fully templated so low level storage is mostly done (still no grapheme cluster layer). I'm finishing storage code so then I can work on "Unicode Character Database" parser because this is required for grapheme clusters, streams, regex and other stuff. Then a lot of other stuff. But proper Unicode is so worth it.
&gt;java is close to as performent guys look! lmao no
Well, Facebook does use C++ as a scripting language, although I'm really curious, how well that works in practice.
I’ve written async web clients and servers in beast + coroutines. It’s actually pretty easy once you get used to the required coding style.
The more I think about it, the more it seems to me that a language advocate might find this behavior correct :-) I.e. at the beginning of the chapter 8 there is this paragraph: &gt; If a prvalue initially has the type “cv T”, where T is a cv-unqualified non-class, non-array type, the type of the expression is adjusted to T prior to any further analysis. But I couldn't find anything that would prohibit "+n" from being treated as an lvalue. And technically it can be an lvalue, since the unary plus can just "return" the original entity back (and the original entity is an lvalue in this case).
I would argue that those are something very different even from a semantic standpoint in that they define the layout of the class instead of creating a new variable. I interpret that “always” as “whenever you create a variable that will, optimizations aside, result in actual code being generated”.
Eh, it can be easily worked around with a bit more code churn (i.e. write the same AbsF/AbsD/... extern C functions, and just wrap them in C++ Abs overloads). Can be easily automated/hidden behind macro if you have specific suffixes. Seems rather small improvement over possible others.
I'm not following
Exactly, you can have a capable API with database connections up and running in Python or Node.js in less than 10 minutes with zero compile time, and the networking overheard is high enough that the difference in performance is practically nonexistent.
https://gcc.gnu.org/wiki/cxx-modules#Bugs Which I think means "Right now, please don't". An ICE right now is as likely to be due to a known unimplemented codepath as an actual bug.
It's a bug. `+n` is a prvalue of non-class, non-array type, so it can't be cv qualified. http://eel.is/c++draft/expr.prop#basic.lval-9
You can't do: std::unique_ptr&lt;T&gt; p; foo(p); You must do std::unique_ptr&lt;T&gt; p; foo(std::move(p)); You can do: void foo(std::unique_ptr&lt;T&gt; p); You can ALSO do (though, questionable) void foo(std::unique_ptr&lt;T&gt; &amp;&amp; p); void foo(std::unique_ptr&lt;T&gt; const&amp; p);
I primary develop web applications, and have virtually no experience in c++. Most of the actual workload for run of the mill web backends is delegated to software written in C++, C or Java (Redis, Postgres, Cassandra, Elasticsearch, etc...). The application code is usually business logic and delegation to said software. It's way easier and less error prone to write business logic in "programmer-friendly" languages (python, js, ruby) than it is in something like C++.
Every single product I worked in the last 15 years takes hours to compile from scratch, so yes it’s a very real problem for some of us.
Probably because you can be in C++ for 30 years and still not "know" everything
I'd say "easier" yes, "less error prone" hardly.
NP
Where did you hear that? I assure you no HFTs are switching to Java.
According to those, the closest Java comes is 10% slower, and the average seems to be well over 2x as long. That does not even compare the memory differences.
Happy Cake Day!
Go is a great example of that.
It was that way back in the early thousands, but when C++11 came out quantitative finance has slowly been migrating from Java to C++.
Having jumped from C to C++11, I never really learned/used `new.` The only time I have used it, I needed placement new to solve a memory alignment problem. I would hope the jump does not exclude me from jobs. &amp;#x200B; ;)
Have they presented on their methods? Hopefully they can make it work well and release it in an accessible form that many c++ users can utilize. There are so many advantage to reducing cycle time and any developer in any ecosystem stands to benefit from access to that kind of workflow.
Microsoft also tried to rewrite large parts of Windows and a whole new browser entirely in managed code. Both we're scrapped after 10s of millions of dollars written off.
Some people think 2x is close.
For builtin unary +, `+n` is always a prvalue. This is mandated by N4810 7.6.2.1 [expr.unary.op]/2: "The result of each of the following unary operators is a prvalue." /7: "The operand of the unary + operator..." (Operator overloading is pretty syntax for a function call; there's separate Standardese saying that the builtin rules don't automatically apply to overloaded operators.)
I up voted you for the sarcasm :)
I'm the maintainer of this list. I originally started it is a resource for my employees. It's far from perfect and it turned out to be harder than I thought to only provide links to only high quality resources. What I want to do is spread information about the really high quality projects like boost, Catch, nlohmann::json, Cereal, etc. So that there was a single resource for people that are not "plugged into" the community to find useful resources to get their job done. Maybe I should really prune these links a significantly?
sounds like a hack instead of using templates, and everyone knows the downsides of using templates.
&gt; But I couldn't find anything that would prohibit "+n" from being treated as an lvalue expr.unary.op/2 says that the result of all the unary operators except `*` is a prvalue.
Yeah, I agree, removed it. I want this resource to be a go to place to find libraries and resource when *std::* and *boost::* have been exhausted.
It was there under the old name. I updated the name and link.
&gt; (Btw try searching “format string” instead of “template string”) This was a big difference. I found Foley, which appears to be the same syntax of python `str.format` format("Only 2 decimals is {:.2f}" I did not realize they also share &gt; adjacent string literals are concatenated by the compiler z const char *text = "This text is pretty long, but will be " "concatenated into just a single string. " "The disadvantage is that you have to quote " "each part, and newlines must be literal as " "usual."; That looks so much cleaner than a heredoc const char * vogon_poem = R"V0G0N( O freddled gruntbuggly thy micturations are to me As plured gabbleblochits on a lurgid bee. Groop, I implore thee my foonting turlingdromes. And hooptiously drangle me with crinkly bindlewurdles, Or I will rend thee in the gobberwarts with my blurlecruncheon, see if I don't. (by Prostetnic Vogon Jeltz; see p. 56/57) )V0G0N"; alternatively const char *longString = R""""( This is a very long string )"""";
What you call the “mini ECS” sounds similar to what I built for flecs to allow for MT: https://github.com/SanderMertens/flecs/blob/master/Manual.md#staging
 **Company:** [Aptiv, fka nuTonomy](https://www.aptiv.com) **Type:** Full time **Description:** Our real-world mobility solutions are driving us toward a safer, greener and better connected future. Aptiv is providing the “brain” and “nervous system” for vehicles that will change the face of mobility for people worldwide. Aptiv’s Autonomous Mobility team is focused on developing, and commercializing autonomous vehicles and systems that enable point-to-point mobility via large fleets of autonomous vehicles in challenging urban driving environments. With talented teams working across the globe, from Boston to Singapore, Aptiv was the first company to deploy a commercial, point-to-point autonomous ride-hailing service based in Las Vegas, Nevada. Work with leading engineers, research scientists, marketers and business development experts, all while enabling the future of mobility. At Aptiv, we believe that our mobility solutions have the power to change the world. For more information, please visit [www.aptiv.com/our-journey](http://www.aptiv.com/our-journey) and see our [www.aptiv.com/careers](http://www.aptiv.com/careers) for opportunities. Our C++ engineers would potentially be working in several different teams; either pure software, or hybrid software + researcher teams. Depending on the team, you would be building software applications, or contributing to design/architecture, and even refactoring our old code, and just generally working towards the future of transportation. **Location:** Singapore **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We use C++11 on Linux mainly, and currently evaluating C++14. Any additional experience in any of the following will be beneficial: * GPU Programming/CUDA/OpenGL/Graphic engines etc * Robotics/motion control software * Radar/Camera related software/libraries * Interest/background in building web applications/APIs **Contact:** If interested, you may email CV/questions to [eugene@nutonomy.com](mailto:eugene@nutonomy.com), or apply via [https://www.nutonomy.com/careers/](https://www.nutonomy.com/careers/) or [https://www.aptiv.com/careers](https://www.aptiv.com/careers)
It normally is related to the codebase.
As someone who works on clang for a living... That's not true
Depends on the industry. In games, I'm working in Windows using Windows-only tools most of the day. I don't want to switch my whole OS and dev environment just to test/fix the occasional CI failure from a central library change used by the server build. When I was a server lead, I made sure the server ran on Windows so the whole team (especially gameplay engineers) could easily work on both client and server components simultaneously, and would have appreciated WSL and VS support for addressing the occasional CI failure.
Is there any mature/open source/web framework in cpp today?
Knock knock.
&gt;in the early thousands oh yeah, the good ol' times when the crusaders used JSP for their website.
Hey, here's an experiment that this guy did between C++ and Java. It's really interesting but even more interesting is that in the beginning C++ was easily winning, but as he developed and optimized the code (for both C++ and Java) Java started to pull ahead. In the final test Java BLOWS C++ away!!! He doesn't understand why, but he never revisited it like he said he might. I've looked over the C++ code as well and I don't really see any obvious performance problems. Here's the final test data: |Steps|Seconds per set|Total runtime, Seconds| | |Java|C++ |Java|C++ | |:----|:--------------|:---------------------| |10,000|0.75|0.77|0.75|0.77| |20,000|1.6|2.7|2.3|3.5| |30,000|2.7|4.9|5.0|8.4| |500,000|125|317|2,206|6,301| |1,000,000|324|980|13,577|37,160| |1,500,000|553|1670|35,203|101,968| |2,000,000|834|2,436|70,420|187,174| I've ran both the Java and C++ code and it works just like he says, so the data is very accurate. The Java code in the final test is WAY faster than the C++ version. Here is the article: http://pzemtsov.github.io/2016/03/21/home-made-hash-tables-in-cpp-a-race-against-java.html Here is the C++ code: https://github.com/pzemtsov/article-life/tree/cpp6 Here is the Java code: https://github.com/pzemtsov/article-life/tree/master
Meanwhile C++ advanced too
I'll might be unpopular, but here my 2 cents: - Lack of real tools (something like 'rake' from Ruby or something that generates classes from a DB model) - Lack of real web rapid application development frameworks (such as Laravel for PHP, Spring for Java) - Lack of dependency management (yeah, Conan.io is catching up, but it is still not common) - Lack of community support in this (e.g. integration with nginx, how to setup a dev environment, etc.) - Finally, slow development. Sure, the solution *at the end* will be faster than everything else, but the development time increases incredibly
Who's.. there?
4GB!!!! WHAT THE FUCK???? Or in the words of Doc Brown from Back to the Future, " FOUR POINT ZERO JIGABYTES???!!!" &amp;#x200B; Seriously, what the heck do you do to make an executable that big? Embed a AAA game's worth of graphics, models, and music in the executable??
[InterSpec](https://github.com/sandialabs/interspec) is a web application that uses Wt since it needs to do lots of nuclear decay calculations, plenty of other numerical stuff, and large file parsing, while the user interacts with the GUI.
More than C?
There are no graphics or even data in the executable, it is all code. It's a weird architecture that dates back to the early 80's, but the gist is basically _everything_ is linked into the same executable. FWIW, this software makes billions and billions of dollars a year.
Man, I'm just really interested in this now. Any more details you could share? I can't even imagine 4GB of code.
 http://reddit.com/r/cpp/comments/bp8rra/awesome_modern_c_resources/ In a recent cpp post this repo came up as a collection of modern cpp resources. There are some blogs mentioned, you might want to check out.
Hi, once every week on bfilipek.com there is nice set of most interesting links from the past week. On meetingcpp.com there is also blogroll with many links.
Well how's this for a detail. Needless to say the dependency graph was not a DAG. And there are alot of dependencies. The actual, official production build process is as follows: Try to link. Collect the undefined symbols and insert dummy implementations (`{abort();}`) for all of them. Try to link again. Repeat this process until the link succeeds (typically took about 5 loops back when I worked there.)
I developed some basic web applications using c++ back in the day. Manually checking http headers, crafting responses, dealing with sockets, etc. It's not pretty, but teaches you a lot about the guts of what you're working with.
I wouldn't blame managed code for failure of Edge. Both EdgeHTML and Chakra were written in C++.
So you are talking about the code for the linker for this 4GB program? Did they have to custom make a linker just for that program? Thanks for the offer, but I doubt that I would really be qualified for a job like that. I have no degree, nor any college level education (unless you count my 1 year class of AP Computer Science in high school). I'm pretty much completely self taught.
No, just a shell script that runs the normal linker in a loop. FWIW I am a high school dropout with no college whatsoever. This place hired me as a senior engineer when I was in my early 20's. It's all about what you know.
Thanks. What was the old name?
Yes, when done correctly. C++ has a lot of zero-overhead abstractions that can help. {{constexpr}} is another place where C++ has faster runtime than C -- it can calculate many more things at compile-time.
... garbage collector
Haha, yeah. Always good to be clear.
There is a very simple reason C++ is not used for web applications: C++ is an unsafe language that does not work well when code has to be changed often and my multiple people that come and go. C++'s manual memory management, especially, makes it difficult to rapidly respond to requirement/team changes. The memory usage patterns must be known 100% by all participant programmers, otherwise the probability of a change that creates memory problems is quite high. Web applications, due to their performance/API limitations, are more attractive to commercial businesses, in which environments requirements change often and team members come and go. And therefore, these businesses choose software that require the least effort to change the software/team, and that meant "not C++". Nowadays things are better in the C++ land when it comes to memory management, but there is still a ton of C++ libraries out there that do not use shared_ptr/unique_ptr. And therefore, C++ is still not the language of choice for web development.
That is not what I'm seeing.
You disable the GC on the JVM that is a non-issue I can guarantee you that a lot of firms in Chicago and NYC moved their C++ code to Java with no delay in their executions.
Yup, they are !!! Recently they are writing the JVM in Java and Java code can be compiled directly to machine code so that a virtual machine is not needed.
I looked one up for you, pretty early in they talk about C++ vs Java https://www.youtube.com/watch?v=BD9cRbxWQx8
But the only reason is that they have so much old C++ code. That is the only reason.
The result is a new object, distinct from `n`, so it ends up not being particularly useful to artifically limit this new object to be `const`. It's similar to how `i` in `auto i = n;` is also `int` because `i` and `n` are distinct variables, with `i` being copied from `n`.
https://www.youtube.com/watch?v=BD9cRbxWQx8 Might be an opening watch for you. I only speak from my personal experience in Chicago and NYC in the business and I see algos being rewritten from C++ to Java.
But hey, I got 70 downvotes by stating what I see in the industry today. https://www.youtube.com/watch?v=BD9cRbxWQx8
You disable it. https://www.youtube.com/watch?v=BD9cRbxWQx8
You could follow [https://isocpp.org](https://isocpp.org) . As well are all articles from ACCU's magazine Overload [https://accu.org/index.php/journals/](https://accu.org/index.php/journals/) are online available as well. Many of them have high quality C++ articles. The other ACCU's magazine, cVU is online as well, but its access is restricted to ACCU members. You may take a subscription into account. Beside these two magazines in print, you get a discount on the yearly ACCU conference. &amp;#x200B; Disclaimer: I am on the ACCU board and the deputy conference chair.
Quantitive Finance where the speed really matters is moving away to FPGA that is 10x faster than C++ and all the rest is moving to Java.
The link to the cpp-code gives me a 404
Insert penis joke here.
I've only seen this: [https://www.phoronix.com/scan.php?page=news_item&amp;px=Facebook-JIT-Cpp-Scripting](https://www.phoronix.com/scan.php?page=news_item&amp;px=Facebook-JIT-Cpp-Scripting), but I haven't found a video of the talk yet.
[Here](https://github.com/skypjack/uvw/commit/34042167eb7331f88a943e0797bfcc14ae403d92) it is. :-)
Why is no http/2 support understandable? Not familiar with it that much, but as far as I understand it's a binary http.
It's quite complex compared to HTTP1/1 and not all that common yet
AAA makes the coder's life easier for a ahort period of time. It doesn't help them when they have to revisit the code months or years down the line, and it doesn't help anybody else who has to review or maintain that code
&gt; I'm using qmake, should I invest time into switching? yes &gt; CMake seems very daunting with its huge pile of required files the only required file when you use CMake is CMakeLists.txt - maybe you're thinking of autotools with configure.ac, Makefile.am, etc etc ? (If you saw repo with multiple CMake files it's because people chose to organize their CMake code that way). &gt; and arcane makefile output. it is, indeed, because it is not made for human consumption - though you should use Ninja anyways instead of Makefiles for CMake I would say.
This reminds me of emplace_back and smart pointers... vector&lt;unique_ptr&lt;Foo&gt;&gt; v; v.push_back(new Foo); // compiler error, unique_ptr ctor is explicit v.emplace_back_back(new Foo); // perfectly fine, don't mind the potential memory leak
auto is okay in the following cases: 1) When you can't write the type, i.e. when you create a lambda variable 2) When writing the type is hard and gives you very little value, i.e. iterators and dependent variables inside templates. 3) If not using auto would force you to write the type multiple times in the same line, e.g. If you initialize the variable with the result from make_unique.
As someone who worked on a large scale website, the language used by the web app itself isn't necessarily all that important, since most of the time spent on a given request is going to be various forms of IO. Even reading from memory cache takes longer than generating HTML based on the data it gets, reading from the database takes many miliseconds, generating 1MB of HTML is a fraction of that. The focus in turn is on which language is common enough that many people can work on it, and how fast can new features be written.
Did it involve _forging_ a solution that is _blazing_ fast?
You are correct here of course, but this is somewhat akin to saying that it is amazing how much easier a children's book is to understand when compared with the works of James Joyce. If you limit yourself to 3000 words then technically you can express any idea that can be expressed, it will just take a lot more text to do it than if you use an adult vocabulary. The same thing is true of programming languages. If the language is small it is easy to understand line by line for a novice but requires more lines of code to do anything meaningful. C++ is not a language for novices.
This list of advantages (which is valid enough) unfortunately misses the point of the posters question. The question is about the use of language constructs not tool chains or difficulty in skill acquisition (in fact the poster's question presuppose competence in C++).
C++20 is getting the formatting part of fmt, no idea about any post-C++20 plans.
I've looked into it and it seems as there are a few things that should boost the performance a little: - he is overriding the equals operator unnecessarily. When working with a POD-Type you shouldn't do this, because every stl-algorithm (e.g. the look-up in std::set he is using) has an optimization for POD-Types which doesn't work when the == operator is overloaded. (memcmp instead of component-wise comparison) - he is using a lot of virtual methods. On each tick he is calling step which is virtual, and inside step he is calling another virtual method. Each function call now has to do a lookup in a v-table which is unnecessarily at this point. - he is doing a lot of copys of Point. On each step he is copying every Point there is three times. You could argue that it shouldn't make a difference because on 64bit sizeof(Point) == sizeof(Point*) but it still came to my eye...
\&gt; A lifetime. I think more.
This sounds like something between implicit RTTI and full dynamic typing. It has noticeable overhead, which templates (being compile-time) don't. We have RTTI already, but you have to opt-in to that overhead in an obvious and somewhat explicit way. I don't think making that overhead less obvious is an improvement.
As someone who's never used fmt, what else does it offer besides formatting?
No idea what this means, sorry.
From scratch around 20-25 minutes. Incremental depending on the module around 20-30 seconds.
[https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c](https://www.grimm-jaud.de/index.php/der-einstieg-in-modernes-c) (It has english translation)
IIRC: writing to IO (in the c++20 version you'll get a string that you then can send to std::cout), colors, more extension points ([http://cppcast.com/2019/04/victor-zverovich/](http://cppcast.com/2019/04/victor-zverovich/))
Is it already merged? I'm asking, because at the end of the last meeting there where so many proposals that are supposed to be merged at the next standards meeting (which IIRC will be the final opportunity) that I'm being a bit skeptical if all of them are going to actually make it.
Sorry for overlooking it.
Ah I remember your great looking dashboard when we were investigating other solutions out there before we decided to roll our own. Quite envious of how it looks. So, reading your link, the mini-ecs container looks like it is a form of your staging approach. Modifications are inlined as well, but new/removed components/entities are "announced" later and those changes are not visible until the tick is over when the state registry moves them into the visible range for operations, and sets their IDs correctly. As a side effect of this delayed form, deletion of components get one "victory lap", where every system (if they listen to `on_remove&lt;T&gt;` and `on_break&lt;Ts..&gt;` operations), are able to deal with the component getting destroyed while still having access to the data. Normal listeners won't get the component anymore though, so to them the deletion happens immediately the next turn as expected. In general we're very happy with how this all flows, and how it has worked in practice. Minimal maintenance and effort required, with a tiny glue layer. We have some redundant memory waste when dealing with the internal cache they each get, but as we haven't run into OOM problems, this hasn't been high on the priority list to deal with.
Its a bit over what I understand tbh, but something like this could be useful? constexpr switch(is_same&lt;T&gt;::value){ //compile time, type based switch case int:{..break;} case float:{..break;} default:{return &lt;null-type&gt;} } branches that would handle different kinds of types or a lack of type, differently. I already have something similar using constexpr if, but something more streamlined. Maybe compile time programming is too out there for most people. idk, I just like the idea of lambda objects, maybe they wouldnt bring anything new to the table
Also currently iterating over unordered associate containers probably gives room for improvement.
Wow, great update! Thanks a lot for the amazing library. I've been using it for two personal projects this last year and have been enjoying it a lot even though the ECS mindset is very different from what I'm used to so creating logic and making everything work require a different approach. That being said, I think this library is great, and I just recently started trying to use the \`reflect\` and \`resolve\` part of the library. I'm not entirely sure what to do with it yet, but I am hoping to automate some UI creation with it. Will update to the latest version and see what I can do with it! :D &amp;#x200B; \*Quick question:\* Would you now recommend using non-owning groups such as \`[reg.group](https://reg.group)(entt::get&lt;Position, Movement&gt;())\` over the traditional \`reg.view&lt;Position, Movement&gt;()\`?
You guys do know that io\_state\_savers are a thing right? [https://www.boost.org/doc/libs/1\_70\_0/libs/io/doc/ios\_state.html](https://www.boost.org/doc/libs/1_70_0/libs/io/doc/ios_state.html)
I would argue r/cpp is the best one. You get a lot of diverse information and good blogs are usually referenced and discussed here.
I'm glad you've used it. If your projects went public, not as code but eg on a store, feel free to open an issue and I can put them in the EnTT in action list if you like. Also, I invite you to join the gitter chat if you have any question on ECS and common patterns in general, there are a lot of smart guys there! Non-owning groups are faster than views in most cases, typically when the intersection between the two components contains half or less entities if compared to the number of elements in the two pools. However, keep in mind that views are already really, really fast in a lot of cases and you should probably profile to know if they are your bottleneck and should be replaced by a group. As a side note, owning groups (both partial- and full-owning ones) work directly in the owned pools and don't require extra data structures. Non-owning groups instead cannot do that for obvious reasons and rely on a dedicate sparse set under the hood. Therefore they tend to consume some memory to work properly (not that much, but still more than their counterparts). Again, probably it won't be a problem for you, but profiling is the way to go here. As a rule of thumb, I wouldn't care of such a difference until I've a problem of performance or so. My two cents.
oops, fixed it. Somehow I added an extra '6' at the end of the url.
are you open sourcing your project? Im interested.
Do you think these are big enough issues to cause such a massive performance difference? The C++ version is over twice as slow by 30,000 steps into the program.
Well honestly the nodejs backend we have at work to serve 2 pages makes much more time to compile than our whole platform in C++... so honestly...
only when i use C libraries. And i have to pass things like C style strings to functions and all that.
Sorry, it was my attempt to guess the company with some internal product names in that space.
you can also use meson.
Yes very true about the 0.2ms, although I do have to admit I enjoy the tuning sometimes. I'll pop by the Gitter some day with any concerns I have! Thanks for the extensive reply :D
Most other features don’t get in until they have complete external and prove implementations in the wild. For modules we have hopes and dreams and lots of words, but implementations are just getting started.
You're welcome. Users and feedback are what helped to make EnTT grow up, so you should never refrain yourself from contacting me! ;-)
I don't know, I'd have to profile it to give a valid answer to that question. My bet is more on that unnecessary copying of each point and the virtual methods.
So there is more than one place that could meet these descriptions? Dear God.
To quote the Kona trip report: &gt; The following features have been approved for C++20, either at this meeting or a prior meeting, but have not been added to C++20 yet because we're still completing the specification. Hopefully they'll be added at the July 2019 Cologne 🇩🇪 meeting, but we may not get to everything due to time constraints. In that list there was `std::format`.
Do you have any programming background in other languages? What types of jobs are talking about specifically? It's obviously going to take more time if you need to learn program logic/basic computer science simultaneously vs just learning the syntax and nuances if C++ (which are complicated in their own right). Similarly different types of jobs require different levels of proficiency at different aspects of the language.
An "object" always resides in a "region of memory" but an `int` expression result doesn't.
Exactly, and the &gt; but we may not get to everything due to time constraints. Part is why I'm a bit cautious. Personally I don't need fmt in the standard, because I can just use the library, but it would of course be a nice to have thng.
Fair enough. That's particularly relevant when it comes to a lack of materialization and can lead to confusion around those rules. I reworded the comment.
Lookup Sutter's Mill :)
Does compilation to WebAssembly/asm.js via Emscripten count? Cause that is used a lot, mainly by games. Basically all the web games made with major game engines(Unreal, Unity, Godot,.. ) use it for their web applications.
Slowly?
A minute is an eternity. With PHP or Rails you're there nearly instantly.
Fair enough. &gt; Personally I don't need fmt in the standard, because I can just use the library This is why I think C++ shouldn't standardize libraries like `&lt;regex&gt;`, `&lt;filesystem&gt;`, networking, audio, linear algebra, graphics... instead, focus on language features, fundamental library support for those new language features (coroutines are missing a piece in C++20), vocabulary types (`function_ref`) and a good package management tool that will make all other libraries that would otherwise be standardized available.
Jason Turner hosts magnificent Cpp weekly channel on YouTube - https://www.youtube.com/user/lefticus1 There's also cppcast.com Not really blogs, yet I can't stop suggesting them to everyone :)
Good stuff on Fluent C++
Well done, great project.
Go through /u/vormestrand's history and check the blogs they post here, that's basically the set of blogs that do well on this sub.
That’s fair. Although, the implementation has been being worked on for years.
Thanks for making it, i will try rigth now
You've got a [name collision](https://en.m.wikipedia.org/wiki/Dart_\(programming_language\))
LOL, yeah, unfortunately we found out about that after the name had already gotten significant traction internally. Nobody in our division uses the Dart language. I'm hoping that the repository name "libdart" will help distinguish it, but if it becomes a huge problem I suppose we could reconsider it.
Very interesting. I'd be interested in seeing how it performs against MessagePack - I found MessagePack to be faster than Flexbuffers.
Ahh, that makes more sense. Specifically about c++: Does keeping debug and object files help in any way? I thought c++ had issues with having to recompile a lot compared to other languages that can cache compilation?
If I may make a suggestion: Eliminate the whole compiler detection and standard level settings stuff from your cmake file. Then, if the user wants to compile your project with c++17, all he/she has to do is to define \`CMAKE\_CXX\_STANDARD=17\` (by default it will automatically fall back to the latest supported version by the compiler) which works on all platforms including windows. There is really no reason for every library to reinvent the wheel on how to set the proper language version.
You might be able to take some ideas from a data structure I made that is always serialized. It is called tbl and combines a vector and hash map as well as allowing keys to contain sub tbls. This means that it was ends up able to be a tree as well. https://github.com/LiveAsynchronousVisualizedArchitecture/lava/blob/master/Libraries.md#tblhpp My experience has been that this single data structure can be used for lots of general scenarios as a basic data structure, file format, IPC tool and even communicating within a process.
&gt; Does keeping debug and object files help in any way? Of course, since the C++ way of building applications is that you compile each .cpp file into a corresponding object file, then all object files are linked together to create a .dll (or a .exe) file for use, so caching object files means that if I only modify one .cpp file (out of 100 for example), I would only have to recompile it into a new object file, then it will be linked with the old cached ones into the final product. &gt; I thought c++ had issues with having to recompile a lot compared to other languages that can cache compilation? I think the problem is this: if you modify one source (.cpp) file then you'd only have to recompile just that file, however if you modify one header (.h) file then you'd have to recompile every source files that include that modified header file.
I actually really wanted to add a MessagePack benchmark, the problem was that I was struggling to find a good "reference implementation." MessagePack is a standard, and there's many implementations of the library, so I wasn't sure if there was an "obvious choice" from a head-to-head benchmark perspective. Of the implementations that I tested, most produced a similar curve. Some started higher at low packet sizes, but everything I tested decayed similarly to Flexbuffers and sajson
I tried to use bgfx once. It was a total nightmare to get working. I never actually got it running.
Thanks for the write up! BGFX looks like a nice abstraction layer. But when I peeked into the examples "common" code, it seems to me that if you want to cross compile your project, you need to write a ton of boilerplate code for window creation, input handling, etc. Have you tried cross compiling your demo to for example emscripten or android?
That's really valuable feedback, I'll look into it, thanks! Yeah, I won't lie on this one, my knowledge of cmake has mostly been cobbled together from StackOverflow articles with no attempt at overarching discipline. My primary motivation was to make things as close to zero-configuration as possible for the average environment, but I've likely constructed a lot of infrastructure there that doesn't actually need to exist.
That makes sense. I believe this (https://github.com/msgpack/msgpack-c) is the reference implementation. I was less interested in key/value lookup than in heterogeneous arrays, so it's likely that it happened to be faster for me in that scenario but would be slower for your uses.
No worries, I guess we've all been there (I certainly have). If you want to make it zero config (at least that aspect of it), just put `set( CMAKE_CXX_STANDARD 17 )` at the top of your cmake file. Of course, if you are going to support MSVC one day, you'll have to put some detection back in, in order to use the correct flags for the warnings, but at least you won't have to do the dance of "On this compiler version, lets use these flags, on that compiler version lets use those flags ..., and then of course there needs to be a way for the user to override those settings ..."
Yeah, one thing that I really want to get done with the repository is more comprehensive head-to-head performance tests. I put a lot of time into the object key lookup curve because that's what I needed for my use-case, but I want to get a fuller picture of where Dart stacks up against alternatives like msgpack.
If you're in high school now, and planning to go to university for computer science, there's no need to master C++ at this point. That's what your uni classes will be for (and even then, you won't master it until you start using it for work). Find some free resources for learning online, play with the language a bit, and then fill in the gaps of what you learn while you are in college. You'll be miles ahead of the other students by the time you get there just by doing this. As for resources to use, Codecademy has a C++ course now. I can't say anything about the effectiveness of it, but I first learned programming from their Python 2 course and the interactive format helped me get started better than just reading books did. The books become easier to read after you've completed a few interactive lessons and get a feel for the language.
The design has been approved and paper prioritized for C++20 but it hasn't been merged yet. Still need Library Working Group approval.
Cheap shared hosting still supports FastCGI, but not anything like http proxying.
Thanks very much
LOL yeah it turns into a pile of hacks so quickly. It's not helped by the fact that there's such wide disagreement about what compatibility with different standards actually entails. My favorite issue in this space is that all of the macOS 10.13 machines (at least the coporate ones we were supplied) come with a version of Xcode that claims to be capable of compiling in 17 mode, but that doesn't actually have the necessary STL headers to do so.
That sounds extremely relevant, actually, thanks! Dart positions itself as a network library, which is true, but we've also been HEAVILY using this for efficiently passing data through shared memory, so I'll take a look through this.
Out of curiosity, do you have any suggestions about how to get more disciplined with cmake? The documentation is pretty famously not great, and I just haven't had much success getting an overall feeling for how the language "ought" to work.
that is true. though cheap shared hosting will most likely not support native programs, only scripting (php/python).
Well, the reason, why I like to have file system in the standard, because `std::filesystem::path` is a vocabulary type, that I want to pass from one library to another. Also, the implementation is highly platform specific. Such types - imho - should be standardized. But I agree for example that std::regex was a waste of resources. With fmt I'm a bit of the fence, because on the one hand it is such a fundamental part of any programming language and virtually every program out there needs something better than I/O streams
Not yet. But soon. The bgfx specific code does not change between platforms from what I have read about it.
The problem is that it has to be done in the right order, and the module has to be built before it can be imported. It would be very easy to accidentally use a stale module. For headers, buildsystems generally rely on dependency information gathered from the last build, and it is not actually a problem if it is changing because the dep can't change without changing some file which will require a rebuild. Unless you put a file with the same name somewhere, or change include paths. &amp;#x200B; Compiling modular code is more like linking from the point of view of a build system. It has to all be done in order.
thanks!
Thanks, let me know how how it goes :)
how about pspdfkit
clang-format can mess up though. Then I have to think about it again.
Those comments increase the cognative load though!
Fair points on `std::filesystem::path`. I considered that and was on the fence about it. It's not like we haven't read files before. fmt is about the same for me. &gt; But I agree for example that std::regex was a waste of resources. Since the original `&lt;regex&gt;` was a failure, did you know that C++ is considering [CTRE](https://github.com/hanickadot/compile-time-regular-expressions/)? Don't get me wrong, it's a great library, but the standard isn't supposed to be the means to distribute your libraries.
Fair points on `std::filesystem::path`. I considered that and was on the fence about it. It's not like we haven't read files before. fmt is about the same for me. &gt; But I agree for example that std::regex was a waste of resources. Since the original `&lt;regex&gt;` was a failure, did you know that C++ is considering [CTRE](https://github.com/hanickadot/compile-time-regular-expressions/)? Don't get me wrong, it's a great library, but the standard isn't supposed to be the means to distribute your libraries.
Okay, good answer. I will keep this in mind if I ever run into this situation. Thank you.
I can, its a really small project though. The school I work for has all these systems that don't communicate with each other so I'm just writing my own tool for keeping track of my data.
I just checked it out, and it doesn't seem to be open source. This is my fault, I didn't specify that I was sticking to open source libraries. I'll edit the main post.
Please use the [pinned post](https://www.reddit.com/r/cpp/comments/b8mxiy/c_jobs_q2_2019/) for job offers.
This survey has been very interesting. I've also found some new interesting things, like Boost::outcome, didn't know about it.
Unfortunate.
I did.
Company: Aimbot Studios Type: Not paid. The game is a passion project and will be free of charge, microtransactions and advertisements. Description: A shooter focusing on character customization and skill known as "Eradication". Location: Our discord server. We work remotely, since we're from all over the world. Visa Sponsorship: Nope. Technologies: We're still deciding on what C++ we want to use, and you can use any OS as long as you can code with it. Contact: Add and DM me in discord with Mr. Blue Sky#0001 or join us at [https://discord.gg/nHW4EB2](https://discord.gg/nHW4EB2) We could use any talent possible, minor or major. I hope to see you soon! **1 CommentShareSave**
Scala?
And I also know some software and libraries that are already named dart
I originally chose the name because it sounds lightweight and fast, and obviously there's the connection between darts and Target, and trying to hit the bullseye with the project, but yeah I'm constantly finding out just how many other things already had the same name...
Yeah, you were not the first one to find this catchy name ;)
I also wanted it to ideally be four characters or less, and be pronounceable, since namespaces that are much longer than 4 characters end up getting abbreviated anyways. I'll give this more thought.
Scale is dead after Java 8 implemented most of them goodies. Same thing will happen with Kotlin btw.
Java has operator overloading now?! That's the big holdup when it comes to financial programming in Java. There are no quantitative data types (fixed-precision floating types) natively in Java and Java has no zero cost abstractions, making financial programming a pain in the ass.
Looks cool, but something I would love with a color library would be if the colors had their color spaces somehow encoded in their types, to make all conversions statically checked. Something along the line of the templates classes in `std::chrono` would be the dream imo. Don't know if that's anything you would be interested in incorporating in your library (and perhaps it's too late now), just wanted to get my thoughts out there. :)
And yet you meet a lot of juniors who do "know everything" and they fill your codebase with `shared_ptr`.
What is kind-of wild is that I am currently *also * making a code generator (C++, Python and TypeScript), *also* for serialisation. Pretty wild to see your codebase.
Very cool. :D
Your expierences aren't everyones expierences dude. I'm compiling now, here's the cmake command line: `time cmake -G "Unix Makefiles" -B"$(pwd)/../LLVM_BUILD" -DBUILD_SHARED_LIBS=Yes -DCMAKE_BUILD_TYPE=Release` it took 47.5 seconds for Cmake to run. it's still compiling, I'll edit this comment when it's done with it's run time. the make command I used is `time make -j8` and it's currently 4% done and I started it a few minutes ago.
have a link?
Eh, this is not about templates. This is about overloading. Templates would bring nothing here.
Thanks for the support!
That's arbitrage trading, which is a tiny subsection of hft, let alone quantitative finance. My bot trades an average every 4 seconds and does not need to be FPGA. Instead I used OpenMP.
Interestingly, for entry-level programming jobs, you should be able to get the job with barely any knowledge of C++ intricacies. Which is great, since programming languages are only a small part of a programmer's job: - Communication matters. Oral and written. If you cannot communicate, you cannot work in a team, you cannot report to your boss, you cannot discuss with clients... well, you cannot work, really. - Programming matters. Forget the language, focus on the abstract. UML is crummy, but the idea is good: first and foremost is the flow of data, the relationship between the various modules, the abstraction boundaries. - Debugging. Programming is the art of creating bugs. And once they are there, they need to be identified and fixed. A rudimentary knowledge of a debugger is useful, though print-style debugging works too... the most important part is *reasoning*. Debugging is about being able to mentally picture the flow of data in the application, make useful hypothesis as to what could be going wrong along that flow, and being able to come up with ways to (in)validate those hypothesis until you've narrowed it down sufficiently that you can pinpoint the culprit(s). Finally, remember, you don't want to be a one-trick pony. You'll be better served by having a superficial (barely functional) knowledge of a couple of languages than you'll be by an in-depth knowledge of one language and no idea at all how others work. You'll need scripting knowledge, for example, such as Bash or Python, and these days SQL is ubiquitous. XML and JSON are not programming languages, but they're so often used you'll need to know their basics as well.
I also suggest reading https://isocpp.org/, there's "Recent Highlight" section with the latest and relevant cpp stuff, plus other important sections.
&gt; Sorry for bad English. Oh and the first step to being a good (C++) programmer is having a good command of English. You want nothing short of near-fluency, at least in the reading/listening part. Unfair? Yes, maybe. Being French I've struggled with learning English too. However, English is just mandatory in programming: - The best resources to learn programming are available in English. - The language specifications are available in English. - The technology specifications (IETF, W3C, ...) are available in English. - The library documentations are available in English. - The talks are mostly available in English. If you want to learn programming and actually program, the resources to do so are available in English. In my own (French) experience, the quality of the materials in my native language was abysmal compared to the equivalent in English... whenever there was *any* material on the topic. Notably because often time, only amateurs' blogs have any native language material at all, and you have no idea whether those guys are good with the technology, or just beginners with a whole lot of misunderstandings. To avoid relying on second-hand knowledge, which may be wrong or biased, you need to go to the source; chances are, the source is English. My advice: start reading articles/books in English, and start watching shows/movies in English (with English subtitles at the start). You'll get to learn English while having fun! **TL;DR: For now, you'll get a bigger bang for your buck by mastering English, than by mastering any programming language.**
You should migrate to Java, sounds perfect. -&gt; Is how 99% of the companies think today if they are in your situation, tech-wise, if you like it or not.
[removed]
I migrated from Java to C++. My older version of the same bot from '10 is written in Java.
I call bs
Do you also want all the static casts?
You would like that to have it based on `std::ratio`, like nholthaus/units Should be doable, and certainly something that would improve this already good looking library. And perhaps bringing back cmake support.
&gt; by default it will automatically fall back to the latest supported version by the compiler Are you sure? AFAIK it defaults to no version at all, which makes compiler use its default standard, which is not neccessarily the *latest* version it supports (IIRC, for GCC and Clang the default is C++14).
I gain no benefit lying to you.
Yes! Type-safe explicit conversions are the best! `std::chrono` has implicit conversions too though and I do think that they work quite well for `std::chrono::duration`.
If you're willing to spend a bit of money, [this book](https://crascit.com/professional-cmake/) is something I'd recommend. I don't agree with all opinions in the book, as they don't apply to writing a CMake *library*, but for writing project files, it works just fine.
In the article, there is this comparison code to compare by salary and then by age: bool operator()(const people &amp; a, const people &amp; b) { if(a.salary==b.salary) { return a.age&gt;b.age; } else { return a.salary&gt;b.salary; } } Using `std::tie` results in much simpler code: bool operator()(const people &amp; a, const people &amp; b){ return std::tie(a.salary,a.age) &gt; std::tie(b.salary,b.age); }
Oh, I will absolutely check that out, thanks! cmake is definitely my weakest skill in this whole stack so I'd like to fix that as much as I can.
The behavior that I observed was that when I didn't tell it, explicitly, what standard to use, and KNEW that it was actually available, it'd use the wrong one. But I've also just been assuming that I had configured something incorrectly to start with, or maybe the behavior has changed across cmake releases.
I was thinking more of having different types for RGB, sRGB, CMYK etc. But perhaps there are uses for `std::ratio` too for similar purposes. I haven't tried nholthaus/units, but it looks really neat! Might try it out later for game logic. Also, +1 on bringing back CMake support. Please. I don't want to like header-only libraries (and in fact I don't), but I'll take them over other libraries that don't provide proper CMake installation any day of the week.
Some Ruby libraries I'd like in C++: * socket (so much cleaner/easier than asio) * open-uri (treat any URI like a regular file) * optparse (think boost::program_options but with lambdas instead of a variables map) * activeresource (treat any object like a queryable database) * pry (if Rick Sanchez made a REPL...) * treetop (I don't always need a parser to be fast; sometimes I just want it to be easy) * benchmark (writing a Q&amp;D benchmark should be easy)
Yes that is what I mean too, but for the static checking you would have those types encode the transformations using `std::ratio` Though I guess you don't have to if you make good use of conversion operators. I like header only libraries if it makes sense; and the ones I make, also have a CMake compatibility; not just for tests and/or documentation building, but to provide targets, namespaces, etc, that make it easy to install and use.
Been there, done that, introduced a cyclic dependency, crashed the application, learned. Sincerely, I'm sorry. - Junior
I haven't done a survey of providers, but with Bluehost you can easily upload static binaries, or even compile or re-link on the server. I'd assume they all support that. Even if you're using perl/python/php the versions are frequently way out of date and it makes sense to upload your own version. Which is also totally doable with Fastcgi.
Nooo keep it
I wrote a C++ and CUDA compiler from scratch. It's currently 115,000 lines of tidy C++. llvm-8 is the code generator. I'm looking for corporate adoption so I can work on it long-term and have help. My goal is to give C++ programmers an alternative to Standard C++, which I feel has not been responsive to the needs of actual developers. The hello world of this language is its tuple: ```cpp template&lt;typename... types_t&gt; struct tuple_t { @meta for(int i = 0; i &lt; sizeof...(types_t); ++i) types_t...[i] @(i); }; ``` Statements prefixed with the @meta keyword are executed at compile time. In this case, when tuple_t&lt;&gt; is instantiated over some template arguments, the meta for is executed and the child statement of the loop is injected once for each iteration. @(x) maps a string or integer to an identifier token, so tuple_t&lt;int, double, std::string&gt; will create this definition: ```cpp template&lt;&gt; struct tuple_t&lt;int, double, std::string&gt; { int _0; double _1; std::string _2; }; ``` There are many introspection and reflection features so you can metaprogram in an imperative fashion, without having to resort to template metaprogramming hacks. As importantly, there's an integrated interpreter. You can execute any function during source translation by prefixing the expression-statement with @meta. If a function without a local definition is called from a meta context, the interpreter searches a set of pre-loaded .so files for the mangled name of that function, dlsym's the function pointer, and makes a foreign function call. One strategy of Circle programming is to move application-specific logic away from the C++ source code and into configuration files (CSV, JSON, your favorite format). The config files can be loaded with standard mechanisms via the interpreter, and same-language reflection used to generate code. Circle empowers the programmer by rotating an existing language from the runtime onto the compile-time axis. There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. But there's now an additional degree of freedom when designing your software. I have a Mint/Ubuntu build available for download. I'd like to get more builds available (especially an OSX build). I'm looking for two things right now: * Feature feedback--what do you want to see in the language? Any special introspection features? * Finding a corporate home for the project. If you like what you see, push your manager to get in touch with me. I'm available, and the compiler is available. And the compiler needs a home.
I can't wait till reflections allow for the ability to at compile time tie all member variables of a class without specifying name. metaprogramming could be so much fun.
LOL, honestly speaking I don't think the open source committee will let me change it at this point.
I like the for enum idea, enums and cases really make me wonder if there is a better way.
&gt; How does the STL implement a tuple? It uses class inheritance and partial template specialization. Each instance of _Tuple_impl stores one value in the data member _M_head_impl. It inherits the next successive specialization of _Tuple_impl, which defines the data member using the next type in the parameter pack. Thats how libstdc++ implements a tuple. libc++ doesn't use recursion nor does Boost.Hana's tuple implementation.
I could design a more compact way to write it, but the backend would still emit a switch statement (switch is so universal it's even an LLVM instruction), so using a switch is instructive as to what gets generated.
Mine is doing every kind of financial calculation on every kind of security and combination of those securities, since portfolios are securities, interactively for a world wide clientele of overworked and demanding financial professionals whose bosses pay ridiculous amounts of money for access to the software. It's also not the sort of thing you design. It starts out reasonable. Just every kind of US bond and stock. And then you keep adding and growing. I'm guessing he's describing Bloomberg, since that describes the Bloomberg `big` servers. I work there, and have for about 15 years. Either that or someone has exactly my problems, and I feel very sorry for them. A lot of the codebase problems are actually pretty stable at this point, and usually not inflicted on working developers. You don't usually have to link a multi-gig executable for your own work. Except when you do, and it's awful.
Senior means having done the work. F*ck credentialism.
Ninja would help. Also `make -r` unless you actually want make to checkout files from rcs or sccs for you. (* I will send that patch to cmake this weekend). It's still very long, though.
&gt; you can't pass it by value is what I don't understand. ``` void foo(std::unique_ptr&lt;T&gt;); foo(std::make_unique&lt;T&gt;()); // passing a value, yeah? ```
Clang has a test suite of some 13,000 unit tests. The whole thing can be run with a simple python script and only takes about 10 mins. The LLVM project also has "green-dragon" which runs even more meticulous testing and measuring. All of this is open source and available. I just wonder if some clever hacks would make it possible to apply it to your compiler. A coorporation is not going to help you produce a test suite like that but clang already has one. Imagine if you could say that the entire test suite passes with your compiler - it then becomes a drop in replacement for serious projects. I would love to see this project succeed and agree on so many levels that better meta programming is needed in c++ to build the systems of tomorrow.
Amazing, gonna give it a try as well!
The introspection features look amazing! That said, there's one thing I noticed that I was left unsure about. It seems that this compiler operated on single translation units at a time. This is definitely a reach goal kind of thing, but what would be truly incredible would be having some form of communication between various files. E.g. allowing something where one cpp file registers a function as an event handler, and another cpp file maintains a list of these registered handlers so it can dispatch events without requiring any clue code. What I'm thinking of is something like [this](https://youtu.be/N2UdveBwWY4?t=11929) showcase of Jai, where a developer console is automatically aware of any new functions added due to a registration system developed in-language which is invoked by the `@RegisterCommand` attribute. That said, this project is already fantastic as-is. If it was open-source, I would probably switch to using it immediately.
Ahaha. I'm the type who just uses raw pointers everywhere. OVERTURN THE SYSTEM.
I hadn't considered adding those kinds of attributes. I'll look into this. One think you can do is define whatever commands in some resource file in your source directory (like a JSON or Lua) and then each translation unit can access it or even modify it.
the "Structure to Array (and back again)" example is particularly cool. obviously you lay out the use case for CUDA, but it also seems really useful for game programmers and other people who have bought into Mike Acton's "Data-Oriented Design" paradigm. [https://www.circle-lang.org/s2a.html](https://www.circle-lang.org/s2a.html)
Thanks for sharing this helpful list. I might try out Ultralight :) &gt; GWORK - not battle tested GWEN is used in Garry's Mod.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of my code generator.
I see a benchmark for reading, but not for writing (or writing + reading)..
I see a benchmark for reading, but not for writing (or writing + reading)..
I see a benchmark for reading, but not for writing (or writing + reading)..
I see a benchmark for reading, but not for writing (or writing + reading)..
I haven’t, thanks! Definitely looks easier to use than curl. I’ll have to investigate sometime soon.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html). Theoretically that could be a big company, but in practice not so much.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html). Theoretically that could be a big company, but in practice not so much.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html). Theoretically that could be a big company, but in practice not so much.
&gt; The whole thing can be run with a simple python script and only takes about 10 mins. Sounds like a candidate for C++. Probably when they started the script took a few seconds so it didn't matter. I agree that better code generation can help build the systems of tomorrow.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html). Theoretically that could be a big company, but in practice not so much.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html).
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html).
Yeah, it makes sense when you're in IR or lower, but I feel like they're a little archaic in higher level languages. Regardless, they still have a purpose.
Yeah, it makes sense when you're in IR or lower, but I feel like they're a little archaic in higher level languages. Regardless, they still have a purpose.
Yeah, it makes sense when you're in IR or lower, but I feel like they're a little archaic in higher level languages. Regardless, they still have a purpose.
Yeah, it makes sense when you're in IR or lower, but I feel like they're a little archaic in higher level languages. Regardless, they still have a purpose.
Yeah, it makes sense when you're in IR or lower, but I feel like they're a little archaic in higher level languages. Regardless, they still have a purpose.
&gt; The whole thing can be run with a simple python script and only takes about 10 mins. Sounds like a candidate for C++. Probably when they started the script took a few seconds so it didn't matter. I agree that better code generation can help build the systems of tomorrow.
These statements: &gt;My goal is to give C++ programmers an alternative to Standard C++ &amp;#x200B; &gt; There's very little to learn, because the syntax and semantics of the language remain mostly unchanged. remind me of [my code generato](https://github.com/Ebenezer-group/onwards)r. We differ though when it comes to finding a home. I'm looking to [help, and be helped by, other entrepreneurs](http://webEbenezer.net/about.html).
Like lambdas, they're too complicated for actual use.
I see a benchmark for reading, but not for writing (or writing + reading)..
I see a benchmark for reading, but not for writing (or writing + reading)..
Hmm, I believe if you check the performance document there should be tests called something like "serialize_finalized_packet_into_json" and "serialize_dynamic_packet_into_json" which are the json writing/generation benchmarks for finalized/dynamic packets, but I admit I don't have a combined test that performs both in one test. I can very easily add it, however!
If you're talking about just general mutation in the library, and not just for parsing, there are tests like "insert_into_{shared|exclusive}_packet" which tests object insertion. I don't currently have a equivalent test for array insertion, but that should definitely be present and I'll add it. As far as other values go like strings, ints, doubles, etc, Dart doesn't actually allow you to mutate them directly, falling back on assignment.
That is less obvious to me what is going on.
I'm cross-compiling it for windows on linux using mingw and for mac using osx-cross. I don't know about android, but i would imagine there won't be any problems as long as you can create rendering surface there. \&gt; code for window creation, input handling, etc It is done by libsdl, bgfx doesn't do input or windows. One thing though: it examples are far from "minimal" and probably not the best place to look if you need a quick guide to it.
Looking forward to a windows build!
Why does this bother you so much? We have been using these names for decades. C++ programmers are familiar with them. Why would anyone want to rewrite the code and relearn the names just for the sake of an arguably slightly better name?
 ./circle: /usr/lib/libtinfo.so.5: no version information available (required by ./circle) can you please link this library statically?
The binary only works on Ubuntu/Mint, but not on any other distro. Also why isn't this open source? Are you planning on commercializing it or something?
Here are my works (Presentation PDF Download page + Repository). Will be glad to hear from you :) * [https://github.com/luncliff/coroutine/wiki/Exploring-the-Cpp-Coroutine](https://github.com/luncliff/coroutine/wiki/Exploring-the-Cpp-Coroutine) * [https://github.com/luncliff/coroutine/](https://github.com/luncliff/coroutine/)
The serialization examples are mindblowing and better than anything i have ever seen. The comitee should look at your approachs and see if they can learn from it, as its massively better than anything in the reflection proposals or even metaclasses.
But new people didn't. Why should we continue having those mistakes in the standard and continue letting new people trip over them?
Hey! I am trying to follow your Guide, but there seems to be no Function called "setPlatformData" inside the bgfx Header. I went through the Repository's include folder and there is no such function in bgfx.h
Thanks!
It's funny how anything people come up with to improve C++ is still hideous because C++ already is. And still people applaud it cause it does feel like an improvement at first 😁 Meanwhile D's elegant static foreach shows how it should have been done from the start (e.g. when introducing variadic templates): https://dlang.org/spec/version.html#staticforeach
The first time you see the pattern it certainly is harder to understand, but that is the case with any idiom. I think it is a huge improvement over having to implement lexigraphical comparison by hand, especially as the number of fields increases.
I have never heard anyone complain about having tripped over `const_iterator` because of its name.
the trend of web dev nowadays is full separation of frontend and backend, i.e. traditional c/s. I believe that's where c++ has its chance. A backend written in c++ will simply beat the shit out of backend written in java/go/python/ruby..., and big companies like google, facebook already use c++ in most of their backends. What we lack is easy to use c++ libs/frameworks. With new language features like coroutine and network, I believe c++ will be a popular backend language.
How often do you intent to spam that link in the comments here?
like only 3x
Why not choose a more descriptive name for your serialization library instead? :-)
From scratch? Why didn't you used clang/llvm? That would ease corporate adption. In terms of features if it would be possible to implement SpringBoot equivalent, then I'd say its feature-rich.
One of the harder things would be diagnostics, since the error message, the amount and any notes would need to be copied exactly by circle. There are a lot of FIXMEs too, but those are less problematic.
You might be interested in \[this\]([https://cista.rocks/#reflection](https://cista.rocks/#reflection)), specifically \`cista::to\_tuple\`.
I found the book really good also if writing a CMake library. Would you mind naming a few things where you don't agree with the book? Just curious and would love to learn.
Do you have plans for alpha-blending operations (with premultiplied and non-premultiplied)? Or different RGB color spaces/profiles (different gamut, gamma, etc.)? (in that case Google has separated the color space conversions from its Skia library to [skcms](https://skia.googlesource.com/skcms/) with might be useful)
He is using LLVM for code generation.
Also dangerously close to "libtard".
Are you arguing for east-const?
We'll get something similar for C++20 probably: [p1306](https://wg21.link/p1306).
If it is just `libtinfo` you can most likely install the old version on your system somehow.
But the order matters for lexicographical sort. What would be the order used for that automatic comparison operator?
Actually most suggestions are shut down, not applauded. C++ folk aren't a particularly welcoming bunch.
I have that old version (it's ncurses5) but [I'm getting mismatched version error](https://stackoverflow.com/q/137773/3980929). Apparently it's because binaries compiled in one distro (here: Ubuntu) are not always compatible with others (in my case Arch). I mean it makes sense since Ubuntu and co. patch packages before providing them. But now I noticed that it's just a warning! Thanks, I completely missed it. The weird thing is that even with it circle seems to work, except for the linking and standard libraries since those paths are also hardcoded. :( Don't really want to get a seg fault because that lib is incorrect or something even if it seems to work right now when circle creates I ject files.
`for...`, like we don't have enough dots already in template code.
This looks practical and understandable, and manages to do metaprogramming without requiring recursion everywhere. I wish C++ would consider this approach as well.
The warning might be caused by having the library stripped by default, but yes it won't find `crt1.o`.
Use the Dockerfile until I get more distributions supported. Won't be much longer.
Cool thank you! :)
I meant as comparison against other serialization systems
C++ is pretty bad, yup. But it's the biggest ecosystem. The world is big enough to have an effort to radically improve on that and also support D and Rust and other projects with newer language-design ideas. The whole point of my compiler is to require "no learning" on the part of the programmer. It's just C++, rotated into the compile time. You put @meta on front of a statement and it does what it ought to.
I think it's possible to write "tidy" C++ code. For example: [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/genz.cc](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/genz.cc) [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/cmwA.cc](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/cmwA.cc) But I've been working on those programs for over ten years. So, for me at least, it isn't easy.
It's hard to build on clang. It's more than a million lines and was written by many contributors. Other companies are always trying to extend clang and it's a major effort. I understand how 100% of my frontend works, since I wrote every line, and can slot in new user-facing features in 20 minutes. I'm continually refactoring major subsystems, which isn't possible with clang since it has so many users. When I have a feature idea I just implement it and see how it feels--it's hard to do that with clang at this point.
No, but fixing pointer syntax could be awesome. `ptr const int` - mutable pointer to constant `int`, `const ptr int` - const pointer to mutable `int`...
Theoretically: C and C++ are in the same ballpark. In practice: - C++ has a nasty tendency to sneak in invisible costs, such as an unexpected constructor call here and there. - C lacks good abstractions for containers, resulting in sub-par containers being used. You can find examples of C beating C++ and C++ beating C; in the end, though, C++ has better abstractions, which is helpful as projects grow.
Since you mentioned shared memory, I'll shill another piece of the puzzle: https://github.com/LiveAsynchronousVisualizedArchitecture/simdb This is a lock free shared memory key value hash map. It's easy to use and very fast - great for interprocess communication.
I think you are confusing multiple things here. From the client point of view, network overhead indeed plays a large part, and databases are relatively slow, thus using Python or C++ will have little impact. From a server point of view, however, this is a whole other game. Python is about 100x slower than C++, thus at the very least a C++ server should easily handle 10x/20x more connections than a Python server (all other parameters being equal). Of course, this requires having a sufficient number of clients to justify the investment; but at scale there are substantial savings from using a high efficiency language.
Pretty cool! Thanks for putting it online! I also support the other's comments on bringing back CMake support, and if it's just for a proper namespaced imported target. Also I think perhaps it would be better to include the colors and colormaps directly into the source/headers, that way you don't need to load json files and the nlohmann/json dependency can be dropped. Well many people use it already I guess, so it's not the worst dependency! But those color info/maps is not too much data and shouldn't increase library/header size much?
C++ metaclasses are already coming to C++, so I'm not sure what a closed-source non-standard tool has to offer a corporation. I applaud the effort but your best bet to keep this alive is to open source it, get some interest and maybe some of your features will be adopted into the standard.
The disadvantage is that you need to spend time writing a fully compliant (and even implement GNU/clang extensions) C++ compiler when you just wanted to write a simple meta extension.
I never even considered that, but you're actually the second person to make that association, which is _very_ unfortunate. Only a two letter difference. I'll need to check what I CAN do at this point, because we've used the name Dart and libdart for all of the paperwork internally, but it seems like one of the most consistent bits of feedback is that the name needs work.
Yeah, unfortunately at the moment the only head-to-head comparisons we have are for key lookups. I had to fly home for a family event this weekend, or I'd likely be working on this right now, but first thing next week I'll be adding a large set of cross library benchmarks for different categories. If you have any more suggestions for other useful performance test cases that would be extremely helpful!
Paging /u/daveedv and /u/andrewsutton
And /u/daveedvdv since that's his real handle...
metaclasses are not part of C++ 20. Nor are typed enumerations. Or introspection. And an integrated interpreter? C++ will ultimately get there, but they're futzing around with an ever-more-elaborate constexpr semantic. What Circle has to offer is that these features exist in the compiler. As far as I know, you can't even do a compile-time printf in C++ 20.
I'm not OP, but here's the [doc]( https://bkaradzic.github.io/bgfx/bgfx.html?highlight=setplatformdata#_CPPv2N4bgfx15setPlatformDataERK12PlatformData).
I quickly opened 2-3 files and didn't dive more into it. But I could already see that is using unordered_map and unordered_set. These two containers are legendary slow because the standard constraint them to have stable addressing. You can find few YouTube videos how much you can gain by using another associate container written with performance in mind. He seems to also allocate in a lot of places where this isn't needed and use virtuals. To me that sounds like someone trying to translate Java to C++ (in a non modern way) and that expect things to perform better. To get anything out of C++, you have to think about how your code and your compiler relates to your hardware. Unlike Java where the JVM can figure that out for you.
This is -- in technical parlance -- straight gangster. I've dreamed of making something like this myself, after getting tired of the horror show that is template metaprogramming. Metaprogramming is really \*just\* programming, where the task you're trying to automate just happens to be... programming. Therefore, the way that you program and the way that you "meta" program should be one in the same. Nice to see someone with the will and ability to actually do something about it.
&gt; C++ metaclasses are already coming to C++, so I'm not sure what a closed-source non-standard tool has to offer a corporation. by the time metaclasses actually are in the C++ standard, AND clang, gcc, and msvc have correct and not too differing implementations of it, you would have the time to build a language from scratch, make a project with it, ship the project, and retire if it is successful. Seriously, it's at least 6 years away... to give a reference, Rust is only a 8 years old language and it is already fairly mature and has a large community backing it.
Have you tried vs2019 yet? I'm loving it
By tidy you mean no whitespace? ;)
I'd say that is a correct assessment. I tried to convert the unordered_maps and unordered_sets into maps and sets but it was gonna take me longer than i wanted to screw with it. I do believe he basically wrote the java code then tried to literally convert it to C++. I don't think that virtual function calls are all that expensive though.
I'm stuck because of dependencies AFAIK, but it sounds great
No. The repo only goes back 2.5 years, but at that time the second file was 288 lines compared to 239 today. Older versions of the file were bigger. There's one function in the file that's bigger than I would like, but the others are better.
If this happened it would literally be a dream come true for me and many others.
There's plenty of information here: [https://www.quora.com/How-did-Spotify-make-a-multiplatform-lightweight-well-designed-desktop-application-What-is-the-technology-behind-it](https://www.quora.com/How-did-Spotify-make-a-multiplatform-lightweight-well-designed-desktop-application-What-is-the-technology-behind-it)
Also, on my Mac there are a lot of spa files (/Applications/Spotify.app/Contents/Resources/Apps/) and they're just zipped packages of css/html/js/json/... stuff. In my opinin, CEF is a low hanging fruit and using it shows not much respect for users - 300+ megabytes for a streaming app?
Metaclasses will likely be in C++23. With the way that compilers have been keeping up with the standard since C++14, I have no doubt we’ll start to experimental implementations in the next year or two.
That's passing an rvalue. Maybe I should have said "you can't pass by lvalue" to be more clear.
This strikes me as quite similar to [this older trick](http://b.atch.se/posts/non-constant-constant-expressions/). To my knowledge, it's intended for said trick to become invalid. Does your implementation have a key difference?
Hey, if that's the complaint you want to point out, then it must be a pretty solid feature!
300 megabytes of decent SSD storage costs 0.05$ at this most. That is 200x less than the *monthly* cost of Spotify subscription.
Perhaps they are struggling with fear. If you are drowning, it's not easy to be hospitable.
space. The array of pointers would be eagerly created whereas the view need not be (afaik but I’m no expert on ranges)
Can someone give an overview?
The copy and move operations of a `View` needs to be O(1) in the number of elements ([\[range.view\]/1](http://eel.is/c++draft/range.view#1)). I guess an array cannot satisfy that.
If people keep finding holes for stateful metaprogramming, why not allow it into the standard?
that would be *very* optimistic. metaclasses depend on reflection, and the reflection TS hasn't even been published. Keep in mind that concepts have been discussed since.... 2000 ? and we are only getting them in C++20 - and metaclasses is an even more disruptive feature.
Huh, I wonder how that’s done. Maybe because copies are lazily computed?
yeah i saw it , basically they they made CEF + many open source GLUE nice not sure why ...
From the provided link: &gt; Examples of Views are: &gt; &gt; – A Range type that wraps a pair of iterators. &gt; &gt; – A Range type that holds its elements by shared_­ptr and shares ownership with all its copies. &gt; &gt; – A Range type that generates its elements on demand.
now i wander what apps did the same as spotify , that is using CEF as their presentation layer
Well the elements of a `View` may be owned by another range (as in [`ref_view`](http://eel.is/c++draft/range.ref.view)), or may be generated on-demand (as in [`iota_view`](http://eel.is/c++draft/range.iota.view)).
You need to include &lt;bgfx/platform.h&gt; for that function to be defined. In the code block where this is first used in the tutorial, up top, there are three new headers that need to be included for the functions in the code block to work.
Now, imagine if you have a truly native implementation. It probably would be about a tenth in size, it would be faster, and it would use the available resources (mot just the disk space but memory and CPU as well) a lot more efficiently.
And people keep looking for holes because they _want_ that feature.
One thing I've been wrestling with is the best way to express arbitrarily-nested control flow in the context of reflection. For example, consider trying to build nested if statements such as: if(a) { if(b) { } else if(c) { } else { } } else if(d) { ... from a flat data structure returned from some library that was invoked in a @meta statement. You loop over this data structure, but how do you express control flow with nesting? Certainly you can generate functions (or meta functions) at each level, and lean on the optimizer to inline everything (which is the template metaprogramming way), but there ought to be some more direct way to express your intent. Does it make sense to allow declarations of control flow statements like ifs and fors and compound statements that can be manipulated like objects? @(label++): ... // Programmatically emit a label from an index // later on... if @(my_label_index) { } // Attach an if statement to a label Maybe have a way to attach a control flow structure to a label? I'm thinking about a way to programmatically generate control flow that still feels like ordinary programming, and not like I'm manipulating a DOM or using something very low-level like IRBuilder.
There are just as many arguments against "static foreach" as there are in favour of it. I'm honestly not convinced that feature is a good idea.
I think you're correct. I suppose this means the view requires some mapping function and a pointer to the original data structure.
Working on it (in the form of `consteval` variables).
What happens if I try something crazy like `@meta int* x = new int;`? Does it matter if the next line is `@meta delete x;`? What about `volatile`?
Right, but how is it copied? That's what I meant, sorry. Feels like it should be proportional to the number of elements that have already been initialized.
enum &lt;-&gt; string_view when? std::(begin|end)(some_enum) when?
At a glance, this looks similar to the "C++ type hole" trick. It uses templated friend declarations to somehow create a "state" that can change during compilation and thus cause a constexpr expression to get a different value during different times in compilation. From what I know, all these tricks use "friend" in some ill-defined way, which will be disallowed in the next standard.
I mean unity is making a gcless c#. Also D is pretty good in performance and it's managed.
Usually views don't copy but offers a way to access data. For instance an array_view might be a pair of pointers or a pointer and size. Then you just copy the view but not the data it's being viewed. For more info I need the article you're referring to, or an explanation of what you are referring to as *copy*.
You don't copy the content of a view, just the pointers to whatever it is a view of
By \_copy\_ I mean creating a second view that acts identically to the one being copied. &amp;#x200B; \`\`\` auto view1 = new View(/\* some data structure \*/); // view1 is used. auto view2 = new View(view1); // view1 and view2 should behave identically from here on. \`\`\` This is what I mean by a \_copy\_, where \`new View(view1)\`.
&gt;Right, but how is it copied? &gt;– A Range type that wraps a pair of iterators. The same way a pair of iterators would be copied. &gt;– A Range type that holds its elements by shared_­ptr and shares ownership with all its copies. A same way `shared_ptr` would be copied etc.
I worked with Filip a while back and it's then that I've learned of the idea of statefull constant expressions. He was mainly interested in finding a standard compliant version. This made his solution limited (counters could'n reach over a fix number, couldn't have changing templated usings, etc...) and even-though it was standard compliant the solution needed to be altered per compiler for a miriad of reasons and newer releases of said compilers broke the solution. The friend injection technique was indeed discussed by the committee and regarded as a [bug](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2118) but no idea as of how to fix it was found, its status didn't change since 2015 (date of original report) and I don't think it will change anytime soon, the committee as bigger fishes handle. I had a talk with Filip about this and he told me that even with friend injection removed from the language other ways existed but he didn't revealed them to me. In the face of all of this I worked on a [library](https://github.com/DaemonSnake/unconstexpr) that only targeted g++7 to allow simpler and weird results albeit non standard ones. Since g++8 this library isn't working anymore (the noexcept trick doesn't work, and other things that I haven't investigated, etc...). The main thing from this new version is the C++20 feature that lambda are allowed as auto default parameter. This forces a new template to be produced a each template deduction. `template&lt;auto = [][}&gt; void func();` `int main()` `{` `func(); //func&lt;lambda#0&gt;();` `func(); //func&lt;lambda#1&gt;();` `}` &amp;#x200B; This prevents the caching the rest of the template arguments as far as I understand it, at least in gcc. As a side note this could also be replaced by using the source\_location part of the [standard library extension TS](https://en.cppreference.com/w/cpp/experimental/lib_extensions) by it being used in a constval/constexpr! function (as it give you access to the line,column,etc... of the caller function not the constvar one) and other cleaver tricks. The '*~~nice~~*' thing about all of this is that the solution since 2014 has become much more easier to implement.
Then I guess couched in my question is that I'm unsure how those objects are copied. But you're correct.
If I understood it correctly: - If the view are a range of iterators, you just copy the range. - If the view generates the data, you just copy the state + the generator, not every thing that has been generated before. Essentially it's O(1) because you always copy *the view*, and because a view has fixed size *once created*, you are always copying the same amount of memory.
```template &lt;typename T&gt; struct view { T* begin, end; }; int main() { auto array = int[] { 1, 2, 3, 4, 5 }; auto view1 = view&lt;int&gt; { &amp;array[0], &amp;array[sizeof(array)] }; auto view2 = view1; assert (view2.begin == view1.begin &amp;&amp; view2.end == view1.end); }``` Here, `view` is a simple aggregate class that just holds two pointers — one to the beginning and one to the end of a range. Copying the view simply copies the two pointers. You can get much fancier than this very basic example, but most view types work on this or a similar principle.
I think that makes sense. Moreso I think I should find various examples of how views tend to be implemented. I think that’ll clear things up for myself. Thanks for the answer!
Filip is an ex colleague of mine. He was manly focused on standard compliance. I don't really care personally, as it is the standard compliant version never worked on all compilers implementing C++11 because its relies on really specifics things and doesn't work anymore on both clang and gcc. I wrote a [library](https://github.com/DaemonSnake/unconstexpr) based on his work but targeting g++-7 only which had a number of benefits but the next release broke the library. You're right about the desire to make friend injection invalid that being said no solution was found as of how to make it illegal and Filip told me that other techniques could be utilized but didn't detail much (something about dependent parent constructors). The bug was reported in 2015 by Richard Smith and it has been discussed much since then. I believe that the committee has bigger fishes to catch and will therefore remains in the language for quite some time. The main difference of my solution is the following: `template&lt;auto = []{}&gt; void func() {}` `int main()` `{` `func(); //produces func&lt;lambda#0&gt;();` `func(); //produces func&lt;lambda#1&gt;();` `}` As I understand it this also forces other default template arguments to be re-evaluted at each template deduction, or can be forced by making the other default template parameters template dependent on this lambda. **constval** function will likely make this even easier to implement and in a standard way. (constexpr function that can return different results such as with source\_location). ***for...*** could also help.
Your new/delete thing isn't crazy. That's the right way to use heap memory. new int is a new-expression, so that boils down to a _Znw call (which is implemented by libstdc++) and delete boils down to _Zdl. Those foreign function calls are made, the pointers are cast to their right types, blah blah. Ordinary dynamic memory. volatile won't matter for @meta stuff because the compiler is single-threaded. And it's run through an interpreter, so I access the data afresh every time I use it.
To that end, I'd like to see Cling to start getting some more traction https://root.cern.ch/cling
It relies on 2 tricks: * templated friend injection * create two templated classes * one as more template arguments than the other * the one with the least amount of template argument gives the declaration of a friend constexpr function but not its definition * the other gives the definition and uses its supplementary template arguments inside said definition * this allows to control the result of a constexpr function when the second type is template instantiated. * template&lt;auto X = \[\]{}&gt; * each template deduction forces the compiler to produce a new version of the thing templated Once you have that you simply have to detect if the constexpr friend function is usable or not and you can produce a constexpr counter by iterating over the versions that have been defined.
Right now because it break many tenants of C++. It's also pretty dangerous to use as many side effects of this kinds of tricks are unexpected For instance: `template&lt;class T&gt;` `void func(T const &amp;x)` `{` [`x.next`](https://x.next)`();` `}` `void func()` `{` `constexpr constexpr_counter::counter c{};` `func(c);` `static_assert(c.value() == 0); //doesn't fail` `}` That being said something similar but well defined and limited in its use
Thanks, I hope it’s useful for you!
&gt; type_printer&lt;list::current_type&lt;&gt;&gt;(); //type_list&lt;&gt; &gt; list::push_front&lt;int&gt;(); &gt; list::push_front&lt;double&gt;(); &gt; type_printer&lt;list::current_type&lt;&gt;&gt;(); //type_list&lt;int, double&gt; That's horrifying. Yet actually could be useful.
So I've also pondered these very questions before, and took on the opinion that hunks of code should be treated as first class citizens like any other variable. Here's a simpler example that just creates an arbitrarily deeply nested if chain, but the same idea applies for the general case. @code myNestedIf = { ...inner most block of code... } vector&lt;string&gt; conditions; readFromFile("file/path", conditions); @meta while (!conditions.empty()) { myNestedIf = if (@{conditions.pop_back()}) { @myNestedIf } } @myNestedIf //However you output to source Note that no DOM-like interface is needed because we don't need to manipulate the inside of myNestedIf, since it's being built from the inside out. However, if you need to peek inside a code object, then some API is probably necessary. But perhaps by relying on pattern matching, the API can very minimal/general, i.e. standard tree manipulation stuff that would be easy for developers to learn. Simple insertion example: @code stuffToInsert = ...hunk of code... @pattern myPattern = if { @any } @or else if { @any } @or else { @any } //Insert stuff into the 6th if/else block @meta myCodeBlock .find(myPattern) .at(5) .append(stuffToInsert); Simple query example: @pattern myPattern = class @any { const (float @or double) foo(int @{paramName}); } //Find the first class that has a method "foo" with the given signature, //and get the name of the first parameter @meta string s = myCode .find(myPattern) .first() .getStr("paramName"); The pattern matching allows a general tree-traversal API, instead of a language specific API such as list\_member\_functions(), get\_return\_type(), is\_const\_or\_constexpr(), or whatever else is needed to encompass the entire language. These examples are super rough and basic, but maybe they can inspire some more refined ideas. Side note: a nice to have would be a block sized meta escape, in addition to the single line @meta escape, like PHP has with &lt;?php ?&gt;
Side note first: block-sized meta escape is @meta+. Eg @meta+ { ... } everything inside { } is implicitly meta. If the chunk of code is treated as first-class citizen, does that imply the need for a closure to access surrounding objects? Is the code you're assigning to myNestedIf parsed and analyzed at definition, or when it's inserted? If the former, it should have a way to know about its context. If the latter, would string composition and @statements suffice? (@statements injects a series of statements from a string). Text-&gt;code seems gross, but it might be the right way to achieve some of this. No API, easy to print...
What I don't understand here is how can you call `_Znw` if you don't really have heap at compile time. C++20 will allow heap allocations at compile time but only if the same object is freed at compile time too. It achieves this by "promoting" those objects to the `.data` segment. How do you work those things out if I am allowed to write `@meta int* x = new int;` and leak that `int`?
I don't see why it couldn't be based on declaration order, given that it's opt-in. If you care about the particular order, you'd manually specify each member, but if you just want an arbitrary ordering (say, to use a type with no operator &lt;=&gt; in a std::map), then you could do so with less code and less risk of forgetting a member.
You do have a heap at compile time. @meta int* x = new int; allocates memory with _Znw as you'd expect. @meta delete x; deletes it as you'd expect. If you fail to delete it, the OS does that for you when it terminates the process, just like any other application. You can fopen/ifstream files the same way. You can use wxWidgets to antagonize your users with many compile-time dialog boxes, if you are so motivated. circle basically has a little VM for executing statements at translation.
Passing the tests that compile and producing *any* compilation error for the rest would be good enough imo.
So ideally it would be parsed and analyzed at definition, except name lookup in outer scopes is deferred until insertion. Optional lambda-like capture at definition would be cool though. I have no idea how this deferral would work though. If it's not feasible then better to just parse the syntax tree at definition, with the analysis done at insertion. The programmer would at least have access to that. The string composition suffices I suppose, although if the programmer wants to do complex querying and manipulation then there's a good chance the strings would need to parsed/analyzed anyway. I'll make another example that tries to repeat what your example does with the label hooking.
I currently work on an embedded application, where we needed a web interface that could interact with the inners of the POS application that's running there. I ended up creating a very small web server, serving files when asked but also having special pages that were precompiled. We could have any external html, js, images, etc. as we wanted, but we were able to query the machine locally via HTTP. I don't think it's not used: I will say that it's not used on projects where experienced programmers are an important cost. Where you have to buy machine time per dollar, it's more common and also where you don't have the horsepower. I think it could be a thing really on IoT.
[Textbook I am using for reference](https://www.amazon.com/Starting-Out-Control-Structures-Objects/dp/0133769399)
Between: `void f(const int&amp; ri);` `void f(int i);` &amp;#x200B; There are several reasons to prefer the latter: \- To express intent: I'll pass you a reference to the object for you to see is not the same that i'll pass you an object of your own. C++ programs try to express **what you want**. C programs (like assembly) try to express more closely **how yow want it done**. \- It's shorter. \- It eliminates indirection (`i` variable could come in a register and be used right away, or copied to the stack); `ri` instead, if passed on a register would mean: use the register value to access memory (maybe the compiler could optimize this if it **knows** the variable is not used somewhere else). \- When you're working with several threads: the copied object has it's own lifetime and needs no synchronization. \- As you get a copy, you get to change it. I don't consider this to be the best practice, but in short functions it could be performant and also look clear (consider travelling a `const char* c` with the `*c++`), you can't increment a `const&amp;`. \- Bottomline: there are uses for both. We search for economy and less effort, but try to avoid the "I'll always do things like this, this works on every case", C++ gives you the option to choose reference or value semantics.
For the same functionality, modern C++ almost always beats C. Most of the time, people compare a version of a program in C that is less powerful than the same version on C++. Even the hated virtuals, they have no more cost than any reasonable implementation in C. You don't get to compare virtuals with static functions and then call them slow.
What was your motivate for writing this?
Around 50 seconds or so. \~100-150k lines of code. Every compilation runs on a vagrant machine, using makepp which loads all the makefiles (and scans for includes), and every compilation runs all the tests and then packs an installer to be deployed to the target platform. The whole compilation from scratch takes about 5 minutes. Sometimes, when I need to speedup the process I do a shadow build on a chroot that's mounted on a subfolder of /dev/shm. Then it takes half of the time.
AWS doesn't care or know which language your compiled binary originated in. I've run loads of C++ servers on AWS. Linked statically, it's brilliant. You just copy your binary up and go. No fucking around with a shitton of dependencies and configuration.
The video is linked to the ~15 min mark for some reason just fyi..
CE / EE major? I had to take a embedded class, and we used the same book for whatever reason.
Very cool! Learning and teaching is do fun. I write and film tutorials on cryptocurrency tech as a continual learning project and love it.
&gt; Only a two letter difference. It's a single `std::swap`.
I'm not sure why this is unexpected. `MyArray();` declares a constructor, which means you are promising to provide a definition later on. The fact that you won't be able to deliver on your promise later on doesn't matter here. A type is default-constructible if it has a default constructor. As far as the type definition goes (as opposed to constructor definition), it does have a default constructor.
You mean you did it correctly. As you probably know, there is an AWS sdk for C++; but that is not a direction they seem to encourage as strongly as other languages.
C++ is context-sensitive, so you can't parse input without doing semantic analysis. That's why the template and typename keywords are needed to disambiguate dependent template and type names, for example. By defining the text you want to insert after the point you want to insert it, you at least have the chance of establishing context and performing the parse. I suppose you could forward declare a pattern, insert that pattern, then define the pattern after. Honestly, there are a probably a lot of reasonable ways to do this, and any of them would be better than having none of them. :D
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqd3nc/changing_for_loop_to_a_while_loop_please_help/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
What puzzled me the most when starting was the reuse of * for pointer type/dereference and &amp; for reference type/address taking. That combined with the stupid habit of attaching */&amp; to the variable rather than the type where it belongs makes it really hard to understand for beginners.
Well that's about the only degree of freedom in the design.
Sure not attacking your project, just C++. I also often look at new fancy C++ TMP code and think hey that's very nifty, e.g. CTRE recently. Then I remember that the whole task would be a no-brainer if they had done variadics right.
Which are?
Definitely not looking for SFINAE. So you're saying that even if the function body is in the header, if it isn't written in the class, the type system doesn't consider it?
&gt; That combined with the stupid habit of attaching */&amp; to the variable rather than the type I always attach it to the type for this exact reason. It just seems way clearer to me.
I'm also confused by this. You describe a "promise later on", but isn't that promise already fulfilled at the site of the failing \`static\_assert\`? &amp;#x200B; Why would default construction produce an error at the same location that \`is\_default\_constructible\` is true? Is there a more appropriate way to \`static\_assert\` that a type is known to fail at default construction?
I think you're talking about using APIs to manage AWS instances. But who cares about that. AWS itself isn't any different than any other host. They don't care what language you use. You want to install some Befunge code on Ubuntu, you can.
That's right, it can't. Think of the following example: struct Bar { Bar() = delete; explicit Bar(int) {} }; Should `std::is_default_constructible_v&lt;MyArray&lt;Bar, 1&gt;` be true? The only difference between this and `Foo` is that we have an extra constructor here. It is entirely possible you will later define `MyArray&lt;Bar,1&gt;()` to invoke the `Bar(int)` constructor on every element. It may even be through a template specialization. In that case it will be default constructible. But yes, in general any attribute of the type depends on the type definition, not individual method definitions. I am a bit confused about why you want to check `is_default_constructible` if you are not using SFINAE. Is it just for better error messages? Because you will get something about `Foo` not being default constructible anyway.
Your program is ill-formed. You can not mark a function deleted after its declaration.
The reason it's traditionally attached to the variable is for multiple initialisation, you need a * for each variable: int * a, b makes `a` a pointer to an integer and makes `b` an integer.
It wasn't rejecting but the committee wanted an Implementation. Now we have one! Not sure if published but I expect that an updated paper will in the next mailing. :)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqdhtr/looking_to_step_up_my_c_game_looking_for_an/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Let's start with the biggest one. Why shouldn't a static for loop introduce a scope? It has `{}`, so it is very intuitive and expected for it to introduce a scope. Not doing that goes against intuition.
Here's another example of general branch building, which is supposed to output comparable code to your example. It's heavily influenced by html templating in the webdev world. For brevity I've omitted the meta keyword and just use the @ symbol. No hooking to labels is necessary, but a few lines at the end shows example code injection to a label hook. First the action enum. enum Action { None, Crawl, Walk, Run }; Then escape into meta to define the branch structs. @{ struct Branch; struct Node { float threshold; Action action; Branch* nestedBranch; }; struct Branch { vector&lt;Node&gt; nodes; bool endsWithElse; }; } Now the helper function that does the recursive branch building. Anything between an @ and a newline is meta. Otherwise the line is output as code. Stuff like @{expression} also outputs the expression value as code. @ void buildBranch(Branch* branch) { @ if (branch == nullptr) return; @ if (branch-&gt;nodes.empty()) return; //If block @ Node first = branch-&gt;nodes.front(); if (@{first.threshold} &lt; x) { doAction(@{first.action}, x); int y2 = y; int y = 2 * y2 + 1; @ buildBranch(first.nestedBranch); @ if (branch-&gt;nodes.size() == 1) { } @ return; @ } //Else-if blocks @ for (int i = 1; i &lt; branch-&gt;nodes.size() - 1; i++) { @ Node node = branch-&gt;nodes[i]; } else if (@{node.threshold} &lt; x) { doAction(@{node.action}, x); @ buildBranch(node.nestedBranch); @ } //Else block, or final else-if block @ Node last = branch-&gt;nodes.back(); @ if (branch-&gt;endsWithElse) { } else { @ } else { } else if (@{last.threshold} &lt; x) { @ } doAction(@{last.action}, x); @ buildBranch(last.nestedBranch); } @ } Top level function that generates definitions for x and y, then calls the helper function. @ void buildBranch(Branch branch, float x) { float x = @{x}; int y = 0; @ buildBranch(&amp;branch); @ } Go back into meta to read the branch data from file, and build and output the code. Also another chunk of code is build and inserted in some file at a label hook. @{ Branch myBranch; loadFromFile("file/path", myBranch); buildBranch(myBranch, 0.42); //Outputs the code Branch otherBranch; loadFromFile("other/path", otherBranch); //Capture the branch code instead of outputting it here @code branchCode = buildBranch(otherBranch, 0.66); //Replace label foo in source.cpp with the branch code @pattern label = foo: @file("source.cpp").find(label).replace(branchCode); } Very rough, but it's just to show a few ideas. Thanks for reading and all the best with growing the project.
That's the book I recommend to my students.
Interesting, I thought those calls would have used different objects of the same closure type.
Not only that, but also for function signatures like \`int (\*foo)(int, int)\`. It makes sense in C, but it is much less common in C++ because we have better ways.
That's allowed by Reflection TS which has been published for C++20. Now instead of a simple "when", go and help your favourite open source compiler actually implement that feature.
Why is the subject “Compiler Explorer?”
Am I losing my mind, what is going on there?
Declares a pointer foo that can point to a function that takes two int arguments and returns an integer.
Ah right, I almost never use function pointers, no wonder. Thanks!
Ah well if parse and analysis are essentially a monolith, then.... yeah.... Reminds me of how the C preprocessor also depends on the parser. So for C++ that would mean the whole front end is inseparable. Well, I still hold hope that someday the problem will be solved, or sidestepped with a better idea.
&gt; We remove old aliases. (C++26) Add a decade or two to this or you'll make a lot of people very mad, who "have to" build codebases that compile with old and new versions.
I watched only the part which was linked to, but I think this is fairly nice for complete beginners. However, you made a handful of small mistakes (you caught some of them in the video but missed some others), such as some output which were missing '\n' and getInventoryInfo setting year twice rather than setting mpg. It might be less confusing if you prepared a fully functioning example in advance (off screen, just for your own reference) so that you can avoid this kind of mistake.
Yeah which was a big design mistake. D fixed it by requiring the same type for all variables in such a declaration.
Really good tutorial, but please, work on audio. Check out audacity, a free program for editing audio. There are many tutorials on how to reduce noise and make your voice clearer. Good luck on future videos!
Let's look at his update function: void step() { std::vector&lt;Point&gt; toReset; std::vector&lt;Point&gt; toSet; for (Point w : field) { auto it = counts.find(w); if (it == counts.end() || it-&gt;second &lt; 2 || it-&gt;second &gt; 3) { toReset.push_back(w); } } for (auto w : counts) { if (w.second == 3 &amp;&amp; field.find(w.first) == field.end()) { toSet.push_back(w.first); } } for (Point w : toSet) { set(w); } for (Point w : toReset) { reset(w); } } Every iteration, he allocates new std::vectors on the stack, then calling push_back on them a bunch of times. So when N cells change state you get up to log N memory reallocations. N gets to grow quite a bit as the game (which is running a glider gun) progresses, so that's really bad. The right way to do it would be to keep toReset and toSet as member variables and call clear() on them at the beginning of each step. Now the reallocations are amortized over the whole execution. The JVM is doing something similar in the background (it keeps a memory pool instead of asking the operating system for memory every time someone writes the word new), except that it collects garbage every once in a while.
please cease showing `using namespace std` you could just as easily have `using std::cout` or the specific things you are using, which will make things a lot more readable and maintainable. It will also stop you encountering collisions or bringing in the whole of std namespace just to use a few of it's consumables. Think of it like going to the grocery store. If you told someone to get everything in the grocery store to avoid writing a list, you'd be out of pocket and most of it would go to waste. Lovely you are teaching others, perhaps there is a way to set a playlist so others dont see "Bong eats". You never know how young your audience will be
This is super useful in general for anything you'll ever come across: http://c-faq.com/decl/spiral.anderson.html
Where are you seeing "Bong eats"? Certainly not from a separate video OP uploaded AFAICT from looking through those. My only guess right now is that you're seeing a video Youtube recommends to you personally.
Is this solving some real world problem or just presenting some curiosity of the language?
Doesn't this introduce some ambiguity to \`void \*\`? What is \`void \*\` now, a pointer to an actual void or a pointer to a unknown type?
Looks great! I see that you have a benchmark folder. Are the results available online? Maybe you could include them in your README.md?
It's a function pointer, the syntax is really fucking confusing because you have two parantheses. i freaked out too when i saw it first in the book.
[👀 ](https://emojipedia.org/eyes/) [👀 ](https://emojipedia.org/eyes/) [👀 ](https://emojipedia.org/eyes/)
This is the type of stuff the people at google and fb use tho. its hard but its why c++ is so favored by the big companies.
As far as I can tell, it would be either. As you do today, you would still need to know which type it actually points to in order to use it safely. Dereferencing a non-null `void*` without casting it first would always give you back an instance of `void`.
 int *foo() The * belongs to int. int (*foo)() The * belongs to the function.
clicking on OP's youtube. IT suggests they are subscriptions. https://i.imgur.com/alMI5wI.png
I see. The only solutions to that would be making the channel's subscriptions private or using a separate channel.
To be honest this is peak reddit, focusing on one part of a single sentence I wrote in a multi-sentence post. The majority of this was about not over-using `using namespace {x}`, saying it's lovely OP is teaching others.
I was just curious. I agree with the point of the comment.
Looks very useful, especially the std::vector allocations. Possible to compile under VS 2019?
Sorry, that was unclear: If you specify CMAKE_CXX_STANDARD to 17 but the compiler doesn't support 17, then the default behavior is to silently degrade to the latest supported standard. You can change the behavior to error out if the requested standard is not supported.
C++ has an alternative form for function pointer declarations that is much less confusing: &amp;#x200B; using foo = int (int Arg1, int Arg2); &amp;#x200B; Or if you already have a function with the right prototype around: &amp;#x200B; using foo = decltype (fooproto);
While little can be said based on a single video, this looks very typical of C++ video tutorials and it seems likely it will have the same issues. The video is primarily a demonstration of syntax, with little focus on why this syntax is worth knowing. The extremely high pace with which features are introduced, with the assumption viewers will just get it, only makes this more of an issue. (Again, maybe you just want to give a quick overview here and you've got videos planned where you cover the subjects in depth, but that's not the impression I got.) &amp;#x200B; My advice would be to start by watching existing video tutorials and figuring out what they did wrong, then understanding how you will avoid these issues. If you can, help a bunch of people over IRC or other chat service—it'll give you an idea of the level of detail actually needed for people to get it. A good example of a terrible YouTube series is thenewboston's stuff; it's worth understanding the mistakes he makes, since most series tend to end up making much the same ones.
Well yeah. Everything I mentioned about loops and arrays and other shit is going to have separate YouTube tutorial videos.... this isn’t the first video in the series. It assumes the person has watched the videos on loops and functions and arrays and pointers first (which I have to make). Why tf would this be the first video in the series lmao
All the other c++ tutorials (especially Cherno and boston) are fucking garbage shit because they’re too fast paced and don’t really cover use cases of how to do it. But I will as I already made a sample program with the concept and definitely did explain the context. I have plans to make a video on everything (loops etc) and they will be 30 minutes long
Thanks for criticism
The youth of America enjoy bong eats as well
What are the advantages over using Git submodules?
I'm not sure how I feel about this.
I like this.
CPM takes care that all projects are added only once and have a minimum required version. Git submodules are fine if your dependencies do not have dependencies of their own. Git submodules can easily lead to dependencies being added more than once and in different versions, which will most likely break your project and derived projects.
I see, thx! What happens when multiple project include different versions of CPM?
Sorry, I didn't watch the video in depth; looking at it again, I see that it doesn't make sense as a first video. However, if this is not just a basic introduction but actually the video on structs, what I said applies twice over: you want to be clear and get the message across. The video doesn't address what problem this feature addresses. Another thing that may be worth doing is considerably harsher editing. Just to take a sentence at random (around 3:30): \&gt; So this is a struct, um struct, like, initialisation \[sic\] called Nissan, right, and you wouldn't actually define structs inside main, right, if you remember in the functions tutorial we actually define structs outside of main, we define them before main or after main, right, so in this situation we're gonna define it before main, right, so now every time I can use this struct thing I can just call it a name. I think the quality here could be higher.
Again, it is hard to judge these things by one video. If you're aware of this and are actively fixing it then that's great, but I don't think this video demonstrates that.
I understand. Thanks for the feedback. I will redo the video with more examples. Tomorrow I will make an arrays and loops video. Please tell me any other specific portions of the video/quotes like you just quoted that you found problematic and any other criticisms you had of them.
I will redo the whole video and be more clear and formal. Please point out to me other examples/quotes you found problematic and explain them so I can write them down when I remake the video
CPM will always use the version of the outermost project. If a dependency requires a more recent version, CPM will emit a warning that can be resolved by updating the outermost project's CPM.
Could you provide a transcript with accompanying code? Trying to pick it up from video is rather time-consuming.
why no using foo = std::function&lt;int(int, int)&gt;; ?
Sure I will, but I need way more examples/specific criticism so I know what I actually need to work on. Could you please run through all the specific things I covered in the video / how I did things you found wrong? Could you also explain how I should structure the video/what things you want me to do so it's high quality? How should I improve my examples and what would you like my examples to focus on? &amp;#x200B; The shit you mentioned about covering basic syntax and not deeper. How can I improve on this? What specifically do you want me to do? &amp;#x200B; I want to write this down before I actually give you the transcript so I really need pointed examples of a) what you found wrong/bad/low-quality b) what you would like to see/how you would prefer to structure it?
Metaprogramming with C++ is not entirely unrewarding: there is a feeling of statisfaction when you manage to manipulate the type system in just the right way. You've solved a puzzle. And we love solving puzzles. We can impress our coworkers with it, and create these immutable pieces of code in the code base that work perfectly and inscrutably or don't work at all (weird compiler error!). If you try solving some of these typical metaprogramming puzzles in Circle; it's not like there are no challenges at all. But I'm actually thinking about what instructions to put down to achieve my goal, and not how to create a type whose recursive construction will have the effect that I want to accomplish. &amp;#x200B; Use your hands to draw the bunny! instead of trying to form a hand shadow puppet bunny. Why *should* the compile-time implementation of an algorithm be unrecognizable from the run-time implementation of the same algorithm in the same language? Not having to solve these types of *inverse problems* saves lives! (and is quicker, more maintainable, easier to each, ...). I enjoy solving puzzles, but what I love more, is building real things(tm) with C++, and feeling and being productive while doing it. Sure, I will shed a tear for that template-based compile-time sorting network I wrote a while ago (maybe I'd print it out, hang it over my desk!). And then I'd like to decomission it in favor of code that is expressive and concise.
Can you share which irc channels you mean?
Its for total beginners but you introduce primitive types, structs and arrays in a single video? Sounds confusing as hell for a total beginner
Now, imagine to port that on all the different platform Spotify works on :v
I should have clarified that this is not the first video in the series. I just started with structs to get a baseline. I'm going to make a separate video on for/while loops, arrays, functions, and variable types (all separate videos). Given that you assume I cover all these things in past videos and this video builds on that, what do you think now?
That's not a function pointer, that's a template class named `std::function`.
Well if you want to make a guide for total beginners i would start explaining what a compiler is, hello wrld syntax, primitive types and their sizes (and why those matter), operators all before i start with structs
Sounds awesome! Thx for the answers.
\+1 on this, proper CMake support would be great! Also, even if you decide to keep using json, please bundle the resources into the compiled source code (via an \`#include\` directive for example). Otherwise any project using this library will break once the original resources are changed/deleted. Also please don't include dependencies directly as there is no way for outer projects to use different versions of the dependencies without easily breaking something.
In practice this should never matter. Declaring multiple variables with the same type in one line is a major C-ism from the days of when we used to put all the variable declarations, uninitialized, at the very top of the function scope. In C++, you should declare variables as close to use as possible, and initialize them as much as possible. Pointers should always be initialized to NULL if no valid value exists. With that in mind, sometimes it makes sense in code like void *first = NULL, *curr = NULL, *last = NULL; But even then, it's only marginally more readable than void *first = NULL, void *curr = NULL, void *last = NULL; and really just saves you some typing.
declare it with const const int nNumber = 3;
If it's something that needs to be mutable beforehand, you'd want to protect it with a lock of some sort. That is, every piece of code that writes to that value would have to obtain the lock before actually writing. If you don't own the memory there's not much you can do.
didn't work
If you are talking about freezing the memory of an external process then there are two philosophies: * Writing the same value over and over in sync or as fast as possible * Patching the process so that it has no access to change that value. To truly freeze it you have to patch the byte code(external) or hook the function that changes the value(internal). Imagine a class function void DecrementAmmo(int value). To add a no ammo loss cheat you could patch this function with lots of nop's so that the value has nothing writing to it, making it "frozen".
https://gist.github.com/seanbaxter/e0e18cbd65095699369773cab924fa56 I think this will satisfy both our needs. It should be very easy to implement. Also, metafunctions go through overload resolution and can be made member functions! You could put all your data into an ordinary class, then define many macros as meta member functions for generating different kinds of content from that asset. The difference from what you wrote in that top snippet is that you wouldn't for loop over branches to generate arbitrarily nested control flow. You'd just call buildBranch recursively, and it would deposit the generated statements into the right place.
That's great to hear! Could you link to the github repo (or similar)? I can't find anything by searching for it :/
No, not that I know of. I checked recently because I thought it always had operator overloading, seeing as how it's based on C++ syntax... but I was surprised to find out that it didn't.
That's not the function that we are looking for big optimization in. That's the worst optimized one that he started with. Read the article and you will see what is going on. We are looking for optimization in the `HashAdditive` class defined in `hash_additive.h` which is being tested with a Gosper Glider Gun in `TEST_GUN(Hash_Additive&lt;2 * 1024 * 1024&gt;);` on line 358 of `life.cpp`. Its `step()` function goes like this: void step() { HashCell *toSet = 0; HashCell *toReset = 0; for (HashCell* cell = full_list.next; cell != &amp;full_list; cell = cell-&gt;next) { if (cell-&gt;live) { if (cell-&gt;neighbours &lt; 2 || cell-&gt;neighbours &gt; 3) { cell-&gt;next_action = toReset; toReset = cell; } } else { if (cell-&gt;neighbours == 3) { cell-&gt;next_action = toSet; toSet = cell; } } } for (HashCell* c = toSet; c; c = c-&gt;next_action) { set(c); } for (HashCell* c = toReset; c;) { HashCell* next_action = c-&gt;next_action; reset(c); c = next_action; } } If you can work some optimization magic on this function and/or the entire `HashAdditive` class, then that's what would change the results of this article. I suspect that CPU Cache optimization is lacking and the use of `std::unordered_map` and `std::unordered_set` instead of `std::map` and `std::set`. Probably only used them because of translation from Java.
This book is very organized when compared to Malik’s c++ book. It’s just much more thorough while providing better examples and explanations.
JUCE has one of the worst websites I've seen; which does not leave a good impression for a GUI library developer. Then again, QT's website is complete trash as well.
If you just want a constant value, use `const` or `constexpr` to keep the compiler from letting you modify the value. But that isn't the same as "freezing" a value that's been dynamically computed. In that case, you would want to flag a part of memory so that future `store` instructions fail silently. This is really not C++, as the language itself has no such concept. I'm going to assume you're working on Linux. I don't know how to do any of this shit on Windows, and I don't care to look it up, but it's probably possible. The basic trick is [`mprotect(2)`](https://linux.die.net/man/2/mprotect), setting the page `PROT_READ`. This will cause the MMU to generate a segfault on any write access to that page. You can then set [a signal handler for SIGSEGV](https://stackoverflow.com/questions/2663456/how-to-write-a-signal-handler-to-catch-sigsegv). You can define your signal handler to do nothing except patch the instruction pointer to skip the store instruction--getting this right is non-trivial thanks to variable instruction length. Keep in mind this may be quite incorrect at the site of the fault. For instance, imagine `x = 7; while (x &lt; 5) {};`. If you "freeze" `x` so that the `x = 7` goes to your signal trap and gets skipped, the following loop could run forever based on whatever the original value of the variable is. This kind of analysis is obnoxious to do by hand, and it's exactly the reason that there's not really a general "freeze a dynamic value" feature in the language. You'll also need to be careful about allocating your variable so that it's got its own page. If you just let the compiler allocate the variable, it's likely to be in the same page of memory as other variables you don't want to write-protect. Use `mmap(2)` with `MAP_ANONYMOUS` to allocate your page, then `mprotect()` it after you write in the value you want frozen.
Basically, any place that beginner C++ programmers come to ask questions about the language. Some years back, ##c++-basic on Freenode was a good place. I'm not sure what the best places are now, and maybe it's Slack or Discord and not IRC.
I mean a transcript of the video you already have up. \&gt; Could you please run through all the specific things I covered in the video / how I did things you found wrong? Could you also explain how I should structure the video/what things you want me to do so it's high quality? How should I improve my examples and what would you like my examples to focus on? Uhh, you're basically asking for a course plan for your video series. It's \*your\* series. If you don't have an answer to these questions, are you sure you are the right person to making one?
Generally, because std::function is a relatively heavy-weight object that allocates memory. You can use it to store lambdas for later evaluation. If you just want to pass a pointer to a callback function, std::function is a bit overkill.
You might be interested in the Windows Subsystem for Linux -- Windows can natively run ELF now (but I'm doubtful about linking to kernel32)
There are multiple issues with that, like it being a Linux application, and WSL being Windows 10 only. And I think you're right with it not being able to link to Windows libs. As nice as the thing is, it's not really a solution to this problem.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt;will containers of void be zero in size aka is sizeof(void) = 0 &gt;yes, no, depends, maybe If you needed a collection of whatever type and you get given a 'void' most would expect that, at the least the container passed back is effectively empty which requires specializing. or that nothing is returned back which still requires specializing. I don't see how this proposal actually helps simplify the language in a way that's more performant or simpler to use. It reads to me like more gatchas which is never the goal of sane design.
[bgfx](https://github.com/bkaradzic/bgfx/blob/master/README.md) If I remember well, CEF being used for the ‘views’ (whatever it means in this context), so using something like the above library (which should cover all supported platforms and more) would give a much lighter and faster UI. Sure, it requires more work than wrapping up web pages with a self contained browser and call it an app. Btw, the web pages works fine on desktop so I find these ‘apps’ even more pretentious.
Why would you expect that? It would effectively require breaking the post conditions on every method. Take vector for example. Push_back has a post condition that the result of size() has increased by 1. For your hypothetical container special cases for void, every post condition would have the "except for void" qualifier on it, instead of treating void equivalently to an empty struct and having no special cases. I'd personally expect the result of push back with a generic type is that the size increases by 1.
And yet another case where "feedback" from the c++ community just consists of nitpicking minor points that are completely irrelevant for the general quality of the video and whether it is well suited for teaching newcomers c++ or not (I.e. this is also called bikeshedding).
That's fantastic, Shah! You will never learn it as well as you will when you have to _teach_ it. I strongly encourage you to _keep making these._ We computer programmers tend to be blunt with our criticism and stingy with our praise as a matter of culture. I hope you take all of the critiques in this thread as the helpful assistance they are intended to be. The mere fact that you are making them at all is impressive. Even if you only make them for yourself, these videos will be really valuable.
I might be missing something, but overall I don't think beginners teaching beginners C++ is a great idea. They're going to have a hard time getting away from bad habits. Have only skimmed through the video without sound, and I noticed doing stuff with raw arrays. In my opinion, std::array should be taught instead.
yes, but in most cases it does the same thing, right? So why use an error-prone c-style function pointer?
how heavy weight?
People keep forgetting that GNU obstack has been a thing for ages. Among other advantages, it doesn't have to follow exact scope. There's no point in using the heap only as a fallback. The stack isn't magically faster than any other hot cache line, it's mostly just the *number* of calls to malloc/free that matter. If you do large enough calls ...
The primary feedback was not to show using std, which I agree with. Far too many examples show that and it's so hard to break people of the habit -- better to start out right.
That wasn't the discussion. Of course you should use something like `std::function` when you can.
Not overly so. It allocates memory (but a good implementation won't, for very small objects). In most of your code that doesn't matter, but in your hot path it might become noticable. The only way to know for sure is to measure.
I really was confused about the whole namespace thing because nobody introduced them properly even though it would be such an important and easy topic to cover for beginners. In every tutorial there is 'using namespace std;' but once in RL it's considered bad practice. I really never understood why namespaces are not covered at an early stage.
Dude I've been rather kind in only picking up on the namespacing. Don't be a brat, it's not an opinion, it's a basic courtesy and sign of competence. If you help people poorly, then it's a bigger issue for someone else to overcome your teachings and explain why, why, why the cargo-cult doesn't make sense. It takes years to get so good there can be only opinion-related feedback. There are easily explained reasons and sources why, just use google * https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice &gt; The problem with putting using namespace in the header files of your classes is that it forces anyone who wants to use your classes (by including your header files) to also be 'using' (i.e. seeing everything in) those other namespaces. and &gt; Library Foo 2.0 could introduce a function, Quux(), that is an unambiguously better match for some of your calls to Quux() than the bar::Quux() your code called for years. Then your code still compiles, but it silently calls the wrong function and does god-knows-what. That's about as bad as things can get. * https://www.quora.com/Why-should-one-avoid-using-namespace-std-in-their-C++-code &gt; Besides used-to-be-dreaded names such as min()/max(), log()/exp(), string/list&lt;&gt;/queue&lt;&gt;/deque&lt;&gt;, etc., to keep one’s modern C++ code clean includes making sure it’d abide by the rules of the next revisions of the C++ Standard. &gt; For instance, begin()/end() were not part of `namespace std` as of C++11. Now they are. * C++ Coding Standards: 101 Rules, Guidelines, and Best Practices ISBN 978-0321113580
ok, should have phrased the question different. "Why would you teach beginners c-style function pointers instead of telling them to use std::function?"
I'm sorry you've had this experience. I've linked in another comment to some sources. The information is out there, quite readily, but I know what you mean sometimes if you get unlucky early on it can be much more effort to course correct.
That's exactly what I'm talking about. Small details like that (just as tons of other small guidelines) are completely irrelevant when you start learning the language. None of the drawbacks apply in beginner programs and even if it results in bad habits (not everyone actually agrees that this is a bad habit, but that's another discussion) it is very easy to correct once you start on serious projects and certainly at work, where you most likely have a company rule about that. There are much much more important aspects to teaching c++ than if the examples follow this or that guideline (some of them mentioned in other posts), but of course it is easier to throw a "you violate guideline X comment " than pointing out actual problems or making suggestions that would actually improve the video, so we throw out the simple stuff that creates a lot of noise, but doesn't really improve anything and leave it by that. It's a bit like people that believe, just because your code follows misra coding standards it is safe, bugfree and most importantly magically does actually what it is expected to do.
That kind of implies you should use std::function whenever you need a function pointer
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqjgnt/best_resources_for_a_c_newbie/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's not about whether using namespace std; is right or wrong. It is about that - in the context of a tutorial for beginners - there are so much more important things regarding the quality of teaching material and I find it sad that feedback on reddit and other channels involuntarily centers around little details like this than things that actually matter. Things like whether to use namespace std become relevant once you start to develop c++ professional or on sizable projects and there you'll have some company/project rule to anyway. Again, I'm not disputing the validity of your point. I'm complaining about the order of priority people seem to assign to various aspects of the tutorial.
So they can recognize the syntax and use it when they have to? I'm all for championing smart objects over raw pointers, using STL abstractions as often as possible, but sometimes you can't always use them. Interfacing with C, sometimes you need to pass function pointers to things. Or sometimes you don't have C++11 at your disposal, so you have to use raw function pointers, or you want to implement your own version of `std::function` (or use boost, but not everyone can or wants to use boost, either) I mean, I don't see anyone saying you should actually use function pointers, but being aware of the syntax is useful.
I totally get that, but isn't that a bridge you can cross when you get to it? (don't know if that makes sense) Teach them how to use std::function and when they ever need to interface with a legacy C code base or want to write their own implementation of std::function they are hopefully at a level where they know what to research to get there. It's like teaching them to use char pointers and printf. Yes, they should see it at some point, but in general it's not a good idea to tell them "look, this is a 'string' and here is how you print it", because they will do it and be unhappy about it
In the sense of optimizing things, logically if you're doing no work you don't want to pass back a container. It's not exactly ideal just for the sake of consistency with every other type to have to allocate a bunch of space that stores literally nothing, do the book keeping for it, and pay the instruction cost to do no actual useful work. That's why I'm saying its useless for performance, the only case in which promoting 'void' to a full type is of any vague use is when dealing with template meta programming or just generic programming.... but that makes it perform worse than a hand rolled solution defeating the entire purpose of good generic code. Thus since its worse people are going to have to remember to build in the specializations anyway defeating the point of the proposal.
thats also ignoring the fun cases with other generic programming... template&lt;typename some_type&gt; [nodiscard] some_time make_type(); pass in nearly everything and that may have a way of dealing with it, pass in void... and what does it even mean to deal with checking the return of something 'void'? Is this just going to turn into a noop after the compiler realizes nothing actually happens? then whats the point of adding the complexity to deal with. It also runs into the problem then with 'void' now being an object and by all sane convention... void do_something(); should have no logical return type as no one cares about it, as indicated by the function signature. The proposal attempts to fix one issue when dealing with generic programming (having to specialize for specific types) but doesn't care about the other cases in which you can have mixed requirements (move only/copy only/non copy or movable/pointers/const/etc..) which all require annoying piece wise specializing.... it only solves one tiny logically simple case, while moving the complexity of dealing with things from an easy compiler error forcing you to deal with it to a hidden optimization.
&gt; I might be missing something, but overall I don't think beginners teaching beginners C++ is a great idea. I teach mathematics. It is a mysterious and bizarre fact of human psychology that sometimes a student can teach another student better than the instructor can. As reasonable and intuitive as your response is, it turns out that [decades of research supports the validity of peer teaching](https://www.teachthought.com/pedagogy/the-definition-of-peer-teaching-a-summary-of-existing-research/), and [a lot of research has gone into figuring out why](https://www.opencolleges.edu.au/informed/features/peer-teaching/). It's not a substitute for professional instruction, nor is it a silver bullet. But that there are situations in which it works very well for both student teacher and student learner, while counterintuitive, is undeniable.
Modern C++ 14 or 17 tested Libraries for common internet protocols, low-level components of, operating system compatibility and high-level functions, schedulers, distributed computer algorithms Teaching materials, including diagrams to show decisions and trade-offs in algorithms and their variants. It makes me so mad to hear "this has O(log(n))" when that is a part of the story that usually depends on a very specific setup or set of conditions and only one facet (reading).
And I think you are really wrong about this instance. Much easier to avoid topics than prematurely engage in them. They could write a library that takes the necessary parts of stdlib into tutorial headers with a makefile include "tutoriallib.h" is all this would take. When I used to teach games programming I'd always make a library or something equivalent like assets for people to get started with.
Thanks for the answer, that's interesting. I thought I could be wrong on that one, considering how common this is. Also great of you to link sources.
Would it be possible to make 0 parameters the same as a single void parameter, instead of introducing an explicit void syntax/special-casing cv-qualified/named void? Keeping void fn(); the same as void fn(void); and making it legal to do fn(fn())?
It wouldn’t matter much if it were a hobby project. But if it’s as you say a large project and you’re working with other C++ devs, it can be a problem. Also you’ll have to do manual memory management to any new object. Anecdotally, the old unix kernel had a program with heavy typedefs and defines that the program looked something like Pascal. I found it funny and I’ll post it if I could find it.
We're just wildly the off-topic now. No one was actually suggesting anyone use function pointers. The only reason why they were brought up was in the context of having the asterisk on the variable name.
This would provide precisely the way of "dealing with" nodiscard. The same way you deal with nodiscard with every other type- you either assign it to a variable that you then use or you cast it to void. The mixed requirements are piece-wise specializations that apply to all types, and can often use the exact same call syntax and be dealt with by perfect forwarding, whereas void requires an explicitly different call syntax. The purpose in my mind of generic code is not to be as performant in all cases to hand rolled overload sets, but to work with as many types as it is likely to come in contact with in exactly the same manner. Nothing prevents you from, for example, creating a collection that compresses objects whose known storage space is less that a byte, but the special casing this has introduced into vector&lt;bool&gt; as a general purpose container has caused lots of confusion for questionable benefit. Similarly nothing about this prevents you from writing an error prone specialization that returns a container with no storage for void, but the different behavior of its iterators and return types would likely cause confusion and require still more special casing in generic contexts.
Ah, you're right, my bad. But digging deeper into `HashAdditive` I found some problems that are even more serious. Every time a cell becomes alive it is allocated (with `new`, which is a problem in and of itself, but I digress), and every time it dies it is deallocated. Allocating from a pool (like Java does) will always be faster than allocating from the OS, so IMO an apples to apples comparison should be overloading operator `new` to get the cells from a local preallocated pool instead of asking the operating system each time. That said, overloading `new` in this way is kind of tricky to get right, so a proper implementation should stop trying to fit a Java-shaped peg into a C++-sized hole. Also, if I understand correctly, each step he's building a linked list of the cells to be set or reset? That sounds bad too, both in terms of caching and the latency to get the next node. I noticed that he tested it against my suggested implementation with `clear()` and it turn out faster, but I bet that's only because the extra latency of the linked lists is hidden by the lots of allocations being done each step.
If it is a personal project, go wild. If it is useful, your users and contributors might even put up with it. But in a professional Java development team, it is a terrible idea.
I was referring to hobby projects. Obviously this is a very stupid thing to do if you work on a team.
So many downvotes... What did I do wrong?
I mean honestly most suggestions are just pretty bad. I would say the effort is applauded but that doesn't mean people feel obligated to take the suggestion. Coming up with a good suggestion for C++ takes tons of expertise, judgement, and reading of prior art. Most proposal authors just don't have all that. So they come up with something, and people are nice and encouraging at one level, but also very critical technically. This is discouraging no doubt but there also isn't an easy fix that I can see.
If these cosmetic changes make you feel more comfortable, more power to you. &amp;#x200B; Experienced C++ devs will find the typedefs confusing and redundant public: declarations distracting. &amp;#x200B; The most important differences between C++ and Java are not syntactic but semantic: manual memory management, deterministic destruction, monomorphic template instantiations, ODR, undefined behavior, etc. These will cause you problems that cannot easily be cleaned up. If using the cosmetic macros let you focus on these deeper issues, great; if the macros are an indicator of how willing you are to adapt to the differences of C++, not so great.
This runs exactly counter to the purpose of this proposal: to avoid introducing new special casing for void. You could define a function that works this way under this proposal. If you declare it as: ``` void fn(void arg = {}); ``` You would have this behavior, which is the same as for every other C++ type. The only way void is different, which only exists to prevent breaking existing code, is that for every other type: ``` T func_name(U); ``` Declares a function callable with a single arg of type u, but no name for that argument. This is as true in C as it is for C++. The only exception to this is void, where that same syntax declares a function callable with no arguments. I (and this paper) would argue that this type of special casing is a mistake; if you want a function callable with no arguments, declare a function callable with no arguments instead of relying on a unique, non-intuitive legacy syntax from C.
&gt;The question is, is it a bad idea to write this way for large projects? Memory management looks like a main problem that way. It is unless you plan on never having anyone else ever work on it/maintain it besides you.
since you are asking explicitly: that you have to ask this question is the problem, you are missing the fundamentals. if you think writing c++ like java makes sense in any way
That's what I meant. I mean obviously it's completely stupid to do that with serious, team projects.
oh, ok. I must admit I did not watch the video. I kind of assumed he was teaching it, sorry
So if I get it correctly, I should only post things about serious projects and team works? I know how to properly write c++ code and I know the fundamentals. I made this post because I was having fun with my own projects and used different coding styles etc and I'd like to see more opinions. It's something completely "for fun". Obviously that's very stupid to do on serious projects.
r/cpp_questions
just to get you an answer because it's simple, -g outputs debugging information into the output file, and -o allows you to set the name of the output file. Here's a link to the GCC manual that covers everything you want to know. [https://gcc.gnu.org/onlinedocs/gcc-8.3.0/gcc/](https://gcc.gnu.org/onlinedocs/gcc-8.3.0/gcc/)
My b
Wait, I don't know if it's a Pascal thing, but how did they define the c and v arguments of main *in* the definition?
Good questions! &amp;#x200B; g++ is a compiler for c++ programs. It takes c++ source code (text) as input, and produces executable code (binaries) as output. When running on the command line, programs often need to get some input to enable various options, or tell the program what to do. These are called "flags". &amp;#x200B; `-g` and `-o` are examples of command line flags. &amp;#x200B; `-g` enables debug output - this means that your program will have some extra information in it, so that when it crashes, you have more information to find out what went wrong. This flag doesn't take any extra information, if `-g` is present, then the debug output will be there, otherwise it won't be there. &amp;#x200B; `-o` is a flag that takes an argument. Here, that argument is `myFile` (because you typed `-o myFile`). This tells the compiler what the name of the binary should be. You can remember this because `-o` is short for "output". (sorry, I don't have a great mnemonic for `-g`). If you don't specify `-o`, usually some default filename will be used (in many cases this is `a.out` for historical reasons). &amp;#x200B; Finally, notice that you also provide an argument to g++ that doesn't have any flag component, `myFile.cpp`. This is just a regular argument to the program, but it needs to get specified. &amp;#x200B; You can find out more about flags that programs take by typing `man programname` in the terminal (so here, "man g++"). Unfortunately the g++ manual is very very complicated (I can almost never find what I'm looking for), but many programs are simpler. Try `man ls` to see the options that "ls" can take. &amp;#x200B; Different languages will often have their own compiler, which takes its own set of flags. Java's is called `javac`, Rust's is called `rustc`.
Thanks! Which section would I look for these kind of commands? What are these commands called?
No that’s old pre-ANSI C. Function signatures were like int function(a, b) int a; int b;
Ok, TIL.
I honestly have a hard time following this code, but I think you are onto something with the allocation not being from a preallocated pool. I didn't realize Java did that, and that sounds like it's exactly why the C++ is slower.
&gt;I made this post because I was having fun with my own projects and used different coding styles etc and I'd like to see more opinions. It's something completely "for fun". Obviously that's very stupid to do on serious projects. perfectly fine, you wanted to know, that's exactly the reason why you got so many down votes.
But why?
Because I was bored?
[removed]
So enjoy... But come on it is not a good idea to do a real project this way...
Interesting thought, sounds like a challenge :)! I'll certainly look into it, if only for the educational journey. Haven't even used `std::ratio` before, that u/parnmatt and others mentioned below. Looks like a very slick API indeed.
Go to GCC Command Options section. [https://gcc.gnu.org/onlinedocs/gcc-8.3.0/gcc/#toc-GCC-Command-Options](https://gcc.gnu.org/onlinedocs/gcc-8.3.0/gcc/#toc-GCC-Command-Options)
Thanks for the feedback! &lt;3 Agreed on json files and the dependency, that has bothered me as well. I think I'm going to convert them to compile-time const data structures in headers (similar to what u/TheLartians suggested), and make the load-from-json functionality optional, so you wouldn't need to depend on json, but can if you want to load custom maps.
Great hint on other working spaces! That got me to look over the code and clarify a bunch of things. To address your question, for now I want to keep the API simple and see how it feels in practice / how people will use it. I got excited though and added low-level *sRGB* and gamma compounding, as well as conversions to and from *Adobe RGB*. On alpha-blending, I haven't included any (yet), as I assumed most blending operations would happen on the GPU anyways. I do see how that would be useful though, even for one of my own current projects. A couple of relevant blending functions is not too much to ask, afterall :).
Is it the same idea of PMR ? Monotonic?
Curious question, reflected myself for a second. It's a couple of reasons, really. First, as described in the readme, I like to use colors in my projects, be it for console output or real-time data visualization. Over the years I have created a bunch of helper classes and functions. *vivid* brings all of those snippets together under one (hopefully) streamlined and clean API. Second though, I finally wanted to start an open source project of my own and get it out there. This seemed like a great candidate. I love the community out there and am happy to contribute, so this is kinda \`doing my part\` ;). I also hope that someone out there might find this library useful, find joy in his or her newly colored console logs, and have a great day because of it. Cheers!
&gt;nholthaus/units Ooh, that's good inspiration. On to learning new cpp tricks ...
Quite the opposite. Here's a snippet to illustrate it: https://gcc.godbolt.org/z/DZqUUf `sizeof` `std::function&lt;int()&gt;` is equal to 32 bytes compared to 8 bytes for a function pointer.
Why would you want to do that?
&gt;and make the load-from-json functionality optional, so you wouldn't need to depend on json, but can if you want to load custom maps Please [think twice before introducing optional dependencies](https://youtu.be/k99_qbB2FvM?t=3031) (50:31-53:20).
Ha! Perfect excerpt. And good point, noted. Dipping my toes into best practices, one after another.
Is it? Do you not package up your code into a debian package and create an AWS image from that?
&gt; That's why I'm saying its useless for performance, the only case in which promoting 'void' to a full type is of any vague use is when dealing with template meta programming or just generic programming.... but that makes it perform worse than a hand rolled solution defeating the entire purpose of good generic code. Err, what? Did you read the proposal at all? The main use case is situations like this: // Invoke a Callable, logging its arguments and return value. // Requires an exact match of Callable&amp;&amp;'s pseudo function type and R(P...). template&lt;class R, class... P, class Callable&gt; R invoke_and_log(callable_log&lt;R(P...)&gt;&amp; log, Callable&amp;&amp; callable, std::add_rvalue_reference_t&lt;P&gt;... args) { log.log_arguments(args...); R result = std::invoke(std::forward&lt;Callable&gt;(callable), std::forward&lt;P&gt;(args)...); log.log_result(result); return result; } This code breaks if R is void. Wouldn't it be nice if this code could just work generically, without needing a special case? If the code just worked and did the obvious thing, how exactly would it be slower than hand rolled code? This sort of thing comes a fair bit in generic/library code and it's really annoying.
It's my pleasure! I have discovered there is a lot that is counterintuitive when it comes to teaching technical subjects, and I'm always trying to learn more about how to do it better. Something that is important for me to keep in mind as the professor is that _I_ myself am actually an extreme outlier in the sense that I was able to learn really well in the environment I was taught in, whereas that's not most people's experience. It might be flattering to my ego to pretend it's because of my superior intellect, but that explanation is a little too convenient and simplistic when I can see for myself how the potential within my students can be unlocked with different keys, so to speak. In other words, what makes me so unusual is that *the system actually works for me.* Those of us who have been able to succeed academically have done so for an abundance of reasons many of which have more to do with how we happen to fit into our learning environment. I also think learning is far more of a social activity than we give it credit for, especially for those of us who have spent a lot of time alone with our computers learning!
I completely agree. It's such an easy thing to explain. Why make things harder by saving it for later? Especially when it involves `using namespace std`.
The sooner you outgrow the compulsion to make one language look like another so it looks superficially familiar to you, the better.
First of all, I'm more familiar with C++ than Java. Secondly, it was a GODDAMN "FUN" EXPERIMENT to make the syntax look like java OK? Why is everyone so goddamn serious, like I was planning to do that for really serious projects? I'm not stupid. I made you the favor and deleted this post, happy now?
An example of what one type of view might look like "under the hood": struct view { int* begin; int* end; }; That's a simplified example of a "pair of iterators" view. It's extremely cheap to copy the view itself because it's just two pointers. The important bit that maybe is causing your confusion: copying a view doesn't copy the _contents_ at all; modify the contents of the view and you modify the contents of all views of that data! That's why they're called _views_ and not _containers_. :) You can iterate over that pair of pointers in a loop. You can pass that pair of pointers to the range-constructor of a container (eg `vector`) to copy the integers from the view (this operation is obviously not as cheap as copying the view itself). The other kinds of views are generally about as simple as the one above. A counted view is just one iterator and a count (no more complex than a pair of iterators). A stateful view may be even simpler (a single integer for something similar to `iota`) or arbitrarily complex (an input view over the result set of a database query).
in the case of dealing with any container it breaks the desired effect of calling/invoking a function with no return type, namely that it doesn't do anything and it surely doesn't have a cost in allocation. The mentioned changes make it possible to have a std::vector&lt;void&gt; be properly formed, and a simple way of implementing an aggregate invoke with... template&lt;typename itr_type, typename type = itr_type::value_type&gt; std::vector&lt;type&gt; invoke(itr_type begin, itr_type end); passing in a itr to void will give you a ton of allocations when the expectation when calling whatever callables may be stored, is that nothing happens when you pass void. A temporary object popped into existence and then ignored isn't really going to cause much of a problem because it's just going to get removed due to optimizations, it becomes a problem when it has actual performance side effects. Here's an easier argument that the committee will love: void func1() void func2(void) normally those would be the same function signature (ignoring function name) with current rules (hold over from C) but with the proposed changes func2 is now entirely different from func1. "but this doesn't come up ever" A ton of C libraries have this style of function calling breaking all kinds of compatibility with libraries.
Related: https://arxiv.org/abs/1904.08555
No. That would be silly. Just image with pretty much any of the stock images, and have CI or your deployment scripts copy up the binary/ies, and maybe some config files. Statically linked C/C++ code doesn't have a whole raft of dependencies. Who wants to have to keep recreating images and reimaging AWS instances all the time?
Because I'm bored, is there anything wrong with that?
Your argument is basically "there's at least one situation where there's better to specialize separately for void return to achieve better performance, therefore this is useless". This still lets code work without special casing in many situations, and in some of those situations, it will be perfectly efficient code. Yes, when you want to call callables from a user repeatedly and stuff them in a container, the generic code will not be optimal. But there are many common cases where that's not happening, like in the example I gave (which I've come across many times). I'd go so far to say as the most common usage of void as complete types will be cases where there is no performance hit. Backwards compatibility is a perfectly valid argument, it's just not the one you were making before. Maybe that will outweigh the benefits and this proposal will get rejected for that reason. But I see complete void as very useful and hope that we do get it.
For the last part: no it's not, for compatibility reasons, the behavior of void func1(void) will not change under this proposal.
my original argument was: this proposal makes it easy to make poor performance, and make it difficult to figure out where the performance issue is coming from. With the current way its setup, dealing with a function that returns void, or somehow worming void into the types you have to deal with; must be explicitly dealt with. The concern being that there is a performance impact, or a logic bug that would propagate.
You asked for feedback and you got it. Quit whining dude.
&gt; Declaring multiple variables with the same type in one line is a major C-ism As far as I'm concerned, it's just as archaic in C as it is in C++.
My general belief why Video Tutorials don't work, while well done education can, is because you cannot know what your students know in a Tutorial. In a solid education environment, you can know what prerequisits the studens have mastered. If I want to teach C++ programming concepts, doing it via geometry, algebraic mathematics, recipie analogies, assembly mappings, mechanical analogies, circuit analogies, another programminf language, or even literary/story structure -- *anything* to have something to hang the concepts on and give the student a scaffold to build on. A generic "C++ for beginners" cannot assume *any* of that. Which means you, in practice, end up either hanging it on nothing, or hang it on some unknown prequisite. Both are going to have huge failure rates. Traditional CS education tries to hang programming on methematics; most first world arwas have 12 years of mathematics educarion before university, so you can assume a little bit. Throw in few years of algebra, calculus, finite and linear math and you can get a set of common concepts in your students, which translate surprisingly well to muxh programming. Of course, the general lack of mastery based education means people show up with varying amounts of mastery of the prequisits, which causes chaos and failure. Plus students who are "here to learn to program" resent being taught the "irrelevant" mathematics. So it all ends up a mess. I have no idea how to solve this.
you can always get started and resume the teaching at a later time
Not necessarily, see ZST in Rust. I.e. if you have a type with `sizeof == 0` you can make it so all containers work naturally. Since the above means there is only one possible instance of the type, containers end up simply incrementing their size on push_back without allocating any actual storage. Though I doubt it's possible to retrofit into C++ in a backwards-compatible way.
Your words are more disparaging and not encouraging or supportive. i AM the right person. i WILL spend hours pouring through 1200+ page tony gaddis textbook. I actually reviewed Ch 11 (Strucuts) which is 40 pages before I made the video as a test/sample. I was just asking if you could point out more specific criticisms directly from the video which you didn't like and what you wanted to see improvement. I wanted advice for how to structure my vids because this is a FEEDBACK thread. I am not a teacher but I feel there is great nobility and passion and humility in teaching programming. C++ is low level af and I want everyone to know they can program it. I will spend the hours doing what you tell me. Please just point me the right way.
This book is responsible for me knwoing everything I know today. I am a finance undergraduate student in a school with no CS department (just an information system/data analytics department). It taught me everything I know.
It was actually a mistake. I was pretty nervous the entire time.
at least you stuck around long enough to learn
STL algorithms are an extremely obvious case: why would you write boilerplate for absolutely no reason?
I'm super interested in this. Have you published your work on this?
This is a good idea.
Aren't you overreacting? You posted about doing something most of us have seen many times before, and many of us tried to do ourselves. So basically, your post seemed to be about when Santa Claus is coming with the presents. It seemed appropriate to tell you that Santa Claus doesn't actually exist. Afterwards you pointed out that you already know the truth about Santa Claus, but we're not mind readers. Your post seemed to be from someone who still believes in Santa Claus.
These are great! Thanks. Helps to see a partition implementation in particular, and to know that those other examples work for sure. &amp;#x200B; This might actually be enough to use it cautously :) previously my issues were with nested namespaces and using namespaces, but I can avoid that. &amp;#x200B; Thanks for the link! Saved.
If you can manage, check out [Starting Out With C++](https://www.amazon.com/Starting-Out-Control-Structures-Objects/dp/0133769399). You can find a free PDF of the book with a simple google search. Move through the chapters and do the practice questions and exercises at the end of each chapter. If you can manage that, you will better off than 95% of any other students in your future introductory CS courses.
I use `std::function` because almost all of my callbacks are member functions. If you use raw function pointer, suddenly you have to do things in C way by giving it additional `void*` and a global function that casts that pointer to the actual object and calls member function. No, thank you.
Thanks a ton! What IDE should I use?
I'm using NetBeans personally since that is what is installed on the computers at school but I'd imagine you could get by with pretty much any of them. I use NetBeans with Linux and Windows 10. If you're still on the fence about which one, go for whichever one looks prettiest. Eventually you'll develop your preferences.
Awesome. I'm very excited to begin what will hopefully be my future career in programming.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqpfes/help_find_segmentation_fault/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
There’s tons of resources online. Premier C++ is always recommended. As for IDE it doesn’t really matter, my school uses Visual Studio. It’s just preference. Goodluck you aspiring Engineer.
But it seems reasonable to assume the systematic error is uniform across algorithms. If we're measuring differences of means, (additive) systematic error should not be a consideration.
Taking many measurements with uncertainty is fundamentally how statistics is used to predict a quantity. If you increase your sample size, your sample mean gets closer to the true mean, converging to the true mean as the number of samples increases without bound. This is called [the law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers).
This is not correct. From my other comment below: &gt;Taking many measurements with uncertainty is fundamentally how statistics is used to predict a quantity. If you increase your sample size, your sample mean gets closer to the true mean, converging to the true mean as the number of samples increases without bound. This is called [the law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers).
I wrote my web application's server in C++. I have a chrome extension that connects to my c++ server along with a multiplayer game that uses a c++ server.
Would you mind sharing how you ran the partitions example? I copied your \`partitions\` directory and added target_compile_options( PRIVATE "-fmodules-ts" ) but the build fails :/ I'm not sure how yours compiled without the above command-line option, so now I'm curious as to how our approaches are different.
I have a feeling that if lambda in default argument already provides uniqueness, we don't really need friend injection... By the way, what part of standard requires that each instantiation gives different lambda types?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqqn4e/help_needed/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I’d start by reading the rules of this subreddit.
&gt; Your benchmarks are not deterministic, and therefore not reproducible as well as may be influenced by outside factors [_Every_ software benchmark is nondeterministic](https://tratt.net/laurie/blog/entries/why_arent_more_users_more_happy_with_our_vms_part_1.html). Sufficient randomization is necessary in this case to avoid accidental bias. &gt; You're reporting the mean, which is almost completely useless, you should be reporting the median [Negatory, good buddy](https://www.researchgate.net/publication/236583161_On_the_expected_difference_between_mean_and_median): &gt; This means that for [the normal and uniform] distributions the uncertainty in the median is bigger than in the mean. For symmetric (non-skewed) distributions the expectation value of mean and median is the same. So there should be no difference between these two apart from uncertainty. But if it bothers you, measure them both. I would be surprised to see a significant difference between the two, and a small difference would indicate the superiority of the mean as a measure of central tendency.
Cplusplus.com Cppreference.com
Wonder if this be useful for emulator dynamic JITing, if I ever get around to something more complex.
https://www.oreilly.com/online-learning/ I’ve used this paid service in the past. Give the free trail a shot and see if it’s beneficial for you.
QtCreator is free and snappy. You will find the latest binaries here: https://download.qt.io/official_releases/qtcreator/4.9/4.9.0/
There's a free version of Visual Studio which is very good.
Indeed they are. &gt;why would you write boilerplate for absolutely no reason? If you want to write less boiler plate, then the standard library algorithm interface is really not what one should use.
your way of speaking is way too.. laid back and casual and frat-bro'ish for absolutely anyone's taste. additionally you are hard to understand. bad audio quality or you need to learn to speak better, independent of the aforementioned style point. also video is a terrible teaching format.
main criticism: why video?? why not articles. because articles are a fucking ton more work but way way more useful
Yes, similar to std::pmr::monotonic\_buffer\_resource. &amp;#x200B; It focuses on providing convenient syntax for making alloca-like allocations from a reserved area of thread\_local storage, but I imagine it could have also been implemented as a small wrapper around std::pmr::monotonic\_buffer\_resource by using suitable initial buffers.
It only uses C++11 so I image it should, but I haven't tried it.
Right, the goal is to get performance gains by allocating memory from pre-reserved, thread\_local regions that act like an extended stack and thus avoiding calls to malloc/free. I don't claim that the memory you get is anything special, just that you can avoid heap allocations. &amp;#x200B; obstack looks interesting. I don't know that it quite the same thing as it's a lower level and more general purpose c library; but I expect you could implement something similar on top of it. I do think there's value, though, in providing a convenient C++ API for making function-scoped memory allocations that can provide many of the same performance benefits as alloca.
I’ve approved this post because it’s sparked a fair amount of mostly useful discussion, but I’ll caution against excessive flaming.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bqp5sw/self_learning_c/eo75z6o/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Then why don't you tell that to the OP? &gt;Much easier to avoid topics than prematurely engage in them. Pointing out straight forward style guide violations is simple. Giving feedback that substantially improves teaching material is hard (same for code actually. Loosely related: I'd recommend to listen to the recent cppcast episode with David Sankle (http://cppcast.com/2019/05/david-sankel/) and what he had to say about the article about the top 25 API mistakes (https://www.acodersjourney.com/top-25-cplusplus-api-design-mistakes-and-how-to-avoid-them/) I really think that priorities seem often to be heavily skewed in the c++ internet community.
Thanks. I added [benchmark results](https://github.com/rnburn/stackext/blob/master/benchmark/README.md)
finally we can do compile time metaprogramming at runtime !
Yeah, and you’re just a fucking prick who’s clearly superior in knowledge. All the other people have commented how I can improve and you came just to disparage me. I’m not a teacher and I just need some help improving my videos. I’m comfortable with C++ and know how to use the language. I doubt you wanted to give me advice more so come here to take out your anger on me. Get life instead of insulting a stranger on the internet because you think you’re superior to others
Congratulations, first of all. This is what happens when a committee fails to recognize the issues of a language and fails to respond to the pressing needs of developers. The single most important feature that I want, and many developers want, in C++ is to able to work with the AST at compile time. The only real solution is what this guy has done: to allow any C++ code to be executed at compile time. Code executed at compile time shall return a new AST tree which is integrated into the existing one or modify the existing one. All C++ development should stop right now in order to get this in the main language. It is that important.
Looks disgusting, but I like it!
Last time I checked llvm could already do that in the python API at least. Compile to x86 in RAM so that you can immediately call it. So what does this do?
first off.. you're the one who just said you know you can do a better job than everyone. no. you can't. and that's just arrogant and foolish. also, you need to learn to take criticism more graciously. my criticism stands and is valid. i didn't sugarcoat it. if you need it sugarcoated, in the future just put that in the title of your post "please sugarcoat criticism" so i can just ignore the post, since sugarcoating things is NOT my style.
Good, working terrible workarounds for the lack of regular `void` was becoming cumbersome :)
Copy the up where? Do you not cycle instances through auto scaling groups? Image creation is super easy and any new machines that start will use them, you only need to create the image once per code release and AWS handles the rest.
Yeah I couldn't find it either. Matt doesn't respond on Slack, but maybe here: u/mattcalabrese
&gt; Then why don't you tell that to the OP? I've taken the view that perhaps OP doesn't know until they were told. Because of your and others utterly unwanted diatribe, they may now be further confused as to how bad that is, and file it under personal preference. I'll also take the view that OP may be able to write code I'll need one day, and that without the right practices when writing that code, it might make it significantly harder for me to use if they don't get over this. &gt; Pointing out straight forward style guide violations is simple. And? As compared with snarking over the choice of critique it's dust in the wind. &gt; Giving feedback that substantially improves teaching material is hard You're in a programming sub-reddit, so I'd assume you have some clue about iteration. Think about what that might have to do with substantial improvements. Clue: they don't have to be biblical in scale. It's okay to give lots of straight forward advice from many sources than to dive the deep seas as a beginner. &gt; Loosely related: I'd recommend... Thank you for your unsolicited recommendations. What do you think of the speed controls on CPP cast? &gt; I really think that priorities seem often to be heavily skewed in the c++ internet community. I really don't care about your thoughts and feelings. I was not looking to start a speakeasy, public venting space or platform for your frustrations at your perception of a "c++ internet community".
2003 is the earliest paper I've seen, so 2000 is about right for the start of discussion.
The problem here would be const-west being inconsistent. const on the left always means "pointer TO const", consider: const int \*, int const\* -&gt; pointer to int const int\* const -&gt; const pointer
The reflection TS has been published. https://www.reddit.com/r/cpp/comments/au0c4x/201902_kona_iso_c_committee_trip_report_c20/
I wonder how they will solve `f(void)` problem since practically every C library uses this syntax (because it has to) and C++ keeps it for compatibility.
Get a life.
I'm not the one bragging that I can do a better job than everyone. So I think it's you who needs the life :)
It really should be default when requesting compiler for sufficiently recent c++ standard.
currently still using _MSC_VER, or use __cplusplus with a .prop file added to every project&amp;config, which has /Zc:__cplusplus defined.wish it could be default too
If you want you can check out my project [CPM](https://github.com/TheLartians/CPM) to see how I handle dependencies in my projects. I like the idea of using CMake to download and configure everything as it works with all platforms and adds no visible dependencies from the outside (besides CMake).
“Too frat bro ish” to understand, what part of that was remotely appropriate or even necessary? That wasn’t any criticism or constructive advice. That was you blatantly making fun of me over your keyboard when the post was literally about me trying to educate people because I know how hard C++ is. You then move to saying “videos are a bad way of learning”, completely removing the purpose of your comment. It’s obvious your Cheeto guzzling, neckbeard virgin incel ass has nothing better to do. Go get a life instead of making a sorry ass pathetic attempt to insult me when I’m trying to upload educational content. If you’re so superior why don’t you make your own videos so we can criticism them? Oh wait, you don’t know shit and you’re probably a shy unconfident loser. I’m glad you realized I’m a college student who has some meaning to my life!
This provides easy way to use those APIs without requiring user to learn LLVM-IR
Suppose I'm a kid and wrote that I believe in santa Claus. Kids are always having fun and make funny stuff. So you should join them in their fun and maybe believe in Santa Claus too, ie tell me your own experiments with the syntax of the language. Instead, you and everyone else was like "boy santa Claus is a freaking fairytale, grow up and stop believing in stuff like that". Everyone here and also developers I've met are the reason I want to give up programming because of this attitude. You're all like "I'm a dev, I do everything right, you're a 5 year old doing stupid things". I really can't stand people with that attitude. Anyway, I've learned my lesson and I won't post bullshit again on this subreddit.
has it ? from what I can see the draft has been sent but nothing official has come out of it yet : https://www.iso.org/standard/76425.html?browse=tc
Yeah, I got that. The overhead seems small and in 99.9% of all cases not overkill. So as long as you don't really identified it as a problem/bottleneck no one in their right mind should use function pointers in modern cpp code
in visual studio 2019 it's not default for c++14. Maybe you mean the flag is added by default when you create a new project.
&gt; The stack isn't magically faster than any other hot cache line I thought the stack was fast because allocation is incrementing your stack, and deallocation is (destructors) + decrementing your stack again A lot of my memory allocation is scope based, so a simple linear allocator (or stack) would work great for me
The documentation states that a patched CMake is required. The "how to use modules" command template has that flag included.
I disagree. Imagine you want to generate HTML page with some kind of templater that generate output HTML file using some king of template like this: "...&lt;table&gt; {{ for $i in $array }} &lt;tr&gt; .. $i\["username"\] ... &lt;/tr&gt; {{ for }} The faster you do this the more clients you can handle per second and hevier DDOS attack can hangle. So C++ matters.
Reading the article it seems this will probably happen for 20.x: &gt; We’ll continue to require use of the /Zc:__cplusplus switch for all minor versions of MSVC in the 19.xx family. But I agree that setting the compiler to be standard compliant should not require a switch to be set...
As MSVC is C++14 by default and does not (and will not) provide switches for earlier versions using any `/std` switch should also update the macro.
Nice list especially for beginners. Some more advise on overusing auto would be great.
This looks like policy-based design.
I've seen similar extensions before, although they tend to work on preprocessed code and not during translation. Can't remember their names off the top of my head... it's been a long time. There's a lot of overlap in the feature set for the work I've been doing over the past few years (the stuff that drives the metaclass proposal). There are also use cases mentioned, especially in this thread, that haven't been in our set of use cases: transforming branches, for example. We've been cautious about trying to turn C++ into a optimizers playground at the expense of compile times. The evaluation model looks interesting especially since it looks like you can interleave meta and non-meta code. I have some thoughts about what's going on behind the scene, but it's pure speculation. Reading the white paper, yes, there are alarm bells going off because these aren't constexpr functions. But it's not because "it's different and new"; it's because the compiler has a security hole big enough to drive a truck through. We can now deploy malicious libraries (a package manager's dream!). ``` @meta system("echo "HAHAHA! I'm evil!"; rm -rf ${HOME}"); ``` Or maybe open a socket. There are lots of things we can do! Maybe there's a whitelist of allowable functions, but it's not documented. Also, any contract violations of extern functions may lead to UB. Not so great for compilers trying to run your code while compiling your program.
Nit-picky, I know, but at the beginning ‘a_float’ is actually a double... One of the problems with auto overuse, IMO.
Thanks. I somehow overlooked that sentence in the article. Guess that makes it virtually worthless in header code for the foreseeable future. I had hoped MS would be much more aggressive about updating the c++ defaults for VS2019 (e.g. also enabling permissive-), but I guess that it is more important for most customers that their old code works as expected without modifications with the new toolchain than the reduction of MSVC specific workarounds in new code.
 std::pair&lt;std::string, int&gt; user = {"M", 25}; // std::pair&lt;std::string, int&gt; std::pair user = {"M", 25}; // std::pair&lt;const char*, int&gt;
To overuse auto, simply add aux variables: auto x = foo(); auto &amp;&amp; x1 = x; auto &amp;&amp; x2 = x1; etc.
Interesting project, and it looks like a cool API. :-) The reason everybody isn't already doing this is that the performance benefit is likely to be much smaller than what you might think. It may be possible to avoid a number of branches by generating specialized code on the fly, but the generated code cannot contain things like inlined functions from the host program. Add to this that actually compiling and generating the code online incurs a very significant computation cost as well. I would expect that a globally optimizing JIT would outperform this in many cases, unfortunately. Still, there can certainly be applications where this is legitimately useful. :-)
The use of auto is not the problem here. It is the auxiliary variables that is being overused.
Does '26.04' deduce to double type ?
You can mitigate the template spam slightly by doing: Projectile* as_proj(){ return this; } Projectile const* as_proj() const { return this; } then `as_proj().SomeTemplateMethod&lt;A,B,C&gt;()` does not need `this` or `template`. Another approach is to make your template methods free friend functions.
[String literals][1] to the rescue! [1]: https://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s
 auto merge(auto data, auto upcoming_data) Please don't. Don't do that.
Hi, Mike here from The Document Foundation, the non-profit entity behind the LibreOffice open source office suite (successor to OpenOffice.org). Our community is running regular workshops to help people learn C++ features, and as most of LibreOffice is written in the language, some experienced devs are available to answer questions in a live IRC session too. Hope to see you there!
IMO they're the dumbest addition to the language
Only because the Gnu extension template &lt;class Char, Char ...C&gt; constexpr some_type operator ""_some_suffix(); was not standardized. template &lt;class Char&gt; some_type operator ""_some_suffix(const Char *str, std::size_t len); is much less useful, because you cannot iterate an array in a constexpr function.
First of all, I have to apologize: my comment is not going to be about the content of your post. But I have an excuse: I couldn't force myself to read it because of your design decisions. High-contrast background that makes half of your data completely invisible is not a very good thing. Look at your diagrams. Either black links are invisible (if the diagram is at the bottom), or blue links are invisible (if it's somewhere around the middle). The white text is almost unreadable around the highlight spot. Scrolling the text makes me lose the paragraph I was reading, just because the part my eyes were following suddenly becomes 3 times brighter or darker. It wouldn't be nearly as bad if you didn't shrink the text (which is completely pointless since you are using only 30% of the screen), but you did. Bonus points for making the title dark red: it completely dissolves the text when you scroll it up so that it overlaps with the top part of the image. US army should try making a camouflage using this trick, surely it will outperform all the existing ones. I mean, it's your blog, so feel free to do whatever you want, but I'd suggest either making it human-friendly, or (if your goals are the opposite) going all the way and changing font to Comic Sans.
I will get the code released and push there before the mailing. All of the frontend work is done and all existing and added clang tests are all passing, except new/delete, for no reason other than I got that far and then was busy with personal things. I may just push sooner if anyone wants to help out. What's left now is operator&lt;=&gt; support and [[no_unique_address]] support for void, though I don't think clang is capable yet of that. The implementation can also be improved -- I model its implementation as an integer in clangs internals, but it should probably be closer to an empty struct -- this was only done because it seemed easiest due to my inexperience hacking on clang, and it made it easier for me to get constexpr/non-type-template parameter support going, using integer types as an example.
yes. `26.04f` would be float. without the 'f' its type is double
Please do not be afraid to be more vocal about this. When I last presented it got a 2/3 majority (waiting on implementation), but some influential people still didn't think there was enough motivation. There is a perception that only experts care about this. In my opinion, this is as much about improving generic programming as it is about simplifying the standard and having a more consistent type system, which we should care about just as much.
They are a very good example of how the language is becoming stupid because of backwards compatibility.
Exactly. This is also not different from any other pointer type where alignments are compatible. A pointer, in general, can have a value that is the address of an object of some other type. You should only dereference and deal with an instance of that type if you know that's what it actually is.
- `auto merge(auto a, auto b)` is not valid c++ syntax. i belive its a gcc extension. auto parameters is only valid for lambdas. - lambda capture section is missleading. you may alter values which you capture by value. just add mutable in the lambda declaration. this may - situational - be a better solution then just plain capture by reference: your lambda could possible outlive the scope and local variables are already destroyed - the examples of class template argument deduction for pair and tuple are also missleading. the deduced types may supprise you (as already meantioned in the comments here)
So what type do you want string literals to have by default? std::string? std::string\_view? or perhaps std::u8string\_view?
`std::string`
&gt; is not valid c++ syntax. i belive its a gcc extension. auto parameters are only valid for lambdas It's valid C++20 :)
Something like that? https://godbolt.org/z/dAT0rT #include &lt;type_traits&gt; template &lt;class&gt; struct Tag{}; template &lt;class T=int, auto Fn=[]{}&gt; constexpr auto test() { return Tag&lt;decltype(Fn)&gt;{}; }; int main() { constexpr auto a = test(); constexpr auto b = test(); static_assert(!std::is_same_v&lt;decltype(a), decltype(b)&gt;); return 0; } I don't know enough arcane magic to turn this snippet in a working meta-programming library, or if I these lines are useful at all.
OK, but then if we don't want to pay the cost of having to construct a std::string object each time we use the string literal we would have to use some other, perhaps more verbose, syntax?
Sure, it works as advice on how to overuse auxiliary variables. Not sure why people want to overuse features, but I'm a people pleaser.
Could you write a bit of documentation about the differences with Boost.DynamicBitset?
;-)
While I agree with the overall spirit of that, you reason about this slightly incorrectly. You would not want a container to be empty (assuming empty meaning .empty() always returns true). What you'd ideally want is a container whose elements do not contribute size, in terms of bytes, to the overall container. Because of [[no_unique_address]] of C++20 you can get some of the effects of this for some container kinds, but without the language having more direct support for *true* size 0 types, we cannot do much better implicitly. I allude to this in the paper, but the ideal would be that size 0 types could/should exist (not just void, but any empty type, of which we have many), and, at least for such types, there would be no unique addressing guarantee. Similarly, arrays of such types would not have pointers as iterators, but instead would need counting iterators. I do not see any clear way forward to that world in C++ for which we could get committee approval, so it is not a part of the proposal. I would like to pursue it eventually and would encourage and help people who care more deeply about it, but I am much less confident in that ever happening. That said, direct containers of void is not the main use-case here anyway, and is absolutely no different from the "problems" of containers of other logically empty types like std::monostate. It would be fantastic if these were always completely optimal, but that requires much more fundamental changes to the language, or alternatively, partial specializations in the library. In practice, though, such situations do not come up often enough even in generic code for the gains to matter. Even if we could get it through committee, it wouldn't be a huge practical win, even though it'd make me personally happy on principle. Instead, I just focus on what can get through committee with the most compelling impact. The real win from the proposal here comes from the many simple generic functions and datastructures, such as those in the paper, such as the log example, [good] async-like operations, future and promise types, and algebraic data types (variant, optional, expected, tuple, etc.). In most cases these functions/types do not support void at all, even though void can easily pop up as a dependent type when working with them, and in other cases (future/promise/expected), there are specializations that *try* to support void but necessarily have inconsistencies and are tricky to specify in the standard and require additional implementation and testing. The regular void proposal makes these work without specialization at all, and [[no_unique_address]] even removes all unnecessary space overhead in many of those cases. The proposal also allows *users* to easily write code that correctly works with a dependent void type when it comes up, and without needing to manually do metaprogramming. It works out of the box like any other scalar type.
IIUC in the [ranges](http://eel.is/c++draft/ranges) library, all these nested types are effectively obsolete. - `T::value_type` =&gt; `iter_value_t&lt;iterator_t&lt;T&gt;&gt;` - `T::pointer` =&gt; ... not provided. It's not like they are useful today. - `T::const_pointer` =&gt; ditto. - `T::reference` =&gt; `iter_reference_t&lt;iterator_t&lt;T&gt;&gt;` - `T::const_reference` =&gt; `iter_reference_t&lt;iterator_t&lt;const T&gt;&gt;` - `T::difference_type` =&gt; `iter_difference_t&lt;iterator_t&lt;T&gt;&gt;` - `T::iterator` =&gt; `iterator_t&lt;T&gt;` - `T::const_iterator` =&gt; `iterator_t&lt;const T&gt;` - `T::reverse_iterator` =&gt; `reverse_iterator&lt;iterator_t&lt;T&gt;&gt;` (or `iterator_t&lt;decltype(reverse(std::declval&lt;T&amp;&gt;()))&gt;`?) - `T::const_reverse_iterator` =&gt; `reverse_iterator&lt;iterator_t&lt;const T&gt;&gt;` (or `iterator_t&lt;decltype(reverse(std::declval&lt;const T&amp;&gt;()))&gt;`?)
&gt;Here's an easier argument that the committee will love: &gt;void func1() void func2(void) &gt;normally those would be the same function signature (ignoring function name) with current rules (hold over from C) but with the proposed changes func2 is now entirely different from func1. "but this doesn't come up ever" A ton of C libraries have this style of function calling breaking all kinds of compatibility with libraries. No, please read the paper before commenting. I talk about this very explicitly and the proposal does not do as you describe.
Just from a quick look 1) Thanks for supporting `add_subdirectory`. 2) I would consider internalizing the libpopcnt dependency. Optional dependencies that affect the ABI/API (that includes using them in the implementation of an inline function) can lead to trouble in some (rare) cases due to ODR violations. By internalizing I mean, maintaining a copy of the the libpopcnt header as part of your lib, but with a custom header name and all identifiers/macros wrapped into a custom namespace. 3) The usual: Whats the difference, how does it compare to other implementations like boost::dynamic_bitset
Perhaps it would be possible to avoid unnecessary copies by storing some kind of static string and let the type be `const std::string&amp;` but this would still require slightly more storage than a C string.
I talk about this in one of the papers. In brief, that would not be logically correct and it can even cause problems in real code if you were to do that.
I just read his functional programming book, and thought it was very good. I'll listen to this later
So I might be able to use this at work before I retire; and even then, it probably won't pass code review
This is my project of WebGL/WebSocket browser game entirely in C++ and pure JS: I parse websocket and keep all data in the single process. http://fintank.ru
My issues where indeed about generic programming, where the lack of support for `void` (except for returning the result of a function returning `void`) makes many things cumbersome. For example I had to hack together [this nasty thing](https://github.com/Morwenn/cpp-sort/blob/develop/include/cpp-sort/adapters/out_of_place_adapter.h#L71#L85) using scope guards to "solve" an issue frankly similar to the one in the "Motivation" section of the paper. But even scope guards only made it into the LFTS and not into the IS, so even the workaround isn't batteries-included.
Or you can use composition and not have that problem ;)
And then all your old code goes into the [commode]?
It broke a bunch of the "Real World Code" projects that we regularly compile (in March 2018). I'm not sure if we reported issues upstream for them to be fixed, but this was an indication that the whole C++ ecosystem isn't ready. Right now, the best thing you can do is apply `/Zc:__cplusplus` to as many codebases (open-source and proprietary) as you interact with, and fix any issues. Customers do indeed hiss when we break their source code, even if such breakage is mandated by the Standard. We try not to let this freeze all improvements, but we still have to be mindful of how much breakage we cause, and whether it's "worth it". The `__cplusplus` macro, while highly visible, is not as important as other conformance issues (as it's been this way for 20 years, and the world has kept turning), especially since it's easy to write a small preprocessor layer that detects `_MSVC_LANG` and `__cplusplus`, hence the slow movement here.
STL has it exactly right. When we made the change in default mode we discovered that many projects (including common libraries like Boost) used `__cplusplus` and `_MSC_VER` in conjunction with each other. The interplay of updating the `__cplusplus` value to the standard defined one yielded some interesting results.
&gt; It broke a bunch of the "Real World Code" projects that we regularly compile (in March 2018). Could you share / link to a few of those instance. I'm curious, what kind of checks such code performs. The article states things like &gt; Your code might be using this macro to determine if it’s being compiled with MSVC or Clang in MSVC-emulation mode. I con't really imagine what that looks like in practice (although I can imagine the opposite: "If __cplusplus is greater than x, then we must be on gcc or clang"). All that aside: I agree that it isn't really important (in new code I'm usually going for feature test macros anyway - thanks for adding them also when compiling in older c++ versions).
Do you happen to have some examples at hand?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bqxam2/looking_to_step_up_my_c_game_looking_for_a/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Oh I see, I didn't check the other branch before. No worries mate :) I starred the repo; whenever gcc and cmake both work I'm sure I'll look at your work again. Thanks for your effort!
[There's a whole section of the paper devoted to it.](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0146r1.html#UnaryVoid)
Direct data includes: *done* ([include/vivid/data/](https://github.com/gurki/vivid/tree/master/include/vivid/data), auto-converted). I'll leave json in for now as I think it's a quick and convenient way to build and share custom color maps. Cheers!
Is there a qualitative difference between a compile-time and a run-time security hole?
Creating a unique type is one part of the solution. If you can't refer to previous unique types and link them together then you can't do much with it. `c++ template&lt;auto = unique()&gt; void func(); func(); //creates a unique type some_stuff(); //no way to get the unique type used by func(), so no way to increment or change anything without keeping track of all previous unique types which is no better that incrementing by hand.`
&gt;I misunderstood the article.Is it possible to compile for both Windows and WSL? On the same solution/project I mean. Yes. In fact you don't even have to have Visual Studio solutions and projects at all. I demoed how to set up a CMake project targeting Windows and WSL at Microsoft BUILD (starts at 5:28): [https://www.youtube.com/watch?v=h41\_MI4eJCc](https://www.youtube.com/watch?v=h41_MI4eJCc) &amp;#x200B; For targeting WSL, we have Clang and gcc configurations available by default (same goes for targeting remote Linux devices).
&gt;I'll be interested the day VS runs natively on Linux...Meanwhile I'll happily just keep using QtCreator Have you looked at Visual Studio Code? It has Remote Development support now too, which is compatible with the C/C++ extension: [https://devblogs.microsoft.com/cppblog/vscode-cpp-may-2019-update/](https://devblogs.microsoft.com/cppblog/vscode-cpp-may-2019-update/)
Thanks! I can't right now but I'll watch it later.
Only if the optimizer is off. In practice, it's little different than the (bad) builtin multidimensional arrays.
I don't know the standard by heart but reading the latest draft of the adopted [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0315r4.pdf) and how default template argument aren't mentioned I would have to guess it's a normal side-effect of allowing lambda in evaluated contexts and it doesn't seems to go against the paper. Default arguments being evaluated while parsing more of a python design. template&lt;auto&gt; void func(); func&lt;\[\]{}&gt;(); func&lt;\[\]{}&gt;(); Shouldn't be different from template&lt;auto = \[\]{}&gt; void func(); func&lt;&gt;(); func&lt;&gt;();
Couple other notable links: - http://wg21.link/index.txt - https://github.com/cplusplus/papers/issues
Jason Turner has a great talk about object life time. Also using available perf tools can help minimize wasted computation and memory usage.
That's a good idea, I will look into boost::dynamic\_bitset to list the differences in the (not yet done) documentation.
Another obvious one is compile time fixed containers like maps and such. Or const std::arrays.
Thanks for your feedback, &amp;#x200B; I want to keep the library integration super simple (copy paste dynamic\_bitset.hpp) and libpopcnt optional, but you are right about ODR problems. At the moment, if the master project already have libpopcnt and uses the dynamic\_bitset with libpopcnt, the libpopcnt submodule path will be added to the include paths and there will be two libpopcnt.h in the include paths. I will add a CMake option to use libpopcnt without the submodule for projects already using libpopcnt. &amp;#x200B; The cocumentation is not done yet, I was thinking about making it with doxygen, and adding a CMake target to generate the html version. &amp;#x200B; I will also list the difference with boost::dynamic\_bitset but I already know the main one (one of the reason I made my own dynamic\_bitset): the dependancies. I wanted my bitset to be standalone, unlike boost:: that [rely on many other boost libraries](https://pdimov.github.io/boostdep-report/master/dynamic_bitset.html) making it very cumbersome to integrate without requiring all boost libraries to be installed on the system.
&gt;Another obvious one is compile time fixed containers like maps and such. Not sure hat you consider a compile time fixed container. Even if the values you are going to store are known at compiletime, std::map and std::unordered_map are still allocating their nodes at runtime from the heap. The specification of standard containers is just I'll suited for small embedded systems and at the same time there are so much better designs out there, so I don't see the benefit of trying to implement a standard's conforming version of them for an arduino. And honestly: Even many of the algorithms are not really ideal. There interface is more cumbersome than necessary 90% of the time (can't wait for std::ranges) and on an arduino, I usually don't sort a million elements or some such, so I don't really care about BigO requirements in the standard.
Yes. We generally expect compilers to faithfully translate the code we compile. If it doesn't do that, then the binaries it produces are not trustworthy and potentially malicious. A readily exploitable compiler is really little more than a trojan horse manufactory. https://www.archive.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf The problem with giving free reign to compile-time evaluation isn't that a module might open a remote shell -- which is pretty bad -- but that user-defined code might subvert the translation of otherwise well-formed programs.
Not very important but would probably be nice to namespace it.
Yeah, I made it about a third of the way through before I bailed out. My vision still has lines across it.
I'm not sure I understand how `std::ratio` would work here. Lots of colour space transformations are non-linear and thus cannot be represented by a ratio. For example, the [sRGB gamma function](https://en.wikipedia.org/wiki/SRGB#The_sRGB_transfer_function_(%22gamma%22\)) needed to get linear color intensities out of sRGB values is defined piecewise, with an exponential section and a linear section.
I learnt C++ with Primer it's a really good book! I'd love to see all the C++14, 17, 21 additions documented.
I never said I was superior. In fact you're the one who said that you can do the job better than everyone. Also, regarding you actually telling me to come fight you irl. I'm waiting for you to confirm that building you live in :)
Would you recommend primer over programming principles as that’s what i’ve just ordered?
Your solution is an edge case of strategy design pattern (known as policy-based design in the C++ community).
My advice: leave it as an int with value 0 or some other kind of builtin scalar (which would probably end up in `APValue` as an int with value 0). Leave classes for user-defined types; `void` ain't that. Also, if you make it a class type, the compiler is going to have to generate special member functions. You don't gain anything by going the extra mile.
When you do, don't forget to put "It's not boost" as one of the main differences. That might sound sarcastic but it's not. The day we removed boost from our codebase it dropped compilation times in half and object sizes by 3 times.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/br0gwz/help_me_please/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`std::ratio` is only a way to store a ratio's numerator and denominator. You cannot include a floating point number within a type, but you can a `std::ratio` as it's just another representation using integer values. `std::ratio` comes with functions that do mathematical operations on these types (https://en.cppreference.com/w/cpp/header/ratio) if you can write the conversion using `+`, `-`, `*`, `/`, `==`, `!=`, `&lt;`, `&lt;=`, `&gt;`, `&gt;=`; then you can write the conversion with these functions. it will not be pretty; but the conversion would be fully encoded within the type itself; and you would use a `using` or `typedef` if you prefer the older syntax, to alias the type to something readable. Conversion operators will probably be more than enough to handle the static checking. I only mentioned it, as the units library using `std::ratio` types, which allows a user to operate on values with dimensions, and *actually* be safe ... like not allowing a value of length to be added to a value of time; however, it will easily add a meter to a foot.
My email archives don't seem to contain a list of the RWC breaks. IIRC, they mostly took the form of code guarded for C++11/14/17 that had never been exposed to MSVC, and was triggering warnings and errors due to platform differences like type sizes. Glad to hear you like feature-test macros. I pushed hard to add them, after changing my mind about them :-)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/br0lz8/how_do_i_check_for_left_mouse_being_held_down/eo95y57/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Don't engage in flamewars and especially don't talk about violence, even jokingly. This is a moderator warning.
Not really on topic, but do you which parts of boost you where using and what you replaced it with?
&gt; [tip]: Don’t reference to draft as it might change, it’s best to select a published C++ version (or a final draft before publication). Mild disagreement. In MSVC's STL, we freely cite Working Paper drafts, since we can't wait for the International Standard to be published before implementing features. And it's not like the IS is crystalline perfection, either; as Core and Library issues are resolved, and proposals improve wording, WPs often have clearer wording than the last IS. Because drafts are fortunately immutable, we cite them like this: N4810 13.8.3 [temp.expl.spec]/7.
the lack of constexpr templated user-defined string literals in the standard sort of crippled c++17.
On VS2013 the second one won't work. error C2955: 'std::pair' : use of class template requires template argument list c:\program files (x86)\microsoft visual studio 12.0\ vc\include\utility(81) : see declaration of 'std::pair' error C2514: 'std::pair' : class has no constructors 1&gt; c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility(81) : see declaration of 'std::pair'
What's new in this version?
That's because Class Template Argument Deduction is a C++17 feature. You should upgrade to the latest version of VS.
The level of detail in Primer is much greater. I have read both and would recommend the Primer over Principles, especially if you are relatively new to C++
\[I arrived at this post from here: [https://atilaoncode.blog/2019/04/24/type-inference-debate-a-c-culture-phenomenon/](https://atilaoncode.blog/2019/04/24/type-inference-debate-a-c-culture-phenomenon/), so my comment is actually a reply to such post. But given that it's in the topic of \`auto\`, I'll share it here as well.\] Indeed, this is a relatively common debate in C++. In my opinion, there are reasons for that. First, in regards to \*type inference\*, we can't put C++, C#, Go, D, etc. into the same bucket as Haskell or ML. Deducing the type of a \`auto\` variable from an initializer expression is no big deal. Whole-program type inference, on the other hand, is a science matter (e.g., [https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner\_type\_system](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system)). If I have an inferred variable in C++ and I want to write a function taking a formal parameter whose type (modulo inheritance) is the same one of the variable in question, I'd have to really know it so that I could write it down in the function declaration. Or… I'd make such function a template, with which we enter a whole new universe of complexity. C++ templates allow for real duck-typing (like in D) and become, during compilation, legitimate inhabitants of the type system. This is not exactly the case of generics in C#, where type information is carried through metadata in the runtime - or even in Java, where type information is completely lost due to type erasure: [https://en.wikipedia.org/wiki/Type\_erasure](https://en.wikipedia.org/wiki/Type_erasure). In addition, C++ offers (nominal) subtyping and operator overloading, features that aren't present in a language like Go. Once we stack piling up such different forms of polymorphism ([https://en.wikipedia.org/wiki/Polymorphism\_(computer\_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))), it becomes harder to "discover" the type of an expression. In fact, while certain features can, individually, be reasoned about (by computers or humans), their combination doesn't necessarily preserves this characteristic; we could even end up with an undecidable system ([https://en.wikipedia.org/wiki/System\_F](https://en.wikipedia.org/wiki/System_F)). From a more pragmatic perspective, the way that type modifiers/qualifiers interact with type constructors in C++ is somewhat clumsy… not to say that "only" the type of an expression might not be sufficient to valid its correctness, given that certain language rules take into account the \*category\* of a value (e.g., rvalue, xvalue, lvalue). For instance, the snippet \`int&amp;&amp; x = 10; int&amp;&amp; y = x;\` yields an invalid program, although both \`x\` and \`y\` have the same type. So… within this debate, I guess C++ is somewhat "special" (there are likely other reasons as well, these are just what comes to my mind right now). Yet, there does exist some discussion about the benefits of explicit type annotations even in Haskell. Also, there are contexts where the system needs a help: [https://dl.acm.org/citation.cfm?id=1159811](https://dl.acm.org/citation.cfm?id=1159811).
Ok thanks, well, principles is currently in the post via Amazon Prime so there’s no going back, least i know what to read next so appreciate the feedback 🤘
\&gt; Your words are more disparaging and not encouraging or supportive. Based on your responses so far, I would recommend gaining more experience in C++ itself and in teaching it to newbies before trying to make a video series. Video series are hard to make well and hard to update once made. &amp;#x200B; \&gt; i WILL spend hours pouring through 1200+ page tony gaddis textbook. If you're serious about teaching C++, I would expect you to familiarise yourself with \[at least a large portion of this list\]([https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/388282](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/388282)) and, again, have experience programming in C++ and teaching. (Yes, I think "by beginners for beginners" is not something that works with C++.) &amp;#x200B; \&gt; I was just asking if you could point out more specific criticisms directly from the video which you didn't like and what you wanted to see improvement. I wanted advice for how to structure my vids because this is a FEEDBACK thread. Again, I'm perfectly happy to do that if you can provide a transcript of this video. &amp;#x200B; \&gt; I will spend the hours doing what you tell me. Please just point me the right way. Once again, I don't think it is my place to make a lesson plan for your series.
Thanks for the advice -- to be clear, I'd never make it an *actual* class type for the reasons mentioned. I would only do something akin to that (and eventually piggy-backing on the C++20 generalized non-type template parameter support, as constant evaluation is where a surprising amount of the regular void change currently lives). The APValue int of value 0 is my current approach and has worked fine, but I suspected it'd be more a proof-of-concept approach rather than something long-term in clang. Maybe I'm mistaken though.
I think an important point here may be interactivity. Students mutually benefiting from teaching each other might not carry over to resources made by students being effective.
ok, suggestes workarounds like `const void` or named argument make a big sense, but for "only in dependent contexts" - I'm not sure if it is the best or the worst solution if used as the only solution
"I say let's get off the merry-go-round. I have. I just couldn't bear to write C++ anymore." That's around the 1hr and 37minute mark of this talk: [https://duckduckgo.com/?q=stan+lippman+video&amp;t=h\_&amp;ia=videos&amp;iax=videos&amp;iai=SLLOSAm-OS0](https://duckduckgo.com/?q=stan+lippman+video&amp;t=h_&amp;ia=videos&amp;iax=videos&amp;iai=SLLOSAm-OS0) &amp;#x200B; I don't discount his perspective, but I'm enjoying C++ more than ever.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;https://github.com/cplusplus/papers/issues/151 has some progress notes.
Replaced with STL version: thread, shared_mutex, optional, variant Replaced with our own version: intrusive_list, circular_buffer, property_tree, crc32, small_vector, flat_map, timer Replaced with our own version (union + enum): variant Replaced with cxxopts: program_options Removed: binomial_heap
To avoid getting anyone's hopes up, while I do plan to update the paper and have the implementation up for the next meeting, this cannot possibly target C++20. It would at most be an early acceptance (or early rejection) for C++23. Given its positive reception in Oulu and that it's supposedly just awaiting implementation and usage experience, it theoretically should be a quick discussion, but I am very much expecting certain folks to be strongly against no matter what.
I just switch to using Reader View in FF whenever I visit such graphics/style-heavy sites...
That sounds like it's not going to happen in time for C++20. Is that accurate?
No, I do not want string literals to be heap alocated mutable data. Or, I want non-heap allocated strings to be cheap and easy to create. Much like how string view makes most char const ptr and std string APIs obsolete, I don't want my code full of pointless costs.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;It's not open-source, but…Apple's [Cocoa framework](https://en.wikipedia.org/wiki/Cocoa_(API)) (since [Carbon](https://en.wikipedia.org/wiki/Carbon_(API)) has long been a deprecated zombie, naturally, and is likely about to be removed entirely in macOS v10.15…) Bindings exist, but they depend on the non-standard 'Objective-C++' language extension; standard-C++–native bindings would be epic (and actually remain on my personal long-term to-do list for an attempt at some, though as a somewhat low priority at the moment.) One would certainly need at _least_ C++ native core-language reflection to do the job properly, though.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/br21m3/help_with_direction_for_building_a_windows/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;What you describe sounds like it would probably even be extremely useful if it were connected not to a web UI, but to some other local process via another API; now I want to see you build this. Nuclear-holocaust–proof console logs, anyone? (That's likely an exaggeration, but you get the idea…)
Does it? https://www.youtube.com/watch?v=Ptr6e4CVTd4&amp;feature=youtu.be Scan + Build with modules for LLVM is faster than a headers build, and the scanner isn't as fast as it could be.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;[P1385](http://wg21.link/p1385) should be relevant here.
Yeah, im starting to really enjoy C++. If only a few things were updated and a few features added. I got my friend hooked on C++ when we started writing a game together, and he's coming from Java and Python. Now he says C++ is his favorite language.
That's what I'm describing (see above). The WebUI is just one of the features that makes sense for that process. It's not really "connected" to web UI, it is providing it as a service. We don't need perf there (like, it doesn't have to be an nginx module or something), but just being able to go and check what's up, check some graphs and possibly switch a few settings in your actual app is something that helps during the development quite a lot. Raw log-over-shmem solutions are not that rare, btw. It's just I'm yet to see good open-source ones, preferably combined with other features that are logically related (events, telemetry, etc).
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;You'd have to ask a committee member to sure, but, yes, that's what it looks like.
So what happens when your platform doesn't have a C++ heap at all?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/br2iup/best_way_to_learn/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That's fantastic, thanks so much!
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;There wasn't a new edition of _The C++ Programming Language_ for C++14 or C++17, either; you can get by with the 4&lt;sup&gt;th&lt;/sup&gt; edition, _Programming: Principles and Practice Using C++, Second Edition_, and online materials, but, now that it exists, shouldn't the Standard C++ Foundation be helping to take care of keeping all of these texts up to date…?
ok so he sent me a private message telling me he was going to beat me up and smash me and all this stuff. did he receive a warning for that?
I think it's fine, but I'm not a maintainer :) I think the hard part will be proving that you can eliminate the storage requirement from void objects, including return values. Although LLVM might just happen to get rid of it...
Mods can't see PMs (you'd need to report that to a reddit admin). However, I've banned him from this subreddit for ignoring my previous warning against excessive flaming and posting the comment that's was 4 above this one. I encourage you to learn from his example.
You'll have better luck asking on the Boost mailing list. This subreddit is not for (potential) bug reports.
Will do. Should have just reported it and not responded here. My bad.
It’s still _your_ code that does the nefarious system call. The only difference is it’s done at compile time instead of run time.
You mean 20, right?
While these articles are good as they increase awareness of "Modern C++ features", I fear we will continue to see these being posted even when C++11 is 20 years old.
That's great. Java is a waste of time imo. I'm working on adding better serialization support to C++ through this [code generator](https://github.com/Ebenezer-group/onwards). Java and C# have been able to eat into C++ with their serialization support. I hope to win some of those people back.
True, but there are many cases where the optimizer won't work for this and the performance will suck.
It's only yours if you wrote it.
I've started reading Primer but classes and structures are kind of messing with me, as someone who has only really used scripting languages and .NET VB :/
The example of constexpr is pretty bad. constexpr double fib(int n) { if(n == 1) return 1; return fib(n-1) * n; } int main() { const long long bigval = fib(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; } 1. This is C++14 `constexpr`, not C++11 `constexpr`. C++11 only allowed 1 return statement in a constexpr function, so it would need to be written as `return n == 1 ? 1 : fib(n-1) * n`. 2. Is `fib(n)` supposed to be Fibonacci? Because it computes the factorial. 3. Why is it returning a `double`? For overflow prevention? It's not clear why it's used here, and the fact that the only numeric literal is an int not a double (ie, `1` instead of `1.0`) suggests it's an error. 4. `bigbal` isn't using the return type of `fib` for its type. See previous point. 5. `bigval` should be declared `constexpr` as well. Since it isn't, it's up to the implementation whether or not it's computed at compile time (usually means it's only done if optimizations are enabled).
That's a clear and obvious violation of you-don't-pay-for-what-you-don't-use principle.
Reading the Implementation document, The key to your performance seems to rely on no two keys starting with the same two characters. I'm curious, have you tried checking how it would do with some kind of 16 bit hash? Also, I'm assuming the profiling uses a data set where no two keys share the same first two letters? What happens when they do, and are there any checks to guard against that?
According to this: [https://www.informit.com/authors/bio/ac171f5a-dfc6-43d1-bc4f-d8488c944125](https://www.informit.com/authors/bio/ac171f5a-dfc6-43d1-bc4f-d8488c944125) seems Lippman has retired. Even though, Lippman's book 'Inside the C++ Object Model' would be still relevant nowadays in the C++20 era :-)
You all are amazing. Libre Office is a great product and these workshops seem really cool.
&gt; Since it isn't, it's up to the implementation whether or not it's computed at compile time (usually means it's only done if optimizations are enabled). A `const` integer variable is usable in constant expressions if the initializer is a constant expression, in which case compilers will initialize it as if it is `constexpr`. This is needed to make this code work: void f() { const int x = 42; [] { int a[x]; }; // or struct A { void operator()() const { int a[x]; } }; }
Barbara Moo has been writing the Primer since the fourth edition. (Early authors' names are not dropped with subsequent editions.) Stan's retirement is irrelevant to whether or not there will be another edition.
That is true. I forgot about that rule of `const` integral types. However, I'd still argue it's wrong (at least for an example) for two reasons: 1. `const` doesn't guarantee that it *is* initialized by a constant expression. If the initialization of `bigval` is a constant expression, then `bigval` is a constant expression. However, if `bigval` isn't initialized as a constant expression, then the compilation will succeed with `bigval` being a runtime value. This makes using `const` less clear, and could lead to confusion if it's used in an expression *requiring* a constant expression. 2. `const` works this way for integral types, but `constexpr` works on any literal type. Just because a variable of type `const int` works as a constant expression doesn't mean that it would work if the type was say `const std::pair&lt;int, int&gt;`. Swapping `const` with `constexpr` solves this problem.
I would consider float type risky anyway. I know they use less space that doubles, but if you need precision, go for doubles.
Sorry, this is a pretty long response, but there's a lot of meat to this question **On the topic of key collisions:** So, the primary idea here is that caching prefix information will lead to accessing the packet data less frequently on average (not necessarily zero), which means fewer cache misses on average for real world applications. The case where no two keys share the first two bytes is undeniably the best case scenario, but even in the case of collisions amongst the first two bytes, you'll still only have to access packet data for the number of keys that collide, instead of the number of keys you actually compare with, which is still a win for overall performance. During the development of this library I was testing against packets that were generated by randomly pulling keys from a large corpus of English words, as I thought that would be a fairly good approximation of real-world data, where collisions *do* happen sporadically, but are still relatively infrequent. The performance that I observed for these test cases was extremely similar to what's currently posted on the repository, but unfortunately during the open sourcing process I ran into copyright issues with the datasets, and I so replaced it with a fully random test for the release. My thinking was that it would be good enough to demo the scaling properties of the library (the test doesn't do anything to try to avoid collisions), but I agree with you that a set of random strings won't have the same collision properties as a random sampling of English words. Here's what I'm thinking (I'm open to suggestions) I could go track down a different corpus and add that as a benchmark case, but it ties the results to English specifically, and I'm thinking it would be a good idea to handle this case more generally. I'll add an additional test case that works similarly to the key lookup case, but which tests an additional parameter: the percentage of collisions in the generated keyspace. That'll allow potential users to evaluate the utility of the optimization for their specific use-cases, and to be honest I also just want to see what the curve actually is. **On the topic of hashes:** As to the idea of using hashes, I actually did look into that, because the collision properties come down to that of the hash function itself (more or less independent of the data), and it DOES produce improvements for specific configurations, but the problem is that it's very finicky, at least in my experience. Part of the problem is that the hash function *must* be cheap, as it's pure overhead compared to the key-prefix approach, but it also *must* have extremely good collision properties for a 16 bit hash, for obvious reasons In the test configurations that I was running, there were only a few scenarios I could produce where this approach was a net win. If the packet keyspace is *enormous*, the prefix collisions begin to outweigh the extra hash function cost, and hashing performs better. If I skipped the final string comparison, relying entirely on the hash function for identity, the hashing approach performed better in most cases. In the case of the former, I decided that slightly worse performance in a few cases, but much better performance in many cases, was the way to go In the case of the latter, I decided that relying entirely on the hash function for key identity was too dicey of a call for me to make without the user explicitly requesting it. Ultimately I decided that the prefix approach was a happy medium that produced relatively good performance across all categories I was testing, and was likely to produce good results for most real-world applications. However, one thing that I'm now thinking about is exposing this functionality as an additional customization point. Adding something like a hashing policy which, by default, uses the prefix logic, but which can be overridden by the user to implement arbitrary hashing policies. It means moving a lot of code around, but I think I can get it done. Is that something you thing would be potentially valuable for your use cases?
Isn't there an error in this? begin is of type T\*, and end is of type T. right?
Thanks!
I sometimes think that c++ should standardize an immutable string class, which doesn't need to allocate when constructed from a string literal. Not sure, but maybe all the constexpr work will make that viable for std::string some day automatically. Would also be nice, if string litterals had their own type distinct from a char array.
Perhaps these compromises can help plug the security hole: * By default, code is read-only during compile time. The programmer has to explicitly mark regions of code as writeable. * Compile time evaluation only consists of pure computation and altering the code structure in writeable regions. Any use case that only needs to read the code can still be met. (Personally I'd like to generate serialization and DB code in this manner). * For use cases that need system access, perhaps it could be enough to only allow read-only access of some special whitelisted file(s). For arbitrary system access, it's the responsibility of the programmer -- during some pre-compilation build step -- to gather all needed data into the whitelisted file(s).
See why I need a new edition?
Just wrote one of these myself, cameout suprisingly similar!
There's a problem, though. `std::ratio` represents rationals, and the x^2.4 term in that gamma function has irrational outputs, so you would have to use an approximation. That calculation would be relatively complex, and I suspect numerator or denominator overflow would be an issue. You could avoid overflow by implementing floating point arithmetic using `std::ratio`, but that feels a little horrifying. A constexpr conversion function would be quite simple by comparison. I suppose I don't really understand what benefit the ratio-based solution would have over that.
I guess you're right - I'll move this question to the Boost mailing list.
This is very similar to [the D programming language](https://dlang.org).
Is it significantly better than VS2017?
Technically i++ implicitly allocates an extra variable. However 99.9% of all compilers will optimize this away in the context of (for) loops
It's a compiler's job to optimize stuff like that. If developer would have to think about all those tiny details they wouldn't have any time to make code ;)
Please note that this is under the assumption that i is a primitive data type. I just don't see how compilers can optimize an overloaded class operator.
All optimizers will be able to generate identical code, at least if iter is a simple type, so it comes down to a matter of conveying what you want to do. To me, it is natural that ++iter increments iter whereas iter++ is special because it keeps the original value in order to return it afterwards. Thus the preincrement operator is the operator that has the fewest requirements of the type (e.g. iter does not have to be copyable) and it is what you should use. Do not mix aesthetics with habits, which I believe you do here.
Good point
Yes, I have seen code that cannot be optimized like this, and wrote this code myself. Let's say you are iterating over records of your own compressed storage. In this case, all your operations are uninlined and placed in .cpp, all of them do a lot of non-trivial stuff, and copying an iterator may even involve allocations (let's say each iterator has a cached uncompressed element, so when you copy an iterator you copy the cache; ofc. you could try minimizing the cost by sharing the cache, but then it starts involving atomics, which is again slow and won't be optimized out). Even if the compiler saw everything you do in one translation unit, it wouldn't possibly be able to guess that these 2 screens of code are not really doing anything just because you are using the wrong operator. You should change your aesthetic preferences, especially if you plan to start writing templated code. "My algorithm works with '++iter' just fine for a vector of ints" is not a good excuse to waste someone's hour on trying to figure out why their code suddenly works 5 times slower with your template than it should, on some sort of database iterator or something. If you need a synthetic justification to use pre-increment for cases where it doesn't matter, I can give you one (it's not going to be really strong, but it will make some sense). How about "don't hide the most important part of the expression at the tail of the expression". This is the same reason why the following line is cancerous and should be killed with fire: if (foofoofoofooFoofooFOOFOO.barbarbarBarbar(aaaaaaa, bbbbbbb, cccccc, dddd) == false) And the following two lines are much better: if (!foofoofoofooFoofooFOOFOO.barbarbarBarbar(aaaaaaa, bbbbbbb, cccccc, dddd)) if (false == foofoofoofooFoofooFOOFOO.barbarbarBarbar(aaaaaaa, bbbbbbb, cccccc, dddd)) The argument doesn't really work when the name of your iterator is 1-4 characters long, but hey, you can be consistent with cases where your iterator is named currentActiveHighlightedElementFrameEdge or something.
A simpler option is to simply limit compile-time evaluation to what's admitted by constant expression evaluation, and to provide safe extensions where we need to. That's the direction that committee work on reflection is taking.
I don't think that the compiler can change directly "i++" to "++i". But when optimizing code it might end up with the same assembly. It is only for inbuild types that it is "known" to the compiler to have the same results. For custom classes it can be different. Lets assume you have a custom class which implements prefix and postfix ++ operator. The Declaration is inside a cpp and not a header file. This will prevent the compiler to optimize "i++" to "++i" usages in other cpp files. (Assuming "link time optimizations" are not activated). &amp;#x200B; I think the "aesthetic" argument is problematic. Aesthetic is kind of a matter taste and taste can change. I think it only should be used if there is no technical difference. Otherwise it is never clear if code is just written the way because it is prettier or because it has side effects that are wanted. For example \`a \* (b / c)\` and \`(a \* b) / c\` seem to be the same thing. But when you assume that \`a\`, \`b\` and \`c\` have different types (double and int) than the implicit casts might be important to the result.
Yep; that's what I get for typing code on mobile. Thanks for the catch!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
If everything about the non-primitive iterator is inlined and the compiler can guarantee that there are no side-effects, it can definitely optimize it (for example, `std::vector&lt;T&gt;::iterator::operator++` will probably fall in this category). However, many C++ programmers prefer to just default to `++i` just to be safe. Something like iterating through an `std::map` can be a lot less trivial for the compiler to optimize.
Welcome to C++. ;-) The compiler is much more constrained that we tend to think. A lot of the time it doesn't matter. Sometimes it does.
I wasn't talking about compilers ability to optimize the code. Obviously if you apply standard rules, it won't be always able to look into it. I was talking about the fact that even in your example, you expect the state of your iterator over compressed storage to be the same after increment, no matter which ++ operator you use. Therefore, from purely mathematical standpoint, compiler can assume that the result will be the same and use the other operator, regardless of what is inside cpp.
&gt;I don't think that the compiler can change directly "i++" to "++i". But when optimizing code it might end up with the same assembly. I was not talking about assembly optimization. I think compiler can assume that the operators have the same effect if you don't use return value. Regardless of implementation of those operators. I am fine with `a * (b / c)` vs `(a * b) / c`, there can be type and precision concerns. Problem starts when someone writes `a * b / c`. But that is another topic. Increment is unary operation, it doesn't concern type limitations or type conversions.
in this particular case, not much; as you are not "creating" arbitrary colour spaces; and there are a fixed number of them. as I have noted, using conversion operators are probably better; in this case, I would go against my own preference and have the operators and constructors be implicit. Thus you do not need to write all of the conversions, just a few of the more optimal ones. The reason it makes sense for the units library, is that you can construct arbitrary units on the fly, where you want the type safety, but also you do not wish to convert the actual value. The conversion operator approach would force things to convert their values all the time, rather than just when you tell it to. this usually comes about due to doing operations, like multiplying two variables of different units, etc. Such operations don't make too much sense with colours; and if you do define such operations, then the conversion operator approch is probably more than enough. I imagine mixing colours; half of this colour, a third of this one, and a sixth of this one, all in different spaces, and output a new colour. but such an interface for colour mixing would need to be thought a lot about.
Video Game Engines. Trading Systems.
I've done/am doing both of those. Also medical devices.
Modern cars software is written almost entirely in C++. Control modules, battery drivers, navigation, radio etc.
Image Processing and sometimes Microcontroller s/Embedded Systems too:)
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Cairo is good at weird shapes and has good quality output. Plus, it lets you print them as well, if you need that. If your intended license allows, you might be able to build on Inkscape, which is GPL-licensed (I think).
There is no purely mathematical meaning for the operations in question. '++i' may launch a nuke, 'i++' format your hard drive, and 'auto a = i' could launch your browser with [AYAYA](https://youtu.be/rGy6FuGdeYk) clip. There could be arbitrary side-effects, and some of them can actually be meaningful. Like, if your iterator holds a reference to a snapshot object of some database, and incrementing the refcount of that specific snapshot is triggering a diagnostic event, and you get an extra record in your log because of that, there is no way a compiler could somehow magically figure out that you probably didn't mean to do that. There is nothing that says that operator++ for an iterator must have the meaning that you want them to have. There is currently no way to tell the compiler that you imply something that is not entirely obvious (like "but in MY app compare(a, b) is always equal to -compare(b, a), why the dumb compiler can't magically figure out what I want?!"). The same is true for ++i/i++ The same is true for even for an overloaded a+b (and it's actually normal to have cases where a+b != b+a, for example where both a and b are strings). The same is true for almost all code except for a few very rare examples where we explicitly allow things to be optimized out (like RVO before we had the guaranteed copy elision; we assumed that there must be no meaningful side-effect that we may care about, so the compiler is safe to throw away some code even if it can't see what it does, and can't possibly verify that, but it doesn't have to do that). Well, there is also constexpr (which allows the compiler to make some extra assumptions about your code), but that's for different cases. Maybe in the future we'll get the ability to establish invariants, but for now if you don't want to get the wrong behavior, just don't write the wrong code.
Im not really familiar with the use of serialization. What are the big differences between c++ and java on that?
Nice. You can add: Control divergence: It's when control depends on the thread id. A thread warp (typically 32 consecutive threads) have to go on the same branch and make the same jumps (hardware limitation), when control diverges, the wrap has to go into one of the branch, then back to where the divergence started and go on the other branch. Register pressure: if there are too many thread per block, each thread has less registers. This means the code of each thread is less efficient and you can have less blocks running in parallel. Scratch pad pressure: if blocks allocate a lot of scratch pad, you can end up with less blocks running in parallel because they would run out of scratch pad space. I think CUDA provide an Excel sheet in which you can provide some information about your code and it tells you what is the architecture "bottle neck".
Seems to me like the order of the authors should be changed at some point.
If you are concerned about performance, it is a good habit to use `float` unless you know that precision might be an issue. This is because on modern platforms, `float`s are twice as vectorizable as `double`s are (e.g. an SSE register can fit four floats and two doubles, while an AVX-512 register can fit sixteen floats and eight doubles).
It doesn't matter whether it's for a small or large project. What matters is whether other C++ programmers will work on it, because most C++ programmers prefer C++ style programming when working on C++ code, even if they know Java. I remember reading the code of an open source project that even went further, writing wrappers for every class that held a pointer, so they could write e.g. A foo(A a) { a.DoSomething(); ... } where A is a class that only holds a pointer to a class that does the real work, so it works just like reference passing in Java. I found it an abomination.
Thank you for the ideas! Allocating too much resources per block/thread sounds like a good fit, same as the divergence. &amp;#x200B; I think that you're referring to this: [http://developer.download.nvidia.com/compute/cuda/3\_2\_prod/sdk/docs/CUDA\_Occupancy\_Calculator.xls](http://developer.download.nvidia.com/compute/cuda/3_2_prod/sdk/docs/CUDA_Occupancy_Calculator.xls).
The [sixth edition](https://www.amazon.co.uk/dp/0135161797) was originally due to published in January 2019. I've had it on order from Amazon UK since it was first announced last year, and the price and availability windows have bounced around considerably. It is back to "*Currently Unavailable*".
I've not read principles, but as a historically Java and Python developer I've found Primer very helpful in learning C++.
You are welcome, that's a good project, thanks for doing that! Yes, exactly.
I saw that as well, but wasn't sure if it was accurate since wikipedia says he's working at 2kQubits. [https://en.wikipedia.org/wiki/Stanley\_B.\_Lippman](https://en.wikipedia.org/wiki/Stanley_B._Lippman)
Right?!
Howard's date library has been affected by this problem. Exposing the true value of `__cplusplus` changed the definition of macro `HAS_STRING_VIEW` to true, thereby enabling the constructors from `std::string_view` \- and these suffered from a teensy bug in their implementation. This caused compilation to fail with msvc in C++17 mode. Ofcoz this has been totally unacceptable in our use-case with `/permissive-` and `/Zc:__cplusplus` as default compiler settings. My solution was fixing the affected constructors (changeset 7231a), but the lession learned is: a sequence of seemingly tiny things can cause total failure. Any there are probably cases where fixing the problem is not as easy as in this particular one.
Did you get an overflow error when you added 3.0f to the year? Be careful with float, they can mess things up!
When I searched Amazon for C++ Primer 6th edition nothing came up. But by using your link and changing it to .com it comes up and gives a release date of Sept 21st 2019. [https://www.amazon.com/dp/0135161797](https://www.amazon.com/dp/0135161797)
Yeas, please make it a regular type. We have in our [stlab.cc](https://stlab.cc) library at many places one implementation for move-only, one for copyable and one for void. That is such painful. Sometimes ago u/seanparent made a strong statement that we need this too.
A more famous example is CppUnit. It was once highly recommended because it was inspired by JUnit. But they tried so hard to imitate JUnit that they didn't think of using C++ features to do certain things. As a result you have to add code in three places if you add a test (declaration of a method in the class, definition, and add it to the test suite), because C++ doesn't have reflection. Later C++ test unit frameworks used auto registration with a macro (which is not possible in Java) so you need to add code in just one place.
I think syntax of raw pointers is broken but fixing it would break a lot of code so I'm not proposing it right now.
Views and weak pointers are kind of orthogonal. You wouldn’t ever flip a coin as to which to use.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/brabm8/looking_for_graphics_editor_library/eocbqqm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Reflection makes serialization libraries in C# really pleasant to use. That's my main gripe in C++ serialization, good deal of boilerplate
it is plausible that the c++ implementation was bad and the Java implementation was good. doesn't mean Java can actually keep up
I agree. Inheritance should be more about type classification and less about sharing code, particularly if it can be solved by encapsulation.
Java has better support for automating the creation of serialization functions. My goal is to do that for C++. These inputs: [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/account.hh](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/account.hh) [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/middleBack.mdl](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/middleBack.mdl) &amp;#x200B; Lead to this output: [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/zz.middleBack.hh](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/zz.middleBack.hh) &amp;#x200B; Java has had this advantage over C++ for decades. My approach is to try to make progress with automation of serialization/messaging.
Uhh, Holy crap, thank you. I think this is the most detailed reply I've ever received on reddit! I guess I asked a good question. TBH I'm not sure my particular situation *has* good use cases for this library - we are pretty much always in a situation where we can have a known schema, so I think Flatbuffers or even Cap'n Proto were more in line with what we were thinking. I just read the implementation docs and was curious? First, congrats on such a tremendously well written (and documented!) library. Asking about the bench mark, you've hit on exactly the thing I was curious about - seeing the collision curve would be super cool! From a usabliity perspective, I was thinking it might be nice to, maybe as a debug option, detect if you were serializing a message that had collisions and issue a warning of some kind. I'm really into the idea of offering the customization you talked about. I was thinking of some kind of constexpr name mangling function or string lookup table / token system - I recall seeing things like that in some game engines, and if you either had a good constexpr hashing function or were using string tokens &amp; synchronized the table as a kind of handshake, I think it could be pretty fast. As an aside, if you're ever changing jobs &amp; wanna work somewhere in the SF bay, DM me? This is a remarkable piece of work.
Really sad. There are so many useful libraries in boost - if they just wouldn't be stuck in c++03 and someone would work on modernizing them I'm pretty sure compiletime could at least be reduced somewhat.
they should just allow writing the type in front of variables instead of the "write the type the way you use your variable" (which btw isnt even the case anymore with references etc added) that leads to the weird type around the name crap. so allow: int\[10\] is; //currently int is\[10\] int(int) foo; //currently int(&amp;foo)(int) or something like that &amp;#x200B; wouldnt even break any code
I have a addon that just makes every site black + text white (kinda like dark mode) :) still the whole website design felt really weird. Why does everyone have to try to be fancy nowadays? Displaying some text shouldnt require javascript!
First time i heard of that version and it seems extremely powerful. Was it not proposed or is there a reason why it got rejected?
char const\[N\]. (as they are) Storing the size as a compile time constant is great. The only thing i hate about it is the forced decay. Without that we could use string literals as non type template parameters
The problem is not the standard being used but [the mindset behind boost.](http://archive.is/2014.04.28-125041/http://www.boost.org/doc/libs/1_55_0/libs/geometry/doc/html/geometry/design.html)
Yes, I find the X&lt;void&gt; specializations cumbersome in the various ways people already know about: code duplication, constexpr litter, inability to define a field, inability to have two different local declarations using constexpr, etc. I'm curious how much thought has gone std::vector&lt;void&gt;, along with other collections. Off-the-cuff I'd go with having it, meaning that accessors, pop\_back, etc return a void that is assignable. Maybe it would not be a complete abstraction, but itcwould move the boundary constexpr/overload/sfinae away from my core code.
This looks similar to kj::Promise from the Cap'n Proto: [https://capnproto.org/cxxrpc.html](https://capnproto.org/cxxrpc.html) I played a bit with it, and I found it minimal (need only CapnProto::kj, CapnProto::kj-async libraries, not the whole Cap'n Proto), useful and somewhat complete, you may want to take a look. &amp;#x200B; I also found the following ones interesting: * [https://github.com/facebook/folly/blob/2cb9738a6537596b1a8aac73ce06bdd8ee8a5a1d/folly/docs/Futures.md](https://github.com/facebook/folly/blob/2cb9738a6537596b1a8aac73ce06bdd8ee8a5a1d/folly/docs/Futures.md) * [https://github.com/tdauth/cpp-futures-promises](https://github.com/tdauth/cpp-futures-promises) * [https://naios.github.io/continuable/](https://naios.github.io/continuable/) * cpprestsdk PPL tasks: [https://github.com/Microsoft/cpprestsdk/wiki/Programming-with-Tasks](https://github.com/Microsoft/cpprestsdk/wiki/Programming-with-Tasks) &amp;#x200B; Would be interested in finding more.
My interactions with Sean at early BoostCons in the mid 2000s were a large influence on me eventually proposing Regular Void. Also, thank you and other contributors for stlab.
Thanks for providing other implementations. I'll take a look at some to see if i can spot problems with my current implementation. In general--unless the problem is hard (like lock-free containers)--we tend to keep our external dependencies at a minimum, preferring to use only std. In this case, I'm wondering if std::future is not the best bet. One big difference is that I wanted the promise chain to be orthogonal to threads, just as the notion of a callback is orthogonal to threads. An exception to this is the .get() method that I provide as a convenience. get() acts like Folly's get(), and maybe std's--in that it waits on a semaphore. Just looking at the docs makes it hard for me to imagine wanting to use std::future because I don't want C++ asynchronous constructs in the promises themselves: threading is handed entirely at a lower level in our code. So while Javascript Promises are then-able, std::promise&lt;T&gt; is a helper object and it's std::future&lt;T&gt; that is then-able. In my implementation, Promise&lt;T&gt; is the then-able object. Also, as compared to std::future there appears to be an explicit container for the value called std::promise that simply holds a value and std::future uses it. In my implementation a value is not "held" anywhere, except privately as an implementation detail for resolve(). My Promise&lt;T&gt; are simply continuation chains of functions where one function's return values being passed as an argument to the next function, and the head function is called with a value in one of two ways: a deferred() callback or resolve(). I wonder if std C++ could have decoupled the notion of continuations--i.e. then-able objects--from threading, and I wonder why std::future is currently just a waitable container of a value while there is a plan to add continuation chains to it under /experimental. My effort at making a Promise type doesn't conflate the aspects of threading and then-chains (aka the solution to "callback hell.")
You mean overly generalizing everything?
\&gt; but all the stuff I learned about python last year seems to have gone out the window to make space for cpp &amp;#x200B; The trick is to just keep coding. The stuff you think you forgot will come back to you pretty quickly when you start using the language again.
I'm having trouble to understand your title. My understanding of reversibility is the ability to reverse or undo something. Maybe you mean forgetfulness? You have two choices: Either you set time apart to explicitly learn stuff by heart, using Anki. That would be the programmer's equivalent of deliberate practice. Or you're doomed to google even the most basic things even after years of practice. If you don't write code e. g. to open files every day, it's only natural to forget. My guess is that 99% of all programmers today only rely on google. I keep files like `cpp.cpp` and `python.py` in a folder `howto` on my Dropbox. I include it in every project, so it's always handy. These files contain small, mostly incomplete code snippets of things I don't want to google for the fiftieth time.
Yes.
That's not a bad idea, definitely something I'll be doing
I like that tip of putting a local cache over common google searches
So, what happens if multiple applications are accessing the card at the same time? Does it fairly distribute load or one gets it and another is locked out, etc...?
This is only true for the most basic things like putting a semicolon at the end of the line. Things that you'll use every day. But everything else, even if you use it once a month, you will forget. An exception to this is the mean things. The little things that make C++ hard to use. Like forgetting to make a destructor virtual when you should have. You'll probably spend hours debugging it when it happens to you for the first time, pulling your hair. And once you do understand it, you'll probably remember. The more painful the more memorable.
Making them std::string would fundamentally break a massive amount of existing code, including my entire code base.
Is there a comparison between CPM and Hunter? Both are package managers written in CMake
I've not been a part of the discussions, but I believe it was considered unlikely to merge from TS. I believe std:: executor is the priority and a new future can't come before that. You might find C++20 coroutines a more ergonomic expression of asynchronisity, or actor system more performant.
Why does this podcast have a disclaimer about medical advise? Am I missing the joke?
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/brfuaw/dealing_with_reversibility/eodpa8s/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
The most important change is that CPM now defines the variable `(DEPENDENCY)_ADDED` and `(DEPENDENCY)_SOURCE_DIR`. This allows to managing projects that don't have a working CMakeLists themselves by creating a custom target if `(DEPENDENCY)_ADDED` is set. Also many examples for well-known libraries have been added, including Lua, where this is used.
IIRC they are discussing how to add array template parameters as in template &lt;auto Array&gt; void x(); x&lt;"this is an array!"&gt;(); but there are some problems. Some we will be able to write template &lt;auto String&gt; constexpr some_type operator ""_some_suffix(); but this won't be earlier than C++2b.
Good point! I still argue that it _can_, but I can't back that up right now. I am much more confident in claiming that it benefits the _teaching_ student, though. See also: [rubber duck debugging](https://en.wikipedia.org/wiki/Rubber_duck_debugging) ([implementation](https://rubberduckdebugging.com/cyberduck/)).
Mongo db has a very nice promise/future implementation: [https://github.com/mongodb/mongo/blob/master/src/mongo/util/future.h](https://github.com/mongodb/mongo/blob/master/src/mongo/util/future.h)
Oh, I have no doubt of that! :)
You have multiple CU (let say 10) on your device. Each application want to run "blocks of threads" (usually thousands). Each block will ask for a fixed amount of registers and scratchpad. They can't ask more than a CU has (compile time check), so they always fit on a CU. If they ask for less than a CU has, you can even run more than a block per CU. Now, the driver can choose to run blocks from multiple kernels or multiple blocks from the same kernel on each CU. But because the L2 cache it's shared between CUs it is usually preferable to do the later as blocks from the same kernel tends to work on the same data. Note that CUDA enforce the fact that blocks are independent exactly for being able to do that.