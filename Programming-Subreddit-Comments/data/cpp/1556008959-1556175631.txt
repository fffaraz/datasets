Ech. I saw they do it. I may be lucky but I have never seen one teaching it.
Another situation is when dealing with legacy code and/or exotic platforms. There might not be a modern compiler available for that platform, and the library might not have the smart pointers we've gotten so used to. Sometimes you have to work with what you've got. Sometimes that's plain C pointers.
One course I took on university teaching c++ did this. But it got better: There was a memory-leak in the exercise-paper. When talking about it all I got was "that it's not important because it's in int main() and the programm will terminate after it anyways" While this explanation is technically correct, I find this very sad. Those guys get payed to teach me something. If you're giving a c++ course get a book not from decades ago and learn c++ first before you teach it. Works on other fields as well.
It's hard to point at any specific feature as being "bad practice" because it depends on how it's used and what the goal is. The problem is if you teach about things without explaining when and why you should use it. I've seen this a lot on YouTube where the people that upload C++ tutorial series often are the same persons who upload tutorials about other languages without being experts on C++ or programming in general. This can easily lead to beginners thinking they should do something a certain way because it's "the right way" or just confusion over there being multiple ways. It's hilarious how many videos there are that explains exceptions by just showing an example where the exception (often an *int* or a *string literal* :-S) is thrown and then immediately catched which makes them look like a more verbose (and less efficient) form of if statement.
I'd say that it is fine when one is writing C, but in C++ I'd much prefer template&lt;class T, size_t N&gt; constexpr size_t size(T (&amp;)[N]) { return N; } which fails to compile when the array has decayed to a pointer.
I think non-owning raw pointers are fine.
Is that a reference to an array of `N` elements of type `T`? I didn't know that syntax. Is this how `std::size()` is implemented for array types?
that example has a high chance of dereferencing a null pointer.
Well, it‚Äôs not even technically correct. A memory leak, as far as I understand, is not guaranteed to be cleaned up. Most modern OSes do it, but I know for a fact that MS-DOS and clones did not. I‚Äôd not be a 100% sure about embedded systems either. I recall a teacher like that. In Hungary, Szeged.uni, teaching C++ amongst many things. Selling himself as an expert. His first example code was called cprog.cpp. It‚Äôs first line: #include ‚Äúconio.h‚Äù (yes, with quotes). The code inside was neither good/idiomatic C or C++. When it was pointed out to him that instead of teaching he is doing damage and that he hasn‚Äôt got a clue, he started to yell that he is being harassed because he is a Transylvanian refugee. He was a Hungarian national. In Hungary. Destroying the chances of all his students to get a job that required any knowledge he was supposed to teach. That guy has made me wish I studied law.
There are safer ways to get the size of an array using templates that will fail to compile if you accidentally pass a pointer or something else that is not an array. In C++17 you can use `std::size`.
Well obviously this is a simplified example, and obviously you check if `obj` is a nullptr afterwards. Besides, with something like `std::optional`, you too have to check `obj` afterwards.
Yes, and yes (ignoring that std::size is also noexcept).
 base &amp;obj = [&amp;] { if (condition_A) return derived_obj_A; else if (condition_B) return derived_obj_B; // ???? }(); obj.do_stuff(); References work just fine for this.
std::optional for optional values, raw pointer for optional references.
Do they? The "????" might be a real world error case. What then? Exceptions? So now you have to surround this with a try-catch block. The code just got even more verbose and convoluted.
You can define a "programmer" as "anyone who writes a program," but you don't wind up with a very useful concept that way. At least once in my life I've cooked a meal, played a game of soccer, taught a class, made an espresso drink, and played a saxophone. That doesn't make me a cook-athlete-teacher-barista-saxophonist.
RVO alone doesn't help if the return value is being assigned to an already existing variable. Thankfully *move semantics* often (but not always) makes it relatively cheap anyway. If you are calling a function in a loop it is sometimes more efficient to reuse the same object. This is often true for std::vector. By reusing the same vector you can often reduce the the number of memory allocations (and the amount of copying) quite a lot.
Indeed they are. However there is often a better choice. Faster and simpler. I have seen a lot of std::map&lt;key*, value*&gt; where there is lots of handwritten code carefully cleaning up those keys and values on erase, with errors.
just fix the example code already. i wasn't promoting optional.
How about you actually look at my post before you say something?
Others have already listed problems that arose when exceptions are kind of ignored - raw pointers/new/deleta without RAII capsules - improper use of raw (C) strings and arrays On the topic of exception safety - copy-assignment operator shall not start by releasing the old resources before executing code that may throw exception -- on the topic I see the anti-self-assignment test as an anti-pattern. Otherwise, many problems I see actually relate to OO. For instance - letting believe or teaching that _"all classes shall implement copy"_ while actually _entity semantics_ require copying to be `=delete`d. - `class ColoredPoint : public Point{...};` , or `class Point3D : public Point2D{...};`. Still a problem that value classes shall not be involved in public hierarchies -- here we cannot have a comparison that is reflexive, symmetric, transitive and that respects Liskov Substitution Principle. I also have (minor) complaints on things like declaring all variables before initialising them.
Using exceptions for control flow is another "thing commonly taught in C++ that is really bad practice". You added the "handle error case" after the fact. No, it wasn't obvious enough. That's why I wrote ???? because there was code missing.
This has been accepted into C++20 afaik: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0315r2.pdf
Are you asking why it‚Äôs not valid until C++20?
Yes, why does allowing the lambdas in signature causes problems?
None of this changes the fact that your solution does not handle the error case properly. What do you return in the ???? case?
Very good point!
Here comes a good one because it will be downvoted to hell ;) Throwing exceptions. They are extremely hard to use correctly in C++. Exceptions also add invisible control flow paths to your program. Code coverage becomes meaningless and the program is hard to reason about. Exceptions also encourage hiding important events in log files instead of doing anything useful with them. In GUI software, exceptions lead to those useless "oops, something went wrong" or "Object reference not set to an instance of an object" (common in .NET software) message boxes. Exceptions obscure the ways a function might fail.
If you make `bar` a template, it does work. https://godbolt.org/z/dchqn4
And in C++20 we can have virtual functions that can't be overrided, without using `final`: struct Foo { virtual void fun(decltype([]{}) = {}); };
You could return a pointer. The `const` makes the nullability explicit. Yes, pointers can be okay as nullable references if it's obvious that they can be nullptr. base * const obj = [&amp;]() -&gt; base * { if (condition_A) return &amp;derived_obj_A; else if (condition_B) return &amp;derived_obj_B; return nullptr; }(); if (!obj) { return; } obj-&gt;do_stuff(); Another way is to use the existing polymorphism. In some cases this might make sense. struct error_handler : base { void do_stuff() override { ... } }; base &amp;obj = [&amp;]() -&gt; base &amp; { if (condition_A) return derived_obj_A; else if (condition_B) return derived_obj_B; static error_handler handler; return handler; }(); obj.do_stuff();
We indeed don't have the same appreciation regarding "hard to reason about" and "obscure". Check for instance a correct code (correct is important) like the following: https://ra3s.com/wordpress/dysfunctional-programming/2009/07/15/return-code-vs-exception-handling/ (search for "Correct RCH-style")
Seems like at least \`std::unorderd\_map\` can cope with bad hash functions. &amp;#x200B; I quickly put together a simple test program: [https://gist.github.com/felixguendling/efd05c932f0bcd5804a6112a9064328f](https://gist.github.com/felixguendling/efd05c932f0bcd5804a6112a9064328f) &amp;#x200B; What's a bit alarming is that \`robin\_hood::unordered\_map\` does not find unaffected entries (which were inserted before the error occurred) after the insertion error. So this error seems to corrupt the whole data structure. &amp;#x200B; For \`std::unordered\_map\`, the documentation says "If an exception is thrown by any operation, the insertion has no effect.". Therefore, I would assume a replacement to at least provide this guarantee, too. Ideally, it would not fail at all for bad hash functions, only for out-of-memory conditions (IMHO).
I disagree. I think that in GUI applications the alternative to exceptions would be crashes and silent errors. Even worse!
Yes, making it a template works. But I want to understand why I can't use something like this "decltype(\[\](){})". Ok let me repharse, why can't I use the lambdas in unevaluated contexts until C++20?
Corruption should't happen. I've created https://github.com/martinus/robin-hood-hashing/issues/22, will look into this
&gt;Yes, it works in C++20. What about Pre-C++20? Try it, it won't work. So why does the standard committee decided to prevent it?
I disagree. I think that in GUI applications the alternative to exceptions would be crashes and silent errors. Even worse!
Any dogma honestly. This language is so huge and varied that it's at least in my experience more common to see people disagree than agree. This language is just a tool, albeit my favourite one and what everyone says about it should be taken with at least an ounce of salt.
How is a comparison to a C monstrosity fair? This is what the example would look like in modern C++. I don't think it's worth handling out of memory in most situations, so I omitted that part. Just catch in main, notify someone, and exit. outcome::result&lt;shared_ptr&lt;NotifyIcon&gt;&gt; CreateNotifyIcon() { shared_ptr&lt;NotifyIcon&gt; icon;//[5] shared_ptr&lt;Icon&gt; inner; icon.reset( new NotifyIcon() ); OUTCOME_TRYV(icon-&gt;set_text("Blah blah blah")); inner.reset( new Icon(...) ); OUTCOME_TRYV(icon-&gt;set_icon(inner, GetInfo())); OUTCOME_TRYV(icon-&gt;set_visible(true)); return icon; }
I think the issue, addressed in 20, is lambdas in an unevaluated contexts. &amp;#x200B; [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0315r1.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0315r1.pdf)
We can have virtual functions that can't be overridden even pre-C++20. Just make type of an argument private: struct Foo { private: struct Bar {}; public: virtual void fun(Bar = {}); };
Abuse of protected:. Where author of base class assumes you will correctly fiddle with protected members.
If I had to hazard a guess, I would say that the original restriction might have something to do with issues linked to the type identity of the unevaluated lambda: if you pass anything to `bar`, how can you feed it an instance of the correct type? In which case can two `decltype([](){})` evaluate to the same type? Since it works in C++20 the issues have probably been fixed, but I wouldn't be surprised if the answers to those questions didn't seem obvious at the time. Also the obvious answer is that lambdas in unevaluated contexts needed use cases before we felt the need to answer those questions. We found the motivating use cases, but when lambdas were first introduced we still needed a few years to play with them and understand what else we could need from them.
I partially agree and partially disagree. Yes, exception throw is hard to use correctly due to memory unsafety and manual resource management. No, the opposite is also true: Exception throw is easy to use correctly due to memory safety and automatic resource management. Yes, `throw` statement add invisible control path to your program. Yes, this makes things hard. No, hiding things is not a bad thing because encapsulation is not a bad thing. Plus, the basic of structured programming is we reason code in terms of blocks, not line-by-line. `throw` respect the concept of blocks, just like `break`, `continue`, `return`. No, exception has nothing to do with hiding events. The people who write the catch-clause do. No, exception has nothing to do with the usefulness of the error message. People who write the message do. No, exception obscures nothing. It reports it.
It's missing documentation. Specifically, what are your guarantees for an observer? Is an observer guaranteed to run synchronously? What if an observer throws an exception, will the change still be correctly go through into the map? Will the observer be called again on the next change? Will other observers be called? How long is the reference passed to the observers on an update safely accessible? Secondly, you should consider offering a way for an observable value to be partially updated. Think of a big vector, I don't want to assign to it, I want to push_back. Now, that opens the doors to something more complicated: transactions - where you update multiple values in a way that looks to be atomic for observers. Not sure if you'd want that or not.
The most important thing to me: on the internet, you can read a lot of "do this" "don't do that" for programming. C++ is a large language with often different ways to do the same thing, and reasons for why that specific way is good or bad. You can read different opinions because of different needs. Treat them as guidelines, not dogmas. What applies for a textbook case may not apply for a specific case in a complex program (even without having to deal with legacy code). Your job is to understand what are the upsides and the downsides of each practice, and judge what is the best solution for your problem.
Can you expand on what you mean with the point on? : public Point
But can you make `fun` not definable?
I would argue, catching is bad.
Using inheritance for code reuse. After a couple of years you have an unmaintainable spaghetti that goes 5 levels deep.
Automatically changing types somewhere else in the program may have unintended consequences. I prefer to manually change types (and get warnings and errors to tell me where are the types that need to be changed) so I can check if the new ones still works as intended.
I thought C++ was weakly typed?
Totally agreed that there are cases with old compilers and hot loops where you can do things more efficiently with out parameters and other cases like polymorphism where return by value is not (easily) possible. I also agree that teaching C++ is an art, but I disagree when you want to imply that the correct choice is that people should use out parameters over returning by value (as a default). I don't have a Kate Gregory like background, but I was responsible for teaching Modern C++ for 2 companies now. I think you have to keep it simple stupid and tell people to return by value (by default).
If you don't catch then what's the point of exceptions? Just to make sure all destructors run properly?
And where did you learn mind reading? I‚Äôd say ask for your money back. Nowhere did I imply that the correct choice is always out parameters and did not want to imply it either (the mind reading part). I told (not implied) that there are situation where there is no choice (and moves won‚Äôt happen), so the real life situation is not that simple. But what do I know. I only do C++ since 1992 and have a mere 18 years of mentoring and teaching experience.
+1 for this, one thing it took me a surprisingly long time to realise is that even with nrvo returning a std::vector is often very bad for performance
you would not like c
I worked in C for 10 years. And no, I don‚Äôt like how most people use C.
they should be taught. you won't fully understand the rest until you know the basics
My book Introduction to High-Performance Scientific Computing has lots of background about parallelism: [https://bitbucket.org/VictorEijkhout/hpc-book-and-course](https://bitbucket.org/VictorEijkhout/hpc-book-and-course) My book Parallel Programming in MPI and OpenMP (alternatively: Parallel Programming for Science and Engineering) teaches you specifically MPI, OpenMP, and the PETSc library: [https://bitbucket.org/VictorEijkhout/parallel-computing-book](https://bitbucket.org/VictorEijkhout/parallel-computing-book)
I like exceptions, but this is a silly reason. what about all c code with guis?
isn't this the same as every other constructor that takes a begin/end? UB if they are from different objects.
It's not just this language. Programming is so huge and varied. And you're right - it's any dogma that is bad practice. Understanding why, why not, when and when not is much more important.
I guess /u/LucHermitte was referring to the following (and I hope they correct me if they meant something else): - Say you have a Point p and a ColoredPoint rp with the same coordinates and the additional property `rp.color == RED`. By Liskov Substitution Principle, I should be able to use ColoredPoint in every context where I could use Point, including testing equality. So `p == rp` should return true. - The same holds for `p` and `gp`, where `gp` has the same coordinates as `p` and `gp.color == GREEN` - By transitivity of equality it should now hold that `rp == gp` is `true`, but both of them are `ColoredPoint`s, and as their colour does not agree, `operator==` would actually return false.
Ive been preaching this for to my colleagues for the last decade almost. I was starting to think it was a lost cause.
Do you also consider changing the behaviour in case of an overflow? If not: can you please give me some pointers on where to start (obviously all `throwOverflowError` calls but which data structures and which logic would need to be changed)?
I mean in C++ you should just be using std::array with very rare exceptions (like constexpr issues prior to 17).
I agree with this but im willing to concede that maybe i just havent seen it used well. In all my experience so far, it has created code that is difficult to reason about where you start to assume that any function may throw at some point. I suppose just because something throws, you don‚Äôt have to catch it, but if thats the case, I dont know why you‚Äôd use exceptions at all instead of crash, dump, restart.
&gt;Exceptions obscure the ways a function might fail. I'd argue only if used incorrectly. When throwing an exception you can give a reason why it does. If it gets catched 10 stack-frames later it's not the exceptions-fault, but the programmer who doesn't care for a catch until then. If catched at appropriate scope they make the programm-flow well readable and can log useful information. The only thing i just hate is that everything in c++ can throw because of bad memory_alloc. This really makes the throws keyword near meaningless.
Using exceptions for flow control (any thrown exception should abort). This is going to be decently controversial, but it shouldn't. C++ uses a zero-overhead exception model, which essentially means exceptions are assumed not to occur for branch prediction, and if triggered then loads a cold region of code from memory. But it gets worse. Then, any code that is in the try block must be unwound, by unwinding the stack. This is glacial. Both errno and C++ exceptions are terrible models for exception behavior. Write your own success/error monadic template and enjoy (like Rust or Haskell).
Can you elaborate on 1?
&gt;It's missing documentation That's a good point. Given the small codebase I originally assumed the examples and tests would be sufficient for most users, but you make a good case that guarantees about the functionality should be well defined. &gt;Secondly, you should consider offering a way for an observable value to be partially updated. That is indeed a very interesting feature! It's on the roadmap and I'll also have a look at the transaction pattern.
How are you supposed to fix running out of memory anyway? You may write a perfect code that has no memory leaks and some other process may cause problems. There is nothing you can do about it. I find it unimaginable that someone will predict behavior of other programs to fix its problems with memory.
The best tools are generally considered simple, like the hammer, the screwdriver. They're easy to use regardless of your level or experience. It will vary on who's using or contributing to your codebase, but in my area I broadly agree that the assumption that $language programmers are generally skilled, eventually so, or striving for it, is easily falsifiable. Most contributors are using the tool to scratch an itch, not trying to become experts at the toolbox itself. I think of C++ not as a language, but as a family of languages, or perhaps a 'culture'. It will vary very much how it's used, which dialects employed, sometimes simultaneously, or how much people will be interested in anything more than solving their itch. Making fewer assumptions is generally a safer bet.
Raw threads and inheritance.
The only return type allowed for main() by the standard is int. I think many compilers won't allow you to write void main(), so it hurts portability.
FINE: Raw pointers can also be okay as references in some cases. One example would be: base *obj; if (condition_A) obj = &amp;derived_obj_A; else obj = &amp;derived_obj_B; obj-&gt;do_stuff(); FINE: Raw pointers can also be okay as references in some cases. One example would be: base *obj; if (condition_A) obj = &amp;derived_obj_A; else if(condition_B) obj = &amp;derived_obj_B; else { /* error case */ return; } obj-&gt;do_stuff(); FINE: Raw pointers can also be okay as references in some cases. One example would be: base *obj = nullptr; if (condition_A) obj = &amp;derived_obj_A; else if(condition_B) obj = &amp;derived_obj_B; if(obj) obj-&gt;do_stuff();
&gt;How are you supposed to fix running out of memory anyway? Release some memory that you don't strictly need? Restart the program? May not apply to every use case, but there must be some where handling "out of memory" is possible.
That is all true. I would argue that the first solution of yours here adds no value though. (The second one does, a clever trick, that one.)
Surprised that no one mentioned this yet, found in most C++ courses or tutorials: using namespace std; Obviously in small programs it may not be a big deal, but I've heard of professors requiring students to use it everywhere, even about some teaching that this is the proper way as opposed to using the scope resolution operator.
Andrei here. AMA about this workshop (and I'll relay questions to Kate and John as well if needed)!
There is the info byte which stores the distance to the original bucket, plus a few bits from the hash if possible. If that byte would potentially overflow in the next insert, I force a resize. I think it might be possible to introduce a special meaning when this byte is 0xff and then switch to a slow rehash mode. But before I do this I'd like to have a look how tessil's robin_map or hopscotch map is handling this problem. I suspect they just use a larger overhead structure than a single byte.
&gt; goes 5 levels deep. That's optimistic.
It adds extra crap when it has to add a vtable to your type. Then your class contains a pointer to the vtable and RTTI entry.
http://stroustrup.com/bs_faq2.html#void-main
It is weakly typed in some areas like implicit conversions of some types (integers, boolean...), but far from being the mess that JavaScript can be. Modern C++ promotes a lot more strong typing than Vintage C++ or C (strong types, explicit boolean operator...).
Not only that, but it prevents you from actually returning success status when your program finishes, hurting your program's ability to interface with others.
This comes down to this argument of 'I do, therefore I am.' It depends on your outlook on life. Many people will claim they are x, y or z because they do x, y or z. I was having this discussion last week. At what point does the things you do define who you are? It usually depends on the person: I do not claim to be a C++ programmer because I spent 2-3 years writing C++03 code at work. However, some other person who cares more to cling on to that, maybe as some identity, would do that.
Fair point. I've induced you were referring to this kind of style from your remark about unsafe memory and manual resource management. For the monadic approach to work nicely we still need a way to guarantee resource release on early exit. On this precise topic, there is no difference with exceptions.
I can see your point, but the difference between using a tool to scratch an itch and being paid for it makes a big difference here. If one is just scratching an itch, learning to use a drill (or some tiny bit of `$LANGUAGE`) to achieve that goal is fine, though that person shouldn't be surprised if his pull request gets blocked because tests are missing or if he's told to use a power drill instead of a manual one. On the other hand, if that person is paid professional he better be familiar with the whole toolbox, no matter if one is a surgeon, a construction worker or a software engineer.
Downvotes showing that this one is still taught. My number 1 most hated thing. Makes reviewing and learning other code so annoying. Refactoring more difficult as well when changing a type has hidden consequences. Just so bad on multiple levels.
maybe consider using "smart" pointers. Like *unique\_ptrs. Definitly worth to check that out!*
That's exactly it. The whole problem is a little bit more complex as we could turn to design to have transitivity (IIRC), but we would loose the other properties. A thorough demonstration is available in Joshua Bloch's _Effective Java_ -- as I said, the problem is not specific to C++. C++ _just_ adds the slicing issue.
I'd say not from valid range rather than different objects (for example, end istream iterators is not from any object), but the requirement for the iterators to be of a valid range is much less strict (and easier to spot when violated), than to point to contiguous memory. For example, `std::find(students.begin(), professors.end(), 10)` is clearly wrong. but `std::string_view s{students.begin(), students.end())` is not - could be correct if `students`
Original [Rule of Zero](https://web.archive.org/web/20170705080311/https://rmf.io/cxx11/rule-of-zero), courtesy of the wayback machine.
you can release memory that you allocated, but I meant case where it isn't your program that causes problems with memory. It's not your job as a progammer to fix such things. You can just inform the user that there is a problem...
Again, it may depend on your type of organization, but nowadays programming is everywhere, so also in places where producing programs is not the goal, but using software (and extending it where necessary) to scratch itches is. I'd wager those type of working places are in the majority now, which leads to most people using your $lib or $program to not give a rats ass about vagueries such as quality, they'll want to bang it into the shape they need as fast as they can. It is nice if the language or platform is somewhat forgiving for such potential contributors. I've seen C++ libs designed in a way that are, and many more than were totally not. One hopes some of them will learn a bit more about the toolbox (I'd like to think I'm one of them), but assuming they will is assuming too much, IMHO. The type of slightly surprising behavior in the article is not ideal, and is very much a detail of this particular toolbox, and therefore of little inherent interest to most trying to scratch itches. In any case, in the case of C++ the toolbox is so huge that I frankly doubt anyone can learn 'enough', especially now that the standard+stdlib is changing faster than ever. C++ is, to me, very much a question of selecting a (small) subset, and sticking to it, so that you may understand it as well as you can, while still realizing that others will chose other subsets, for perfectly valid reasons.
If you've got analogous types with similar method signatures but that have different logic, you're doing something majorly wrong. AAA style should error in all the right places if the new type or interface is incompatible with the old, just without all the noise.
Would just like to say thank you for doing this. It looks like it took a fairly large amount of work to put together and I found it a really interesting read. Also thanks for putting summaries above each page as there is just so much data it's hard to keep it all in my head at once when looking at the graphs. And particularly your little explanations at points as to why something performed the way it did I found fascinating. So once again thanks for the work!
I'm not sure how AAA style makes code harder to learn. Dynamic languages like Python are considered much more readable and easier to learn, and static languages with type inference when possible (like Rust, Go) do fine without explicit type annotations. I'm not sure why auto is an issue. Most text editors/IDEs should also be able to determine the type of the auto if desired.
What's wrong with (see below)? template&lt;typename t&gt; struct Tree { T val; vector&lt;shared_ptr&lt;Tree&gt;&gt; children; };
&gt;"Try not to mention any of 'the big 5', but if you mention any of them, you should mention all of them". That's exactly how C++ Core Guidelines puts it: * [C.20: If you can avoid defining any default operations, do](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero) * [C.21: If you define or =delete any default operation, define or =delete them all](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five)
For everyone downvoting, you should likely read on the subject before you critique. [C++ Exceptions Considered Harmful](http://www.lighterra.com/papers/exceptionsharmful/) [C++ Exceptions, Pros and Cons](http://shanekirk.com/2015/06/c-exceptions-the-good-the-bad-and-the-ugly/)
I don't think that will quite work. Haskell typeclasses are ADTs (algebraic datatypes) that can be self-referential. I don't quite see how you'd do that in C++. ADTs in C++ are variants, rather than structs. The problem is, if you try to define a variant, you don't have a type into which to define a unique_ptr, because it's a self-referential structure. You don't *want* to use structs, because conceptually your type is a variant, not a record. Pre C++20, there's basically no way of doing it without introducing hacks involving structs or maybe pointers to voids. I was wondering if Concepts was a way of solving this problem.
Every junior I've worked with gets fiery over informing them this is bad practice, too.
A lot of programs doesn't care. Changing the return type from *void* to *int* isn't hard to do if you later find out that you want to return different values.
Yes.
How are pmr types different when it comes to RVO?
In some cases it is reasonable to catch failure to allocate large buffers and abort the current operation, but keep the program running. This is especially the case for things like simulation software, where you are likely to need to do a big allocation at the beginning of your solution.
Pmr types have associated memory resources that are separate objects. Creating a pmr type locally, using an allocator that allocates on the stack, returning it as a copy, you would get an object that uses the default memory resource. If RVO or NRVO is used there is no copy. A shell is created in the displaced variable that is referring to things allocated my a memory resource long gone when the function returns. Essentially it will return a reference to a temporary, the dead memory resource.
Yes there are cases where nothing can be done. But it's the same error either way. The language can't distinguish between cases where you can handle it and cases where you can't.
That's why the post started with &gt;while there are of course exceptions
‚ÄúTransformation‚Äù? I didn‚Äôt understand.
OOP
It doesn't work in all contexts. std::vector&lt;double&gt; some_filter(std::vector&lt;double&gt; const&amp; pixel); .... for (auto const&amp; input_pixel : an_extremelly_big_image) { auto new_pixel = some_filter(input_pixel); Here, returning by value is a very bad idea. And when most of the colleagues to whom I teach C++ work on these kind of images, I cannot KISS. We cannot return dynamic data by value in hotspots.
I think I have a counter argument: the ‚Äúcascading if‚Äù problem. Maybe there‚Äôs an error that a function caller is interested in, but only happens to be reported 11 calls down. For the traditional return-value thing, all the remaining 10 functions have to arm themselves with error handling logic just to pass the error down, even though they aren‚Äôt interested in the error. Exceptions can help bypass this, because only the interested parties have to modify their code.
The post started with ‚ÄúThere are of course exceptions‚Äù, because he was going to pull a strawman later? BTW one of the exceptions I listed creates undefined behavior. Using a destroyed object. Invalid pointers. That is kinda serious.
&gt;A memory leak, as far as I understand, is not guaranteed to be cleaned up. There are a lot of things that are not guaranteed by the C++ standard. A leak-free program is a allowed to use up resources even after it has ended because it's outside the scope of the standard. Sometimes you just have to trust that the implementation to do the "right thing".
makes sense. If contiguous iterators were pointers this would be an easy fix. but they're not
Right. For that people need to agree on what that right thing is. When that happens, it takes the form of a standard. Like POSIX.
My professor uses this everywhere in his own code and then goes on to include std:: everywhere it would normally be needed anyway, which is confusing. It's possible I just don't understand. I've tried to stop using that after reading on other forums that it's a common bad practice.
If observer1 deletes observer2, you still notify observer2 about a change. https://www.youtube.com/watch?v=RVvVQpIy6zc
Thank you a lot for your feedback!
Inheritance is exactly the right tool - but for a very small class of problems, namely one where the relationship between your two classes is "is-a". Even in that case, if one concrete class inherits from another, then you have the slicing problem - where you copy the parent class instead of the derived class. What particularly burns me is library writers who use inheritance for callbacks, and force you to extend some huge base class to do this: class MyMain : public TextWindow { public: void onDataChange() override { doBlah(); } void onSizeChange() override { doSomethingElse(); } }; Quite quickly, that one class becomes a [God Object](https://en.wikipedia.org/wiki/God_object) because all new changes have to go through it.... Much better is either: class TextWindow { public: template &lt;typename Data&gt; using Callback = std::function&lt;void(const Data&amp;)&gt;; template &lt;typename Data&gt; void addCallback(Callback&lt;Data&gt;); // ... }; or class TextWindow { public: template &lt;typename Data&gt; struct Callback { virtual void callback(const Data&amp;) = 0; }; template &lt;typename Data&gt; void addCallback(Callback&lt;Data&gt;); // ... }; The first is a little more convenient but quite likely performs worse than the second, if only because the optimizer almost certainly cannot inline through a `std::function` call.
Difference is not only in member being public vs private, but also in the default inheritance rules
\&gt; they're a bit like Haskell typeclasses, but not How are they like typeclasses? C++ concepts are predicates on types, that is, C(T,U) maps some pairs of types to `true` and other pairs of types to `false`. (as for recursive data structures, [boost.variant](https://www.boost.org/doc/libs/1_70_0/doc/html/variant/tutorial.html#variant.tutorial.recursive.recursive-variant) is recursive, but nothing like that is proposed for C++)
&gt;I'm not sure how AAA style makes code harder to learn. It's harder because it's not always obvious what type you're dealing with.
Any complex type conversion. Essentially I think data structures should be minimal interfaces to data with anything non trivial or non essential put somewhere else.
Unless it's changed significantly in the last 20 years, everything.
So vectors (the algebraic ones), matrices and quaternions are not data structures to you? (Even though they benefit of having their fields accessible)
A Tree contains a val OR children, not val AND children.
That's not how i would define a tree tbh. If anything, I would define it as a leaf or a node of value and children
&gt; What's so terrible about that Because, as you say, it might decay to a pointer and _silently_ give you the wrong answer?
Learning a language is a completely different issue than learning a piece of code. In Python specifically because of duck typing I dont see how theres a comparison--all code is in some sense generic. In Rust I havent found it to be as much of a problem because (provided files are small enough) you can usually infer what type a variable is because you usually have a very limited number of types in scope, unlike in C++ where it could be any type obtained from networks of includes. But generally I dont know why they do or dont have these problems in other languages. Anyways its extremely simple. Every auto means that the developer has to keep an additional piece of context in their head when reading a function. It also means that information may be lost when switching contexts. You read the definition of another function, you go back, now you need to look up the type of the auto again. IDEs help, but if the codebase is large and template heavy just looking up the type of that auto may take awhile. Auto makes it easier to write code. But it comes at the cost of time when grokking code either in order to maintain it, change it, or fix a bug, which together take up the vast majority of developer time. Its a missed opportunity for documentation. IDEs can get you the type. But you also may be reviewing code, in which case just to understand the function all of a sudden you need to close the codebase, open up the project in your IDE, wait for it to index the project, and then you get your type annotation. Obviously there are shorter ways, but this still shouldnt be necessary, especially for large or complex codebases. Writing code so that reviewers have to do more work to understand what it does is bad practice. Using auto when calling constructors, literals or functions like make_shared is fine as that type information is redundant. Standard functions such as begin which return iterators are well known and the return type is essentially noise. But otherwise in non generic contexts the value gained from auto is only for writers and aesthetics, not maintainability.
I'm guessing you want to do something like template&lt;typename T&gt; using Tree = std::variant&lt;T, std::vector&lt;Tree&lt;T&gt;&gt;&gt;; This does not work because C++'s type system is eagerly evaluated, and this would lead to unbounded recursion.
This looks great! Feel free to create a pull request to add your book
You're doing so by forcing everything else to become aware of the insivible code path that you're introducing. There's terse syntax in other languages for monadic flow control, like "?" for example in Rust. And no, that's the whole point of optional monads, they don't need specific logic to pass the error down: you simply must be aware that the code may error, which you should be cognizant of regardless (or else, errors abound). There's many issues with using exceptions for flow control, but they're massively amplified by how C++ exceptions are implemented (see: zero-cost exceptions, branch prediction, and stack ubwinding) and the lack of memory safety in C++. Manage a resource? All that code must be exception aware.
Sorry, I don't speak git. I was hoping you'd just add the links.
encapsulate when you need to maintain invariants.
Well that's the first time I hear about that approach. It doesn't make sense, you gain nothing if you still use std:: but you still pollute your namespace. Just get over it and don't use `using namespace std;` That being said, `using namespace x` is not always a bad practice by itself, it's fine as long as it's limited in scope (for example in a function) and used for something specific (as opposed to the entire standard library), and you sometimes even need it to use some custom literals like string literals or chrono literals, I like to use `using namespace std::chrono;` in particular so I don't have to write out the long names like `std::chrono::steady_clock::now()` and it gives you the unit literals as well.
"How are they like typeclasses?" https://www.reddit.com/r/haskell/comments/1e9f49/concepts_in_c_template_programming_and_type/
Adding an invisible code path for everything doesn't make code simpler, as long as there's a terse way to deal with that invisible code path explicitly. But even this is fairly tangential to the core issue: C++ exceptions are implemented poorly. They're implemented by essentially every compiler with the assumption the exception never happens, which is fine for extremely rare errors but for common flow control leads to major performance degradations. And, bakc to the invisible flow path, the implications of not recognizing an invisible code path in C++ may occur and erroneously catching an error of the same family can lead to severe memory bugs.
I hate AAA too but I think it's actually a problem with how people have turned it into a dogma immediately. The biggest mistake in the whole thing was naming it "almost always auto" or making a big deal out of it at all. The original AAA proponents (Scott Meyers, Herb Sutter) also say don't use auto when it reduces readability of code.
Well, suppose you are required to implement my definition of what a tree is?
&gt; Type punning with undefined behaviour, esp. in embedded software and device drivers, which are supposed to be reliable... Yes, I've seen a lot of this and I always feel a bit sick. The worst is that if you explain to a lot of people why it's bad, they say, "But how else could it be laid out in memory? The type pun _has to_ work!" and the answer is, "Even though it works now, it's undefined behavior and at some optimization level, you might eventually get unexpected results." It's... unfortunate that `union` only allows type punning without undefined behavior if you are writing in C (there's a flag for gcc for C++ but then you're trapped in that one compiler). Otherwise, there is no way to do what the device driver writer wants to in place in memory - they have to use `memcpy`, if I recall correctly, and that has unnecessary overhead. I can see why they want to do it - but I can't see a way to accomplish it. In type punning between A and B, you might for example "write" A, but then the optimizer hasn't actually stored A, which is in a register, to memory, so when you read the punned B out of memory you get the old value. I wonder if the `volatile` keyword might mitigate the issue?
You'd have to replace it with return codes which has just as many problems
Python is just as nice as compile time C++ programming in this respect. Concepts may help for C++ and Python has new ways to add type information also. Nit pick: Python is Dynamically but Strongly typed, similar to compile-time C++.
 template&lt;typename T&gt; struct Tree { std::variant&lt;T, std::vector&lt;Tree&lt;T&gt;&gt;&gt; impl; /* accessor methods follow */ };
Yes, this is the sort of thing I want to do. I was thinking that Concepts may introduce some way breaking this recursive dependency. I don't know the answer to that, which is why I'm asking.
&gt;If observer1 deletes observer2, you still notify observer2 about a change. Oh yeah, that is also a thing. I fixed it in the current version. &gt;"Thread-safe Observer Pattern - You're doing it wrong" [https://www.youtube.com/watch?v=RVvVQpIy6zc](https://www.youtube.com/watch?v=RVvVQpIy6zc) Well of course there is a 1.5h long youtube lecture about exactly this thing! Thanks for sharing.
It is strongly typed but does not very enforce it.
If you're not sure what type you're dealing with, and the type is critical and isn't going to be refactored, you're falling outside the case of AAA. The same could be argued for typedefs (and in fact, has), and yet no ones going to seriously argue: ``` std::vector&lt;std:list&lt;std::unique_ptr&lt;FILE, FileDestructor&gt;&gt;&gt;; ``` Is less readable than: ``` using FilePtr = std::unique_ptr&lt;FILE, FileDestructor; using FilePtrList = std::list&lt;FilePtr&gt;; std::vector&lt;FilePtrList&gt;; ```
"But generally I dont know why they do or dont have these problems in other languages." I like how you admit you're pleading a special exception before you even get to it. It sounds like you seem to be ok writing C++ in a way that isn't comprehensible while in other languages with similar constraints of static typing, this isn't an issue. AAA has solutions for when you need to initialize to a specific type, or if you need to specify a certain type, so the interface shouldn't be ambiguous if you're writing your code cleanly. In fact, we use templates all the time without any specific type ever declared in the template, yet no one is going to argue std::algorithm is hopelessly convoluted and difficult to read.
Aha! I think we have a winner. Thanks for that.
&gt;What is it Joinable to? Itself! So you define `Joinable&lt;T,U&gt;` so that it returns `true` when `Same&lt;T,U&gt;` returns `true`? It's just a predicate, it doesn't do anything else.
Holy shit yes. This goes beyond cpp though. I don't think I've ever been more annoyed programming than chasing through 3-4 levels of nested inheritances in Luigi jobs.
I think it's good to learn how to use raw pointers and c arrays, to have to use them for a while, so that you understand how it all works and you can then be happy about using smart pointers and stuff like std::array. I used raw pointers and c arrays for a long time, just because i found it fascinating, and once i dove into the STL i could really appreciate how much work it took care of for me. I feel like it should be taught and used, but only before being followed up by a proper introduction to the STL and all it's gory glory.
Even worse is that the destructor will not get called. This may be fine for their toy example, but what happens when whatever is leading spawned threads, buffered I/O etc... Not fun to debug, so I fully agree that this ought to be taught immediately. Better safe than sorry.
\&gt; they don't need specific logic to pass the error down \&gt; like "?" for example in Rust This is not available in C++ though, you are forced to write code like this auto result1 = Graphics::createDevice(); if (result1.is_error()) return result1; auto&amp; device = result1.result(); auto result2 = device.enumerateAdapters(); if (result2.is_error()) return result2; auto&amp; adapters = result2.result(); auto result3 = adapters[0].createViewport(); if (result3.is_error()) return result3; auto&amp; viewport = result3; ... and so and so on. Granted, you could provide a method `then` that would do this plumbing automatically for you, but still its syntax would not be the best: auto&amp; viewport = Graphics::createDevice() .then([&amp;] (auto&amp; device) { return device.enumerateAdapters() .then([&amp;] (auto&amp; adapters) { return adapters[0].createViewport(); }); }); This could continue for a great number of necessary result-types and could end up with a great string of `});` in the right. And, even then, it will create useless closure objects while they are running. Without special C++ treatment for result-types, it could become unbearably difficult to use them.
like pointers to existing objects? for example MyObject object {}; my_function (&amp;object); ? is that non owning, or what do you mean? (sorry, kind of new to c++)
&gt; Be prepared to have long blocks in try statements, that all need to be unwound if an exception occurs, because you don't know where that invisible path may suddenly lead your carefully managed resource to be suddenly in an invalid state. Turns out the C++ community already settled in a way to manage those raw resources: wrap them in RAII initializers (like you have already said). For your quote of the other comment: &gt; Manage a resource? All that code must be exception aware. Again the solution found by the C++ programmers is very straightforward: the copy-swap idiom.
&gt; Ok. I guess you aren‚Äôt working in an environment where your code must work with barely functional C++03 compilers. Should C++ pedagogy have to account for C++03 at this point?
Shh: i was told by a ninja master coder of rank 1337, that the heap is actually inside of the bytecode. How about you look into the binary output of your compiled lib? Might settle some of this ü§ó
It's especially bad since I feel like it just leads to lots of frustration later in your programming career. Whenever I explain C++ code to somebody else who doesn't know C++, I always just say "ignore the std:: infront of everything for now". Of course it's messy to look at at the beginning, but you get used to it, and you get to learn the structure of the std namespace(s), and once you get used to it it doesnt make a difference. I feel like it's also necessary in some way to have it be specifically std::endl, since it may get confusing when everything looks like a local variable or function (cout, cin, endl, array, vector, etc). Just dont do it. teach it properly and get over the fact that its a bit more to write.
Not advocate of the inheritance-callback "solution" either, but `std::function&lt;...&gt;` is a heavy type that does allocation, type-erasure and possibly more than one dynamic dispatch for it to work in all cases.
How so? Isn't OOP a very powerful and elegant tool to solve many problems and model real life relationships like is-a and has-a ?
Five? Only five?!? &amp;#x200B; you're slacking, man... &amp;#x200B; work harder, not smarter
Why on Earth would you ever do this when you can just put it on the stack? Smh
auto has its place and time, especially for templated class method return types (imo?). I would recommend always explicitly stating the type instead of using auto _if you know the type_. This will prevent stuff from breaking without any warnings. It will make it easier to read, understand, follow and fix your code. You wont spend _that_ much time actually writing new code in your career, so why not make the code you do write safer and nicer to read. It's not like having to look up the documentation to figure out what auto will in that case resolve to is faster than just typing it out so you immediately know what it is next time you look at it.
Any optimisation that's missed by using std::function will be missed by the alternative with the virtual function as wel tough. The extra dynamic allocation might be avoided in the latter example but I find it hard to believe that you would gain a measurable difference.
 Don't write c++ code as if it was dynamically typed, it just isn't. Just type out the damn type, it doesn't hurt that much to write _proper_ code instead of _simplistic and completely unspecific code_.
For embedded environments with limited memory, dynamic allocation might be very costly or even unavailable. And people use C++ all the way down on those.
Yes. Non-owning means that the recipient/holder of the pointer is not responsible for the cleanup of the memory it points to.
Thanks!
I think to have a better idea of the issues, imagine that
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/bgi6xy/need_help_with_linked_lists_and_binary_trees/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; I‚Äôd not be a 100% sure about embedded systems either. You'd need 2 things. An embedded system that actually has an OS with allocation implemented and an embedded application that actually terminates. From people I worked with it sounded like both are *really* unlikely. Not freeing your memory on exit has actual upsides. If your system swapped out your pages freeing just means swapping them in again for throwing them away. Instead just let the OS throw them away instantly.
&gt; Never use auto
Exactly this. If your argument for how you use a feature of the language is that "the IDE can probably figure it out for me", you must be doing something suboptimal. I love IDE's, but if I can't roughly understand someone's code without code insight features, syntax highlighting and all that jazz then I'll assume that it's not very good code. I'm not saying write code as if you're writing it for a serial killer that only has microsoft's notebook.exe, but it's kind of what I'm saying.
Thanks!
Good question. I assume it depends on the level of the education, the age of the student and the purpose of the education. A lot of code in actual use out there is still 03 or bares the scars of once being it. OTOH if I teach a 10 year old I would not burden them with more than saying that C++03 has existed. Once saying it and never mentioning it again, unless they find code on the net that requires explanation. If I were using C++ to teach algorithms and design and thinking (Parent style, all hail rotate) I‚Äôd not deal with 03 either. So it depends.
Aha. That works in two cases. You OS guarantees it can and will do that, your code won‚Äôt execute on an OS that doesn‚Äôt (which probably is the easy part) and that whatever objects you did not release held no other resource than the kinds the OS will clean for you.
What I like to do in the last case is either aliasing the namespace or only import specific names with `using std::chrono::steady_clock;`. You don't pollute your namespace and reduce visual clutter. It's great.
AAA is certainly not "commonly taught". It's quite controversial - even among experts.
`volatile` will prevent a lot of optimizations, which isn't ideal either. That said, I once had the need to do something like [this](https://godbolt.org/z/olLRS6). I'm pretty certain this is valid C, but I wonder how would I avoid UB in C++.
What about instead of `std::reference_wrapper` in containers?
YAY!
If the heap is inside the bytecode, then how can you heap allocate anything more than the size of the compiled binary? What you're looking at is the stack. Stack allocation and deallocation is literally just moving a pointer, so it's faster as you don't have to go through system memory. Do you know what a cache is? Do you know what a benchmark is? Are you seriously arguing that mallocing strings is faster than stack allocation? If so, why even bother doing int x = 2; You should do int * x = new int[1]; *x = 2; if you were consistent.
I regularly find complete tree of inheritance in our code base. Often 7 to 10 levels deep, with sometimes shadow hierarchy, and deriving Qt framework because why not. Debugging is more than hard sometimes :/
&gt; operator== Pardon me if I'm about to say something stupid but... is this conundrum not solved by having the correct overloads of `operator==`? e.g. `bool operator==(ColoredPoint, ColoredPoint)`? After, all if you compare a `Point` to a `ColoredPoint`, I would expect only the coordinates to be compared but it's on you to not compare two `ColoredPoint`s as `Point`s if that's not what you want.
Please, C++, safe me from #define nameof(x) #x :(
Sure, but that is a specific requirement. The default advice should still be to return by value and then later, when the need comes up, you teach them when other patterns are more appropriate.
Pick any style you want and stick to it. &amp;nbsp; Yeah, great. Now there's five different styles in my codebase because I use five third-party libraries... Ugh...
# they use capitalised names for member functions you're welcome, and also, fuck microsoft.
I think you have misunderstood and picked an argument with something I never said in the process. First, I didn't say anything about the definition of a data structure, just that putting complex transformations or logic into a data structure is a mistake I see made all the time. Second, vectors and matrices can be an example of what I'm talking about, though aren't the most stark example. The operators that make up expressions don't have to be part of the class. The vectors and matrices can manage memory and use simple access while complex math is not part of the data structure itself. Then, including a simple vector doesn't have to bring along enormous dependencies of all the other types it could possibly be used with. With this design you get modularity instead of everything you include causing bloat.
I think, today I would teach 03 as an "advanced" topic. Most of it is simply a subset of c++11, so you don't need to teach any additional functions or features (with very few exceptions), but it might make sense to teach (as an advanced topic) how you can best work around certain limitations and also, what performance problems you might have to keep in mind when having to deal with really old optimizers. &amp;#x200B; But unless explicitly payed to do so, I don't think a teacher should teach outdated technology, just because some companies don't want to pay the price of upgrading.
And (imho more important) retargetable references
Except for the usage of raw pointers, what is wrong with this? Or is the only wrong thing the raw pointer usage?
But this is because you are not "dependency injecting" the memory resource correctly (or I do not understand what problem you are describing). So, returning by value while using \`pmr::xxx\` with special memory\_resource setups might not be as straightforward as you would hope does not invalidate the general rule.
You should use auto, when the reader shouldn't need to care about the actual type (at least most of the time). If the exact type is important, then write it explicitly, but 99% of the time, spelling out the exact type I got back from a \`std::container::begin()\` is useless information, assuming the variable has a sane name.
I'm not pleading a special exception. I dont know how you've read that into this. In fact, you've completely ignored any actual argument to focus on a fabricated point. &gt;AAA has solutions for when you need to initialize to a specific type, or if you need to specify a certain type, so the interface shouldn't be ambiguous if you're writing your code cleanly. This is hopelessly unspecific. 'Almost always auto' allows you to initialize to a specific type? Youre going to have to be more specific, also on how the AAA style facilitates this and this is not one of the auto keyword's actual use cases. &gt;In fact, we use templates all the time without any specific type ever declared in the template, yet no one is going to argue std::algorithm is hopelessly convoluted and difficult to read. You should already know the type that a template function is instantiated with if youre not plastering code with autos. Unless youre using some kind of user defined literal. As I said previously, theres nothing wrong with using auto can be used in cases where writing out the type is redundant (such as std::make_shared).
It is unnecessary to dynamically allocate the object. The following is simpler, less error-prone and more efficient. MyClass myObject(....); ... ...
It doesn't actually help. It almost makes it worse. You would have `assert(p==rp); // true` and `assert(p==gp); // true`, but then `assert(gp==rp); // not true!` which breaks the principle in logic that if A==B and A==C then B==C must be true. Of course you could "fix" this by creating `bool operator==(const Point&amp;, const ColoredPoint&amp;) { return false;}`, but then `Point` and `ColoredPoint` are effectively different types. And it's not pleasant to do this for an entire inheritance hierarchy!
Those things arent mutually exclusive. Although i dont know whether its actually 'commonly taught'.
Iterators are a classic example of an appropriate use of auto because the specific type doesnt matter, just the iterator interface which is essentially universally known. Aside from iterators I find cases like this are relatively rare.
&amp;#x200B; I want to go further than this - I want to make C++ hotreloadable, in similar manner to javascript. File save would trigger recompile &amp; run. But I'm still a beginner in Visual Studio extension development, but have already prototyped something. Would be interested to find people, who are using different IDE's, maybe they could help with porting to other IDE &amp; compilers.
Ahha. Ok. So there is a case where returning by value results in UB, using nothing but ISO standard types from the C++ standard library but let‚Äôs ignore it, throw in some popular techobabble that means nothing in this context and hope that it will just go away.
&gt;There is no scripting language I have found that isn't difficult to shoot oneself in the foot with You can shoot yourself in leg also with C# script or python. I think it's a matter of being able to debug &amp; troubleshoot code / scripts.
Unless that object is very big and would blow up your stack.
&gt; &amp;*first Will that work for empty strings? Probably not. So an extra branch would be needed to check for emptiness. It's the silliest design, like `vector&lt;bool&gt;`.
`int main(void)` is totally legal.
`std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;` is better.
That‚Äôs what memory fences are for: https://en.m.wikipedia.org/wiki/Memory_barrier It‚Äôs a complete non issue, in practice, if you know what you‚Äôre doing.
I mean in many cases there is no performant alternative to type punning, and I think this is well understood by compiler writers; they're not likely to abuse your reinterpret_cast's between primitives, or reading the not-last-written member of a union of primitives.
It would be more likely, I'm guessing, because they may not want to take the time wrap C++ in C++ just to expose it. But the bigger issue of course is that you can't prevent them from doing almost anything, and it's running most likely in the context of your own process which means that they can do major damage. If you try to avoid that by pushing them into a separate spawned process, then you make it that much harder on yourself to have to provide cross process access to all of the information or state your process has that they may need to access.
&gt; copy-assignment operator shall not start by releasing the old resources before executing code that may throw exception -- on the topic I see the anti-self-assignment test as an anti-pattern. It sounds like you are advocating CAS for copy assignment, to get the strong exception guarantee, which frankly, is itself an anti-pattern... In most cases copy assignment should prefer to only offer weak exception safety, and better performance. Users that want to pay perf to get better exception safety guarantee can do it theirselves on top of your class' API, but if you go for the slow-but-strong-exception-safe option, users can't recover that performance.
Ignore. There's this whole anti-OOP cult that has sprung up lately. They somehow ignore the fact that almost all the software they use was somehow created using OOP languages. OOP IS a very powerful and elegant too to solve many problems and model real life relationships.
lol, this motivates even more for iterator constructor
Moreover this doesn't handle the case of `vector&lt;Point*&gt;` which could hold vanilla and coloured points altogether. And from the moment we refuse to compare a `Point` with a `ColoredPoint`, we are violating the LSP. Here, the only way to factorize without introducing design issues is to use aggregation instead of public inheritance. Alas (bask to the topic), this is quite a classic example used to introduced inheritance to newcomers.
you should use this in combination with the other answer
I don't find exceptions hard to use correctly at all. I mean they should really be used as EXCEPTIONS and not stack unwinding mechanisms. For things that can be expected to fail (because you are dealing with something that may or may not be available), then it becomes a bit more of a judgement call and maybe you want an exception and maybe you don't. I will sometimes do such methods with a trailing bThrowOnErr = kCIDLib::False parameter, so that by default the method returns a failure status, but you can also ask it to throw if you want. That way you can choose what is appropriate for each block that might call it. I think that a fundamental concept is that the bulk of non-domain specific level code doesn't care in the slightest why something failed, only that it failed and they just want to clean up and pass responsibility on up the chain. If you write a lot of general purpose code, as I do, then that is immensely useful and keeps the code vastly cleaner. I use janitor type classes to make sure things get cleaned up if an exception occurs, so there's no real extra complexity involved. Domain specific code that understands the context in which that call chain was made can catch and make a decision as to how to really react to the exception.
I think std::deque&lt;char&gt; is a good place to start
Exactly. I argue this all the time and get shouted/voted down. I think a lot of newbies are maybe coming from a world of semi-trivial software like web sites and using languages like Javascript. But in larger scale, serious software that you are going to maintain over years and decades, it makes absolutely no sense not to be as explicit as you possibly can be and the language allows. Measure ten times, cut once.
LLVMs codebase has Twine which is a Rope implementation I believe.
It kills me how many hoops modernists will jump through to try to return everything as a return value. It makes absolutely no sense. Output parameters are perfectly acceptable mechanisms, hence why they have existed since pretty much the beginning of software time.
Could be made to work if `ContiguousIterator` had a way to get the address without dereferencing.
I guess it's personal preference here, but I've had auto save me a ton of time. If I change a return type to a new compatible type, I shouldn't have to make changes throughout a huge project. Why are you changing a return type to something incompatible if you haven't first looked at how that return type is being used?
D address a lot of these issues
GCC allows writing to one member of a union and then reading from another as long as you do it through the union type even when the -fstrict-aliasing flag is used. Accessing different members by references or pointers could still cause alias issues.
I solved the problem by writing a \`MemoryMap\` class template that used an accessor policy w/ inline asm in it, along with a bunch of generated class templates that made all the different registers and fields easy to access by name, neatly avoiding all the type punning, bit field shenanigans, and other nonsense the optimizer might want to mess with.
It also means that the owner and the holder need to agree on a contract to ensure that the non-owning pointer is not used after the owner releases it.
Haskell boxes its types, so the \`shared\_ptr\` is nearly equivalent to what it does.
I don't have a problem with auto making something hard to understand in my day-to-day work. If that's the case, then there's some kind of larger issue irrelevant of the keyword. I would agree that there should be some type of context in or around the initialization (e.g. variable name or method name) that plainly states what type of object is being held in that variable. I see that your argument below is that the context exists only in a single programmer's head, then the real issue is auto without context, not the auto keyword itself. &amp;#x200B; One might argue that the variable name should be changed so that you don't even have to look for the initialization to find out what is being held, or that the method name should be made less ambiguous.
I mean, there are some features that are bad practice in all usages.
It's much more verbose and probably twice as big.
guideline: separate function for each behavior outcome: classs with billion private methods solution: use free functions that are declared and defined only in compilation unit (cpp files)
Lies!
Which part? It's not more verbose, or it's not twice as big?
I wouldn't say never, since there might be some weird template'y thing that sort of can't be done with out it. Other than that, I agree. It's some sort of Javascript disease that has infected C++. Be as explicit as the language allows, if you are writing serious software that you have to support for the long term. You write it once, you have to read and modify it many, many times.
No, that is not what I am saying ... let me see if I understood your problem you are complaining that code like this: auto f() -&gt; std::pmr::vector&lt;int&gt; { std::array&lt;char, 64&gt; buf; std::pmr::monotonic_buffer_resource local_storage(buf.data(), buf.size()); return std::vector(3,5, &amp;local_storage); } has undefined behaviour? And that this is somehow a reason not to return by value? (by default)? Correct?
 Not correct. Not complaining, stating. Never said it is a reason not to return by value by default. I have said very clearly, several times of what I wanted to say. Having to repeat it every time someone constructs another strawman of the same family gets tiresome. Please do read what *I* wrote if you wish to know what I mean. I did describe it in detail several times.
Sorry, the post was supposed to have a URL to god bolt but I messed up the syntax :-P
&gt; A==B and A==C then B==C This is the part where I get hung up. In your head, these are all the same equation operation but in my head, they are not. The mathematical `==` and the software `==` are not the same thing. Arguing software syntax from the perspective of mathematical notation doesn't make much sense to me.
Surely you have to specify the names somewhere, and that is basically your definition.
You should try AngelCode. It has most of the C++ syntax, and it compiles into byte code, so all the type checking is done when you load the script. It makes for a very nice experience. Oh, and you can call functions before you declare them. Now I don't understand how we can live without in C++...
True, although I think I'd rather see std::invoke work with structs than see structs replaced with tuples.
I see. I did not intend this as a strawman, but I tried to understand. I did read what you wrote carefully. You introduced pmr in direct reply to the advice to returning by value. I do not understand what the connection between returning-by-value or returning-by-out reference is here.
OK, I had a look but I'm not sure what I'm supposed to look at.
You're missing the entire point. Rust basically has AAA, so does Go, and neither have issues with "what's the type". This is also clearly addressed by Sutter in arguing for AAA.
Repeating it here for ease of access: Ahha. Ok. So there is a case where returning by value results in UB, using nothing but ISO standard types from the C++ standard library but let‚Äôs ignore it, throw in some popular techobabble that means nothing in this context and hope that it will just go away. EDIT: What I mostly hear in this sub thread is: I want my rule to be simple and reality be damned. I agree that the simple rule must be taught. I also think that telling that there is at least one exception to the rule (and not detailing it) is also absolutely warranted. Programming is the details. Programmers should at least know that they exist.
This is so true, and most people just like to pretend shared_ptr fixes their messy spaghetti like a magic wand. It works right, why should I care?
I'm not advocating C error handling with errno. I am advocating monadic types like Haskell's Maybe monad. It turns out you can get both legible flow control (actually, better) without having invisible flow control or secret thread-local global variables.
Yeah, I am aware of that. I just added the _other_ method that already exists. I have well understood your proposal, but read what I have in the other responses, please.
You've completely ignored other languages that don't have the same issues C++ has despite being statically typed where type inference is the default, and you can opt-in to specify types. Special pleading C++ as different when these languages don't have this issue is still special pleading. And you should always know the interface or type you're working with. If you're writing code where you need to know the type to know what you're doing, something is really, really, really off. Especially in a static typed language.
I know that and I mention it explicitly in my previous answer. Which is why I didn't address it again. C++ error handling still is awful.
But what if you want to want to access private members of the class?
You also get horribly performance in a lot of cases, because good performance requires dealing directly with the data and not getting it via access methods in bits and pieces. I mean this is sort of another aspect of the sort of anti-OOP thing, that just completely seems to forget why encapsulation was created and why passing data around through function space to be operated on by stuff that doesn't understand any of the constraints and cannot optimize any of the operations it does on them.
``` A::value_ptr() [clone .isra.0]: mov eax, DWORD PTR [rdi] ret A::value_ref(): cmp BYTE PTR [rdi+16], 0 je .L14 mov rax, QWORD PTR [rdi+8] mov eax, DWORD PTR [rax] ``` The optional reference wrapper generates 3 extra instructions related to checking for `nullopt` and throwing. If you change `.value()` for `*` then it's 1 extra instruction, at the cost of undefined behavior ``` A::value_ptr() [clone .isra.0]: mov eax, DWORD PTR [rdi] ret A::value_ref(): mov rax, QWORD PTR [rdi+8] mov eax, DWORD PTR [rax] ret ``` That's hardly a ton of extra code size
You cannot store a lambda in a variable without using `auto`.
You do realize you can chain errors outside as well as inside. You can also write your code legible. Lambdas are great for simple logic, not so great for cascading logic. Any decent maybe monad should have the ability to return itself from the function, that is, you shouldn't only return success. ```auto&amp; viewport = Graphics::createDevice() .then([&amp;] (auto&amp; device) { return device.enumerateAdapters() .then([&amp;] (auto&amp; adapters) { return adapters[0].createViewport(); }); });``` Becomes: ```auto&amp; viewport = Graphics::createDevice() .then([] (auto&amp; device) { return device.enumerateAdapters() }) .then([] (auto&amp; adapters) { return adapters[0].createViewport(); });``` Which looks a lot nicer. And can also use external functions. Oh, that actually does look good. ``` auto&amp; viewport = Graphics::createDevice() .then(enumerateAdapters) .then(createViewport) ```
&gt; Ahha. Ok. So there is a case where returning by value results in UB, But it is not the return-by-value that is the problem here, but referencing local state. Returning by out param would be as wrong: void f(std::pmr::vector&amp; out) { std::array&lt;char, 64&gt; buf; std::pmr::monotonic_buffer_resource local_storage(buf.data(), buf.size()); out = std::pmr::vector(3,5, &amp;local_storage); } whereas returning-by-value is fine too, if you do it right: auto f(std::pmr::memory_resource* mem) -&gt; std::pmr::vector&lt;int&gt; { return std::pmr::vector(3,5, mem); } I am not saying that the problem you describe does not exist, it is a big problem (and Herb Sutter did a presentation about it IIRC at CppCon 2018) just that it is not (directly) related to either pmr nor return-by-value.
That's exactly what [`std::to_address`](https://en.cppreference.com/w/cpp/memory/to_address) is for, but I don't see the issue with `&amp;*first` on an empty string to begin with. Empty != null...
[`std::to_address`](https://en.cppreference.com/w/cpp/memory/to_address)
In principle I agree, but for me putting the type is better because its 'idiot-proof'. Idiot proof for the writer in that the type *must* be updated, whereas the variable name need not, and idiot proof for the reader in that they cant misinterpret or not trust a type the way they can a variable name. Auto doesnt make otherwise good code prohibitively difficult to understand
`std::function&lt;&gt;` shouldn't do memory allocation when given a function pointer, or a lambda that captures nothing. And since in this case it is being passed `Data`, it probably doesn't need to capture anything. It could be passed `TextWindow` too, if that would help. For example: [https://gcc.godbolt.org/z/CGCTpS](https://gcc.godbolt.org/z/CGCTpS) as written doesn't allocate. Uncomment the line so it captures a large object, and it does.
Pointers?
Strings as a non 8-bit string of bytes. I was so excited when I asked about strings in golang and rust when they said "Strings have nothing to do with text. You can use them for that, but you'll need help". Imagine if we never re-implemented string and instead used it as a backing store for higher-order character and varchar types.
That‚Äôs new, and it makes sense actually. I was thinking on `then` as the `&gt;==` Haskell operator, that I was always seeing chained inwards (since thus you could preserve the variables declared in the entire `do` scope).
Who teaches exceptions for flow control?
Nope. Allocators are initialized (pmr at least) construction time and never updated again until then object is destroyed. Hence, there is no way to move the local state out. (move with different allocators copies.) And yet, I did not say out parameters must be used or taught. Although they are the usual solution. What I said is all there. Please read it.
If all I want is some nicely named variables within a container, then struct is probably the way to go. If it turns out to be something that gets used more than once, there's probably some common functionality in multiple places where it gets used, and now there's an invariant. I now need to protect some of the data which means I turn it into a class. A struct only becomes a class if it needs a private member for some reason or another. This is pretty frequent, which is why you see way more classes than struct in everyday use. However, to think that structs are falling out of favor seems ridiculous to me.
Thought that was just for fancy pointers. But there's a [2019 draft](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1474r0.pdf). Guess that would be useful for `std::span`.
Also, just saying this, for flow control, you cannot use exceptions for performance reasons in critical code, as long as the exception is hit decently frequently (&gt;=1%). Which means, you need another approach. I get there's pains with everything, but my experience with other languages has really shown me just how powerful maybe monads can be. Is it perfect? Hell no. But is it good? I'd argue yes.
But using aggregation ignores the fact that a colored point IS a point, and that an enormous benefit of inheritance is the ability to operate on heterogeneous lists of things in a generic way. You may very much want to process a big list of points and colored points by passing them to a method that can blast through them all at the point level and process them in a very efficient way to do something. I personally find the whole comparison of things at different levels in a hierarchy problem to be overblown. I just don't see it happening much in practice. Or the slicing problem that much for that matter. At least not in my very voluminous code base. And of course sometimes both of those things are actually quite convenient to purposefully make use of.
No real programmer EVER write code this way. #1 "Excuse" of C++ devs about any complains.
If you don't teach programmers these types of concepts then they aren't really programmers when they come out the other side. That's like astronauts not being taught engineering principles.
But it won't handle tons of other stuff. E.g. &gt; I don't see how we can reject code like this w/o rejecting lots of other safe C++17 code. https://github.com/isocpp/CppCoreGuidelines/issues/1038
Let me reword it. Maybe that helps. I state that returning by value does not work properly in all cases. Most of those will not affect a beginner, however not everyone remains a beginner. Hence, while teaching that return by value is the rule of thumb with modern C++ it is important to mention that there are exceptions to that rule and those who study more expert features or have the pleasure to work on all codebases might meet those. I have not said that out-parameters must be the default. I have not said beginners must learn pmr or legacy C++03 considerations. They just need to know that there is more to know.
This where the problem lies. A `ColoredPoint` is not a valid `Point`. Instances of the first cannot be substituted where an instance of the mother class is expected without breaking the LSP. Here the problem arises with comparisons with `operator==` or with hashes. We may consider they don't need to be compared, nor hashed together, in that case there is no issue. In all cases there is an incompatibility between LSP and comparison/hashes.
Why not getting both performance and safety? It's a false dichotomy created multiple decades ago and it still alive.
There is no runtime check of any way here. It literally does `if (condition) { mem::free(foo) }`. The only runtime checks has `Rc/Arc` just like C++'s `shared_ptr`'s. You actually have less overhead in rust since it could perform some checks at compile time while in modern C++ you always will use smart pointers of some kind.
You are simply lying. I mentioned two out of three of your examples, Python and Rust, and why they would care less about these issues. I cant speak about languages I don't know. Since you seem to know about these issues in other languages, you should be able to know whether or not they apply to other languages and explain why you dont think they apply. In fact, you are being intellectually lazy and simply pushing your point by making unsubstantiated claims and invoking inapplicable fallacies without actually addressing anything being said. &gt;If you're writing code where you need to know the type to know what you're doing, something is really, really, really off. That's a stultifyingly nonsensical statement and frankly irrelevant. I'm not talking about writing code for yourself, and trying to justify a coding style based on your own needs for understanding your code is nonsense. The point is for others who will be reviewing, maintaining and debugging your code.
Consider what would happen if we didn't have lambdas, like in pre-C++11 times. We have to define a functor: class MyFuncIntToDouble { public: double operator()(int x) { return x / 2.0; } MyFuncIntToDouble(std::string s): s_(s) {} // Boiler plate to fill in members. private: std::string s_; }; Note that different instances of `MyFuncIntToDouble` can have different values for the member variable (analogous to the bound variables in a lambda). But different instances **cannot** represent different functions; they all have the same `operator()`. To have a different actual function you'd need a different type: class OtherFuncIntToDouble { public: double operator()(int x) { return x * 1.5; } MyFuncIntToDouble(std::string s): s_(s) {} // Boiler plate to fill in members. private: std::string s_; }; Now remember that lambdas are really just syntactic sugar for the above. So lambdas with a bound variable are all different types, even if they have the same signature: std::string s; auto myFunc = [s](int x){ return x / 2.0; } auto otherFunc = [s](int x){ return x * 1.5; } static_assert(!std::is_same&lt;decltype(myFunc), decltype(otherFunc)); It wouldn't make sense to have a function parameter with type `decltype([s](int x){ return 0.0; })` because then you couldn't pass it *anything* because nothing would match that type, even a lambda that you copied and pasted from the function signature. (Plus, where would that `std::string s` come from?) Lambdas that don't have any bound parameters are a special case because they're guaranteed to have the same type as a regular function pointer. But if you want a function pointer as the type of your parameter, why not just use the normal function pointer syntax?
&gt; Anyway, I think a better way to do this would be to identify the flaws in the existing languages and figure out how to get rid of them. E.g., failure to de-allocate memory in C++ gets solved with smart consistent use of smart pointers. New languages are actually old languages with some overhauled ideas. For example rust is just some kind of C++40, with old features removed from the language. Since you cannot remove anything from existing languages you cannot do great things new languages could. For example you can't enhance algol60 to make it comparable to C++, and it just doesn't make sense, C++ is better in any forseeable way. Just take it and throw algol in the recycle bin. The same thing happens regularely. Languages appear, grow, make successors and then die. It's completely fine. Tech stack is not your mother, you shouldn't mourn when its time came. Just choose another one that fits better. It wasn't invented to hurt you, it was invented to help you. Between modern languages you could find languages from authors with same values as you so you will profit from using it. In rare cases when you don't you just create a new language and it probably takes the world. I.e. rust was designed with small syntactic sugar over C++, with green threads and so on. I found [this pretty old presentation](http://venge.net/graydon/talks/intro-talk-2.pdf), I suggest you take a look. The main idea I was shocked by was "Nothing new" as virtue. Being said, C++ is a great language, but there is nothing wrong with looking at its cons objectively. If the only answer for some problem is "just write better code" then you don't have an answer. It's ok if there is nothing you can do, but if there are tools that helps you have to consicer it. At some point benefits from solving these issues overweight lack of already written and tested code and the samsara cycle makes another turn.
I don't think cycles could be resolved without some kind of GC, and you obviously probably don't want this in C++.
I've updated to clarify what I mean. Not teaching raw un-managed pointers wouldn't murder the ability of programmers. Also people who cannot reason about all nuances of pointers are still programmers.
&gt; In Rust I havent found it to be as much of a problem because (provided files are small enough) you can usually infer what type a variable is because you usually have a very limited number of types in scope, unlike in C++ where it could be any type obtained from networks of includes. Sounds like you're just writing shit C++ code then.
Being said people want Scala level language with C++ performance. I can't blame them for that. And it will happen in the near future. Rust is really close to it although some decisions in the language team are too hindsight. Maybe we need one more iteration to get languages like this. But you feel really refreshed when working with new languages. Stackoverflow surveys don't lie as well as your experience if you give it a try.
Some people (and so do I) think you don't have to pay safety for code that actually doesn't need performance. I believe in priorities "Always safe and almost that fast" over "Always fast and almost that safe", because 10% slow down is much nicer than incorrect program flow happening in 10% cases.
&gt; &gt; copy-assignment operator shall not start by releasing the old resources before executing code that may throw exception -- on the topic I see the anti-self-assignment test as an anti-pattern. &gt; It sounds like you are advocating CAS for copy assignment, to get the strong exception guarantee, which frankly, is itself an anti-pattern... What do you mean by "CAS": _Check And Set_, which permits to implement (thread) atomic operations? If so, this is not what I mean: I don't like burdening my value classes to make them thread-safe. If the trade-off isn't that important, I prefer indeed to offer strong exception guarantee. Between the naive and unsafe (and classic) T&amp; operator=(T const&amp; rhs) { if (&amp;rhs != this) { delete[] m_buffer; m_buffer = new whatever[rhs.size()]; m_size = rhs.size(); copy... and T&amp; operator=(T const&amp; rhs) { auto tmp = new whatever[rhs.size()]; copy.... delete[] m_buffer; m_buffer = tmp; m_size = rhs.size(); I definitively prefer to teach the later one at first. Then I explore how to avoid reallocating with a more _advanced_ audience. &gt; You can have value classes involved in public hierarchies though, it may simply be that the value parts of the API are not part of the polymorphic API. Anyway, this is much too abstract to be an anti-pattern (IMHO). My experience on the subject is that there always is a design flaw somewhere (comparison and/or slicing which are typical to value/regular classes), and honestly, so far I've never needed to really have such design. In the end, in 99% of the time, I don't need to copy instances involved in a public hierarchy. The default reflex I teach is that value classes are not meant to belong to public hierarchies: otherwise we have a design smell. There are indeed exceptions (pun intended), but they deserve a more thorough analysis in order to confirm this is really what we need and that the limitations induced by the various incompatibilities (LSP vs ==/hash ; slicing) are not a problem for our use cases.
I get where you're coming from. But (and isn't there always a "but"?) the point of operator overloading is so that the syntax of the program can mimic the syntax of the problem domain. The `==` operator is called the equality operator, a name it takes from the = symbol in arithmetic. Equality being transitive (the formal name for A=B, A=C, therefore B=C) is one of the core axioms of arithmetic. If you violate it, **you break maths**. Okay, I'm exaggerating for rhetorical effect. But the point will stand that breaking transitivity makes it much harder to reason logically about the program. It also violates the [principle of least astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) for whichever programmer next comes along to use the code. Both these things are undesirable. I'm not sure I'd fail a code review for them, but there would be some stern comments on the check in. One solution, which could keep everyone happy, would be to have `operator==` be the `Point` comparison, and don't declare it for `ColoredPoint`. Use a member function, or a free function to do a full comparison. It would still be a little unwieldy, but the code would be more logically sound.
&gt; If he would have mentioned rust or switf as examples and not as "you should run away from c++ to those lengauges", then, I would have upvoted the post. What if it's the only option, if not today then maybe in near future? You can't add features indefinitely, and adding new features don't help fix old ones. Your position "How to fix the C++ to make it great" and you don't want to hear "there is no way C++ could be revamped". You may disagree but consider this point, it may be right.
1. You addressed no actual points aside from citing other languages 2. You provided no evidence for any claims about those other languages 3. You ignored counter arguments 4. You resort to insults, lying and personal attacks in what doesnt need to be anymore than a technical discussion 5. You are completely unable to accept even a plausible downside to your usage of auto I dont know why you're even posting when you clearly arent interested in discussing anything. And frankly, if you think any file with a sizable number of includes including transitive includes is shit code I doubt youve ever had a C++ development job.
You just accused me of lying and you're complaining about insults? Sooo rich.
It doesn't have to be a valid point, it just has to have all of the characteristics of a point, which it does. That's fundamental OOP stuff. They by definition aren't the same, but one contains all of the characteristics of the other and can be treated as one. That's why inheritance and polymorphism exist and why they are so powerful. Any argument that that's bad because one is not the other seems fundamentally silly to me. Obviously they are different, by definition.
Your comment was originally these two sentences: &gt;Sounds like you're just writing shit C++ code then. Which, I pointed out, in more friendly terms above.
See my other reply for an example that performance and safety don't play along well.
Well, you wouldn't be doing what you are doing right now if programmers didn't understand raw pointers and how to allocate and delete memory and so forth. Not everyone writes web sites or applets. The operating system you are working on right now clearly will have vast amounts of raw memory manipulation going on, as will lower level utility code and almost every bit of code that manages media formats or does any number of other resource constrained stuff.
Oh, no.
Furthermore, namespace pollution is an orthogonal issue. You can have perfectly clean namespaces which are divided logically and strictly and auto can bind to any type from any of them.
Transitivity holds, you just have to do the same comparison. What would it mean to say a Point equals a ColoredPoint? It‚Äôs ambiguous to the point of indeterminacy. The simplest arbitrary answer is False, they‚Äôre not equal, but if you don‚Äôt provide the arbitrary answer then either this shouldn‚Äôt compile or it should raise an exception. However, comparing Point to ColoredPoint After casting ColoredPoint to Point is unambiguous. It will compare their Points. Similarly, if you compare two ColoredPoint point objects which have equal Points but different colors, the equality test will return True IFF you cast both to Point type first.
That's fundamentally untrue. In modern C++ how many classes are full of operators that do various things? How many classes have a remove all or a add or a push and on and on.
Often, people think that an array of pointers is the same as a 2D array.
I'm going to disagree: std::shared_ptr&lt;MyType::NestedType&gt; const ptr { std::make_shared&lt;MyType::NestedType() }; I'd MUCH rather see: auto const ptr { std::make_shared&lt;MyType::NestedType(); } And many other places as well. I've found that it's often better to use auto when the actual type doesn't matter, but rather its behavior (effectively duck typing). This has made code much easier to modify to change the underlying type without having to change a bunch of other client code -- making it clearer when reviewing the commit what the actual core change is. For example... do I really care if it's a QSharedPointer (yuck), or a std::shared_ptr to just use it as a pointer? If the things that I need to do with it don't matter which it is, then I much prefer auto as it makes it much easier for me to later transition away from the horrible QSharedPointer to std::shared_ptr (as an example that I deal with far too often) auto const ptr = interface.GetObjectPointer(); This is quite common in the Qt codebase that I work in where people use Qt types far too often (IMO they should be limited to GUI layer only, or well encapsulated with a standard interface if there's no better option elsewhere). Since the Qt types have analogous calls to the std types you can often write code that doesn't care about the actual type, making it easier to refactor later.
Normally, in C++, you'd use `memcpy`: uint64_t representation = 0x3fe9000000000000ull; double value; std::memcpy(&amp;value, &amp;representation, sizeof(value)); std::cout &lt;&lt; value &lt;&lt; std::endl; //On a IEEE754/twos compliment machine, should print 0.78125 With C++20, however, we have access to [`std::bit_cast`](https://en.cppreference.com/w/cpp/numeric/bit_cast): uint64_t representation = 0x3fe9000000000000ull; double value = std::bit_cast&lt;double&gt;(representation); std::cout &lt;&lt; value &lt;&lt; std::endl; //On a IEEE754/twos compliment machine, should print 0.78125 Incidentally, one major benefit of `std::bit_cast`? It's `constexpr` (which can't be done with `memcpy`!), meaning it's valid for code like this: constexpr int64_t representation = std::bit_cast&lt;int64_t&gt;(74.13457);
Well, I don't use the STL so I typically don't have to deal with their ridiculously convoluted templatized code. When types get so long that typing one becomes a major burden, that's probably a sign something is wrong to begin with. But, nonetheless, I'd still explicitly indicate it. It will take me a couple seconds to do it once, but might cost me days of terror a year later trying to figure out a subtle bug that was introduced by me not being explicit. Of course I'd also likely alias such a type if I was using it in more than just a few ad hoc scenarios, which also makes it completely easy to change but also still strictly typed.
I've seen `std::vector` be derived from. And then they wonder why I think all hope for humanity is lost.
Unless if you're actually a colleague of mine, after a decade of preaching it probably is a lost cause.
&gt; Lambdas that don't have any bound parameters are a special case because they're guaranteed to have the same type as a regular function pointer. Not quite ‚Äì they're _convertible_ to function pointers, but they each have distinct types just like lambdas with captures.
Very true (unfortunately). I had a specific hierarchy in mind that has about 5. Not as bad as they come, the top level is even pure virtual, but the bottom four all add so much member variables it's easily the most difficult I can think of. Did I mention that there are (virtual of course) methods where only the casing of the name is different but they do very different things?
Another use for inheritance is turning off destructors in RAII by having a parent class with an empty destructor.
If you're not using STL, why are you using C++? I can't imagine what you must be using -- in my experience, people who choose to use some major feature of the language end up doing something FAR FAR worse, which may not be what you're doing, but it does make me suspicious.
I see this all the time and it drives me nuts.
Both variables are [_default-initialized_](https://en.cppreference.com/w/cpp/language/default_initialization) ‚Äì for scalars this means uninitialized (and reading the value as you are is actually undefined behavior), but for `std::string` this means default-constructed. N.b. questions go in /r/cpp_questions, not this subreddit.
Can you give an example?
That cocrruption issue should now be fixed in version 3.2.3
A screwdriver is useless if you keep turning the wrong way.
With that reply and this one, I‚Äôm not advocating inheritance, but the nice thing here about inheritance vs composition in this case is that I don‚Äôt have to know the name of the Point component of a ColoredPoint object, I just cast to Point type. But that is a single inheritance example. What about the color? What if you have charge, mass, color, spin, position and velocity as individual aspects and you have various types which combine them via multiple inheritance? I wouldn‚Äôt want to inherit from ColoredPoint to create a massive colored point type, nor would I want to inherit from MassivePoint type or ColoredMass type. So, I wouldn‚Äôt be able to (trivially, by inheritance) cast both massive colored point and charged colored point to ColoredPoint type when I want to compare both their color and position. I could cast them to Color and Point, separately, and combine their comparisons, though, if they inherited those types directly. I‚Äôd say a ColoredPoint is not a Point, no more than a ColoredPoint is a Color, so inheritance is inappropriate here.
I have my own entire system, from the ground up. It's open sourced if you care: https://github.com/DeanRoddey/CIDLib It's a totally integrated system that doesn't use the STL at all, and that provides the functionality that modern applications require without having to slap tens of of third party libraries together.
Thanks for the reply, but I still got questions...I'll move it over to [/r/cpp\_questions](https://www.reddit.com/r/cpp_questions).
50% is quite a lot, but it doesn't seems to be as bad as that actually. Defining and using the functions outside the class produces the same instructions. Not sure what was going on in your code but perhaps something to do with using `__attribute__((noinline))` on an inline function. [https://godbolt.org/z/ospdGc](https://godbolt.org/z/ospdGc) When I said "twice as big" I was actually refering to the size of `std::optional&lt;std::reference_wrapper&lt;int&gt;&gt;` compared to `int*`. [https://godbolt.org/z/GxF\_Qj](https://godbolt.org/z/GxF_Qj)
Are you suggesting that the following should return different results? Point&amp; p1 = a; Point&amp; p2 = b; return a == b; Versus ColoredPoint&amp; p1 = a; ColoredPoint&amp; p2 = b; return a == b; You could accomplish this by making equality comparison non-virtual. It technically satisfies the transitive property you're looking for but it seems otherwise unintuitive and I'd rather prefer making this situation impossible by breaking the polymorphic relationship.
So? I'm kind of assuming your familiar with what AAA code is, rather than just writing a long diatribe on it without any prior knowledge. For example, let's take a fairly complex piece of sample code, and let's take an algorithm for a generic cartesian product algorithm over a sequence, one that should be efficient: ``` #include &lt;cstddef&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;vector&gt; template &lt;typename T, template &lt;typename...&gt; class C&gt; struct is_specialization_impl: std::false_type {}; template &lt;template &lt;typename...&gt; class C, typename... Ts&gt; struct is_specialization_impl&lt;C&lt;Ts...&gt;, C&gt;: std::true_type {}; template &lt;typename T, template &lt;typename...&gt; class C&gt; using is_specialization = is_specialization_impl&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;, C&gt;; template &lt;typename T&gt; using is_reference_wrapper = is_specialization&lt;T, std::reference_wrapper&gt;; template &lt;typename T&gt; struct iterator_reference { using type = std::conditional_t&lt;is_reference_wrapper&lt;T&gt;::value, T, std::reference_wrapper&lt;const T&gt;&gt;; using container_type = typename type::type; using value_type = typename container_type::value_type; using iterator = typename container_type::const_iterator; using reference_type = std::conditional_t&lt; is_reference_wrapper&lt;value_type&gt;::value, value_type, std::reference_wrapper&lt;const value_type&gt; &gt;; static iterator begin(const container_type &amp;t) noexcept(noexcept(t.begin())) { return t.begin(); } static iterator end(const container_type &amp;t) noexcept(noexcept(t.end())) { return t.end(); } }; template &lt;typename BidirIter, typename F, typename Allocator&gt; void product_impl(BidirIter first, BidirIter last, F &amp;f, const Allocator&amp; allocator) { using traits_type = std::iterator_traits&lt;BidirIter&gt;; using value_type = typename traits_type::value_type; using helper = iterator_reference&lt;value_type&gt;; using iterator_type = typename helper::iterator; using reference_type = typename helper::reference_type; using iterator_allocator = typename std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;iterator_type&gt;; using reference_allocator = typename std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;reference_type&gt;; using iterator_vector = std::vector&lt;iterator_type, iterator_allocator&gt;; using reference_vector = std::vector&lt;reference_type, reference_allocator&gt;; auto iterator_alloc = iterator_allocator(allocator); auto reference_alloc= reference_allocator(allocator); auto buf = iterator_vector(iterator_alloc); auto val = reference_vector(reference_alloc); // sanity check if (first == last) { return; } // fill vector for function calls auto size = distance(first, last); auto k = size_t {0}; buf.reserve(size); val.reserve(size); for_each(first, last, [&amp;](const value_type&amp; value) { buf.emplace_back(helper::begin(value)); val.emplace_back(*helper::begin(value)); ++k; }); // iterate over all elements auto it = first; while (it &gt;= first) { k = it - first; if (it == last) { if (f(val.data(), val.data()+val.size())) { // early, manually-specified break break; } --it; } else if (buf[k] != helper::end(*it)) { val[k] = *buf[k]; ++buf[k]; ++it; } else { buf[k] = helper::begin(*it); if (it == first) { return; } --it; } } } template &lt;typename T&gt; struct sequence_sequence_product_helper { using first_type = typename T::value_type; using second_type = typename first_type::value_type; using reference_type = std::reference_wrapper&lt;const second_type&gt;; using byte_allocator = typename std::allocator_traits&lt;typename T::allocator_type&gt;::template rebind_alloc&lt;std::byte&gt;; using sequence_allocator = typename std::allocator_traits&lt;byte_allocator&gt;::template rebind_alloc&lt;reference_type&gt;; using sequence_type = std::vector&lt;reference_type, sequence_allocator&gt;; using matrix_allocator = typename std::allocator_traits&lt;byte_allocator&gt;::template rebind_alloc&lt;sequence_type&gt;; using matrix_type = std::vector&lt;sequence_type, matrix_allocator&gt;; }; template &lt;typename T, typename F&gt; void sequence_product(const T&amp; t, F &amp;f) { using helper = sequence_sequence_product_helper&lt;T&gt;; using sequence_type = typename helper::sequence_type; using matrix_type = typename helper::matrix_type; using byte_allocator = typename helper::byte_allocator; using sequence_allocator = typename helper::sequence_allocator; using matrix_allocator = typename helper::matrix_allocator; // get the allocator auto byte_alloc = byte_allocator(t.get_allocator()); auto sequence_alloc = sequence_allocator(t.get_allocator()); auto matrix_alloc = matrix_allocator(t.get_allocator()); // initialize the wrapper matrix auto matrix = matrix_type(matrix_alloc); matrix.reserve(t.size()); for (const auto &amp;outer: t) { auto sequence = sequence_type(sequence_alloc); sequence.reserve(outer.size()); for (const auto &amp;inner: outer) { sequence.emplace_back(inner); } matrix.emplace_back(move(sequence)); } // call the product product_impl(matrix.begin(), matrix.end(), f, byte_alloc); } template &lt;typename T, typename F&gt; void product(const T&amp; t, F f) { sequence_product(t, f); } int main() { auto aa = std::vector&lt;std::vector&lt;int&gt;&gt; {{1, 2, 3}, {4, 5, 6}}; product(aa, [](auto first, auto last) { std::cout &lt;&lt; "["; for (auto it = first; it != last; ++it) { std::cout &lt;&lt; *it &lt;&lt; ", "; } std::cout &lt;&lt; "]" &lt;&lt; std::endl; return false; }); return 0; } ``` This is AAA style (it differs slightly from my own style, I tend to do `type value {init}` rather than `auto value = type {init}`, but... At no point is anything here type-ambiguous. The only times the IDE comes into play is when you're unsure of the return type from a given function, which, is intentional. Say we want to change the implementation of an internal function to use a deque instead of a vector, now I need to grep everything and replace it. This isn't an example I'd use in production (overly complex for what it's doing, the real purpose was to be able to do cartesian products also over associative containers and sequential containers). That is to say, even with AAA we know: 1. When we're using containers, iterators, size_t, etc. 2. Instead, we're mostly working on interfaces: `for (const auto &amp;outer: t) {...}`, `for (const auto &amp;inner: outer) {...}`. We expect some sort of behavior, and we don't really care what type of iterator we get. Simpler examples include (taken from [here](http://cginternals.github.io/guidelines/articles/almost-always-auto/)): ``` // Stack Allocation auto e = employee{empid}; // Heap Allocation auto w = std::make_unique&lt;widget&gt;(); // Literal Suffixes (User-defined suffixes coming in C++14) auto x = 42; // int auto x = 42.0f; // float auto x = 42ul; // unsigned long auto x = "42"s; // C++14, std::string auto x = 42ns; // C++14, std::nano_seconds // Function declarations and named lambdas auto f(double) -&gt; int { ... } auto f = [=] (double) -&gt; int { ... }; // Alias declarations using dict = std::set&lt;string&gt;; template &lt;class T&gt; using vec = std::vector&lt;T, myalloc&gt;; ``` Do you notice how in none of these cases type information is lost? Almost always auto isn't about obscuring necessary types to remove your code's type information, it's being dry to avoid repeating yourself (which also helps the compiler), and if you absolutely need to get the type from a returned function, your IDE should be able to do that. That being said, if you don't know what that function does, you should probably look at it regardless.
Oh man you make me chuckle. I wasn't proposing stopping you from using pointers, I never demanded they be removed. I never suggested we rewrite an OS without pointers, so why the hyperbole? Please don't tell me it was to suggest people can be better. My core point is and stands to be that raw pointers are a specialist area. I know how to use raw pointers, but I am pretty sure I can go a long time without teaching new coders to use them. Do you know what the junior at our offices did today? They got our software running, setup DNS and some other high-level working prototypes. Maybe in 5 years time they will be stepping through memory dumps, like one of the other programmers suggested today as a way to debug the threading and complexity they and a senior had recently shat into the codebase. Knowing when and how are things that come with time. There is no need to teach people all that detail, when they mostly won't be using it.
All the operators do different things, but should be unique specifically to the family of types in question. `operator+()` shouldn't behave differently for any numeric number, and if you want concatenation, it shouldn't behave differently for any sequence or string, even though it may be implemented for both numbers and strings. But if you are willy-nilly replacing strings and integers in your code, you're doing **much** more than just refactoring or changing implementation details, you're changing logic in your code. So, no.
Okay, `memcpy` is an obvious solution and `constexpr` helps a lot, but is there no way to avoid a copy and not hit UB? From the gcc's man page: -fstrict-aliasing Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an "unsigned int" can alias an "int", but not a "void*" or a "double". A character type may alias any other type. Pay special attention to code like this: union a_union { int i; double d; }; int f() { union a_union t; t.d = 3.0; return t.i; } The practice of reading from a different union member than the one most recently written to (called "type-punning") is common. Even with -fstrict-aliasing, type-punning is allowed, provided the memory is accessed through the union type. So, the code above works as expected. However, this code might not: int f() { union a_union t; int* ip; t.d = 3.0; ip = &amp;t.i; return *ip; } Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.: int f() { double d = 3.0; return ((union a_union *) &amp;d)-&gt;i; }
You invoked namespace pollution to special plead why Rust was different than C++, so yes, it is an orthogonal issue, but you **brought** it up.
using namespace std Its bad because of global scope pollution, but C++ teachers tend to use it. Even some of them recommend putting it in public header.
Based on the C++ questions I see on Reddit: * Using the old C string library (`strncpy`, etc.). * Using built-in arrays. * Using `new`/`delete` as your default, general-use memory-management method. * Using `cin &gt;&gt; ` as your default, general-use input method. If people would stop teaching those, then half of the C++ questions on Reddit would vanish.
I spent a few years working at a company with \~1mil LoC software that was about 10 years old at that point that we migrated pretty heavily to auto almost everywhere. For the most part, I found it easier to read not harder. But, YMMV and I understand not liking that style. I have been doing a lot of legacy Java lately and I really find FizzBuzzEnterpriseEdition style code pretty difficult to read.
by "it" are you referring to the lifetime profiler? the example in the issue is the same as the one the lifetime profiler catches so thats why im confused. and surely youre not surprised that static analysis isnt 100% or that building static analysis tools is challenging. So i cant really place the significance of the link but i will guess anyway :p if your worried about false positives/false negatives, imo thats why you dont rely on only one static analyzer (and why dynamic analysis is crucial), also imo a good static analyzer should have a way to do inline suppressions e.g. `//NOLINT` in clag tidy. Extra analyzers help with your missed detections, and inline suppressions are there for false positives. obv the scope of static analysis is limited but its undoubtedly helpful for fighting the exact problems OP is talking about. Plus its not the only tool you have. I cant emphasize enough that asan or valgrind would have caught all of those no problem (actually if you take a look at the clang feature report in the issue you linked, you can see a demo of asan catching the same error).
Thank god compilers started [warning about this](https://gcc.godbolt.org/z/xTvwby), though I'd imagine the people doing this largely intersect the people compiling without warnings.
Good point. I'm not sure how it's internally laying out the `has` flag in the optional (seems like 4 byte) but no idea what reference_wrapper is up to.
I mean you often could change language a bit to make static analysis work without false positives. When you forbid aliasing for instance. Affine types is an example of that. But you can't change the old behavior since backward compatibility and stuff. So you have to create some new language. Overhauling of the old one has its limits. I see people waiting modules for decades and it still not here. Why? Because it's so complicated to get it in existing language. No one would use a tool which gives even 10% false positives because it's a lot. But changing the language a bit allows to reduce it dramatically. This is why this is the way increases productivity and coding pleasure.
Alright, here's the hill I die on. C++ features that should never be used: 1. Using `[]` to mean pointer addition 2. Pointer to a member function 3. Function try blocks
Well, there is no easy way to have them both, but there could be smart ways. PhDs works hard to make it possible and after several decades since C++ was originaly designed they are probably aquired enough of good ideas to make a breakthough. Rust is one of this ideas. It may be not ideal, and there probably would be successors, but it's defenitely a step in the right direction. Stronger type system, typeclasses instead of OOP and so on, this is what I wish for C++ too, but these changes are too big to make it happen in reality. You can't fix the most profound problems with tools and guidelines, you need shift the whole picture of how you organize the code. I wish we have GADTs, functors and other fancy stuff in mainstream languages alongside with performance and nativeness. Rust isn't there, it doesn't have GADTs or functors, but there probably would be more languages. Idris looks promising as well but it's quite far from mainstream... I wish I see some alternative in near future... I wish.
I ‚Äú think‚Äù that I‚Äôve learned a few things from this thread already. As noted Best Practices evolve over time, especially with Languages like C++ that have gone through major overhauls. It would be interesting to compare best practices from the 1990‚Äôs to today‚Äôs best practices for modern compilers.
Is it bad that I don‚Äôt know what‚Äôs so bad about this? Other than the fact that not using pointers would work just fine 99% of the time
I put a Linux binary out there. Will make frequent public updates from here on out. https://www.circle-lang.org/
Single entry, single exit. I understand the reasoning in C, although even there it's ugly and makes your code utterly complex. In C++ there's no reason for it thanks to RAII and smart memory management. Check the conditions and return immediately, if not fulfilled, don't create a monster of if clauses.
The extra space is probably just padding. The flag could be stored as a bool (1 byte) but the pointer needs to be properly aligned which means that on x86-64 it will need to waste 7 bytes just so that the pointer is stored on an address that is divisible by 8. | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16| | | | | | | | | | | | | | | | | | |B | | | |O | PADDING | POINTER | |O | | | |L | | |
Doesn't matter. They are SYNTACTICALLY the same. If you change the type by accident and they both implement the same operators or the same methods being called, the compiler will not care.
Yeh, I gave up on that decades ago.
A lot of places, even in respected C++ codebases, use them pretty extensively for flow control. Even common utilities (like fstream) in the C++ standard library default to exceptions, and you have to disable them (like in basic_ios) or avoid them (don't use `at`, manually check indexes), etc. You can see this fairly clearly in even very popular codebases, for example: https://github.com/zeromq/cppzmq/blob/d1e7c538cc37da42d73bc860980805f33ceebcef/zmq_addon.hpp#L383 Rather than have a return value signalling an error occurred, an exception is used instead of conditionally rollback on error. In any performance-critical code (it doesn't matter here, mostly because the overhead of the method will likely far exceed the actual exception overhead), this would lead to significant performance drawbacks. WxWidgets also does this all the time: https://github.com/wxWidgets/wxWidgets/blob/e9fb190ed7c06b7a6246f6082c992a2dfec1fb0d/src/msw/ole/droptgt.cpp#L202 Fairly good libraries tend to avoid catching exceptions in general, so the problem isn't as pervasive in a lot of high-quality C++ libraries, but it's fairly paradoxical for many developers to avoid C++ exceptions except for a very high-level.
 **Company:** [Stellar Science](http://stellarscience.com/index.html) **Type:** Full Time regular W-2 employment with phenomenal benefits. **Description: Stellar Science is seeking several Modern C++17 Developers** with experience creating reusable, maintainable code solving challenging math and physics problems. BS (or equivalent experience) required, MS/PhD degree desired. Join our unique, collaborative team to help implement leading-edge scientific software tools in fascinating domains. **Location(s):** Albuquerque, NM or Vienna, VA **Remote:** Remote work is not immediately available. **Visa Sponsorship: NO -** US Citizenship is required + willingness to undergo background investigation. **Technologies:** C++14, C++17 - Cross-platform software development on Linux, Windows, Mac **Experience in any of the following is a plus:** ¬∑ Additional languages: Java, Python, JavaScript ¬∑ Relevant libraries: Boost, Qt, Guava ¬∑ Cross-platform development on Linux and Windows ¬∑ 3D graphics: OpenSceneGraph, OpenGL, WebGL ¬∑ Supercomputing: MPI, OpenMP, threads, GPUs ¬∑ User interface development: Qt, Swing, GWT ¬∑ Continuous integration: git, Bitbucket, Jenkins, CMake ¬∑ Image processing, imagery analysis, computer vision, computer aided design (CAD) ¬∑ Aerospace vehicles, orbital mechanics, electromagnetics, space situational awareness ¬∑ Modeling and simulation, including directed energy **Code sample or C++ evaluation required.** **Extremely flexible work schedule &amp; generous benefits.** **US Citizenship required + willingness to undergo a background investigation.** Vienna, VA / NoVA - [https://stellarscience.applytojob.com/apply/ODTuzXfAJK/Modern-C-Developer-NoVA?source=reddit-cpp](https://stellarscience.applytojob.com/apply/ODTuzXfAJK/Modern-C-Developer-NoVA?source=reddit-cpp) Albuquerque, NM / ABQ - [https://stellarscience.applytojob.com/apply/yKnRIXYDtZ/Modern-C-Developer-ABQ?source=reddit-cpp](https://stellarscience.applytojob.com/apply/yKnRIXYDtZ/Modern-C-Developer-ABQ?source=reddit-cpp) POC - John Jones - Technical Recruiter - [jjones@stellarscience.com](mailto:jjones@stellarscience.com)
``` const auto first = range.begin(); const auto last = range.end(); logger.add(std::string_view(&amp;*first, last - first)); // call std::string_view(const char*, size_type)```
C++ is kind of weakly typed: you can do even meaningless things in regards to types: like reinterpreting a pointer to a type into a pointer to a completely unrelated type. Python, JS, etc. are dynamically but way more strongly typed: you can't break havoc (read: corrupt the VM) by merely doing a mistake on types (like an **unchecked** std::optional deref when it was actually null) : you however will tend to notice type errors later (at runtime instead of at compile time), but you DO notice them (attempting to call methods on None will throw an exception, and not format your hard drive...)
We've had like 50 years of dynamic languages that do just this and this isn't a problem. We also have the same behavior in Rust, Go the same issues exist and yet no one's complaining about how their code suddenly broke unless they massively changed the underlying code without checking it. **Rust** ``` // Ints let mut sum = 0; for i in &amp;ints { sum += i; } // Strings let mut concatenated = String::new(); for str in &amp;strs { concatenated += str; } ``` **Go** ``` // Ints sum := 0 for _, i := range ints { sum += i } // Strings concatenated := "" for _, str := range strs { concatenated += str } ``` I'm not sure why people are special pleading C++ for this.
I feel ya, but it's not the users' fault that the language doesn't allow extension via any other method, even if we require that class extensions have no data members and only access the class through public methods. Here's a dumb example, but I had a project where I really wanted to have an `std::map` with a function std::optional&lt;ValueType&gt; get(KeyType const &amp; key) const { if ( auto iter = this-&gt;find(key); iter != this-&gt;end() ) { return *iter; } return std::nullopt; } I have no palatable way to extend `std::map` to provide this, even though doing so does not violate the class invariants in any way (since it's just `find` with some massaging of the return). The options are: 1. Subclass it, risk the wrath of the STL devs 2. Compose it, end up writing dozens of boilerplate function `operator [](auto x) { return this-&gt;map[x]; }` 3. Use a free function, which is gross I chose 1, and I will accept the wrath (and undefined behavior) as is my due. No regrets.
Maybe it aims at. But arguably it fails. There are safe languages that are now faster. C++ on the other end, likes to repeat the billion-dollar mistake over and over again. On my side, that is what I feel is getting old.
Codegen for std::function seems a little rough even in non-capturing lambdas: https://gcc.godbolt.org/z/c5cMMw
Though I don't use them much, a pointer to a member function is fundamental to providing good encapsulation of threads within threading frameworks, so I use it in that context.
Burn it before it spreads
Bound checking usually can be hoisted out of loops. If the profile shows that it is not enough, then targeted micro optims shall be employed. But C++ do not give tools to properly isolate those kind of dangerous manual optims that must be reviewed more specifically.
I think fundamental is a bit overstating it, but maybe I'm missing something. What is being encapsulated? A thread or a work item?
The correct answer is (3), and it is not gross.
After five level is no more spaghetti code... it's lasagna code.
You forgot to add `class TextWindow final` ‚Äî that‚Äôd be the best contract ;)
*optval on std::optional is totaly unreasonable to be unsafe. And there is no need for it to be by default, if the only reason would be to be compatible with 30 year old code.
Im a freshman who's taken two c++ classes in uni right now, why is this bad practice? My teachers told me that I will pretty much always use namespace std, and that I need it in all my files.
Those are trivial examples. Anything is safe in four lines of code. When it's four million lines of code things get a lot different. And, I have to ask, how many of the commercial applications or operation systems you use were written in those types of languages? It's fine for a web site, but there's a world of space between that an a huge application to be maintained over decades.
Everything. Given what the language is and must stay for backward compat, it will always be unsound. Still *WAY* better than nothing, though.
Any reasonable threading framework is going to vector the thread into a method of a class, or have that as one of the primary means of running threads. There's no other way to do it besides a pointer to a class member.
OK, but please agree with me that it's just a matter of syntactic sugar to transform `obj.func(arg);` to `func(obj, arg)`. I'm not asking for semantics, just for being able to bind a free function to a class and call it with `.` and `-&gt;`. [ Which anyway is the core language problem and not the STL's problem at all. ]
does code like \`auto x = my\_type{...}\` count? I use this style a lot when the types are not deductible easily from the names.
Valgrind is only dynamic, not static. Likewise for compiler-based sanitizers. On a subject as critical as VM corruption, it is unfortunate to only have unsound or dynamic tools.
&gt; No one would use a tool which gives even 10% false positives because it's a lot well i dont have any such data handy (do you?) so im not sure what false positive rates actually are. but i can tell you that clang-tidy seems relatively popular and i've had good experiences with it. still though if you really hate static analysis so much, you can just use dynamic analysis instead (: Besides that, it doesnt even feel like we are talking about preventing vulnerabilities in c++ code anymore so, on the topic of breaking changes to the language: idk theres a lot to say on that topic. obv there are the downsides you mentioned, but the cost of a breaking change in the language would be pretty substantial i expect. So even if it was done it would be a huge deal and the benefit would have to be insane.
You mean something like thread_fwk_async(this, m_function); Why not thread_fwk_async( [this]() { this-&gt;Function; } ); Maybe I'm confused what it means to 'vector a thread into a method'. That sounds like "execute this class method on this class object in a thread", but maybe not.
This reads like nonsense, why would short access functions that return references and can be inlined make anything slow? Why is there any implied inheritance?
It pollutes the namespace, suddenly everything from the standard library is in the surrounding namespace, you can easily get name conflicts and for example call a different function then you meant too, your code won't behave in the way you expected and it can take some time to figure out what's happening, especially if you're a beginner. It was a problem in C when you used 2 independent libraries which happened to use the same names for something, so avoiding that was the entire point of adding namespaces to C++. If you want to read more, here's a thread on Stack Overflow: [https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice](https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice) FAQ on the Standard C++ Foundation website: [https://isocpp.org/wiki/faq/coding-standards#using-namespace-std](https://isocpp.org/wiki/faq/coding-standards#using-namespace-std)
That is not a question of education. Having UB everywhere is retarded. *Even more so in newly specified facilities.* I'm not made at string_view because C++ just can't do better. But std::optional * having been specified as UB... I'm speechless. I would have been happy with .unsafe_deref() or something like that.
&gt; "all member variables shall be encapsulated behind getters and setters" When is it not the case ?
As /u/AssKoala said. This is perfectly fine. You are saying this is bad without knowing the size of the object the person is allocating. Knowing when to allocate on the heap vs the stack is an important part of memory management.
It's the latter, but that's still essentially a pointer to a class method. The fact that you used a lambda wrapper just means it's a pointer to a function that is pointer to a method basically. It's just syntactical sugar. In my framework, threads are objects, not just magic things in the background that you point at something. And you give them target objects that tell them what to call because they don't immediately call it. They will only call it once the thread is started. One of the target types is a method of an object, which needs to get a pointer to a method of that object.
Try writing a vector and matrix class like that for a gaming system.
And I never suggested you suggested those things. I just said, it makes no sense to me to train programmers without training them to understand what they are manipulating. It doesn't have to be on day one, but if they want to be more than code monkeys they need to understand these things. If anyone came out of school without having been taught about such things I'd be asking for my money back.
1. What is the intended way to convert a `std::filesystem::path` to UTF-8 encoded `std::string` in C++20? Keeping in mind that it should work in Windows? 2. Is there any way at all to portably and guaranteed get a path to the executable's directory, if such directory exists? Keeping in mind that that's often different from current directory.
&gt; well i dont have any such data handy (do you?) so im not sure what false positive rates actually are. I just saw myself projects with thousands of warnings which were never fixed because some of them was false positives and people got tired of fixing them and just disabled them in IDE so it was like "show 0 warnings from 5612". It doesn't excuse them but it explains a bit how people think. &gt; but i can tell you that clang-tidy seems relatively popular and i've had good experiences with it. still though if you really hate static analysis so much, you can just use dynamic analysis instead (: The only thing that really work is compilation errors. Dynamic tools like profilers and linters are strictly worse than type system, the same applies to tests. It's should be the last resort when everything else was done, but not a tool for everyday use. Typesystem of the language should be expressive enough to catch up all common patterns. &gt; Besides that, it doesnt even feel like we are talking about preventing vulnerabilities in c++ code anymore so, on the topic of breaking changes to the language: idk theres a lot to say on that topic. obv there are the downsides you mentioned, but the cost of a breaking change in the language would be pretty substantial i expect. So even if it was done it would be a huge deal and the benefit would have to be insane. Cost of breaking change is so high that no one ever will do that. This is why new languages has concept of epochs that allows them to abandon some features, but the old ones just have this burden forever. For example people asked microsoft to implement not-null types for more than decade and they only implement it as a flow checker that produces some warnings. Of course you can treat them as erros but anyway. And we're talking about one billion mistake which is pretty easy to fix with the tool (just change types `T` to types `Nullable&lt;T&gt;` in the whole program and it will keep the old meaning), but they didn't went to the errors or any breaking changes. What to say about less significant language design flaws. So no, I don't believe breaking changes are possible. I justify that we need new languages, and we shouldn't be reluctant to use them. People makes don't make languages just to show themselves or something, they do that when they are dissatisfied by all existing ones. And some times they solves a really big assnail.
CAS = Copy and swap. Implementing your assignment operator to use the copy-constructor and a swap operation. T&amp; operator=(T rhs) { swap(*this, rhs); return *this; Basically the same as your example but factored differently.
Got it. If I were writing that, I would probably type the target function as a `std::function` which would encapsulate both the method and the object into a single callable. YMMV :-)
I don't use the STL. But, I likely wouldn't do that though. I'd prefer these things to be concrete classes of their own, that can be treated polymorphically since they will have other applications outside of threads.
'auto' doesn't work well when you don't have the best names for the variables or methods: auto foo = bar(); Reading that, you can't tell what's going on, but this example is easy to understand: auto firstName = QueryUserForFirstName(); There is still the criticism that 'auto' still hides which type 'firstName' is, and what operations you can use with it. However, I find that many codebases I have to work in, I'm still not sure what operations I can use if it's not a standard type: SuperStringType firstName = QueryUserForFirstName(); Since I use an IDE, I can still see which type is returned fairly easily. I also like that 'auto' lets me change the return type of QueryUserForFirstName() with a new type or fa√ßade that implements the same operations of the old type without having to update all the current callers.
wxWidgets has many problems, but using exceptions for flow control is not one of them. You're misreading the code at the link you gave, all this try/catch does is to prevent exceptions thrown by the user-defined event handlers from leaving the module boundary, which is quite different.
If they have time to embed a scripting language into their program, which necessarily includes all the things to isolate the internals, they would do that. And why would it be running in the context of the program? Browsers don't let Javascript run in the context of the main program. So if you have time to embed a scripting language, you would also have, by necessity, already done the process isolation. I mean, these are all solved problems.
Solved isn't the same as implemented. Browsers probably go through a vast amount of complexity to get that isolation because Javascript is an unconstrained language. And it's not just the main process, even if they spawn off a process per tab, they still probably have to protect that process from the javascript it invokes as well. If your scripting language doesn't allow those things, you can save a vast amount of work and worry because it can safely be embedded in the process.
Yes, SE/SE is a notion that needs to die. Herb Sutter is particularly un-fond of it as well.
OOP is fine, just overused. Particularly in the context of *teaching* it is taught as the solution to everything.
\`auto\` is cute because you don't have to remember the precise return type of a function: \`\`\`auto x = f();\`\`\` but then \`f\` throws an exception and \`\`\`auto x; try { x = f(); } \`\`\` doesn't work.
I've been programming for \~20 years, in C++ specifically for almost 10. I still \`using namespace std;\` I've heard countless times that it's bad, but it seems to work just fine for me. I've never gotten bitten by doing it. #changemyview &amp;#x200B; **Disclaimer:** I absolutely do NOT allow \`using namespace\` to appear in any header file whatsoever. **Disclaimer 2:** I know there's ADL issues to be concerned with. Eh? I have a few custom \`to\_string()\`'s in my personal toolbox that sometimes become ambiguous with \`std::to\_string()\`. So I'll slap a \`utl::\` on it. Problem solved?
This is why smart pointers are a godsend.
I've done all of what you just described with complete success, including checking the assembly, using SIMD, and being aware of memory access patterns. I have no idea what you think is wrong or why. Do you think std::vector is slow?
I think objectively, having type information makes reading code much easier. However, it‚Äôs more annoying and verbose to type. What I do is use auto when I‚Äôm prototyping an idea myself, especially when type names are subject to change. Once everything is pretty set, i add in types everywhere and then push that commit.
I believe I read that Bjarne calls \`protected\` a failed experiment. I only use it when dealing with some goofy unit tests. It's definitely a code smell, and I'm glad it's there, but it should almost never be used.
The only way you could do that is if you exposed the raw data. If you do that, then you you could just use C. You have absolutely no means to apply constrains on the contents of the class if you do that. That's like the 1980s all over again.
Um, a growing number in recent years, and numerous bugs have been quashed in moving to those systems, albeit, since most errors and memory errors and Rust and Go tend to not have manual memory management, which quashes like 70% of all major software bugs. And you're pretty naively assuming the following: 1. If you don't have the type, you have any information on the variable. 2. If you auto-declare the type, you don't have type information easily available. 3. Type information is sufficient or at least mostly sufficient for this. None of these are true. `operator+()` on a `std::string` between UTF-8 and UTF-16 data will produce nonsense. Type information can help you with what you need to know, but it isn't sufficient nor close. You want to know if something is a mutable or immutable sequence of characters, you generally don't need to know if it's a string, or string_view, or if not using string-specific methods, vector&lt;char&gt;. You also need to know what this type is (is it a custom binary format? is it UTF-8? UTF-16? Shift-JIS?) If it's a number, you might care if it's a percentage or a pure number. Is it an angle? Is it in degrees, radians or gradians? Type information gives you none of that, unless you hard-code it into the type system, but it can be better to normalize it upon input so you only deal with a single unit of a given type. So my points pretty much stand: AAA increases refactorability, you need to know much more than just the return type of a value, rather, you should know the interface and purpose of a variable. Hard-coding a type doesn't give this to you. size_t can be an index, or an offset, or it could be a length.
obligatory: [https://xkcd.com/927/](https://xkcd.com/927/), Look forward to reading your sources.
Std::
Part of the reason many people might want to use auto is that modern C++ often requires ridiculously convoluted and long type names. If a type name if 25 characters long, even someone who wants to be explicit might just say the hell with it and use auto. If you are using much less templatized code, that's not so much of an issue and the wee bit of time it takes to be explicit may save you days of pain and death threats from customers at some point down the line.
Especially if you're in a shop where you get paid by the line, but need a little plausible deniability!
That assumes your implementation of your scripting language has no bugs. Even if your scripting language doesn't allow dangeous things, the script interpreter itself is necessarily doing those dangerous things. So you would STILL need to implement your scripting language to run in isolation. You're going to have to do the same work anyway.
Dunno about you, but I don't let my friends have access to my privates.
Not really, no. This is like arguing that you can't run your own program unless you can prove that your own program has no bugs.
This is completely untrue in both theory and practice. Do you think std::vector has performance penalties?
Yes, I'm in favor of unified call syntax. However, I don't think any syntactic concern is worth the semantic headaches that deriving from standard library types causes.
I would say it depends on what my_type actually is. auto is a very powerful keyword but it can be confusing to a user. auto newVec = makeVec(); That is very readable. auto will be a vector. However, if you do something like auto x = doThing(); then what is x? what is doThing?
What would you consider to be the best way to teach input?
Your point has some merit, but I think you misunderstood me. I do not try or intend to develop a new **standard** for everyone. Generalization is hard and that's why there are so many available solutions on the market. Each and every one focuses on particular set of problems, that hasn't been properly resolved by existing tools. The existing solutions did **NOT** suit **my** needs. I had to develop a new solution that puts needs of embedded systems (support for already defined third party protocols, compile time customization, robust and safe handling of malformed data, etc..) as its corner stone. The use cases that require high serialization / deserialization speeds are definitely not going to use my solution.
That's not weak typing. Unsafe casts are explicit requests to go beyond type system.
Well then that's when you take out decltype ```cpp int foo(); int bar() { decltype(foo()) a; try { a = foo(); } catch (...) { a = 0; } return a; } ```
The only time I like auto is when a section of code is meant to be implementation independent, or you have a seriously crazy type like some of the crap in &lt;chrono&gt;. In all other cases I think the sacrifice to code readability isn't worth it. From a people perspective I find its generally used by lazy or less rigorous developers and then they rationalize the choice with the auto talking points, but I'm sure there are exceptions to this.
Oh you are right in this case, I've been on my phone so it's somewhat harder to find examples. The POCO C++ libraries are a much better example in much of their networking code, where they use C++ exceptions to signal invalid results and therefore control flow, rather than a return value or some form of maybe monad. My bad.
Those are good thinking, but in the end you pay for what you wanted to do, and in the end it depends on whether you can afford the overhead: if it's fine, the good for you; if it's not, then too bad.
Hey thanks! That was not in my repertoire yet.
&gt; I just saw myself projects with thousands of warnings which were never fixed because some of them was false positives that sounds to me more of a specific case where static analysis was misused, maybe also with a combination of bad coding habits? or maybe it just wasnt a great static analyzer. but like i said clang-tidy seems to work for a lot of people. &gt; Typesystem of the language should be expressive enough to catch up all common patterns. ideally sure, but we dont have that. I agree that from a language design perspective its better for the language to detect errors compared to external tools, but my point is that you can still write safe and secure code in c++ right now if you use appropriate tooling. &gt; I justify that we need new languages, and we shouldn't be reluctant to use them. well i think you should always use the right language for the job. im cool with new languages and stuff. but the original point was just that you can write safe c++ code and the entire point of the article is countered by mentioning tooling.
That's not the same at all. Because running your own program involves running your own program. By definition, it's in a separate address space. You don't run a program in kernel space, do you? No, you claimed a script cannot hurt your program. But if it's running in the same processs, then yes it can. How can you argue against that? How can you argue against the precise reason why we have processes?
I don't think that many gaming systems would use such a vector or matrix class, because because either you have to piecemeal copy the values out to another block of data, operate on it, and copy it back, or you have to directly expose some sort of structure which completely violates encapsulation principles. Either way, it's not optimal compared to a vector that can both operate on its own data directly and maintain constraints on the contents. As to std::vector, I don't know. I don't use it. I'm pretty sure that various collection algorithms are slower than the versions of those things that can operate directly on the data. It's a basic convenience vs. performance trade-off. But most uses of collections in your average application isn't that performance constrained. However, I would have to ask you in turn, does std::vector expose all of its member and let you manipulate them yourself? If not, why not?
Isn't it still acceptable to just typedef those long types into something shorter and/or more local anyway? typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt; Moment; Timer::Moment start_time; Timer::Moment now();
Yes, I tend to do that too. I use it for prototyping ideas often, but almost always remove them before pushing.
You are right, I should not have used this as an example, because arguably it is explicit enough. However, I still can't make sense of the most handy operators of std::optional being specified as UB if it was actually nullopt. My understanding is that most compilations of programs actually exhibiting this (quite hidden, this time) bug will result in the type-system being bypassed and memory being accessed as-if it was the specified type, while there is garbage in there. I would be totally happy with a method called .unsafe_deref() doing that, given the rational is that *SOMETIMES* (rarely...) is needed to get that extra bit of perfs in a context where the compiler did not have enough information to make the optim itself, safely. But \*optvar... Yeah, I'll call a language that specifies a potential UB on that being weakly typed, no matter what the history of \*rawptr is...
I was making no point, just a joke and an encouragement that I intended to look at **YOUR** implementation that suited **YOUR** needs as opposed to others that I have seen such as MPack, NanoPB, etc.
OK, it's not exactly the same. But the point is, ultimately you have to trust that your own code does what you designed it to do, by thinking, testing, evaluating, bleeding on the floor, etc... Compare to the complexity required to have my CML engine run in another process, and all of the many different ways it would provide to make mistakes, I'm very comfortable having it being in-process. All of the code is either CML generated code, which is inherently safe because it's interpreted opcodes, or it's just very simple wrappers around my underlying C++ classes. I'm more than willing to take that very small risk compared to the vastly greater amount of complexity to do otherwise.
can someone elaborate on which situations might be slow to return a std::vector despite (n)rvo and why?
Yeh, that's what I'd do if I was having to deal with such crazy type names. If they were used at all publicly I'd alias them publicly and use those in any interfaces and internally. Then you have both type safety and the ability to globally change the type at any point if you want to.
I don't think I will change your mind, with that amount of experience you're already aware about the problems it introduces. But are you trying to say it's not a bad practice, or not a big deal most of the time? Because that's 2 different things I think. If you know what you're doing I suppose you can use it just fine for the source files but I don't see the point, you have another thing to worry about in an already complex language in exchange for typing a few characters less. That can be subjective to some degree, but the biggest problem with `using namespace std;` is teaching it to beginners and often not even telling them about the potential problems, and for them it's a bigger issue considering that they won't know a lot about what is in the standard library and what isn't.
I sense we are not talking about the exact same thing. All I'm saying is, some check is not supposed to be turned on by default. If it's on by default, then you also need a way to turn it off in some cases. Using this same bound checking example, in the end, the instruction is just reading from a memory address you give, and whatever else you want to do will introduce an overhead. If you can ensure you won't read outside that range, then you don't have to pay the price of bound checking.
Name one language that does what you said. I highly doubt you can. There is no room between C/C++ and bare metal that can host a safer language.
Its not that its slow to return a std::vector, its that if you call a function repeatedly which returns a vector that means it has to allocate fresh memory each time If you pass in an already existing vector, you can resize it to the correct size which may then involve a lot fewer memory allocations as there's a good chance your vector is already adequate
Well you cannot really have a non initialized ref so you'll have to put the try inside a lambda encapsulating the "foo" call then.
Exactly this. Some people suggest doing things just because it's what they are used to and they don't want to change their methods.
would a compiler not be able to do that for you, if it sees you are returning by value into an existing vector?
&gt; You're doing so by forcing everything else to become aware of the insivible code path that you're introducing. There's terse syntax in other languages for monadic flow control, like "?" for example in Rust. With the Rust "?" syntax, there's still just as many code paths, and the "?"'s have to be put in so many places that it just becomes noise. // With exceptions String EvaluateSalaryAndReturnName( Employee e ) { if( e.Title() == "CEO" || e.Salary() &gt; 100000 ) { cout &lt;&lt; e.First() &lt;&lt; " " &lt;&lt; e.Last() &lt;&lt; " is overpaid" &lt;&lt; endl; } return e.First() + " " + e.Last(); } // Hypothetically if C++ had Rust-like "?" syntax String EvaluateSalaryAndReturnName( Employee e ) { if( ((e.Title()? == "CEO")? || (e.Salary()? &gt; 100000)?)? ) { cout &lt;&lt; e.First()? &lt;&lt; " " &lt;&lt; e.Last()? &lt;&lt; " is overpaid" &lt;&lt; endl; } return e.First()? + " " + e.Last()?; }
Well, I work in embedded mission critical systems and we use some limited features of C++. No dynamic allocation, no rtti, no multiple inheritance, no exceptions, no stl, etc. What bugs me is that every C++ class starts off with new and delete and how to allocate memory. It leads to programmers who take it for granted and do not know how to size things when the system is constrained.
`std::remove_reference_t&lt;decltype(foo())&gt; a;`, I think. [type_traits reference](https://en.cppreference.com/w/cpp/header/type_traits)
A good use of auto is when you don't care what the type is. A bad use of auto is when you don't care to type out the name of the type. If your code if only using some basic generic stuff like an iterator then auto is probably fine (though note the subtlety between begin() and cbegin() which can introduce const errors more easily), but if all of what you're doing is predicated on it being a particular type then write it out. Nothing is worse than trying to figure out why something compiled - it's almost always due to a conversion you didn't expect or an operator you didn't know about. Fail early and loudly, let the compiler generate compilation errors rather than runtime errors. And consider using explicit on constructor taking one argument. I've personally never liked auto except in range based for loops over maps and anywhere it is required (trailing return type syntax).
&gt; What would you consider to be the best way to teach input? That's a bit tricky. Standard C++ has no easy to use, robust input method that works well at the introductory level (`"Type a number: "`). The trouble with `cin &gt;&gt;` is that it doesn't really do what we usually want, and it mixes poorly with `"Press ENTER to continue"` prompts, which are necessarily line-oriented. Some people teach `cin &gt;&gt;` because they really don't know any better, while others teach it in the expectation that students will switch to better methods once they learn them. But my experience has been that students tend to stick with the first method they learn. My *eventual* solution to the `"Type a number: "` use case is to use `getline` to read a line into a `string` object, then get whatever data you need out of the string, perhaps using `istringstream`.[1] And an error check (`if !(STREAM)`) must be done immediately after every read or open operation on`cin` or a file stream. When starting out, I can write an input-a-number function for students, and require them to use it. Once they know about `string` objects, I can start them doing input as above, but without the error check -- and I give them a stern warning that we are being *temporarily* evil. Then we do error checking, and I expect them to write it all. ---- [1] Why not `atoi` or `stoi`, you ask? The former does not return useful information if something other than a number is entered. The latter throws, which is fine, except that I want to be able to introduce input handling long before I tell people about exceptions.
Also, while it hides the type you see, it helps enforce the type the compiler sees. In other words, `auto` can only be exactly what it's supposed to be and there shouldn't be a risk of a sneaky implicit conversion if the underlying/returned type changes in the future.
Exactly! When in doubt write `public :` ... not `: public`
You can use `type_traits` to strip the reference and declare it as a value if you have to. I don't think a lambda is going to save you if you try to construct a local default in the `catch` and return a reference to that.
Mandatory use case for auto is with ranged for. for(auto&amp;&amp; v:values){ } Manually specifying the type name is just a recipe for mistakes, especially if `values` is an associative container.
&gt;What if it's the only option, if not today then maybe in near future? You can't add features indefinitely, and adding new features don't help fix old ones. Someday, but it doesn't seem like in a near future, maybe in 40 or 50 years assuming the last standard is c++17, when all the legacy code dies and when all the new c++ code written everyday becomes obsolete. &gt;Your position "How to fix the C++ to make it great" and you don't want to hear "there is no way C++ could be revamped". You may disagree but consider this point, it may be right. Oh, no, you misunderstood my comment, I want to hear how c++ will become obsolete by other languages, how other languages implement things, I like to learn a lot of different approaches to a problem and even when I consider C++ my favorite language most of my code written is in java and python. The problem is, with this article, it only shows examples of bad c++ that shouldn't pass any code reviews for secure sensitive software and it does not provide any examples on how to do it better, but everything would have been fine even if he only included the examples with the bad code, even if he showed examples in how to do it better in Rust or Swift I would have liked the article, the 'real' problem for me is that at the end he shows nothing of how can you do it better in any way but by killing c++ and moving blindly to any other language: &gt;... is that the safety of modern C++ is simply no match for memory safe by default languages like Rust and Swift &gt;Even with the most modern C++ idioms available, the evidence is clear that, at scale, it's simply not possible to hold C++ right.
You're probably making the standards committee's job harder. Even though they have their own namespace (std), you're making it harder for them to add any new names to their own namespace, because any new name they introduce might collide with a name in your cpp files. That exact kind of problem is why `unordered_map` wasn't named `hash_map`.
&gt; consider using explicit on constructor taking one argument. Using explicit should be your default and only go without it if you have a good reason to.
auto is fantastic. i dont care what type i deal with as long as it suits well in my algorithm. and that is all i care of. Sure, thete could be misstakes hidden like float to int conversion, unwanted copy and what not. but in my expiroence, they almost always prevented by solid strong types system, following coding convensions, stroct compiler aptions like -Wall atleast and static analyses. auto not only saves time in tuping, but on reading too. when i read an algorithm, i usualy dont care about types as long as this algo works proper. all i care of is understanding of whats going on. and if x int, or uint, or strong type does not matter if this x goes through series of opetations and compiler good with it. more to that, in most cases when algo does not work properly i still dont care about types it usong, though it is nice to have an ide to easely peek what's hiding behind some suto
Not a problem if you design-by-contract.
&gt; you have to piecemeal copy the values out to another block of data, operate on it, and copy it back, or you have to directly expose some sort of structure which completely violates encapsulation principles A std::vector returns a reference to an element, this pattern works well. Data structures are good for managing resources and accessing them. There is no reason to think data has to be copied out or it breaks encapsulation.
UB when it is nullopt seems reasonable to me. Anyway I was trying to say that it will be fair to compare real world codebase in rust vs c++ when the isage will. Be comparable. Because the programmer matters and when a language is as deployed as C++ for many years used by all kind of people, it is a bit ubfair to compare with newish languages where the majority of users are experts...
I disagree, I find it makes the code more readable.
It kind of defeats the purpose of using a strongly typed language doesn't it? Obviously it has its uses, but that I think is why people dislike it.
If the type is obvious from the right-hand side, then sure, e.g auto myThing = std::make_unique&lt;Thing&gt;(); Or when working with iterators or other very complex types. But the majority of time spent as a programmer is _reading_ code, not writing, so I optimize for that. Writing is insignificant.
Running a separate process and communicating via message passing is really not difficult. It's not vastly greater amount of complexity. In fact, I've already written one that can be run via a websocket, with no unsafe stuff necessary, for running "scripts". It's really simple.
Even if it is a standard type, you might not be clear what you can do with it if you don't know more about it. If it's a UTF-8 string, you cannot add UTF-16 data to it. If it's an angle in radians, you can't subtract degrees from it. Type information is one piece of the puzzle.
Are you saying people shouldn't be prefixing "std::" or that they shouldn't be using the STL in general? You're wrong either way.
Okay, I can definitely get behind that. For example, I try to be very clear to interns how it works and I'm not draconian about it; if they want to prefix everything with `std::`, that's fine with me.
What are you suggesting be the default memory management instead, I'm assuming you're not talking about `malloc` haha
What are you suggesting be the default memory management instead, I'm assuming you're not talking about `malloc` haha
No, it's not. Not when there could be hundreds of things that need to be communicated. All that stuff would have to be encoded into some sort of data structure to be passed back and forth. IPC itself is not hard. I have very good mechanisms to do it. But it's the actual stuff being IPC'd that's the issue. Way too much to justify, given how unlikely a problem CML is to be.
I know what I'm signing up for when `abusing namespace std;` (sic), so I'm not expecting any favors from the committee and certainly would never voice concern about changes that would break such code. I advocate for updating the toolchain as frequently as possible (though it's not even feasible more than once a year or so where I work), so any break would be obvious and most likely isolated. Either tests will start to fail (because of changes to ADL), or code will fail to compile (because of newly ambiguous resolutions); pretty simple to address IMO.
That post is 5 years old and talks about a design for concepts that was abandoned 10 years ago.
I've looked through it a bit. It's clear that you did a LOT of work on it, bigger than anything I've ever open-sourced, so please don't be offended by my comments. To be honest, I'm not a fan. First and foremost, I think you seem to have missed the primary benefit of the STL, which (for the most part) takes a functional programming approach of separating algorithm from data, allowing you to apply functions to ranges of data. Your library seems to take a much more object oriented approach, which is much more limiting and does not scale nor extend nearly as well. I also find it to be somewhat jarring stylistically, but admittedly that's much more subjective. I know that I personally would find no value in integrating that into any codebase that I've worked on. That said, if it's working for you... good luck.
I definitely agree with that. For me language or a compiler is just a tool to enter instructions into computer more efficiently, not a religion or goal in itself. So yes, I woul definitely love an easier to use, faster to write and more performant language then C/C++. But as of now I am often forced to fall back to C/C++ for not just performance reasons, but even infrastructure, availability, knowledge base etc.
Aliasing is better then typedefs.
FWIW, you could also use a small class hierarchy instead of a variant.
 using namespace std;
The only times I use auto is when I don't feel like typing out std::vector&lt;something::something&gt;::iterator, std::function, or index-based for loops (that I also dislike and barely use). Otherwise I always just write the type name - it's easier to read this way, and works better with auto-completion.
 &gt;I also like that 'auto' lets me change the return type of QueryUserForFirstName() with a new type or fa√ßade that implements the same operations of the old type without having to update all the current callers. I think a better approach for this would be type aliasing.
I would say that people dislike it because they feel it hides types. Typedefs hide types, but devs have no problem typedef'ing a thing three times before I find out it's just an int. Some people also don't like change. Find a copy of "Effective Modern C++". Using auto correctly should never hide types, enforce initialization (not always desirable, I know), and avoid implicit conversions that can get you in trouble down the line. I like auto, but I don't use it everywhere. But there are also a decent amount of situations where it comes in handy. Love me some generic lambdas.
&gt; What are you suggesting be the default memory management instead Encapsulate it in something. For the most part, Standard Library classes can be used. So instead of this: Foo * data = new Foo(SIZE); // Don't forget to delete you probably want to do this: vector&lt;Foo&gt; data(SIZE); In other situations, you might want a `unique_ptr`.
Type aliasing is better with `using` `using Moment = std::chrono::time_point&lt;std::chrono::steady_clock&gt;`
std::decay is pretty useful for this.
You're completely ignore that you have to deal with the uncertainty that the code will produce a value on the codepaths. If `e.Title()` being compared to `e.Title()?` is hopelessly over simplistic, because the latter says an error or optional value may occur there, while in the former it may occur at any statement under any circumstance. Need to manage a resource? Need complex code that might need rollback logic? With "?" says the code may return an error or an optional value only there, so you can handle it there. With invisible code, your code can short-circuit anywhere, you're just not marking it.
Most of my use right now tends to be iterators for stuff like `find` where I'm only going to use it once, and if I want it to be a const_iterator I'll just make sure to compare it to `cend`.
`#define final /**/` i'm helping :D
You do CML however you want. Why you want to stop other people from doing what they want is beyond me. If someone creates a C++ scripting language that can do all that work, then people using this system won't have to do the work any more. It no longer becomes a problem.
&gt; A bad use of auto is when you don't care to type out the name of the type. I disagree, there are plenty of times when I care what the type is, but auto cleans up the code. auto my_data = std::make_shared&lt;DataClass&gt; ();
In my opinion, the ONLY acceptable use, is with templates. In all other cases you know the output type your function returns, therefore you should specify that type.
I've been bitten by it once. Some windows header defined a `byte` typedef (not just `BYTE`), which clashed with `std::byte` when we upgraded to C++17. Not `using namespace std;` but the same project wanted `using namespace OurCodebasesNamespace;` which caused a clash with `OurCodebasesNamespace::UUID` and windows's `::UUID`. Luckily for this one we could avoid including whichever header defined `::UUID` except in one platform interop file. Side note: why do you use the \` backtick for code but escape it so that it doesn't actually render as code?
In theory, yes it could. A compiler can do anything it wants as long as it doesn't change the meaning of your program, under the as-if rule. In practice, no. It would either be levels of understanding which are decades out at least or it would be the special-est of special cases (and wouldn't help at all if I were using a type other than exactly `std::vector`).
Now, you could write a macro that does this, but!!! You're: 1. Marking the second branch as unlikely. 2. Creating an exception from an exception table, likely fetched from a cold region of memory. 3. Unwinding any statements made in the try block. 4. Then executing the fallback branch. This is all assuming DWARF 4 exception handling as opposed to SJLJ exception handling on the Itanium C++ ABI, which is pretty much standard. Which means performance hits.
Stop people? What are you talking about? I'm just putting forward potential issues to consider.
SuperStringType lol
It scales very well actually. CQC, the automation system built on top of it, is very large and very complex. I'd never even have attempted that using the standard C++ stuff, ever. And I'm not one of those folks who somehow suddenly are claiming that OO is a bad thing. It's one of the most powerful tools available. So of course it's OO oriented.
Yes! The best part about most library updates to 14/17 (and hopefully 20) is that many devs maintain standalone versions that are drop in replacements for the stdlib. All I needed is a template&lt;typename T&gt; using optional = otherlib::optional&lt;T&gt;; (Some are even done by the very same stdlib maintainers, ‚Äòmpark‚Äô put several up on github) The important part is that once standardized you can depend on the syntax/semantics with confidence it won‚Äôt break in two years. In my case I don‚Äôt need to worry about ABI stability so i can use ifdefs / has_include to conditionally take the stdlib implementation where available.
Does the IDE work like Rust? In that `foo`'s tooltip tells you the concrete type? (I'm not sure if I'm using the phrase "concrete type" correctly)
BTW, it should be said that CIDLib isn't something you integrate into your code base. It's something you build a code base on. It's more like an OS than a library.
No. Both the very big object and dynamic allocation should be hidden behind abstraction.
Literally everything (but Java is worse) except for not to ignore warnings. I can't remember the last time I use a singleton, I only use static variables for debugging purposes, if I use global variables and it's a serious app they will be thread local [https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html](https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html), I avoid inheritance if I can (ex: I may inherit multiple interface like classes but any concrete class I will never inherit), etc etc But I also have strange programming practices because I write complex code (data heavy with lots of if statements) . So it might not be so bad for everyone else.
How so?
The "ONLY acceptable use", eh? You sound like that annoying pedantic extremist guy on the team. A real treat to sit through code reviews with.
Yep, I've gotten things like that before. Pretty simple though, right? The code never had `std::byte` before, so you the human know that's not the type intended. So, either you deal with the handful (hundreds? thousands?) of compiler errors, or you do a fairly simple find/replace to remove the ambiguity if it arises in the future. Same with your `UUID` example. I've certainly hit little things like that and resolved them before I ever considered it to be a problem worth avoiding `using namespace` over. &amp;#x200B; I'm not bothered with typing the extra `std::` everywhere, I just hate the visual noise it adds in the code. I think it's worth dealing with rare headaches like you mention to reduce the noise that explicitly qualifying namespaces introduces. I promise you every single time you see an unqualified `vector` or `string` in my code, it's from the `std::` namespace. &amp;#x200B; Side response: I was on a different computer than normal and was using the WYSIWYG comment editor, not the markdown editor, so the backticks didn't post as formatting.
Lots of people apparently think it makes code unclear. They find it hard to reason about whats happening. I personally in general don't care whats happening unless it matters whats happening but you will find at places like google and facebook lots of people do care and you won't be able to use it.
I mean LLVM literally declares a type called StringPiece and uses it everywhere so.....
...no. As with all dogmas, it depends. If I‚Äôm constructing some object for use and storing the data inside the object, in memory, is more efficient (and it generally is in terms of both performance and memory layout efficiency), then that‚Äôs how it should be written. Otherwise, why don‚Äôt I just make everything a reference and switch to C#, Java, or some setup with a handle based memory system? At least I‚Äôll be memory efficient there. And much faster to allocate. Or maybe you decide to abstract and have the object construct based on whether it‚Äôs on the stack or not? No, now you‚Äôre trying to be smart. Don‚Äôt do that. You‚Äôre going to do the wrong thing more often than not. Maybe I‚Äôve decided that I can fit this large object in stack memory because I allocated enough or maybe my platform can just keep expanding stack memory until it runs into heap address space, whatever. The entire point of using C++ and not Java or C# or whatever is that you have the flexibility to do what you need for the given situation. When you say ‚Äúeverything should be hidden by abstraction‚Äù, you‚Äôll inevitably write shitty code: maybe it‚Äôs slow, maybe it wastes memory, whatever, but you‚Äôre giving the C programmers more reason to hate you. Just use C# if you want to hide everything, it‚Äôs much better at it.
I've read a lot of unhelpful comments so now I don't ever write comments
As a senior programmer I think it's completely ridiculous to think this is bad practice. However I am mostly thinking about using std and core libraries, not every possible namespace.
Yes, if it's not a generic context.
This sounds completely stupid. Why are you not using Ada then? What draw backs are there to auto? My #1 fav place to use auto is in for loops
I have never mentioned "everything should be hidden by abstraction". Don't twist my words.
how does that differ from auto&amp; in practice?
You said both should be hidden by abstraction. What do you mean then? You said no to my statement about allocating the large object on the stack. I‚Äôm open to be corrected, but when you literally say nothing I have to read your mind.
Namespace collision is super easy though. We had 3 libraries providing vector as a type and a couple providing transform as an example in one of my workplaces.
**Company:** Microsoft, Visual C++ **Type:** Full time **Description:** Join the Visual C++ team with a focus on new platform development! Our mission on the Visual C++ team at Microsoft is to build the best tools and libraries for any C++ developer, any app, any platform. The Microsoft Visual C++ compiler team empowers a broad C++ ecosystem on multiple platforms impacting millions of developers and billions of users. We are looking for an experienced software engineer to help develop compilers and tools targeting new Azure hardware in addition to known hardware. You'll come on board as a core team member of this early-stages project, working alongside some of the best compiler engineers in the field. This is an opportunity to be involved in groundbreaking hardware innovations. Opportunities will be available to shape the direction of this project as you'll be directly involved in new platform bring up. You'll be interfacing with other internal teams such as operating systems, debugging, architecture, security, and cloud computing. Successful candidates should be comfortable in a fast-moving and dynamic environment. We are looking for a wide range of skill sets to fill out this team. This small team will own the full-stack of development tools for this new platform during development. If you‚Äôre a software engineer and interested in getting involved with compilers, debuggers, libraries, assemblers, and other tools, this is a rare opportunity! Apply using one of the following links. Please feel free to email me directly after doing so to highlight your application. * https://careers.microsoft.com/us/en/job/569834/Software-Engineer-II * https://careers.microsoft.com/us/en/job/570239/Senior-Software-Engineer *Responsibilities:* * Contributing to the design and implementation of compiler back-end and tools for new and existing hardware platforms on both Windows and Linux * Participating in new platform bring-up * Helping to debug issues spanning the full HW/SW stack * Supporting the core C++ compiler team * Delivering product milestones *Qualifications:* * BS in Computer Science, EE, Computer Engineering or equivalent experience * 3+ years programming in C, C++, or other systems programming languages * Comfortable working with assembly - familiarity with one of the following is preferred: x86, x86-64, ARMv8 * Comfortable with algorithms and data structures * Excellent teamwork and communication skills * An instinctive appreciation of celebrating team success! *Prefer some combination of the following:* * Entry level compiler or language design course work. * Familiarity with compiler back-end technology (e.g. LLVM or GCC experience) * Knowledge of multiple processors and ISAs * Knowledge of modern CPU architecture fundamentals * Knowledge of operating systems fundamentals (Linux and/or Windows) * Knowledge of debugger internals * Knowledge of C and C++ runtime and libraries * Strong skills with debugging, profiling, and/or code analysis **Location:** Redmond, WA **Remote:** No **Visa Sponsorship:** No **Technologies:** C, C++, assembly, LLVM, GCC, Linux, Windows, GDB, WinDBG, LLDB **Contact:** Email IANB at microsoft.com (Principal Software Engineering Manager, Visual C++ Code Generation and Optimization)
Because Ada isn't remotely useful for most commercial development, among other reasons. At the level I work at, on large scale frameworks, explicitness is far more important than convenience.
Nice catch, but only feefee/f00f00 were special to the debugger :-)
Cool story bro. it doesn't make sense otherwise.
I'm pretty sure there is a runtime check in this case and any time something is conditionally moved. It's called dynamic drops (see e.g. this merged [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0320-nonzeroing-dynamic-drop.md)). After all, all values are dropped exactly once (unless you `forget` them or otherwise leak them). So at the end of the function: fn conditionally_moves_foo() { let mut foo = Bar::new(); if (condition) { drop(foo); } // foo might need to be dropped here. } There has to be a check. In rust, this implemented as a flag that the function keeps track of, but it's morally equivalent to an `std::optional`. And it is absolutely not equivalent to `mem::forget(foo)` which doesn't run the destructor! P.S. Of course you're correct that `mem::drop` accepts a value. :)
Me? Oh no, I don't have a point other than I just wanted to let you know that you tend to come across as one of those "my way or the highway" type of guys, who are a real joy to work with.
not if you end up with 4+ nested 'if' statements when you could just flatten the code with if() return
declare it a friend function?
I find that people who still use malloc in their C++ hate auto. People who are academics hate auto. People who are coding like it is 2019 love auto.
"Everything" and "both" are distinct words with distinct meanings. Just don't try to read people's minds. You can't do that over the Internet. Don't accuse people to be trying to be smart basing on only one or two sentences. There just isn't enough ground to do that. Nor saying a simple statement is a dogma. It is impossible to expect every comment to be accurately worded to represent the full picture of the commenter's belief. Admittedly, I might have used "no" and "should" incorrectly because the comment was meant to be a vague supplement to yours rather than a strong opposition. What I tried to express was: When you are designing a class, and you know its data size is too large to be on stack, the usual design choice should be to hide the complications behind abstraction, such that the object can simply be instantiated as an automatic variable, spearing your users (such as yourself a few seconds into future) from trouble. That being said, there is no concise and uncontroversial definition of "usual", and there is no mention of how or whether to support advanced use cases, and there is no mention of what if you can't do this and that.
This is "that" guy who not only wrote the organization's coding standard, but spends a huge amount of time checking code out, formatting it exactly his way, and then checking it back in. One space after a function, two spaces after a switch, three spaces after a template declaration, no spaces after a for loop, semicolons need a space before them and you don't want to know about his comments "RULES!!!!!" Then he defends the standard by saying that somehow not all coding just like him will result in bugs and chaos. What he doesn't realize is that any halfway decent programmer who spent a week or more at the organization realized that his BS wasn't worth it and immediately started looking for a new job. Thus his crap opinion has cost the organization massively and the halfwits who remain are fonts of endless bugs. Note, I use organization as I doubt his opinion is from a corporation, but a government, or academic type group.
That's odd.. If you ask the people who still use malloc what group is "pushing" auto, I'd wager they tell you it's the academics.
&gt; It kind of defeats the purpose of using a strongly typed language doesn't it? No it doesn't. Strong typing still completely works. You just don't have to care what the types are in what you type. You will still get the same errors when the types are incorrect.
If ADL issues don't concern you, and compilation failures don't concern you, then I can't change your view and we'll just have to disagree. Side response response: ah, I forgot that the WYSIWYG editor exists since I stay in old reddit. That explains it!
auto eliminate accidental type conversions on assignment, which for me at least, avoids a lot of bugs and performance issues. Functions are typically returning exactly the type you should use already. If you want it to convert then seeing a non-auto indicates that. It also makes refactoring a ton easier and less error prone.
&gt;Code reviews live or die based on compliance with his commenting standard. At this, I experienced something like (I imagine) a mild PTSD flashback ;) You put into words what I was not able to express previously. Thank you, sir.
Not caring to type out the name of the type is a gateway drug for not caring what the type is :)
I'm not suddenly claiming that. I've been avoiding OOP anywhere that a "substitutes for" relationship is strongly required for a long time, and even there I have strongly preferred static polymorphism for ages.
I don't know about other text editor, but in VSCode you can easily peek the type as well on mouse hover after installling C/C++ extensions.
again: hard drives are slow Mallocing is simply finding a free page in memory, paging, memory mapping sounds like much but isnt ;) depending on how you implement your memory model you might even get O(1) free ee page finding And memory mapping is free
\*i might return T, not T&amp; for some use cases.
Aah, ofcourse
Why a macro? Why not a metafunction?
While that will work, I hope you aren't seriously advocating using that style (at least outside of templates).
&gt; ‚Ä¢ "all member variables shall be encapsulated behind getters and setters" Coming from predominantly C, what should be done instead? No access?
a function does not accept a type as one of its parameters, it could be formulated as `isinstance&lt;type&gt;(obj)` if we were to use a function, but the syntax is not as pretty.
I wonder how would that work. Since you are making it into a compile time thing. So if obj is a reference to a base class in type, but really refers to a derived object, won‚Äôt that be lost?
Looks very pretty to me.
This sounds like auto with extra steps.
I would argue that you should use auto&amp; unless you're expecting it to return T, then use just auto. Returning T over ranged iteration is pretty rare, so if you're not expecting it and use auto&amp; the compiler will catch that for you and you can decide if that's what you actually want.
that requires `dynamic_cast` and in this case, overloading does not work either.. I would say, **if possible**, one should prefer concepts and templates (static polymorphism) over inheritance and virtual functions (dynamic polymorphism) in cpp 2a.
Why?
if a certain functionality could be implemented by either static or dynamic polymorphism, the static version in cpp generally looks cleaner and less bloated as it is non-intrusive, you do not manually declare interfaces and implement (inherit) them, an inheritance tree is not necessary for all your types, it works the same way as duck typing at compile time, which means it is far more flexible and has much higher type accuracy than type erasure. It also (theoretically) has no runtime overhead unlike virtual functions.
But it has serious build time overhead and increased coupling. This is the 2000s all over again.
y tho?
Aliases provide all the functionality of typedefs while playing nice with templates.
For me, when I want to accept command line input from a user, I want security not speed. Creating your own data types like Hash\_Maps, using char\* arrays directly, self defined memory management, direct array access, etc., is big red flag to me and is basically a ticking time bomb. With the amount of C code and potential to shoot yourself in the foot, I think this would be a fun thing to run under asan, valgrind, static\_analysis, etc.
Templated aliasing, for example. https://en.cppreference.com/w/cpp/language/type_alias
I wish rust designers understood that
in some if not rare cases, say you have multiple overloadable functions that are 99% the same, each with one or two different lines for a specific type, you could merge them all into a single function (template) and save a lot of copy-paste.
Could you show us an example of the code?
To replace pattern matching with instanceof chains is going backwards.
Great question. My opinion is as follows. I have banned the use of auto in my department for two prime reasons: 1) Learning from history. I have been in the industry for more than 20 years now. Saw the rise and fall of Java when I started out in this language. In the beginning it did, like many other new languages struggle from certain caveats and lack of established ecosystem and best practice. Then more and more people started saying things like: "Just use framework JSuchandSuch and you wont have to worry about $AREA_OF_CONCERN never again. And people started using JSuchandSuch, along with JSomethingElse and JWhatever for more areas of concern. Few years in, everbody used JSuchandSuch, JSomethingElse and JWhatever in every single project because they have long since forgotten what $AREA_OF_CONCERN actually is all about and what problems those frameworks solve or indeed what they do at all. Or indeed, many have never actually learned it in the first place because they started out in a world dominated by those frameworks. In my opinion this was one major reason for Java becoming the bloaty monster it became and its developers are what they often are. I see auto as a piece in the same puzzle for C++. Sure, now people use it to not have to spell out iterator_such_and_such but a few years in they will have forgotten what an iterator actually is or never learned it in the first place because everything is auto anyway. 2) It pushes the effort of reading and understanding code to the reader. This one is pretty common. When I read, change or review code I need to know exactly what's going on, when, what types and classes are involved. When the writer uses auto a lot, this means I have to painstakingly figure all this out for myself, whereas it would have just been a few more letters to type for the original writer. This is inconsiderate to peers and lowers the likely effect of reviews and change effectiveness. Those two and many other reasons. Auto is the only language feature completely banned here.
As I'm basically throwing consistency out of the window there isn't such thing as a 'typical' example, but FWIW something along the lines of (and you have to see this across 80 columns to appreciate it), `constexpr auto create_slider_service` `= [] (Episode_Runner::Slider_Control Episode_Runner::*ctl)` `{` `return [ctl] (const MS::Query_String&amp; Q,` `const int socket)` `{` `if (station_runner.episode_runner)` `(station_runner.episode_runner.get()-&gt;*ctl).target` `= Q.get ("target", 0) / 100.0;` `MS::Http_Server::return_html (socket, {});` `};` `};`
The build time is relative to the complexity of the interface, and the coupling is _decreased_ by any sane definition of 'coupling'.
Fully agree, except: &gt; If the type is obvious from the right-hand side This puts the burden of proof to you or the reviewer. When, in a review, you have to judge if this usage of auto is OK, OP can always say: It's obvious. You then have to argue why it isn't. Too much hassle for a few saved letters.
Use 4 spaces in front of each line for preformatted text. See [the helpful HFY Reddit formatting guide](https://www.reddit.com/r/HFY/wiki/ref/faq/formatting_guide).
&gt;What particularly burns me is library writers who use inheritance for callbacks, Here's looking at you MFC ....
Regarding your second point: What's your stance on type-aliases?
The sheer amount of time that could be saved by just adopting a simple linter...
Or refactor the 99% in to smaller functions
Type aliases are OK and encouraged when appropriate. To be honest, I don't see that strong connection why they are often mentioned in discussions pro or con auto. After all, it's not like every alias is 'auto'. Still, looking at my second point I would agree that overusing aliasas can have a similar effect on readers.
This . IMO, people who are against auto are luddites. It's type inference and I have yet to find a Haskell or Ocaml or F# programmer complaining about it.
what's the use of this?
[Havent seen Herb Sutters post proffered yet](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/) IMO, I find that `auto` works best with a particular set of programming paradigms that may or may not fit into the development structure that someone might be a part of. I use them when I'm implementing an algorithm where the types are less important and the decoupling between implementation and signature more useful. Also where the types are relatively obvious which is usually the case (for me anyway) as you can't use `auto` without some sort of initialization be it creating a new instance or using a function call.
which significantly increases runtime overhead with no benefits...
Our standards will usually be a bit more specific, e.g. is the type literally mentioned on the right side? This never really occurs for us regardless - most engineers are pretty good about taking on feedback. If someone other than the writer thinks it isn't obvious, generally the writer is open to changing it. It never really becomes an argument :)
[Here](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/) is an interesting read about auto written by Herb Sutter. The main reasons I like to use auto: 1) Usually I do not care about the type, and if I want to know I can always look it up with my IDE. 2) The compiler knows anyway, and almost always better than me. It helps to avoid implicit cast errors. 3) The most important for me: auto is ALWAYS initialized. I even like to use things like `auto id = int{0}`, because when someone will be changing my code in 5 years she cannot forget to initialize it even if playing around and trying things out.
Right now, it is memory safe, using snprintf to make sure there are no buffer overruns or loops that stay within the bounds. The only way you could make it memory unsafe is if you passed in an array without I'm thinking about switching over to std::string/std::unordered_map for developer's peace of mind, a smaller code base, and to make absolutely sure that I'm not making any memory errors. A lot of this library is me trying to go too much for speed and small binaries, but both could take a hit right now. When I ran it under callgrind/kcachegrind, most of the time was taken by just system stuff setting up the program. The largest function that was actually part of my code was strcmp at 3%. I don't understand what you mean by self defined memory management, as nothing is allocated on the heap, except for vectors of stuff (usually non-ownership pointers to Values) which I just clear using vector.clear() so subcommand data doesn't interfere with supercommand data. Thank you for yout reply. I'll make some improvements.
[https://www.boost.org/doc/libs/1\_70\_0/doc/html/boost\_asio/net\_ts.html](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/net_ts.html) I guess this link is what you need.
That's not a language issue but rather a bad API design. I would also like optional to have a monad interface.
[Libclang allows this kind of query fairly easily.](https://github.com/Valloric/ycmd/blob/master/cpp/ycm/ClangCompleter/TranslationUnit.cpp#L308-L386) Clangd on the other hand, isn't so smart at the moment.
Let me argue for the sake of argument: Are you sure your indentation is inconsistent? Perhaps your indentation actually has a consistent internal logic albeit unconventional? OK, seriously. No matter how you indent, make sure you don't obstruct your tools and human cognitive processes.
I've never seen someone actually write out the type for a std::function. They are insane, and having auto enables that level of insanity to exist.
use the lambda trick: auto x = [&amp;]{ try { return f(); } catch (...) { return -1; } };
You meant "return p1 == p2;", right? I think your example is more clear when rewritten as ColoredPoint a = ... initialized with Point p and "red" ColoredPoint b = ... initialized with Point p and "blue" Point&amp; p1 = a; Point&amp; p2 = b; return p1 == p2; Versus ColoredPoint&amp; cp1 = a; ColoredPoint&amp; cp2 = b; return cp1 == cp2; Of course these are different comparisons, they're comparing different types, so they can return different results in general. In this example the first should be true, the second should be false. This is not unintuitive, it's completely straightforward. The == operators don't need to be member functions, nor should they be.
I think they're mostly brought up as a way of addressing one of the problems that `auto` addresses in decoupling the implementation from the signature. IMO type aliases fail at this though because type aliases usually aren't as generic in the same sense and it doesn't actually address the problem, it just moves the definition of the type somewhere else (sometimes God knows where) so that actually updating the signature becomes an easter egg hunt. IMO I disagree with straight banning of language features in general for the simple fact that it strikes me as having a tool and actively deciding to use it under no circumstances whatsoever, but I can certainly see the arguments _for_ it. I find your first point interesting though I'm not sure I totally agree (assuming I'm understanding it correctly, so forgive me if I've misunderstood). C++ is rife with mechanics that you almost have to stumble upon before you even know that they're a thing (like move semantics and the _real_ depth of template metaprogramming). Also just because the types aren't explicitly labeled doesn't mean that you don't still have to be type _aware_. If you've got programmers that are just banging out code and tweaking it to satisfy the almighty compiler without really _understanding_ why their code isn't working (I've worked with several devs that follow that "iterative blackbox" paradigm) then I think they've got some learnin' to do. The information for where the type is being derived from (creating a new instance, function call) is available and if I'm reading code then I'm probably gonna be diving into those momentarily anyway. Personally I think it declutters a lot of code especially in the case of iterators where the chains of types and templates don't really help you in understanding what the code at hand is actually doing. But that's mostly formulated from my own anecdotal observation. I think there are certain programming patterns/paradigms that don't work as well with `auto` which could be a result of various things including culture, confidence, an existing code base, etc. It could also be that while I mostly started with C++, I've worked a lot with duck-typed languages so operating in a more type-abstract space is familiar to me. Ironically I just had a conversation with some colleagues today about the use of `var` in C# which encompases a lot of the same talking points I've found in the post comments.
Type aliases increase readability if used correctly. The most classic case is typedef'ing native types to u8, u16, u32 etc to avoid the ambiguity of an architecture. Other obvious examples are things like handle_t (likely a void* or int that should never be used as either).
Which is a gateway drug to unreadable gibberish like most "modern" C++.
&gt; C++ is rife with mechanics that you almost have to stumble upon before you even know that they're a thing (like move semantics and the real depth of template metaprogramming). That is absoluetely true and I will generally not judge someone's code for being simple and not using the 'fancy stuff'. Myself, I try to restrict my use of those language features to those times when I can absoluetly justify it. First and foremost because I am a learner at C++ and I know for sure there's tons of such methods I have no idea about. Second because I value development efficiency in my teams over fancyness. Meaning that if one person writes code that others will have to spend extra time understanding, changing or reviewing, I will tend to blame the original writer unless the case is clear that the technique in use should be able to be understood by a majority of coders. Unless of course there's good justification for it.
Impossible to read code or find where a type is used.
I find it more readable, YMMV.
Agreed, and it drives me nuts because template metaprogramming is so cool! But because it can be _rediculously_ difficult to reason about I don't think it really has a strong place in most production level code without at least some adjustments to the syntax alone. Of course libraries will depend on a lot of those things so it _does_ have a place, but it's worth scrutinizing if/when it comes up.
Agreed. The reason I brought it up was _mostly_ because of his point on `auto` causing more pain in trying to identify the concrete type, which is totally a problem space that type aliases _easily_ fall into. They can also have the side effect of embedding that concrete type in some pretty far flung areas of a code base especially if they get chained together. That being said, after a bad run in with a custom instance ID system that directly used `int32` for it's type _everywhere_, I would have loved nothing more than for that to be a type alias so that it wouldn't be so risky when we went in and changed it to actually support UUIDs &gt;.&gt; and I'm a fan of type aliases in general because they contextualize the types they alias as you've pointed out.
Yep. It hides very important information abut what it is. When You read code that wrote someone else or after long period, understanding it requires more time that when types are explicitly used. Also code auditing in such tools like gerrit when You see only auto is impossible without further investigation in cherry picked code. I don't use it as code readability is very low and can introduce errors when someone makes wrong assumpions about what a given auto is in reality.
A lambda isn't an std::function. It's either it's own anonymous type or if stateless a regular function pointer. std::function is basically just an any for callable types.
They rather helpfully provide no coding examples, which would be ok if the networking TS was a simple text substitution replacement.
Nope, when you use alias to type for ex in class You give clear information to code reading person what You are using. When You use only auto You hide all information, code auditing is like a horror story as person Who does it have to investigate more code to be sure what You are exatly doing with what.
This is what the same code looks like with the default clang-format settings constexpr auto create_slider_service = [](Episode_Runner::Slider_Control Episode_Runner::*ctl) { return [ctl](const MS::Query_String &amp;Q, const int socket) { if (station_runner.episode_runner) (station_runner.episode_runner.get()-&gt;*ctl).target = Q.get("target", 0) / 100.0; MS::Http_Server::return_html(socket, {}); }; }; Not sure I see your code as substantially better.
Clang format does pretty good job in 99.99% of the cases, with some options like: \`\`\` AccessModifierOffset: '-4' ColumnLimit: '80' IndentWidth: '4' TabWidth: '4' UseTab: Never \`\`\`
One possible rule is that the type is obvious if the right hand side is a literal, or explicitly mentions the type (eg. in a static cast), or is a call to make_unique / make_shared.
Then you still have to declare them in the header file within the body of the class which I thought was what [dzosz2](https://www.reddit.com/user/dzosz2) tried to avoid.
Yeah, I also don't understand the level of dislike for auto here. We don't by any means use it everywhere but it's very rarely ever caused an issue for me in terms of readability. If it is, then it's usually a sign that something else in the code is named badly. Auto is always one click away (or a mouse hover depending on the IDE), whereas typedefs can be 5 levels deep.
Have you looked at cbor? I kinda love cbor :) http://cbor.io/ https://github.com/RantyDave/cppbor
Explicit should be the default. In an ideal world there would be an "implicit" keyword that enables coercion.
Thank you all for your answers. Does using the "decltype(\[\](){})" in the function signature causes any issues with the name mangling?
Wrong. Tools are able to find where a type is used even "hidden" behind an auto.
Thanks ! The document looks helpful as a reference documentation when updating legacy code. Didn't noticed the document is already available at the official site. Thanks again :)
&gt; Too much hassle for a few saved letters. The letters saved isn't the main issue - refactoring is. The type of the variable isn't actually important, it's what you can do with it that is.
I think the opposite is also true. Some people recommend new ways of doing things before the downsides are well understood, and sometimes the downsides (e.g. verbosity, overhead) are simply ignored and instead the focus is on a few advantages (e.g. hard to use incorrectly, thread safe) that the person thinks are important missing the bigger picture.
I think you completely misunderstood what the post you answered on was saying.
actually a function template simply fails sometimes cuz it is not guaranteed to be constexpr, while the macro is. the function version would probably be like `template&lt;typename T&gt;` `constexpr auto isinstance(auto &amp;&amp;obj) {` `return std::is_same_v&lt;std::decay_t&lt;decltype(obj)&gt;, T&gt;;` `}` the following example gives you an "expression did not evaluate to a constant" error `auto a = 1;` `auto &amp;b = a;` `constexpr auto x = isinstance&lt;int&gt;(b);` while the macro version works perfectly fine here
Type aliasing makes sense, if the same type is used at different points in the interface. Otherwise I don't see any advantage compared to auto.
you could move those function declarations to separate .h, then create macro with function declarations, then add single line of macro to your main class (not that I would ever spawn such monstrosity myself)
Chances of that are however much smaller than not knowing the intricacies of the reasons for the Rule of Zero.
\`\`Helps with consistency.'' So what? My question is what good does consistency actually do?
I can only say that I don't agree with you. That's fine.
It's not about saving typing it is about making reading easier by having less visual distractions in the code. The return type of `std::make_unique` is obvious, so repeating the type doesn't benefit anyone.
Ideally this kind of information *is* encoded in an object's type. That's what a good type system excels at, and it provably cuts down on bugs. Of course in reality types often fail to encode such information, because programmers are lazily reusing existing types instead of providing their own. However, this is definitely an anti-pattern in big systems (it even has a name: ‚Äúprimitive obsession‚Äù).
Which is also what happens on a struct. There is simply zero difference between class and struct, except that classes are private by default and structs are public /u/ijmacd
I don't know why that would be bad practice in source files.
Why do we need all this? isn't sending structs over the wire more than enough? I've worked on embedded devices too, all we needed is to define some structs (that share the memory layout for all participants) and send them over the wire.
'Consistent' means being the same for the same case. Indentation shall be consistent then, because if the same cases have different indentation each time, it would be hard to read the code.
&gt; Runtime endianness check. A compile time endianness check is nearly always just as wrong. I don't usually like what Rob Pike has to say, but on this [he's right](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html).
The older C++ code is a lot clearer.
Restricting it to source files doesn't solve the problem it introduces, only makes it less bad than putting it in headers and forcing everyone who includes them to use it.
&gt; It's some sort of Javascript disease that has infected C++ It really isn't, It's type inference, predates Javascript, and nobody seems to complain about it in OCaml, Haskell, Rust, D, F#, Go, ...
Often people think an array is the same as a pointer, so there's that.
My biggest beef with auto is type obfuscation, it can hide the worst sins in a very innocuous looking line of code. example: auto names = GetNames(); How bad this line is depends entirely on the type of the return value. So something like std:: vector&lt;std::string&gt; GetName(); Is significantly worse than std:: vector&lt;std::string&gt;&amp; GetName(); The usage of 'names' in any of the code that follows would give you no clue about this either. Not to say that you couldn't figure it out if you really put your mind to it, but something like that so easily slips into large codebases and is so easy to miss in a code review that I personally avoid auto wherever I can. Note : not to say that I don't have other issues with it , but this is a particularly insidious problem.
The problems are real, but C++ won't go away anytime soon due to economic reasons.
In my opinion consistency is important when you work in team with 2 or more developers. Every one of them could have it's own opinion what should be the indentation, where should be the braces, etc. And I think a person could get annoyed if he/she needs to go through the project files and each one of them is written with different indentations, etc. because it's been written by a different developer. That's why teams usually agree on some kind of style guides and then either enforce them through code review or with tools like clang-format (at least this is my observation). People claim that the single style formatting used/enforced by the Go language (go fmt tool) really help readability of the Go code. In addition, I think that consistency may facilitate searching through the code. For example, if you always use \`const Obj&amp;\` you may search and find all matches easier, but what if some developers prefer write in this way but others write it like \`Obj const&amp;\`.
I have more than once found myself wondering whether a function is calling a std:: function or if it's something the author has created himself when looking at a code snippet posted by a beginner asking for help. For me std:: makes the code more readable. It's a bit more cumbersome to write (I often release the shift key too early ending up with std:.) but it's totally worth it.
1. I simply don't see that. 2. If that didn't exist, there would be no way to expose a C++ class to python. Bye-bye Boost.Python and Pybind11. 3. There's no other way to catch exceptions from constructor member initializer list.
Its not the assign operator, its a copy ctor
Nice example. As a matter of fact I also have a rule to exclusively use those cstdint types such as [std|boost]::uint64_t over builtin types such as long integer or short. I have very few exceptions, mostly when it comes to interacting with libs that use and demand those types (such as Qt). It may be argued though whether or not the cstdint types are actually aliases or language features, since they are within a std header.
Yes. I feel the same way. Would love to be able to use templates more but I have to consider the tradeoff between what I would choose and what my peers, who often have to understand and change it, will easily understand. Otherwise I risk sacrificing overall development team efficiency for some black magic showoff effect. Yet then again, this is not too strong an argument, since when you only ever use the same techniques, no-one will evolve and learn new ones. So you constantly have to introduces new ways and challenges. Which I often use templates for.
This only works if you have a very homogenous setup (same architecture, compiler, etc). If you have different types of processors in your system, or you need to interop with someone else, this falls apart. It's also hard to extend safely, and doesn't deal with variable-length data.
The most annoying thing about rust was all the "impl mut str rc cr". stuff. Just use words, no ones gonna complain about lines being 3 letters longer id it means its atleast readable
T&amp; should still work in that case due to lifetime extension: [https://ideone.com/IENGoK](https://ideone.com/IENGoK)
 // Returns if this is expired. bool is_expired() const { return this-&gt;expired; } I audibly groan when I find comments like this.
If you're manipulating both kinds of strings or angles in one function (which should be rare if you fix a standard format for the codebase), then it helps to have that in the variable name anyway if they aren't different (incompatible) types to begin with. Or just have extra functionality on the types that allows correctly combining them without having to care.
Well, I checked and you are definitely correct. I guess I still feel like its easier to skim by something like this auto names = GetNames(); in a massive block of code and not think about it. However, when you see this : std::vector&lt;std::string&gt; names = GetNames(); The problem is much more obvious. It makes the fact of the vector copy quite bare for everyone to see and fix.
\`const T&amp;\` would still work in that case due to lifetime extension: [https://ideone.com/IENGoK](https://ideone.com/IENGoK) (you should always put const anyway if you aren't intending to modify the value returned by the iteration)
Isn't the problem that the compiler can't infer the return type of the lambda from this expression? In all cases, isn't it more informative to use `std::function&lt;void ()&gt;`?
it doesnt work with proxy objevts/ expression templates etc. most libraries arent written with audio in mind, even tbe stdlub with garbage like vector book
Have you tried flatbuffers?
"Provably?" Has someone actually proven this?
If you don't know the type then how do you know its interface?
Yes, you are right! I did not even think about using `const auto&amp;`, but that should be the best solution.
as a footgun
Of course using std::function&lt;void()&gt; is definitely more informative. However, using the decltype(\[\](){}) make sense in some cases and that's the reason it was made possible in C++20 standard.
Yes, see e.g. [Zheng, Bird &amp; Barr, ‚ÄúTo Type or Not to Type: Quantifying Detectable Bugs in JavaScript.‚Äù (2017)](https://paperpile.com/app/p/3070170e-933e-0956-82ec-879fb924e452). Unfortunately they fall short of providing their own custom types but they show beyond any reasonable doubt that providing value constraints in the form of types leads to *substantially* fewer bugs. I like this paper because it‚Äôs controlled, conservative, and yet shows a huge effect size. We can extrapolate from this that using more constrained types would increase the effect even further.
The compiler is able to generate a mangled name. But the linker might not be able to merge multiple definitions of the "same" entity (e.g. multiple instances of the same inline function definition in a header) based on the mangled name.
You have a good point. A bit of contexts: When I put forward this point, I'm thinking of: 1. This high-vote bad answer on Stack Overflow: https://stackoverflow.com/a/1001373 2. Bad code of the same idea, such as this: https://github.com/scipr-lab/libff/blob/f2067162520f91438b44e71a2cab2362f1c3cab4/libff/common/utils.cpp#L93 3. The Howard Hinnant's nice, elegant, now-adapted proposal: wg21.link/p0463 So, my opinion is: OK, you need endianness check. I don't know why, but I would suspend my disbelief. Can you at least stop dirty hacking?
&gt; A bad use of auto is when you don't care to type out the name of the type. Disagree. It might be good or bad. Remember, you're not just saving typing - you're saving a lot of people from having to read it.
&gt; This only works if you have a very homogenous setup (same architecture, compiler, etc) Only same endianess. But you are right about extension and variable-length data.
The use of multiple adjacent inter-word whitespace looks a bit weird, but the indentation of this snippet doesn't look too bad.
To add to the other good answers, type aliasing with `using` is also more readable, as it looks like other variable assignments where the thing being assigned is on the left... auto a = 1; using b = MyTemplate&lt;MyData&gt;; # but... typedef MyTemplate&lt;MyData&gt; b;
In addition to bad readibility others have mentioned, it doesn't comply with "fail fast" philosophy. Let's say you have this line auto foo = bar(); And bar returns int. And 10 lines below there is float baz = (float) foo; Somewhere down the line, you change bar to return char*, it is casted to float and the gibberish address values of the char* are used as if it's the return value of bar. If it was declared as an int, this scenario wouldn't happen. And before someone says this is unlikely, the exact scenario happened to me a month ago. To be dramatic, I will say, there's no reason to use auto except a few select scenario where you __need__ the pseudo polymorphism it brings.
In my opinion, these are the reasonable options for member variables: User needs|Access mechanism :--|:-- nothing | `private` read access | `private` + getter read/write access; all values are valid | `public` read/write access; not all values are valid | `private` + getter + non-trivial setter
Especially when dealing with embedded communication, there are many additional considerations - connections may not be as stable as you'd like and/or susceptible to interference, so features such as error detection/correction/recovery become very useful. In simple situations defining structs on both ends may be sufficient, but in my experience this is an approach that is very error-prone when the application reaches a certain complexity.
Best type of comments XD
&gt; IMO, people who are against auto are luddites. AAA - "automatically against `auto`" - is wrong. But sometimes, not so often, you need to explicitly use the type - for example, this loop will never finish because `i` ends up getting an unsigned type. for (auto i = x.size() - 1; i &gt;= 0; --i) I have to say, though, that I get more and more fond of `auto`. When I first saw things like `auto b = True;` I was like, what? But that wouldn't jump out at me anymore if I saw it now, though I'm still not ready to write that over `bool b = True;`.
@cpp\_learner: It make sense. so what you meant was that if we have a header **test.hxx** `#ifndef TEST_HXX_` `#define TEST_HXX_` `inline void bar(decltype([](){})) {}` `#endif` &amp;#x200B; If this header file was used in multiple source files, each file will have it's own definition of the function (even though its the same function but the mangled name will be different for every definition) and linker can't merge them into one. &amp;#x200B; Is my understanding correct?
&gt; Auto is never a reference Auto is never _automatically_ a reference - you can of course have: for (auto&amp; i : container)
Sending structs over is called "serialization". It might work for some cases and might not for others. The [article](https://www.codeproject.com/Articles/1278887/Implementing-Binary-Communication-Protocols-in-Cpl) that I mentioned in the post contains several examples and explains why serialization is not good enough. I encourage you to read it. Some time ago I also wrote a bit shorter version called [Communication is More Than Serialization](https://arobenko.github.io/cc/articles/2019/01/05/communication-more-than-serialization/)
&gt; It makes the fact of the vector copy quite bare for everyone to see and fix. Why is the first one any less bare? It pops out to me as "possible copy here!" auto names = GetNames(); // A copy might happen. auto&amp; names = GetNames(); // No copy happens. This is no more or less clear if I replace `auto` with an actual type `T`.
Every time I mention my work on any social resource there is always someone posting a comment "Have you tried X?". It looks like you haven't read the post (and referenced article). One of the core features in my solution is to be able to easily implement **already defined** third party protocols with their custom data layouts and encodings. Most of the available **serialization** solutions use their own encodings.
Please see my comment about "flatbuffers".
Well its auto so you know that whatever the functions return is the exact type you have without coercion so any calls to methods of that object, calls that use the object, etc in the code say you're refactoring define its interface. Parts of the interface you don't use are irrelevant to me. I trend toward the verbose side in method names and comments. I also use lamdas fairly liberally. It makes it easier to say go from with this specific object I do this specific thing to here is an object which has these set of methods do the thing I have asked you to do with it. I think with auto the barrier to seeing those kind of connections is lower. I think what I want that may be more feasible with contracts is to write code where if I need specific behavior I modify the input object and the code that deals directly with its internal representation or data model and none of the algorithmic code associated with it.
I would add "anyone who writes a program *on a regular basis*". Doing things once does not define you, but doing it regularly can. Someone playing the guitar on their freetime can call themselves a guitarist even if they never played on stage.
In general a many before said, `auto` is a great feature yet it has to be explicit, so programmer is always sure that right type is used. In case of shadowing the type, in most cases one does not need to know what is behind, especially in small code snippets like range based for, generic lambda (parameters), lambdas in general, or `stl` methods like `make_shared` or `make_unique`. Also `auto` is a extremely handy for `templated` code, as return type for instance -&gt; `template&lt;class T&gt; auto foo(...){ ... };` In most cases I can see that C++ devs are trying to avoid abstractions, quite often it's irrelevant what type is below, type or construction just need to be compliant with logical concept, and businesses logic. And here **Concepts TS (C++20)** come in handy, from what I recall concepts for variables is excluded from C++ 20 Draft, yet it will come somewhere in the future. In short concepts can be used instead of auto, as it brings bigger narrowing. How it could look -&gt; &amp;#x200B; template&lt;class C&gt; concept Container = requires(C con, Value_type_of&lt;C&gt; a, Value_type_of&lt;C&gt; b) { { con.size() } -&gt; size_t; { std::begin(con) } -&gt; Iterator_of&lt;C&gt;; { std::end(con) } -&gt; Iterator_of&lt;C&gt;; std::EqualityComparable&lt;Value_type_of&lt;C&gt;&gt;; std::Destructible&lt;Value_type_of&lt;C&gt;&gt;; std::CopyConstructible&lt;Value_type_of&lt;C&gt;&gt;; std::DefaultConstructible&lt;C&gt;; std::CopyConstructible&lt;C&gt;; std::EqualityComparable&lt;C&gt;; std::Swappable&lt;C&gt;; }; ... Container c = foo(); Even though `foo` tells you nothing about its return type, then still you know that type returned has to meet container requirements.
Yeah, it indeed should performs some kind (it wasn't dropped), but I don't see anything wrong with it. It has nothing with borrowchecker, you literally do the same with C++. In other terms, borrowchecker is completely compile-time feature unless you ouse Ref/RefCell.
Well, good luck in self education. I know a guy who writes C++/Haskell code and it pretty happy having the latter one. Sometimes it even could outperform C++ code. Of course you need treat GC specifically to avoid it when possible, but you have all this fancy stuff Haskell offer for free. It works in specific cases, not all, but where it works it works :) All sort of parsers/data transformations/etc are ideal, for instance.
I would compare auto names = GetNames(); To std::vector&lt;std::string&gt; names = GetNames(); A stark difference and in a large code review or a file written by someone else, the second line pops way more. It's harder to skim over it even if you are just scrolling through giant source files.
I get the impression (reinforced by the answers here) that people who dislike `auto` fundamentally misunderstand the arguments in its favour. The core objection seems to be that reading code is much more important than writing code, and that we shouldn‚Äôt accept decreased readability just to save a few keystrokes. But **virtually all proponents of AAA agree with this.** The whole point of AAA (= almost always `auto`), or, since C++17, ‚ÄúAA‚Äù (= always `auto`) is *increased readability*. Fewer keystrokes is, at best, a nice bonus (but often it‚Äôs not considered at all). So (why) does AA increase readability? Opponents claim that not having explicit type information in code at the site of declaration decrease readability. But this isn‚Äôt obviously true, and I claim that it‚Äôs obviously untrue, at least in some (important) cases. Consider: typename std::vector&lt;T&gt;::iterator i = begin(vec); // vs auto i = begin(vec); If you genuinely think that the first line is more readable than the last line then I probably won‚Äôt convince you^(1). Otherwise, we have now established that *at least in some cases* `auto` increases readability. I‚Äôll argue that it *always* increases readability: The real readability benefit of using auto does not come because it‚Äôs shorter (in fact, it will sometimes be longer). Instead, it comes from three things: 1. avoiding clutter 2. uniformity 3. no loss of explicitness (!) In order of least to most surprising: **Avoiding clutter** ‚Äî I guess most reasonable people will agree that the example above contains virtually no relevant type information. Yes, `begin` returns a kind of iterator but unless your code does something crazily non-obvious, spelling out the exact type has no benefits. We already know and accept this, since we‚Äôre comfortable [programming to interfaces rather than concrete implementations](https://softwareengineering.stackexchange.com/q/232359/2366), and using C++ templates. Choosing good variable names is eminently more important (and having an iterator named `i` implies a lot about its usage, so it can be an appropriate name). **Uniformity** ‚Äî For me, this is the big one. Even if AA had actual disadvantages (and I don‚Äôt think it does), these would be easily offset by the benefits of uniformity. C++‚Äôs syntax is generally considered flawed in many regards but one thing that often gets overlooked is the fact that variable declarations really don‚Äôt stand out and are easily lost in a sea of noise, because *every variable declaration looks different* (which leads to gems such as the [most vexing parse](https://en.wikipedia.org/wiki/Most_vexing_parse)). The whole point of AA is to make variable declarations syntactically uniform, and thus making them easier to read. Unfortunately the gain from this is hard to explain or quantify if you‚Äôre not already convinced. This is a case of ‚Äúseeing is believing‚Äù: Using this style consistently for a project is pretty convincing. **No loss of explicitness** ‚Äî ‚ÄúHang on‚Äù, I hear people say. ‚ÄúIsn‚Äôt this precisely the point of `auto`‚Äù? No. The point of `auto` is to remove *unnecessary* explicitness, i.e. to avoid clutter. But I agree that there are many cases where explicitness helps, or may even be crucial. And nothing in [the rules of AA](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/) says to avoid such explicitness. I‚Äôll be more direct: *The claim that use of `auto` leads to loss of necessary explicitness is categorically false*. Stop using it as an argument, it‚Äôs simply disingenuous. And, crucially, syntactic uniformity is such a strong boon that even in cases where types are specified explicitly, one should use `auto`, and write something like the following: auto format_flags = std::uint8_t{}; auto constexpr BOLD_MASK = UINT8_C(0x10); (This is using the [function macros for integer constants](https://en.cppreference.com/w/cpp/types/integer), since C++ fixed-width integer types don‚Äôt have literal type suffixes.) Here we have a case that‚Äôs definitely made more verbose due to use of `auto`. But unlike in the example above the added verbosity adds clarity and structure, not clutter; it‚Äôs the good kind of verbose. It‚Äôs OK to disagree with some (or maybe even all) of the above points. But I get the impression that most opponents of AA don‚Äôt so much disagree as fail to understand these arguments. At the very least the vast majority of arguments against AA (in this thread and elsewhere) are quite simply attacking a straw man. --- ^(1) Maybe if I showed an example where using `auto` prevented a bug by avoiding an erroneous implicit conversion. But while this is indeed a valid argument it‚Äôs rare enough that it might not offset the inconvenience of losing explicit type information.
What is type punning?
Operator+ doesn't gives the same results same when the values used may cause an overflow/underflow with a type but not another. So even with integer arithmetic you can get surprises.
I don't know what codebase you're working with, but algorithms are rarely what I care about. I'm generally solving problems like Thing.Connect() requires an Address instance, and Address.Create() requires an Endpoint instance, which requires a Socket instance. auto in that sort of situation is equivalent to obfuscation, because I can't know what this variable is without a lot of hovering. Nevermind that with sufficient levels of auto, most IDEs literally cannot tell you anymore.
That's fucking gross. Apologize to the world.
&gt; Someday, but it doesn't seem like in a near future, maybe in 40 or 50 years assuming the last standard is c++17, when all the legacy code dies and when all the new c++ code written everyday becomes obsolete. I think you underesimate exponential grow of software. It may happen much quicker. &gt; The problem is, with this article, it only shows examples of bad c++ that shouldn't pass any code reviews for secure sensitive software It's nothing to deal with secure sensitive software. I hate common apps (like games) crashing as well as bank payment web pages. But when your answer is "why you written this code" and "you have to review better" it doesn't really answer anything. I look at PVS articles that show that any project has all sort of "stupid" mistakes that no real programmer ever does if you ask him. But shomehow they appear in the code. &gt; and it does not provide any examples on how to do it better, but everything would have been fine even if he only included the examples with the bad code, even if he showed examples in how to do it better in Rust or Swift I would have liked the article, the 'real' problem for me is that at the end he shows nothing of how can you do it better in any way but by killing c++ and moving blindly to any other language: I agree on this one. It could have some sort of examples in other languages. E.g. first example may look like ```rust // moved to the function to avoid lifetime prolongation rust offers by default fn with_world(s: &amp;str) -&gt; &amp;str { &amp;format!("{}{}", s, "World\n") } fn main() { let hello_world = with_world("Hellooooooooooooooo "); println!("{}", hello_world); } ``` Which leads to the error ``` error[E0515]: cannot return reference to temporary value --&gt; src/main.rs:3:5 | 3 | &amp;format!("{}{}", s, "World\n") | ^----------------------------- | || | |temporary value created here ``` [link to the playground with first example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4ace79449e4e61f719cc7c5f1d6dcf81) Second example could look like: fn f&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Fn() -&gt; i32 + 'a { move || *x } fn main() { let mut y; { let x = 5; y = f(&amp;x); println!("{}", y()); } println!("{}", y()); } So you explicitely shows your expectation and compiler knows where closure may or may not be used. The first usage is legit when the second one gets rejected: ``` error[E0597]: `x` does not live long enough --&gt; src/main.rs:9:15 | 9 | y = f(&amp;x); | ^^ borrowed value does not live long enough 10 | println!("{}", y()); 11 | } | - `x` dropped here while still borrowed 12 | println!("{}", y()); | - borrow later used here ``` [link to the playground with second example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e40260d6dbdaf5d11d2cb38b5431e031)
Once you know what type literals have (and, being a core language rule, you *should* know this), `auto id = int{0}` doesn‚Äôt really buy anything over `auto id = 0;`: you‚Äôre simply repeating a type that‚Äôs already explicitly stated in your expression (well ‚Ä¶ `0` can technically be a lot of different types, but this will never happen in a direct initialisation to an `auto` variable). I otherwise agree.
 try { auto x = f(); } Why would you ever want to use the uninitialised `x` if `f()` throws?
Many people are saying it can prevent bugs due to implicit conversion but are not many concrete examples. Well, we have one from another recent topic: std::string_view sv = std::string{"Hello"} + "World\n"; // BAD auto s = std::string{"Hello"} + "World\n"; // GOOD
&gt; exactly what it's supposed to be With the frustrating exception of auto&amp;. Maybe it's a bad idea to have functions return references, or maybe I'm just bad for forgetting to use auto&amp; when I needed to, but it's caught me out a bunch of times.
I find it really handy for writing lambdas =) Seriously though, when I first discovered auto I tried to declare every variable I could as auto because why not? I quickly learned that this is not what auto is for. It's awesome, but the most obvious (not having to choose your variable type at declaration as it will be inferred) use is actually the least useful and practical use. Most of the time it's unable to infer, especially if you've declared *everything* as auto and aren't initialising each variable with the result of a function. However, you try writing out a range based for loop without using auto. You'll still be typing it out the day you die, and your code will look horrid. auto is your friend when mucking about with container iterators.
&gt; cuz it is not guaranteed to be constexpr, You are wrong. https://ideone.com/cpXv3a
&gt; that sounds to me more of a specific case where static analysis was misused, maybe also with a combination of bad coding habits? or maybe it just wasnt a great static analyzer. but like i said clang-tidy seems to work for a lot of people. It was compiler warnings, actually, not some kind of linter. And even they were disabled. Of course it's bad habits, but you probably underestimate amount of devs with these habits and amount of code they write you use. &gt; ideally sure, but we dont have that. I agree that from a language design perspective its better for the language to detect errors compared to external tools, but my point is that you can still write safe and secure code in c++ right now if you use appropriate tooling. I belive we do have that. Using tooling and writing right code is much harder than just have a compiler that supports all your intents. This logic may be extrapolated further. I saw a lot of articles about dynamic languages with same arugments. "If you have the right tooling and good documentation you don't need types that only limit you". We both can probably agree that they are not quite right. But the same applies to your arguments. &gt; well i think you should always use the right language for the job. im cool with new languages and stuff. but the original point was just that you can write safe c++ code and the entire point of the article is countered by mentioning tooling. Well, I never actually safe C++ code. The larger codebase is and smarted devs are, the more bugs there we have. Windows/Linux/Chrome/Firefox/..., take any program big enough and there will be plenty of bugs. Of course, some of them you will have in any language, but some of them are specifically out of bounds/null dereference/double free and all sort of things. In Mozilla research about FF bugs this kind of bugs was an absolute majority, and they are literally impossible in some other languages. And no, these languages don't produce their own kind of bugs, they just fix these without introducing new ones instead. And tooling and all sort of things won't help. I'm quite sure that FF/Chrome/... guys use all sort of analysis, they have really tough code review, they have multiple testing cycles with thousands of testers... And they still plant these bugs. We all are mere humans, we all make mistakes. The more type system helps, the better code we write. It's easy to spot misbehavior in business logic, but it's really hard to spot memory issues, especially in multithreaded envirnment. The first kind of bugs is easy to find and fix, especially with TDD approach, the second one is the hell.
[Protlr](https://www.protlr.com/) does what you want - Custom byte- and bit-oriented protocol serializers. It uses a DSL to define the format and provides code generation targets for C89 and CPP11 which generate extremly fast, compile-time constant memory footprint and reusable code. Exaclty what you need for embedded systems.
Are you usually compiling with -O0 or don't you have the slightest idea how compilers work?
I'm a developer, I like to automate things, even my own life and my own work. So if I can learn anything that will save me some time multiple times then I go for it. Why do we care about performance? Because one second of user awaiting multipled on users count gives our millenia of wasted time. The same applies to you, e.g. you can copypaste all sort of things or you could learn metaprogramming and automate it.
Can be necessary. I created a `ParticleSystemManager` that had a nice little array of `Particle` objects which had a bunch of `vec3` members. Well, not that little, actually, since it contained 64K elements. Pop went the stack, but not immediately, no, only in some OS-level initialization calls. And that's when I remembered that stack space was finite, and no dogma is fool-proof.
Then I guess it is compiler dependent, the example fails in visual studio 2019
100% agree. I would legitimately ban `throw` from my codebases if I could. It would also get rid of 90% of the justifications for modern C++ paradigms like RAII and smart pointers. I want my pointers dumb as hell.
And then you'll hear from others that it's too verbose (e.g. Java).
And why should I risk if the compiler decides not to inline the small functions, point out one single benefit that writing extra small functions does over the isinstance style, and please don't even say things that are subjective to individuals like "I think writing a lot of functions is more readable"
I somewhat tutored C++ in college. The one thing I noticed was people who were use to python using auto to supplement a lack of knowledge of type systems. My biggest peeve is obfuscation types or even, god forbid, polymorphic instance variables (I work in Ruby for a living at this point). My personal opinion is for smaller projects, use aliases for long type names. Larger projects, it‚Äôs okay to use auto for iterators if your functions and inputs are organized.
This is what truly makes me sad about lambdas. I wish I could, for a non-capturing lambda, define the type, eg. std::lambda&lt;int&gt; f = [](){ return doThing; };
Also, your modified example does not show if the function works for the constexpr context, you are printing the values which has nothing to do with if the evaluation is constexpr or not, do a have slightest idea of what compile time evaluation is?
You're also preventing people from reading it. Unless you literally don't care what the type is, I think you should write it out. This is fireable offense IMO: auto foo = getThing(); foo.doStuff(); Calling any method on an auto is intentional obfuscation, because I don't know what else I can do with it from a glance. This too: auto foo = getThing(); auto bar = getOtherThing(); auto baz = foo + bar; I have no idea what is going on there - are those integers, floats, strings? Something else with an operator+ overload? What's baz? This is probably OK: auto foo = vec.pop_back(); vec.insert( 0, foo );
Maybe your code base is smaller, but mine is IDE-stallingly huge. If I replaced every return type with auto right now, I'm not sure Visual Studio would ever be able to figure out what any underlying type actually is. Also, tools _often_ fall apart when your code isn't in a compiling state, which is usually when you want the most information.
Hmm you should probably mention / take a look at http://stellar-group.org/libraries/hpx/ I personally feel neither MPI nor OpenMP are the real solutions too those kind of problems. Will probably take another 10 years to get those parallelziation abstractions completely correct so that it does not matter anymore where your code actually runs (cpu/gpu/remote cpu or gpu) as long as it has the required input data.
Also, since we're using almost always auto `GetNames()` could have an auto return type, and it's getting the names like this: return Database.RunQuery(); How far down the rabbit hole can we go? Very fucking far. I feel like auto is only pushed by people with small codebases like students, hobbyists and academics.
I'll admit that this case is a little artificial. I fail to see the situation (outside of templates that force your hand somewhat) where you *want* to use auto for the return of foo() but yet still know the return type enough to be able to produce another usable value in case an exception is launched.
A non-capturing lambdas can be implicitly converted to a function pointer. int (*f)() = [](){ return 5; };
For 20 years my brain has been programmed to parse a variable declaration as "type variablename = value". With auto, I have to mentally break that training and now get the type from the right hand side. That doesn't make things easier for me with less visual distractions. It increases my congnitive load
This is why I use struct everywhere. Public inheritance by default and public members first make much more sense.
You also need the same alignment, and even then it's still not truly defined, even if you will generally get away with it.
The only thing I really hate about auto is when it's used for parameters of non generic lambdas. I mean it's ok when it's a one liner comparision operator or something like that, but there are also complex lambdas - especially for asyncronous callbacks. The IDE then won't / can't help you and you don't get any hints when hovering over the parameter, which makes Herb's IDE argument moot for this case.
One of the caveats of auto, which people often bring up, is that it makes the code slightly harder to reason about, because the type is less obvious when reading the code. Another (hypothetical?) caveat is that it can lead to subtle bugs, where the type resolves to something else than what you thought it resolved to.
Can I simply goto the return statement? /s
I currently work in a codebase that has 1000s of lines of comments like this. Funny thing is, more than one of them was copy-pasted and not updated, yielding inaccurate comments that never should have existed in the first place.
Technology changes, you need to learn to adapt to it.
Didn't know that, nifty.
I wonder if doctors can get away with that excuse. "I've always performed this now outdated and objectively riskier procedure. Asking me to read the patient's chart and note a new number to replace the old number I used to read in its place increases my cognitive load. I'm better off sticking with what I know, for everyone's sake!" I know this example is pretty extreme compared to the "type variablename = value" example given, but that example was in response to the context of "The return type of std::make_unique is obvious". Given the context, it feels like you're trying to make the case for continuing to use C++98, ignoring as much of C++11 and newer as possible. Hopefully I'm wrong about that.
I think what you're saying is that this CAN be perfectly fine, but only under assumed conditions. In the spirit of the thread, teaching something like this to as standard practice is definitely terrible. It's a technique generally reserved for when a class a) is too large for the stack, and b) is performance-critical. That situation is pretty rare in most problem domains, and moreover you need expert knowledge/techniques to determine if it's a true performance win. I agree that it's not a "never do this" thing, but it's also not a "usually do this" thing.
I totally and strongly disagree here. All the obfuscation arguments apply, especially if values is declared some distance away in a who-knows-where header file. In that line v could be just about anything, but 99% of the time the author knows exactly what it is. &amp;#x200B; Sure there are good, generic, reasons for using auto. But that's just about the only time it should appear in a codebase.
A few month ago, I removed 30k (yes, 30'000) lines of comments in our codebase. It decrease by ~5 the size of some headers. I suddenly understood that all of those classes were value types (and not classes that encapsulate behaviors). The amount of useless comments effectively **decreased** the readability. And now, I can still remove ~2/3 of the file to remove all getters + setters, and make every fields public (those classes don't have any logic, and all fields have read+write access, so it make no sense to not just use a plain old struct).
I don't use the `auto id = int{0}` syntax right now so I don't have enough hindsight on this but an argument I've seen around is that it brings homogeneity to the variable declarations : Always `auto` on the left side, always the type on the right side (which will appear only once by declaration).
It depends on the service the class is supposed to fulfil. - Is it only an aggregate of data without any invariant? Why isn't it simply a struct in that case - There are invariants? Then why exposing data? Does it really make sense? (there are case where is does) Can't the class instead provide us a service? There is a lot of literature about setters here and there.
Why it is ugly? Copying a vector is really fast thanks to move semantic (you need to copy 24 bytes on my machines), whatever the number of elements inside.
From the moment we block comparisons between `ColoredPoint` and `Point` or have them behave differently depending on the static types, we stop respecting the LSP and tricky issues may appear later on. If we prevent syntactic substitution (offered by public inheritance), we are no longer bound to respect a deeper substitutability (LSP) -- Sorry I have troubles to express it clearly in English. Let's change the example struct list { void append(int i) [[post: back() == i]]; int back() const; ... }; struct sorted_list : list {...} [[invariant: is_sorted()]]; // I know we won't have this contract void some_function(list&amp; l) { l.append(42); do_stuff_with(l.back()); // expected to be 42 } sorted_list sl { 1, 2, 50, 100 }; some_function(sl); On a syntactic level we can pass a sorted list where a list is expected. On a deeper level we cannot use a sorted list in that function because there is no way to guarantee that the new element will be appended at the end **and** that the list stays sorted. If we remove `append()` service from sorted lists... we would also break (English?) the LSP. It's the same with coloured points and points, we cannot remove a service that works or have it behaves in a way not compatible with class contracts.
Shouldn't you be using [`std::remove_cvref`](https://en.cppreference.com/w/cpp/types/remove_cvref) instead of `decay`? Decay also converts arrays to pointers and functions to function pointers, neither of which you really want here.
[There is no language called "C/C++"](http://www.stroustrup.com/bs_faq.html#C-slash)
I give up _inclusion polymorphism_ because contracts/LSP cannot hold all the way in these cases. It's not about being silly, it's about getting rid of improper design that is likely to introduce surprises. LSP is fundamental OOP stuff. Well it's _Design by Contract_ applied to inheritance. And an invalid contract is a bug in the design.
`using namespace std;` is a bad practice because it pollutes the global namespace. A better practice (if you want to save yourself some typing) is individual `using` statements for everything you want to pull in from the `std` namespace. God help you if you put `using namespace std;` into a header file somewhere.
The return type of this lambda is `void` because it lacks a return statement.
The problem here is the cast, C style casts offer no protection whatsoever.
Wait I don't understand. Does this code illustrate what you mean? #include &lt;iostream&gt; int intBar() { return 7; } char charBar() { return 7; } int main() { { auto foo = intBar(); float baz = (float) foo; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; "\n"; } { auto foo = charBar(); float baz = (float) foo; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; "\n"; } { int foo = intBar(); float baz = (float) foo; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; "\n"; } { int foo = charBar(); float baz = (float) foo; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; "\n"; } } Compiled with g++ it prints baz: 7 baz: 7 baz: 7 baz: 7 So there is no difference. Also what does "the gibberish address value" mean? Is the char returned by bar a index of some sorts? But even then the compiler wouldn't have noticed it.
The fireable offence in this code is the use of unreadable variable and function names. If the code is still unclear with proper names in their proper context then, sure, add explicit type information. But literally no proponent of `auto` (including Herb Sutter with AAA) advocates writing code such as yours.
`protected` is useful for member functions, but should be forbidden for attributes.
In C++ struct and class are exactly the same except for the default access. In struct it is public in class it is private, but since you can specify it explicitly in both, the difference between them is only syntactical.
You can add access modifiers to a struct in C++
I really don't understand why people try to run parallel Python. They are already running 100x slower. Why even bother about performance when you're running Python?
People who don't like auto want to know the type of an instance just by looking at some code in isolation. Generally they are people who want no ambiguity and or don't use an IDE when code reviewing. People who do like auto don't want to know the type, they just see what methods are used with the instance. They trust the names given to variables and the methods called on them. The auto camp probably have more of a proclivity to structural typing (tell me what I can do), as opposed to nominal typing (tell me who you are and I'll decide if I like you).
Of course, it's an example. The core of my argument is that variable names are less descriptive and helpful in describing what a program is doing than typenames. Variable names are just comments, and comments get out of date. I would argue that the only reason AAA has gained any popularity is because modern C++, by making typenames verbose and difficult to parse, has made the above less and less true with each iteration. No longer do we have simple types like `Thing*`, instead we have `std::unique_ptr&lt;Thing&gt;`. That's 17 characters of noise, for something as simple as a pointer. That's the simplest, most friendly example I can think of; you'll note that I'm not even driving the point home with maps or iterators (or iterators into maps) here. If we would have got `Thing^` with the same semantics as `std::unique_ptr`, among other improvements, I don't believe that the AAA movement would have gained any steam at all.
To add to this since OP asked why dislike it: Some people are pushing for the use of `auto` *instead* of typing the type, and using a constructor instead. For instance, you can find some CPPCon videos from 3014 where Herb Sutter gave a talk about modern CPP features and talked about how auto should now be used everywhere, and people should basically write something like this: auto foo = int{5}; Rather than just: int foo{5}; The reason a lot of people like it is to not have to type-out long names twice, or when knowing the specific type itself isn't important (i.e. iterators since your vector's type might change), but some people are pushing it too far for some people.
In general, I do not like auto. I spend most of my time reading code in my day job. I have to quickly understand what is going on. Sometimes this is from an IDE, but often it is from a text editor or a diffing tool. Auto greatly impedes my ability to trace the flow of code. IMO, the only acceptable uses of auto are: * Iterators that are obviously iterators and are used in a common way. * Rarely when writing templates, if it increases code readability. These are common cases that auto is used for in practice, and why I dislike them: * Auto makes it easy to change return types with less refactoring. This is true, but it also makes tricky type-related bugs harder to spot. Just change your return types and refactor. It's not a big deal. * Auto saves me typing. It does, but the seconds you save each time you type it can translate into minutes lost by the people trying to read your code. * It's okay to use auto as long as the type is on the same time, e.g. `auto blah = MyType(5, 10);`. The previous statement could be a type, or it could be a function. It is rarely clear enough to justify the usage of auto, and even if it is clear, code readers will be scanning the left column for the type, not the right. * Auto makes ranged for loops much easier. It also introduces accidental copies. I have seen this go wrong numerous times 'in the field'. IMO, auto trades a small amount of time now in for a comparatively larger time later. Its usage is a non-obvious form of technical debt.
I remember c++ errors back in the day. Before std included smart pointers. One typo and it returns 500 words. I recently started Rust, and oh my gosh errors are so much nicer. Maybe that's not Rust but because of Clang ? Has c++ improved that well ?
I do not really see any value added in this article. Merely a compilation of information available in myriad other sources online.
Is this an advantage of auto? If the same author wrote both of these examples, I would argue that the first example is better. It will likely crash the application and make the developer consider what type they ACTUALLY want `sv` to be. In the second example, the author intended `std::string_view` but got `std::string`, which seems like it may turn into a confusing bug or have performance implications later down the line.
That code is not only hard to ident, it is also hard to read. It took me several passes to understand what is happening here. Why not assign the inner lambda to a variable and return the variable? The code will become more clear and more indentable (if this is a word)
Ok, I'll bite: How does knowing the type make the code more readable?
I'm not saying I can't/won't ever use auto, I was replying to the statement "making reading easier by having less visual distractions in the code". You are removing potentially important information that could have been seen at a glance, and now you have to stop and spend time to interpret what the return value is, instead of just reading it. I'm all for the use of auto in things like STL iterators where it is obvious to EVERYONE what the return type is, and it is super long. Not in a case like this: auto filename = GetFilename(); Now I have to have a deep understanding of every single class and function in the code base I'm working in. Does that return a `std::string`, a `QString`, a `Foo::Filename` object, a `char *`? And before someone says "let the IDE tell you what it is", that goes back to be original point: Now I have to move my mouse over the variable to have the IDE tell me, when I could have just read it if it wasn't using auto. And what if I'm not in an IDE? Is a patch file or a code review in a browser going to give me that information? No.
Consistency in formatting is important in code for the same reason it is important in natural language. It immediately communicates the structure of the text and lets the reader focus on the content.
the auto is still not a reference there. sounds pedantic but auto using templates deduction rules is exactly why eg auto &amp;&amp; works the way it does.
Avoid the OCD that half of the readers suffer when they see inconsistent things or two spaces to separate two words without any apparent reason x)
That's interesting. Using slightly modified version of the code: #include &lt;type_traits&gt; template&lt;typename T, class Z&gt; constexpr bool isinstance(Z&amp;&amp; ) { return std::is_same_v&lt;std::decay_t&lt;Z&gt;, T&gt;; } auto a = 1; auto &amp;b = a; constexpr auto x = isinstance&lt;int&gt;(b); This is compiled by gcc and clang, but fails on icc and msvc. I wonder who is right here and who is wrong.
True, but it's also fully consistent with my claims you need to know what you're dealing with, and the type may not be even close to what you need to know. If you're dealing with an angle in degrees, anything about 360 is overflow. You shouldn't mix UTF-8 and UTF-16 data.
I write C but have to fiddle with poorly written C++ code a lot. I don't know how to cast properly in C++ by heart. But I doubt the C++ cast would catch this, too.
That's pretty much my point.
&gt;But the majority of time spent as a programmer is _reading_ code, not writing, so I optimize for that. Writing is insignificant. Honestly, I don't get it. This should be just as easy if you're using an IDE.
I know you can, I just don't
The issue is that `doThing` is a bad function name, no matter what is the return type. I agree that `auto` makes things worse, but when you get bad news, you shouldn't kill the messenger!
It also doesn't necessarily have to be tied to one type though. vector&lt;angle&gt; might one day want to be replaced with deque&lt;angle&gt;: you should not be manually typing these in everywhere. AAA or typedefs remove redundancy from your codebase.
 #include &lt;iostream&gt; // Old bar() int bar() { return 7; } // New bar() char *bar() { char *baz_ptr = calloc(13, sizeof(char)); return baz_ptr; } int main() { auto foo = bar(); float baz = (float) foo; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; "\n"; } I didn't run but it'd output old baz: 7 new baz:-5.487463454472838 because foo is an address like 0xff0000ffffff0000
That loop was dangerous long before `auto` was a thing, because people *happily* wrote the same loop with an explicit `size_t i` declaration. If anything, this code is evidence that explicit types aren‚Äôt all they‚Äôre cracked up to be. In reality, counting backwards in a half-open interval of indices (which requires starting at 1 before the end, and stopping on an inclusive bound) simply confuses people. The whole point of using half-open intervals of the form [a, b[ is that they reduce confusion. But when counting backwards, we‚Äôre suddenly faced with an interval of the form ]b, a], which has different behaviour at its bounds. C++ provides a much better solution for this use-case, which is to use the ‚Äúright form‚Äù of half-open bounds here, via the `rbegin()` and `rend()` iterators. The whole reason for the existence of reverse iterators is to avoid this pitfall, and it‚Äôs utterly unrelated to the presence or absence of explicit types, and hence to `auto`.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
https://developers.redhat.com/blog/2019/03/08/usability-improvements-in-gcc-9/
Casting from char* to float is not allowed right? g++: error: invalid cast from type 'char*' to type 'float' float baz = (float) foo; ^~~ clang: error: C-style cast from 'char *' to 'float' is not allowed float baz = (float) foo; ^~~~~~~~~~~ I doubt MSVC would let it pass
&gt;Of course, it's an example. But the example only works because you chose bad names. This is a *crucial* point. &gt;I would argue that the only reason AAA has gained any popularity is because modern C++, by making typenames verbose and difficult to parse, has made the above less and less true with each iteration. To anybody who uses other modern languages next to C++ it‚Äôs obvious that this is false. Type inference akin to C++‚Äôs `auto` is present in lots of industry-strength languages with modern type systems, and was moreover added to other modern languages where it previously didn‚Äôt exist (most notably C#). The real reason for AAA‚Äôs gain in popularity is that C++‚Äôs syntax for variable declarations objectively sucks (‚Äúmost vexing parse‚Äù, enough said). Nobody seriously contests this, and AAA gives us a simple, direct way of making declaration syntax suck a lot less, and make it more similar to other modern languages with static typing.
Your example: auto foo = getThing(); auto bar = getOtherThing(); auto baz = foo + bar; First, you have the issue of: Thingy foo = getThing(); OtherThingy bar = getOtherThing(); CResult baz = foo + bar; If you think functions can be badly named, then there is no reason why your types would have any better names. Furthermore, in this case, you will have to look at Thingy *and* getThing() to check if there is a conversion going on, or some ugly slicing. At least, with auto, you don't have to care. Second, you have the issue that you don't protect yourself against: CResult baz = getThing() + getOtherThing(); This is not readable either. Lastly, refactoring the code will do the right thing with auto, while it may add spurious conversions/slicings with explicit types. That said, I do understand where you are coming from, and code like: template &lt;class T&gt; auto f( T &amp;t ) { auto data = prepare( t ); analyze( &amp;data ); return finish( data ); } can be quite hard to follow at a non-superficial level, in particular when prepare, analyze and finish are also full of templates and auto... TBH, this is what C++ is about looking at definition sites since forever. You *always* had to look at definition sites, because: int a = 42; f( a ); g( a ); have very different behavior depending on wether we are talking about ```f( int )``` and ```f( int &amp; )```...
Here is my favorite use of `auto`: // round to nearest, to even on tie template &lt;class To, class Rep, class Period&gt; constexpr inline To round(const std::chrono::duration&lt;Rep, Period&gt;&amp; d) { auto t0 = floor&lt;To&gt;(d); auto t1 = t0 + To{1}; if (t1 == To{0} &amp;&amp; t0 &lt; To{0}) t1 = -t1; auto diff0 = d - t0; // Best: diff0 is common_type_t&lt;To, decltype(d)&gt; auto diff1 = t1 - d; if (diff0 == diff1) { if (t0 - duration_cast&lt;To&gt;(t0/2)*2 == To{0}) return t0; return t1; } if (diff0 &lt; diff1) return t0; return t1; } The intermediate results `diff0` and `diff1` can have a type that may not be either the input type (`d`) or the output type `To`, but rather is the `common_type` of these two user-supplied types. For example if `d` is `microfortnights`, and `To` is 1/3 of a second, then the type of `diff0` and `diff1` is 1/1875 of a second, and it really doesn't help the reader of the code to know that. Here is the most dangerous use of `auto` I've seen: // Take any of the predefined Durations and return their // average as nanoseconds template &lt;class Duration1, class Duration2&gt; nanoseconds avg_nanoseconds(Duration1 d1, Duration2 d2) { auto ns = nanoseconds{d1 + d2}; // Worst: Uses error-prone explicit conversion return ns/2; } This is intended to take any of six "predefined" chrono durations, average them and output the result as nanoseconds. The problem with this code is that the template parameters are overly generic, *and* the code **explicitly** converts these types to `nanoseconds` as the `auto` syntax encourages. This code works correctly when used correctly: auto x = avg_nanoseconds(2us, 1ms); However it also allows run-time errors, for example if the units on the input are forgotten: auto x = avg_nanoseconds(2, 1); In this latter case `avg_nanoseconds` silently converts the integral inputs to `nanoseconds`, which is not intended. One way to fix this is: // Take any of the predefined Durations and return their // average as nanoseconds template &lt;class Duration1, class Duration2&gt; nanoseconds avg_nanoseconds(Duration1 d1, Duration2 d2) { nanoseconds ns = d1 + d2; // Better return ns/2; } Now the latter case is a compile-time error because integral inputs won't implicitly convert to `nanoseconds`.
wow. it's very complicated! who the hell has invented this shit? but the article is good. thank you.
One issue is that you add another name in your code. [Naming things is *very* difficult](https://www.martinfowler.com/bliki/TwoHardThings.html)...
C++ is a really complex language and takes quite a bit of time to learn. Be sure to keep an eye open for "modern C++", if you're not tied to some legacy codebase. Also, keep in mind that it's a HUGE language and no advice should be taken in a dogmatic way. On a more important note though, why would you learn C++ if your goal is to create webapps? That's like learning to sing because you want to be a good painter...
Because running 50x slower is better than running 100x slower.
&gt; to return char *, it is casted to float and the gibberish address values of the char * are used hint: typing \* as in char \* don't display a \* but put the rest of the line in *italic*, making everyone scratch its head. Please fix by using char \\\* instead of char \*. Thx!
Go back and read your previous comment. Then edit your char \* to char \\\* in that comment.
about 100k loc msvs project full of auto. intelly sense have it's issues allright, but pretty workable. and i use vscode on my ubuntu box, works flawlessly.
This isn't make's fault. What version of the OSX SDK are you using? [32-bit isn't supported by default anymore.](https://github.com/the-tcpdump-group/libpcap/issues/760#issuecomment-429596416)
Thank you for responding! "HUGE" in term of libraries or would you mind elaborate ? I wasn't necessarily learning for web app, I'm kind of interested in object oriented programming, and C++ seems organized into classes like Java? for an average of 2hrs coding in a day how do you think it'll take me to get familiar. I'm in summer break try to be productive lol. again thank you for your response.
My bigger challenge is convincing my team that comments like these do not add value.
When I'm lazy, I typically implement copy/move ctors in terms of assignment. Also, calling the dtor won't allow existing allocations to be preserved for copy assign, but that's probably not a problem for the kind of types where you would user-define special member functions. Also, make sure you check that `this != other`.
&gt;One possible rule is that the type is obvious if the right hand side is a literal auto str = "Hello"; // Did the author intend str to be a const char* ? auto&amp; str2 = "Mundo"; // Did the author intend str2 to be an array? // Is it obvious to the reader? auto n = 12571352561; // What type is this?
I'm not sure what I'm using. But I know I can compile a static (.a) library just fine. I don't even know how I'd found the version out. I'm not specifying any versions anywhere if that helps. And I CAN compile 32-bit shared-libs from Xcode just fine. Either way I still think cmake would give less cross-platform problems than make.
As mentioned C++ is not for web. You do have beast and some web frameworks that build on it, but unfortunately not many companies will use C++ for web
Man, people are *really* touchy about this! I was just making the -- hopefully uncontroversial! -- statement that most C++ code is written by people who aren't familiar with the language and don't write C++ code on a regular basis. People seem to think that "not being a C++ programmer" == "not being a worthwhile human being" here.
Biggest downside I can see: what if construction throws?
Your approach is technically correct. But the more common and robust approach to the same problem is the [Copy-Swap idiom](https://cpppatterns.com/patterns/copy-and-swap.html).
I believe a better analogy would be something along the lines of: "Making your own pencils, colors, brushes etc... so you could become a painter". You could make a webapp with c++ but there are lots of tools which are easier to learn, maintain and use for this task.
I mean, 100k lines is still what I would consider small.
I'll hop on the train and ask a more general question, if it wasn't asked already. What defines an "intermediate" C++ developer? Good template metaprogramming skills? Knowing when to pass by const reference and when to use pointers? Avoiding raw mallocs? Knowing how to optimise an algorithm?
Why is it more optimal than copy swap?
Don't.
Note: `this == other` is only legal in copy statements - it's undefined behaviour in moves and you can safely assert on it instead.
This is weird and you should stop doing it as soon as you can manage. It makes working with other people unnecessarily hard. Just use a code formatting tool. You will get used to it.
I do a lot of image processing and related research. Most people in this field use Matlab or Python to figure out algorithms. Even though I was taught C++, using Python to do your research is a no-brainer with all the very solid packages (numpy, scipy, simpleITK, Pandas, Tensorflow/Keras, etc.) that it offers, letting you skip writing a lot of boilerplate code. When you are running a script on a set of 1000 3D patient scans, total run times can run into the realm of days (or weeks, in some unlucky cases). This brings me to your following point: &gt;I really don't understand why people try to run parallel Python Any optimization you can get in there will be a massive time saver on large scale operations.
This is not exception safe. If \`new(this) Foo{other};\` throws, then \`\*this\` is left in a destroyed state, and behaviour will be undefined when it is destroyed again finally. &amp;#x200B; Copy and swap is marginally slower, but its strong point is exception safety. &amp;#x200B; Move assignment is not easy to implement with exception safety, but on the other hand, move construction is typically much easier to implement with no-throw guarantee than copy construction.
Python is used quite a bit in the scientific world, and for good reason. The ecosystem includes many high performance libraries that delegate the bits that would be slow if written in pure Python to compiled languages like C++ while giving you the rapid turnaround possible with an interpreted language. In reality, if you're doing something in Python that ends up being 100x slower than what you can do in C++, you're likely doing something drastically wrong.
Building a shared-lib with Xcode works... mymac% lipo -info .../sharedtest-gyxkokmltjryxtfgkcygzxmuygxo/Build/Products/Debug/libsharedtest.dylib Non-fat file: .../sharedtest-gyxkokmltjryxtfgkcygzxmuygxo/Build/Products/Debug/libsharedtest.dylib is architecture: i386
I used to think exactly like you, until I had to do a code review for someone who over-used auto "Because why would you need the full type when working in an IDE?" I have immediately reduced using auto since then. Sometimes, even in 2019, you will need to read code without an IDE, and auto can really obfuscate code at times. Is this an int? An unsigned int? Is this a pointer or a handle or a raw pointer?! I like the more balanced approach now. If the type is obvious or unreadable (such as in template heavy code), use auto. If it's not, don't.
&gt; But the example only works because you chose bad names. I disagree. Here, better names: auto customerNames = GetCustomerNames(); Alright, what capabilities does `customerNames` have? Can I use `std::find()` on it? Can I remove a name from it? Seeing this line of code does not give me enough context to know anything about how I can manipulate it. I spend so much more time reading code than I do writing it that having to pause for even a second at anything made unclear by `auto` would slow me down near-infinitely. I fixed a bug last week that took me 9 hours of painstaking debugging in an unfamiliar codebase, and the fix ended up being a one-liner. That is my reality. `auto` is incompatible with it. &gt; added to other modern languages where it previously didn‚Äôt exist (most notably C#) Yes, it was, and Microsoft's own guidelines state this: &gt; Use implicit typing for local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important. [Source](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions) That's quite different from almost always auto.
Well this is a destructor call + copy/move constructor call, copy and swap is copy/move constructor call for argument, swap, and destructor call of argument, so the swap is avoided. If the copy and swap operator='s argument is constructed from other constructor then a move constructor is avoided, but a swap is still necessary
Consistent formatting removes visual noise. When you get used to the formatting style, you can read code much faster because you can focus on its meaning. You don't have to waste brain cycles normalizing the code in your head. This effect might differ from person to person, sure. I don't think that there is any better way than consistent formatting though. The other benefit is that you can type much faster because you don't waste as time on fixing whitespace. Just type away, skip spaces, ignore newlines. Cut and paste without any whitespace adjustments. Let the tool fix the mess in the end. I would never work without a formatting tool anymore because it saves at least 20% time. Again, I can focus on the meaning of the code and don't have to waste brain time with its formatting.
 using namespace std::string_view_literals; auto sv = "Hello"sv.substr(1); // BAD std::string s = "Hello"sv.substr(1); // GOOD
This is tangential, but [here is a discussion](https://www.reddit.com/r/cpp/comments/a3dy9j/web_interface_for_c_program/) from a few months ago about some c++ web app tools that you might find helpful. I came to c++ from Java and my advice for starting out would be to get familiar with object lifetime rules. That was the largest philosophical change I experienced. Hope you enjoy c++!
&gt; But I know I can compile a static (.a) library just fine. Static libraries aren't linked. If you were to try and link that library into an executable, you'd have exactly the same problem you are now. &gt; I'm not specifying any versions anywhere if that helps. It's actually most likely your problem. Just tell XCode to spit out the verbose build commands and you'll see what you're missing. &gt; Either way I still think cmake would give less cross-platform problems than make. CMake is going to generate Makefile or XCode projects. It's not going to magically paper over the fact that you don't understand the platform you're developing on. In fact, since it only will generate one flavor of the build system at a time (32-bit or 64-bit), it's probably going to be even more frustrating for you. But, it sounds likes you're doing something reasonably simple and are just trying to get up-and-running. This is a bog-standard project template like you'd find in any example online: cmake_minimum_required(VERSION 3.12) project(your-project VERSION 0.1.0) add_library(your-static-library STATIC foo.h foo.cpp ) add_library(your-shared-library SHARED bar.h bar.cpp ) add_executable(your-executable main.cpp ) target_link_libraries(your-executable PRIVATE your-static-library your-shared-library )
Also, don't get discouraged if this post is downvoted. I assume people are downvoting it because they see this question a lot, but that's just proof that it is a good question. It also shows that people switch to c++ frequently and you can too.
&gt; check if there is a conversion going on, or some ugly slicing If these are your biggest problems then you don't have very big problems. I'm not giving up _the best_ tool for aiding in the reading of code to solve them. CResult baz = getThing() + getOtherThing(); I agree that's not readable. I don't think you should write that code. &gt; very different behavior depending on wether we are talking about f( int ) and f( int &amp; ) I don't think you should write `f(int&amp;)` either. What I'm saying is that you should optimize for _readability_ above all (well, most) other concerns. C++ code is rarely throwaway - it makes far too many trade-offs in favour of performance by sacrificing iteration speed for it to be a good language to just hack out some script in 20 minutes. If there's a choice between readability that sacrifices some refactoring ability, then that's an easy choice to make.
What about values other than 0? Do you mention the type for those? Where do you draw the line? auto x = 20000000000; // What type is x?
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bgv06e/anyone_came_from_cjava_how_long_it_took_you_to/elntkg8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Two things regarding your example, and one thing regarding coding guidelines. First, are the names really better? Maybe with a proper contest (context is *crucial*). But honestly the names are already duplicated, tell me nothing, and having a type (`CustomerName`, maybe?) would do nothing to improve this. You‚Äôre just repeating the same piece of information three times. Secondly, you keep ignoring my point that `auto` does not preclude usage of an explicit type, and my top-level comment shows this usage. Regarding guidelines: &gt;Microsoft's own guidelines state \[not to use a lot of implicit typing\] Microsoft‚Äôs .NET coding guidelines (in general, not just regarding this point) have been inconsistent and controversial as long as I have been programming in .NET professionally, which is now two decades (yes, since the early beta). Lots of influential C# developers (e.g. [Eric Lippert](http://blogs.msdn.com/b/ericlippert/archive/2011/04/20/uses-and-misuses-of-implicit-typing.aspx), former principal engineer of the C# compiler) disagree with this particular guideline. In other modern languages with static typing and type inference (Haskell, F#, Scala, to name a few), the point is moot: Using implicit typing liberally is the status quo, no widespread guideline contests it.
I just hope that I don't cause some std algorithm to accidentally self-move one day.
So like perl but shittier?
At work we use python as our test infrastructure. Running tests in parallel, for instance, would be helpful.
lol 10 years....na√Øvet√© is cute
ad revenue
then some day you'll have to fix a bug.
&gt; If these are your biggest problems then you don't have very big problems. Don't patronize me, please.
It won't be the first std algorithm I've reinvented.
Nested range-based for loops was what made me start thinking that maybe I had been overusing auto.
That is not really related to high performance parallel Python. (Which is what I'm ranting about)
Thank you so much ! glad to hear someone has similar experiences . If you don't mind how long have have been coding in c++? , how long it took you to get familiar with c++? thank you for recommending , I will check it out" object lifetime"
This is actually a well-explored anti-pattern, for example, see here: [https://isocpp.org/wiki/faq/assignment-operators#self-assignment-why](https://isocpp.org/wiki/faq/assignment-operators#self-assignment-why)
Thanks for the info! My uni pretty much only teaches c++ and Java so I don't have an option about learning it in school.
First of all, I think the shift towards Python is stacking technical debt. We already have Julia which is as productive and much faster than Python. Also, I have quite some experience with Python and it's really easy to get more than a 100x slowdown. A simple function call in Python is so freaking slow! Even calling Python wrapper functions for OpenBLAS, MINPACK doesn't scale.
C++ is mainly a huge language, it has TONS of features and things you can/need to learn. To give you an idea of what I mean, take a look at the Wikipedia article on C++11: https://en.m.wikipedia.org/wiki/C%2B%2B11 It lists a lot (probably not all), things that were introduced in C++ in the 2011 revision. Since that, there have been 2 "minor" revisions (C++14 &amp; C++17), and we have another major revision coming up in 2020. These are revisions they are changes/additions to an already existing language, so you can see why it's quite simply a big language. In terms of the std. library (and the STL), C++ takes a rather minimalist approach. We have basic containers and data structures, but you won't find any TCP Socket Code (although that is in the works), Parsers for any kind of dataformat,... in there.
C++ is seldom used for \`web apps\`.
I think that is wrong in the first place. You should never lean towards parallelization first. That's completely against the principles of performance optimization. Converting to C++ first, then you look for parallelization.
In a decade of professional C++ programming, I've run into maybe a dozen bugs caused by slicing, is all I'm saying.
Are you sure? At least sef-swap (which is usually implemented in terms of move) should work.
But why would you even bother with auto if you have an explicit type anyway? Now you're just being deliberately silly. I hope to god that's not actually something you'd write.
true that. what i hope for is that somebody else is struck with the bug first and goes through the trouble to report it. if you implement the algorithms yourself, you are just multiplying the problem. you don't find bugs in the official main line and you have new code that is audited by far less people, because it is your own. in general it sounds like a bad plan to deviate from the standard for minor reasons such as possible incompatability. what reason is there for the overlap constraint on set_intersection? One would assume that it is is never possible for the result to be larger than any of it's inputs. at no point during execution of the algorithm. at first glance it seems like an arbitrary restriction.
What advantage is this supposed to have over regular implementation of an assignment operator?
What it is with software developers and their need to throw insults into any technical help? **"It's actually most likely your problem"** Yes I know that, technically "it's my fault" but the problem is that "make" is fucking awkward. It makes everything even the simplest of things a nightmare. **"It's not going to magically paper over the fact that you don't understand the platform you're developing on"** Yes I DO understand. I understand better than you. I just don't want to deal with this kind of attitude anymore. Your first reaction is to blame me by making up the fact that I can't compile 32-bit shared-libs, which wasn't even true. Then you tell me I don't understand the platform after giving me a false-fact? jeezus. I'll get my help from someone with less attitude thanks.
Not sure what the reason is, but that's what [cppreference](https://en.cppreference.com/w/cpp/algorithm/set_intersection) and the standard says.
I don‚Äôt know about you but I have no idea what the type of that value is off the top of my head. `long`, maybe? Use the appropriate type suffix (and, for all that‚Äôs holy, use thousands separators): auto x = 20'000'000'000L;
&gt;But why would you even bother with auto if you have an explicit type anyway? For all the other advantages that `auto` gives me, foremost syntactic consistency.
The C++ standard actually says that any `X&amp;&amp;` parameters on a function (including the move assignment operator) are allowed to be treated as unique references to that object by the compiler. This actually means it's free to remove `if (this != &amp;other)` checks inside move assignment operators :) This actually makes it impossible to implement a completely safe self-move-assignment
 auto s = std::string{"Hello"sv.substr(1)}; // BETTER ‚Äúbetter‚Äù, because it makes an implicit conversion into an explicit one.
&gt;But I doubt the C++ cast would catch this, too. It does.
You said: &gt; I don't even know how I'd found the version out. I took that to mean you were, like many folk, a developer who primarily worked on other platforms and was just trying to make OSX work to be a good cross-platform citizen. It was not intended as an insult, just an observation of fact. &gt; Your first reaction is to blame me by making up the fact that I can't compile 32-bit shared-libs, which wasn't even true. No, I said: &gt; Static libraries aren't linked. If you were to try and link that library into an executable, you'd have exactly the same problem you are now. Because you are having linker issues and said: &gt; But I know I can compile a static (.a) library just fine Again, just an observation of fact. &gt; I don't need to be treated like a beginner when I understand programming better than you. I have no idea what your expertise level is, and having helped tons of other people with their build problems, I've learned that it's best to work up from the basics, instead of assuming expert-level knowledge and just confusing them. &gt; Yes I DO understand. I understand better than you. But I'm the one with the attitude?
&gt;I don‚Äôt know about you but I have no idea what the type of that value is off the top of my head. That is my point. It's not obvious. &gt;`long`, maybe? Maybe. It's actually implementation defined. &gt;Use the appropriate type suffix &gt; &gt;auto x = 20'000'000'000L; Still implementation defined. If `long` is not big enough the type will be `long long`. &gt;and, for all that‚Äôs holy, use thousands separators Yes, I agree. I was just trying to make it a bit less obvious. ;-)
Is it in the standard that destroying an object twice is undefined behavior?
&gt; a developer who primarily worked on other platforms and was just trying to make OSX work to be a good cross-platform citizen. Nope. Not reasonable. And you can't observe a fact that doesn't exist. &gt; Your first reaction is to blame me by making up the fact that I can't compile 32-bit shared-libs Yes actually you did say that when you said &gt; What version of the OSX SDK are you using? 32-bit isn't supported by default anymore. The OSX SDK is IRRELEVANT. It's just some trivial fucking irrelevant command that needs to be written into a make-file somewhere that doesn't need to be written into a makefile if make were designed properly in the first place! And that irrelevant command won't have anything to do with the OSX SDK version once I find it. You are leading me in entirely the wrong direction and too arrogant to admit to it. &gt;But I'm the one with the attitude? Yes because you can't accept that make is flawed and have to instead blame me by saying **"you don't understand the platform you are developing for"**. JEEZ. The arrogance in that statement.
I like your examples but why not fix the `avg_nanoseconds` function as follows: template &lt;class Duration1, class Duration2&gt; std::chrono::nanoseconds avg_nanoseconds(Duration1 d1, Duration2 d2) { auto ns = d1 + d2; return ns / 2; } ‚Ä¶ of course I‚Äôd rather constrain the subtype of the argument types explicitly, and I‚Äôd probably avoid using an intermediate result here.
I don't think there's a one-size fits all optimal answer to your question. But between type info and no type info, I usually find code easier to read with type info. Without it you get into cases where you MUST have an IDE and a debugger to make heads or tails of a piece of code.
That was my point of creating the function `doThing()`, it's a bad function name and there are some programmers that would create such a function and it would confuse everyone looking at it. And here, the use of `auto` makes it worse, because you know `doThing()` returns something, but what? That was the point I was trying to make.
Yes, destroying twice (without an an-place construction in the middle) is UB. Re what about a no-op destructor, I'm not sure of the formal view, but it's prudent to assume that it will UB also in that case. Because the compiler can do or not do things on the basis of assuming that the formal UB will not occur. No matter how clear it may be to a human what the code's effect would be without the formal rules.
&gt; The OSX SDK is IRRELEVANT. It's not. If you don't have the files, there's no library to link against, and so obviously the symbols wouldn't be there. That's 100% relevant. &gt; You are leading me in entirely the wrong direction and too arrogant to admit to it. I'm trying to establish how you're setup, because I have literally no idea what's on your box, and you didn't provide any of that information. &gt; accept that make is flawed Make is a piece of shit and I would never use it given the chance. By even coming in here and asking these questions, you are making it clear you are not an expert on OSX or CMake. If you were, you wouldn't need help. I don't know what's arrogant about stating that. It's okay to not be an expert in everything. &gt; All I wanted was one simple pointer like "hey... rarlib uses cmake, try that!" No, what you wanted was &gt; a reasonably small cmake file And all the major cross-platform projects that do the things you're looking for aren't small by any definition of the word. That said, go look at the CMake or Clang/LLVM builds if you want to see what full cross-platform support looks like. &gt; You don't understand how to code for MacOSX Didn't say that either, but I wasn't specific either: you're obviously not comfortable outside the XCode environment. There's nothing wrong with that, either. Sorry for any offense I've caused, but I've only been trying to be helpful. Look through my post history. I spend a lot of time trying to help people figure out how to make CMake do what they want. But, you've obviously got a huge chip on your shoulder and I have no need to be insulted either, so have a good day.
This loop is wicked. If you use explicit `size_t` type, the behavior is the same. If you use int, you get a compiler warning (which might at first prompt the programmer to use `size_t` index instead.). So you have to write ugly code with a cast like `for (int i = (int)x.size()-1; ‚Ä¶` and it'd be even uglier with C++-style cast. Unsigned sizes for containers are a one big f*up.
&gt;That is my point. It's not obvious. Then I don‚Äôt understand your question: for non-obvious values, by all means use explicit types (or type suffixes). &gt;Still implementation defined. OK now C++ is just aggravating. But at least a modern compiler gives a clear warning in this case, and that‚Äôs good enough for me (I always compile with `-Werror`).
Never knew that. Thanks!
Please check rule #1 for this subreddit.
For you maybe. There is always a subjective component to readability that depends on what the reader is used to. Personally I don't have a problem with the right to left information flow, because it is just the same way you determine the value of a variable and the cases where you do use auto at all, the variable usually has no other meaning than holding the return value of a function.
Code isn't more readable when it confuses the reader, axiomatically. In some cases, auto improves readability, in some cases it decreases it. I watched the CppCon AAA talk from (IIRC) a Blizzard employee and I consider the end product far less readable than the original code. When people say things like, "Well just hover over the auto in your IDE and it will tell you what type it is!" they're admitting the code is not readable (since the reader needed help figuring out what type it was). That said, there's some clear cases where auto should absolutely be used, such as when you have a dependent type (i.e. the type of one variable depends on another), range based for loops, iterators, etc.
In that case, it's much better to rename `doThing()` that forbid the use of `auto`. It's the same with prefixing all variable with `a` (local), `i` (input), `o` (output) and `io` (input-output). It brings value if the function doesn't fit in a screen, but prevents easy refactoring, and doesn't bring anything if the function is less than 20 lines (since the declaration is already visible). We are using this at $WORK, but I sincerely think, that it's a bad habit that make an ever worse habit less painful.
Given how commonly overloading and template specialization occurs in C++, it is, in general, impossible to know what code is doing without knowing what it's doing it to.
Even if you're using an IDE, having to hover over every variable declaration to figure out WTF is going on is tedious.
Thanks, I think this is the best response I've got. I've always used emacs and its auto-formatting, it's just that one day it struck me I ought to explore the alternative. Anyway, nah, I'll go back to the way it always was!
Ah, ignore me then
Thanks. I got a good advice from a different sub, they were actually helpful instead of telling me that: "you don't know how to code for the platform you've coded for for 20 years... all because you never used make before! And its not as if xcode makes libraries for you and almost no one needs to use make at all and it's kind of a forgotten art, is it? Nooo. Its that your 20 years of coding on MacOSX mean NOTHING.". Yeah. Instead of that I got something useful. If you want to learn how to write useful replies, check this one: https://www.reddit.com/r/cmake/comments/bguv6n/any_good_examples_of_a_cmake_sharedlib_project/ This is a good starting point: https://github.com/robotology/how-to-export-cpp-library See the difference? Nice comment from him = happy response from me Bad comment from that guy on this thread = unhappy response from me. I hope I educated you on some very simple things that you really ought to know and are just pretending you don't know.
&gt; The C++ standard actually says that any X&amp;&amp; parameters on a function (including the move assignment operator) are allowed to be treated as unique references to that object by the compiler. Could you pull the reference for that? I've heard that, but I remember the situation wasn't quite as clear cut as that. &gt; self-move does not have to be a no-op That is clear, but if you have to manually implement move at all, you are usually in resource managment territrory, in which case, self move should at least do something sane and e.g. not leak resources, but either properly release them or be a no-op.
 you could take a look at: https://github.com/aeon-engine/libaeon
Here's how this works: you break the rules, your post gets removed. You break the rules repeatedly, you get banned. You're seriously surprised you got better answer about CMake on the CMake subreddit...? Your post simply doesn't belong here. It's not against you, it's just not what people are subscribed here for. We're not here to answer your questions, nor to get praise (or snarky remarks) from you. Thanks.
&gt;Then I don‚Äôt understand your question: for non-obvious types of values, by all means use explicit types Well, personally I prefer to always be explicit when it comes to integer literals so I just felt a bit uncomfortable with the idea of relying on the implicit type of integer literals and wondered where you draw the line. 0 is obviously obvious and 20'000'000'000 is obviously not obvious, but what about all values in between? For example, is 65'000 obvious? I guess it depends on if you assume that int is 32 bits, which you could do if you're only targeting 32/64-bit systems, but technically and int is only guaranteed to be 16 bits. ‚Äì You don't need to give an answer this. &gt;a modern compiler gives a clear warning in this case I don't see why it would warn, unless it overflows, but that shouldn't be possible here because `long long` is guaranteed to be at least 64 bits which is enough to hold 20'000'000'000.
I entirely agree but I just want to make it clear that nothing of what you said contradicts my arguments. In particular, I‚Äôm *never* arguing against necessary explicitness, and if adding a type annotation helps understanding, it should be used. Again, AA does not say otherwise.
&gt; When code and comments disagree, both are probably wrong.
Just to pacify things a little bit, I'd like to point out that, although make was originally designed as a project management tool, these days it is regarded more as plumbing compared to (c|auto|.\*)make 's porcelain. For this reason I also agree that you are wrong to blame make for your problems, and I think you should have done more of your own research for how to make dynamic libraries with cmake than bother the good people here--there are loads of examples and tutorials.
Yes, alignment has to be the same. What do you mean by *not truly defined* (note that I did not suggest to just cast a char pointer into a pointer into a POD on the receiving side)?
Regarding the suggestion to use \`swap\` to implement move assignment: Note that \`std::swap\` is implemented in terms of move assignment, so unless there is a custom implementation of \`swap\`, there would be infinite recursion.
You‚Äôre right, the compiler only warns on overflow, my mistake. These are definitely situations where an explicit type helps. And for the cases in between, well, know your audience I guess (and the same applies generally, not just in the context of `auto`). 65,000 should be obvious but 65,536 should probably be properly annotated unless you‚Äôre specifically writing with the assumption that your code will never run on 16 bits. These are real potential pitfalls but they predate `auto`.
Try using x in static_assert. GCC simply ignores if you want something to be constexpr, unless it really has to be constexpr.
&gt; What if the destructor simply does nothing? If you mean that the destructor is trivial, then there's probably no reason to not have (implicitly or explicitly) default assignment operators, so it doesn't really matter in this context. But indeed, in the special case that the destructor is trivial, it might be OK to invoke it more than once.
Nb. There is no such thing as "more optimal". Optimal is the best there is (according to some metric).
I agree that they do. The situation seems to be like code managers when CVS was king, and then along came GIT and sorted it all out. Dependency management's GIT moment could happen tomorrow or it might take 20 years... but the solution, once realized, I'm sure will be surprisingly simple.
See article from Eric "Post-Conditions on Self-Move" \[1\] and discussion on reddit \[2\]. &amp;#x200B; \[1\] Post-Conditions on Self-Move: [http://ericniebler.com/2017/03/31/post-conditions-on-self-move/](http://ericniebler.com/2017/03/31/post-conditions-on-self-move/) \[2\] reddit: [https://www.reddit.com/r/cpp/comments/62msre/eric\_niebler\_postconditions\_on\_selfmove/](https://www.reddit.com/r/cpp/comments/62msre/eric_niebler_postconditions_on_selfmove/)
Then say it this way. Also, you are omitting the conversion issue. In my admittedly longer C++ experience (my first C++ compiler was called ‚Äòcfront‚Äô), I have seen quite a lot of conversion errors, in particular when refactoring large code bases. I am surprised you did not.
Julia: 2012. Python: 1991. Matlab: 1984. The people teaching scientists the programs we are using when prototyping have just shifted from Matlab to python. So give it 20-odd years and Julia might matter. C/C++ is used by a small sub-group in my field, with Fortran still king for at least the next few decades imho. Conservative opinions matters in fields with experiments costs hundreds of millions to a few billions of Euros. So C/C++ is still valid in scientist speak, since we are at about 1999 still. (Really, the code is C with custom Matrix and Tensor classes since the past 20 years, which is why I want the LinAlg proposal to pass but with support for the Fortran LaPack-interface included so it is close to current practice.)
This variant is much better readable IMO.
https://twitter.com/meetingcpp/status/994232604898377728 and a thread: https://twitter.com/tvaneerd/status/1120378212658192384
Conversion tends to be a perf issue mostly in my experience. I've fixed plenty of those, including a gnarly 200+ file refactor after changing a constructor to explicit. But still, it's not really my biggest problem. Reading code absolutely is.
I find my own evolution of preference in that regard interesting. At first I also only used auto to avoid typing out complex types and when the right hand side made the type obvious or caused a lot of repetition. The longer I use it the more I gravitate towards the almost-always-auto form, because I see a great legibility benefit in having the type and its initializer next to each other instead of having to parse a kid not infix notation. This becomes especially relevant when writing things like `constexpr auto const my_constant = MyTemplate&lt;MyType&gt;{...}`
The thing that kills me about so much of this "anti-OOP, let's go procedural" stuff is that, if it was some sort of new and untried thing I'd be all for let's try it and see what happens. But we already tried it and we already saw what happened. It's not some modern hipster magic, it's like wearing spandex and eye shadow and playing a DX7, it's 1980s stuff. A lot of us grew up on procedural code, so we spent a lot of time and effort learning it. But most of us also ran away from it screaming as soon as possible, despite the fact that, having grown up with it, if anything we'd have been resistant to leaving it and very resistant to the very different world of OOP. But most of us were glad to leave BECAUSE IT SUCKED. We didn't get our opinions about that from reading an article from some industry talking head or watching Youtube videos. We LIVED that world professionally doing serious software. And it wasn't good. When I see people now arguing that it's now a bad thing to encapsulate the intelligence about a data structure with the data itself, or that being able to polymorphically manage a class of data structures should be abandoned, I feel like maybe I took one too many hits of acid back in the 70s and it's caught up to me now.
Just tried - works as expected, no compilation error when used with `int`, assert violation when used with `char`.
That's true, thanks.
If you have a getter that returns a non-const reference, and you think that that is correct, you have way bigger problems than auto. I'm just tired of people making arguments with contrived and stupid examples. It's just like the university professors with their shape class hierarchy. If you think that something might be bad, and all you can think of is a stupid example, then maybe it's not so bad after all.
I find I'm not bothered by inconsistent indentation at all. also, there are a lot more columns than 80. Unless of course you are still on a VT100 terminal, in which case, I'm so, so sorry for you.
&gt; Will probably take another 10 years to get those parallelziation abstractions completely correct so that it does not matter anymore where your code actually runs (cpu/gpu/remote cpu or gpu) as long as it has the required input data. [Legion](https://legion.stanford.edu/) and its associated programming language [Regent](http://regent-lang.org/) do this already.
Being available for different languages beats being really good for one, IMHO.
Or you could use an "overload" class with lamdas: template&lt;class... Ts&gt; struct overloaded : Ts... { using Ts::operator()...; }; template&lt;class... Ts&gt; overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;; overloaded { [](auto arg) { std::cout &lt;&lt; arg &lt;&lt; ' '; }, [](double arg) { std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; ' '; }, [](const std::string&amp; arg) { std::cout &lt;&lt; std::quoted(arg) &lt;&lt; ' '; } }(parameter) ;
For many scientific applications, the libraries in Python are good enough that the slowdown would be closer to 1.5x. At that point, running stuff in parallel is much less work than rewriting your entire code base.
1. Homogeneous setup: you can use packed representation and explicit on-wire endianness; if you have accessors rather than raw access to data-members, it's really easy. 2. Safe extension: you can use a version/size field on all messages, indicating how many bits/bytes are used on the wire, and disabling access to some data-members. 3. Variable-length data: tougher one, but solvable. Restricting them to "tail" data-members makes things easier. 4. Checksums: a simple read/write template function can handle pre/post steps such as swapping bytes and fixing/checking checkums. If you have not already, I advise looking at the SBE protocol. It's relatively easy to setup a straightforward decoding and encoding process which just bit-copies structs around, and it supports all the above.
C++ `std::thread`?
`auto` only really works well if you have a tool that can tell you the concrete type (IDE, LSP server). You want to enjoy the benefits of strong typing. One benefit is that the compiler uses types to enforce things. The other benefit is that you should be able to know the type of variables. If the compiler doesn't have a way of communicating that to you, you miss half the of what strong typing has to offer. I'm looking forward to one day go `View-&gt;Show types`, and have all variables adorned with their concrete types. I'm also looking forward to one day having smart diff tools that interact with LSP servers, and show types. I'm also looking forward to one day having late auto as in `auto x; if (y) {x = f();}`.
Every in \`std::\` is bad, mkay? Never use it. Never include butchered C headers such as \`&lt;cstdio&gt;\`, use proper C headers such as \`&lt;stdio.h&gt;\`. We have our own standard library that is obviously better. Our \`string\` is just a typedef for \`char\[156\]\`.
where do you try to execute it? IDE? have you compiled it? What the compailer says?
There is necessarily a custom implementation of `swap` for a user-defined class that uses it to implement its other parts.
It also accepts tabs.
and why would I do that, this clearly goes against my esthetic standard... no, I'll have `auto overloadable_lambda = [](auto &amp;&amp;arg) {` `if constexpr(isinstance(arg, double))` `std::cout &lt;&lt; std::fixed &lt;&lt; arg &lt;&lt; ' ';` `else if constexpr(isinstance(arg, std::string))` `std::cout &lt;&lt; std::quoted(arg) &lt;&lt; ' ';` `else` `std::cout &lt;&lt; arg &lt;&lt; ' ';` `};` thank you.
Disable the real-time static analysis (clang-tidy and clazy) in the code model settings.
When I'm considering to either use scripting language or not, the main goal personally for me is to be able to quickly iterate development-test loop and try things without too much effort like waiting for project recompilation. I'm a software developer. But if my main goal was to give an ability to change program logic for non-developer, it is absolutely different thing, and here scripting language is best fit. Personally I prefer to not complicate my solutions with one more programming language or some cling-like solutions with heavy dependencies (like clang). I'm totally comfortable with c++. So if your main goal is to quickly iterate over development loop, you can try [jet-live](https://github.com/ddovod/jet-live) or [blink](https://github.com/crosire/blink), it really speeds up things (I'm using jet-live on my primary work, gamedev projects).
You include a specific experimental header such as `&lt;experimental/filesystem&gt;` for Filesystem TS. I would assume all the stuff in Audio TS would go in `&lt;experimental/audio&gt;`.
I'm not suggesting that no code base uses it. I'm querying whether it is commonly taught as best practice. Also, using exceptions for error handling is not the same as using them for flow control. If the error conditions never happen, then the performance hit when they happen doesn't matter. I've never seen anyone seriously use `std::vector&lt;&gt;::at()` for flow control.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bgxtoq/it_says_the_system_cannot_find_the_file_specified/eloddml/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
1. The terminology "script" is generally for interpreted languages, where tasks are at the macro level (move a file here, download a file there, parse this csv, run this other file). 2. That sounds like a bash command line error, not an executable runtime error.
type info is sooo fucking important... if you don't know what something is right off the bat, then you'll spend possibly hours (considering a big javascript codebase f.ex.) figuring out what it is. Instead of having it written out right before you
Agreed, that aspect by itself beats typedef.
I think at the point you have what is described you basically have a full blown serialisation system, just one with a clear approach to efficient serialization (flatbuffers is another system with a similar approach). Thus is still a lot more than just memcpying the struts you have about.
Okay I have ran this through compiler explorer. &amp;#x200B; [https://godbolt.org/z/ChvtCf](https://godbolt.org/z/ChvtCf) &amp;#x200B; Here with the relevant highlight, just for you: [https://pasteboard.co/IbEGmWJ.png](https://pasteboard.co/IbEGmWJ.png) &amp;#x200B; Does that get my point across?
Technically using swap in move assignment is suboptimal for at least two reasons: \- Indeed, swap will move other into \*this, which is good, but it will also move \*this into other, which is just a redundant work. \- \*this could own a huge chunk of memory (say, a vector of something), if moved into other it will stay there for who knows how much longer instead of being freed instantly.
Indeed; that's the point I'm highlighting. Although, \`std::swap\` can technically be used to implement copying if there is a custom implementation for moving.
I think it is very reasonable. If I have a function taking an optional and I call value() somewhere at the beginning why should I bother with overhead the next 20 times I access that value?
&gt; This is still a lot more than just memcpying the structs you have about. A tad more, indeed. What I like about it is that it remains pretty simple yet efficient setup: - You don't need any code-gen step: just write your structs/classes in a certain way, done. - No performance overhead over memcpying structs, because you're just memcpying structs. Of course, it fails the OP's requirement of interacting with existing protocols, since it's a protocol. But simple, efficient and flexible enough for about any kind of protocol? That's great.
If it's impossible to read the code then how do people manage to use it so much?
that's why we should use the macro here, it is guaranteed to work for any compiler (that supports modern cpp of course) under any situation. I don't understand the irrational hostility toward macros that a lot of people here have. If a feature gets things done right and nicely, USE IT for gods sake.
I implemented standard c++ strings instead of char arrays and I'm using std::unordered\_map instead of a homemade Hash table, there is no direct memory management, the only direct array access is inside a for loop where I know the size of the vector I'm iterating through, I'm initializing all memory, and now I'm not stack allocating any memory. I fixed all the problems you mentioned. I'm still going to reduce verbosity soon.
&gt; but you probably underestimate amount of devs with these habits and amount of code they write you use. I'm not trying to comment on how often it happens. Regardless of how often it happens it's not good c++ and I don't think we can talk about the safety of the language unless we assume ppl are going to actually try to use the language correctly. &gt;I belive we do have that. Using tooling and writing right code is much harder than just have a compiler that supports all your intents. Just to clarify, I am saying we don't have that in c++. We don't have the complier to handle everything, but I say that's okay with tooling filling in the gaps. Yes it's not ideal, but I honestly think it's close enough for practical purposes. In reality, it's just one extra build in my continuous integration so it's not an inconvenience for me. &gt; some of them are specifically out of bounds/null dereference/double free and all sort of things That's the thing, I really insist that proper c++ usage will prevent all of those almost entirely. Of course no system is 100% secure and every program will have bugs, but those memory type errors are almost non existent if you code correctly and use tooling. &gt; it's really hard to spot memory issues Outside of really obscure things that you likely can't avoid anyway regardless of language choice or whatever, I would say no it's really not. Memcheck literally checks every bit of your program, and a vast majority of what you write in c++ should be memory safe by default if you care about what you're doing. I really don't see the difficulty, I just see people not knowing how to use c++ or even worse insisting on using c++ the wrong way.
not good people. Bye.
thanks :) I'll see what they are doing!
There are several design mistakes in `avg_nanoseconds`, and thus several ways to improve it. But I was trying to focus in on the fact that the "always auto" mantra can lead to the use of explicit conversion syntax. And that explicit conversion syntax can be dangerous to use in cases where implicit conversion syntax would get the job done. Here's another such example: auto f(shared_ptr&lt;Derived&gt; p) { // lots of code (too much really)‚Ä¶ auto bp = shared_ptr&lt;Base&gt;{p}; // more code‚Ä¶ } The conversion from `shared_ptr&lt;Derived&gt;` to `shared_ptr&lt;Base&gt;` should be implicit, but the coder has followed "always auto" and that pushed him to use explicit syntax. Now imagine that under maintenance, the function parameter is changed to `Derived*`: auto f(Derived* p) { // lots of code (too much really)‚Ä¶ auto bp = shared_ptr&lt;Base&gt;{p}; // more code‚Ä¶ } The line in question still compiles but silently changes meaning. To guard against this happening, the original code should be changed to: auto f(shared_ptr&lt;Derived&gt; p) { // lots of code (too much really)‚Ä¶ shared_ptr&lt;Base&gt; bp = p; // more code‚Ä¶ } Now if under maintenance `p` suddenly doesn't *implicitly* convert to `shared_ptr&lt;Base&gt;` it will be a compile-time error. Of course a better way to fix `f` would be to shorten it. But we program in a real and complex world, and so it is best to belts *and* suspenders everywhere we can think of in order to make our code more robust in the face of future errors introduced over the long lifetime of code. To be fair, I *like* `auto`, and use it a lot. But "always auto" is not a good policy for robust code.
&gt; Consistent formatting removes visual noise. I waffle on this point... but as a counterpoint, I don't think you can just dismiss whitespace as visual noise. There's a Kevlin Henney quote from a talk he gave that I couldn't turn up in a couple quick searches that's something along the lines of "the bandwidth that you have available to communicate to other programmers via your code is actually quite narrow, so you ought to make as best use of it as you can; and whitespace is part of the *message* you can convey." For example, I know that this appears to be an unpopular opinion (at least unpopular enough that "don't align things" is a common rule), but to make up some kind of crappy code, I would much rather see move_to(x, y) draw_to(x, y+h) draw_to(x+w, y+h) draw_to(x+w, y) draw_to(x, y) than move_to(x, y) draw_to(x, y+h) draw_to(x+w, y+h) draw_to(x+w, y) draw_to(x, y) The former does multiple things, all centering around the ability to easily pick out both the similarities and differences between the lines. First, it makes it more obvious that they are all related in some way. Then, it makes more obvious that the `x` and `y` are the same cross lines. Then, it shows you what *differs* between the lines -- sometimes you have `+w`, sometimes you have `+h`. And in other cases, I assert it can make it much, much easier to spot copy and past errors. I think may takeaway is something like 95% of the time, an autoformatter would work perfectly and improve things a *little* bit, but 5% of the time it makes things worse and a fair portion of *that* by a *much* wider margin. (Note: I'm not exactly talking about sort of "local" use by you of autoformatting in your editor at your command in those 95% of times, but more like some policy that says that the entire code base is run through it and must match or something like that.) There are some edge cases (e.g. I've made "tables" in code made from array literals) that can be obviously protected by "don't format this" markers, but sometimes whitespace that I'd call important might be as subtle as where the line break in a line goes. For example, suppose I have two successive lines in the source code that both output stuff to standard output with kinda similar structure to their messages. I'm more hesitant to put a line break in them than if the line was there on its own, because again I think you *get* something from more easily seeing how the two lines compare. On the other hand, I actually kind of have this neat dream of a project where you could do something like when you check out a local copy you can run your own personal formatter for it that lays it out just the way you want, and then when you commit it formats it back to some standardized format. :-) But I don't know which of those wins out -- the common small case or the rare large case? Popular opinion seems to be pro-formatter, but I've not yet joined y'all fully. :-)
`std::function` is an incredibly expensive approach to being more informative.
What‚Äôs your point? Just turn off the formatted locally, as you said.
That's not how English works. You're wrong. If you think you're right then show me the authority that issues the definitions of words and their perfectly defined unchanging definition of the word Optimal.
Make me an automatic formatter that does this and I'll consider trying it. I kind of like the idea but after using automatic formatting for a while there is *no way* I am going back to manual.
And based on codebases I've worked in: No one does.
I like that answer.
Inconsistent formatting can give you code that looks like this: if (i == 3); j=2; It's a hell. Also I had inconsistent line endings which made the compiler print the wrong line numbers for errors.
You remember that my comment was about auto in conjunction with std::make_unique? In that case you are not destroying any more information than in the iterator case.
&gt;I'm also looking forward to one day having late auto as in `auto x; if (y) {x = f();}` Would it be the same as `decltype(f()) x; if (y) {x = f();}` ?
To be absolutely clear, I wasn't talking about this sort of inconsistency. I totally wouldn't write code like that. I was only referring to the overall indentation of complete code blocks, i.e. move away from the strict 2-spaces or 4-spaces rule.
People have distrust towards macros for good reason. They disrespect scopes (be it class, namespace or function scope), and they are not that easy to get right - because they are nothing but textual substitutions and thus calling context sensitive. They also make error reporting less informative. I still remember my pain during my very early days of Windows programming when I was trying to do a class which would have a GetWindowText member function in it and compiler showed me a completely incomprehensible message which I finally deciphered, and the reason was that GetWindowText was a macro defined in windows header. Because C++ made such a progress towards world without macro, a knee-jerk reaction of any macro introduced is - "can it be done without it".
[String literals are stored in static memory](https://stackoverflow.com/questions/349025/is-a-string-literal-in-c-created-in-static-memory) within the actual binary itself. Replace the string literal with int * variable = new int[500]; int variable[500]; and you'll see that the heap allocation will request memory while the stack allocation will simply shift the stack pointer.
Great, now fix the task list please
C++ made the choice to implement arguably too much (for my taste) in templates, and not enough in the core language, in particular for subjects like variant, optional, etc. That is still a respectable choice, especially given the history of the language, but I will not let it transform into a free pass to be considered as secondary and merely an "API" issue. Well of course it is, but the API we are talking about is specified in the very same standard as the core language is, and will be used by most C++ programmers, so it better should be of the same level of quality. I would stay that when we talk about the C++ language, that includes the standard library.
Because C++ compilers are good enough to optimize away the 20 other checks.
Take a look at http://greenlab.di.uminho.pt/wp-content/uploads/2017/09/paperSLE.pdf
If a feature is likely to produce unexpected behaviors, then it should be used with care, and if you're sure that ur usage is not gonna lead to some weird failures, then I don't see the problem here. People should not stop using something simply because it has to be used with care, especially that the functionality of macros cannot even be fully implemented by other "safer" options like templates, like the situation we're talking about
This is why I don't like this language anymore.
Yea, pretty much. It would remove the reference-ness from a type though, because it's `auto`. It would require all assignments in every branch to have the same `auto` type.
Just wait 4 more years to be told that reflexpr won't make it to C++23
You don't suppose it's possible that people are just disagreeing with the statement that most C++ code is written by people who aren't familiar with the language? Maybe people aren't touchy; maybe it's just a silly thing to say.
The rvalue argument to the move assignment operator, is by assumption a temporary. Moving into it has the effect of guaranteeing freeing of resources, via that temporary's destructor invocation. I haven't encountered a case where there was a problem with that expression not denoting a temporary and holding on to precious resource longer than necessary. So I think fixing that (by moving to a local variable) would generally be premature optimization. But if **measurements** show that this is a critical bottleneck in some code, then such move-to-local optimization would be one possible cure.
No, because the nature of the responses is more along the lines of "you're a programmer if you believe in yourself!"
I didn't find the paper you gave, which compares computer languages for energe efficiency, has anything do regarding language safety as you suggested in your previous comment. Also, for std::map and std::unordered_map your were talking about library implementation instead of language features, so it's also irrelevant.
Then your limited experience is insufficient to understand.
Using my own C++ Runtype Type Reflection library - see my own post: [https://www.reddit.com/r/cpp/comments/bg29qb/c\_as\_a\_scripting\_language\_c\_runtime\_type/](https://www.reddit.com/r/cpp/comments/bg29qb/c_as_a_scripting_language_c_runtime_type/) It's possible to achieve to xml or any other string format serialization without generating any code whatsoever. Serialization functions are recursive call, which produces required data. I haven't studied how to achieve binary serialization, also my own library has some windows specific code (E.g. CString class), but I doubt it would be difficult to cross port it to another OS / embedded system, also adapt it for binary needs. Let me know if you need some assistance, I can help as well.
&gt; multithreaded data caching Is there a description of what this algorithm is attempting to do? Is it adding to/searching through a linked list that is a "cache of data"?
while you're here, do you have any advice on getting robinhood hash to work with something like Cereal or Boost::Serialize? I'd really like to swap in robinhood but can't figure out how to get Cereal to serialize it
I just went through this in another thread. I think recommending CAS without mentioning the very significant caveats for it is not good: 1. It provides strong exception safety, which users almost never need. 2. If users do need strong exception safety, they can actually simply write a generic 2 line CAS with the strong guarantee, and use that. 3. The performance is sub-optimal, for many types it is *heavily* sub-optimal, and users have no way to recover this performance. Even if your type doesn't seem to have anything obvious that's sub-optimal, if your type has e.g. vector, string etc, members, this approach will also result in heavily sub-optimal performance. So, CAS can only really be justified by having users that are desperate for strong exception safety but can't be trusted to call a generic function to do it (basically, a non-existent use case), or, a slight decrease in somewhat-duplicated code. If you are following the rule of zero, you should anyhow heavily be "pushing down" logic like this and classes that need to have these members implemented should be quite small and rare. I would not wait to benchmark before implementing something sub-optimally for such small benefit (taking this approach everywhere in your codebase will just lead to "death by a thousand papercuts" performance issues). Not to mention, that once you actually explicitly document/guarantee strong exception safety, it's an API break to drop it (e.g. for performance reasons). And if you don't, users will still want to use their own implementation. In addition, unified assignment operator as written is very questionable, because you aren't offering noexcept move assignment, which most types should have. You can mark unified assignment operator noexcept, and its actually technically correct, but it's kind of bizarre and misleading. So I think unified assignment operator isn't a great choice anyway. I wouldn't say "never use CAS for copy assignment". But, almost never. If you need to write out your special member functions, just do it properly for each, and just use the generic swap. If you prefer reference to authority, here's Howard Hinnant saying pretty much the exact same stuff: &gt; Warning: The copy/swap idiom is used far more frequently than it is useful. It is often harmful to performance when a strong exception safety guarantee is not needed from copy assignment. And when strong exception safety is needed for copy assignment, it is easily provided by a short generic function, in addition to a much faster copy assignment operator. See slideshare.net/ripplelabs/howard-hinnant-accu2014 slides 43 - 53. Summary: copy/swap is a useful tool in the toolbox. But it has been over-marketed and subsequently has often been abused. https://stackoverflow.com/questions/24014130/should-the-copy-and-swap-idiom-become-the-copy-and-move-idiom-in-c11. https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom
This continues to propagate in other threads, so I wrote a response elsewhere you might find useful: https://www.reddit.com/r/cpp/comments/bgv9mt/implementing_assignment_operators_with_destructor/elotmcy?utm_source=share&amp;utm_medium=web2x
Besides this there exists also: C++ runtime compiled [https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus) &amp;#x200B; but I wanted also take a dive into project generation tool as well. I have used cmake by myself once upon a time, and find it quite grotesque to use. You always either need to learn second programming language (python, julia, lua, cmake odd syntax) - want to get rid of it. Only native C++, nothing else. Thanks for links, I will definitely check them out. I was planning to create Visual studio extension for supporting C++ hotreload - initially prototyped already, but haven't yet recombined into working solution. Only prototyped with C# hotreload.
Yours is relatively innocent macro, but it also has relatively low value added. For example, change your example function from `auto f(auto p)` to `template&lt;class T&gt; auto f(T p)` and you can use `std::is_same` right away with `T`. If you are one of the AAA folks, add `using arg_t = std::decay_t&lt;decltype(p)` and use this `arg_t` later down the road. In my view, the drawback of injecting a token into everything I have in my code is not justified by the minor benefit. I personally believe there are very few scenarios where you need a macro, and your case is not one of them.
This is fantastic, the new CMake project functionality in VS is great already - working directly with a CMake project (without having to actually run cmake) with automagic Ninja building really is a stroke of genius. Now with Clang support for the best of both worlds of build options. Nice work!
I understand, you make a good point. Still, for reasons of uniformity (and also because this is otherwise such odd code) I‚Äôd really like to rescue the use of `auto` here. It would be great if C++ had a (built-in) explicit way of invoking an implicit conversion. I should probably know this but I can‚Äôt off the top of my head think of a way of writing this (nor find it with a cursory search). std::forward could be abused for this but I worry that its use here would be misleading.
Ok I'll say the forbidden word: Rust is that "new" language in town "everybody" is talking about (or even... using! madlads!) and is well known for having a cool approach to lifetimes, and not much tolerance to the potentiality for UB in case of programming errors outside of unsafe sections explicitly tagged as such. Including in presence of threads. But all of that would be of much less value, IF, at the same time, it did not managed to do it with an extremely good efficiency AND without a GC AND with a lean runtime (comparable to a libc or shared part of a lib c++) While I'm convinced by the approach, and even more by the underlying philosophy (that in some points goes 180¬∞ against the historical C++ culture of allowing programmers to shot themselves in the foot), I humbly admit I did not do an extensive review of the publications on overall safety, and at the same time I will be both astonished and of course extremely interested if the result for Rust are poor. For the time being I'm happy with my approach of making the hypothesis that, the design looking sound for me and even for people way smarter than I am, UB are mostly eliminated. On the other hand, I remember that recent reviews found that ~30% to more than 50% of vulnerabilities in unsafe languages were due to UB. As for the theory that the standard library is not part of a programming language, I respectfully disagree with vigor, especially when both an international standard and I would even say most of the practicing community tend to use the meaning that it is indeed part of, and when the core language coevolve extremely strongly with its standard library. Yes you can use the core language alone, BUT that is not the general case, nor a situation that would yield to a useful component ecosystem if everybody did that without any restraint, and also you would even miss really basic types because C++ chose the STL route for them (optional, variant, ...).
This is a rather poor example imho. The real violation is to naming a variable and method like this. It the variable is called 'firstName' and the method 'trimTrailingSpaces()', why write out the type 'std::string'?
Does this mean we can write fully compliant C99 code in Visual Studio finally?
Luckily there's a compiler warning to catch this.
&gt;by assumption a temporary Maybe, maybe not. We can't be sure as long as std::move exists.
Funny, i have a very similar background. I just enrolled. What most other comments miss with just buy a book and check stackoverflow is that this course gives an up to date and well design training over 5 months. This can't be compared with self research where one can get lost in so many paths. Sure self learning is a good skill to aquire but it takes so much more time specially on subject like c++ programming.
You can write fully compliant C99 code for Windows, macOS and Linux using clang/clang-cl today. LLVM does not depend on Visual Studio.
&gt; It provides strong exception safety, which users almost never need. As I see it that's a highly dubious and misleading assertion. Correctness, such as here not leaving an object in a state with indeterminate values or one that doesn't satisfy the class invariant, is the most valuable property of software. When one ditches the correctness requirement anything can be made *arbitrarily* fast. E.g. one can then let assignment just be a no-op doing nothing. But the focus on micro-performance as good, and correctness as not needed, is, as I see it, very questionable. As a first rule of optimization, don't. Second rule, **measure** before diving in with optimizations, especially ones that ditch correctness guarantees.
That's a different case.
Even without subclasses, this is UB because it ends the lifetime of the "object" (in the language sense), but references to the old object still exist.
People do use var, but it's officially not recommended. auto is really rather uncommon in practice in my experience. Writers and academics like it, working programmers rarely do.
I'd argue that it's not "never do this" or "usually do this" but "look at the wider context before you judge". You say "That situation is pretty rare in most problem domains", but I don't believe this to be the case. C++ has a primary role in domains where performance is crucial. Operating Systems, Games, Embedded, Scientific, Banking, HFT and Medical applications are HUGE domains where C++ is widely used. I'd argue that if you're not in a performance critical domain, then you'd probably want to pick a higher level language than C++. &amp;#x200B; FWIW, I've made a career working in C++ across those domains. Knowing the difference between Heap/Stack is something we consider a 101 skill when hiring/training.
Both of the problems discussed apply to the code in this question.
&gt; Correctness, such as here not leaving an object in a state with indeterminate values or one that doesn't satisfy the class invariant, is the most valuable property of software. When one ditches the correctness requirement anything can be made arbitrarily fast. E.g. one can then let assignment just be a no-op doing nothing. Weak exception safety guarantee does leave objects in valid states, that obey their invariants. So it's still correct; resources get cleaned up, the object can be queried, etc. The question is whether you need the object to be in precisely the same state as before the operation. In most cases, the answer is no, and in many cases, it's not even practical to provide. And as I already said, users that need strong exception safety can easily implement it on top. They can't speed up the copy assignment operator. So you are providing a strictly worse product to downstream users. No "correctness" is being ditched; I'm not advocating writing no-ops, just correct copy assignments with a weaker guarantee and better performance. &gt; But the focus on micro-performance as good, and correctness as not needed, is, as I see it, very questionable. As a first rule of optimization, don't. Second rule, measure before diving in with optimizations, especially ones that ditch correctness guarantees. Again, it's not more correct, just a stronger guarantee. I think there is some confusion here about what "correctness" actually means. If those are your rules for optimization, then I think you just don't need to write very optimized code. Like everything in engineering, how to write your code is a trade-off. If I can get better performance for almost no cost, I'll generally do that. Doing otherwise, as I already said, tends to leave codebases in a state where the "slowness" is smeared out all over the place and its hard to get into a good state. This has been discussed specifically by people in charge of large codebases e.g. Chandler Carruth. These mythical codebases where you just happily write naive code, benchmark, and find that 90% of the cost is in a single 100 line function, are just that; mythical.
I appreciate your lengthy and detail reply. I have to say that it looks like we are not talking exactly about the same thing. And admittedly I'm not familiar with Rust, so I cannot comment on that either. Anyway, my point is, C++ made the choice to prefer performance over safety due to many reasons, including historical constraints, and it is still going strong after nearly 40 years. Maybe Rust is better as you suggested, but only time will tell.
I'm surprised nobody has mentioned the self-assignment issue. Say you have Foo x; ... x=x; //maybe in a call stack 10 layers deep where you got the same object in two parameters, maybe in some sorting algorithm, whatever. Your code would basically destroy x and then copy construct from it. This is likely going to go very wrong. You could first compare addresses of this and foo, but then you're slowing the common case for a rare case. And so forth. In general not a great pattern to follow
Based on a quick reading, so I'm not confident I've got this quite right. As far as I can tell, it uses an extra N of space (but it might be 2N?). It appears to sort things into runs, where it can append to the front or back of a run, and a new run is made when it would need to insert into the middle of a run. Then later, it merges the runs.
No ‚Äúbig picture‚Äù thinking ability basically.
Yes, I'm aware of this! However, I have zero intention of putting it to the test. As for previous versions, the entire world is going to be rebuilt for each version to avoid any doubt. Reading https://devblogs.microsoft.com/cppblog/cpp-binary-compatibility-and-pain-free-upgrades-to-visual-studio-2019/ it sounds very much like the VS2019 linker will be happy to link v140, v141 and v142 libraries. However, there's nothing said about the reverse, which leaves me with the strong suspicion that it would fail horribly. It's for this lack of clarity that I prefer to provide libraries for each version.
What c++ std.lib will be used?
And it would be nice if installer indicates what version of Clang is available (7? 8?)
I had to maintain my own setup for this. I'm really grateful this got in.
Another difference is in the default inheritance: public for structs and private for classes.
TBB is probably closest thing - is yours better/different/how ?
Has anyone else seen extremely slow loading of cmake files from within recent versions of vs? Our team would really love to use the ninja based native cmake support but it takes about an hour for vs to fully load up our cmake projects (which aren't _that_ extremely large or complex, in the grander scheme of things with roughly 2000 cpp files). Once loaded it seems to work well. Because of this we are still generating sln and proj targets via cmake and loading those within vs. This is ok, but for example we can't now use clang as the compiler. And ninja is just so much quicker and more efficient than msbuild.
Thanks for the comment. Your reading is correct. &amp;#x200B; \&gt;it uses an extra N of space yes. It is not 2N.
&gt; The question is whether you need the object to be in precisely the same state as before the operation. In most cases, the answer is no, and in many cases, it's not even practical to provide This is where you need to provide concrete examples to make the case there is at least one situation where an assignment operator can be made significantly more efficient (e.g., avoiding a dynamic allocation) by offering only the weak guarantee.
It would be informative if you could rerun your clang tests with `-stdlib=libc++`.
You mean by reusing existing capacity? For something like `vector`, the only way to get the strong guarantee is copy and swap, which always allocates. But if the capacity of the target is at least as much as the capacity of the source, then obviously you already have all the memory you need and shouldn't need more. So yes, the strong guarantee would force you to make an unnecessary memory allocation. cppreference actually doesn't even list vector copy assignment as making the basic guarantee; I don't know if that's because its implicit or because allocator shenanigans can get so crazy that even the weak guarantee cannot be offered, or something else I hadn't considered. With string this isn't the case because its storing trivial objects which are guaranteed not to throw on copy. So providing the strong guarantee is free, so it does. Pretty much any generic element "capacity" oriented container is going to have this issue so it's not exactly a very niche example.
There's one case where this is AFAIK the only method: Changing the type of an existing object. As long as they have a common base class, the vtable will be compatible, so yay!
 template &lt;class To, class From&gt; To implicit_cast(From&amp;&amp; from) { return std::forward&lt;From&gt;(from); } If you prefer you could restrict `From` with `is_convertible&lt;From, To&gt;{}`. This would just change the error message a bit, not sure it is worth it.
thank you for the advice! I'll give it a try.
"These toolsets will use Clang in clang-cl mode by default on Windows and link with the Microsoft STL."
The thing is, we have the same problem with OOP in general, and while there are some complaints, the use of a base class and virtual functions isn't nearly as hotly contested.
I think it's hit and miss. Sometimes it's helpful, sometimes it's not. Enough that for me it's a wash.
Oh I don't think people \*should\* use those macros I posted. I just wrote about some ideas I found interesting. Personally I use the macros in my own code and liked some properties I observed. That's it.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bh1xi9/c17_memory_allocation_problem/elpebn2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/bh1i76/how_to_use_qt_in_clion/elpecce/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
We write code without knowing the types all the time. Virtual functions is one example, but no one complains this much about them. In my experience, we often end up with tons of code that looks like Phonebook* phonebook = db.get_phonebook(); Person* person = phonebook-&gt;get_person(name); *Tons* Is that really better than auto phonebook = db.get_phonebook(); auto person = phonebook-&gt;get_person(); People also don't complain if I write it like; db.get_phonebook()-&gt;get_person(name); Literally type info there, yet it's perfectly easy to understand. Yes, these are simple examples, but really, look around, you don't know the type nearly as much as you think.
Your English is great. The ColoredPoint example does not have the kind of issue you suggested. There‚Äôs no contract in Point type or ColoredPoint to violate. LSP is about flawless substitution in a fixed context, e.g. being able to replace Point with ColoredPoint and have all the Point operations hold ... and that works because ColoredPoint is ‚Äúa Point and more‚Äù and we can ignore the ‚Äúmore‚Äù in a Point-only context. If we change the Point aspect of the ColoredPoint while in Point-only context, it‚Äôll still be a valid ColoredPoint. In a Point-only context, a==b from the above examples. Stepping outside the Point-only context, LSP of Point class comparisons is irrelevant to ColoredPoint context comparisons and a ~= b. If you create contracts in subclasses which essentially guarantee that you will raise an exception, invalidate an invariant (fixed size? Sorted?), violate LSP or whatever ... that‚Äôs just bad program design (eg making a derived class which can‚Äôt possibly maintain LSP). There‚Äôs nothing subtle or deep about it, once you realize, you just have to change the design ‚Äî drop inheritance, drop the approach to expressing or ‚Äúmaintaining‚Äù the invariant, whatever.
&gt;multithreaded data caching &amp;#x200B; See testcase2.cpp and testcase1.cpp ‚Äî this is an example how to use it in threads for insert and search: ```c++ //Prepare insert threads: for (i = cnt_insert_threads; i; --i) { std::promise&lt;InsertResults&gt; prom; fut_insert_results.emplace_back(prom.get_future()); threads.emplace_back(std::thread (&amp;TestCase2::insert_in_thread, this, curSize, std::move(prom), p_tester)); } // for insert //Prepare find threads: for (i = cnt_find_threads; i; --i) { std::packaged_task&lt;FindResults(TestCase2 *i, int, IAlgorithmTester *)&gt; ta( [](TestCase2 *i, int count, IAlgorithmTester *p_tester){ return i-&gt;find_in_thread(count, p_tester); }); ```
I think if you ask malloc people what group is pushing C++ they would say it is the academics as well.
Been there, done that, the only problem is that pedantic nitwit is the one who will spend the time to configure it for what he can. Some of the worst coding standards are often not linterable. Things like the SubjectVerbObject ordering for function names. Or the rule about using a double underscore to show __member variables. Or you have some hungarian notation nitwit around.
That is a live or die interview question for me. If you think long winded carefully formatted comments all over the place are a good thing the interview is over. To me comments are kind of like road signs with warnings. If you are driving along and there are 300 per mile saying things like "driving with the music too loud can damage your hearing" you will miss the one that says the bridge is out.
Wow, 1h is way outside the range of what we've seen yet for a first-time scan of a CMake folder (I assume the CMake configure step takes significantly less time than that). Would you be available to help us further diagnose the issue you're seeing? Hopefully this is something we can fix quickly. If yes, can you open a ticket at https://developercommunity.visualstudio.com (or from the IDE, Report a Problem) and let me know the link to it?
I am curious to know if it would be possible to make a "lazy" version, that would only extract the N smallest values from the whole set of values, without sorting the rest.
I don't believe I ever said there was anything "wrong with it", and drop checking is part of region checking which determines the duration of borrows. And of course this makes sense given that drop checking is directly tied to lifetimes! Honestly, I fear you are operating under the mistaken impression that I have something against Rust and am trying to convince people it's slow, when is quite the opposite of what I said in my original comment. In fact, I like Rust quite a bit and will like it even more once GATs are implemented. P.S. `mem::free` doesn't exist, so your code doesn't compile. Your statement that "there is no runtime check of any way here" is both grammatically incorrect and completely wrong according to the official docs. You do not "literally do the same with C++" because the compiler always calls the destructor for objects at the ends of their lifetimes (although a type like `std::optional` can effectively make it conditional, but that's behavior you opt into). So let us dispense with the pedantry.
What's Foo?
Annoying little smiley at the end :)
No idea how cereal or boost works with custom types, but it will probably work by somehow serializing the type, size of the map, then iterate through it and serialize the key value pairs
Will clang support Qt? (Through Visual Studio on Windows)
Exactly, because my guess is that the problem will be there. At the moment I always use the `snapshot build` (trunk, i.e. Clang-9.0) with the `LLVM Toolchain Plugin`, works a treat (also using lld if desired). I fear that the included version will be continuously out of date (like the included CMake is always out of date currently). Adding the support is a good idea, supplying the outdated download of said tools is not. VS should just tell the user to go get and install the [any] tools (and add to path), job done.
Btw: read the bytecode i sent you again: notice the memcpy? just another reason why you might not want to use your char arrays ;)
Even C11.
Knowing how all of those work can be important, if only for the purposes of maintaining legacy code.
Are you just mashing the spacebar a random number of times whenever you need whitespace? Why is that better than just not doing that?
It should work fine, however I‚Äôm not sure if qt will distribute binaries compiles w/ clang. In any case clang in cl (well really msvc abi) mode is linkage compatible with msvc, so you should be able to use the msvc binaries from the Qt guys no problem.
Quoting from Eric's post: &gt; Of note is that clear_() leaves *this in a state such that it is still OK to moveFrom_(*this), which is what happens when that and *this are the same object. In the case of Function, it just so happens that the effect of this code is to put the Function object back into the default-constructed state, obliterating the previous value. The particular final state of the object isn‚Äôt important though, so long as it is still valid. Calling a d'tor on the this-object does not (necessarily) leave the object in a default constructed state, hence it's a no-no [the original question].
I think that the best way to implement assignment post C+11 is as follows. It puts all work in the copy constructor and the destructor. Foo&amp; operator = ( Foo&amp;&amp; other ) { swap( *this, other ); return *this; } Foo&amp; operator = ( const Foo&amp; other ) { *this = Foo( other ); // Foo( other ) is a temporary, hence this is a // moving assignment. return *this; }
Yes, you are right, however, Clang(-cl) does not support LTCG. And for having Clang's LTO (or ThinLTO), one needs to use lld (it cannot work with link.exe).
Does the article state otherwise anywhere?
A bit, yes, but mostly the editor is smart enough to indent following lines the same as previous ones so it is not an onerous burden. The editor is also capable of shifting blocks left and right. Code has to be written to be read, which I think is why it is better than just not doing that.
I see what you mean. Hmm, going to have to review my use of std::function. Why couldn't they have kept it simple?
The point was to illustrate the problem by using an obviously bad way of writing code and showing how the use of auto obfuscates the problem. No, I personally would never write that method signature but that does not mean that I have not seen it written many, many times while reading other people's code. So, I wish that example was stupid but I have worked at enough places now and seen enough engineers who ought to know better commit these sins. My concern with auto in this specific context is that it makes it harder for me to spot these sins in code reviews or while reading code written by other people.
Yes.
Do you get a memcpy when you do std::string test = "Hello world!\n"; because you should get a memcpy and a heap allocation, especially if you concatenate a string? What your code does is create a static string literal from a string as char str[100] = "Some string."; is shorthand for char str[100] = { 'S', 'o', 'm', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g', '.', '\0', ...}; It adds the extra nulls at the end because you told it to and because it has to set all the bytes of the string anyway, so it might as well have the extra nulls in the string and do a single memcopy. I didn't do anything like that and I made sure to keep my buffers significantly smaller. Is this code compiled with any sort of optimizations? Also, I switched to using strings because strings make developers feel that the code is safer, as you can see in another comment. All the extra includes for basically the same functionality led to an extra 20KB in the binaries, so strings were using up more space than the buffers.
AFAIK the line in question i.e. auto names = GetNames(); will cause a copy construction and not a move operation. Do you know of any reason why it would not ? [Sidenote : Even if it is moved, a move would leave the original vector empty, which would definitely not be what you would want out of this API.] Even if there was a magical way to copy vectors that was super fast, I'm sure we can conceive some data type that has a non trivial copy constructor. Perhaps a custom type written by someone else that is very good at what it was meant to do but unfortunately has a slow copy constructor Perhaps the sub optimal copy constructor lives in a third party library that cannot be easily changed. Finally, even if all this was not an impediment perhaps manufacturers created the hottest new CPU's and Memory that can copy many hundreds of megs of data on your latest machine without batting an eyelash, would that be true on all customer hardware? Would such software be portable to other platforms that may not have the magic copy instructions? Things like phones or video game consoles? The specific example I used was to illustrate a point. The point was that 'auto' can obfuscate errors by making code look simpler and more elegant than it really is and that is by no means a theoretical concern. I wish it was, it would make my job easier as I would never come upon a piece of code that looks simple, but is in-fact deceptively so.
Furthermore, In response to your assertion *If you have a getter that returns a non-const reference, and you think that that is correct, you have way bigger problems than auto.* This statement takes an obviously incorrect example that I created to illustrate a point, uses it to question my skill as an engineer and then turns that implication into an attack on the argument itself. This is a logical fallacy, we as engineers should try to debate the argument, not try to attack the character , skill or personal traits of the person making that argument. Here is a good explanation : [https://yourlogicalfallacyis.com/ad-hominem](https://yourlogicalfallacyis.com/ad-hominem)