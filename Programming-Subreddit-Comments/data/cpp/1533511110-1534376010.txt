Does it do log rotation? How is it better than Boost.Log?
Nice job, I used it for a long time.
Who is "we"? Are you part of the Filament team and speaking for them? I wholeheartedly disagree, RAII trumps everything. Manual releasing of resources if not good C++ practice. It has never been, not even before C++11, except for very rare circumstances.
Very interested in trying this out. Anyone make use of [DLT logging](https://at.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace)? DLT also has some nice features, and I can imagine possibly writing a dlt_sink.
While we're at it, curly brace all the things :) `for (auto i{ data.size() }; i--;)`
Yeah, I think you'll need to find time to work on personal projects without limitations. Most workplace projects will be limited by different factors, legacy code-base, older compilers, less experienced developers (or less motivated!) and so on. I prefer to use non-c++ languages in my free time, but I choose ones that give me a new perspective which I can use during my daily work. (like Haskell and Rust)
How do you define successful?
I work on Filament yes.
Maintaining careers spanning decades, where they perform respectable quality work and pull a decent salary. Mostly senior and principal software engineers. What did you think I meant? In the places I've worked, I've been a bit of a rarity because I *do* projects at home. Nothing remotely related to what I do at work, though.
I was curious if you include quality work int he definition. I know many people, who are "successful" in every other term, but they don't do quality work. Though, we can debate what quality work is. Is it enough to do the problem safely and efficiently enough given the project parameters? Or you also care about the solution and coding quality?
In my experience people usually patch things because they don't understand how that part of the system works in the first place. They then find the one place that they know they can make a fix and do it. Underlying design never gets changed because after years of 'patching' no one has touched that core design code nor do they understand it. So, patches build up, but the code base is unmanageable and hard to work with. Any suggestion to rewrite/heavily refactor gets put down because there is now so much legacy code.
Nice paper. This reminds me of SIMT execution in CUDA for memory level parallelism...
That's a result of the job market. There is more demand for good people than there are good people. And in some cases, it still makes sense for companies to keep mediocre developers on board. Or it may be like at our shop, where middle management becomes more and more clueless over time, and no longer recognizes quality work or lack thereof. 
You can say the same things about heap allocations in general: "You don't have to release the memory, the OS will clean it up when the program ends". These sure look like resources to me. 
The people I'm thinking of collectively kept a large cross-platform C++ application maintainable for two decades. There were a few who were definitely "meh", but who could be relied on for smaller features, just not the deeper architectural changes that might be necessary to implement (for example) a new storage backend. The codebase was clean enough that those kinds of things could still be considered. Then there were the cheap foreign dev team that we hired. They liked raw pointer arithmetic and char arrays in their "C++" code, and wouldn't respond to suggestions to improve the code during code review. Thankfully, they only worked on a couple of plugins disconnected from main operation of the app. Those parts of the codebase were known as untouchable piles of crap. Although they were employed for many years, they aren't the kind of "successful" I was thinking of.
That's a weak excuse. If it's a C++ library at its core interface-wise, it should be providing a modern C++ interface. Secondary interfaces should be the ones jumping through hoops to use the library, not the users. If it is meant to be a lowest-common-denominator API, it should be exposed as pure C instead.
It is so wrong.
&gt; moron You seem to read more into my comments than I am writing. I'm all for standards and I'm glad C++ has one. I'm also aware that specs doesn't magically become free of [defects](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html) when they are blessed as standards. Likewise, implementations of standards are not [bug](https://gcc.gnu.org/bugzilla/buglist.cgi?chfieldfrom=7d) [free](https://bugs.llvm.org/buglist.cgi?chfieldfrom=7d) either. 2d graphics has been standardized before, why was that not good enough for your needs?
It does log rotation. I don‚Äôt know for your other question as I‚Äôve only just looked at the readme
What if you need `std::hash&lt; std::vector&lt; std::string &gt; &gt;`? The `std::vector&lt; std::string &gt;` isn't a user defined type.
Much faster compile time and much better performance than boost.log
I don't agree with you. I prefer: friend struct Properties&lt;MyClass&gt;; to DONER_DECLARE_OBJECT_AS_REFLECTABLE(MyClass) as for the latter I have no clue what it's doing, while the first is absolutely clear what it does.
To make this case work with RAII, you'd need reference counting. Which is a serious overhead. It's a rendering engine, it shouldn't superimpose any memory management onto the user. If you want RAII, wrap it yourself in a shared_ptr/unique_ptr. But don't make me use them. They should **never** be part of s public API. 
Don't single header versions of libraries slow down compilation time?
Depends. Header-only libraries generally do. But if you use single-header-header-only libraries you should have enabled precompiled headers anyways...
What toolchains and language versions are supported?
Imho the number of headers rarely matters as long as it is header only, but if dependency handling is a problem, I'd recommend a packet manager.
No on drags a packet manager into a cross-platform codebase though. Easiest for us it to have on thirdparty folder with versioned single-header includes. If a libraries provides that it will always be preferred over any other.
Why do you have to use std::move when passing the string by value to the constructor? What is the difference between moving and not moving?
If you move it, the string won't get copied; instead, the string gets turned into an r-value and will keep using the internal char buffer. As a downside you can no longer safely use the string 's2'.
&gt; Manual releasing of resources if not good C++ practice. That depends. Manual releasing of resources is basically the only way to properly release resources where 1) the release operation can fail, and 2) handling failure is important.
Loving and using this for a while now, thanks!
Is there really a reason why anyone outside of (AUTOSAR) embedded applications would want to use DLT? Even AUTOSAR themselves move in the direction of "normal" logging frameworks (where DLT is used "only" as a backend for remote logging): [AdaptiveLogAndTrace](https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-10/AUTOSAR_SWS_AdaptiveLogAndTrace.pdf) And I don't know about Genivi's implementation, but at least according to the standard it has some dependencies that you normally don't want.
It seems you actually agree with me, and find the style of /u/donerkebap13 less clear :-)
&gt; Your "very rare circumstances" are somebody elses everyday bread and butter. Yes definitely. This is true for everything. &gt; C++ does not have a zero-cost abstraction for handling this particular case A rendering engine is quite something of broad applicability. I know it's not a rendering engine, but for example in SFML, I don't think there's any manual releasing of resources, or at least there's no owning raw pointers as far as I am aware - and SFML is similar in that it has to access the graphics drivers rendering and resources (like OpenGL) too, like the rendering engine Filament. So I am surprised to hear there would be no zero-cost abstraction to handle this case. So e.g. SFML's resource management abstraction has some cost? How big is that cost? Since SFML is widely used in many high-performant games, this cost must be negligible in most circumstances? Also I am wondering, is this being worked on in the C++ language, that we get a zero-cost abstraction for this use case? How would that mechanism be called? Or is it thought to be impossible to accomplish with zero costs?
&gt; So I am surprised to hear there would be no zero-cost abstraction to handle this case. So e.g. SFML's resource management abstraction has some cost? I don't know how SFML's does this, but I don't know how to free the camera via the engine in the example code shown above using a destructor without storing an extra pointer to the engine. &gt; How big is that cost? If you store a pointer to the engine in the Camera or the custom deleter, that pointer has to be a smart pointer to support the case in which the Engine is moved. So that's _at least_ two words of memory per camera. If the `Camera` had zero size before, the cost would make the camera infinitely larger... My point being, it depends, but doing nothing / storing nothing is often cheaper than doing / storing something.
You should probably tell us more about what was taught in your syllabus. Was it just pointer and class? Was there std container like vector, map, set? Was there templates?
YES!!! How Exciting, How exciting! Finally a compiler for the common man. More Breakthroughs! Daily Breakthroughs! Does it plug and play with Jerlang, Pony and ChefDB?
I would say try them both. Most likely you would find juCi++ faster, less resource demanding and more stable compared to QtCreator, mostly due to the fact that juCi++ is a smaller project that is programmed in newer C++ and is using gtkmm instead of Qt. juCi++ also started out with a tight integration with libclang that we have improved throughout the last several years.
Looks interesting. However, I really hope the project provided Windows binaries.
I tried opening a very big qmake ‚Äúproject‚Äù (just a list of all c files) of qemu in juCi++ and nothing worked out of the box (no autocomplete, no go to definition). This is what‚Äôs nice about Qt Creator and CLion, they both worked the first time.
Currently, only CMake and Meson projects are supported directly.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9508xb/help_with_personal_project/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Despite the name, `std::move` doesn't actually move anything. It just performs a cast. The move happens elsewhere.
Sorry, we do not provide binaries. At the moment, only FreeBSD provides a precompiled package, and Arch Linux AUR has jucipp packages. We depend on package managers to help out on the various platforms. 
No.
Sorry, I typod qmake -&gt; cmake. I created a **CMake** project for qemu. Just added all non-test c files and the required include directories. That should be enough to get auto complete and navigation right?
Just remember to set project name through the `project` function in the top-level CMakeLists.txt file
This is what I meant by creating a spdlog dlt_sink, to push logs into DLT. There is a bit of overlap in features for redirecting log output. DLT supports TCP remote logging like you mentioned. It has a message injection callback which can be helpful if needed. The viewer is also decent and has a plugin system for customized processing of logs or adding some utility to the viewer. I am not sure what you mean by the dependency constraint; I have only seen it linked dynamically and I don't think that was much of a burden unless I am misunderstanding your statement. I am not really an advocate, but I have never seen it brought up in discussions of logging so I wasn't sure if it has any use outside of AUTOSAR compliance.
The level of C++ that is taught is not even near the professional modern C++. Also, you can program for years in this language and still don't understand a lot of the code. Effective C++ and Effective Modern C++ are great starters if you already know some C++. There aren't really any general advice books to follow (at higher level), so you'll have to learn through experience.
Apart from the speedup and improved battery life by using juCi++ instead, I would argue clang does a better job at parsing C++ than CLion. Additionally, you can get clang-tidy checks without doing double parsing by using clang tidy as plugin. CLion is also closed source. 
I mean, string\_view is great, but in general it would be more clear to just have two constructors, like this: Foo(const string&amp;) Foo(string&amp;&amp;) which also states your intent more clearly imo. There's also [this](https://clang.llvm.org/extra/clang-tidy/checks/modernize-pass-by-value.html), but it's a purely clang thing afaik.
What I meant by Dependencies: AUTOSAR specifies some dependencies that are required by the DLT module (like PduR, DET, DEM, SoAd,...) and many of them probably are optional or can be stubbed, but I don't think it will be a clean solution if you're not already using AUTOSAR BSW modules. But: I don't know how deeply coupled this implementation is to other AUTOSAR modules.
Just installed it from AUR. It looks great. How can I change the font size of floating hint information when I place the mouse on the editor. It's very small with default size. 
Hi, I also wrote an article about this topic that covers many more use cases: [http://blog.codeisc.com/2018/01/09/cpp-comma-operator-nice-usages.html](http://blog.codeisc.com/2018/01/09/cpp-comma-operator-nice-usages.html) I hope it's interesting for you
[CppCon 2017: Nicolai Josuttis ‚ÄúThe Nightmare of Move Semantics for Trivial Classes‚Äù](https://www.youtube.com/watch?v=PNRju6_yn3o)
I honestly love this sub. Best software recommendations on the internet
&gt; To make this case work with RAII, you'd need reference counting. No, it could return a unique_ptr.
I'm tempted to start a little challenge or competition on using comma operator nicely.
CLion can use [clangd for parsing](https://blog.jetbrains.com/clion/2018/07/clion-2018-2-clangd-gradle-compdb-sanitizers/).
What are you talking about? It's using one of the most common existing compilers to compile a multi-decade old language using either one of two the most common build systems. This is just an IDE.
We should probably have an option for this. Currently, the gtk+ default font is used. You can change the size in for instance Gnome Tweaks, Fonts, Interface.
I am happy they go in this direction, though it is still experimental, and they are thus using two engines by default at least on MacOS and Linux.
Why? a view's only purpose is to show the data; each time you use the MVVM model, a controller is dying to be separated from its view :-).
Which is reference counting, capped to a single reference.
No wonder so much code is generated if he doesn't use constexpr !
&gt; Shouldn‚Äôt the compiler be able to figure this out and do the right thing, or is there anything preventing the compiler to do that? I guess you are referring to this case: // from r-value reference std::string s2 { "Marc With Very Long Name"}; UserName u3 { std::move(s2) }; The C++ standard is preventing the compiler from automatically doing this r-value cast because it would violate the as-if rules. But the C++ standard (before 2017) requires that in those situations where it explicitly allows "copy elisions" (= eliminating temporary objects and named return value objects, a move construction should be preferred over a copy construction if the compiler won't do this copy elision for some reason. Since 2017, compilers are forced to do copy elisions in the situations they are allowed (basically). Examples: string source() { string blah = "hello"; return blah; } int main() { string o = source(); } Since C++2011 it is guaranteed that in the above program no string object is ever copied. At most, a string object is moved from one place (`source`'s `blah`) to another (`main`'s `o`). At best, source and target object memory is fused into a single object and only one string object ever exists (thank you copy elision!). Since C++2017, compilers are forced to apply this copy elision optimization which allows you to even return non-movable objects from functions by value.
Romain Guy is well known in the Android world.
Thank you for the book recommendations. I will try them out! :) Have an upvote kind sir!
no, this ( passing the by value string argument in constructor to string member) is not a copy elision and not a guaranteed copy elision context. https://en.cppreference.com/w/cpp/language/copy_elision so you better insert the move.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Why Gtk and not Qt?
Yes, but no, but yes, but... The problem is that this doesn't scale beyond one parameter very well if you wanted to support all variations of const lvalue- and non-const rvalue references. For specific types that are known to move very efficiently, I tend to prefer pass by value in such situations, so class person { std::string name; public: explicit person(std::string name) : name(std::move(name)) {} }; You don't have to put a double-ampersand anywhere and it makes things real easy. Now, to "solve" the explosion of l/rvalue variants for multiple parameters you could also use perfect forwarding in the general case. Probably like this with a "constrained" template to avoid silly instantiations that wouldn't compile anyways: class person { std::string first_name; std::string family_name; public: template&lt;class T, class U ,class = std::enable_if_t&lt; std::is_convertible_v&lt;T,std::string&gt; &amp;&amp; std::is_convertible_v&lt;U,std::string&gt; &gt; &gt; person(T&amp;&amp; x, U&amp;&amp; y) : first_name(std::forward&lt;T&gt;(x)) , family_name(std::forward&lt;U&gt;(y)) {} }; But pass-by-value doesn't require double-ampersands and is easier at presumably an insignificant cost in most of the cases: class person { std::string first_name; std::string family_name; public: person(std::string x, std::string y) : first_name(std::move(x)) , family_name(std::move(y)) {} };
&gt;alt+Enter and it'll give you the option to create the new function is there a way to do this in IntelliJ, I tried it just now but it didn't work.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/951plo/how_long_it_would_take_for_the_average_person_to/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Apparently alt + Enter should [do the same thing in IntelliJ](https://intellij-support.jetbrains.com/hc/user_images/k6LoYKnaL9eiUmaS0MR4Mg.png) but I don't have it installed.
That didn't answer the question.
Division (modulo) is costly. Multiplications, additions, shifts are not. Compilers are smart.
but isn't it prohibited to have STL in the public API?
Just to say that there are [build instructions for Windows using MSYS2](https://gitlab.com/cppit/jucipp/blob/master/docs/install.md#windows-with-msys2-httpsmsys2githubio). If you're using the MSYS2 setup on Windows already (which I would recommend) then it's easy enough to set up. I've tested it just now and it works as good as on my Arch machine.
What are the correctness pitfalls you run into?
I shall look intro that algorithm. I also do AVR work, so faster algorithms are always nice.
Huh, it wasn't last time I std::visited that particular page. I see it was added in March... nice.
by whom?
&gt; faster, less resource demanding and more stable compared to QtCreator, mostly due to the fact that juCi++ is a smaller project that is programmed in newer C++ and is using gtkmm instead of Qt. ye gonna need some sources for this. GTK3 uses a good deal more resources than Qt. [Food for thought](http://blog.qt.io/blog/2018/05/03/qt-microncontrollers-mcu/) - consider than in the last few years a *lot* of OSS projects have migrated from GTK to Qt (wireshark, dolphin, subsurface, etc). I don't know a recent instance of the opposite happening. 
True, universal references allow for easier scalability, but in this very case two constructors work better imo. As for double ampersands, I think it's not a big problem, the problem is the bulky template syntax and the fact that you have to keep the constructor's implementation in the header. But yeah, I see where you're coming from. If you can guarantee that strings you pass are short enough for sso to be employed and you aren't going to create millions of persons than it may be a viable solution to use pass-by-value. Or ranges.
Why does it ship it's own copy of fmt anyway?
Did you saw the big red box when posting? This subreddit is not for help. Try /r/cpp_questions for question about C++
Probably to prevent issues with a project already including a different version of fmt.
OP might be using the "new" version of Reddit... (I am) There doesn't seem to be any of the usual banners, sidebars, or other things I'm used to in the old version, so the warning may not even be visible any more.
Yep SDL did some questionable black magic with main() so be sure to sort it out.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; `-lSDL2 -lSDL2main` Aren't these in the wrong order?
&gt; I shouldn't have to define a variable. Then you shouldn't be programming in a strongly typed language...
Now why in the heck would you want gridlines in your editor? I noticed they follow the monospace font, but I mean, whats the purpose? It's not a layout application. There are good methods to visualize indentation for example, but this just clutters everything up. That said, what benefits does this application have compared to KDevelop and Visual Studio (which are by far the best IDE's out there for Linux and Windows respectively)?
It‚Äôs very nice and a lot faster than other IDEs (that are not written in cpp). One issue I have with it is the lack of debugger GUI (unless it‚Äôs there and I missed it) Would be nice to provide a variable explorer if it‚Äôs not too hard.
LLVM gonna be smarter about modulo codegen soon :) https://reviews.llvm.org/D50222
C++ can't convert arbitrary lvalues into rvalues because of how the standard is written. "Obvious" cases to us humans - and even cases that any modern compiler can easily figure out - can't be expressed in the language of the standard. The standard doesn't have a clear way to define last-use of lvalues or the like; the existing copy elision cases are those that can be proven correct entirely via grammar and value categories, which unsurprisingly are exceedingly limiting. The standard would need a pretty large overhaul to add a reliance on advanced analysis passes to do that kind of stuff. Unfortunately, there are downsides to doing that (always are), and I don't see the current committee moving in that direction in any event.
Definetely this is a matter of taste. I see it as an API call (the problem in this case is that you can't encapsulate that in a function :P). When in any API you call foo.Init(), you shouldn't care about implementation details, you just use the public interface.
Thanks for taking your time writing this example! :D I see some interesting things in this code. I'll have a deeper look. As for your last line, that's more or less what DonerSerializer ends up doing but, as for API design, I prefer to encapsulate that inside macros to give a cleaner, more semantic usage. As I said in other comments, this is a matter of taste :P
Could you please clarify why the manual control was chosen over RAII? Why is it better practice in this case?
I had a look to Hana some months ago but, after reading this &gt; What is this library about? So all is good, but what is this library actually about? [...] The purpose of Hana is to merge the 3rd and the 4th quadrants of computation. More specifically, Hana is a (long-winded) constructive proof that heterogeneous computations are strictly more powerful than type-level computations, and that we can therefore express any type-level computation by an equivalent heterogeneous computation. This construction is done in two steps. First, Hana is a fully featured library of heterogeneous algorithms and containers, a bit like a modernized Boost.Fusion. Secondly, Hana provides a way of translating any type-level computation into its equivalent heterogeneous computation and back, which allows the full machinery of heterogeneous computations to be reused for type-level computations without any code duplication. [...] Sorry but my anus shrunk to the size of an atom when I read that. I'd say what DonerReflection offers is a way way simpler library (only ~100 lines of code) for anyone interested in do stuff with their class members. And nothing else. Obviously Hana is more powerful and allows you to do stuff that DonerReflection doesn't, but for simple cases as Serialization, UI generation etc. I think you don't need that amount of extra features. 
You can disable the gridlines in preferences. 
If my project already uses fmt in version X and spdlog provides its own copy in version Y then this will certainly lead to problems - or is it putting the fmt symbols into a separate namespace?
I think gtkmm has a more modern API. For instance, instead of QVector, std::vector is used. Gtk also uses UTF-8 directly, and gtkmm is using std::string as internal UTF-8 storage, so no need for unnecessary conversions when using other C/C++ libraries. Additionally, you have gtksourceview, a decent text editor library, which has been of great help in developing juCi++.
And there is a new version coming up early next year. I hope the publisher reads this :-)
Mostly careful bounds checking, plus handling arbitrary bases in [2, 36]. I wouldn't exactly call them pitfalls, it's just that reading/writing raw buffers requires lots of attention to detail.
Ok, but why would you want it? What is the reasoning for this being what I presume default settings?
&gt; The standard doesn't have a clear way to define last-use of lvalues Could you expand on this or is there a paper you recommend? It seems like the difficulties here would be pretty interesting. 
No idea. I was just giving one possible reason.
This doesn't actually deal with the issue of the comma operator, which is that it's overloadable. The issue in \*this\* article is that C++11 constexpr is insanely hobbled, and the use of the C-style comma "operator" allows you to jam multiple lines into one. But there are no justifications for overloading operator, given.
Callgrind with specific start/stop markers around the actual computation would've been more useful i guess...
Maybe try /r/programmerhumor although I'll suspect it'll get downvoted there too. It's not that funny.
Just define SPDLOG_FMT_EXTERNAL before including spdlog to (fmt 5.0 and above).
Off-topic.
No, and no.
I mostly work in Java and Scala at work. I come home and basically spend about half of my free time trying to play catch up with C++. (I used to be a good C++98 programmer, so I have to get up to speed with C++11/14/17 to be able to say that I'm still a competent C++ programmer.) I think - if you want to program outside of work - then the key is to find a project you feel passionately about.
&gt; Taking into account that no object can have a size of zero They can: `[[no_unique_address]]` allows this in C++20.
That's the main reason I didn't try it yet: I'm willing to build tools I need, but I can't be bothered to fully build it just to give it a try ^^'
Allright man, I cant force you to answer some (very simple!) questions about your product, but come on. Have some integrity!
I think the point I'm trying to make (albeit in a very roundabout fashion) is that MVC makes it difficult to handle two way data bindings - in theory neither the view or controller should care about the other. In practice this is difficult, if not impossible, to achieve, with the view, controller pairs becoming irrevocably intertwined. In many respect the view-model in MVVM is similar controller with one strict constraint: it is only allowed to bind data. This prevents the view-model and view becoming co-dependant.
How about a remote headless version on the server and a gui version on the client which can connnect to the headless one, then all the headers and related stuff came from the server.
&gt; Manual releasing of resources is the only way to properly release resources for which 1) the release operation can fail, and 2) handling the release failure is important. Can you give an example of such resource? I'd argue that for a correctly designed resource if release failure is possible at all, it is either fatal or ignorable, and there is not much reason to expose either to the client code.
Sad that that isn't the default, but it's probably the price you pay for not having a single, stnadard, commonly used dependency/package manager
Any plans to support other make systems? I've got a project that's using make I'd like to try it on.
Cool, thanks for the pointer! I just watched one of his talks and it was great, amazing speaker! :-)
I see. It's true that text editing is a pita in Qt. I always avoided Gtk because I tought it was definite-not-modern and used C idioms.
Say hi to him, you were talking to him in this very thread!
Agree strongly with templates being a bigger problem. Nobody is going to want to write all those template constraints, so most won't bother.
This is where arch or manjaro shine. I just install it using one line in terminal: `yay -S jucipp-git`
It's important to remember that those things are part of your API and that just because you COULD make your API that way doesn't mean you should. The tool couldn't know whether or not it would be ideal to make the change.
You really should make at least a minimal effort to provide binaries for windows. linux matters less, managing binaries there is a mess anyway, idk if it can even be done, thats what the package manager is for, but windows? Nobody wants to build it here, especially just to try it. You're cutting out an entire platform with a lot of potential users because of laziness? Especially because managing dependencies sucks so damn much no matter the platform, especially windows. Nobody wants to figure out how to get all your dependencies just to *try* it. You have *two* CI configs in the repo, both of which seem to support windows, so.. whats your excuse? you're building on windows anyway.
It's also worth mentioning they seem to have appveyor configured to build using msys, meaning they're building windows binaries and just.. not bothering to give them to you for some reason. which doesn't make the project look good at all. Nobody wants to install msys and the rest of it's dependencies just to build it, especially when the only reason there aren't binaries seems to be pure laziness. I think it's safe to assume that extends to the rest of the project.
It's just a personal preference. Some people don't respond well to aggressive questions. 
That's the beauty of it here. Instead of decrementing in the decrementing step, it does this in the check step, which happens in the first iteration as well.
Package manager might be overkill, but I don't see much difference between 3rdparty folder with single headers vs versioned subfolders. You're probably using subfolders already anyway I guess. 
Great job!
Just a few recommendations: - you have written a unit testing *framework* - not a *unit test* (hopefully also the latter, but that's not the point here, right?) - host your project on a platform like github, bitbucket or similar. That way you don't have to post lots of code here and can make your text / question more terse. I think you shouldn't explain what the benefits of unit testing are - the readers who knows about will get bored before they reach your code, the others won't get enlighted by your posting. So next time try to focus more on one aspect like *what* you expect from the readers... Like code review or something. Have fun programming üòâ
And how one can use this framework? Some examples would be helpful. 
Dude, they are working in their free time on it for free.
`requires requires` why is this required?
&gt;GTK3 uses a good deal more resources than Qt. Do you have a source for this?
&lt;Compilation failed&gt; from godbolt
The point of this demonstration is to show the error messages produced by the concepts feature, so the compilation failure is intentional 
The first requires denotes the start of the requirements of the template, the second is the start of a "requires expression" listing expression and type requirements (the requires expression can appear in other places as well) 
Well yes the example is a bit contrived, I'll consider having a better one. 
Please correct me if I've got this wrong: - the first `requires` introduces a _requires clause_, which must consist of a constant expression - the second `requires` introduces a _requires expression_, which is a type of constant expression This is kind of confusing, because `requires requires` does look like a mistake at first sight.
Maybe some feedback about the code / header... In C++ you should really use std::string instead of using char\* all over the place. You can also mark constructors as deleted since C++11. Something like this: &gt;\#include &lt;cstdio&gt; &gt; &gt;\#include &lt;cstdlib&gt; &gt; &gt;\#include &lt;string&gt; &gt; &gt; &gt; &gt;const std::string MBUVersion = "2.0.4"; &gt; &gt;const std::string didPassStr = "pass"; &gt; &gt;const std::string didFailStr = "fail"; &gt; &gt; &gt; &gt;class MBUnit { &gt; &gt;private: &gt; &gt; std::string \_thisStr; &gt; &gt; const std::string \_thisName; &gt; &gt; unsigned int \_numDidPass = 0; &gt; &gt; unsigned int \_numDidFail = 0; &gt; &gt; bool \_summaryFlag = false; &gt; &gt;protected: &gt; &gt; unsigned int passTestCount() const { return \_numDidPass; }; &gt; &gt; unsigned int failTestCount() const { return \_numDidFail; }; &gt; &gt;public: &gt; &gt; MBUnit(std::string initName); // move string into place &gt; &gt; MBUnit(MBUnit &amp;) = delete; // no copy constructor &gt; &gt; MBUnit() = delete; // no default constructor &gt; &gt; MBUnit operator = (MBUnit &amp;) = delete;// no assignment operator &gt; &gt; &gt; &gt; const std::string&amp; version() { return MBUVersion; }; &gt; &gt; //I guess you are storing the strings? otherwise use const&amp; or string\_view &gt; &gt; void init(std::string initName); &gt; &gt; void test(std::string description, const int flag); &gt; &gt; void report(); &gt; &gt; bool summary(bool flag) { return \_summaryFlag = flag; }; &gt; &gt; bool summary() { return \_summaryFlag; }; &gt; &gt; &gt; &gt;};//end of class...
Just for OP information, No compilers (at least last time I cheacked) implements it yet.
There's this benchmark - Cinnamon and Gnome3 both use gtk3: https://blog.lxde.org/2016/10/04/benchmark-memory-usage-lxqt-desktop-environment-vs-xfce/
A USB dongle? A file? A network socket? They all check the two boxes: * releasing the resource can fail (e.g. the user removes the dongle, hard drive, ethernet cable, etc. while releasing). * handling failure is important: there might have been data on ram that was being flushed to any of these three devices on release. If releasing fails, the user might want to flush the data somewhere else (some other file, ...) instead of losing it. Sure, you can always ignore failure. But while people do this often with files because when releasing a file handle fails there is typically too much wrong going on, no major OS does this with USB sticks, where the user removing the USB stick while its being released is always notified to the user since the memory in the stick might have been corrupted as a consequence (only a part of a file might have been flushed there). 
You're right. Perhaps the committee can work out a shorthand for this but as stated, this is the noexcept(noexcept(...)) case, which hasn't been changed since C++11
Just because someone made a mistake long ago doesn't mean we have to repeat it over and over again. 
It started out as a Bachelor project by three students at the University where I work. The goal was to create a resource conservative IDE that had better support for the C++ language. At the time, IDE support for C++11 was pretty bad, and there existed no editor that used libclang yet (to my knowledge). From then it has continued on as a hobby project that has been in use in several of my courses for some years now. 
Great IDE. I have been using this on my laptop when I'm not at home, because others just suck my battery :)
What's an overwhelming decimation?
You should really watch some talks about modern C++. Also stuff like `return _summaryFlag = flag;` is not really good code in my opinion. I suggest you look at how existing unit text _frameworks_ work too.
Why is it difficult to handle two way data bindings? I've never had a problem not only with two but with multiple data bindings.
quick question about concepts: is it possible to write a concept such that instead of writing void foo(const MyType&amp; x) { ... do_stuff(x); } void foo(MyType&amp;&amp; x) { ... do_stuff(std::move(x)); } one could write void foo(const ??&amp; x) { ... do_stuff(std::forward&lt;??&gt;(x)); } so that const MyType&amp;, MyType&amp;&amp; are ok, but any other type fails ? Basically, a terse version of template&lt;typename T&gt; auto foo(T&amp;&amp; x) -&gt; decltype(std::enable_if_t&lt;std::is_same_v&lt;std::remove_const_t&lt;T&gt;, MyType&gt;&gt;, void) { do_stuff(std::forward&lt;T&gt;(x)); }
Zortech C++ IDE was actually one of the first ones to do that kind of presentation.
Everyone should know that, but many people don't. I once wrote a fir filter, which was perfect as far as I could tell. It would diverge with 32 bit floats, but was stable with 64 bit doubles. In cauda venenum, the poison is in the tail, as the Romans said.
Yes, I know - it was meant both as a general statement as well as a directed message ;-) (I watched the talk [Keynote: Modern Android Development](https://www.youtube.com/watch?v=8GFLCL0u1lw) to be precise - Hi, and thanks for the awesome talk! :) )
 If you just want the same type. template &lt;typename T, typename U&gt; concept UncvrefSame = Same&lt;uncvref_t&lt;T&gt;, uncvref_t&lt;U&gt;&gt;; template &lt;UncvrefSame&lt;MyType&gt; T=MyType&gt; void foo(T&amp;&amp; t) { do_stuff(std::forward&lt;T&gt;(t); } The default argument allows you to still call this with a braced-init-list.
great, thanks ! 
With setters, it's a bit different because pass by reference will result in copy assignment, and pass by value will result in copy construction. Copy assignment lets you reuse memory potentially. If you imagine calling a setter for every element in a list, you only heap heap assign if the element you're setting is the largest element so far. Doing the math this is actually only log N heap allocations on average for N calls to the setter. Whereas pass by value is always N allocations.
Ah, so you were talking about doubling the amount of reserved memory each time we exceed the current limit. I see, thanks. 
Obligatory [quote](https://sec.ch9.ms/ch9/9fb9/5f4cd3b3-4569-4651-987a-46dcc2739fb9/GN13STLrandConsideredHarmful_mid.mp4) from /u/STL: &gt; Say you have a problem, so you use floating-point. Now you have 2.000001 problems. Don't mess with float-point. [...] I treat it with respect and fear.
I think it depends. Qt's QString uses CoW and it's still a common way to pass it by reference for the same reason it's recommended to pass shared pointers by reference within the same thread. Copy on write is mostly useful in multithreaded applications, so classes employing it usually use atomic counters under the hood, and incrementing an atomic is undesirable if you can avoid it. 
[By ABI](https://stackoverflow.com/questions/22797418/how-do-i-safely-pass-objects-especially-stl-objects-to-and-from-a-dll)
Totally agree with you, this seems utterly ridiculous. `requires requires`? How did this ever get through the standards committee?
Yes, a range-for loop for reverse iteration would be a good addition. In any case if you don't want to leak variables into the enviroment, use the "for" version: for (auto iter = v.end(); iter != v.begin(); /**/)` { --iter;` // Process *iter` }
I remember applying some theory to doing some calculations, and getting a more accurate result than expected. We 'blamed' it on the cpu internally working in 80 bits, meaning the intermediate results didn't get written to memory.
That's interesting, can you explain how that works?
Yep, that can still happen nowadays with `long double`, I think it's in most mainstream CPUs.
At least on modern versions of gcc &amp; clang (and icc), `long double` is supported and will use 80-bit x87 instructions, however `sizeof(long double)==16` so the problem of it being truncated in memory is avoided, at the cost of some padding space (but if you're using long double you're not expecting maximum efficiency anyway presumably). MSVC seems to treat it as being the same as 'double' however, so this is a QoI thing. https://godbolt.org/g/fEBis8
if they aren't already bundling the required DLLs somehow, kindly explain how anyone on windows can build and then use the resulting binary without it failing to run because the dlls aren't there. They already have a perfectly working windows build process that results in a working binary, literally the only thing they need to do is upload it. The fact they havnt is pure laziness. next time try even the smallest bit of critical thinking, will ya? you presumably have a brain, so try using it.
The DLLs come from MSYS2.
Had to deal with that odd MSVC choice some time ago when writing [xtensor-fftw](https://github.com/egpbos/xtensor-fftw). Any idea why they chose to just alias `long double` to `double`?
I've had reverse difficulties. I was integrating steep parallax in VR. It was extremely disorienting - one eye would be 'out of phase'. This was due to the algorithm using integral steps - one eye could be 4, the other 5. I switched it to use floats and a scale. This fixed the issue, since they'd not be out of phase anymore. Looked better, too.
No, the binary requires DLLs to run which MSYS2 provides. You'll need the bin directory on your PATH or copy the needed DLLs next to the exe file.
I remember when I first read "had had" in a book. I was convinced that I had found a typo.
Documentation. 
https://en.cppreference.com/w/cpp/language/types &gt; long double - extended precision floating point type. Does not necessarily map to types mandated by IEEE-754. Usually 80-bit x87 floating point type on x86 and x86-64 architectures. 'double' becomes 80-bit anyway.
I don't know how long Hana takes to compile if you add it as a dependency, but you could be wasting compilation time in things you don't need (Being a metaprogramming library maybe this is not an issue, I don't know). Also, something that could sound silly but it really matters in our day to day as devs, is that intellisense-like systems times for searching usages, references etc. will go up with all that extra files you don't need. Also, for new joiners in your team or your project who doesn't know what Hana is and what parts you need or not, having the entire project could be way more intimidating than having 1 header file with 70 lines of code. As a final, personal thought: DonerReflection macros are more descriptive than Hana's, showing better its final purpose. This make it easier to get into for new joiners, in my opinion. 
It got through because it was assumed (rightly or wrongly; it remains to be seen) that defining concepts inline in constraints would be frowned upon, so people would not be doing it very often.
Which DLLs are needed though? They could just copy all of MSYS2, but that would result in quite a big package. Furthermore there's Gtk+, which needs not only several DLLs but also CSS files and other data stuff in the right location. I also think that clang needs a specific directory structure and several data files to work.
&gt;So I am surprised to hear there would be no zero-cost abstraction to handle this case. So e.g. SFML's resource management abstraction has some cost? How big is that cost? Since SFML is widely used in many high-performant games, this cost must be negligible in most circumstances? Part of the problem may be related to Vulkan: in Vulkan, you have to be very sure to explicitly manage the lifetimes of your resources. This paradigm has begun to change how I handle many things myself, and indeed my resource system for Vulkan has your manually calling \`resourceApi-&gt;DestroyResource()\`: GC or RAII isn't going to be consistent enough, usually, when I need to manually control the backing memory and resources for all my buffers/images unfortunately :(
Is it possible to annotate a class in some way to indicate that "this class conforms to XYZ concept"? Last time I looked at concepts I couldn't find a way to do this. But it seems like it would be useful for code readability. I think the best I can do now is to try to use the class in an interface that requires that concept and just see if it compiles. 
wow Ive always liked C idioms, I cant stand the syntax of modern languages
spdlog is great, and I'm thrilled to see it reach this 1.0 milestone. However, I must admit that I am seeing a considerable performance regression in fmt version 5.x compared to v4.x. There were substantial changes and a re-design, but code that is heavily formatting output into memory buffers, the fmt 5.1.0 code is almost twice as slow as the 4.1.0 based solution. Has anyone else seen something similar?
Sadly, no. The closest we can get is to put `static_assert(Concept&lt;Foo&gt;);` after the definition of `Foo`. This obviously doesn't work for class templates, but you can approximate it by putting the `static_assert` in a member function that you know will always be instantiated.
&gt; Which DLLs are needed though? run dependency walker on it and copy those. one and done. The required DLLs won't be changing if the dependencies don't. Thats like 5 minutes work. &gt; Furthermore there's Gtk+, which needs not only several DLLs but also CSS files and other data stuff in the right location. The same way you package a gtk+ app on linux?
I want to say - as someone working on a Vulkan rendering engine ([https://github.com/fuchstraumer/Caelestis](https://github.com/fuchstraumer/Caelestis)) I was super stuck on material handling. I wasn't sure what kind of material system or model to choose, and how to make it robust enough to support a variety of use cases. Filament is definitely helping a ton with that, and the \*incredible\* (honestly) documentation has been a tremendously educational read so far and I have to thank all of you for that! Really appreciate the choice to open source this project, for sure \^\\\^
Without SIMD summation, if you're latency-bound, single precision addition is the same latency as double precision. With SIMD summation, if you're throughput-bound, 4x the operations is 4x the time taken. Not sure how you're getting that result.
The main question you probably have to answer is: why use this instead of gtest? 
&gt; This is kind of confusing We had `import export` nonsense, now this. People involved in designing C++ are amazingly smart. I have no idea how this ends up even in a working draft...
I'm in China, and Inziu Iosevka makes CJK characters exactly 2 times as wide as alphas. So it's my go to choice when I want everything looks nice.
The main question you probably have to answer is: why use this instead of Catch?
Fast, simple and portable. That is why i'm using it.
Lol, I'm normally not bad at guessing what people meant (and in this case it was also a bit of a joke), but I would've never guessed that it means "documentation". Nice one!
So future Base ODF files will contain Firebird data files instead of HSQLDB data files? That would make the new files incompatible with old versions of LibreOffice?
thank you for listening to your users 
Even with the provided example I don't understand how I could use the framework for real-world work. Can you create a comparison table with tests written in yours and in Catch and GoogleTest?
Point is: https://godbolt.org/g/dTDMoC
Hilarious in hindsight considering that I've been working on floating-point charconv for months.
The short answer is pipelining. Two of the operations contribute directly to the current sum. The other two are updating the compensation value, which can normally be overlapped with loading the next value to be added. Of course, if the array being summed is very large, none of this means much at all--if you're reading (even most of) the data from main memory (or L3 cache) the speed will be controlled entirely by your read bandwidth.
Can anyone provide some background here? It‚Äôs missing from the post and the Readme On the GitHub doesn‚Äôt provide any clues. 
Gtk+ is easier on Linux as the package manager installs it (it already is installed on most distributions).
It was 80-bit in 16-bit days. They've changed it to be the same as `double` (which is standards-conforming) apparently due to: &gt;The major reason is that FP code generation has been switching to the use of SSE/SSE2/SSE3 instruction sets instead of the x87 FP stack since that is what both the AMD and Intel recent and future chip generations are focusing their performance efforts on. These instruction sets only support 32 and 64 bit FP formats. [link](http://forums.codeguru.com/showthread.php?390950-RESOLVED-When-is-80bit-long-double-coming-back&amp;s=a4ff5ba771062f32bb2c6a51ddd9dac6&amp;p=1410439#post1410439)
THAT's how it pronounced!
What kind of background are you talking about?
Here's what I've found after updating my investigation into the subject: First here's [the version of my file](https://github.com/Ebenezer-group/onwards/blob/master/experimental/upBuffer.hh) that uses unique\_ptr. The size of text segment of [this program ](https://github.com/Ebenezer-group/onwards/blob/master/tiers/cmwA.cc)when built with the unique\_ptr version is 76 bytes larger than the version that uses raw pointers. That's with g++ 8.1.1 and the -Os flag. The version that uses raw pointers is 6 lines longer than the other version. However if you consider the total number of bytes of the two approaches, the raw pointers version is only 25 bytes more than the other version. And the raw pointers version doesn't have to include the &lt;memory&gt; header which amounts to over 7,000 lines on my machine.
Could this be used to split a tcp connection over two different network adapters?
you're saying you need to full on install all of gtk just to use applications that happen to use it for gui, and all applications using gtk for gui need global system state just to run? Really? What kind of terrible "library"(if you can call a system wide installed binary a library. the same way your web browser is a library for displaying html. /s) is this? jesus christ. assuming thats true.(i assume it isnt accurate) not that my quick googling has found these mysterious required css files and whatnot, simply pointing to stuff like [this](https://stackoverflow.com/questions/49092784/how-to-distribute-a-gtk-application-on-windows) and [gtks own dependency list](https://www.gtk.org/download/windows.php), none of which mention random data files. 
Can't wait!
In C++20, `uncvref_t` is spelled `std::remove_cvref_t`.
You snooze you lose? ü§£ j.k. I wasn't aware you got back to working on the GCC implementation! That's great to hear üëç let's hope this triggers some other compilers and IDEs (and WGs) to speed things up a bit
Site seems down at the moment.
MSYS2 on Windows is going to be a hard pass for me.
A snapshot of the site is available at [the internet archive](https://web.archive.org/web/20180807220156/http://kayari.org/cxx/antipatterns.html) for anyone experiencing connectivity issues. I think a lot of the recommendations up there are solid advice, and highlight some interesting things about the standard library (I for one didn't know that std::thread's constructor took arguments to the function you can pass to it, along with the function!)
Technically yes but you'd be better off trying to integrate that kind of feature into the native system.
Who the fuck came up with that?
or any of the other perfectly good ones already out there.
They said they've already started enough on concepts in MSVC to add a compiler flag to enable it. No idea what the actual progress is though..
I doubt they'll ship it until it's pretty stable, so they'll wait until the standard is pretty much complete. Not breaking compatibility is important, and concepts could still introduce breaking changes.
Because it looks nice? I actually kind of like it. It's not too much, and it relieves the emphasis on the code. Anyway, if you /write a whole editor/, you get to put whatever you want into it :)
Is this pre or post-Boost 1.66? I.e., when ASIO was updated to reflect the Networking TS (N4656)?
I use Boost 1.67 to test the code.
Oh, I should have seen `io_context` vs. `io_service` right away... Thanks for clarifying.
That's the WGs part in my comment - this implementation has raised some wording issues already and it's clearer what problems remain in the current draft right now I believe, being the first specification based implementation. In general, having the two major compilers support concepts I believe will make many more users make the jump and will speed up the standardization as well given the increased user feedback and experiences, which in turn might speed up MS 's willingness to join the party 
They're a company and have a lot of work to support C++17 completely already, so I think it's fair enough that they wait for the wording to be fixed before going full speed on it. When you have volunteers, people work on what they want so obviously popular features will get implemented quickly (at similar complexity). The trivial to implement features like removing trigraphs don't need much enthusiasm, but concepts is a big chunk.
Hey, do you have any other comments regarding how Pcap++'s benchmark \[is not fair\]([https://github.com/seladb/PcapPlusPlus/commit/f6e04a747679d3923687fe4c964c230cd46b0e98#diff-b3d0534123c32141affdff020f8d5bda](https://github.com/seladb/PcapPlusPlus/commit/f6e04a747679d3923687fe4c964c230cd46b0e98#diff-b3d0534123c32141affdff020f8d5bda)) and is doing less work than the rest of the libraries you compare it to? When I compare the performance of Pcap++ against libtins I actually get different results as in my benchmarks I make both libraries \[do the same amount of work\]([https://github.com/mfontanini/packet-capture-benchmarks/blob/master/pcapplusplus/benchmark.cpp#L74](https://github.com/mfontanini/packet-capture-benchmarks/blob/master/pcapplusplus/benchmark.cpp#L74)). I think both benchmarks should provide consistent results, unlike what's happening now. Cheers!
Yeah, why would they design site that could go down? Totally an antipattern!
Yeah it may be optimistic to assume they would go that far, and yet they have shown increasing commitment in the last couple of years to improve and break the bad rep they had had. In general myself and many other people who want or need concepts have switched to gcc because only it had them. MSVC having them might bring back a lot of users and may end up being worthwhile for them. 
They are definitely working hard, but catching up and getting full conformance for existing standards obviously takes priority.
This could prove to be very useful. I was about to start playing with the Networking TS using Boost.Asio (or as close as possible until actual TS implementations start appearing). Thanks!
lmao this guy and his pumpkins
Note that the reference Ryu implementation has some issues. A bunch of its code is missing some very low-level optimizations that should pick up a few cycles (eg. `decimalLength` can be done with bit magic, which would save a branch miss), and, much more worrisomely, its benchmarks look completely invalid‚îÄthey aren't timing any stochasticity.
&gt; It's easy to do, but it can damage long term productivity. I don't have even the slightest evidence for that. &gt; If your controller is manipulating the data before passing it to the view That's wrong. In the MVC model, a Controller modifies a Model, it never passes data to a View. &gt; there is a good chance this controller has become so niche that it does not work effectively (or at all) with an alternate view The above situation is due to the error mentioned above. If controllers only alter models, then multiple alternate views can be attached to models. Your conclusion stems from doing MVC the wrong way.
The string question is easy: it's because a lot of people come from reference-semantic languages where an uninitialized non-fundamental type is null. But then again, reference-semantics are themselves an anti-pattern a lot of the time.
What about just `[[maybe_unused]] constexpr auto var = expr;`
&gt; int i, j, k; &gt; if (in &gt;&gt; i &gt;&gt; j &gt;&gt; k) Ugh, iostreams
Because if you want to write a quick and dirty tool, it's there.
1. Visual Studio is an easy IDE since it is made for Windows first. Easiest to begin with. 2. C++ is a compiled language. Each .cpp file represents a module that is compiled independently, then comes the linker that makes connection between each modules and generates the output. 3. Visual C++ 4. Read tutorials, read blogs, read books, watch conferences. Try to find a domain you want to focus on for now and learn programming that way. For me it was networking, I discovered a lot by building apps and libraries around it, and have a lot more to learn.
[#34](https://github.com/ulfjack/ryu/issues/34) tracks the former. The latter is also known (see the comment thread). I'll write a proper benchmark when I'm done converting it into C++ &lt;charconv&gt;. I'm confident that it'll continue to crush Grisu3 (which is also benefiting from the lack of branch mispredictions in the current benchmark), since it just does so little work. I'm actually worried that my extra layers of code on top, handling the charconv interface, will be a significant cost, since every nanosecond counts. If you can identify other low-level optimizations, that would be great!
This is a good comment, but I want to add something. I‚Äôm also a beginner and I find Visual Studio being too much, sometimes it seems overwhelming. What I‚Äôd do if I were he, I‚Äôd use Code::Blocks. It is simpler and crossplatform. 
&gt; you're saying you need to full on install all of gtk just to use applications that happen to use it for gui, and all applications using gtk for gui need global system state just to run? No, I didn't say that. I just said that some DLLs next to the exe aren't enough.
&gt; I‚Äôm also a beginner and I find Visual Studio being too much, sometimes it seems overwhelming. Can you elaborate ?
Great. It was more an FYI than anything. If you want something to check against, [my integer printing routine](https://www.reddit.com/r/programming/comments/7ljzty/how_to_print_integers_really_fast_with_source_code/dro1umo/) (not 100% sure that's the most recent version) is probably worth retrofitting in to the final step. I suspect the `while (vp / 10 &gt; vm / 10)` loop can be done with `vp &gt;= vm ? decimalLength(vp - vm) : 0`‚îÄa special `decimalLength` might help, since 99% of the time you get 0 or 1, so maybe do two conditional adds and then a slow path. You don't want to divide `vr`/`vp`/`vm` there either; only `vr` is needed and you can just ignore those places when you print. A lot of earlier places my main concern is "why are you branching?!" more than anything specific (`if (acceptBounds)` is going to mispredict a *ton*). Eventually you end up at concerns like "unaligned writes are slow".
The word "pattern" is usually a shortened form of "design pattern", a fundamental concept in a "pattern language". The key word here is "language", that is, a design patterns empower us by giving us a language for speaking about recurring solution to design problems. This is why design patterns have names, so we can talk about them. An "anti-pattern", likewise, is also related to a pattern language, but in this case, instead of referring to a model we should follow, an anti-pattern describes a model we should _not_ follow. Much like we give names to patterns to create a language around them, we also give names to anti-patterns, so we can talk about them (e.g. we can say "bike-shedding" instead of "over-designing this trivial thing"). Programming design patterns tend to be programming language-agnostic. It is strange to consider something a "C++ pattern", because this implies a solution to a design problem that is unique to C++. Generally, we use the term "idiom" to refer to a language-specific model for good code. Since idioms are not usually part of a larger pattern language, they often lack names, though they can be named (e.g. RAII). There are idioms that we refer to as patterns (e.g. CRTP), but this is the exception rather than the rule. In this case, the common mistakes that are listed are not named, and they are language-specific. I would therefore label them "anti-idioms" (if I wanted to invent a new term), or just "common mistakes".
Not all?
This produces a statement rather than an expression. In the example given (https://godbolt.org/g/qXowwt), the result of FORCE_CONSTEXPR(expr) is returned; the lambda makes this possible.
lmao this guy and his pumpkins
You might find /r/learncpp useful.
Welcome, new programmer. Take a look at: - [Get Started!](https://isocpp.org/get-started) - [Tour](https://isocpp.org/tour)
-1, not enough templates
 std::string s; is ambiguous. Did someone forget to initialize this variable? We should explain this with a comment. //intentionally empty std::string s; This is ridiculous, right? A better way of saying the same thing is: std::string s = ""; With optimizations enabled this won't make any difference. Both lines generate the same code: https://godbolt.org/g/FQ6iwn 
In Herb Sutter's proposal about Zero-overhead deterministic exceptions, I read in between the lines, that exceptions are not welcomed in the long run to sanction contract failures. Will we still be governed by the Lakos Rule in a world were `std::logic_error` is expected to be deprecated?
&gt; I was convinced that I had had found a typo. FTFY &amp;nbsp; Yours truely, grammar nazi with a sense of humour.
Will the presentations be published on YouTube? 
Cinnamon and GNOME 3 actually use a toolkit called Mx (which is based on Clutter). Also DEs differ so much in background processes and other stuff, I doubt that this benchmark can really be used as a comparison of toolkits.
I'm currently using VSCode on macOS and quite happy with it. Very nice UI and fast. And with awesome C/C++ extension (from Microsoft too) you could debug your code same as Visual Studio. The missing feature is detecting memory leak.
I think so.
That's fair, there could be 3 benchmarks: the existing one which parses a packet that contains payload after the TCP layer, one which would parse something like a SYN where there's no data and one that lets the library skip data. I don't know if the rest of the libraries implement this so this may be a pcap++ specific one. I know there's nothing that particularly says what the benchmark is supposed to measure but I presume that if the input is a series of packets that contain a chunk of payload, then the code should load the entirety of it and give you a packet that contains all of the input data, not just a convenient slice. There wouldn't be payload there in the first place if you were supposed to just skip it. 
Sounds nice compared to C++ and MFC.
No it's not. At least, what I mean by quick and dirty tools are small utilities that are written for a very project specific self contained task. In situations where that's needed, bringing in large tool chains for premature automation is the anti-pattern. Why drag in CMake or build system of the week if your tool build can be specified by Makefile? And why use a Makefile if your tool can be simplified enough to be compiled with a one line `(clan)g++ -std=c++17 tool.cpp`?
If you look beyond the default Qt libraries you can also use KTextEditor, which is basically the Kate text editor as a library (and the basis for KDevelop )
long double means it will store it as 80 bit, but I believe that even if you use a float (32 bit), as long as it stays on the cpu it's all in 80 bits (the internal format). You can get some extra speedup setting the cpu in low precision mode. So you can get unexpected precise results.
We had that too üíÄ
&gt; Were other methods of testing assertion failures considered? No, not in n3248. Did we read the same paper? It discussed some possible alternatives, including `setjmp`/`longjmp`.
&gt; but I presume that if the input is a series of packets that contain a chunk of payload, then the code should load the entirety of it and give you a packet that contains all of the input data, not just a convenient slice. I think this is a poor assumption for this class of library - the use case here usually isn't "I'm handling the payload in my app". It'd make more sense to bring the other benchmarks down than to bring this benchmark up.
!removehelp
It's definitely a far more common use case to process the payload of a packet than to ignore it, hence what the benchmark is trying to measure. But fair enough, if this really is that ambiguous then I'll create separate benchmarks for each case.
why do you need the [&amp;] capture?
So what is the question?
IMO, the answer to the question ‚ÄúShould I learn X‚Äù is: yes. Especially this early in your career. I learn all sorts of stuff that doesn‚Äôt directly relate to my job or a project I‚Äôm directly working on, and it has served me well for my whole career. Learning things outside your normal purview only gives you a chance to expand your knowledge and open up new possibilities for you. C++ in particular is one of the most used programming languages. Of course it is useful to learn if you are going to have a career in software.
Actually, the fact that c++ and java handle their memory fundamentally differently and that c++ has templates and java not can have a significant impact on the software design. Hence, having c++ / java/ python / lisp specific patterns isn't that far fetched. It is just that the "original" design patterns where focused on object oriented programming, which of course is applicable to multiple different languages. I share your conclusion though: These aren't patterns but just a collection of bad coding examples.
Depends on your requirements. For many applications, iostreams are just fine.
Addressing everyone asking why i‚Äôm using this framework instead of something like gtest or some other unit-testing framework. For fun I like to reverse engineer C++ classes into there C equivalents while keeping as mush OOP concepts as posable. I wonted to follow along with C++ unit-testing tutorials using C. The unit-test framework header #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include &lt;memory.h&gt; typedef bool Toggle_t; const static char * const _passTestStr = "pass"; ///&lt;Pass cString const static char * const _failTestStr = "fail"; ///&lt;Fail cString const static char * const _UTestVerion = "1.0.0";///&lt;Version number static Toggle_t summaryFlag = false;///&lt;Summary flag value typedef struct { const char * _listLabel;///&lt;Unit-test label uint32_t _numPass;///&lt;Pass count value uint32_t _numFail;///&lt;Fail count value uint32_t _numTest;///&lt;Test count value }SqdUnit; /* --- My programmer appliaction interface --- */ //Unit-test INFO const char * const utestVerion(void); //Create/allocate ( unit-test ) SqdUnit * const createUnitTest( const char * const label ); void initUnit( SqdUnit * const this ,const char * const label ); //SqdUnit: functions void unitTest( SqdUnit * const this ,const char * const description ,const int test ); void report( SqdUnit * const this ); Toggle_t summary(Toggle_t flag); bool testTest(void); //Message: functions void messageLog( const char * const msg ); //Utility: functions const char * const testLabel(SqdUnit * const this); uint32_t passTestCount(SqdUnit * const this); uint32_t failTestCount(SqdUnit * const this); uint32_t testCaseCount(SqdUnit * const this); //Erase/deallocate ( unit-test ) void eraseUnit( SqdUnit * this ); 
I‚Äôm not if I should put all my effort in to C++ or Java, whichever I choose I will devote to all my time to for my last school year and hopefully get a job with. I want to use and learn C++ but I‚Äôm new to it, while I know already know java. So would it be better to just expand my java or pick up C++ and use it everyday for a year? Which is better for my career in the long run, I‚Äôm not sure I‚Äôll have as much time as I have now after school.
/r/cscareerquestions
If you really want to be pedantic, std::string s(std::string());
In case `expr` uses any local variables. As it's just a macro they wouldn't otherwise be captured.
Because it's the best option out of a couple not too great ones. And because they can, in contrast to popular opinion, be quite fast. (I for one cannot reproduce most of the complaints on my Linux, so complain to Stephan if you feel that they are to slow on Windows, not to the standards-committee.)
Maybe add more examples about async with boost::coroutine(2) or boost::fiber or clang's stackless coroutine might make this little book more complete :)
Be extremely careful about anything that you may have signed with your employer about rights to things you code off-the-clock. Unless I get it approved ahead of time by legal, my employer gets to claim any intellectual property rights on things I may have coded on my own time. Your employer may be different.
&gt;The size of text segment of this program when built with the unique_ptr version is 76 bytes larger than the version that uses raw pointers. That's with g++ 8.1.1 and the -Os flag. &gt; &gt;The version that uses raw pointers is 6 lines longer than the other version. However if you consider the total number of bytes of the two approaches, the raw pointers version is only 25 bytes more than the other version. Bytes isn't the most important measurement IMO - while it's worth keeping in mind (it could add up badly over a large program), readability, chance of bugs, and functionality need to be compared also. &gt;the raw pointers version doesn't have to include the &lt;memory&gt; header which amounts to over 7,000 lines on my machine. Honestly, C++ needs to slim some of its headers down a bit! `&lt;algorithm&gt;` is another that seems to contain the kitchen sink. And then list/vector/etc get their own headers instead of their being some kind of all-inclusive "container" header. It's very inconsistent!
lmao this guy and his pumpkins
I might be wrong on this one - but as far as I know and can find, constexpr variables are not actually guaranteed to be evaluated in compile time, only that they \*can\* be evaluated in compile time if needed. This means that the text in the post saying that it \*forces\* compile time evaluation is a bit misleading IMO. I dunno how significant this is in practice, if it will actually happen that constexpr varibales are evaluated in runtime in some cases or if it practically never would... Note the wording here on cppreference [https://en.cppreference.com/w/cpp/language/constexpr](https://en.cppreference.com/w/cpp/language/constexpr) "The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. " Nitpicky, but in a language like C++, details are important
When creating an operator&lt; for ordering, is there a difference between using std::tie as shown in the example and std::tuple?
`tie` returns a `tuple` of references to the arguments you pass. If you used `tuple` directly (e.g. with C++17's deduction guides) you would create a copy of those arguments instead of passing by reference.
&gt; Recommendation: Don't use std::bind to create a std::thread from multiple arguments. This can be simplified to: &gt; Don't use std::bind &gt; Recommendation: Use the default constructor to create empty strings. I'm not really sure I agree with this. The only concrete grounds here are performance. The problem with arguing about performance for something rather small like this is that sometimes it's an issue, sometimes it's not, and many people have a good idea when they're in their critical path or not. The other part of the argument is that it's more code. That's true, it is more characters, but it is easier to read. You should optimize for reading, not writing. I think it's actually slightly easier to read for anyone, because it's more explicit, and more clear immediately clear that it's an empty string. Novice developers (and most teams will have a few of these) don't have to look up the default constructor, and experienced developers don't have to perform the mental access. Certainly, with integers, if I explicitly wanted to initialize an integer to 0, I much prefer `int i = 0` over `int x{}`.
&gt;PcapPlusPlus v18.08 released - a multiplatform C++ network packet sniffing and crafting library The whole purpose of synthetic testing is to control as many conditions as possible and have only one variable, the measured one, be the determinant. If you are comparing packet parsing you need to make the sure that both libraries are doing the same and running with the same input. That is not held in this case, which gives `PcapPlusPlus` an advantage over `libtins` but distorts the results. To do a proper comparison you either need to have both libraries parse the whole packet or look for the way, if possible, to have `libtins` parse only up to TCP. And compare those versions. If it is not possible, a synthetic test like this lacks usefulness to test performance. Imagine a library that would just do a memory copy at parse time and everything else is done at usage time. For this test it would be super fast but it would not be fair for the other libraries and a more holistic type of test is necessary. In my opinion, this test is aiming to expose how performant memory management is when parsing a packet from start to end including all the layer and retaining all the layers.
or std::string s((std::string()));
&gt;Bytes isn't the most important measurement IMO - while it's worth keeping in mind (it could add up badly over a large program), readability, chance of bugs, and functionality need to be compared also. To the best of my knowledge the two versions are functionally equivalent. For example, these two lines: compress=new ::qlz\_state\_compress(); compress(::std::make\_unique&lt;::qlz\_state\_compress&gt;()) both cause the pointee to be zero initialized. I'm not sure the unique\_ptr version has an edge in terms of readability and would again mention the lines above. 
Why wouldn't you name this Sea++? Huge opportunity missed.
Sweet pumpkins.
It's not initialized in the C++ sense, but the idea is to reflect to the reader that you actually want it to be the empty string, as opposed to some value you don't care about to distinguish later. For example, I could get behind a convention that would distinguish these uses: std::string s = ""; for (auto const &amp; thing: stuff) s += stuff; versus std::string s; if (something) s = "foo"; else s = "bar"; and recommend that the objects be initialized as above. (Yeah yeah, "the first example is an inefficient way of doing it" blah blah blah, this is example code. It's an example.)
But CMake is much simpler than Make especially for just a simple executable
Bikeshedding: the name "positive" is a little weird? On the substance, I found it great! I like it a lot from a user POV, and I guess it would map well to how compilers work (the errno part might be interesting, but I guess we've seen more complex things...) \_Catch() introduces "hidden" exceptional code-paths in C expressions, though, which might be considered unconventional from the traditional C POV. Likewise for \_Try() with the extra bonus of hiding a return. It is an excellent thing that _Fails(X) calls must be catched, otherwise refactoring would be dangerous; but with that in place, the whole thing is very reasonable. For prototyping can we somehow construct a TryOrPanic()? Could we also export \_Either(A, B) from std::expected&lt;A, B&gt;? I hope it will be accepted, and thank you for your work! 
Your line of thought doesn't reflect reality ‚Äì this is C++, and default constructors are a thing.
You're kinda right but also wrong. You're wrong because according to C++ constexpr variables must be evaluated at compile time. You're kinda right because C++ doesn't define the meaning of either "evaluate" or "compile time." The compiler is required to know that the answer is "6", but it can generate arbitrarily terrible code to actually get the value 6 into `x` at runtime. A compiler is theoretically permitted to get the value 6 into `x` by generating code for all of `optionally_constexpr_sqrt` and then executing that code... as long as it can prove that executing that code will always produce the correct answer of "6". That would be a really bad "Quality of Implementation" but it would indeed be permitted by the C++ Standard. More realistically, the compiler could load 6 into `x` by generating JavaScript that would be fed to a massively complicated JavaScript interpreter at runtime. emscripten does this. If the value of `x` is used in a template, like `std::array&lt;int, x&gt;`, then a traditional compiler with name-mangling and stuff would have a damn hard time **not** evaluating it all the way at what we intuitively think of as "compile time."
So clearly we shouldn't bother to have conventions about layout or naming or other style issues, because they're all the same to the compiler? I'm not saying I do that, and people should definitely be comfortable reading code that doesn't do that. But at the same time, if the primary argument is that it's redundant, so are tons of *other* conventions that everyone knows are plain common sense (like indenting), and so are tons of other conventions that are commonly followed (like putting braces around single-statement if/loop bodies). If it's that it does something different at the logical level, that's counterfactual. If it's that it produces worse code, that appears to be counterfactual, at least on GCC and Clang with optimization. (Based on TyRoXx's link, `-O1` is sufficient with GCC or libc++ for the "extra" initialization to generate the same code; `-O2` is sufficient with clang and libstdc++.) Writing in a clearer way doesn't necessarily reflect a denial of reality.
i mean... it seems reasonable that you can dabble in fun projects. your wife outright banning it is honestly kinda dumb. plenty of devs have a balanced family life. 
At least on almost every Linux distribution make is already there. 
It basically doesn't have a query planner/optimizer. And whatever the index settings are supposed to do, they sure never seemed to improve performance in my use cases, despite it seeming to me that the data for the relevant queries was highly indexable. Profiling would still show almost all the application time was spent iterating through records, where in my opinion the data volumes were quite small. People mostly use SQLite as a simple serialization layer, for which I guess it's fine. If you actually want to use it as a real relational database with a 3NF schema and sub-queries and everything, you hit problems quickly.
Experienced developers do have to perform "mental access". Every time they see that line, they will ask "why isn't it using a default constructor"? The thing about novice programmers is that they don't stay novice for very long. So coding to cater to novices is pointless. Novices should be expected to look things up if they encounter something they didn't realize.
That's the name of an upcoming text adventure sequel: Open Sorcery: Sea++. (I highly recommend the first one.)
I've actually use `std::tie` in that manner and the compiler just optimizes the tuple away. It can see that the tuple is temporary, and that the members are references, and that once compared, the references are no longer referenced outside of the expression. The compiler can literally just inline the comparisons.
&gt; The role of default constructors in C++ is mostly consistent Initialization in C++ is universally accepted to be a giant mess. I just don't see any downside in being explicit here. The same way I don't see a downside to being explicit with `int i = 0`. At any rate we can agree to disagree but there's clearly no black and white answer here; it's most definitely not an "anti-pattern" (and I wouldn't claim that `int i{};` is an anti pattern either, etc).
Hah, I thought you were joking. Though I was imagining a Zork-like IF game about a C++ programmer who is also a pirate (a sea pirate, not a software pirate).
Looks reasonable to me, given a cursory reading. Separating the `_Either` metatype into a `_Fails` function attribute and an `_Either` sum type is a nice way to make things more straightfoward. Bikeshed: do `_Either`'s variants need to be named `.left` and `.right`? Picking different names (`value`/`error`?) would sidestep the "orientation" question entirely, and neither C++ `std::expected` nor Rust `Result` use those names anyway.
Coincidentally, I am a C++ programmer who wears pirate-eyepatch-glasses. Arrvalue references, matey.
Tragically missed opportunity for someone to begin their response with "C++20 requires `requires requires` because..."
https://gist.github.com/Veedrac/069dd35f896de4df4e14b881a455ca47
&gt; You are the only one talking about performance here - that isnt the issue. TFA talked about performance, and so did TyRoXx when he started this thread. dodheim didn't say what his objection was. I'm guessing it was the syntax part of the "redundant" specification, which is why I made that the primary focus of what I wrote. &gt; Just because it is your preferred style, don't expect it to be universally more readable or clearer for others. Anyway, it's *not* my preferred style, and I don't use it. The reason I jumped in was because, judging by the number of "disagree" buttons that have been clicked in this thread, there are a lot of people who seem to think that even the suggestion of the convention is ridiculous, and I just disagree that's the case.
My objection is that "It's not initialized in the C++ sense" is clearly a falsehood. &gt;_&gt;
Crap, that's just a typo. :-)
21 comment karma per post, I guess
If you want a really trivial (and obviously very easily defeatable) solution, try the start menu's "startup" folder. Type `shell:common startup` into a run prompt to find the generic pathname for this folder (I assume it's likely 'C:\\\\\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup') and have the "malicious" program create a shortcut to it's current path in this folder. If you only want it to be for the current user, I believe `shell:startup` is all you need. Keep in mind that any antivirus program is likely to be listening to these directories, so the act of referencing your program in this folder may or may not result in a quick scan of the referenced file, and, if your file does have some "malicious" code that it recognizes, deletion.
so do I need just need to put the shell::startup into the main.cpp. I understand the code I already have I'm just worried about formatting causing a ton of errors
Hence my query about Firebird. It may suck for all I know. The point is they're both embeddable, which obviates a lot of problems with other solutions.
The issue with the keylogger is it doesn't stay on. Let's say someone downloads one by accident through a fake download. Normally the logger would be activated the first time and have been coded in a way that it works even when you reboot. The purpose of the course is to find a true solution and that turning it on and off doesn't always work. That's why I'm making it like this to add the reality factor in. I did find part of a code that finds the startup folder and found the shell functions to create a shortcut to a folder but I can't figure out how to put them together.
&gt; That's why I'm making it like this to add the reality factor in. So... just to make sure I understand properly, here. You've come to r/cpp, with what seems to be a very bare-bones familiarity with C++, and you're here asking us to help you design a fully functional, vulnerability-abusing keylogger? One that would keep working after being "downloaded by accident through a fake download"? And you're teaching a class on malware, but you don't see a problem with this? &gt;The purpose of the course is to find a true solution A solution to what, exactly? Being able to build your own keylogger? So you're teaching your hypothetical students not 'how keyloggers could work', but 'here is *exactly* how you can, currently on a modern operating system, create and distribute a working keylogger'? If this is a legit post and you're *actually* trying to do this, take this advice: guide your students through a historical piece of malware, one that *someone else* wrote, one that has already been patched out, but one where you can examine how vulnerabilities and malware function "in reality". Without worrying about getting fired. If you're trying to follow through with your threat to hack someone's computer or something like that, take this advice: Don't. It's not nearly as simple as you'd expect, and there's sorta this little issue with it being illegal. Not worth screwing up your life &amp; potentially others'.
The "anti-pattern" was specifically talking about strings. For a `std::string`, it can be an anti-pattern. Apparently only the default and move constructor for a `std::string` can be `noexcept`. Being explicit for `std::string` would be `std::string var{};`. You don't need to go for `= ""`.
Given that C doesn't have destructors I don't like hidden return in `_Try`. It's ok for C++ or Rust which will automatically destruct everything on every return but in C one would want to check that all resources are deallocated before every return and hiding return in `_Try` doesn't help.
Thank you for your time. The keylogger is someone else's and is already written. He just never upgraded it with the function I am looking for though it was stated in his last log that he would but that was over a year ago. I already have the logs on how it was made and how it works. This is a class nothing else. If I wanted into someone's computers there are a lot simpler ways than this method. I do thank you for reading my request. I will find somewhere else for my question. I came here for the reason I don't understand the intricacies of c++. I was hoping someone here could help as you all know way more than I ever will on the subject as it's just not my favorite language. Again thank you for your time. 
Khan Academy has some [intro to programming](https://www.khanacademy.org/computing/computer-programming) classes. You might get a better into to the basics there. You might also want to pop over to the [Cunningham and Cunningham](http://c2.com/) web site and poke around on their wiki. Maybe in the Portland Pattern Repository and Extreme Programming links. The tutorials you've watched probably assume some basic experience with programming in general. A lot of people will tell you that picking up new computer languages is easy, because it's just syntax and the fundamental concepts surrounding programming still stay the same. So if you're familiar with variables, conditional statements, loops, etc, you get a leg up by looking for them in other languages you try to pick up. That's mostly true, although I think many languages can take quite a long time to truly master. As to variable names like "sQuestion" and "sNum", generally languages don't require your variables to be anything in particular. Some people adopt an loose or strict notation (like Hungarian Notation) so they can remember what types their variables are. I'd guess that "sQuestion" and "sNum" are both strings and that one holds a question and the other holds a number in string form. I feel like if you need a notation to help you remember your variable type, your functions are probably too long. And also may be using too many variables. Those guys might even be using global variables in their tutorial code, which you should never actually do. Also in programming, when someone tells you you should never actually do anything, there's always an implied "Unless you REALLY want to." Some of the dinosaurs will explain to you that using a goto really is the best way to break out of a deeply nested loop, and they'll take great delight in using them in their code. So just name your variables sensibly and don't let superstition keep you from things. You know. Unless you really want to.
`std::string var{};` calls the `initializer_list&lt;char&gt;` overload, which is also not `noexcept` (though obviously no sane implementation would throw). ;-]
Why do people upvote them? They've been doing this for a while now.
okay, thanks a lot :) You were pretty spot on, in one video he writes out: std::string sQuestion ("Enter Number 1 : "); std::string sNum1, sNum2; In other words it's like he's writing StandardQuestion and StandardNumber even though he doesn't need to, it could just be written as Question and Number and it wouldn't make a difference, correct? 
So something like `int normal_return = _Try(func(param)) {_ReturnFailure();};` where `_ReturnFailure()` does something like `T failure_return; return failure_return;` (`T` is the failure type from `_Either`)? That way you could also do something like `int normal_return = _Try(func(param)) {goto cleanup;};` and in the `cleanup` label you could then call `_ReturnFailure()`?
+1 for `value`/`error` rather than `left`/`right`.
I always found type prefixes to be silly in strong typed languages like C++. Your code won‚Äôt compile if you misuse them. Though, I found it pretty useful in things like php, js, python. 
juCi++ uses clang to do the indexing of the symbols? If so, I found that SlickEdit IDE is actually 25 times faster to do indexing! We measured clang indexing vs SlickEdit indexing, and SlickEdit indexed an 8000+ file in 35 seconds while clang based indexing took 15 minutes! I've found that for the very large projects that we have in my company, SlickEdit IDE scales the best and is still fast when operating with 10000s of files. This indexing provides the ability to find symbol references across the project, and the IDE is aware of functions, classes, etc. SlickEdit's C++ indexing has been in development for 25 years and has had loads of refinements. Also, SlickEdit is written in highly optimized C++, not a java application like CLion. CLion chokes and is unusable on my 8000 and 30000 file projects that I have at my company.
&gt; I suspect the while (vp / 10 &gt; vm / 10) loop can be done with vp &gt;= vm ? decimalLength(vp - vm) : 0 That's not possible. `130 / 10 &gt; 129 / 10`, but `!(124 / 10 &gt; 123 / 10)`, yet `130 - 129 == 1` and `124 - 123 == 1`. Comparison and subtraction can't notice that the first pair of numbers crosses a tens boundary.
I only meant it as a joke. Of course she isn't banning me. She only suggests that i don't program at home because i already do so much programming at work. You're absolutely right that some people can dabble in projects, but I'm actually not one of those people... I overwork myself and can get overly invested in projects. 
You've got me there, I'm afraid
Pulls in the internet fantasy points.
Have you tried trying?
That's lame
Yeah, I heard about Hungarian code, didn't realize he was using it. thanks for the references :) Someone suggested I start with python, so I did, I'm starting to get it now, although python is a bit more simple, the channel I'm watching is making it easier to understand the Variables, classes and such and sorta how to use them, it wouldn't hurt to interchange them though. Will totally take a look at those channels though.
I found a good improvement for x86 after investigating this area: https://github.com/ulfjack/ryu/pull/66
In the settings you can change the verbosity of the build process, you can get a level of detail that in rather mind-boggling up the the level of calling this function, evaluation this result, oh, not true so I'm gonna do this (or that) etc...
I don't dislike VSCode, but the building you have to set up yourself in json-files (unless I am missing a trick, please comment if yes). Rust also has an integration for VSCode, which is much better as this includes the package manager, the compiler and the build system, all in one (or it looks like one at least).
What does MQT Engine stand for? That's just the name of the discord or it's an ongoing project?
Usually when something can be forced to constexpr, it is either global or is a literal. 
Here, I'll quote a comment from the server: &gt;\[The MQT is the\] Mostly Quoran Techno Engine. Most of us are from Quora, or at least we were! (I and the server's co-creator had the idea for it on there) &gt; &gt;We call it an engine because there are so many of us, all taking in problems and churning out solutions just like a powerful machine. Or- like a search engine, called that because they're massive virtual systems that do a lot of work!
I use [meson](https://mesonbuild.com/) as buildsystem and for the small-ish projects I build so far that works ok. But yes, the tooling of Rust as a much more modern language is a lot nicer than that of c++.
discord is bad
I've seen people advocate for some pretty crazy things, but implicit variable definition has to take the cake.
Okay, but not always, since local variables can also be constexpr.
&gt;C++ ... is no longer used as a general purpose application programming language in new projects where indeterminacy might be more acceptable :-(
Yeah, but how do you know the second string was supposed to be empty? Maybe the programmer wanted to put some text there and just forgot? Better be sure: std::string s = std::string (std::string ()); ;-) 
My bad. I didn't if you were the same person that wrote the first post (TyRoXx). Sorry for that. To repeat my main position: &gt; I don't have a problem with your style, but what's the problem with the first one? I'm certainly not condemning the use of an explicit value for initialization. But I'm heavily disagreeing with the notion that omitting that value makes the intention somehow less clear. Imho it is a pure personal preference. to use one or the other.
Or use braces `string{}`
Assuming optimizations are enabled both versions (hopefully) compile down to the same code for simple types.
Why are you using brackets style for one and = style for the other? Both should work for either. But that's beside the point, you're right that those two lines should be equivalent and the unique_ptr version is a little less readable (the error messages for make unique are also worse). But, if one is 76 bytes larger than the other they aren't identical - unique_ptr is a zero-cost abstraction over exception-safe leak-safe handling of raw pointers, so if the code generation is different I'd suspect an extra check or few is being added somewhere in the program that you didn't have before - it's possible you have a bug that the unique_ptr version has fixed. If you want to be absolutely sure, I'd diff the disassembly and take a look.
The fact that the standard that concepts support requires requires `requires requires` requires people to write in this strange syntax in order to use concepts 
Hah, I hope the solution quality is not lime the average answer quality on quora. So esentially your group is solving other people's problem? For free?
&gt; Notes for Windows users Boost.WinAPI has been updated to target Windows 7 by default, where possible. In previous releases Windows Vista was the default. Moving on, it seems.
If you ask regarding coding style: Unreal Engine 4 itself and the example c++ projects included.
Ah, I see. I'll stop by then, could be interesting.
I'm not sure what you mean. Do you want to learn C++ programming so you can create a game with Unreal Engine?
Yes, but I can't remember every single thing by heart. I need a sheet or a reference guide to look at.
&gt; Say if I want to open up code blockers what is "code blockers" ? do you mean Code::Blocks, the IDE ? Doesn't UE4 come with its own ? &gt; what library for c++ would you recommend what do you mean by library ? In C++, "library" has a very specific meaning, it's a piece of code that you add to your own code to use some functionalities. For instance, an audio library allows to play sound, a math library allows to solve equations, etc. &gt; as a guide for coding in unreal engine 4? UE4 has very poor code style, you shouldn't take it as an example. Instead look at the books here : http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Windows is not my primary OS, and I never tried the unofficial lldb-servers. It's been a year or so since I last looked at this, and maybe there now is an lldb-server available as MSYS2 package? If you figure out how to run debugging on Windows, it would be great if you could post an update on the issue [https://gitlab.com/cppit/jucipp/issues/190](https://gitlab.com/cppit/jucipp/issues/190). Thank you for the feedback so far.
I'd do it, but I don't know where to start from. 
Offtopic question: how is your library is BSD-licenced when FFTW is GPL-licensed? Or do you expect your users to get a commercial license for FFTW?
Pretty reasonable decision IMO. Vista is nearly 12 years old now and it's been out of extended support over a year. You can still force Boost to target Vista by recompiling with `BOOST_USE_WINAPI_VERSION=0x0600`
I was more coming from the other angle, extended support for W7 ends 523 days from now, while mainstream support has already ended 1304 days ago.
Ah I see what you mean!
Mainstream support for W8.1 has also ended (begin this year), so basically it's simple, there is only 1 supported OS, it's called W10, and in all honesty, for the better. I was skeptical at first (I loved W7), but now there's no going back (I have accepted that they listen in when I fart, but they cannot smell them (yet)).
Good point, that is probably true, and may in some edge cases be a reason to use the x87 fpu.
C is not keen on destructors, and in C++, C `_Try` *does* execute C++ destructors. BTW I originally proposed auto-propagation for C `_Fails`, but that was a step too far for WG14. They wanted devs to explicitly write code to propagate failure. I suggested `_Try`, as that's what Rust and Swift and others do, and there was no objection. Ultimately they may wish for something like `_Finally` in C. I can see that being very controversial, many C programmers consider stack unwind cleanup a tool of the devil. And there is a school of thought that C programmers who want stack unwind cleanup simply flip their C into C++ and otherwise keep writing C (GCC is of this school of thought). We'll see how things fare. 
&gt; _Catch() introduces "hidden" exceptional code-paths in C expressions, though, which might be considered unconventional from the traditional C POV A fun idea is to combine `_Catch()` with statement expressions, so in C `_Catch({( statements...; )})` would effectively implement a poor man's exception throwing mechanism for C :) &gt; For prototyping can we somehow construct a TryOrPanic()? Some WG14 members are keen on importing C++ contracts into C. Those would be ideal for panics. &gt; Could we also export _Either(A, B) from std::expected&lt;A, B&gt;? It depends on what implementation is chosen for `_Either(A, B)`. If compiler magic, I don't know. If a proper type synthesised by a macro, it's doable. &gt; EDIT: one last question: will _Either(A, B) have its memory layout standardized? Most types in C are. I have in mind: struct _Either_ ## A ## _ ## B { union { A left; B right; }; _Bool positive; }; But again, it depends on choice of implementation, and that needs committee time to decide. 
reasonably, what is the interesection of the two following sets in 2018: - people using the latest version of boost - people deploying apps in windows 7 by default.
&gt; Bikeshed: do _Either's variants need to be named .left and .right? Picking different names (value/error?) would sidestep the "orientation" question entirely, and neither C++ std::expected nor Rust Result use those names anyway. WG14 want a generalised sum type, hence the `.left` and `.right`. value/error is more pejorative, plus it clashes with `std::expected` where `.value` and `.error` are member function pointers :) 
One would have to install lldb: `pacman -S mingw-w64-x86_64-lldb`. Then rebuild/recompile juCi++ from scratch to enable debugging. After that one would need a working lldb-server. 
I *knew* it when I chose `.positive` that that would raise the most bikeshedding! I would say that the Haskell sum type treats the right branch as more positive than the left branch, simply because right is good and left is sinister. However, Rust and C++ have inverted that ordering, for better or for worse.
Dunno, you?
I actually just created an issue for that: [https://github.com/egpbos/xtensor-fftw/issues/36](https://github.com/egpbos/xtensor-fftw/issues/36). If you have any thoughts, don't hesitate to put them there :) My original thoughts were that the source code itself would be BSD licensed, but that any compiled code that also links to fftw should be GPL'ed. The way I understood things, this is legal, since I have the copyright to my code and so I can license it in whatever way I like. However, I'm now thinking that this is a bit misleading, especially since the BSD license also mentions "spreading in binary form", which means that it can only be legally spread in binary form without linking, i.e. only the object files... which nobody does. I personally don't spread the code in binary code at all, since it's a header-only library, so I think I'm still within my rights. ... but yeah, it's a good question, and I'm looking for a good answer :)
I'd say it's the empty set
We agree then.
To be fair, I think, Robert R. has not ignored this issue, but it's apparently more complicated (or at least he seems to think so).
I don't get the difference. How is assigning a constant expression to a constexpr variable not returning the result of the expression? In both cases you're evaluating a constant expression and getting a value out of it constexpr'ly.
| The hope is that we can reach nearly perfect mapping That won't really matter if the resulting C is something most C developers would refuse to use. I fear what is being proposed would split the C language. I see the benefits for C++ in changing C here, but not the benefits for C programmers - who have largely already worked around the mentioned issues, largely by ignoring the functions mentioned as having side effect issues and using better replacements not in the standard libraries.
What I'm getting at is that nowhere in the definition of a constant expression says that constant expressions HAVE to be evaluated at compile time. Only that they can if needed.
Interesting reply, thanks. Does the standard even mention"compile time"? I though it only talked about "constant expression" which are possible to evaluate in compile time. 
Unfortunately, I don't know enough to help you there. &gt; but that any compiled code that also links to fftw should be GPL'ed Maybe this is the case, I am a little confused here. 
Id go back to 8.1 if i could. Sick of 10 "forgetting" my settings and ignoring group policy to install an update behind my back.
No experience with any forgetting (maybe after an update, not sure), the updates are relentless though, I fully agree with you there.
As with C++, the C standards committee tend to have different priorities to the user base. I posted the above paper last night - so far WG14 reflector feedback has been very positive. So far they seem to feel that apart from naming (as always), and perhaps a more functional style for the observers, the proposal meets what they are looking for. The reflector is not the committee of course. But I have noticed a change in WG14 focus in recent years. They now see themselves as the glue language binding all branches of C together onto the C tree. That's a reasonable strategy for a forty year old language ecosystem which probably doesn't see much brand new code written in it any more, and of course an awful lot of C code is nowadays compiled in a C++ compiler, with occasionally bits of C++ getting used on an otherwise essentially C code base. It's a multi faceted world out there.
&gt; Although they were employed for many years, they aren't the kind of "successful" I was thinking of. Sounds like they were successful in some sense.
For me personally the greatest thing about Win10 is that it made me switch to Linux. Very happy about that.
Sorry, I am giving up. It seems there is a problem with pacman on Windows 7/64-bit.
&gt; It [C++] is no longer used as a general purpose application programming language in new projects where indeterminacy might be more acceptable... Do you have any proof for this? Is it really no longer used by anybody? If it is your opinion, please, either remove that paragraph or paraphrase it to something like "I no longer use C++ as general purpose application programming language".
Is there a link to the issue somewhere? I've a fair bit of experience with these kind of issues and maybe I could help.
This was my first book as well, and the only thing I can recommend you is to start writing programs.
I know what a unique_ptr is. It's still considerable overhead (although considerably less than a shared_ptr). If you want to use RAII, wrap it in a unique_ptr, with your custom deleter. But don't force me to use it. 
No, you should just program something instead. It's the best way to learn.
Isn't C still the dominant language used for programming microcontrollers?
Stop reading. Start doing. I had to learn that the hard way. Source: background in mathematics, used to have a bad habit of ‚Äúlearning all I can before applying it‚Äù. Bad habit. Don‚Äôt take it to the other extreme though, that‚Äôs also bad. I mean, keep learning, just learn while doing (and learn by doing). 
If you search the archive of the boost dev mailing list you must be able to spot it, certainly not longer back then 2 months I would say (from memory).
Certainly. That's why I provided a more detailed explanation of what I was saying by "successful".
Yes. But it's not entirely a standard C, and usually only a partial C11 (or C99!) at that. Indeed, the whole `_Fails(errno)` proposal is being smiled upon because it means that the requirement for implementing TLS can be avoided, and that makes standard C much more widely usable in embedded systems. Also everybody is aware of how much work WG21 is investing in taking over the space currently occupied by C so it becomes the de facto choice for all reliable and embedded systems in the future. Hence the heterogenous and low latency study groups et al. C is aware of this too of course, and while a minority dislike it, I would say there is a majority which doesn't find too much issue with C being compiled with a C++ compiler and it is down to the discipline of the developer to not use the C++ features which C folk dislike. GCC's source code is a good example of this. My personal aim is to get standard C++ to a point where Linus will permit the Linux kernel to be compiled with it. My current hope is for C++ 26, but 23 may tip us over for the Windows and FreeBSD kernels at least. We'll see how it goes.
They have not inverted that ordering, because they don't even use the left/right naming. ;) Another way to think of it is that, in a left-to-right language, left is associated with the first numeric value in the discriminant- 0. This then fits in well with mnemonics such as "0/false for failure, 1/true for success" as well as discriminant elision optimizations around non-zeroable `right` values.
Well, as it happens, WG14 also don't like the naming. Semantics are fine, naming not. So it'll probably see yet another iteration on naming. Yay.
Your statement can certainly [not be denied](https://www.netmarketshare.com/operating-system-market-share.aspx?options=%7B%22filter%22%3A%7B%22%24and%22%3A%5B%7B%22platform%22%3A%7B%22%24in%22%3A%5B%22Windows%22%5D%7D%7D%5D%7D%2C%22dateLabel%22%3A%22Trend%22%2C%22attributes%22%3A%22share%22%2C%22group%22%3A%22platformVersion%22%2C%22sort%22%3A%7B%22share%22%3A-1%7D%2C%22id%22%3A%22platformsDesktopVersions%22%2C%22dateInterval%22%3A%22Monthly%22%2C%22dateStart%22%3A%222017-08%22%2C%22dateEnd%22%3A%222018-07%22%2C%22plotKeys%22%3A%5B%7B%22platformVersion%22%3A%22Windows%207%22%7D%2C%7B%22platformVersion%22%3A%22Windows%2010%22%7D%2C%7B%22platformVersion%22%3A%22Windows%208.1%22%7D%2C%7B%22platformVersion%22%3A%22Windows%20XP%22%7D%2C%7B%22platformVersion%22%3A%22Windows%208%22%7D%5D%2C%22segments%22%3A%22-1000%22%7D).
Type argument order is not tied to variant naming. That's why we have names in the first place- one step above tuples :P
I hope you'll find it fun! There 350+ tech people just waiting to meet you!
The relevant build tools aren't... and since you likely have to install them with a package manager, adding 'cmake' isn't particularly hard.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/95wgg7/if_ive_completed_programming_principles_and/e3wcewv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I've always wondered how this works when you're traveling, just need to send one email, and instead get a gigabyte download down your 19k2, $10/MB pipe. It's basically what's stopping me from considering a new laptop with Windows 10.
\*\*Company:\*\* [Susquehanna International Group, LLP](https://sig.com/technology/) (aka SIG) \*\*Type:\*\* Full-Time \*\*Description:\*\* At SIG, we build some of the most powerful trading systems in the financial markets. Our developers work on low-latency applications that drive our trading. We focus on performance and optimization, while bringing our ideas into production quickly. \*\*Location:\*\* Philadelphia, PA \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Yes \*\*Technologies:\*\* We look for the best technology to build optimal solutions. We mostly work with C++11 /C++14, with some C++17. Development is done in both Linux (GCC/Clang) and Windows (MSVC), with various build system (CMake/Makefile/Ninja), and CI integrations. Typical libraries are Boost; RapidJson; Google Protobuf, Test, and Benchmark; and Python integrations. Our engineers usually choose their own development environment. \*\*Contact:\*\* [zanaya.wagner@sig.com](mailto:zanaya.wagner@sig.com). Find out why people love working at SIG [here.](https://www.sig.com/about/beyond-work-benefits/)
The new YAP library for building expression templates looks really interesting.
&gt; GIL: &gt; &gt; - The I/O extensions have been entirely rewritten. &gt; - The library now requires a C++11-compliant compiler. Just calling attention to this since I've seen so many people here call GIL dead/unmaintained.
This was explained to me sometime back, so I'm not sure I remember the details perfectly, but the short version is that `constexpr` variables don't _have_ to be evaluated at compile time; the only requirement is that the variable is usable in a constant expression. The compiler thus is free to decide that a `constexpr` variable's initialization expression only needs to be evaluated at compile time _if_ it is actually used in a context that requires it to be evaluated, e.g. in a non-type template parameter or the like.
&gt; Visual C++: 7.1, 8.0, 9.0, 10.0, 11.0, 12.0, 14.0, 14.1 I wonder if that includes the 14.11, 14.12, 14.13 and 14.14 toolchains?
They have to be constant initialized. They can be used outside of constant expressions. 
Slowly. An hour or so every morning as a warmup :) Making good progress though. Just a heads up, there's going to be a small change in template parameter equivalence. The current wording doesn't account for associated constraints on template template parameters. 
You can mark connections as "metered" (i.e. charged by the byte) and it stops most silly background updates unless you never connect to home for a couple of months.
I was planning to work on this for a GSoC project a few years back, but boost was denied funding that round. Glad to see someone else has taken up the reigns and done something with it!
&gt;many C programmers consider stack unwind cleanup a tool of the devil why?
Something strange is going on - I added a couple of counters to see how many times the ‚Äúcommon case‚Äù is reached, and how many times my new loop is true - but I see zero occurrences of the common case (so of course the loop is zero)! Yet I observed a perf improvement with the (known-inaccurate) benchmark; perhaps codegen side-effects? I also know that f2s‚Äôs common case is executed because I damaged its correctness. Do you observe d2s‚Äôs common case executing?
Yes, I can't give the numbers right now (not at home) but IIRC it was something like Executed 0 times: while (vp - vm &gt;= 1000) { // Optimization: remove three digits at a time. roundUp = (vr % 1000) &gt;= 500; vr /= 1000; vp /= 1000; vm /= 1000; removed += 3; } Executed 0 or 1 times, about 40/60 split?: if (vp - vm &gt;= 100) { // Optimization: remove two digits at a time. roundUp = (vr % 100) &gt;= 50; vr /= 100; vp /= 100; vm /= 100; removed += 2; } Executed roughly 0-6ish times, distribution roughly 1/100/200/50/20/10/5 while (vp / 10 &gt; vm / 10) { roundUp = vr % 10 &gt;= 5; vr /= 10; vp /= 10; vm /= 10; ++removed; } 99% sounds about matching my numbers.
Ah, I messed up the `extern "C"` linkage. Yes, I appear to confirm your results. I believe I was confused by trying insufficient variations - IIRC I added the 1000-loop at the same time that I converted the 100-loop to an if. I suspect the latter was the true win. Continuing to investigate...
Right, so in what situation would you want to force an expression to be constexpr, and not use the resultant variable in a compile-time evaluated context, like a non-type template parameter? Actually, I've recently gotten into the habit of writing a `static_assert` for every definitely-constexpr variable I create, since we may as well have the compiler check itself now that it's possible, and that does force the variable to be evaluated at compile time. So the use case for this macro doesn't seem to exist.
Nice.
You'd have to ask them, but I believe they feel it offers insufficient fine control of deallocation, and is just a bad form of garbage collection. I'm not exactly sure to be honest. I've never understood that argument.
I hate how the standard library uses std::pair extensively which leads to unreadable code, having to write `.first` and `.second` instead of meaningful names in the given context. Please don't repeat this error with your proposal. The generalization can go only so far before you lose the semantics.
Basically, if you're serious, you have to weigh "obvious shortcomings" with the primary shortcoming of every single other embeddable database: puny test coverage. Or, to paraphrase: if you care about the data surviving if it at all has a chance to begin with, you'll use sqlite. If you care more about other stuff, you can use other embeddable databases... The survival of the data was put as the guiding principle of the design and testing, at the expense of everything else, but then if you're using it as a database to store non-constant data, presumably you care about the data being there at some point in the future, uncorrupted. It all depends on how much you care about the data, but I wouldn't call it "cultish". Some people just care about their data...
You have to be careful. But basically, any non-trivial global objects should never be used (prior to 17). Instead, you should create a function static local, and return a reference to it. This should work through any combination of static and global linking. This approach is lazy by default, but you can make it non-lazy while maintaining correctness (though you have to be careful).
Further improved, with control flow stats like what you measured: https://github.com/ulfjack/ryu/pull/67 Given the percentages, I expect/hope that this will be a win after considering branch mispredictions - `if (vp / 100 &gt; vm / 100)` is true ~86.2% of the time, then the following loop usually never executes (70.6%) and otherwise almost always executes exactly once (27.8%).
Go on..... You can tell callgrind that you only care about certain sections??
Normally this would to under /r/cpp_questions Quick fix: you could set the `LD_LIBRARY_PATH` on the same command line, for example: LD_LIBRARY_PATH=/home/siddharth/Desktop/new/include ./xyz 
thanks a lot it finally works!!!!!!!!!!!!!!!!!!!!!!
I agree, but, will you be upgrading your products to boost 1.68 ?
You could check out examples on cppreference.
Show singleton failure: https://github.com/boostorg/serialization/pull/110 Show crash described: https://github.com/boostorg/serialization/pull/111 Fix for both: https://github.com/boostorg/serialization/pull/105 Note that I started with the last and factored out tests showing the 2 bugs separately in an attempt to make it easier to understand.
Hello singleton! Yes you are right and using a static local is part of my fix, but also part of the commit introducing the crash again due to destruction order: Those singletons access each other in their destructors but the order of them becomes messed up for shared libs and the function `is_destroyed` is broken.
Judging from the mailing list the latest MSVC compilers were tested for at least some libraries (there was a last minute issue due to a bug introduced in the then-latest compiler but fixed in the next after beta release of boost)
&gt; Or that metaclasses, which seem to take the approach of giving a specific return types to functions Do you mean encoding meta information on the function by the way of its return type, so that it can be inspected in the metaclass generation ? Etiher way, do you have a link ?
Page 37: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0707r3.pdf the proposed syntax is : QClass MyClass { property&lt;int&gt; value { }; signal mySignal(); slot mySlot(); };
I don't have the means to use Linux together with Windows at the moment.
C++ relies on the basic mechanic that everything it actually needed to compile something has already been defined, with the proviso that it won't require anything it doesn't need. When compiling a method which calls A-&gt;SomeMethod(), the compiler needs to know whether that is a call to a late-bound method or not, and thus whether it can possibly inline that call or jump to a specific location to run the method on this instance of A. If it hasn't already compiled A, then it does not have the pieces of information it needs there - it is in the declaration of A and its methods that we would find out whether SomeMethod was declared virtual or whether we can inline it, etc. So the problem in this setup is that to compile the methods of A we already need the declaration of B's member variables and methods, and vice versa. So the basic resolution is to firstly forward-declare A and B, thus permitting the compiler to accept the declaration of B and A along with the declaration (but not definition) of the methods. That is enough for the compiler to know what all the types and address offsets of the variables and methods are, so then it can proceed to compile the definitions of the methods of both classes. For the compiler to cope without this ordering, it would need to defer actual compilation of all the methods until after all the source files had been read, then perform graph decomposition on the whole source code. That's difficult but tractable, but when you add in things like templates and macros it becomes impossible; you would need both the graph of declarations and also the state machine of the macro and meta-programming system as it was when each declaration or definition was encountered. Even if such a thing was possible, it would break for really unfathomable reasons; you change one dependency somewhere and suddenly for no apparent reason your compile time multiplies and you get a warning about some unrelated type declaration somewhere else. C++ is not the language for those kinds of things. C++ works on the basis of predictability; if you write this legal C++, all compliant compiler implementations guarantee you will get xyz. Compiler optimisations, for example, exist in a magical world of changes to your code that do not violate any of the contracts that were made with you; they are smart within very specific confines. If you want a system which will intelligently interpret what you wrote and construct things to assist you, C++ generally points you to other languages for that. It's never meant to surprise you, for better or worse.
&gt; Dynamically allocating std::thread objects I have seen dynamically allocated vectors too. Many just don't get the point of containers, don't understand "you should use vector" and end up with vector pointers.
Don't forget IoT and the rise of embedded.
I was mostly objecting to that you state that it was ignored, it wasn't. The way I understood is that Robert was going to have a look at it but was busy so could now not dedicate time to resolve the issue (investigating it himself) before the release of 1.68, so he left things as they were.
While I agree that properties/attributes are useful, and I feel they would reduce boilerplate if we had them in C++, there are a number of problems with your argument: First, the C++ example you give uses Qt, whose meta-object compiler (moc) and signals/slots mechanism predates modern C++ by decades (Qt itself predates the original ISO C++ standard!). So this is not a good example, because they use macros and a code generator to remain backward-compatible. Second, you've conflated signals/slots with properties/attributes. These are related only insofar as there happens to be a changed signal on the property you've defined, but this isn't a fundamental feature of properties. Third, metaclasses have nothing to do with return values of functions. The idea, afaik, comes from smalltalk (https://en.wikipedia.org/wiki/Metaclass#In_Smalltalk-80). A class's metaclass is the class's class. In C++ a class does not have a class, because a C++ class is not an object (it is not an instance of a class). So the Qt guys imlemented smalltalk-like metaclass semantics in C++, which adds additional run-time type information to the class (http://doc.qt.io/archives/qt-4.8/metaobjects.html#meta-object-system). It is possible in modern C++ to do much of this without the use of macros or an external code generator. Here's a quick and dirty (probably buggy) implementation of the Qt signals and slots example (http://doc.qt.io/archives/qt-4.8/signalsandslots.html#a-small-example): #include &lt;iostream&gt; #include &lt;functional&gt; #include &lt;vector&gt; template&lt;typename... Args&gt; class Signal { public: using slot_t = std::function&lt;void(Args...)&gt;; void emit(Args... args) const { for (auto &amp;&amp; slot : slots_) slot(args...); } void connect(slot_t &amp;&amp; slot) { slots_.emplace_back(std::move(slot)); } private: std::vector&lt;slot_t&gt; slots_; }; template&lt;typename T&gt; class Property { public: Property(T &amp;&amp; value) : value_(std::move(value)) { } T &amp; operator()() { return value_; } T const &amp; operator()() const { return value_; } void operator()(T const &amp; value) { value_ = value; changed_.emit(value); } using Changed = Signal&lt;T&gt;; Changed const &amp; changed() const { return changed_; } Changed &amp; changed() { return changed_; } private: T value_; Changed changed_; }; class Counter { public: Property&lt;int&gt; value { 0 }; }; int main() { Counter a, b; a.value.changed().connect([&amp;](auto value) { b.value(value); }); std::cout &lt;&lt; "a=" &lt;&lt; a.value() &lt;&lt; ",b=" &lt;&lt; b.value() &lt;&lt; std::endl; a.value(12); std::cout &lt;&lt; "a=" &lt;&lt; a.value() &lt;&lt; ",b=" &lt;&lt; b.value() &lt;&lt; std::endl; b.value(48); std::cout &lt;&lt; "a=" &lt;&lt; a.value() &lt;&lt; ",b=" &lt;&lt; b.value() &lt;&lt; std::endl; } One line of code to get a property with a changed signal, no macros. 
Binary compatible (of the resulting library file) doesn't mean it will compile on a specific compiler version without errors. Code can compile on 14.13 and fail to compile on 14.14, yet the resulting object files (if they could be compiled in the second case) would be binary compatible.
&gt; So this is not a good example, because they use macros and a code generator to remain backward-compatible. I provided an example using verdigris (https://github.com/woboq/verdigris) which absolutely breaks source compatibility, and still have to use macros, due to the lack of reflection &gt; Second, you've conflated signals/slots with properties/attributes. These are related only insofar as there happens to be a changed signal on the property you've defined, but this isn't a fundamental feature of properties. I am just giving an useful example of use of properties / attributes. Of course you can use them for N more things, but in this precise case, this post is an example of making the attributes useful. &gt; Third, metaclasses have nothing to do with return values of functions. yes, but that's how Sutter proposes to encode the signal / slot information with metaclasses in the Qt case - I posted a link to the metaclasses paper with the relevant section. &gt; It is possible in modern C++ to do much of this without the use of macros or an external code generator. Here's a quick and dirty (probably buggy) implementation of the Qt signals and slots example This implementation is only superficially useful. A big point of Qt signals &amp; slots is that the context is unique and part of the enclosing object, not of each signal / slot / property. In your case, the context will be duplicated in each std::function, and you will pay the cost of a virtual call every time if you're not in a trivial case that LTO is able to optimize, since it's how std::function implements it. Since properties are stored in struct with their signals, you loose the ability to pack your properties in memory as you want, and you will have N dynamically-allocated arrays for storing your signals's callbacks instead of one. In addition, Qt signals are thread-safe - you can send signals from multiple threads to the same object in Qt, because signals are serialized in the object thread's event loop. This has no per-signal additional cost in the Qt case, but in your case you would have to store one additional pointer to the event loop *per-signal*. Finally, you're paying the large cost of template instantiation for every object, and loose source compatibility: pointers to properties are not convertible to pointers to the underlying value, assignation won't work the same due to the different overload rules for templates vs non-templates functions, etc. So no, your solution isn't in any way a viable replacement for Qt signals.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; There's no guarantee that binaries build with different toolchains will work together. That simply depends on what the toolchains promise you. E.g. binaries generated with VS2017 are compatible with ones generated with VS2015 and afaik clang claims to be compatible with VS too (of course, all tools can have bugs) . And I have read the linked email thread (actually long before this version of boost was released) and if I read it correctly, there is already a bugfix. It just hasn't been merged in time. &gt; 'Sometimes tricky' is quite a euphemism. You might say that. On the other hand, people have used shared libraries for decades now, so it is very much possible (just as they wrote multithreaded programs before c++11 btw.). I just want to be very clear about one thing the people seem to forget nowerdays: What does and doesn't work doesn't (directly) depend on some text in a piece of paper, but what your toolchain actually does. Now ideally, your toolchain implements the specification written down in one (or more) of the c++ standards, but that doesn't mean that anything outside of the standard just works "by accident". In fact, the whole process of getting from c++ code to an actual binary executable on a real system is outside of the standard. It works (or at least should work) if the documentation of your toolchain says it works. So just because your program does something that isn't defined in the ISO c++ standard it isn't automatically undefined on the particular platform you are using it on. And also the reverse is true: Just because your program is 100% pure ISO c++ code doesn't mean it is portable, because few (probably no) compilers actually implement the standard 100% bugfree (although the situation nower days is certainly much much better than 10 years ago) and e.g. on many embedded systems you deliberately don't get a 100% conforming runtime environment (e.g. disabled exceptions/RTTI/thread local memory) That is what I meant when saying &gt; Lets not pretend a c++ program is compiled by a staple of papers. 
&gt;it is also possible to schedule the pending restart to up till a week But when that time comes it will just force a reboot without asking. So tough luck if you had any unsaved work and failed to keep track of exactly when the reboot was sheduled. (At least it did in recent versions) 
Modern C++ has done a pretty good job of helping separate execution from data, and now we would be faced with something that would conflate the two. Is it really so hard to put () after a symbol? Having used properties in C# and Javascript, I think they are a nonsense nightmare. Suddenly you don't know if you are triggering other execution and larger updates to state instead of just copying or moving data from one place to another. Not to mention that I can't figure out what it actually buys. If you want to be tricky, return a small struct that contains a pointer to the class and have it change the larger class with its operators. 
He is a professional casual. Its like +1 -1... Hot and Cold... In And Out... Up and Down... Lalalalala
I think this pattern comes from C itself, the value of an uninitialised int is undefined behaviour since the rule is "when in doubt, do as the ints do" people assume that the value of an uninitialised string is undefined behaviour.
I'll just add that the C++ standard isn't even the only stack of papers of standardeze that might apply, so it's not even necessarily your toolchain. The obvious example here is POSIX, which nails down a number of behaviors that the C++ standard leaves open.
Look at Unreal Engine it has beautiful UPROPERTY
Wouldn't checking for NaN be faster than running sqrt? 
[C++ Primer](https://www.amazon.co.uk/C-Primer-Stanley-B-Lippman/dp/0135161797) is getting one, too. I can't find more information about either of these specific releases though.
Thanks. I can see you have exposed a ref to a vector with all the sinks, which I suppose is the way to manage sinks, right? To me it is kind of breaks incapsulation, which is not nice. But I guess you have done that to avoid sync'ing inside spdlog to reach high figuers. One question though, assume sync mode (messages are delivered to all sinks as they submitted), how do you ensure "thread safe consumtion" by sinks? This is relevant even for trivial sinks like console (without sync'ing messages may mix if submitted by different threads). For async mode this is irrelevant cause sinks are fed by a single thread.
For me it depends on how you setup your contracts. Do you want the caller validating the input, or are you fine going as far as possible with bad or half-bad input? Usually, I would advise the first solution: Fail Fast and Hard.
We don't dis-agree.
The NaN case specifically, GPU's have historically not handled that well. I've had drivers crash (old days), to drivers giving corrupted output, and some handling it just fine. Something that makes it clear to the programmer what would be an error situation (even if it works most of the times), is better than the program going into an undefined state and hoping for the best. This is doubly so worse for newcomers to the language that now have to learn the hard way, or possibly learn something incorrectly because it has always worked on their machine.
This is a nitpick, but shouldn't it be `s += thing` rather than `s += stuff`?
I like this because it matches with my philosophy of comments, which is that "if a comment can be expressed in code, express it in code". This expresses the intent perfectly in a way that all C++ programmers should understand.
This still relies on the (correct) assumption that the default constructor of std::string produces an empty string.
Calling a function with arguments violating the contract is straight up undefined behavior, not a failure. (note that I am referring to contracts in the C++20 syntactical sense, not the general concept of contracts). Unless I can somehow guarantee that a `float` is non-nan, at that point during computation, I HAVE to nan-check the value before invoking `sqrt()` or any other function that has a contract on a float value (unless it has a `|| isnan(x)` as part of the contract I guess), otherwise the program is not valid. 
No. See [non-intrusive json_io](https://bitbucket.org/sobjectizerteam/json_dto-0.2/src/default/#markdown-header-non-intrusive-json_io) and [user-defined IO](https://bitbucket.org/sobjectizerteam/json_dto-0.2/src/default/#markdown-header-user-defined-io) (for most complex cases).
The unreal engine had a preprocessor to do some the it‚Äôs magic. Eg if you don‚Äôt start certain variable types with the correct letter, they won‚Äôt be usable to UE.
Ok, I understand better your point. My point was that `[[expects x &gt;= 0.0]]`or `[[expects x &gt;= 0.0 || isnan(x)]]` are simply two different philosophies. But Soon(tm), you should have a static analysis tool that, if you use `[[expects x &gt;= 0.0]]` and call the function without an `[[assert x &gt;= 0.0]]`*, then you'll get a warning. In other word, a callee pre-conditions can and should be checked using the caller post-condition/invariant. * `[[assert x &gt;= 1.0]] should be ok too.
What's going on with something like this? Are there actual execution/instructions being run on every function call due to an attribute? 
It can (but probably won't in release builds), but it does allow the compiler to assume that the predicate is met when it compiles the function. Letting the compiler makes these assumptions makes it so that calling the function with arguments not matching the predicate lead to undefined behavior.
I think listing the types of container you support is the wrong way to go about this. If you want to expand the feature in such a way, it would really need to be able to easily support user-defined containers, either through an iterator-based interface, or a trait type.
Good point, thanks. I thinks there is a huge difference in usability difference between: auto data = from_json&lt; std::deque&lt;Data&gt; &gt;(json_doc); and: std::deque&lt;Data&gt; data; from_json(json_doc, std::back_inserter(data)); The first one is less error prone (IMHO). May be the library should support both approaches.
It's hard question. First of all we didn't know about this library when we started json_dto. We used RapidJSON for some time and decided that amount of work required for (de)serialization can be significantly reduced. Because of that we created a thin wrapper on top of RapidJSON. It's hard to say what could happened if we used nlohmann::json instead of RapidJSON. As far as I can see nlohmann::json is like RapidJSON -- uses similar ideas but with very different API. It means that usage of nlohmann::json library will be similar to usage of RapidJSON. You parse your JSON-doc and then you should extract values you need, check their types, check their values and so on. I think you will write the same actions but with different syntax. May be this syntax more terse. But you have to do the same actions. Because of this I think that if we was using nlohmann::json we would write the similar wrapper but on top on nlohmann::json instead on RapidJSON.
A big part of nlohmann is how clean the syntax reads in actual use. The ADL templates to automatically handle most container types are also very useful. It benchmarks very well: https://github.com/miloyip/nativejson-benchmark 
I speak about code like that (from nlohmann::json README): using nlohmann::json; namespace ns { void to_json(json&amp; j, const person&amp; p) { j = json{{"name", p.name}, {"address", p.address}, {"age", p.age}}; } void from_json(const json&amp; j, person&amp; p) { p.name = j.at("name").get&lt;std::string&gt;(); p.address = j.at("address").get&lt;std::string&gt;(); p.age = j.at("age").get&lt;int&gt;(); } } // namespace ns I don't like to write code like that. To many repetitions. I prefer to write something like: namespace ns { // a simple struct to model a person struct person { std::string name; std::string address; int age; template&lt;typename Io&gt; void json_io(Io &amp; io) { io &amp; mandatory("name", name) &amp; mandatory("address", address) &amp; mandatory("age", age); } }; } But this approach can be easily implemented on top of existing nlohmann::json API.
According to [https://en.cppreference.com/w/cpp/numeric/math/sqrt](https://en.cppreference.com/w/cpp/numeric/math/sqrt), std::sqrt() is currently defined to return NaN if the argument is NaN or negative. I doubt Sutter intended to change the std API, so he either got the precondition wrong, or he was thinking of some user-defined version of sqrt() with different behaviour to the standard. Documenting that different behaviour in a testable way would be a good thing. Most likely he just used a poor example. We know what he means, but in practice sqrt() wouldn't have a precondition like that for the reason you give. The result of std::sqrt() is defined for all values of its argument.
Thats quite smart. It reminds me of a similar idea used in the boost::serialization library.
I think OP is talking about 1000+ lines of code per function
Yes, boost::serialization was used for inspiration.
Technically, if you don't want the iterator approach (which is the sanest IMO) it's also possible to return a proxy type that uses the implicit cast operator to accept any container (if they meet the container contract I.e. reserve(), push_back() available)
Right, the example is indeed poor, but I believe it still illustrates how this idealized view of contracts is at odds with the propagating nature of NaN values in general. I've added another, more on-point example to the OP to illustrate how It feels like contracts seem to have very little value unless we start treating Nan as having undefined behavior.
In fact, the _whole point_ for the existence of NaNs is to allow chains of computation to behave in a predictable (albeit nonsensical to the untrained eye) way even in presence of invalid input. Heck, the standard (the IEEE-754 standard, that is) even explicitly differentiates between ‚Äúquiet‚Äù NaNs (go through) and ‚Äúsignaling‚Äù NaNs (possibility to raise exceptions etc).
Are you implying that interbase/firebird are known for losing data? That sounds unlikely to me.
Given the ability to overload `operator=` and/or `operator T`, it's entirely possible for something like `a = b;` to involve arbitrary amounts of computation. Properties don't change that. On the other hand, that also means they add nothing you can't do (better) without them either. In nearly every case, a property is a mistake not because it might be doing unexpected computation, but because you're defining a variable as having one type, when you really want it to have some other related type, whose invariants are enforced by its accessor/mutator. In such a case, the right move is not to use an accessor and/or mutator, but to define the type you really want, and then use it directly. And yes, it might well (probably will) overload `operator=` and `operator T`. Such is life.
The usual way - by using mutexes. 
Disabling via group policy still works fine in Win10 Pro.
I hope compilers will have a flag to create assertions using contracts. Speed is always appreciated, but creating UB can be quite time consuming... 
I believe you are thinking of denormalized floats, those run very slow indeed, at least on on intel
I'm waiting for this for a long time.
Small nitpick, it's not undefined behavior, it's an ill-formed statement. Undefined behavior will compile, it just won't do anything like you'd expect.
Obviously this is great, but I think focusing on making the program faster and more user friendly with the current tools might be a little better of an idea than introducing more features. CLion has too many problems right now that need serious work within the current tool set. If CMake is one of the reasons those problems exist, then maybe this is a good use of time now because this kinda allows you to bypass it, but if it isn't, then how about massive improvement in CMake tooling and completion, as well as some serious thought about why CLion is massively slower at code completion than a number of competitors. Whatever is wrong with code completion is likely the same thing that spins my fans at a million rpm and eats "360%" of my processors. And yes, I am labeling basically everything as a library. 
It depends on your hardware, I think. Some hardware can't handle the exceptional cases of IEEE floating point. Instead, it causes an interrupt so a library can do the work in software, and that whole process is very slow. I don't know which platforms this is true for, nor if computations on NaN are commonly done via software, though. But that's likely what you're thinking of 
I think ti would also be useful to define and refine the standard on floating points. In practice there are already various floating-points implementations in various compilers (strict, precise, fast) and adding some strict definitions there would help.
Nope, it is UB - it will compile. Contracts are runtime checks (although the compiler can obviously give a a warning if it can prove a violation will happen at compiletime. And by the way: UB is allowed to prevent compilation - it is just not guaranteed.to do this.
For a strict floating point implementation comparison operators with NaN always return false, so if you want NaN propagation you can always ensure that the opposite of your precondition is false. With a non-strict floating point implementation I would not trust NaN propagation to work.
Program to find leap year using if else in c++ r/https://youtu.be/TP6qD4AoCEg
Some industries - e.g. avionics, medical and other safety-critical environments use operating systems that can be rather old. And some people do develop software for those environments using boost. So the intersection is not empty. I for one work in that intersection.
&gt; And some people do develop software for those environments using boost. So the intersection is not empty. I for one work in that intersection. I don't doubt that you use boost. But do you use boost 1.68 ? e.g., as far as I know, there are still plenty of devices that are made today with Qt **3**, which is almost a 20 years old version of qt
You're approaching the problem from the wrong direction, I am afraid. Containers usually have constructors and methods taking iterators, therefore the ideal interface would be: auto data = std::deque&lt;Data&gt;{ json_dto::iterator{ json_doc }, json_dto::iterator{} }; This is *extremely* flexible, and allows not only constructing new containers, but also using `.assign` (to avoid allocating more memory) or `.insert` to add *more* items to an existing containers. Similarly, the other way around, instead of hard coding a type of container to convert to json, simply accept any container with `.begin` and `.end`, then type-switch on the presence of `mapped_type` to detect whether it's an associative container or not.
&gt;Right, the example is indeed poor, but I believe it still illustrates how this idealized view of contracts is at odds with the propagating nature of NaN values in general. I don't think it is at odds. If you want NaN to propagate, you can express that in the contract. I've posted examples elsewhere. Also, sometimes we don't want NaN to propagate. In much of my own code, NaN is not so much rare as impossible, so there's no need to check for it at all. If one does occur it is a bug that should be detected as early as possible. The notion that NaNs are legal and should propagate through calculations to be detected at the end doesn't apply to me.
You can always checkout reviewed changes locally.
CLion is unusable with my 30000+ file project at my workplace. I find SlickEdit IDE works much faster with larger projects. When I tried CLion the indexing took forever and the ~/.Clion2018.X directory needed 19GBytes of space. This link discusses it more: https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000035030-Not-useable-with-bigger-projects These Clang based indexers do not scale very well to extremely large projects, it takes forever to do the indexing. SlickEdit is able to perform indexing using its own engine which is much faster and does a great job with C++. I compared clang based indexing to SlickEdit on a ~8500 file project - SlickEdit did the indexing in 35 seconds while it took clang indexing 15 minutes! That would not scale well to my 30000 file project, it would take hours! SlickEdit is also able to invoke your build of any build system (executes any script) and go to next/prev error while opening the file at the line number of the error.
So I'm not seeing anything that indicates that this includes meson support, but this still is looking like a step forward. 
On this note, does any have a good reference for a GN compatible ide?
I think `x != x` is very bad, in any context - particularly if you don't document it. As a beginner, or even intermediate or more advanced programmer that is not from that domain, `x != x` just looks odd to me and not clear. What does it mean? What's it supposed to accomplish? Because I browse /r/cpp I've heard stuff like this before and I think it's to check for NaN's, it would probably be false if x is NaN or something like that, and then I can look it up. But I bet a large percentage of C++ programmers wouldn't have any clue about that. We should write code that's clear, and in that case it would be `isnan(x)`.
It's spelled "Qt".
Wait so contracts have no semantic meaning other that introducing more UB cases? What is the point of having them in the language if the language doesn't enforce them in any way?
Tooling support. They can't be checked at compile-time because they're operating on runtime values (and C++ is not dependently typed), but a static analyzer, like clang-tidy or like the one in your conpiler, can look at your contracts and give you a warning if you're calling a function whose precondition is not being checked or fulfilled.
There are some good points in your reply, thanks! But my question is not about implementation details. json_dto was used in several projects and there wasn't need to deal with std::deque or std::list. It seems that std::string and std::vector are covers almost all cases in real projects. So we can add support for other containers but there is a probability that nobody will use it.
I'm skeptical if this is possible. I hope it will at least generate an assert for debug builds.
Why shouldn't it be a contract? I was first introduced to contracts in the language Eiffel, and they were used for such things there. Generally you want to capture as much of the semantics of the function as you can, in an abstract way. Having that clause helps specify what the function does, for both users and implementers. It helps detect bugs in the implementation. Unit tests are something else. They check specific cases, and they verify that the contract holds.
Why shouldn't it be possible? It's no different from type checking. At the point of an invocation `f(x)`, where `f(T x) [[expects: P(x)]]`, `x` may or may not be known to satisfy this predicate. If the last operation on `x` prior to the call is `[[assert: P(x)]]` or otherwise `[[ensures: P(x)]]`, then it is definitely satisfied; otherwise, it's not definitely satisfed ‚Äî issue a diagnostic. Regarding contracts aaserting in debug builds, that is the plan, yes; in fact there are several methods being discussed for diagnosing contract failure at runtime. You should read the Contracts proposal; it explains all of this much better than I can.
I mean possible in the general case. It's like the halting problem isn't it?
Does it matter if every remotely realistic case is decidable that some insane theoretical ones aren't? Anyway, C++'s type system is already Turing-complete, so that cat's well out of the bag :)
I use totalView at work. It's not free but it works very well with C++.
I'd wager it's the case that people who need such functionality simply won't go near your library to begin with, and so you won't get feedback from those people. I'm only speaking for myself here, but I won't touch a library that's ignorant of allocators, and I'd be shocked if I'm the only one.
Anyone that ignorant of the way C++ types work has no place to claim they know C++.
That assumption would hold true for literally every string class written in C++ in the last 25 years. At a certain point it ceases to be an assumption and simply "common sense".
Indeed, I am in the same position. There are many competing C++ JSON libraries, so unless *all* are lacking the functionality, I'll pick one which works for me rather than trying to wrangle it out of another. It's harsh, I know, but serialization to JSON is just a peripheral for me, input/output, and so I'm not willing to spare much time for it when I have so little time to work on the actual guts to start with.
json_dto is not a JSON-parser, it's just a thin wrapper around RapidJSON. RapidJSON support allocators. We do not express this via json_dto's API yet, but it is because json_dto is at version 0.2. If someone needs simplicity of json_dto and allocators from RapidJSON we can extend json_dto API. And I think we will do that on the way to v.1.0.
That's great, but missing the point entirely... ;-] I'm explaining one possibility for you not getting feedback along the lines of supporting other containers ‚Äì it's not that people don't have that feedback; it's that your library just appears ill-suited for anyone who would have that feedback anyway, so why bother?
The short answer to your question is yes ‚Äî with C++17, compilers are required to ignore any attributes that they don't recognize, so you can absolutely invent your own and use them wherever you like, maybe write an analysis or code generation tool that does something interesting with them, hopefully eventually reflect on them and use them to modify or generate code within C++ itself. They are infinitely flexible. The exact semantics of attributes is an interesting subject, though. There's some disagreement and contention there. It's commonly cited that attributes should have no effect on how code is generated, but this obviously isn't the case with existing (pre-C++11) attributes, and we don't necessarily want it to be the case with future attributes, either. It's also commonly cited that attributes should be able to be completely ignored by a compiler without affecting the validity of the code, which is a weaker restriction but still not one that jibes with the current state of vendor extensions ‚Äî *e.g.*, before C++11 added alignment specifications, there was GNU `__attribute__((aligned(...)))`, which was even then required for code correctness in some instances. And the standard doesn't have much to say on the subject of what attributes mean in general ‚Äî just those few it specifies. So everyone kind of has some idea of how they should work, but everyone's idea is slightly different, and that's about the state of attributes at the moment. However, it's also been noted that the lack of strong general semantics may be exactly what makes them so flexible, so maybe we don't *want* to specify them any more than we have? Make of that idea what you will.
&gt;As of c++11 values are zeroed on a read fail for the built-in &gt; &gt;operator&gt;&gt; &gt; &gt;s. I was not aware of this issue until reading this blog post. Do you know what happens when a \`\`\`std::string\`\`\` extraction fails with \`\`\`operator&gt;&gt;\`\`? After reading [en.cppreference.com](https://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt) it seems to me that the string would not be empty but instead contain all the characters read successfully until the ifstream extraction failure. Is that right?
&gt; It doesn't matter why someone don't want to tell anything. If you want more users, wouldn't you want to know why people aren't using your project? (And if you don't want more users, why are you posting here..?) &gt; If there isn't any feedback then we will do futher development on the library based only on our own ideas and needs. This is fine for your own project, however this whole line of thinking is fatally flawed if you want _other_ people to use it ‚Äì you need to get users before you get feedback from users.
You're basically correct (e.g. extraction stops at whitespace, not just 'failure'), but the right docs are here, with a thorough explanation: https://en.cppreference.com/w/cpp/string/basic_string/operator_ltltgtgt
&gt; If you want more users, wouldn't you want to know why people aren't using your project? If someone don't tell anything then we don't know anything useful. It doesn't matter why he/she doesn't speak. We have no information to analyze. We can make some assumptions what is wrong with the library but these are just assumptions. &gt; if you want other people to use it ‚Äì you need to get users before you get feedback from users. Ok. What should we do with json_dto to attract more users?
OK, thanks.
Go to the top of this subthread and reread it: you are getting feedback from non-users (possibly would-be-users), and dismissing it because it isn't "feedback from users". In particular, this is patently false: &gt; It seems that std::string and std::vector cover almost all cases in real projects. If I'm using RapidJSON, presumably I care about performance; for code in which I care about performance, you won't see much `std::string` and `std::vector`, but you'll see a lot of `folly::fbstring`, `boost::container::small_vector`, `boost::container::static_vector`, etc. And if you do see me using `std::basic_string` in performance-critical code, it's almost certainly with a different allocator, never `std::string`. The entire point I was trying to make is the fact that you haven't gotten this feedback doesn't mean your design assumptions are correct, it just means that you have fewer users to give you feedback in the first place. Dismissing feedback from e.g. this very thread because "no one has asked for it yet" is backwards (to put it nicely). ;-]
&gt; In particular, this is patently false: This is just our experience and experience of our users. And in our projects JSON (de)serialization is out of performance critical parts. &gt; but you'll see a lot of folly::fbstring, boost::container::small_vector, boost::container::static_vector, etc. Does it mean that someone needs to do something like that: struct my_data { folly::fbstring name_; boost::container::small_vector&lt;id&gt; ids_; std::array&lt;bitmask&lt;32&gt;, 5&gt; masks_; ... template&lt;typename Io&gt; void json_io(Io &amp; io) { io &amp; mandatory("name", name_) &amp; mandatory("id", ids_) &amp; optional("masks", masks, default_masks); } }; ?
&gt; and experience of our users \*sigh\*... I give up.
You should check that the inlining decisions are reasonable even if you put them in separate executables ‚Äì it may still fail to inline things in small benchmarks that are inlined when used in a realistically sized translation unit.
Let me explain what I see in this topic. json_dto was created to simplify working with JSON. Dealing with plain RapidJSON requires a lot of code. We didn't like that and we wrote our wrapper. We published json_dto and we get some users who wanted simplicity (may be at the cost of efficiency). At this moment no one asked us about support of `std::deque`, `std::list`, `std::array` or something else. It means that the basic set of types supported in the current version of json_dto is just enough for the tasks where json_dto was used. We think that support of such containers could be potentially useful. But how we can validate this assumption? So we just asked. Now you tell me that someone can just ignore json_dto because of some reasons. And, because json_dto is ignored, there won't be any feedback. Ok. Thank you. I understand that. But your explanation just tell nothing for us. We still don't understand what a potential user want to see in json_dto. Allocators? Iterator-based approach? Support for Boost.Containers just out of box? A possibility to add support for some containers by himself? More detailed documentation? More examples? Something else? What does stop an user from trying json_dto?
It's more about documenting UB than creating it. A lot of code in wild have "don't call this function with a null pointer, or "don't call this with an out-of-bounds index" as part of their documentation (`std;:vector::operator[]` comes to mind). Contracts are a way of formalizing this so that the compiler has a fighting chance to catch these during compilation.
I don't know what they are known for, but I do know that sqlite is tested in a way that only aerospace software is tested. You can draw your own conclusions.
Well, I'm thinking, if you put `res*res==v` in the contract for `sqrt`, that's essentially what the function does, so it's a test of the algorithm itself. Imagine you have a more complex, multi-line algorithm - would you then also put in the contract this much more complex formula, if there even is a formula? I'm not saying you're wrong, what you say definitely makes sense.
If a local variable is constexpr it must also be static. If it's static it does not need to be captured.
&gt; If a local variable is constexpr it must also be static. Huh?
Thanks.
Yes of course, a constexpr variable must be evaluated by the compiler and can also be used for template arguments. If it wasn't static (and const), but dependent on the current function execution, that wouldn't make much sense. [Example Code of what I mean.!](https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:c%2B%2B,source:'int+test()+%7B%0A++++constexpr+int+x+%3D+0%3B%0A++++return+%5B%5D()+%7B+return+x%3B+%7D()%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang_trunk,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'1'),lang:c%2B%2B,libs:!(),options:'',source:1),l:'5',n:'0',o:'x86-64+clang+(trunk)+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4) 
[This](https://godbolt.org/g/dbK1VM) works fine so I don't understand what your point is...
Point is that as far as I can think of there can't be a situation where you would need [&amp;] capture. See parent discussion. ;)
Oh, I see; I misinterpreted "must also be static" as a blanket statement. Sorry for the noise.
Aren't the contracts dropped by most optimized builds? So, the debug version is slow, and correctly throws the expected errors, while the release version is fast?
One big translation unit gave us a 3.5% overall improvement.
Is the issue with macros that they are unhygienic? Otherwise I generally like macros. Although constexpr is generally nicer if you can get away with it.
That's excellent! Any word on The C++ Programming Language 5th edition?
What makes shared_ptr insecure?
\&gt; The biggest reason why I think that such approaches are too much is that the problem they solve is actually very very simple. So simple, that your choice is either boilerplate, or: \&gt; I myself ran into this and I solved it by using code generation, where I define my components in external json files and then generate the C++ components along with helper functions as a build step. So, maybe the problem is not that simple after all? Explicit codegen in C++ should be absolute last resort. I'm not saying never, but it should be very rare. I just don't buy very broad excuses like "templates slow down compile", or, "I have to learn how to use a library". It just seems knee-jerk, without more specific examples of problems with libraries using existing approaches.
I disagree. Templates have a huge compile-time cost and code bloat cost (in debug mode). They are absolutely not light.
The point is that you don't have to solve it that way. With such a simple approach you're free to solve it however you want. Implement templated helpers if you want. It's not even guaranteed that you run into boilerplate issues - I did mostly because I wanted serialisation functions and debug printing/rendering functions for my components. Your needs might be different and such your solutions too.
The point is that you don't have to solve it that way. With such a simple approach you're free to solve it however you want. Implement templated helpers if you want. It's not even guaranteed that you run into boilerplate issues - I did mostly because I wanted serialisation functions and debug printing/rendering functions for my components. Your needs might be different and such your solutions too.
Careful when you say "right is good", that seems like an association the left handed community is rather uncomfortable with.
&gt; You should never do something with macros that can be done with templates, generally I generally agree, but I've also hit the case, where straight up code generation via macros was just so much easier to understand and debug than the template solution that I do allow exceptions to this rule - but I also never allow macros to escape the current file and see them for what they are: A text/token manipulation mechanism.
Is int not a C++ type?
&gt; In the end, templates are the lightest metaprogramming facility C++ has. As they are also the only one, that doesn't say much. Also, it imho sometimes shows that their original purpose wasn't metaprogramming (although bjarne thankfully made sure that they can be used for it)
&gt; Programming design patterns tend to be programming language-agnostic. Have you read the GoF book? &gt; The choice of programming language is important because it influences one's point of view. Our patterns assume Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. If we assumed procedural languages, we might have included design patterns called "Inheritance", "Encapsulation," and "Polymorphism". Similarly, some of our patterns are supported directly by the less common object-oriented languages. CLOS has multi-methods, for example, which lessen the need for a pattern such as Visitor. In fact, there are enough differences between Smalltalk and C++ to mean that some patterns can be expressed more easily in one language than the other. (See Iterator for example.) 
Why call it `Auto`? Seems like a bad name. Why create a lambda on a different line? Why not create it as a temporary? Note that `__COUNTER__` is a gcc extension; so this is not C++11. 
&gt;Well, I'm thinking, if you put `res*res==v` in the contract for `sqrt`, that's essentially what the function does, so it's a test of the algorithm itself. It's part of the specification of the function, and evaluating it tests whether the function was implemented correctly. That's the intent. It does not say anything about what that implementation is, and in this case it's not even obvious how to find `res` from that clause. &gt;Imagine you have a more complex, multi-line algorithm - would you then also put in the contract this much more complex formula, if there even is a formula? If there's a formula, then yes. Another example would be: void push_back(int v) [[ensures back() == v]]; The idea is to say what the function does without constraining how it does it.
Is there a similar solution that doesn't involve macros?
**Company:** [quasardb](https://www.quasardb.net/) **Type:** Full time **Description:** QuasarDB is a high performance, distributed, time-series database for demanding applications. We are looking for a passionate C++ software engineer to join the core team. You will be responsible for developing new features and pushing the performance of the technology further. **Location:** Paris, France **Remote:** No **Visa Sponsorship:** No **Technologies:** C++ 17 - In addition: Python/Go/Clojure **Contact:** [jobs@quasardb.net](mailto:jobs@quasardb.net) \- [Official job posting](http://www.quasardb.net/jobs/jobs/2018/07/04/cpp-software-engineer.html)
lmao this guy and his pumpkins
Any bet Stroustrup will wait until Concepts is finished. 
`L&amp;` would not be able to catch the lambda if it was a temporary. `L&amp;` would need to become either `const L&amp;` or `L`.
Shouldn't what you refer to as "union" actually be an "intersection"? &gt;returning a set of IDs that are *present in all maps given*
Oh, good point, I'll fix that. Thanks!
`typedef std::map&lt; const char *, void (*)( void ) &gt; WorkItemList;` `static WorkItemList sWork;` This isn't a good idea, for various reasons, including SIOF. Instead just: `auto&amp; workItemList() {` `static std::map&lt;const char*, void(*)(void)&gt; s;` `return s;` `}` It will always be initialized in time now for anyone that uses it, eliminating SIOF much more cleanly than with new and null testing (and without memory leaks).
I think the point is you don't have to give the variable a name. Some sort of wildcard identified that gets replaced by a unique name every time it's used would be very useful.
If performance is an issue, your way requires a lock and unlock every time that function is called, since the standard requires that to be thread-safe since C++11.
It's not required by the standard but it's what all compilers do. The realitiy is that if you are dealing with globals, it's often very hard to get the behavior you want in a standard conformant way. Especally once shared/static libraries, linker visibility, etc, get involved. You have to be willing to look at the implementations you care about.
I like rust a lot but this is not going to bring anyone new to the language. 
How does this even work well? The default comparator for ‚Äòstd::map‚Äô will not work work as intended for ‚Äòconst char*‚Äô. Because it‚Äôs going to camp are pointer addresses instead of actual characters
It's not a lock, but the Meyer's Singleton requires an atomic check for initialisation on every call.
I'm not fully clear as to what problem this is solving.
The real question is 'Why, today, would I do project X in C++?' The capabilities of the language and runtime is one thing; another is the ability to find developers, the time to implement the final product and the maintainability of it. C++ lacks in all these areas compared to other languages. We find it extremely hard to get decent C++ CVs in from recruiters, but luckily the turnover of my team is very low. But the day will come when I'm asked why we use C++ and not $LANGUAGE\_OF\_THE\_DAY, it gets more difficult to answer as time goes on.
once CLion calms their cpu usage and implements a faster autocomplete i am happy. But untill that day I am happy with cquery + vscode.
I've loved the idea of contracts ever since seeing them in Eiffel. (This is from July 2nd so, old news - I actually posted it to help me find the original posting, but no.)
Of course, but I don't see that part possible without macros. At least for the time being.
It's a troll trying to look like a Rust zealot. Just check its comment history.
You mean this? https://www.reddit.com/r/cpp/comments/8vl19w
Yep I dun got trolled.
I thought that contracts will be checked at runtime if checking is enabled in the compiler...
If by "atomic check" you mean "atomically reading a bool", then yes. Atomically reading a bool is required to be lock free to implement C++11, and on most platforms (including x86), reading a bool is always atomic so there's no added cost. In other words, on most platforms, the extra cost of accessing a static local is just a single ordinary branch, that will basically always be predicted correctly. Which is followed up by using the hilariously slow \`std::map\`. So I find it amusing that apparently a bunch of people seem to think that this is a performance issue.
I am a codegen proponent and if something is faster for me to implement, and easier to maintain, as either a clang-based code rewriter or outright a fully fleshed out parser, analyzer and output module, then I‚Äôd say that C++ is the wrong tool for that job. Some things are really easy to tackle in an understandable fashion as codegens, but just end up horrible kludges even in most modern C++. I love Verdigris and I hate Verdigris, but I mostly hate it because the clang approach is so much more flexible. As an example: I have had no-UB, standard C++ coroutines in production code 20 years ago. Yes, all codegen, but it wasn‚Äôt gnu M4-based codegen, it was a DSL that understood a C++ subset and would take in valid C++ and rewrite methods into coroutines. It grew over the years and I can now easily express communication-like protocols in it. I just chuckle when I run into hand-written protocol stacks. I can invert control flow with a single attribute, and going from a linear packet ‚Äúparser‚Äù in valid C++ to a continuation-based one that has error handling etc. It makes me happy and productive. That‚Äôs but an example. I use codegen for everything nowadays, and I can‚Äôt stand the mountains of code usually written manually for simple things. Of course I have accreted quite a toolset to pull all to it off, but all the tooling itself is code-generated and it‚Äôs trivial to bootstrap as all the intermediate products are standard C++ with few or no dependencies other than boost and similar well maintained and popular OSS libraries. 
Wow, I just noticed this blog entry is from 7 years ago. Nothing better since C++11?
Are there cache costs ?
Contacts are good, but we REALLY NEED MODULES!!! I'm really optimistic about modules in 20.. @.@ God help the committee bring modules! _/\_
Yes, but anyone thinking it's as simple as that has no place to claim they know C++. &gt;_&gt;
The answer from deathtopenguin5 is correct regarding what Patricia was advocating. However *shared_ptr* can indeed lead to insecure code in two situations. - Care is not take to mark cycles as weak, thus leading to circular dependencies that don't get released - Deeply nested datastructures can lead to stack overflow, depending on how the destructors get called. Herb Sutter has a CppCon [talk](https://www.youtube.com/watch?v=JfmTagWcqoE) on this matter. Both of them could lead to a possible DOS attack.
Useful concept, probably better named as "defer" since that's what some other languages call the concept. 
&gt; Note that `__COUNTER__` is a gcc extension; so this is not C++11. You can achieve the same thing with `__LINE__` and requiring all calls to be on separate lines.
&gt; Why wouldn't someone write an invoicing application, or some other simple desktop tool, in C++? Ignore, for a moment, all the trickery that fills these pages, stop worrying about maximizing efficiency, and just use it as a straightforward application language. Actually that works pretty well! So why give that up? Because there is no graphics library built into the standard? Just grab Qt and develop away! I don't wish to sound disrespectful, but you might want to try writing one of those applications in almost any other mainstream language first. Even Visual Basic. Qt is okay if you have to use C++. But compared to the major GUI frameworks in other languages, it's not great. "Sufficient" would be my most charitable term. Just because you can write something in some language doesn't mean you should for a new code base. There are better language choices for desktop application development. C++ only still has a presence there at all because hardware in the 1990s was so lacking, and partially because C++ code is still such a pain for interop with anything else, it can mean it's easier to stick within C++ for both front and back ends. &gt; We should not be so fast to shed large parts of the C++ community, just because we personally don't know anyone who uses the language in a particular way. The view from the /r/cpp ivory tower has its own distortions. The largest, most invested, multinational in desktop C++ is by far Microsoft. Unsurprisingly, they positively stack WG21 with their employees, and provide much of the funding for the ecosystem. They are also championing the OOM proposal, indeed they originated it (for the record, it received a LOT of feedback from internal Microsoft teams before it ever became public). &gt; Just in this last period we had a proposal to drop everyone who relies on OOM exceptions That proposal I think received a vote at LEWG, and was unanimously approved. So it's not a proposal any more. That's entered the standards track. EWG will vote on the same proposal at San Diego I believe. If it clears there, and I expect it will, that's coming to your next C++ standard. So it's not a proposal. It's on course for standardisation (so far). &gt; (so, that's anyone on machines with limited RAM, plus all the people who write desktop applications that do already handle this correctly), I've got a bit of code which lets a thread install an OOM recovery handler for a piece of code. It's already been circulated around the major multinationals by the WG21 leadership. I'll admit there has been some grumbling, but once the pros and cons are explained, to date it's been generally accepted. &gt; to drop everyone who relies on Boost on Windows 7 (which still has a market share of around 40%) That's not how Boost works. The minimum required tracks Microsoft EOL dates, which is what everybody should be doing anyway. Individual libraries often go on supporting much older Windows. Up to the library maintainer. If some user is on an extended EOL programme i.e. have paid Microsoft for that, and they need some latest Boost library, then they can pay its maintainer to backport, or do the backport themselves. Otherwise they can stick with an older Boost release (which is what happens 99.9% of the time). &gt; and now basically everyone who is not writing time-critical stuff. Sure, C++ is doubling down on its strengths viz current hardware and trends. That deprioritises historical priorities. &gt; If we keep going like this, soon there will be nobody left. Hardly. Where C++ shines, it's literally the only game in town, and will become more so. Where C++ has competition it cannot possibly beat e.g. in desktop applications, there I agree things are not looking rosy. But a rump will likely continue for decades to come. There are, after all, an enormous number of MFC applications out there, probably more than all Qt applications. And MFC received SPECTRE mitigated builds immediately after the standard library in Visual Studio, and before lots of other libraries. Which shows how many important customers using Visual Studio are using MFC in security vulnerable use cases, even today.
&gt; We find it extremely hard to get decent C++ CVs in from recruiters Sure, but employers are similarly unaccommodating in their relocation requirements. Niche skillsets can't be filled using conventional recruitment. C++ shops still persist in thinking that C++ devs are as liquid as Java devs. That stopped being the case a decade ago, if you want a C++ dev who isn't stuck in the 1990s anyway. If you want to see a surfeit of available talent, try recruiting an all remote C++ developer team. You would be *amazed* at what you can get, and how cheaply you can get it relatively speaking.
&gt;Explicit codegen in C++ should be absolute last resort. One thing that's nice about [explicit codegen](https://github.com/Ebenezer-group/onwards/blob/master/tiers/zz.middleBack.hh) is it's easy to tell what is and isn't getting generated. On-line codegen allows me to retain control over my work. That's not as easy with a traditional C++ library.
Yeah, I'm not sure I agree with her on this one. I think the advice should be not to overuse shared_ptr rather than avoiding it. I mean, if you aren't using raw pointers, new or delete, or shared_ptrs what exactly are you doing for memory management? Not everything can be stack allocated or unique_ptr owned. I would say prefer stack allocation above unique_ptr, prefer unique_ptr over shared_ptr, don't use new and delete.
&gt; be not to overuse shared_ptr Unfortunately, all developers think they're special and that their situation is special. When you say "do not overuse `goto`", developers will still code themselves in corners where they see a `goto`as the only legit way out. I'd rather they step back, rethink and rewrite. Same with `shared_ptr`.
The boolean is only ever written once. Because of that, the cache line should be sharable between cores and the cache effects should be minimal (after initialization).
I'd really have to see an example. Usually, when templates can do something, not only is it better to use them, but also much much easier. Macros, like I said, are very awkward. Compare a similar task in the TMP world and the macro world: map. In the TMP world, you want to apply a metafunction to a list of types to produce in a new list of types. In the macro world, you want to apply a macro to a list/sequence of arguments to get a new list/sequence. Writing the TMP map is a handful of lines of code that is quite easy for an experienced C++ developer. It's just not possible to easily write the macro code; you actually need to generate macros by hand that do things like count arguments or select the Nth argument, etc etc, in order to do this.
Would wrapping the registry in a "get" function solve that? Since the registrar's constructor would be calling the get function that would be in the same translation unit as the registry, that should ensure the registry is initialised, right?
There is a helper called `gsl::finally` that seems superior in every way. Why use macros when you have equally good nonmacro alternatives. The Auto macro would definitely not pass code review at my company.
&gt;don't use new and delete. If you use new and delete in constructors and destructors, what's the problem? [https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception#38780597](https://stackoverflow.com/questions/38780596/how-to-handle-constructors-that-must-acquire-multiple-resources-in-an-exception#38780597) I use that approach in my code and the text segment is 76 bytes smaler than when I use unique\_ptr. That's with gcc 8.1.1 and -Os. You don't have to include the memory header so it builds faster.
It does seem that C++ has taken 30+ years to produce something that still isn't as sophisticated as what Eiffel had in 1986. In particular, this proposal doesn't have the inheritance behaviour that Eiffel has (ie pre-conditions can be weakened, post-conditions strengthened). Nor does it have a way to refer to old values. You can't say something like: void pop_back() [[ensures size() == old size() - 1]];
76 bytes for the whole application is a very small price to pay in my mind. I guess you are coding in an extremely constrained embedded environment? As for advantages of unique_ptr I would say that you eliminate the chance of unmatched new[]/delete[] with new/delete causing memory corruption. As an aside, the most expensive bug I ever saw was caused by this very thing. You eliminate the chance that via a refactor you accidentally remove the delete, or put it behind a condition that prevents it being called. You reduce the cognitive load on the developer of having to track the lifecycle and to check for the above class of error because now they just need to look at the member declaration and they know just by looking at it that the memory is freed via RAII. If it's a raw pointer then you have to go check the destructor to see how it's deallocated and the constructor to see how it's allocated. 
rofl !
&gt; Entity Component Systems (ECS) are all the rage these days as an architectural alternative that emphasises composition over inheritance. Really!? I never heard of them until now.
I do admit to not having a great deal of experience with GUI development outside of C++ (last time I did that was in Powerbuilder, 20 years ago). What language or GUI framework would you consider to be a good choice for modern language development? What is it that makes them so much better than what we have in C++? 
thanks for the lesson. some people go to a lot of effort to remove branches. 
Relocation shouldn't be an issue for us since we're in central London. I don't think I'd classify C++ itself as a niche skillset, a less valuable one perhaps. As for remote working, I'd love to but obviously I'd work remotely myself first - earning a London wage but having the cost of living of somewhere like Portugal is very appealing! Small shops aren't too keen on contractors either unless the situation is dire... investors consider it a huge risk if your talent can walk off with little or no notice period; in-house is preferred.
Off topic, but I'd be really interested in seeing how reflection could be emulated using hana
Why would I use this over something like Go?
&gt; Relocation shouldn't be an issue for us since we're in central London, the place should be full of C++ talent Firstly, you would be surprised. I live in Cork, Ireland, barely a 45 minute flight from any London airport. Could you get me to work *anywhere* in the English South East for *any* money? Categorically not. I'm too old to be bothering with any of that. Young person's game. There is a TON load of people who will not, under ANY circumstances, work in the south east of England, for any money or project. Especially the experienced ones. After all, what's the point rising to the top of your profession if you have to go work in the south east of England? God no. Anywhere but there. Same goes for Silicon Valley. You get to the top so you have the choice to get out. Secondly, employers in London don't realise how uncompetitive their pay is. Once you deduct the cost of living and unavoidable costs of working there, last time I ran the numbers I'd need to earn ¬£180,000 a year to match the after-costs standard of living I have over here in Ireland in a good year. And for the record, I don't even earn a third of that here, but my cost base is a tiny fraction of over there. I get approached a lot by London recruiters, and they're like "Oh we're paying ¬£140k + bonus OMG amazing employer amazing project blah blah ..." and I'm like "you **do** realise that's a *substantial* cut in my standard of living right?". They just don't get how uncompetitive south east England is. Unless you're on a quarter million a year upwards to compensate you for having to live there, it's just not on the radar. Thirdly, contractors in the UK are forced to move employer frequently due to IR35, but non-UK contractors working abroad are not so bound. Plenty have five year plus relationships with their employers. As with any business, if you're nice to your people and don't pay them a fifth or more below the market rate, they'll tend to stick with you. Start being mean to them, or don't keep up with pay raises, and sure they'll walk. They'll walk in London onsite just as much as remote, perhaps more so because of the crazy constant cost of living increases in London. So I'm sorry, there are good reasons you can't find skilled C++ talent. Start with a salary of ¬£250k upwards if you're in London. You'll find talent then. Or build out a remote team for ¬£100k (before all taxes) each and put together an even higher calibre team. But don't think for a second that there is a shortage of highly skilled C++ developers, because there isn't. C++ has one of the most liquid talent markets outside of web dev in the world. Just need be more attractive, then you'll get them.
Because it has generics
[agar.io](https://agar.io) server was written in C++ 
Any codegen that requires complex data structures is not possible in modern compilers because they run the metaprogrammed or constexpr code very slowly and with lots of memory overhead. Template metaprogramming still feels like basic on an 8-bit machine right at the turn of the decade between 70s and 80s in terms of performance. It sucks. Even libraries like Eigen struggle with it when a very straightforward generator can output comprehensible and well-optimizable C++ for linear algebra or just about any other numerical stuff you may be doing. Plus, with template expressions you‚Äôre never guaranteed the level of optimization ‚Äî you have to benchmark your product just to make sure a compiler change didn‚Äôt thoroughly break it. Sometimes you hit an inlining limit and trivial code turns out into a slow-as-molasses big pile of assembly. Usually in the equivalent of an inner loop. I used to use Eigen a lot and it‚Äôs fine for experiments but for production it‚Äôs codegen to C with restrict and the output code is like from handwritten low level FORTRAN. About as fast as the hardware allows. 
For me personally, the biggest argument against Hana is that it reimplements a very limited runtime environment that you get with any programming language. And it does it only so that it would execute on the template language that C++ compilers implement. It‚Äôs a wonderful hack, but using it in place of a codegen is nuts IMHO. Rewriting clang AST is very easy. 
&gt; What language or GUI framework would you consider to be a good choice for modern language development? Oh my ... it's been a while. I've written C++ apps in Qt, wxWidgets, GTK and native X11 or Win32 before, but it has been fifteen to twenty years as well for me. Not much recent market demand, if I am honest. For other languages, I wouldn't do down .NET with C#. Annoying how much you have to type to qualify what you're referring to, plus like with Java there is a half dozen ways of doing anything, but you can ship a finished and well tested (Windows) desktop app in .NET far faster than in C++. I also always rated highly NeXT application development. They did a lot of stuff there right from the beginning, with only a few major oops like no anticipation of threads. That's, nowadays, the Cocoa framework in Mac OS, and it's such a nicer experience than the clunky Win32 API, despite being technically actually older. Most of my more recent GUI experience is actually on mobile or on web, and I like how Android didn't repeat many of the mistakes of desktop GUIs, though it still repeated more than it should have. The various Apache projects for this I found reasonably well put together for doing cross platform mobile development. That Flutter thing from Google looks like a nice evolutionary step forwards again, though shame about the NIH Google language requirement. For web GUI development, I'm about to demonstrate how old and out of touch I am, but I knocked together something with Python Pyjamas a few years back and came away quite impressed. I'm not keen on Electron type desktop apps, but in theory they could be made to not suck for the end user so badly. One day, maybe. That said, if you need to knock together a desktop app fast, and you hate your end users, Electron is definitely the right rapid development tool :) &gt; What is it that makes them so much better than what we have in C++? Memory safety, garbage collection and dynamic runtime. All stuff where Python and friends excel, and C++ does not. For a GUI I never want to think about memory corruption, resources or concurrency. Other languages make all those go away, in exchange for profound non-determinacy. But users don't see tens of milliseconds of stochastic variation in latencies, and I get to ship finished product sooner which is *far* easier to maintain over a long time period. Obviously all the above is in my personal opinion only, and a lot of it is very subjective indeed. I would mention that I do tend to choose to write C++ or Python most of the time unless there is a compelling reason not to. Those two languages are an excellent pairing, and improving the closeness of their interop is a big personal goal for me. Hence my proposal paper! 
I'm so hyped for class types as non-type template arguments! Still hoping for modules, though and contracts look neat.
These are two very good examples, thanks!
An object with initialization side effects would have sections that make it clear to the linker, and I‚Äôd consider any compiler/linker combo not doing the right thing to be practically broken. 
This is over a month old and I am pretty sure it has already been posted, hasn't it? I would be really surprised if it hasn't.
My conclusion is that SQLite is very often dog slow and a lot of products that use it are slow because they naively use SQLite. They shoot themselves in the foot. \*Most\* software is not banking or avionics. Three times I used SQLite and it turned into a big performance problem, and in those cases I really didn't care about losing the occasional megabyte to corruption. A lot of people are writing monte-carlo simulations or games or other things where ACID concerns must be weighed against other business considerations. The data maybe isn't super valuable, but speed is life or death for the project.
Yes; it should be L. And make it an aggregate and initialize with {} while you are at it.
Why would you use a library for C++ over a different language? Does that question really make sense..?
Sure; have a macro `ANON` that does the `__LINE__` or `__COUNTER__` trick. No need to hide other magic as well.
Stop with this.
[Ahem](https://i.redditmedia.com/PiTwgjEp7i5lHqxYd9KpZ7pey7-EbCEvRYcg2fOtCew.jpg?s=37d8b6cfc0e1df0fb5f5fbe8659ca42b)
Note that [MSVC defines `__COUNTER__` too](https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros), and presumably clang has it, so the 3 major compilers support is probably good enough.
Wtf? 
I think it would be more than 76 bytes if there were more resources involved. I don't think anyone is suggesting vector or string be implemented in terms of unique\_ptr. I'm not sure how many resources are too many in terms of cognitive load. Can static analysis tools catch mismatches between new\[\]/delete\[\] and new/delete?
See Andrei Alexandrescu's CppCon 2015 talk ["Declarative Control Flow"](https://youtu.be/WjTrfoiB0MQ). There are a few cases where you want to run code when you exit the scope, but it obscures the meaning if you were to write a unique type just for a destructor. C++ doesn't have `try` / `finally`. This is a lot like the `finally` of languages with it.
Yes. But you deal with it.
Shrug - sorry, usually reddit won't let you post a double. I thoroughly expected that it had been posted, and thought I'd find the thread and make a comment there. 
Yes, it had. But usually reddit won't let you post a double, it will just take you to the old one. Sorry about that. 
We need that video of Steve Balmer dubbed so he says "modules, modules, modules!"
Hm, `audit` should have at least one category tag that can be used to enable/disable checking of all audits with that tag. For example, `void sort(vector&lt;emp&gt;&amp; v) [[ensures audit: is_sorted(v)]];` is nice to have in the stdlib, but most of the time I'm not interested in checking stdlib implementation. 
Is this talk going to be recorded and perhaps eventually uploaded to youtube (or some such)? Also, is there a version of this perhaps already available as such video(s)? Please let me know. Thanks!
What was the 3rd mentioned CI service after Travis and Appveyor ? It wasn‚Äôt mentioned in show notes.
... and why wasn't it written in Go?
Unfortunately that has the same problem. The issue here is that you only guarantee something is initialised before some point by odr-using it, and you never odr-use the registered things in this scenario; you rely on initialisation to put the things in the registry and then you access things from the registry.
\&gt; *Presumably* the language is already decided by the time you're finding a library for it I don't agree (I'm not the original poster), Will you decide on a language before you know which libraries are offered? Best example I have is a friend writing a pet project in rust because "rust is better for the web" but after a week of work he realized that rust doesn't have a lib that fully supports the xml standard. AFAIK Go was built for the web (I am not a Go developer feel free to correct me) so building a web service would be her niche, If C++ has a lib that is trying to fight in the same domain, then I would want to know more .
Can I use C++ to manipulate the DOM with Webassembly so I don't have to use that horrible Javascript? 
Well, I can only reply with my personal anecdata: 10k files (~1.9Gb) project is indexed by QtCreator in 120sec on a single core (files are located on local HFS+). QtCreator does not store the parsed index on disk, memory usage with this project is ~700Mb.
All talks are recorded.
w.r.t clangd: does it help if you disable Settings | Languages &amp; Frameworks | C/C++ | Clangd | Use clang-tidy via clangd?
One thing I forgot @ /u/STL: Would it be possible to define a compiletime switch, such that any char text is interpreted as utf8 text by the standard library and automatically converted to utf16 before calling the respective windows API functions? I hope we'll get something like that once char8_t gets standardized anyway, but it will probably take a decade or so until I can use that in cross-platform projects.
classic go
[you can go further than that](http://blog.qt.io/blog/2018/05/22/qt-for-webassembly/)
I'm glad I'm not alone in disliking this blog for minor reasons despite he is obviously knowledgeable. I just don't like his profile picture on his blog.
Why is remove_cvref not removing volatile via std::remove_cv as the name would suggest?
Probably should be. Good eye.
In C++20 there will be https://en.cppreference.com/w/cpp/types/remove_cvref ;)
I could get rid of the struct you're right, I just prefer doing it that way. One example of a situation of where I've used `fwd_ref`: template&lt;typename T&gt; auto get_members(fwd_ref&lt;widget, T&gt; w) { return std::forward_as_tuple(FWD(w).a, FWD(w).b, FWD(w).c, FWD(w).d); } This gives you a perfect forwarded tuple of `widget`'s data members. I've used this for implementing `operator==`, `operator&lt;`, serialisation, etc: bool operator==(widget const&amp; x, widget const&amp; y) { return get_members(x) == get_members(y); } bool operator&lt;(widget const&amp; x, widget const&amp; y) { return get_members(x) &lt; get_members(y); } widget&amp; operator==(widget&amp;&amp; other) { // Hmm... get_members(*this) = get_members(std::move(other)); } template&lt;std::size_t I, typename T&gt; using remove_ref_tup = std::remove_reference_t&lt;std::tuple_element_t&lt;I, T&gt;&gt;; template&lt;typename T, class Members, std::size_t... Is&gt; T do_unserialise(unserialiser&amp; u, std::integer_sequence&lt;std::size_t, Is...&gt;) { return T{u.read&lt;remove_ref_tup&lt;Is, members&gt;&gt;()}; } template&lt;typename T&gt; T unserialise(unserialiser&amp; u) { using members = decltype(get_members(std::declval&lt;T&gt;())); return do_unserialise&lt;T, members&gt;(u, std::make_integer_sequence&lt; std::size_t, std::tuple_size&lt;members&gt;::value&gt;()); }
It's written ≈ìil. That's also why I hate when people use french as names. Interesting interface, I was searching a mock interface for a while, I'll check that soon!
You can start by having a look at [Component Software: Beyond Object-Oriented Programming](https://www.amazon.com/Component-Software-Object-Oriented-Programming-Addison-wesley/dp/032175302X)
Can it only mock virtual functions? Then it's not quite useful.
You probably could, but a JS version of the chat client will usually be much smaller than if it was written in any other language.
not only virtual: [https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#-mocking-non-virtual-member-functions](https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#-mocking-non-virtual-member-functions) for example free functions too: [https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#-mocking-free-functions](https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#-mocking-free-functions)
Except the validity of sort depends on the correctness of your `&lt;`; have a bad `&lt;` and sort may fail to produce something sorted.
&gt; It's spelled ≈ìil. That won't stop me calling it oil.
&gt; &gt; &gt; And yet, will you develop a website back-end in C++ ? probably not ... you can use nodejs / GO / Scala / python ... Depends on the website, but I have a bunch of http / websocket back-ends in production out there and they're 100% C++. &gt; Will you perform your statistical analysis in C++? sometimes ... most of the times you'll use R / S / Python ... I've used R and Python in the past for this but nowadays I just use boost.math directly. Kept having typing errors in these two - and I generally end up having to integrate the result of these statistical analysis in bigger programs anyways. &gt; Will you develop your windows only GUI application with C++? well you should because QT is the best framework but let's face it you'd probably use C#. well, I'm currently being paid to develop a windows-only GUI application, and I'm doing it with Qt. It's a GUI editor to make point-and-click games, with undo-redo, JSON save and a bunch of other features. I'm 13 days in and almost done - even if I was fluent in C# I'm not sure if I would have been able to make it.
I'd take like to take the articles conclusion a step further and say that it's always a good idea in microbenchmarking to check what the compiler has generated. Every microbenchmark is a lie, although a given microbenchmark is with luck and care a consistent lie, making regressions possible to catch. I'd agree with the article that comparative microbenchmarks require a special amount of care and handling / understanding.
Wouldn't have thought that this really works and the compiler is able to deduce the using-type. Also std::forward does work directly as usual: https://ideone.com/7VryJy
Template argument deduction basically "looks through" template aliases. After you replace the `fwd_ref&lt;std::string, T&gt;` with `T&amp;&amp;` you are left with a deducible type.
I really want modules more than anything, but going by the reports it seems there is little reason to be "really optimistic " :( 
Unfortunately yes.. But there's going to be a modules specific meeting at the time of CppCon before the final feature freeze meeting in November.. that's what making me have some hopes...
"A Tour of C++" 2nd edition is there! "C++ Concurrency in Action" is getting an upgrade too!!
$75 for a fifteen year old book? No thanks
Rust and XML is a tragic intersection right now. The quick-xml crate is the best you're going to find. Need support for xmldsig or encrypted? Prepare for a slog, or a lot of pain with extern C libraries. I don't like working with XML on the best of days, but Rust's current available support makes it extra obnoxious.
Thank you for your efforts, watching now!
This is not necessarily true for sufficiently complex web applications, and this is where raw javascript becomes more difficult to manage regardless.
Agreed, JavaScript programs become harder to maintain the larger they get.
I don't think that's possible without breaking binary compatibility, but we're looking into supporting a UTF-8 locale.
Ever heard of libraries and 2nd hand?
I came here for the pumpkin comment. And now I'm very disappointed :(
It‚Äôs an absolutely needed thing. There‚Äôs very little on CMake out there that could be used to quickly put together a decent build system. Modern C++ has so much to bring but unfortunately lack of tooling like cargo puts it back. I‚Äôm pretty sure your playlist will be helpful. 
You can create a `diff`, easily wrapped into: ```bash diff-clang-format() { clang-format "$1" | diff -u --color "$1" - } ``` and then call ```bash diff-clang-format foo.cpp ``` 
One thing that I came across and infuriated me on a third_party project I imported in my project was the use of a `cmake_minimum_required(VERSION 3.12)` that was not warranted. Don't force a minimal version, especially the latest, if a lesser version works. cf. "How to CMake Good - 1a - A "Hello, world" executable" - 4:36 mark where you use force cmake 3.12. My debian:buster (testing) has cmake 3.11.2 
I know of a code base (which shall be named) which does: #define main SDL_main /me :pukes: 
Thanks. I'm hoping to eventually be able to do write-ups of similar caliber. The trouble is in finding a text-based platform already as ubiquitous and featureful as YouTube that lets me do what I need. I was working on a longer-form text (a book, of sorts) that would cover the same material. Trouble comes in that it takes a _long_ time before being able to publish the thing and some materials become out-of-date by the time it is completed.
This is great. I've learned CMake mostly through osmosis, so it's nice to have something more structured from someone who knows the details and explains things I've only guessed at. I personally like the video format, and watching it on 1.25x makes it a lot more time-efficient :) Thank you and please keep creating these!
The tooling trouble is indeed _trouble_-ing. I work on build tools both for work and for a hobby, and I'm hoping that I'll be able to work in a lot of tooling discussion in these lessons.
Since you're on something as recent as 3.11, I can't complain much. That's pretty close to the bleeding edge. If someone isn't making use of features from a certain version, then they might as well not require that version. My trouble comes when people _abstain_ from new CMake features in order to maintain backward compatibility with an ancient CMake version. Updating is _extremely_ worth it and _extremely_ easy and isn't a huge ask for your consumers. See #0a.
Thank you kindly!
The "[**Cache-Line Aware Data Structures**](https://accu.org/index.php/journals/2535) " paper made me very sad. In 2018 the fact that a paper like can be published in a leading C++ journal and make no mention of std::hardware\_constructive\_interference\_size / std::hardware\_destructive\_interference\_size is very sad. Making cache-line awareness portable is the very reason they were added. Instead, we get a hard-coded 64.
So is VS2019 again backwards compatible to VS2015? In any case: We wouldn't need it to be binary compatible - neither with libraries compiled with older toolsets, nor with libraries compiled with different project settings, but it would make things just so much simpler (although a utf8 locale probably suffices for most cases anyway
Something I'd like to see would be some sort of tool that scanned through what features were used and recommend a minimum version. Would be incredibly useful for putting together packages.
I assume that's what resulted in [this](https://www.reddit.com/r/cpp/comments/96o6e4/the_auto_macro/e435r10/).
Could you explain the difference between this library and other mocking libraries such as Google Mock and FakeIt? Why would I use this over FakeIt? - https://github.com/eranpeer/FakeIt - https://github.com/google/googlemock
Have you consider a Gist or Git repository (either for raw Markdown files or for a wiki)?
Those are an option, but it still missing a lot of the platform features I'd miss from YouTube. This might be a good idea for a new tool dedicated to the task. Something like CodeProject but less visually horrific and distracting, and it would need to have some element of inline interactivity. Hmm...
Does anyone have recomendations for a C++98 and C++11 solution? I'd like to avoid making the original functions virtual and/or templated if possible. Something that could work with Boost Unit Tests would be even better. Thanks.
Unfortunately C++98 is not supported, but can be used C++11 [Trompeloeil C++11 API](https://github.com/rollbear/trompeloeil/blob/master/docs/Backward.md) You can [mocking a class template](https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#-mocking-a-class-template) [Use Trompeloeil with boost Unit Test Framework](https://github.com/rollbear/trompeloeil/blob/master/docs/CookBook.md#adapt_boost_unit_test_framework), and other test frameworks 
I see. Anyway, thanks for the heads up.
Problem is that if I am on a system that packages the most recent version of CMake, and my CMakeLists.txt configures OK on my machine, how am I meant to know whether it will do so in previous versions for others? Someone with a system that packages an older version of CMake can easily change that variable to allow the build. Are we meant to read through the entire CMake changelog to work out the minimum version that a project will configure with?
The linux kernel solves this same problem by making a list of objects in a custom defined section of the binary. See https://github.com/torvalds/linux/blob/master/include/linux/dynamic_debug.h#L74. This has the benefit of not having to do any heap operations pre main. Not necessarily better but definitely in the realm of interesting compiler tricks
It might not be equivalent but strictly better. That is, the conditional code makes it so that you get nicer features with a newer version of CMake; maybe it compiles faster, maybe it gives better diagnostics, maybe it gives more information, etc.
Hello, I'm the author of LuaConsole. It's a REPL implementation of lua.c which combines luajit and luajit seemlessly, so that you can use the version you want. I made it as an intentional replacement for bash and cmd for my own purposes, but there project has proved awesome with a lot of debug possibility. The changes between 51 and 52 an 53 are understandable, and with practice you can change your version or write non-breaking scripts. I also designed it in c. The main reason lua isn't in c++ might have to do with pointer black magic as you would call it imho. Remember that each language has its strengths. I would pick up http://GitHub.com/Tilkins/LuaConsole and build it. You might have great use for it and I'm still developing it. It takes time to learn lua API sand learning C is very useful. 
The overall cpu usage is down. clangd is still listed in the process list, but instead of a consistent 10+%, it's at 0-4%. CLion is still sluggish while typing (clear delay between typing and text showing up) though. Side question. I'm using CLion with MSVC and `std=c++latest` on my Cpp compiler flags line because Cmake doesn't recognize anything higher than 17 for the c++ standard. The highlighting in the editor in the latest version is not recognizing MSVC extensions with my tag, sometimes it even chokes on C++ 17 stuff like std::optional. (the way I use std optional works in both clang and gcc with the appropriate flags, but is being marked as errors in CLion)
You wouldn't want to manipulate the DOM directly, since the support for the DOM specs (or rather the XML specs that are built on DOM) are a moving target and incomplete in various ways across various browsers.
I know it'd be a hash map, but that's still cumbersome to use as a key, especially because it's big.
Separate reply in case you already saw the last one. It seems I spoke too soon. clangd is no longer a permanently running process but changes will still cause clangd to run and, for brief spurts, take up &gt; 20% cpu cycles while editing normal files.
Definitely agree. `isnan(x)` is so much clearer as to what it actually means and I really can't see the argument of using `x != x` because it's less verbose, as it's only 2 characters shorter. I really don't think the *significantly* worse readability is worth saving just 2 characters over. 
You sound like someone that would enjoy using Haskell for tasks without tight performance requirements. Your DSL can probably be embedded into Haskell without any metaprogramming (probably with much worse performance though). I also recommend you take a look at Terra for the other end of the spectrum, where you have a very simple object language and a very powerful meta language.
**Company:** [Loki](https://loki.network/) **Type:** Full Time **Description:** Loki is an open source, fully funded project aiming to develop a censorship resistant mixnet with an end-to-end encrypted messaging service built on top of a privacy centric cryptocurrency. We are mostly comprised of C/C++ developers who work on the core of our product. However, there are many upcoming projects that require a competent web developer to extend the practical functionality of our product suite. We are looking for a candidate that possess both Medium/Strong C++ and also has a strong understanding of Web design and front end languages like Javascript. The right candidate for this position is experienced, creative, and is passionate about privacy preservation. We are fairly agnostic about the framework or language that the candidate uses, so long as they are competent within it and can rationally justify their design and implementation choice, as opposed to just 'liking' a particular framework or solution. Particular proficiency in any of the following areas is desirable, but not a requirement: * User Interface/Front End Design * Web Extension and Browser Experience * Distributed Network Engineering * Experience with C++ to interface with front ends * Blockchain Technology * Information Security/Penetration Testing * Open Source Projects/git **Location:** We have offices in Melbourne and several remote developers in the US, but applicants should be aware that they may be required to relocate for work or be comfortable working remotely. **Remote:** Yes **Visa Sponsorship:** No **Technologies:** We have a wide breadth of technology, mostly we use C++ and work on the Cryptonote code base, projects outside of Cryptonote are still C++ and networking heavy like LLARP our internet overlay protocol. **Contact:** PM me on reddit
Toss in some newlines and maybe indent and it doesn't seem *as* bad, but it's definitely long. template&lt;typename T&gt; requires std::is_arithmetic_v&lt;T&gt; T sqrt(const T &amp;Number) noexcept [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here } 
Sure, but that doesn't necessarily mean I'm interested in auditing every call to sort() in my application, especially if doing so slows it down to unusable speeds. Most libraries have their own switches to allow for fine-grained checks to be enabled on a per-library basis; I don't see that capability in the proposal. 
I say it's not too bad, just spread it over a few lines and try to indent it nicely
I thought constraints were in the template parameter such as: ```cpp template &lt;MyConstraint X&gt; void f(X x) { } ``` On the other hand please note that rust is not that short too with all the [#] annotations.
I‚Äôm not familiar with the contract syntax, but I think it‚Äôs right. It‚Äôs saying that the result of sqrt(Number) is less than Number. So 5 is less than 25. 
sqrt(0.5) &gt; 0.5
TL;DR: I argue that these don't actually make function declarations longer, but they make them *shorter*, once you consider what they are replacing. Constraints don't make function declarations longer; if anything, it makes it shorter. Before, we had to write: template &lt;typename T, std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, int&gt; = 0&gt; T sqrt(const T &amp;Number) noexcept { ... } // vs template &lt;typename T&gt; requires std::is_arithmetic_v&lt;T&gt; T sqrt(const T &amp;Number) noexcept { ... } Which is definitely worse than the constraint. I would agree that contracts make the function declaration remarkably long, but I don't see it as *that* big of a problem; that's stuff that should be in a documentation comment anyway and/or asserts. But I don't personally like the position of the contracts; I find that hard to read as compared to a documentation comment. As for explicit bool and conditional noexcept, they also reduce function "declarations." Compare: template &lt;typename U, std::enable_if_t&lt;std::is_convertible_v&lt;U, T&gt;, int&gt; = 0&gt; explicit my_constructor(...) { ... } template &lt;typename U, std::enable_if_t&lt;!std::is_convertible_v&lt;U, T&gt;, int&gt; = 0&gt; my_constructor(...) { ... } // vs template &lt;typename U&gt; explicit(!std::is_convertible_v&lt;U, T&gt;) my_constructor(...) { ... } It's much easier to understand in the latter case, as there is one fewer overload. If we take it to the extreme, trying to implement conditional explicit and conditional noexcept would take 4 overloads vs just the one. Also, consider that these only come up in specific generic contexts. In contexts where they don't apply, don't use them; your function declarations will be just as short as they were before.
Let's fantasize we got abbreviated template and noexcept by default: auto sqrt(const Arithmetic&amp; Number) [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here } The real challenge seems to be getting the committee members agree on the syntax of abbreviated template and the breaking changes on noexcept-ness.
I don't think this is a problem. All the new syntax is adding useful information to the function declarations - information you might already have in a comment anyway because people need to know it to use it properly.
You can write `template&lt;MyConstraint X&gt; void f(X x){}` too, or you can choose to be explicit like OP.
or in asserts
Don't forget that contracts reduce number of asserts in the code
This is mainly a formatting problem. There is a reasonable/consistent way to indent all of this: template&lt;typename T&gt; // template header requires std::is_arithmetic_v&lt;T&gt; // template constraints inline static constexpr // silly keywords auto sqrt(const T &amp;Number) noexcept -&gt; T // function signature [[expects: Number &gt;= 0]] // contracts ... [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] // ... one per line { // Implementation comes here } If any of the comma-separated lists get long, I indent and break them into one item per line. I try to keep the function signature all together (works most of the time), but if either the `noexcept` expression or the return type don't fit, I break them into their own lines. template&lt; typename SomeLongTypeName, typename SomeOtherLongTypeName&gt; requires std::is_arithmetic_v&lt;SomeLongTypeName&gt; &amp;&amp; std::is_something_else&lt;SomeOtherLongTypeName&gt; inline static constexpr auto func( const SomeLongTypeName&amp; argument1, const SomeLongTypeName&amp; argument2) noexcept( noexcept(/* some condition here */) &amp;&amp; noexcept(/* some other condition here */)) -&gt; SomeLongTypeName [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here } As a result, even if the whole thing is very long, all the items line up perfectly like a top-down list, which makes the whole thing very readable.
&gt; *I know a lot of people are very skeptical of educational video. I've dealt with enough of this debate for a lifetime, so I'm not going to argue it here. Suffice to say: I learn best through video, therefore I can teach best through video. It really depends how you can showcase something and know how to do it. For me reading seemds the most comfortable as you can stop and reread it much easier than the vid. On the other hand, in video you can showcase much more and that's why I like to mix text with images.
sqrt(1) -&gt; 1
```template&lt;typename T&gt; requires std::is_arithmetic_v&lt;T&gt; T sqrt(const T &amp;Number) noexcept [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here } ``` or template&lt;typename T&gt; requires std::is_arithmetic_v&lt;T&gt; T sqrt(const T &amp;Number) noexcept [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here }
I wholeheartedly agree. I do not think they should be considered 'longer', but only _more explicit_, which is a good thing because it helps prevent bugs.
The thing I don't like about this is the number of hash look-ups you're doing. It's probably alright if you don't have that many entities though.
Tried to port over a pretty simple c++ http server to use beast and it was easy using the examples with the exception of not being able to parse URI's which was a show stopper. There is an open issue but it seems pretty complicated so not expecting this to be resolved soon. r/https://github.com/boostorg/beast/issues/787
sometimes its not your decision. I'm working on a project that is written is C++ and needs the ability to get files from the web for parsing.
Ever write just `begin(c)` on a standard container, without doing `using std::begin;` before hand? That would break.
I'm thinking that the proposal to reduce the scope of ADL will end up not going anywhere, because there is a chunk of Boost libraries which will stop working, including my own Boost.Outcome which *heavily* relies on ADL in namespaces of user supplied template parameters. I remember explaining this to Herb some months back after his paper, and he seemed genuinely surprised that anybody was actually using template argument namespace ADL in anger (and deliberately). I quickly sketched through the alternative implementation options, and the only other customisation point option is user injection of specialisations into designated library namespaces for ADL. Boost.Outcome *also* uses that technique where it can, but in some cases you want customisation points to be *universal* and not library specific. In that situation, I am unaware of an alternative to template argument namespace ADL in the current language. I could warm to a warning diagnostic however like the one in the article. Especially if there were a C++ attribute to say to the compiler "I really do intend template argument namespace ADL here". Actually, that's an idea: C++ attributes to limit the scope of ADL. Now *that* would be a great proposal. Somebody not I should propose that.
Yeah, it's wrong. That's what I get for staying up late... Thanks
There is no `Arithmetic` concept, that's why I had to use the explicit syntax.
lmao this guy and his pumpkins
In his original paper, Herb argues that that is a feature, not a bug. I imagine that a lot of real-world code would break on this point, but if we deprecate this functionality, implement this warning, and give people six or nine years, I think it'd be fine. I feel like breakage and a deprecation cycle would be a small price to pay for not having to worry constantly about ADL sneaking up on our generic code. I still don't like ADL ‚Äî I think that modules will bring the potential for better solutions to the problems it solves, as long as they don't get ruined before they land ‚Äî, but if we must have it, let's have a moderately sane implementation.
Even if C++ were a bad tool for a particular job, it's entirely possible that a given person would be so much more familiar with C++ than tool X and so for _that person_ it might make sense to use C++.
I kept thinking about that `sqrt` function. My comment was primarily-focused on contract implementation in general: UB sin't such an issue as we can validate/chain `expect`&amp; `ensure`. But I didn't used a point a point, the `nan`. I don't know if it's possible, but what I would like to do, for `abs`is: - if `v` not nan, then `res` not nan and positive - or if `v`is nan, then `res`is nan.
template &lt;auto&gt; auto sqrt(auto x) requires: auto, expects: auto, ensures: auto { // Derp. }
lmao this guy and his pumpkins
What is the result of this? struct A { B b; int x; }; struct B { A a; int y; }; int main(void) { std::cout &lt;&lt; sizeof(A) &lt;&lt; std::endl; return 0; }
&gt; As for customization points, why did traits based design not suffice? Oh, Outcome uses traits too. The customisation points use the most appropriate implementation for each. Some during the Boost review felt it was "messy", but it probably is better than using a single mechanism for consistency where it wouldn't fit well for some points. It's a tough judgement call.
I like this proposal. Shame we can't wind the clock back to when ADL was designed :(
I wasn't just referring to answers I got, sorry I didn't made it clear. I was more interested in why no one gave a simple answer to the C++ with Beast vs Go question... No one suggested a benchmark, or pros and cons. 
sad :(
&gt; I thought constraints were in the template parameter That's a short-hand that's available when you only have one constraint. It's equivalent to: cpp template &lt;X&gt; requires MyConstraint&lt;X&gt; void f(X x) { } The longer syntax is necessary when you want to combine multiple constraints: cpp template &lt;X&gt; requires MyConstraint1&lt;X&gt; &amp;&amp; MyConstraint2&lt;X&gt; void f(X x) { }
likewise for `swap`
Ah it's much clearer now. I'm doing something similar in my code then, except some corner case example, and even these corner case I make most of the type explicit, like `template&lt;typename T&gt; void service_map(MyType&lt;T&gt; const&amp;)`. I mostly agree with Herb then. The ordering of function should try to find the best candidate, from the closest namespace possible. A very generic candidate in a far namespace should not be picked.
Just for my understanding: do you need to repeat this on both the declaration and the definition? For the rest I'm mostly thinking that the added information is optional and has value, so I'm not too bothered by it.
Why do so many programming examples use duplicated, single-variable names for namespace, functions, and variables? Would it just kill us to use a real(er) name instead of `B::B&lt;A::A&gt; b;`? namespace Safe { template&lt;class&gt; struct Place {}; template&lt;class T&gt; void Describe(const Place&lt;T&gt;&amp;) { puts("hello from a Safe Place"); } template&lt;class T&gt; void CheckLocation(Place&lt;T&gt; place) { Describe(place); } } namespace Dangerous { struct Fire {}; template&lt;class T&gt; void Describe(T&amp;) { puts("You're on fire!"); } } int main() { Safe::Place&lt;Dangerous::Fire&gt; place; CheckLocation(place); } I don't know. Maybe I'm just not smart enough to parse names like that and it's my fault.
The point isn't whether it's a feature or bug. The point is that there is definitely code that breaks and I disapprove of the blog post making it seem like it basically wouldn't break any.
Ok, one use case. Now let's say you are starting fresh, and you have equal knowledge in both languages. No one offered benchmarks, no one discussed ease of maintenance, edge cases, eco systems (for the specific use case). The writer of the library just gave Agar.io as an example for a web service on C++... but AFAIK Agar.io wasn't written with beast ... so the library author can't even give a good summary of what he thinks the library's strengths are?
Wouldn't it be great if C++ would have default parameters behave exactly like in Python... I wish someone would write a proposal for that, it's a sorely lacking feature
Because Go is a abhorrent language while C++ just sucks.
FakeIt looks nice! I realllllyy like the fact that you can create a Mock in one single line without having to rewrite the entire header somewhere else
```cpp template&lt;typename Range&gt; auto rootMeanSquare(Range&amp;&amp; range){ using std::sqrt; auto sum = range.front() * range.front(); auto count = 0; for(it = range.begin(); it != range.end(); ++it){ sum += *it * *it; ++count; } return sqrt(sum / double(count)); } ``` Right now this uses ADL lookup for the `sqrt` function of custom user types such unit-aware types (as in 10.0 meters) or arbitrary precision floats. As I understand it, under Herb's proposal, this code would cease to function, correct?
Indeed, although those are in the implementation rather than the declaration so a curious reader has to dig a little deeper to find them.
Why stop there? template &lt;auto...&gt; auto auto(auto&amp;&amp;...) [[auto...]] { // well now what }
Or shorter, negative indent for the function name: &gt; inline static constexpr auto func(const AnArithmeticType&amp; argument1, //concept lite syntax const ASomethingElse auto&amp; argument2) //adj syntax noexcept( noexcept(/\* some condition here \*/) &gt; &gt;&amp;&amp; noexcept(/\* some other condition here \*/)) \-&gt; SomeLongTypeName \[\[expects: Number &gt;= 0\]\] \[\[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number\]\] { // Implementation comes here }
\&gt; truely \&gt; grammar nazi Pick only one
Writing benchmarks isn't simple. Recommending programmers stop trusting every one they see online is moronic.
conan
That's fair. But as widespread as this breakage may be, I think it's also fair to say that it would be minimal, at least in terms of real impact. A simple warning catches every case, and the fix is trivial and can even be applied mechanically (modulo whether the affected code actually intends to call the resolved function or not, of course; there would no doubt be some latent bugs caught if this warning were rolled out today).
Nothing stops you from writing arbitrary-long functions on a single line even in `ANSI C`.
usually the first step is to make your own library, and see if anyone finds it useful. getting it into the standard library would come much later
If the user's overload took templates, yes. namespace N { struct A {}; template &lt;typename&gt; struct B {}; auto sqrt(A); // would work template &lt;typename T&gt; auto sqrt(B&lt;T&gt;); // would now fail }
`sqrt(0) == 0`
I think you're correct. You can see this happening a lot in languages such as Haskell, where the mathematical basis is more prominent.
What do you mean? Doesn't `begin(c)` work exactly the same for standard containers: https://godbolt.org/g/hoVk6z Unless you mean a container of standard containers? boost::container::static_vector&lt;std::string, 5&gt; arr; begin(arr); 
I don't think you've understood the proposal correctly. The only change is when adl relies on the template parameters of the argument. In your example, the `sqrt` function is in the same namespace as `B` so adl won't get as far as looking at `B`'s template parameters and so adl works exactly the same. https://godbolt.org/g/qH5wJy
The nested namespaces in this one really got to me.
Did you take a look at boost's object pool?
No, it's not. Herb's proposal has two parts: narrowing the set of associated namespaces and narrowing the set of functions looked up. The latter restricts to only matching the (possibly cv-qualified, possibly pointer/reference to) type. It is very much the goal of this proposal to reject template matches. Apparently Arthur didnt actually implement that. This _should_ be a warning: namespace N { struct C { }; template &lt;typename T&gt; void foo(T); } foo(N::C{}); But it's not.
The code in that link would no longer work.
Totally agree with this, and also, never ever do this manually. Use clang-format, it will do it for you. :-)
Thank you /u/vector-of-bool, that's awesome! Adding to the scarce but slowly getting-larger list of modern CMake resources :-) For anyone that prefers reading: Two books came out very recently, I haven't seen them linked yet in this thread: * https://crascit.com/professional-cmake/ (I can personally recommend this one) * https://leanpub.com/effective-cmake (this one is early-access and apparently 70% written) There's also some free resources: * https://cliutils.gitlab.io/modern-cmake/ (this one has been linked here already) * https://codingnest.com/basic-cmake-part-2/ (this links to part 2, there's also part 1) * https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/ * https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1 Other videos: * https://www.youtube.com/watch?v=bsXLMQ6WgIk * https://www.youtube.com/watch?v=eC9-iRN2b04 
The main problem with CMake isn't the lack of resources, it's the awful language. I believe writing a language that transpiles to CMake or directly interfaces with the C++ backend would really be the answer for how to make CMake good.
The committee likes to standardize existing practices so definitely start with your own library. 
&gt; The main problem with CMake isn't the lack of resources, it's the awful language. From years of experience and can say this is patently false, and if you think the _language_ is the worst part of CMake, I have some bad news...
Basically anything involving callbacks is made enormously easier and concise with lambdas.
Oooh, noooo.
It's information people trying to use the function really need to understand. The code for the contracts is almost always shorter than the English-prose that would accompany it, so in the end it's a win. I think. Hindsight is 20/20, so I guess we'll find out in 2023...
I am pretty experienced with CMake. I even have contributed to the unofficial cmake package manager Hunter by porting autoutil projects to CMake. So I'm not just speaking from ignorance. * Functions have no return values. * Variable names are sometimes inputs and sometimes outputs. * The falsey values are terrible (`"*-NOTFOUND"`) * Lists are not a real type, just strings with semicolons. * Simple math is not in the language. * Generator expressions are way too complicated. If I had to choose between the C preprocessor language and the CMake language I'd have a hard time saying which is worse.
Qt for example is massively simplified when you do not have to create yet another slot for a minor corner case.
Yeah, it's unreal how streamlined it makes simple callbacks: int add_x_to_y(int x, int y) { return x + y; } Scheduler()-&gt;schedule(1.0f/60.0f, &amp;add_x_to_y); vs Scheduler()-&gt;schedule(1.0f/60.0f, [](int x, int y){ return x+y;}); Plus when you have a section of repeated functionality, you can define a lambda inline and call that over and over again with the captured variables, instead of binding a helper function with a bunch of variables.
Have used lambdas with find if a couple times, resulted in more readable code IMO.
Registering class creation with a template function and lambdas is really useful. ```cpp std::vector&lt;std::pair&lt;const char*, std::function&lt;BaseClass*()&gt;&gt;&gt; classes; template &lt;typename DerivedT&gt; void Register(const char* name) { classes.push_back(std::make_pair(name, []() { return new DerivedT(); } } ```
Lambdas make it super easy to memoize things in simple functions (as long as you know they'll not need to be invalidated later): // This function retrieves a value that is not known // until runtime, but which is known to be constant // (e.g. some operating system value) int get_dynamic_constant_value() { static const auto value = [] { return get_the_real_value(); // expensive } (); return value; }
grammar nazis shouldn't have to deal only with grammar doe :v
They are great if you have a variable that ideally would be 'const', but it's initialization is too simple to be worth extracting into a standalone function and yet too complex to cram into a single line. 
This is my primary use case for lambdas as well. Originally I didn't understand how I'd ever use them but learned the syntax just for completeness, and now I can't live without them.
I pretty much exclusively use lambdas to inline the sort function to std algorithm calls.
Personally I have used lambas quite a bit while prototype a new feature. Basically the idea is spaghetti but with lambda meatballs inside. You start writing the feature, and whenever you feel like you‚Äôre going to separate some functionality to a new function, you write a capture all lambda instead and call that. You can easily add variables without having to change function signatures and when you feel like you‚Äôre finished you can remove the capture all and see what should be refactored out as parameters or class members. The disadvantage is that you have to remember to refactor your lambdas away afterwards. Another thing I use lambdas for is where you have to assign a variable based on a switch on another variable. Instead I write a lambda that returns the value to assign and call it in-place: int y; //function parameter or whatever int x = [y]() { switch(y) { case 0: return 15; case 20: return 3; default: throw ...; }(); 
There's always a ramp-up period before someone starts being productive. It's going to take you a while to learn your way around their code base. Focus on learning how they've set their projects up -- what tools you need to install to work with their code, checking out their code base and building it. I usually spend a few days digging through their code to get an idea of how it all fits together. They probably have at least some documentation somewhere, as well. If you see anything in the code that confuses you, don't be afraid to ask about it.
What does the lambda buy you there? You could just initialize the static to the function return the lambda was returning.
Basically, every case where you have an interface with only one function in it you can create a wrapper for a lambda type and use lambdas instead of many subclasses.
The lambda buys you the ability to do more complex initializion than fits into a single expression. Really, I got the description wrong here. It's magic statics in combination with lambdas that make this work so well, but what the lambda actually does is more general ‚Äî it lets you perform complex multi-stage initialization on a constant variable, similar to what you can achieve in Rust by defining a `mut` and then rebinding as non-`mut`.
Boost's object pool is kinda not that useful IMO. OP means something like [this](https://github.com/carlosb/object_pool).
Sure, I get that - but the example you wrote wasn't that, hence my confusion. If the lambda *was* that expensive run-time calculation then maybe. Using a lambda instead of a function call in initialization is not always the right thing to do. Sometimes it's better to have that helper function be elsewhere (e.g. in an anonymous namespace). One of my biggest complaints about lambdas is that people use them as an excuse to *not* subdivide methods and are bringing back the days of hundred-line functions.
Lambdas have helped a lot with encapsulation and readability in my code. My most common uses are: * Callbacks and predicates * Local helper functions that I don't want to pollute the namespace/class with * Variable initialization I think the last one is very useful but a lot of people are still unaware of it. It's vastly useful in variables that are expensive or that should be `const`. For example, const auto results = [&amp;](){ std::vector&lt;int&gt; results; for (auto something : somewhere) results.push_back(func(something)); return results; } (); There just is no cleaner way to do this that I'm aware of.
Build an emulator :-D That's what I did in a similar situation, starting my first job about 10 years ago. There's a lot that school never covers. &gt; I get the feeling that everyone else is a C++ expert and I don't know anything. It took me a few years to get over that feeling. Basically when I started having my own little corners of the code that were my sole responsibility.
Ah yes, the great [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression) pattern.
If I compare our pre c++ 11 codebase and current one it's incredible how much cleaner the new code is. And by far the biggest improvement is thanks to lambdas. What once was huge pain in the ass 2600 loc Callback class now can be expressed cleanly and concisely as simple lambda. This fueled major codebase refactoring making it fully asynchronous I/O + main loop based instead the ad-hoc blocking I/O thread pool mess it was before. If I had to give up all post C++ 98 features and only keep one it would be lambdas.
I'm curious, it sounds like you've been in that new job for a few days or weeks or so? But you haven't seen or done any coding yet? What are they having you do then? Do you have experience in any other programming languages, or are you straight from a B.Sc./undergraduate degree or something like that?
I use them a lot in a UI library for embedded systems. For example something like: \`\`\` class Button { public: std::function&lt;void()&gt; on\_click; } Button red\_button; red\_button.on\_click = \[\]{ DoSomething(); DoSomethingElse(); }; \`\`\` The buttons then get updated with their UI state every whatever number of system ticks and if there's an event they call the associated callback. 
Exactly? Including the insanity about reference type default parameters being shared after first use? 
&gt;The writer of the library just gave Agar.io as an example for a web service on C++... but AFAIK Agar.io wasn't written with beast Well, someone asked why use "this" instead of "Go." Since Go is a programming language, I interpreted his question to mean why use C++ instead of Go. If you are asking why use Beast WebSocket over other C++ websocket implementations, there are a few reasons. There is outstanding handling of the WebSocket Upgrade handshake. Beast WebSocket allows you to interact with the handshake using the library's HTTP message model. Furthermore, Beast adheres strictly to the Networking TS interfaces and idioms. If you know how to use Boost.Asio, then you will be immediately comfortable using Beast. Finally, there's a great comparison of Beast to the next best WebSocket library (websocketpp) which goes into more technical depth about the differences: [https://www.boost.org/doc/libs/1\_68\_0/libs/beast/doc/html/beast/design\_choices/comparison\_to\_zaphoyd\_studios\_we.html](https://www.boost.org/doc/libs/1_68_0/libs/beast/doc/html/beast/design_choices/comparison_to_zaphoyd_studios_we.html) I hope this answers your question!
I'd also like to point out that WebSocket is a popular choice for API endpoint, and in particular there are a lot of cryptocurrency server services written in C++. For example, exchanges very often use C++ to implement their order books and matching engines because of the fine-grained control over threads and synchronization offered by the standard library - very important for performance and to ensure correctness!
Could you please give an example of how lamda simplified your callback? Thanks. 
I'm actually going to drop a bit of code I wrote Doing a bunch of mathematics in a very tight loop lead me to write ([bit more context](https://pastebin.com/yRHxDqih)): // Calculate the objective // auto tau_sq_integrand = [&amp;](double e_x, double e_y, double e_z) { double T[3]; // Stress vector calc_stress_vector(e_x,e_y,e_z,T); // Pythagoras: TiTi is the square of the length of the stress vector // TiNi is the length of Ti's normal component, thus // TiTi - TiNi*TiNi is the square of the length of Ti's tangential component double TiTi = 0.0; double TiNi = 0.0; for(int ii=0; ii&lt;3; ++ii) { TiTi += T[ii]*T[ii]; TiNi += T[ii]*r_n[ii]; } double tau_sq = TiTi - TiNi*TiNi; if(dump_file) { (*dump_file) &lt;&lt; ',' &lt;&lt; std::pow(tau_sq,m); } return std::pow(tau_sq,m); }; objective += area * SimpsonsRule([&amp;](double e_z) { return GaussQuad5([&amp;](double alpha) { return tau_sq_integrand(alpha*e_x[0]+(1.-alpha)*e_x[1], alpha*e_y[0]+(1.-alpha)*e_y[1], e_z); }); }); Within that function is a bunch of other functions that all share a common context with relatively expensive to calculate numbers. Lambdas help me to capture what variables I need, to declare what needs to be provided and to compose a bunch of small functions easily. Very possibly the compiler could inline a fair bit of it, in particular `SimpsonsRule` and `GaussQuad5` while still allowing me to write the easy to understand names instead of a bunch of function calls and random magic numbers. I'm also not polluting the namespace with a bunch of small tiny functions that have one specific purpose in one location.
I'm actually going to drop a bit of code I wrote Doing a bunch of mathematics in a very tight loop lead me to write ([bit more context](https://pastebin.com/yRHxDqih)): // Calculate the objective // auto tau_sq_integrand = [&amp;](double e_x, double e_y, double e_z) { double T[3]; // Stress vector calc_stress_vector(e_x,e_y,e_z,T); // Pythagoras: TiTi is the square of the length of the stress vector // TiNi is the length of Ti's normal component, thus // TiTi - TiNi*TiNi is the square of the length of Ti's tangential component double TiTi = 0.0; double TiNi = 0.0; for(int ii=0; ii&lt;3; ++ii) { TiTi += T[ii]*T[ii]; TiNi += T[ii]*r_n[ii]; } double tau_sq = TiTi - TiNi*TiNi; if(dump_file) { (*dump_file) &lt;&lt; ',' &lt;&lt; std::pow(tau_sq,m); } return std::pow(tau_sq,m); }; objective += area * SimpsonsRule([&amp;](double e_z) { return GaussQuad5([&amp;](double alpha) { return tau_sq_integrand(alpha*e_x[0]+(1.-alpha)*e_x[1], alpha*e_y[0]+(1.-alpha)*e_y[1], e_z); }); }); Within that function is a bunch of other functions that all share a common context with relatively expensive to calculate numbers. Lambdas help me to capture what variables I need, to declare what needs to be provided and to compose a bunch of small functions easily. Very possibly the compiler could inline a fair bit of it, in particular `SimpsonsRule` and `GaussQuad5` while still allowing me to write the easy to understand names instead of a bunch of function calls and random magic numbers. I'm also not polluting the namespace with a bunch of small tiny functions that have one specific purpose in one location.
For some reason this mixing of CamelCase for method name and snake_case for variables really bothers me... It reminds me of Chromium where some methods (even in same class) are snake_case while other are CamelCase.
on the isocpp website somewhere there is a link to a discussion forum. Post there, you will get feedback and various members of the committee browse it. Provide code samples, and example code too. Rational, use cases and etc.. so people understand what your idea is, why it's useful, where it's useful and etc.
Maybe, the guideline when writing C++ should be to default writing functions as `constexpr auto myfunc = [](my_class&amp; c) -&gt; int{` `// Do stuff` `};` Which will not use ADL. When you want ADL to find your function, you write a "classic" function `void myfunc(my_class&amp; c) -&gt; int{` `// Do stuff, that you want found by ADL` `}` This brings up the issue that it is painful to separate declaration and definition, so maybe we need to extend the language to support `// my_library.h` `const auto myfunc = [](myclass&amp; c)-&gt;int;` `// my_library.cpp` `const auto myfunc = [](myclass&amp; c)-&gt;int{` `// Do Stuff.` `}` This way you can easily opt out of ADL.
&gt; I think it's also fair to say that it would be minimal in terms of real impact. Is it? I would have to see evidence of that. Any intentional customization point that you write that is a function template would break. Consider something like Boost.Serialization. If I want to add a non-member serialization function, I could write that as: ```namespace N { template &lt;typename T&gt; struct wrapper { T object; }; template &lt;typename Archive, typename T&gt; void serialize(Archive&amp; ar, wrapper&lt;T&gt;&amp; w, const unsigned) { ar &amp; w.object; } }``` This now doesn't work. I'd have to either make `serialize` a member function of `wrapper&lt;T&gt;` or... well, in this case, I can stick it in namespace `boost::serialization` (assuming that lookup isn't ADL-based... if it is, that one wouldn't work either). But that escape hatch doesn't necessarily always exist?
Standard lambda feature is such a great gift people longed for, think how hard [boost tried to imitate it in pre-C++11 standard.](https://www.boost.org/doc/libs/1_68_0/doc/html/lambda.html)
A lot of committee members read this subreddit :)
New software engineers aren't hired for their knowledge. They're hired for their teachability. Take a deep breath and relax a little bit, it's going to be alright! &gt; I get the feeling that everyone else is a C++ expert and I don't know anything. C++ is a language where few honest people without like, ~10 years of experience would feel comfortable calling themselves experts. I am by no means an expert, but I do usually end up taking on bringing our new people up to speed. Here are some recommendations. * Pick up a copy of [A tour of C++](https://www.amazon.com/Tour-2nd-Depth-Bjarne-Stroustrup/dp/0134997832/ref=dp_ob_title_bk). This is a good, quick introduction for someone who doesn't need language spoon feeding, written by Mr. C++ himself. * Every time you encounter a library function or concept you don't fully understand, write a small program illustrating it, and document the results. I've got a directory on my machine with about ~40 single-file programs from just the last 3 months that do nothing but confirm my understanding. * As you work, you'll encounter repetitive tasks that you'll want to automate. Resist doing them in something like bash or python (even though those are good tools for the job). Write out a C++ program to do those things for you. It's good, practical knowledge. * Build yourself a knowledge base. Whenever someone teaches you how to do something, turn around and start writing yourself up a short _howto_ article. I like [org-mode](https://orgmode.org/) or [QOwnNotes](https://www.qownnotes.org/) for this, but whatever works. Just save it in a git-repo somewhere. * C++ is a language that has _best practices_ and not a lot of hard rules. You'll get pretty far by learning what those are, since they derive from experience. Your company probably has a style-guide. You should read that, and pair that with [The C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines). Be humble and friendly, ask questions, get people to teach you, and _want_ to teach you. The language is pretty vast, but you'll be fine.
std::transform?
Then `const auto results` can't be `const`.
This reminds me of the [Colony container](https://www.reddit.com/r/cpp/comments/5535dh/cppcon_2016_matthew_bentley_colonies_performance/) that was mentioned here. But that might be just how my minds works...
Good advice, but I would have mentioned a different[ search engine](https://duckduckgo.com).
ADL's original motivation was entirely for operator overloading with free function overloads. Without ADL, this wouldn't work in any sane way: namespace simd { struct vec3 {}; vec3 operator+(vec3 lhs, vec3 rhs); } int main() { simd::vec3 a, b, c; a = b + c; // ADL necessary to find correct operator+ } All the later stuff we have like `std::begin` and such are from a desire to treat named library functions as if they're builtin like operators. Which I think all started with the ios stuff from IOStreams which of course also abused the heck out of operators; it really managed to illustrate all the worst ways to design C++17 libraries back when it was written in the 90's. :p I'm not sure how reflection or meta-classes would help in any sense with the problem space addressed by ADL.
&gt; the fix is trivial and can even be applied mechanically Is it? 14ned said this above: "I quickly sketched through the alternative implementation options, and the only other customisation point option is user injection of specialisations into designated library namespaces for ADL. Boost.Outcome also uses that technique where it can, but in some cases you want customisation points to be universal and not library specific. In that situation, I am unaware of an alternative to template argument namespace ADL in the current language." which sounds to me like pretty much in direct contradiction. In fact, it sounds like there's question as to whether there *is* a good fix in all cases. But I don't feel like I understand the issue enough to be able to talk intelligently.
You could still use `std::transform` inside the lambda: #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;algorithm&gt; int main() { const std::list&lt;int&gt; foo {1, 2, 3, 4} ; const auto func = [] (auto x) -&gt; auto { return x*x; } ; const auto results = [&amp;] () -&gt; auto { std::vector&lt;int&gt; results ; std::transform(foo.begin(), foo.end(), std::back_inserter(results), func) ; return results ; } () ; std::copy(results.begin(), results.end(), std::ostream_iterator&lt;int&gt;(std::cout, " ")) ; return 0; }
Or, in C++, just use a ternary? That‚Äôs existed since forever. 
That's true, and in this example you could do that, but the original had an extra println (), which would make the ternary unusable. So use ternary when possible, but for multi-line pieces of code, I+LEs are useful.
Well even then you could factor each of the cases into their own function and use a ternary, but this is a nice alternative to see in modern c++ as well...
I dunno, not enough different font sizes
Yes (and this applies even to contracts).
Those are sensible recommendations. I'll have to look into it.
Reflection and metaclasses would help in the problem space that ADL is being shoehorned into - finding an unqualified function based on namespace. Reflection would allow library designers to specify better ways of fulfiling a customization point, and metaclasses (ie, the formulation of metaclasses that would also create free-functions) would help library users to generate types that fulfills customization points. As for the operator overloading use of ADL, I think it's high time we seriously move ahead with one of the operator dot proposals. But reflection could also help in that case since a library relying on ADL to find operators could instead use reflection to find the operators by searching declarations in a namespace, for example.
I was simply commenting on the contents of the article, which evidently misrepresented the situation, based on what I have read here and in the follow-up article. There are lots of questions, and I don't claim to understand all of the subtleties well enough to feel comfortable commenting on it either, apart from that these wrinkles don't endear me to ADL any more than I already was.
There was also this book recently released: https://crascit.com/professional-cmake/. It's been great so far.
You can do some Lisp if it's just for a println : ```cpp auto s = condition ? "Luck" : (println("fail"), "Not this time"); ``` 
 template&lt;typename T&gt; concept Arithmetic = std::is_arithmetic_v&lt;T&gt;; // ... auto sqrt(const Arithmetic auto&amp; Number) noexcept //&lt; P1141R0 syntax [[expects: Number &gt;= 0]] [[ensures Ret: Ret &gt;= 0 &amp;&amp; Ret &lt; Number]] { // Implementation comes here } Note, the idea is to have your own concepts, no matter how corner case. Everything will be expressed in terms of them and not all will be in the STL. This is the same as classes - *most* are not "standard". 
I don't get why conditional noexcept would contribute to the number of overloads. There already is a noexcept(bool).
&gt; One of my biggest complaints about lambdas is that people use them as an excuse to not subdivide methods and are bringing back the days of hundred-line functions. I will take a hundred-line function with five lambdas every day over 5 helper functions in whatever namespace that are called only once
I care about code readability and comprehensibility.
They enabled me to write my first real instance of ‚ÄúI wrote this code but I have no idea how it works‚Äù. Said code is still live. I still judge them incredibly useful.
cplusplus.com apparently hasn't been updated for C++14 (at least that page hasn't) so I wouldn't use it. cppreference.com is much better.
&gt;&gt; pointer to member functions &gt;I treat these as anti-patterns and warning lights/code smell I don't think that's a luxury you could can pre c++ 11. After c++ though I don't think there's single one in our entire codebase.
1. You wouldn't be **constantly confronted** with declarations like this because this was an extreme case for demonstration purposes. 2. You cannot really "browse" any header that is heavy on templates (look at any header-only library or Boost). Also, other languages do just fine without declaration/definition separation. This is just something we **have to** use because of the compilation process and we wouldn't do it otherwise. 3. I don't see what you refer to as "noise" here. C++ has a lot of noise yes, but I'm just trying to show how I format it.
From my experience lambdas are great for short anonymous functions were intentions are clear. However, I have seen many times were lambdas grow into flesh eating monsters and even define other lambdas. At that point the function should be named. Overall I would say that lambdas can make our code shorter and more concise. But does it make code more readable? I have my doubts... 
Why are there so many game engines popping up recently? I mean it's a great learning project and fun to develop, but why would anyone use this in production? What does it offer that engines like Unity/Unreal can't?
To be honest I'd rather use the ranges lib, transform's interface is messy. And as a bonus, it does away with the need to use the lambda at all!: const auto results = somewhere | ranges::view::transform(func) | ranges::to_vector; ... or ranges::to_&lt;std::vector&gt;(), or just put vector instead of auto (`vector&lt;auto&gt;`?)
From your reply I still don't know which particular problem you can't solve without them. Do you have an actual problem you encountered in this way?
&gt; EnTT library that I use is the fastest ecs currently avail According to its creator, at least. I'm yet to see any other benchmark confirming it. The one that you can find in the entt repository is not very useful as it poorly imitates a real game scenario.
Just updated... what the hell microsoft. The following code does not compile : (it does if `public bar` or `public baz` is removed from the base classes of foo) class bar { }; class baz { }; template&lt;typename F&gt; struct Functor { F func; }; template&lt;typename F&gt; constexpr Functor&lt;F&gt; fun(F f) { return {f}; } class foo: public bar, public baz { void blah() { } void x() { constexpr auto x = fun(&amp;foo::blah); } };
UE4's ENQUEUE_UNIQUE_RENDER_COMMAND family of macros vs the EnqueueUniqueRenderCommand _function_ which takes a lambda (added in 4.15) is a similar thing - it's amazing how much simpler the lambda version is!
Which part is difficult to understand? You use pointer to member functions when you need to call member function after something happened. AsyncExecutor::defaultExecutor().run(Callback&lt;void,TypeSeq&lt;&gt;::List&gt;(this, &amp;ScrubbingState::deleteInstance)); This asynchronously invokes doDeleteInstance on this. Without pointer to member function I'd have to I'd need to do this static void _deleteInstance(ScrubbingState *instance) { instance-&gt;deleteInstance(); } AsyncExecutor::defaultExecutor().run(Callback&lt;void, TypeSeq&lt;ScrubbingState*&gt;::List&gt;(_deleteInstance).bindAll(this)); In this case using pointer to member function is clearly beneficial.
I wouldn't say that its creator is saying that it's the fastest ECS ever. Its creator says explicitly in the README file that those benchmarks are copied from entityx so as to compare the two ECSs and are all the way wrong: &gt; In fact, these benchmarks are the same used by EntityX to show how fast it is. To be honest, they aren't so good and these results shouldn't be taken much seriously (they are completely unrealistic indeed). [...] it is not as fast as reported by these benchmarks. This is why they are completely wrong and cannot be used to evaluate any of the entity-component systems. He tries also to give you the reasons for that: &gt; The compiler can make a lot of optimizations because of how EnTT works, even more when components aren't used at all. This is exactly the case for these benchmarks. Its creator is also available to explain the internals of the ECS if you didn't get it yet. It will help you to understand pros and cons Oland decide if it matches your requirements. But use your head when you make your choice, as suggested by the creator of EnTT: &gt; If you decide to use EnTT, choose it because of its API, features and performance, not because there is a benchmark somewhere that makes it seem the fastest.
Confirmed, compiles with clang-8.0.0, does not compile with vc-15.8.
Sure, you can do that, but don't read too much into this particular example. The initialization inside the lambda could be arbitrarily complex and unless the value is the result of a single expression you can't assign it to a `const` variable without a lambda or other function call.
&gt; Then just call the member function? Because you don't call it directly. Something else needs to to call it - i.e. threadpool when there is free thread, or a timer after elapsing some time. Or a button, when you click it. You have a button somewhere in your user interface, you want member function to be invoked when the button is clicked. How exactly would the button callback interface look?
LOL
I reported many regressions too... They were fixed in 16 it seems.
nameless function that you can pass around like it's a variable.
&gt; those are not general examples. Those are actual examples that I took from the old codebase. Yes they are non-specific. You're wrong. Consider this: int index = 0; // this isn't an actual example of anything &gt; Or a button, when you click it. You have a button somewhere in your user interface, you want member function to be invoked when the button is clicked. How exactly would the button callback interface look? This, however, is specific. &gt; you don't call it directly. Something else needs to to call it - i.e. threadpool when there is free thread, or a timer after elapsing some time. http://cpp.sh/2yu6 The protocol pattern has been out there for a long time and can do what you ask for.
I'm looking at your example and it looks so verbose. And you need to have different subclass for every button in you UI? How on earth would that scale? Your entire example can be written like this my_button.signal_clicked().connect( sigc::mem_fun(this, &amp;this_class::on_my_button_clicked)); cancel_button.signal_clicked().connect( sigc::mem_fun(this, &amp;this_class::on_cancel_button_clicked)); close_button.signal_clicked().connect( sigc::mem_fun(this, &amp;this_class::on_close_button_clicked)); void on_my_button_clicked() { ... } void on_cancel_button_clicked() { ... } void on_close_button_clicked() { ... } This is about as good as it goes with pre c++ 11. Having a subclass every button just so that you can have click handler would not something I'd do for any non trivial UI.
I don't think that would really apply to C++ since there it's explicitly stated if you have a reference or a value. The problem in Python is that objects are always non-const references, even where it isn't useful.
This should have a `reserve(foo.size())`. The number of resulting items is known in advance. Or `std::vector&lt;int&gt; results(foo.size())` with `begin` instead of `back_inserter`.
Those examples that I've provided were examples of a class method being called asynchronously on another thread; It's a very common thing that gets much nicer with lambdas. That's pretty far from int index = 0; At this point I'm really wondering what kind of software are you working on.
https://groups.google.com/a/isocpp.org/forum/#!forum/std-proposals
You forgot to mention what kind of engine it is.
Also, try to get it into Boost first. That's probably easier than the standard, depending on the kind of library.
Honestly, if you are serious about game programming, you better attempt this at least once even before getting too deep into a complete engine, otherwise you'll probably miss understanding of how an engine even work and that can lead to a massive ton of missed opportunities. (although you don't need it to be publishable haha) That being said, it's indeed surprising that so many engines are being published recently. My current guess is that programming games is becoming a little easier because of languages evolutions (C++, Rust, even Javascript etc) helping a lot with things like ECS (though some reflexion and metaprog features would make that even easier) and new graphic APIs (Vulkan and Metal) motivating people to write new code with them.
So I just regenerated the build files for my CMake project and tested the [just my code](https://blogs.msdn.microsoft.com/vcblog/2018/06/29/announcing-jmc-stepping-in-visual-studio/) feature by calling `std::sort` on a vector - and it didn't work out-of-the-box. I also checked the entire list of command line options for the project from Project/properties/configuration properties/c and c++/command line - and the `/JMC` switch is nowhere to be found in the Debug configuration (also checked the linker flags). How can I enable this goodness?
In CMake we use it by adding flags on Windows set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /JMC") set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /JMC") set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} /JMC") 
It works with CMake using set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} /JMC")
&gt; an instance method being called asynchronously on another thread &gt; scheduling execution on another thread or after delay is too abstract Yes, it is.
If you consider a separate subclass for every button handler a viable approach than I'm really wondering if you've ever worked on any non trivial software. It's not just that is verbose, it's also that you need to propagate all context to those handlers, scattering the logic across multiple places just to get around language limitations. Also, I never called it clear. Lambdas are clear. Signal and slots are messy, because they all work around language limitation. But as messy as it is, it's still way better than having 3 extra classes for three buttons. That's a maintenance nightmare.
So a thread pool or run loop is too abstract for you but a button is not. Thank you for the clarification.
Thank's for the suggestion !
So I have to set it up explicitly... Perhaps a newer version of CMake will play with VS 15.8 properly and set it on by default
Your operator &lt; wouldn't really matter in the case above, unless it produces random result each time, since is\_sorted check will rely on &lt; as well.
std::function is just about impossible to use cleanly, so I've lost count of the number of places where we'll put a callback function call in a lambda instead. As a counterpoint, as generally written they really mess with debugging (where to put the break). And don't get me started on trying to read nested lambdas. Then there's cases where you pretty much have to use them (see the example section for [https://en.cppreference.com/w/cpp/utility/apply](https://en.cppreference.com/w/cpp/utility/apply) for instance). Like everything in the language, there are good reasons to use them. There's also good reasons to not over-use them. Nothing is a panacea.
If `&lt;` fails the axioms, there is no guarantees that the result will pass is sorted. It could, bit I would not expect it to: an efficient sort relies on the transitive property. And that is a common way `&lt;` fails.
They've silently removed \_NOEXCEPT. Presumably as part of the "we are now standard" machinery. And of course it's an internal symbol, so it doesn't need documenting. Unfortunately, all sorts of library codebases (yaml-cpp for one) uses it to handle the previous "noexcept( true ) vs throw)" mess that various compiler versions had introduced. The symbol "leaked", [Hyrim's law](http://www.hyrumslaw.com/) remains valid.
I wish there was a way to revert these updates. I'm having all kinds of regressions and have a feeling it's going to now take me a day or two to figure out how to reinstall VS2017 back to 15.7.xxx. :(
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/97idpr/what_other_programming_languages_do_you/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I think you can just install the 15.7 toolchain from the VS installer! Should be named 14.14 or something while the one from 15.8 is probably 14.15.
I'm surprised that yaml-cpp is not part of their test suite, they test against a huge list of open source libraries according to talks that they gave.
&gt; just install the 15.7 toolchain from the VS installer! Should be named 14.14 or something while the one from 15.8 is probably 14.15. https://blogs.msdn.microsoft.com/vcblog/2017/11/15/side-by-side-minor-version-msvc-toolsets-in-visual-studio-2017/ You should be able install the old toolset by following these instructions. The blog post is old but it should still work I reckon
Unreal Engine is about as horrible as it gets from a C++ and build system perspective.
I was pointing out what it would be like without conditional noexcept
See [N3897](https://wg21.link/3897) for summary of the arguments against.
These dependencies are completely out of control. There is no reason to use boost for shared lib loading or simple filesystem stuff. The underlying platform specific calls are so simple and adding a boost dependency is a complete deal breaker. Not only that, but you have another filesystem library and two different scripting languages. 
Thanks - I somehow did not see this paper (or forgot about it). The point stand though, the concerns are mostly regarding things that can already be done or aren't related to `auto`, but incompleteness at large.
&gt; I think the strongest showcase at the moment would type deduction #includeTest on Compiler Explorer ! &lt;vector&gt; struct s { auto v1 = std::vector{3, 1, 4, 1, 5}; std::vector&lt;int&gt; v2 = std::vector{3, 1, 4, 1, 5}; }; What's wrong with this? #include &lt;vector&gt; struct s { std::vector&lt;int&gt; v2 = {3, 1, 4, 1, 5}; }; The `make_shared` example is better.
Hello, you do not seem to have understood the scope of the project. The dependencies are not out of control because they are used behind the very good VCPKG package manager. Boost is used voluntarily in a pedagogical sense, it is always good to know how to handle libraries like boost that are requested in some companies. The user chooses which modules he will use, so he is not forced to use the shiva-dll module. For information std filesystem is part of the standard since c ++ 17 and used in the library. On the other hand the engine will use EMScripten which does not yet support std::filesystem (library apart which must be compiled with the emscripten compiler).
I'm getting a 404 with that link.
Yeah, should be replaced with something like this to touch the initialization list problem: struct X { auto v0 = std::vector&lt;int&gt;(3, 1); auto v1 = std::vector&lt;int&gt;({1, 2, 3}); };
Fixed
it can be named anything you please. this is just a convention. basically everyone explicitly supplies the name of the desired executable when calling gcc. there is no reason why you should follow this convention. the most common convention is to give the executable the same name as the source. gcc just does not do this and you can easily fix this undesired behavior by supplying a -o option. some conventions you encounter may have a non obvious reason. this one is really quite meaningless.
I actually think that it doesn't matter if people are depending on behaviors that you told them not to depend on and now it's broken, it's still on the person who's depending on something they shouldn't have been depending on. If you rely on something that you know is going to break, then it's on you when it breaks.
\&gt; In general exposing binary-stable interfaces in C++ is a complicated exercise that should be avoided. Eh? What planet is this author living on?
I don't think there's a release date yet, but it most likely a breaking release.
You can also fix it by adding \`\_\_declspec(empty\_bases)\` to the foo: \`class \_\_declspec(empty\_bases) foo : public bar, public baz { ...\`
It was originally called "[a.out](https://en.wikipedia.org/wiki/A.out)" by default from the early UNIX days, and since GCC comes from that lineage it keeps it (on Linux it would still be "a.out" unless you specify something different). Just use the `-o` flag, e.g. gcc -o main.exe main.cpp 
Yes completely broke my code too, I had to roll back. Thanks Microsoft for wasting my time. Do you guys even run any testing before your releases? Or pushing us back which one? 
Exactly. At least check if the macro is actually defined if you're going to use it, especially if it can be removed any time. Add a fallback to it at least.
Shouldn't the compiler be able to recognize empty bases on its own?
maybe, but it's still broken in the non-empty-base case (I just wanted to provide a minimal example but C++ has semantic-altering minimality, which would make for a great prog metal songname but can be painful in cases like this).
When was the last time you looked at it? This statement just isn‚Äôt true, and unless you‚Äôre somebody that uses UE4 on a professional basis, it‚Äôs probably better not to comment.
AFAIK in Haskell FP style, you simply focus more on naming types than variables. fp code is much more readable if you pay close attention to types of things.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/97j6rq/why_is_executable_file_called_aexe_not_mainexe/e48o9s2/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Would yoy use it if it came? For sure! I wonder why it is not added yet. But I have never used non-standard extension `__restrict` . I also wonder if C++ compilers these days are smart enough to infer if a pointer can be `restrict`ed and do optimization itself without a user's guidance. (like `const`)
Except for Microsoft. It's now in the culture to blame Microsoft if *anything* goes wrong with your computer so it's always "on Microsoft" to make sure your computer works. Here's a [fine example](https://blogs.msdn.microsoft.com/oldnewthing/20030828-00/?p=42753). I also recall another post from the same blog relating how when investigating dumps, it appeared that the `XOR` instruction was broken for some users, as in, literally `0 XOR 0` would return `1`. Was Windows so broken that it fucked up your CPU? Now, people had just been sold overclocked computers unbeknownst to them. But are they gonna blame the store? No, Microsoft, of course! *That's what you do!*^TM
FYI, you're shadowbanned. You'll need to talk to a reddit admin (as a subreddit mod, I can notice shadowbanned users but can't help them, except for approving their comments individually).
It looks like we do have yaml-cpp coverage - I suspect it's through vcpkg instead of "Real World Code" as my coworker Alex [submitted an upstream fix](https://github.com/jbeder/yaml-cpp/commit/0f9a586ca1dc29c2ecb8dd715a315b93e3f40f79) and Alex works on vcpkg.
Thanks for the repro, I've reported this to our constexpr dev.
_NOEXCEPT wasn't noexcept(true) vs throw(); it existed only to suppress "noexcept used but exception handling mode not specified; termination is not guaranteed" warnings. Here is a patch for yaml-cpp. If you use vcpkg, it gets applied automatically. https://github.com/Microsoft/vcpkg/blob/master/ports/yaml-cpp/0001-noexcept.patch
VS 2019's branding has been publicly announced, but we haven't announced a release date yet (AFAIK). While it's version 16 of the IDE (like VS 2017 was version 15), it will contain a C++ toolset that's binary-compatible with the 2015/2017 release series. This will be a 14.x toolset (exact versioning may vary).
Simmer down, pal
Thanks for the clarification. I'll wait until this version for updating.
My biggest piece of advice for people fresh into their first professional job is to not take negative comments made in a code review personally. Also, ask questions if you're stuck, don't just sit there freaking out to yourself. FetusFeast mentioned writing small programs as the best way to get to grips with a new concept. Totally true, I do it all the time too.
hey reddit-land, just an FYI, we are monitoring and trying to figure out what we missed here. will update when we know. Just sent a heads up to the team on this thread. Steve, VC Dev Mgr.
Avoiding 15.8 is an undesirable outcome - do you have a list of the regressions that you can't easily work around? We have the ability to backport fixes, although they have to be approved by management (so we don't backport everything and destabilize the product).
&gt; It's the only thing C has, but C++ doesn't Only if you forget compound literals, variable-length arrays (along with the whole family of variably-modified types), flexible array members, designated initializers for arrays (and actually usable designated initializers for structs/unions), static array indices, anonymous structs, generic selection, the fenv pragma, and malloc that can create objects.
I feel the same way about our code, but I believe the biggest improvement was NSDMI. It got rid of endless repetition, lots of constructors, and a considerable number of cases where the initialization was simply (and erroneously) missing. 
With contracts added to the standard, maybe we don't need to add a hard-to-specify keyword `restrict. We could instead consider adding a much narrower `std::aliases` that could take a pair of ranges and tests whether there's any aliasing between the addresses they cover, and then just say `[[expects: !std::ranges::aliases(input, output)]]`
There was a related paper [N4150](https://wg21.link/n4150) from 2014. Although [issue list](https://cplusplus.github.io/EWG/ewg-active.html#72) shows that reception was positive, there doesn't seem to be any recent paper. &gt; Straw poll: Encourage continued work? &gt; SF 11, WF 9, N 3, WA 0, SA 0. 
Can you submit bugs for the regressions? We might be able to fix them in micro-updates, or provide simple workarounds while fixing them in future toolsets. Even if they look really complicated, they might be caused by something small. I know I repeat this ("please submit bugs") in my comments, but I spend a huge amount of my time dealing with evolving layers of tech (C1XX/Clang/EDG updates affecting the STL, STL updates affecting user code) and figuring out how to keep improving things without breaking the world. In general, using preview releases, reporting issues upstream, and applying temporary workarounds is a good way to steadily move forward. We do this in the STL to a greater extent than you might imagine - we work in the same branch as MSVC's front-end C1XX, and I test Clang's release candidates and upgrade to each major version. This results in lots of compiler bug reports, and workarounds being added and removed - search for TRANSITION in our headers to find them. Notably, this makes things better for third-party libraries like Boost - bugs that affect the STL will almost certainly affect other complex libraries, and we find and report them first. Sometimes bugs are truly blocking and there's no choice but to avoid an update until they're fixed, but that should be a last resort.
I'll try to find them all or try to find workarounds. I reported what I found was easily reproductible while testing 15.8 preview. Even then, two of my bug reports contained the preprocessed source of a failing code. Understand that extracting a self contained reproduction of a bug can be time expensive, and I do this in my free time. I'll test what I can. It's really nice to hear that backporting is possible, I really appreciate the effort. I'll see what I can do.
Thanks! While minimal self-contained repros are ideal, preprocessed repros are always acceptable for compiler bugs (certain back-end/linker issues involving multiple translation units require "link repros" but this is rare). As long as your preprocessed file + command line triggers the same bug as compiling the original file, the compiler devs can find the root cause. For library bugs, preprocessed repros are less desirable (as they don't separate your code from header-only library code) but they're still preferable to nothing.
How up-to-date are you on the C++20 proposals? There's a lot of work being done on your wish list. &gt; No smart enums [Static Reflection](https://wg21.link/p0194r6). Currently a TS, dunno if it's going to make C++20. &gt; No compiler generated comparison operators [Spaceship operator](https://wg21.link/p0515r3). This will be in C++20. &gt; No user-defined built-in types I think what you're going for is called a "strong typedef." I'm not familiar with any current work, but C++17 (or was it 14?) tweaked `enum` so that it can serve as a strong typedef of integer types. I know this is on the wish list of other people, so I don't think it's going away any time soon. &gt; Adding features at library level instead of compiler level A common complaint. This is a tough call, though -- adding things to the language severely complicates the language itself. Features interact in at least O(n\^2) ways: you have to consider how every feature interacts with every other feature, and sometimes in combination with several features. If something doesn't need to be in the language itself, it should be done within library. That said, maybe `std::variant` was a mistake. Maybe it should have been a language feature instead. I don't know. But the general rule holds, IMO. &gt; Template masturbation just to check if a function exists AKA [Concepts](https://en.cppreference.com/w/cpp/language/constraints). This will be included in C++20.
\&gt; Stared my first "programming" job but I think I'm under-prepared You are. \&gt; I've had very little formal C++ training in school Yep. \&gt; I've hardly used C++ for the past two years OK, you should burn for that. \&gt; I've never worked on large, collaborative projects like this before. Of course not. New hires never know shit. New hires that are new to the game don't know shinola either. \&gt; I get the feeling that everyone else is a C++ expert I very much doubt that. Maybe from your perspective, but a lot of devs, who usually stay in the game until they retire, never really get any better than you are now. They just get promoted. Of course I never really worked in a competitive market. Most seem not to be and are just desperate for anyone that can at least get the basics...you know, or not.
Um ... I think you need to write a proposal on this. On paper, that actually sounds like a great idea!
No, restrict is not needed for classes of different types or different pointer types.The compiler assumes different types may not be aliased, unless you use gcc's may_alias.
Eh, I just use CMakeLists.txt as a list of the source files in my project and set up a custom target to call a wrapper shell script that does my actual build (it uses ant... hey, it's not my choice). Works just fine for me...
&gt; How up-to-date are you on the C++20 proposals? Not very. I knew of some proposals for things that sounded amazing but nothing specific to the things I mentioned (except for the spaceship operator). I'm looking forward to anything that can alleviate at least part of the issues I mentioned.
we will be using the dev comm data to backport some issues to 15.9 (or for severe common issues, servicing updates to 15.8) so for anyone reading this please search for any issues you see and upvote / file. Sorry for the inconvenience.
Thanks for the clarification and the patch. We're inside various firewalls, so I'll have to hand-lift things over. It's always a pain point when libraries don't move as fast as their users.
It's not built-in to the language yet but [Better Enums](http://aantron.github.io/better-enums/) helps a lot with improving the current situation. Compatible all the way back to C++98. It's helped a lot with me in my work.
I found that once I started to really record the lessons I picked up everyday, that my learning accelerated quite a bit. I really try to encourage all of our new engineers. I'm not sure that QOwnNotes Or Orgmode are the perfect answer though. Most of the wiki software I tried was a pain to use, had a weird format / markup or search, and didn't store well in git. I wanted my notes to be portable, for when I find a better system.
Word!
Sure, but you could have a function that takes `double *A` and `struct S { double *B;}`, and want to declare that the referent of `A` doesn't alias the referent of `B`. If those are, say, a vector and a sparse matrix, knowing they're distinct could be quite valuable for vectorization, parallelization, etc.
&gt; I love and hate implicit conversion. I just wish there were a compiler flag to enforce something along the lines of 'Treat implicit anything as error'. Or it be nice that everything were explicit and you had to explicitly set things to allow implicit.
&gt; C++ stdlib has a lot of things that can be "restrict"ed &gt; I'm using "__restrict" twenty times a day For these exact reasons *everything* should be restricted by default and only explicitly `relax`ed where needed (0 to 1 times a year or so). 
&gt; Adding features at library level instead of compiler level Absolutely this. C++ needs a "library -&gt; compiler" spec update. It would really clean the language up.
&gt; Malloc not being able to create objects makes sense because objects aren't structs I was referring to the current bug in C++ spec that makes it impossible to even create an object of type int with malloc
Ah that. My C++ knowledge is mostly limited to embedded systems with GCC, and there's a ton of stuff that just never comes up on embedded.
Just like /u/mjklaim said, you can have your `special_int` by wrapping it in a `struct` or a `class`. struct special_int { int value; explicit special_int(int v) : value(v){}; }; void func(special_int x) { /* Your code that requires special_ing */ }
I'm serious but yes it's harder than in c# (but then, you have control on what is exactly the string). The main issue is that you have to write code so there might be mistakes. Things like reflection would help with that but wouldn't still be as precise as a way to specify the string equivalent.
Sure. However our method of programming is: implement the features you need and don't waste time writing stuff until you actually need it. So with that said it's severely stripped down feature wise compared to std::variant however in most use cases that doesn't matter (it didn't matter at all for us when we switched over to it). https://gist.github.com/Rseding91/b63189f13f538e4a26ed627f48fd0a45 It has several assumptions: * All the types are noexcept movable (you could re-work it to not enforce that but I've yet to find a place where we didn't want it) * You can't have the same type in the variant by-value and by-pointer (again you could remove that limitation if wanted) * All of your types are default constructible (again, could be changed)
Reflection specifically will not ship before 2023, hopefully not after.
That doesn't bring along all of the standard behavior of how int works. You can't do special_int + special_int without writing operator+ and everything else which I don't want to do. I want to just do this: special_int : protected int where special_int can call and invoke any logic on int it wants but special_int + int can't.
I believe we use some variant of that now. but that's what I would describe as "error prone hacks". Every usage of that requires you add in all of the other logic you may or may not want.
Hey, there's some really cool stuff in this update; thanks for the great work! Are you by any chance able to give a rough ETA for range-v3 support? It's something I'm eagerly awaiting to properly experiment with. :)
Do you really want an error when a `std::string_view` is implicitly created from a `std::string`?
So what you're saying is that comparing your variant to `std::variant` is apples to oranges?
&gt; // prints "Red" As if we didn't learn better from the issue with C function overloading and typesafety. Clearly a string representation of a C++ identifier should be unique and exact: "::__cxx11::ns15anoymous1252262::e3Foo3Red".
Maybe not string related stuff since they're so common. 
You could take it that way. If you wanted to re-implement all of the bloat that std::variant has you could. The version we have is a simple tagged union which is what we actually wanted but got the full package that is std::variant.
They broke driver development lul https://stackoverflow.com/questions/51853537/error-lnk2019-unresolved-external-symbol-checkfordebuggerjustmycode-reference/51855915#51855915 Updated today, drivers are no longer compiling. GJ on testing, boys
My last project in C++ using a RPi was to build something that works just like a telephone to be used as part of a puzzle. You will need to handle the keypad, the hook and the audio output. It should work as a regular phone. Dial tone, DTMF tones for each key, busy tone, calling tone... I used FMOD, a fantastic library used in many games and it really makes dealing with audio a breeze. There should be some kind of mapping for correct numbers that will play some audio piece, like someone answering the phone, and then hanging up. Any number not in the list will play the busy tone or some message. In my case, after the message was played, a relay was activated until a special sequence of numbers was used to reset it. For a more advanced version, you could try to include a mic and some voice recognition. RPis don't have audio input, so you will need extra hardware.
&gt; No user-defined built-in types I'm not sure I understand the use case. If you're worried about function interfaces wouldn't a proposal of an `explicit` qualification on function arguments be what you want? int func(explicit int); int main() { int i; double d // OK func(1); func(int(1.0)); func(i); // ill-formed func(1.0); func(d); }
This was known -- you're supposed to opt into that with /JMC... that's why there's a switch for it at all... removing the /JMC switch should work.
&gt; We treat regressions as high priority and are tracking this bug internally. We're happy to hear feedback from any source, but for this and other issues filing a bug in the C++ dev comm will allow us to communicate the status of fixes and workarounds more directly. I filed a bug this morning. But frankly, this is very distressing. Since VS2015 (can't speak for before since it did not really support C++11 back then), *every* minor release and sometimes even patch release have broken my code or [code of libraries I use](https://github.com/OSSIA/libossia/tree/master/3rdparty) at some point - the last time being 15.7.6 for instance. Meanwhile, I don't remember one time where I had to change my code when upgrading clang / GCC - and I sometimes test with git HEAD versions of those. 
[removed]
I've asked this on the Gitter channel, verbatim copying it here: --- We've discovered this issue month ago, in the 2017 15.8 beta, and now it hits us in production. Simply put to compile failed to compile now with /std:c++17 with msg "You've instantiated std::aligned_storage&lt;Len, Align&gt; with an extended alignment..." (from &lt;type_traits&gt;). The recommendation is either to compile with _DISABLE_EXTENDED_ALIGNED_STORAGE or _ENABLE_EXTENDED_ALIGNED_STORAGE - We've compiled with the DISABLE one, but app was crashing in weird way (strange callstack). We haven't tried (yet) _ENABLE_EXTENDED_ALIGNED_STORAGE because it might cause hidden bugs - we do have a lot of precompiled software (we precompile it), but then a lot of external precompiled (by someone else) frameworks. So In general - is there are tool, methodology (something looking at the symbols, class/struct dumps) to tell us what needs to get recompiled, etc. Anyone else running into the issue? Related: https://developercommunity.visualstudio.com/content/problem/274945/stdmake-shared-is-not-honouring-alignment-of-a.html?childToView=280485#comment-280485 and facebook/rocksdb#4062 - https://forum.qt.io/topic/93714/visual-studio-15-8-0-and-qt-5-11-1-does-not-compile-qrandom-std-aligned_storage (we use Qt5.10 which we compile ourselves, and distribute locally the .dll files) Also use vcpkg to recompile things, and not super familiar with CMake, but in general we may have a very mixed bag of SDKs, Frameworks, open source, etc. all linking together, and we need to know what would work with what else. Is there for example some kind of /MISMATCH kind of pragma for this (at least to enforce it, though I realize this needs recompilation anyway). Otherwise we are stuck back to 2017 15.7 version of the compiler - e.g. have to set VCToolsVersion=14.14.26428 in the environment (also no longer works if it's set in the top of the .vcxproj, or top-level .props file)
You can also workaround it with `/D_NOEXCEPT=noexcept`
Yes the compiler knows all that and more but "reflection" is basically to allow the compiler to provide that knowledge to the programmer to let them do something with it (actually the providing part is "introspection"). Currently the compiler cannot provides you that because nothing in the languages allows it to provide it. Compiler implementers could easilly implement what you described and more but as long as it's not standardized or at least done in a very common way, it's not as useful as reflection.
TLDR - We need to know what to expect if you mix precompiled code with _DISABLE_EXTENDED_ALIGNED_STORAGE, _ENABLED_EXTENDED_ALIGNED_STORAGE or not having it all - and how to discover quickly what needs to be rebuild (out of sync with the rest).
&gt;Local helper functions that I don't want to pollute the namespace/class with I tend to use the anonymous namespace for this quite a bit, defining functions that are local to the compilation unit.
&gt; New hires never know shit. New hires that are new to the game don't know shinola either. Not true, they'll have watched Herb Sutter's videos on YouTube. Tedious conversations will then ensue where the new hire will learn about the realities of modern software development.
BillyONeal, with all respect, this is amazingly bad, when you update your IDE, and your code is no longer compiling.
looks more like an advertisement than a tutorial to me
If you didn't update your project to throw /JMC and /JMC got thrown for you maybe that shouldn't happen. If you enabled the feature but didn't get updated libs that provide a symbol it needs I don't know what you expect us to do.
DISABLE provides the original behavior, so you can freely mix object files, static libraries, and DLLs built with 15.8-DISABLE and built with 15.7 or earlier. You get the exact same representation as before, so there are no mismatch implications. If you're seeing crashes when mixing 15.8-DISABLE and 15.7-or-earlier, the cause *cannot* be mismatch. (It may be something else, or it may be the improper alignment itself.) ENABLE activates the new representation, so you can't mix object files and static libraries with ENABLE-sensitive layout. (Same for DLLs when such classes are on the interface.) If you can at least recompile everything, you can put a mismatch pragma next to your alignment-sensitive classes, but that doesn't work if you really can't recompile anything. Since your app was working before, I recommend compiling in DISABLE mode, upgrading as much as you can to 15.8, and investigating the root causes of any crashes. 
actually, it is a bit of both if you want to call it that, it is a video tutorial for an open source extension for visual studio that I have developed
I'm aware of all that :) and I'm all for some kind of reflection - just back to my original post complaining that it has been how many major versions and how many years and we still can't do even something as basic as iterate all enum values.
I've got to ask. How is one supposed to keep track of so many mismatched version numbers?
You have an exam in a language you've never used before?
It took me 7 years and even then I feel there's so much more to learn. The question is: how much do you want to be ready?
These are just intro classes, so I think I'll only need to get used to the syntax and be able to write simple applications.
You kind of can, by adding a private cast operator, and making all classes that want to use your special_int a friend, but it's still a bit awkward.
&gt;Hey, there's some really cool stuff in this update; thanks for the great work!Are you by any chance able to give a rough ETA for range-v3 support? It's something I'm eagerly awaiting to properly experiment with. :) blog post update coming soon.
I don't get what you're trying to say. `rel_ops` just redefines `&gt;`
 "*Enhanced debugging for* ***Viual*** *C/C++. Dump blocks of data, load data in memory and more.* " Is this supposed to be 'Visual'? Just a heads up.
Thankfully it is being deprecated in some future standard.
Well that really depends on your capabilities, how well your brain is able to process new things, etc.
So what have you done all the time prior to the Data Structures exams? Why haven't you studied C++ since the beginning of the class? If Intro to CS was offered in C++ and you knew Data Structures was C++ only why didn't you go the C++ route? Sorry dude, you screwed yourself. Take your classes seriously next time.
Additional release notes: * C++20 feature-test macros are now supported in the compiler and libraries (with the exception of `__has_cpp_attribute`, which will be implemented in the future). Feature-test macros are unconditionally provided regardless of Standard mode (that is, individual macros are defined or not defined depending on the Standard mode and fine-grained options, but you don't need to opt-in to getting the macros at all). All library macros are provided by dragging in any STL header; C++20 &lt;version&gt; is not yet implemented but when it is, that will be a way to get the macros without any additional machinery (in the meantime, use &lt;ciso646&gt; for the same effect). * Floating-point `std::from_chars()` is now available in C++17 &lt;charconv&gt; and is approximately 40% faster than the UCRT's strtod/strtof. It has been extensively audited for bitwise correctness (with no bugs found, in either charconv or the UCRT).
!removehelp
Yesterday, and yes I've also worked with the latest, UE 4.20. It's really pick one: Modern-style, pleasant C++, or UE. And that includes everything from their build system to code, compiler flags and documentation. If you like it, you probably also like C++98 and autotools, or something along those lines. I'd rather stick to C++ from this decade, a build system where I **can** actually change compiler flags (and don't tell me to edit build files in C:\Program Files\UE....), and something with decent documentation. Really, I've never had to work with anything as horrible as UE4.
Cool! That fix was already committed on June 30 btw (I suppose more or less as soon as the first 15.8 Preview came out). Nice works.
&gt; nothing in the languages allows it to provide it That's not true at all. A compiler can implement any number of extensions to the language. And here, specifically, it could be a rather simple library extension backed by codegen. Instead of having `for (auto value : EnumType)`, a syntax change, you'd have `for (auto value : __ext::EnumType::Values) { ... }`. The `__ext::EnumType::Values` is declared as an initializer list. The compiler would generate it, but it the linker would discard it if it was unreferenced. Thus clearly pay-for-what-you-use, and a completely compliant extension without any side-effects for existing code.
I'm not sure if I prefer whitelisting or blacklisting aliases. What's better - aliases: a, b. Or distinct b, c? Really, the question becomes "strict aliasing or no?"
Having to define those operators is exactly what I want to avoid.
Yes
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/97muc6/q_are_the_books_by_scott_meyers_namely_effective/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don't have the space on my SSD to budget for an entire second installation of VS (preview) to test. I do have the space to budget for a [preview build toolset sans IDE](https://visualcpp.myget.org/feed/dailymsvc/package/nuget/VisualCppTools.Community.Daily.VS2017Layout), but that still hasn't been updated since April despite [this promising comment](https://www.reddit.com/r/cpp/comments/8u52b2/visual_studio_2017_version_158_preview_3/e1hggfr/?context=6) over a month ago... Compiler Explorer _just got_ dailymsvc-package support a couple months ago, so people everywhere can test the latest compiler easily, and you guys just completely abandoned it. Sad, for real.
What's the compile-time cost for this? It feels like because there are so many hacks and tricks that it'll end up costing a lot of time to compile just for basic stuff.
I'm not even a CS major, but I'd like to minor in it, so I'm taking several (optional) proficiency exams at the beginning of this semester. I knew Java since high school, so that's why I initially began brushing up on the CS Intro class, but now I'm faced with this dilemma.
Is that a common guarantee to make? Every C++ lib I use either expects an exact match between headers and binary or they have a C interface.
Well, some argue that parts of ADL also are an abomination :p
That's fine if the TU is small enough. But making it local is a strong signal to only expect that the local function's implementation has only considered input/behavior that's relevant to the outer function. Makes it a lot more readable IMO.
This is related to the new C++ Just My Code Stepping feature in Visual Studio 2017 15.8. Because the feature depends on CRT (C Run-Time Libraries), if the project does not link to CRT, it may hit "error LNK2019: unresolved external symbol \_\_CheckForDebuggerJustMyCode". The workaround is to add /JMC- to compiler option. Etc, in project setting, add /JMC- to "Configuration Properties" -&gt; "C/C++" -&gt; "Command line" -&gt; "Additional Options"