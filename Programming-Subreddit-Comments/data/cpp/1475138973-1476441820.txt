But operator overloads can be free functions?
Even then: The only reason I can think of doing a generic interview would be if I was looking for consultants. It never hurts to have a generalists on a consulting team that you can dump into a wide range of projects without embarrassing your company too much.
Does anyone know why this video was removed?
Dunno, but [here's a mirror](https://www.youtube.com/watch?v=vwrXHznaYLA).
Slides available [here](https://github.com/CppCon/CppCon2016/blob/master/Presentations/The%20MAME%20Story%20-%20From%20C%20to%20Modern%20C++/The%20MAME%20Story%20-%20From%20C%20to%20Modern%20C++%20-%20Miodrag%20Milanovic%20-%20CppCon%202016.pdf). 
got an RSS feed?
Thank you very much. :)
Commit with some comments about that https://www.mail-archive.com/cfe-commits@lists.llvm.org/msg36479.html
From that isuue I get that they do not support precompiled headers and don't have plans to, but they *do* support modules.
As a women in tech with a bunch of years of experience by now, I think I should speak up. First of all, thanks Meeting C++ for introducing this initiative! Secondly, I understand that opinions are different and they're always gonna be. It's hard to make everyone happy and I know that people like cppenthusiast are probably never going to change their mind. At least not consciously - that would require wilingness to do so and paying some effort into educating themselves. Yes, educating on facts, not only sharing pure feelings and opinions. I mean, it's fine to have opinions and share them. But it's also good to admit they're just opinions. And that they can vary among people. Like, for instance, spreading the word that women "don't like cpp more than Ruby". I think everyone likes to work in a nice and friendly environment. The community gathered around Ruby actually happens to do a great job being open and welcoming. On the very early stage they focused on making people aware of what it means to be inclusive and that jokes based on stereotypes / sexism are just not funny. And it worked. I believe it can start working in the C++ communities as well. I used to go to a lot of tech meetups and some just didn't make me feel like going back there again, especially due to some not-so-funny jokes I needed to hear. So sure, I doesn't mean I should drop using the language because of it, but honestly, it's cooler to talk to and hack with people who are actually nice and respectful and who you find a common language with, isn't it? I studied Computer Science at the faculty, where some old professors thought no woman should become an engineer. Just because. You develop thick skin over time, but hey, sometimes, you're just like 'screw it, why would I want to keep hearing stuff like this over and over again?'. And you head somewhere you don't have to. To sum up - I believe that seeing a more diverse crowd around changes the way people think and is the only way of getting rid of all kinds of stereotypes and bias we've all developed throughout the years. It's ok to admit we did and it's cool to want to do something about it. And of course, you can disagree. But just because you do, does it mean such initiatives should be dropped, even though others believe in them?
**Company:** King **Type:** Full time **Description:** C++ Game Developer - Candy Crush If you want to create amazing user experiences and entertainment for millions of players to enjoy on the go then this is the right job for you. Together with your colleagues you will have a part in creating and maintaining our mobile casual games. You will specify, design, build and implement existing and new game features. As part of the development team you will enjoy a creative, challenging and collaborative environment where your ideas will be every bit as valued as your programming expertise. Your responsibilities will include: - Designing, testing and implementing game features - Taking an active part in game creation - Maintaining and optimizing new and existing game features - Contributing high quality and well-structured code to our global code base - Sharing knowledge and helping colleagues [Take a peek at our office!](https://www.youtube.com/watch?v=TvIpR4YjX1M) **Location:** Stockholm, Sweden **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++ 11 **Contact:** Send your CV to Dan Orre at dan.orre@king.com **NOTE:** NO RECRUITERS 
Which OS are you targeting? POSIX-interface?
How's that stay-at-home thing working out for you? :-)
&gt; I was always told ffast-math is dangerous and should not be used. What do people here think about it? I used to be afraid of it, but once I started using the Intel compiler and read up a bit more on floating-point, I embrace it everywhere (except in unknown or known to be broken libraries)
Sure do, it's the RSS link in the top bar. Alternatively, the link itself is standard format: http://www.voidae.com/blog?format=rss
As ever, claims of impossibility are tricky to analyze.
How closely are you going to follow the STL specs? 
Implementing `std::tuple` isn't that bad, it's more an issue of template magic on top of template magic, on top of inheritance ;)
Tom NEVER got a cookie. It was Tim who got the cookies last year. Tom is the new guy who'll not get a cookie because Tim was a jerk to everyone, and because they have the same skin color. But everyone just looked at them as a same person because they're obviously racist. Don't look at people as groups, but as individuals. Then look at anything beyond your bullet-points, and see how horrifying that could make innocent people feel. Also, your bullet-points are the only thing you can do without discriminating against anyone.
Which reminds me of the code I made recently #include &lt;iostream&gt; #include &lt;stdlib.h&gt; struct C { C() =default; C(const C&amp;); // never defined: declared only to allow copy elision C&amp; operator=(const C&amp;) =delete; C(C&amp;&amp;); C&amp;&amp; operator=(const C&amp;&amp;) =delete; }; C f() { return C(); } int main() { std::cout &lt;&lt; "Hello World!\n"; C obj = f(); } Which also reminds me why I hate includes... why the heck is that 2.5 MB lol
Done. I hope they improve the static analysis checker using the core guidelines.
Twas a joke :-)
Slides are not yet available, but hopefully will eventually be available on [CppCon 2016's GitHub repo](https://github.com/CppCon/CppCon2016). 
He is talking about all of the STL and his overview lists iostreams, tasks, chrono, locks and so on. Edit: There is a blub on the website about skipping OS specific stuff.
Yep, sure! :-) Thanks :) Odd, I've never seen functions pre/postfixed with f/d etc. They have type aliases, maybe that's what you found (e.g. dquat is an alias for tquat&lt;double&gt;, etc.).
[Boost Hana](http://www.boost.org/doc/libs/1_62_0/libs/hana/doc/html/index.html) is a modern TMP library. Maybe learning how to use it and looking at its implementation might help you.
w-why would you want this? üò∞
The speaker is drunken.
This data structure should be called a "pile" or a "mess". Putting stuff in is easy. If you can find it, and that is a headache, taking stuff out is easy.
Towards the end I will inevitably have to target something OS specific, but until then everything else is platform agnostic. I'll probably use the POSIX-interface for threading, locking, and such.
Isn't this basically what boost::hana is all about? http://www.boost.org/doc/libs/1_62_0/libs/hana/doc/html/structboost_1_1hana_1_1string.html
I beg to differ. Implementing std::tuple is bad.
The odds of Tom never having had a cookie in their life is very high. Chances are that Tom spent 3-4 salaries worth of money to pay for the the conference ticket, a 20 hour bus drive (planes are a luxury for Tom) and 2* hotel for the duration of the conference. And that isn't even an outlier, you just have to live in a certain country to be in that situation. The bullet-points really are the best approach - it doesn't bring instant change, but impulsive changes bring oscillations that never settle in the point you want to reach. Many creative ways to do the bullet-points though - a photo gallery would be a simple example, where people who care can directly get informed, while others don't even notice it! I'm a proponent of keeping personal data anonymous when doing selections in general. A selector shouldn't even know which university/company/country they represent - their proposed topic/summary/paper/whatever should stand on its own merit.
What is "mainstream modern TMP" then?
Iterating all the elements in a colony is also fairly efficient. I tend not to be able to consider all the individual things in a piled mess very easily. Maybe I'm doing it wrong? :p
Ahh, ok, that makes a lot more sense. I was going to ask why you are using std::remove_reference instead of "stl::remove_reference" but its because you are not writing your own remove_reference function.
Oh I know, and likewise. Sorry, I replied right after I woke up, came off much snarkier than intended. :-S TBH, to my surprise I've never had anyone so much as flinch at F# in an interview; using modern C++ definitely results in significantly more confusion most of the time.
More than just the STL, then.
This is very interesting especially when you move into embedded systems and also where you have a lack of libc. I currently started writing something similar for a closed hardware system (all we have is code exec, no libs or anything)
Yes I know. I'm using that addon. It's great. Keep improving it. :)
I'm not saying it should fix Tom's financial situation, I'm just showing you that the white able-bodied male called Tom far from being a 1 in 10000 situation. A conference should generally not try to fix problems it's not contributing to. I'll be perfectly honest here: I think the problem you've presented right there - solving that complex issue will probably be the _greatest_ contribution to diversity in the long run. A good preprocessing system is much better than having people calculate their inner biases with magic formulas :) A principle that I guide myself with in decision making is giving up of control. A scoring system, decision trees that must be followed at any cost, etc...
I forgot how much fun arguing semantics is :) Colloquially the stl and the c++ standard library are used interchangeability - the OP doesn't seem to make the distinction either. But you are of course right, the road map lists the part of the standard library.
edit: I've just now realized that you meant in the context of the array-version of `swap`. I've made the correction and noted it at the top of the article. Thanks =) Yes and no. The standard requires two "default" `swap` implementations to be placed in the `&lt;utility&gt;` header; one for unqualified reference types and another for arrays. User defined swaps are required to be eligible for ADL in the standard container and algorithm libraries, which is why any method in the above using `swap` will perform it in a way equivalent to: using std::swap; swap (a, b); so that ADL can take place. Whether one of the two `swap` implementations from `&lt;utility&gt;` is used depends on what user-defined implementations (if any) are available in that context.
Should you also remove `stl::` from noexcept-declaration of array-swap?
Done.
Thanks, sorry about that, it's been a long day.
The problem is with non-member overloads. Because the destructor calls for parameters are run in the callee from left to right (for both `__stdcall` and `__cdecl`), and because C++ guarantees that those destructors are run in the reverse of the order in which the parameters are constructed, the parameters must be constructed right to left in the caller. Any other option requires an ABI change or non-conformance. Edit: It's worth noting that MS can probably address this in a future release by changing their ABI in some way. But as Clang aims to be compatible with the existing MS ABI, this isn't an option that's really available to us.
They're tricky to analyze until somebody proves them wrong. I this case, I think they're wrong. It looks to me like they're conflating the order in which arguments are arranged on the stack (which `thiscall` requires to be right to left) with the order in which they're evaluated (upon which I don't believe `thiscall` places any requirements at all). Given something like `foo @ bar;` it is, of course, easy and obvious) to do a sequence like; evaluate foo push evaluate bar push mov rcx, this call func or else evaluate bar push evaluate foo push mov rcx, this call func `thiscall` requires that the arrangement on the stack reflect the latter order--that is, arguments are pushed right to left. `thiscall` does *not*, however, specify anything about order of evaluation or destruction, only about the arrangement on the stack. As such, you *can* do something like: sub rsp, 16 evaluate foo mov [rsp+16], foo evaluate bar mov [rsp+8], bar mov rcx, this call func Of course, in the callee, the destruction order must be a mirror image. We now have a return value on the stack as well, so we need to adjust for that: mov rax, [rsp+16] call bar_dtor mov rax, [rsp+24] call foo dtor ret 16 This is a little longer/clumsier/more complex than a sequence like: pop rax call foo_dtor pop rax call bar_dtor ret 0 ...but not to a degree that's particularly significant, unless, perhaps, somebody's still writing code for MS-DOS, where squeezing their code and data into 640K means a few extra bytes for `mov`s instead of a one byte each for `push`/`pop` is a major problem. :-) Note: the fragments here assume that `foo` and `bar` are of types that will fit in a single register. If they're too large for that, you obviously need to push/pop more data (but all the sequences are affected similarly). I've also written kind of a warped version of the code that would be produced. For a given call, you'd end up *either* moving the address of the left operand into `rcx` *or* pushing it on the stack (former if overloaded as a member function, latter if overloaded as a free function). To cover both possibilities, what I've shown includes both of those.
Interesting stuff. Some thoughts: There's no such thing as O(random). (as far as I know). plf::colony doesn't really do efficient lookups, does it? Given the index of an item in the colony, finding it will be O(n) presumably. This is a major slow point when compared to std::vector, std::map etc. When comparing performance with STL datastructures, especially for unordered data structures that support efficient addition and removal, you really should compare against std::unordered_map. It should be quite a lot faster than std::map. And there are faster hash map implementations available (e.g. google dense hash map). I think they would a good thing to compare against. The overall colony data structure reminds me a lot of a memory allocator with a free list etc.. (except you are using a free stack).
Slides are available [here](https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Template%20Normal%20Programming,%20Part%202/Template%20Normal%20Programming,%20Part%202%20-%20Arthur%20O'Dwyer%20-%20CppCon%202016.pdf).
Slides are available [here](https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Template%20Normal%20Programming,%20Part%202/Template%20Normal%20Programming,%20Part%202%20-%20Arthur%20O'Dwyer%20-%20CppCon%202016.pdf).
Please see my other comment. The problem is in ensuring that the order in which destructors are run in the callee is the reverse of the order in which constructors are run in the caller. This is de facto part of the ABI. And consider a case like this: struct A { A(); ~A(); /*...*/ }; struct B { B(); ~B(); /*...*/ }; void operator&lt;&lt;(A, B); // calls dtors for A and B in some order void operator+=(A, B); // calls dtors for A and B in some order void f(bool cond) { A() &lt;&lt; B(); // guaranteed to construct A param before B param A() += B(); // guaranteed to construct B param before A param auto *fp = cond ? &amp;operator&lt;&lt; : &amp;operator+=; fp(A(), B()); // compiler picks an order } In order to support the first two calls, `operator&lt;&lt;` must destroy the `B` param before the `A` param, and `operator+=` must destroy the `A` param before the `B` param. In order to support the third (indirect) call, the construction order picked must be compatible with the destruction order of all possible callees. And that's not feasible if `&amp;operator&lt;&lt;` and `&amp;operator+=` refer to the same code that's run by the `&lt;&lt;` and `+=` expressions. This could be solved by changing the ABI in a number of different ways (for instance, generating two functions for each of these operators, with different destruction orders, or passing a flag to specify the destruction order, or -- if the ABI otherwise supports it -- by destroying the parameters in the caller instead). If you see a way to address this without an ABI change, we'd be interested in what it is.
No, everything is in english. You can find talks on youtube
Oooh, it would be pretty easy to extend this to do compile-time prehashing! Instant hashmap lookups! I might try it...
Careful here. Not all `__declspec()` can be erased and the resulting program lead to the same semantics -- a "requirement" for attributes (a compiler should be able to ignore your attributes and still generates acceptable/sam code).
It would be great if all that was also explained in the tutorial :) it was really a bit confusing
Well, I know about typename, but the subtleties of the signature of the function in this case were explained a lot better in the comments here than in the article. 
I think what we really need is a Modern C++ migration quick-fixes and context actions. Like say you're working with a raw pointer: having an action to *Replace with unique_ptr/shared_ptr* while preserving correctness would be cool. Static analyses for move semantics (make this argument by-value and put a `std::move` here) would also be great. Oh and 'refactor everything to use modules' :)
To be fair, the use of | as operator for sequence chaining is truly unintuitive. Couldn't `-&gt;` have been used? Or maybe some double-hop operator like `---&gt;`? 
Thanks for sharing this. We'll try it out.
[deleted] ^^^^^^^^^^^^^^^^0.8053 &gt; [What is this?](https://pastebin.com/64GuVi2F/07117)
Sweet. I know the authors, so surely worth the read. Yet, its free as in "Pay with you email address".
Original video here https://channel9.msdn.com/Shows/Going+Deep/E2E-Herb-Sutter-and-Erik-Meijer-Perspectives-on-C (posted Jan 13, 2011)
"Having a C++ package manager is a fallacy, such a thing cannot (in a sane mind) exist. For good or bad, what can exist are C and C++ package managers." So C++ package managers can't exist, but C++ package managers can exist? Two consecutive lines in the post, directly contradicting each other. 
&gt; template &lt;class T, std::size_t N&gt; &gt; void swap (T (&amp;a_array) [N], T (&amp;b_array) [N]) &gt; noexcept (noexcept ( &gt; swap (stl::declval &lt;T &amp;&gt; (), stl::declval &lt;T &amp;&gt; ()) &gt; )) As explained in [LWG 2554](http://wg21.link/lwg2554), the noexcept-specification is actually incorrect.
definitely something a C++ guru should read through.
http://i.imgur.com/xfeud9m.png
Thats nice, but their website is the worst I've ever seen.
You're right, thank you for pointing that out, but it's incorrect as of [P0185R1](http://wg21.link/P0185R1)'s acceptance into C++17. Prior to that the noexcept specification is "correct" (unfortunately so). Since it's not guaranteed that the people reading the post have access to `std::is_nothrow_swappable` I think it would be better to leave a note and link to P0185R1.
http://www.pinvoke.net/default.aspx/misc.Helpful%20Tools Lots of examples for dealing with windows DLLs and the link also points to some useful tools.
"Practical" and "C++ Metaprogramming" in the same sentence. Will have to check this book if they actually managed to do it.
This is off-topic for out sub; you can ask this sort of question on /r/cpp_questions.
Hi, I am one of the authors (Edouard). Should you have any question about the book, feel free to ask.
Will there be more?
Are you being paid for this book? If not, how can we reimburse you if we value the book? 
Thank you for your comment, don't worry about my compensation. :-)
It does have a syntax highlighter, but I'm not a huge fan of the theme. You're right, it could stand out more. I'm looking into alternatives right now (I'm using highlight.js, by the way).
No, assuming I understand correctly. `hana::string` provides a compile-type string but all `hana::string`s have the same type. OP's solution defines each string as a unique type. Very nice!
[Relevant repository](https://github.com/SuperV1234/cppcon2016)
&gt; Implying that not all forms of metaprogramming are practical. 
From the book: &gt;By definition, metaprogramming is the design of programs whose input and output are programs themselves. Put another way, it‚Äôs writing code whose job is to write code itself. It can be seen as the ultimate level of abstraction, as code fragments are actually seen as data and handled as such. &gt;It might sound esoteric, but it‚Äôs actually a well-known practice. If you‚Äôve ever written a Bash script generating C files from a boiler‚Äê plate file, you‚Äôve done metaprogramming. If you‚Äôve ever written C macros, you‚Äôve done metaprogramming. In another sphere, you could debate whether generating Java classes from a UML schema is not actually just another form of metaprogramming. &gt;In some way, you‚Äôve probably done metaprogramming at various points in your career without even knowing it.
Static assertions, compile-time branching (and recursion) based on statically available information and code generation come to mind as the main use cases, but any logic that runs at compile time counts imo. Templates are C++'s main tool for this. It's also doable using the preprocessor, if you're stuck with C.
omg, and each time I've wanted to kill myself. has anyone ever considered the possibility C++ template language is a crime against humanity?
We've successfully used it in [our product](https://www.quasardb.net) to : * Have rich compile-time checks * Analyze structures at compile time and generate zero-allocation (de)serialization routines when possible * Automated protocol regression testing generation (ie test that v2 is backward/forward compatible with v1) 
It's not just templates anymore. `constexpr` and static conditionals also count. And macros, though they're worse than templates.
Another person posted an excerpt from the book that may answer your question. If not, another way to put it: * *Programming* is writing programs. * *Meta-programming* is writing programs which, in turn, generate programs. * *Template meta-programming* is writing programs, which, in turn, generate programs (ab)using the template system of the C++ language. Like the Inception movie taught us, sometimes you have to not be afraid to do recursion. :-)
Hmmm. Only three chapters?
I was hoping my libc++ shared_ptr optimizations would have made it in to the talk. Oh well :) I think they represented a good case where the compiler had the leeway to optimize atomics, and in a way that could matter. http://lists.llvm.org/pipermail/cfe-dev/2016-July/050033.html https://github.com/llvm-mirror/libcxx/commit/16d768ba0d9a4c9a1b67f5600f1584977577007c
It's really great when you have a good understanding of it. It's basically just compile-time functional programming, but really powerful. TMP is my favorite feature of C++.
Perhaps you are in the wrong subreddit. I believe there are subreddits for more juvenile languages like Python, Ruby, etc.
Look at ReSharper. It preserves correctness even under large-scale refactorings. So yes, I would.
It is as clear and good as the previous presentation done by Mr Brown on [Metaprogramming](https://www.youtube.com/watch?v=Am2is2QCvxY). CppCon, if you are able to get another talk next year from him, it will be most welcome !
What other alternatives for that matter would you offer?
Anything a lot less ugly and easier to parse by eyes and compilers. the moving goal of which is the newer less ugly mixing of spaces and angle brackets should bring tears to any developer's eyes. I'll take lisp macro backquotes everyday. ETA: for examples: http://stackoverflow.com/questions/7304699/what-are-all-the-syntax-problems-introduced-by-the-usage-of-angle-brackets-in-c http://stackoverflow.com/questions/7087033/for-nested-templates-when-did-become-standard-c-instead-of http://stackoverflow.com/questions/15785496/c-templates-angle-brackets-pitfall-what-is-the-c11-fix Jesus, the shit C++ enthusiasts think is reasonable to foist off on developers and then snark that people who dislike that shit should use ruby as if no other design and syntax decisions could have been made.
Yeah that's a cool one! I trimmed a bunch of things out because 1h blows by fast.
Very good talk, don't be discouraged by the seemingly obvious topic - a LOT of good info in this presentation. Also, quick question: If I understood correctly, the engines are required to give you the same results cross-platform, but the distributions are not? Is there a standard way to get the same random values based on the same seed for a distribution cross-platform? Even just uniformly distributed?
It's an oversimplification to say that `hana::string`s have the same type. If they did have the same type, then they wouldn't be able to hold different compile-time values. `hana::string` is a class template that operates like a tuple over compile-time characters, which are passed as non-type template parameters to the string template. Of course, the Hana implementation is a lot longer than the original blog post because it uses C++14 and provides more features/concepts: https://github.com/boostorg/hana/blob/master/include/boost/hana/string.hpp
Do you go into reflection at all?
It is actually difficult to write a proper uniform_int_distribution that handles every conceivable input and output range. It requires a fair amount of detailed thinking.
The book has been great so far.
Thanks!
So it's not as perfect as I thought :( It kinda makes the header only half useful, if I have to implement a distribution myself (which, as STL mentions, is complex).
They write in a conversational style and give credit where credit is due: &gt; After a short while, Erwin Unruh came up with a very interesting program that builds the list of every prime number between 1 and an arbitrary limit. &gt; [...] &gt; Let's take a moment to ponder the scope of this discovery. It meant that we could turn templates into a very crude and syntactically impractical functional language, which later would actually be proven by Todd Veldhuizen to be Turing-complete.
oh boohoo. the worse crime for you is that you've probably been forced to rely on my shitty software to + keep your plane in the sky + authorize your credit card transactions + enable paramedics to communicate with hospitals, query databases as to why you always call them and many other silly terrible trivial exercises in bit fiddling. anyway, your name checks out.
**Please keep comments respectful. Disagreements are fine, insults are not.** 
The AV crew is still postprocessing and uploading Monday videos. Nat's talk was on Wednesday, so it will probably be a week or two.
I have insulted no one. Why are you addressing this to me? I was the one both those other guys insulted.
Interestingly, this book is not accessible from the top level page, http://www.oreilly.com/programming/free/. There is one more C++ book there though.
You still see support of the for scope thing linger on in modern compilers: [gcc](https://gcc.gnu.org/onlinedocs/gcc/Backwards-Compatibility.html#Backwards-Compatibility) and [Visual C++](https://msdn.microsoft.com/en-us/library/84wcsx8x.aspx).
Does this book mostly cover the template and preprocessor varieties of C++ metaprogramming, or do you cover other approaches?
A lot of the benchmarks I write start off as a single file which is compiled by hand. Sometimes -Wall doesn't make it into the Makefile when I eventually write one. AKA bad habit. Sadly, Clang is often not the first compiler I use.
Seems weird to choose javascript as an ideal implementation language. There's SoLoud, portaudio, SDL, libsoundio, and FMOD for sending samples to an audio device. There's also an audio lib from Evan Balster (programmer behind SoundSelf) but I don't remember the name of it. As mentioned in the other comment you could also do stuff with libpd. What was your reasoning?
After watching the talk I feel I don't know if I understood Almost-Always-Auto correctly to begin with. I think there was a whole lot of (unneccessary) refactoring going on, instead of just using *auto* instead of writing out typenames. I don't really see the point where using *auto* would force/require you to suddenly convert functions to lambdas (see Heal() and Hurt()). The speaker justifies it to some degree by saying he didn't like how *auto* behaves with C-style arrays, but then again the rule is **Almost**-Always-Auto. Later on with the branching examples where he starts using templates: That approach would be valid without using auto as well; you'd just have to type out the typenames again. Actual question though: should I start using *auto&amp;&amp;* instead of *auto* for most things? Does it have any benefits/drawbacks?
I believe auto&amp;&amp; is alway reference or pointer. Auto is tries to be nonref or pointer.
Any abstraction built with fprintf/ostream :)
Hi; this question is off-topic for our subreddit. Please try /r/cpp_questions, StackOverflow, or the Boost IRC channel/mailing list.
This is incredibly cool. Makes me want to write games directly against VGA hardware like I did in the DOS era...
Oh, that seems a lot less robust though. Interesting.
Could be pretty robust if your parser is good enough, can't be that hard to be better than the preprocessor. See for example: Qt's moc/uic/rcc I've also seen folks generate C++ source from lisp/sexprs. That's really easy to parse
Quite a few of those you don't need to deal with though when you write it for yourself since you have control over the generators (like not starting at zero, or it not being a clean power of two, ...), which makes it a considerably easier task than writing a distribution for the std library.
Presumably, this only affects stdcall and thiscall in x86? IIRC there's only a single unified calling convention on Windows x86-64, and I don't see how these issues would apply to that.
It does support templates.
I feel ya.
Also in Racket: http://matt.might.net/papers/ballantyne2014metameta.pdf (and any pure functional language rally, since that's what template metaprogramming is)
Looking through I note a couple of a strange overdesigned examples like this: static const std::uint64_t default_buffer_size = std::conditional&lt;sizeof(void *) == 8, std::integral_constant&lt;std::uint64_t, 100 * 1024 * 1024&gt;, std::integral_constant&lt;std::uint64_t, 1024 * 1024 * 1024&gt; &gt;::type::value; which is equivalent to: static const std::uint64_t default_buffer_size = 1024 * 1024 * ((sizeof(void *) == 8) ? 100 : 1024);
I feel ashamed that this wasn't my first thought. I also fondly remember `int 13h`.
The book is all about templates. No preprocessor (not really needed anymore in C++ 14).
OK thanks for the update
Why on earth was this given a platform to be presented? AFAICS, it seems just plain vaporware. The talk keeps referring to non-existing or non-usable homegrown libraries with suggestive titles like Boost.AFIO, Boost.KernelTest and Boost.Outcome, none of which have been officially Boost reviewed (apart from an earlier version of AFIO which was unanimously rejected). Yet, somehow, the author manages to present this over and over again on all the C++ major conferences. 
Any reason for the aversion to clang? 
Well if you remove all of the hairy templates you don't have `std::tuple` or `std::variant`.
My aversion is to other compilers, actually. In HPC, other compilers have produced faster code historically. However, Clang/LLVM is increasingly becoming an option in my industry, on both SIMD and now SIMT architectures with the introduction of the Clang/LLVM CUDA compiler.
I just want to point on the ternary operator. Surely `constexpr` is the best choice. Are you sure, that `ull` suffix always match `std::size_t` type? It is better to write `std::size_t(1024)` to be pedantic, or still stick to `std::integral_constant`.
my point was that all those features and some others that QVM has aren't necessarily available in one other library. That said, QVM can be used atop of GLM to provide access in to the underlying types in a specific way. In short it's not QVM or nothing, it's more QVM or QVM and your other data types etc. 
They are going to add `constexpr switch`, right? *Right?*
What's ADL?
Port [WaveFunctionCollapse](https://github.com/mxgmn/WaveFunctionCollapse) from c# to c++
Though I wouldn't say that, but the presentation was very bad...mostly because the way the presenter sounded. I couldn't make myself to watch the first 3 minutes itself. I will probably just go over the slides and the linked repo.
I generally prefer 'const auto&amp;' and 'auto&amp;' as it communicates intent. Using auto&amp;&amp; means it could be either depending on the constness of the container. For the proxy vector&lt;bool&gt; case, wouldn't auto&amp;&amp; have to deduce to a 'const proxy&amp;' to bind to the returned temporary? Seems like in that case you'd want to use auto alone to get a modifiable lvalue. 
Did you eventually find out what is the cost of this change on ARM?
[removed]
[removed]
Agreed, that was very boring. Ideally, the program committee selects for content and entertainment value, /u/GorNishanov/ (and Carruth and previously Alexandrescu in the same category) being close to #1 on both accounts. But solid technical background (e.g. Hinnant, Brown) should be key. 
He said he went really far with AAA and that practically, he'd probably use it where it makes more sense without a bunch of boilerplate refactoring going on. This was just an experiment for him to see the effects of taking AAA to the extreme.
[removed]
On slide 53, he shows the template parameter deduction from constructors, and `auto p = pair{42u, "Hello"s};` Does that mean `make_pair` is obsolete and could be deprecated, or is there any use left for it? If not, (why) should I prefer one over the others?
You would get the same result, yes. auto&amp;&amp; works like T&amp;&amp; with a deduced T in a function template, it's a forwarding reference.
auto alone works with vector&lt;bool&gt;, but so does auto&amp;&amp;. If you're writing a template and you don't know if you get a vector&lt;bool&gt; or a vector&lt;int&gt;, you use auto&amp;&amp; if you want to modify, which works in both cases. auto&amp; fails with vector&lt;bool&gt; and auto fails with vector&lt;int&gt;. With auto&amp;&amp;, by the construction of how range-for is defined, you basically get the same thing as you would get using *it in an "old-style" iterator loop. With vector&lt;bool&gt;, you get a reference&amp;&amp; (with reference as defined in http://eel.is/c++draft/vector.bool#1 ).
All of those libraries _exist_; not (yet?) being official Boost libs does not make them vaporware.
False positives suck, but it's wonderful when a tool points out that bug you never would have found otherwise. There are better ways to surface code analysis issues. We just need to explore the space first. 
&lt;sigh&gt; Yeah. I know. So I picked up a set of demographic questions from someone on my team. When I last did a survey in February I really wished I had some background information before I started calling to chat with people. I tweaked the demographic questions very slightly--just by splitting "C++" into two languages, pre- and post-11. I've heard from a few friends in this tiny niche that we work in that they're not well-represented. But hey, embrace that "other" field! It means you're special.
Someone actually has to do the work to propose something - that's how I got `make_unique()` into the Standard. In this case, writing a paper wouldn't be uniquely hard, since you're providing an exact specification. You just need to actually get a correct and efficient implementation.
nah he swaps a and b if a is larger just before
Oh look, another one.
Exactly my reaction. Thankfully, Hunter is one that has been mentioned here before.
That's not relevant. Suppose they're `int64_t` and `a` is negative (e.g. -5) and `b` is hugely positive (e.g. 2^63 - 1). Then `b - a` exceeds the range of the signed type.
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
It can't be an issue. Only bugfixes are supposed to be done through issues (occasionally, extremely minor features get in that way). Changing the definition of uniform_int_distribution is a runtime-breaking change, which vendors may or may not be happy about. It would be better to specify a different class template, and allow implementers to alias it if they want.
That's a surprising stance to take. Aside from #includeing and using it to make code work across different versions/platforms, it's still needed to simulate reflection and to write certain kinds of debugging tools.
Hopefully there will be a decent chunk for NYC this time! And embedded too!
&gt; The library is really specialized IMHO, so for most C++ users it might not directly accessible for what they'd be able to use it. It's a foundational library like say &lt;atomic&gt;. Most C++ users ought to neither be aware of it nor use it directly same as &lt;atomic&gt; as higher level abstractions like &lt;mutex&gt; are more appropriate. I know Bjarne's interested in AFIO v2 precisely because of its zero overhead abstraction and (if it's any good and fit for purpose) potentially helping C++ remain relevant as SSDs push past 20Gb/sec sustained i/o which will require replacing iostreams (as I mention in my talk). I expect to start building out that high level zero copy i/o and race free extension of the Filesystem TS (as I also mentioned in my talk) in 2018 once the Ranges TS becomes available on all major compilers and STL 2 firms up as it's a critical dependency for what I have in mind.
ah yeah good point
[removed]
You may not be aware I have worked extensively for nearly fifteen years now with those you deem to have "solid technical background", just not publicly. In fact every one of the people you mentioned apart from Alexandrescu whom I only met for the first time last year. I have been giving beginner tutorial level talks recently because the conference chairs really want a lot more of those rather than the constant "philosophy of programming" talks everyone likes to give, especially at CppCon. I'll be changing things up in 2017, if my plans pan out the ACCU 2017 talk should have some symbolic execution in it showing how Outcome + SMT solver = KernelTest. It depends on Fujitsu granting me permission, so we'll wait and see.
Well, I watched your talk, gives me an idea what it is. But not how to use it or what for. It seems good for filesystem access. Do you offer watchers? So I could watch for changes of a file? What are the use cases you have?
wtf. Why is this needed? Seems so random.
&gt; It seems good for filesystem access. It's a very thin wrapper around the OS facilities. So thin it's unmeasurable. AFIO v2, apart from its algorithm template library, is as thin a portable API abstraction as I can manage. Essentially 90% of the filesystem code you write using AFIO v2 ought to be fairly portable so you need not #ifdef around say VirtualAlloc() vs mmap(). As quirks are passed through unfiltered, you will need to do some #ifdef-ing in any real world use case as platform quirks demand alternate code paths. &gt; Do you offer watchers? So I could watch for changes of a file? No, and neither did AFIO v1 for that matter. It's *very* hard to write a race free, correct, portable file system watcher. Much harder than it looks. I don't discount implementing one eventually, but it's a long way away. And even then, chances are I'll only implement watching a single file entry only. Anything more than that gets really hard to implement. &gt; What are the use cases you have? First use case will be writing a very simple ACID transactional key value store. You could already write that with AFIO v2 as it is right now in just a few days, but the problem is you couldn't prove empirically it's reliable given the current test facilities. And if it's not proven to be reliable, I don't think it has a compelling value proposition. My second use case will be a transactional filing system layer extending the Filesystem TS. Idea is programmers can configure domain specific filesystems with various properties like strong durability or transactions or audit trails. You can then place data you actually care about in those, and place data you don't care about in the main filing system. The hope is to make available a better fitting and much more performant alternative to SQLite for when you want to care about persisting data. But in terms of general use cases, let me give an example from a recent consulting gig I had where a client wanted to render multiple live 4K uncompressed video streams at a high frame rate with undetectable to the eye latency. That's a big ask, even from today's storage, and you have to be uber careful in how and exactly when you talk to the filing system to avoid stutter. That sort of client - and you'd be surprised how many of them there are - currently must code up separate bespoke implementations per OS. Something like AFIO v2 would let them write most of their code once. Big win in that quite niche but very rapidly growing market of very high quality Augmented Reality. I expect to continue to do very well financially from consulting in that field in years to come.
This is used for operator overloading to work correctly (because it is impossible to explicitly specify namespace for an infix operator call) namespace MyNamespace { class MyVector; MyVector operator+(MyVector, MyVector); } MyNamespace::MyVector a, b, c; a = b + c; // without ADL, how would the compiler know to look into MyNemaspace for 'operator+' ? Also, it is used to create so called 'customization points' of which swap is an example. There is a default swap implementation in the std namespace. But what if I can implement swap more efficiently for my class? I write my own implementation in MyNeamespace. How would the user know to use MyNamespace::swap instead of std::swap, especially in the generic code? template&lt;typename T&gt; void MyGenericFunc(T &amp;x, T &amp;y) { // I want to swap x and y. // How do I write it to allow call to optimized version as well as generic version in std? swap(x, y); // Without ADL this would only look in the current namespace and fail std::swap(x, y) // Without ADL this would call std::swap only and not MyNamespace::swap using std::swap; swap(x, y) // Without ADL, this will find std::swap since we imported it into current scope, // but not the optimized one }
My understanding was that the client was live modifying these multiple 4K streams and displaying them to humans in some sort of AR setup who must not get disorientated from lag or stutter. To be honest I didn't ask for much detail nor was much detail supplied, it wasn't important to the problem I was being asked to consult upon which was how to get the data off the storage with a low worst case latency and leave enough CPU free for some processing and sending it to the GPUs.
If you were reading serial data straight, what is there to do other than keep a buffer?
An uncompressed 4K video stream is many Gb/sec of i/o. If you're playing a prerecorded video you can afford a nice large RAM buffer to smooth out i/o jitter. If you're doing live modifications to part prerecorded part live video for an AR use case you need to keep that latency much lower. In the client's case I think they had a buffer of just 2 or 3 frames. It wasn't straightforward, if it were they wouldn't have hired me and paid me a lot of money after their own engineers had run into a brick wall. Anyway, I helped them tune their i/o strategy by repacking their intermediate file storage into a less space efficient but easier to read format, doing scatter gather 4Kb aligned i/o friendly to their particular SSD models without buffering etc and they departed happy customers.
Agreed.
Is there an expectation that modules will reduce link times as well? I would hope that a module that exports only a handful of symbols would be easier to link against than a legacy library that effectively exports everything.
Ah, don't know enough about xamarin. Even better then.
As has been mentioned, Android doesn't "require" Java. Plenty of mobile apps are written in C++. Many (if not most) games for any platform are written in C++, as well as compilers, server apps, desktop apps, etc etc. just about the only thing that's regularly NOT written in C++ are web apps. But I don't do web development so who knows, maybe that's changed these days (probably not). 
I'll be presenting a proposal to fix this in Issaquah.
&gt; many alternatives The only thing that I comes to mind are macros with proper quasiquotation, you can't go higher than that.
name checks out
Are you open to candidates able to work in the US willing to relocate to NYC? What level of experience are you looking for (new grad/mid level/senior)?
Know a guy who works here. He seems really happy with his job.
I confirmed with the speaker that this was not intentional; must be some type of editting error.
**Company**: Blizzard Entertainment **Type**: Fulltime **Description**: Blizzard Entertainment is seeking an enthusiastic programmer to join the classic games team. They will empower the team with new and powerful tools by working on build systems, asset pipelines, deployment apps, and developer workflows. The ideal candidate will be self-driven and a strong problem solver with a passion for learning new systems and improving old ones. **Location**: Irvine, CA - USA **Remote**: No **Visa Sponsorship**: Yes **Technologies**: Mac/Windows/Linux, C++14 and beyond + C# **Contact**: http://us.blizzard.com/en-us/company/careers/posting.html?id=16000SN
With Emscripten you can do C++ web dev without deep knowledge of javascript.
Using your analogy, some people eat by microwaving two-minute meals from the supermarket; others eat by crafting their own meals from fresh ingredients. I would say most C++ programmers belong in the second category. It takes more effort, but you greater control over the final flavour and experience.
We talked about this internally a few days ago. The discussion didn't reach a firm conclusion, but the general feeling was that it would be difficult to discuss individual videos without individual threads. We also talked about possibly using link flairs for this. I suggested having some sort of summary thread. Community input would be great. **UPDATE:** [See this thread](https://www.reddit.com/r/cpp/comments/55load/cppcon_2016_videos_megathread_now_with_flair/)
My new idea: use separate subreddits for individual threads for each CppCon and C++Now video and keep a single stickied thread here. Keynotes and panels should probably be excluded. I snapped up /r/cppnow for this. Someone already has /r/cppcon, but I reached out to them.
On a similar note, can there be a stickied thread that lists all of the CppCon threads?
Your post has been automatically removed because it appears to be help/homework related. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. If you think this detection is wrong, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Homework%20False%20Positive&amp;message=Please%20review%20my%20thread%20at%20https://www.reddit.com/r/cpp/comments/55hmoi/help_with_classstruct_and_multiple_data_types/) and we'll review it. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thanks!
Well the conference is called CppNow.
Oh that's good to know :)
Considering that the overall amount of activity on this subreddit is nowhere close to that of many other, far larger subreddits and the fact that CPPcon is not a conference that's running in perpetuity year-round - I'd make the case that simply posting threads as-is is entirely tolerable. Perhaps the CPPcon stuff could be tagged to assist with filtering for those who are (un)interested.
Just a compilation thread of all the cppcon video threads would be a great addition. Coming from Dota subreddit, when there is a tournament going on, they will have a mega discussion thread of the day's matches, and it contains links to all individual match discussion threads.
Was in the talk, its a good overview on what to do with TMP.
JUCE is maintained and documented, and has already been recommended above. Abstraction is not somehow anti-C++... WTF?
I think a separate subreddit is not necessary and could dampen discussion. Flair or tags could be helpful if we really need a way to manage the influx
I'd rather have a thread for each video for the reason that reddit is good at a thread-level for showing new content. Anything new in comments in a specific thread isn't going to pop up in my main page.
C++ is hard to learn because you need to understand what thing you are writing actually mean and how they work.
Wrong thread? 
This is a top-level comment for **meta** discussion about this post and how CppCon videos are shared on /r/cpp. Please reply here if you have questions or concerns about this post or other CppCon video posts in this subreddit.
Author here - feel free to ask any questions! It it still very early in development, but I think it is presentable enough to get some feedback.
I'm gonna axe this thread; I don't think we need two threads for two part talks.
[Part 2 is here](https://www.youtube.com/watch?v=-rIixnNJM4k)
or maybe even a single post every day that summarizes it
http://cppnow.org/
Yah, sorry, my post may have not made that clear. The conferences are run by different non-profits, but the head organizers are the same.
there have been a number of C++ framework to do website. or think about CGI, you use it in any language.
**Company:** Optiver **Type:** Full time **Description:** At Optiver, a proprietary trading firm, we need the most advanced technology and continuous innovation to remain successful as a global market maker. We build high-performance software that is used by our own traders to trade a variety of financial instruments on exchanges. Our story begins in 1986, with a single trader on the floor of Amsterdam's options exchange. Today, we are at the forefront of trading and technology, employing around 950 Optiverians of 40 nationalities across offices on four continents. ****Jobs @ Optiver**** * [Graduate Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9281/Graduate-Software-Developer?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Graduate%20Software%20Developer%20Reddit&amp;utm_content=Textlink&amp;utm_campaign=Graduate%20Software%20Developer%20Reddit%20Posting#.VzC82IRcRBc) * [Software Developer](http://www.optiver.com/amsterdam/careers/job-vacancies/details/9101/Software-Developer?utm_source=Reddit&amp;utm_medium=Posting&amp;utm_term=Software%20Developer&amp;utm_content=textlink&amp;utm_campaign=Software%20Developer%20Reddit%20Posting#.VzC7-YRcRBc) **Location:** Amsterdam, Netherlands **Visa Sponsorship:** Yes **Remote:** No **Technologies:** C++14 on Linux, next to that C#, Python and Lua and FPGAs also form part of our technology stack. **Contact:** Please e-mail Jan Bernhart at recruitment@optiver.com for any questions. For more information about our jobs and events, click [here](http://www.optiver.com/amsterdam/careers/jobs-and-events?utm_source=Reddit&amp;utm_medium=Jobposting&amp;utm_term=Job%20overview&amp;utm_content=Textlink&amp;utm_campaign=Job%20overview%20Reddit%20posting).
I totally understand why, so it's not a critic per say... but... Module and namespace levels feel like overlapping features ( even though they are not ). You have a function that is simultaneously in the calendar.date module and in the chrono namespace. This increase complexity and cognitive load. Modules should be be small enough that namespaces become unnecessary and redundant. But you still need a way to avoid conflicts across modules so the import statement should be scoped, or you need a syntax to address a symbol from a particular module. ( equivalent to auto x = A::B ) 
You are right. But I guess is not much different from what we have now with includes? For instance you want to include vector you do #include &lt;vector&gt; and then you call it with the namespace std::vector. ~~In other languages although seems that they are the same, for instance in C# you just include the namespaces as they work as modules. This simplifies it.~~ edit: (seems it doesn't work like that in C# as silveryRain answer below)
How is work-life balance in game industry nowadays? Do you still have "crunch" times?
&gt; for instance in C# you just include the namespaces as they work as modules. This simplifies it. Not true. You also have to refer to the containing .NET assemblies. The default project templates do this automatically for a select few assemblies, but it must be done either way. The assemblies [EDIT: act kinda like modules in this regard] (not to be confused with F# modules, which compile to static classes [EDIT: or the netmodules that /u/dodheim elaborates on below]).
&gt; The assemblies are .NET's "modules" (not to be confused with F# modules, which compile to static classes). .NET has actual modules, too, formally called 'netmodules' and with the file extension `.netmodule`. They contain type metadata and IL but no assembly manifest &amp;ndash; basically static libs for .NET. (Not trying to detract from your overall point, which is quite correct; just worth noting that the term 'module' actually already has formal meaning in the overarching .NET ecosystem.)
TIL
For the record, I don't think your broader point was necessarily wrong (and I suppose some dynamic languages might actually do it like that at runtime using dlopen/LoadLibrary/whatever).
You need a gcc 6.x. My example output is generated by 7.0, but I have tested it on 6.2, too.
C++ is a language that does not force the programmer to do things in a certain way. With that comes additional complexity, but also the power to solve *you're* problems that way *you* want because the language doesn't presume to know what the best solution is for you. Other languages make different choices to make things simpler, but that optimization often makes edge cases hard or impossible. I can easily imagine a scenario where a large code bases requires modules to split along different boundaries than namespace in order to deliver to outsources, or implement a build time optimization etc. 
Of course. I'd be curious to know how many are done in C++, though. I'd imagine the numbers are pretty small.
&gt; i want to know if i can program in C++ and still do the C way of programming Yes, but it wouldn't be idiomatic (unless you time-travel back to the 90s) and other devs who have to read your code will quite possibly hate you for it. ;-] &gt; i have to learn C++ because i need the OOP OOP is not C++'s strong suit, and to put it bluntly, this is a rather terrible reason to pursue the language.
but glm is in cpp.
glm doesn't have much to do with OpenGL it's just a math library which uses the same naming convention as GLSL, plenty of math libraries written in plain C.
You do not need to use glm in order to use OpenGL. But glm shows another important c++ feature: user defined types. 
I'm really happy to see ISPC being an inspiration for dealing with SIMD. So far it seems to me to be the most reasonable approach. I question 'varying' being the default instead of 'uniform' and I think foreach only takes 32 bit ints for its range for some reason, but by and large it seems head and shoulders above the library based approaches. If it had destructors and simple move semantics it might be the type of language that game developers would love to use by default, (like the niche forgotten language Clay) but that starts to quickly skew the target purpose of the language. 
Fair point. I'll take them out when I get into the office.
What is the definition of "small enough"? Should the standard library (the part of it in the std namespace) be considered "small enough"? Should Qt be considered "small enough"? A desired feature of modules is that we have a well-defined boundary of components, so a module is closed. Namespaces are, by definition, unbounded. As the design shows, these two notions are orthogonal. That some programming languages make the choice of lumping them together isn't necessarily the 'right' choice to make for every programming language. The choice we've made for C++ is actually simpler -- every thing you know today about name lookup continues to apply, and you have no new name lookup rule to learn in practice.
[here](https://www.google.com/search?q=GLM) you go.
I'd be happy to review, and benchmark code you have. ARM performs very differently depending on the implementation, so a win on one CPU won't necessarily be a win on another.
Has a winner between the VC++ and Clang approaches been decided yet?
checkout the [getting started](https://isocpp.org/get-started) page of isocpp.org Also checkout [this](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) stack overflow thread for books
There are plenty of languages which handle OOP as well as, or better than C++ does. C++'s strong-suit are very deep zero/minimal overhead abstractions.
It's about time. Java had database access almost from get go ( 20 years ago?). I hope there is sufficient interest to carry Erik's effort to fruition. It also appears the guy is developing the same interface for D. Similar [presentation](https://www.youtube.com/watch?v=mhmonq2zDCQ)
I understand the design decision in the context of existing C++ code. However, it would be reasonable to expect that a name be unique in a module ( It is my understanding that a module is maybe generated from a handful if compilation units, and that is it not designed to be a complete library. - Is that a wrong assumption ?). So, if you can uniquely identify symbol s in module M1 from symbol s in module M2, and you can explicitly select one symbol or the other through a language facility, you can have a module semantic that obey the same lookup up rules as namespaces. The only remaining difference would be that modules are bounded and that namespaces are not. Not a huge sacrifice to make for a reduced complexity. The dot syntax also permit to organize the modules in bigger entities, reducing the need for unbounded sets. Though, as others said, there are already two things to remember per symbol : the header to include + namespace. So the current proposal does not indeed add more overhead. But there is a way that could be reduced in the long term. And it probably can be done later. If two modules are imported in the same translation unit such that the one definition rule is broken, a syntax could let the user explicitly choose from which module the conflicting symbol should be taken from. One other way to look at it: Despite the facilities offered by namespaces, the one definition rule is somewhat fragile and I think modules could help with that. 
no, i was asking for the alternative C libraries to glm, but thanks anyway..i guess.
Wow, great talk! I'm a novice when it comes to hardware and assembly language so this might be a silly question, but I've been googling around and I found that the NES and the C64 are both written in the same 6502 assembly (more or less). So, would his x86-to-6502 tool be able to reassemble x86 code to run on the NES as well? I'm asking as someone who's never done this sort of programming before and thought it might be an interesting learning experience. Any thoughts? Paging /u/lefticus.
&gt; Or can the reddit markdown used for the table be changed so that users could choose themselves how to order the table? [RES](https://redditenhancementsuite.com/) does this. However it'll sort the dates alphabetically, so it won't really work properly in the `W, D M` format.
Yes, should be possible. It's on my longterm to-do list, but if someone beats me to it, that's cool too :)
I have some numbers for a Zynq 7020 (Dual ARM Cortex-A9, ARMv7-a)... Last weak ref released, 74ns -&gt; 29ns (~61% faster) (edited, was ~45%) Not last weak ref released, 62ns -&gt; 64ns (~4% slower) Note that you only get the slow path if there's a weak_ptr involved somehow.
Thanks! So, likely a win in total.
 int* i = nullptr; auto nn = NonNull&lt;int*&gt;::make_non_null(std::move(i)); //EXCEPTION! Why would you not make make_non_null(nullptr_t) = delete; ?
**Company**: SoundHound [Careers Page](http://soundhound.com/careers) **Type**: Full time, Internship **Description**: For C++, a variety of server side roles. This includes data processing, neural networks, distributed systems, working on a compiler, natural language processing, machine learning, search algorithms, speech recognition, text to speech, digital signal processing, and more. Looking for both junior and senior positions. *That includes new grads.* **Location**: Santa Clara, San Francisco, Toronto **Remote**: No **Visa Sponsorship**: Depends, PM for details **Technologies**: Different teams vary based on needs, but includes GCC, Clang, Boost. C++98 and C++11. Development is mostly on beefy Linux servers, but some embedded hardware too. Should know way around a command line. A number of non-C++ languages used as well (best language for the job, includes Java, Go, Python, Node). **Contact**: Formally apply on the careers or PM me
The example was straight from OPs code, more to ask why there is only a runtime check when a compile time check is basically free. But yes, in this case you will still get a runtime error.
 **Company:** [Cruise Automation](https://jobs.lever.co/cruise?lever-via=YdDVhEpFej) | San Francisco, CA | ONSITE **Type:** Full-Time Onsite **Description:** Cruise is building the future of autonomous vehicles. We believe in improving people‚Äôs lives by making transportation safer, more accessible, and more convenient. Our team is small and we move quickly. We‚Äôre currently testing a fully driverless solution on city streets. We're looking for smart, ambitious people to help build the world‚Äôs largest fleet of driverless cars. We are solving some of the hardest problems in the world right now and building some of the coolest technology you have ever seen. We are looking to fill a number of [C++ roles](https://jobs.lever.co/cruise?lever-via=YdDVhEpFej), if any of them seem interesting to you please feel free to email me directly **Location:** Our office is located in SOMA(SF) and is full of cars and robots and the brilliant people building them. **Contact:** Asimile@getcruise.com **Remote:** Not currently available **Visa Sponsorship:** Taken on a case by case basis, if we can get a visa, we do. 
Bjarne mentioned it very briefly in his [keynote at 1:00:47](https://youtu.be/_wzc7a3McOs?t=1h47s), kinda in the context of things he was disappointed didn't make it into C++17 and he's hoping will get more attention before and make it into C++20.
`operator.` probably wasn't the one you're looking for. Extension methods would be handled by one of the "unified function call" proposals by Bjarne or Herb, e.g. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4165.pdf Bjarne did briefly mention the idea at CppCon during a talk, annoyed that the committee didn't accept it for C++17. :) It's mostly blocked by someone proving that it doesn't break any real-world existing code, iirc. (e.g. that the lookup rules don't result in new ambiguities or anything, even in the face of fancy template SFINAE tricks). The lambda stuff is an entirely different topic. Short version: your lambda proposal is impossible without breaking C++ and making a new incompatible language (how does the compiler know what `it` is, what it's type and qualifiers are, etc. if `filter` takes an arbitrary functor type, etc.)
&gt; how does the compiler know what `it` is, what its type and qualifiers are, etc. the same way it knows when you pass a polymorphic lambda
There is nowhere in the C++ language where a type-specifier is optional, even if it's `auto`. Indeed, this is precisely why STL's `for(x : range)` shorthand for `for(auto&amp;&amp; x : range)` proposal was rejected. This is an arbitrary expression inside of braces &amp;ndash; `{ it &gt; 0 }` looks like list-initialization of any type constructible from `bool` (or whatever type `it &gt; 0` happens to yield). It seems to me that this would be a complete nightmare for the grammar.
Is there a static initialization in new modules? If I use module something run before and after using this module.
You have a smart dog.
A few suggestions: * Instead of calling `base::data.begin()`, consider using `using std::begin; begin(base::data);`. The `using std::begin` is for argument dependent lookup, and `std::begin` will work with for a superset of containers that `data.begin` will work for. * In `Unique&lt;T&gt;` (and `UniqueAndSorted&lt;T&gt;`), you use this in `make_data_unique`: auto it = std::unique(base::data.begin(), base::data.end()); base::data.resize(std::distance(base::data.begin(), it)); The standard idiom in C++ (called erase-remove) would suggest you do this: base::data.erase(base::data.begin(), std::unique(base::data.begin(), base::data.end()); though you are right, not every container will support this * In the constructor for `UniqueAndSorted`, you do this: std::sort(base::data.begin(), base::data.end()); make_data_unique(); but if you did it in the opposite order, you might have a much shorter container to iterate over for `std::sort` * Isn't `NonNull&lt;T&gt;` pretty similar to `reference_wrapper&lt;T&gt;`? `reference_wrapper` is a non-local variable that can be rebound and is never null. Instead of an error when a null value is passed, it is undefined behavior (or maybe a segfault), since you'd have to dereference a null pointer to set it to a null value. I can see a use case when using a shared pointer, however, since it combines reference counting with non-null. Still, since `reference_wrapper` decays into `T&amp;`, it will play more nicely with compiler optimizations. * In `NonEmpty`, I'd suggest replacing `in.empty()` with `using std::empty; empty(in);`, for the same reasons as above * You don't enforce the class guarantees when using the `class(T&amp;&amp;` constructors, only for `make_xxx(T&amp;&amp;)`. I can see that you are trying to avoid throwing in a constructor, but I think that's preferable to breaking the guaranty of each class. * Finally, in your examples, you do `int* p; auto q = std::move(p);`. That's not wrong, but for an object with automatic storage duration (such as `p`), you will have the same behavior (a copy) with `auto q = p`. Anyway, this is an interesting project. Hopefully this doesn't seem too nitpicky, I thought it might be helpful. Nice work!
On the classic games team we have a very good work life balance. Crunch times are normally not a thing at blizzard and we try and avoid them as it tends to burn out engineers.
&gt;Stanturd FTFY.
Technically not optional since you can't actually put a type, but `[x=5]() {...}`
This new edition of the podcast
Grabiel: modules, apart from allowing better semantic tools, faster compilations and all other goodies you comment in the presentation, would allow an easier code sharing? Currently C++ lacks a standard package manager or some mechanism to make easy to integrate external libraries in a project, which in some cases can be a very hard work. Even some libraries go straight for header only approach, in part for this issue. Do you think modules are going to help to improve this situation in some way? Thanks
This is off-topic for our sub-reddit. /r/cpp_questions or StackOverflow can help you out.
can you guide me on this, so i cant use 1 syntax instead of 2. tell me the difference. i am following this video https://app.pluralsight.com/player?course=learn-programming-cplusplus&amp;author=kate-gregory&amp;name=learn-programming-cplusplus-m5-classes&amp;clip=5
thanks for guiding me out, i will ask there :)
actually i have initialized it back in the class, so we are good than, right
&gt; I would love to have a way to override my methods with a compile-check to avoid using virtual function. You mean static polymorphism? You can already do that in C++ with the [curiously recurring template pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern).
I'm not sure about the binary output of this static polymorphism but I was thinking about something without template. Just simple method overriding method (no crazy syntax). To be fair I'm using Swift for iOS apps and this is where I got this habit, which is pretty nice and simple in my opinion. 
Well my classes aren't using template so far, I don't feel like adding this just to be able to override a method. Feels kinda overkill.
&gt; The standard idiom in C++ (called erase-remove) would suggest you do this: &gt; `base::data.erase(base::data.begin(), std::unique(base::data.begin(), base::data.end()));` That would not do the same as you are removing the unique objects that were selected by `std::unique`. This line should be: `base::data.erase(std::unique(base::data.begin(), base::data.end()), base::data.end());`
this is also an oop safety mechanism. somethings should not be overridden, and enforcing this can lead to better code(tm). think like const for code
First a standard DB access api so everyone can use it even if they don't want to use objects and structs to check for data. Then you can have a standard ORM library built upon it.
Same as Netanyahu's nickname.
No, it's there: https://www.youtube.com/watch?v=_wzc7a3McOs&amp;feature=youtu.be&amp;t=38m17s
Well, I guess it is not too late to propose your approach for standardization. Not with that licence though otherwise no one will touch it. 
There's always `void *` if you're a sadist.
Touch√©!
It's simple: in general it can't. Global analysis can help, but it will never be as powerful as an explicit final declaration. It can optimize by deducing static types, but it won't devirtualize usages when pointers are involved, and there's no other hint of the actual type. The reason is simple: consider the simple case above, but add to the simple example an additional mechanism, a plugin system capable of loading dynamic libraries. If you build an executable today with a compiler which does the devirtualization automatically, that compiler will decide that no subclass exists, and so will devirtualize the calls to value(). Tomorrow you write a new plugin which provides the executable with instances of a new class C, derived from B and overriding the function value(). The calls to value() were devirtualized, so C::value() won't get called. That's why current compilers, even if they can deduce a lot of information, can't really devirtualize and optimize those calls.
C++ Modules, as designed, aren't for package delivery. However, I fully expect the notion of 'header only' library to just evaporate with modules -- you can just deliver one source file containing the module definition and export only the thingies you wanted to export. You get full encapsulation. Furthermore, my favorite C++ package manager will be not only module-aware, but manipulate modules as central concepts :-)
Umm, I fail to see a scenario where this would occur, as this particular attribute changes which function actually gets called. Since an extension function is a free function, it won't incur any polymorphic effects. As for static analysis, a free function is a free function, so I honestly don't see what the problem is - we analyse the function as if it wasn't there, minding any possible inlining.
Solved guys :)
Glad to hear that, thanks again!
It looks very interesting. I have 2 questions: - Is it possible to provide a predicate for sorting templates? - If I add a new element to that vector it gets sorted automatically?
&gt; Inline seems to go straight out of the window, the compiler can/will ignore it. That's incorrect, I am afraid. `inline` is about telling the compiler that the definition of the function may occur in multiple translation units and it should therefore apply some magic to avoid the "multiple definitions" error at link-time. `inline` is implicit on most template functions and on class methods defined within the class definition, but must be applied manually when defining, inside a header: - a non-template function - a fully specialized template function - a non-template class method, outside the class definition It *can* be applied to any function or method, and is ignored (semantically) if it was already the default. --- Now, it seems that compilers doubled-down on this, originally, and used the presence of `inline` to decide whether to inline the function/method or not. With the development, of smarter heuristics, however, they mostly stopped doing so and now prefer their heuristics to reinterpreting semantic markers. And instead they added *attributes*, which have no semantic of their own, to control inlining behavior. I much prefer this latter situation. SRP and all that.
&gt; you don't fight abstractions imposed by the standard DB API ODBC **is** the standard db API though, it is a common denominator, too. By your logic, you should be using the db vendor's C library.
Pipe syntax feels so natural, love it!
It might be possible to chain them, I already started working on it. But this has some issues : - Unique&lt;Sorted&lt;T&gt;&gt; != Sorted&lt;Unique&lt;T&gt;&gt; which is rather bad, since now the it won't typecheck. If I offer an explicit version of the combination, this problem doesn't exist. - auto ohBoy = Unique&lt;Sorted&lt;NonNull&lt;std::vector&lt;int&gt;&gt;&gt;&gt;((Unique&lt;Sorted&lt;NonNull&lt;std::vector&lt;int&gt;&gt;&gt;&gt;Sorted&lt;NonNull&lt;std::vector&lt;int&gt;&gt;( make_non_null({1,2,3})))
I think there was a misunderstanding, sorry if I was not clear. You choose to split the std in several modules. You imported `std.io`, `std.string` rather than just `std`. So despite the size of the standard library, it is still composed and small modules whose size are closer to that of a compilation unit than that of a big library. ( And it's totally make sense from a performance point of view. ). I was always under they impression that individual modules were mean to be of small size. Btw, I'm eager to see what the best practices will be regarding splinting a code base in modules and choosing modules boundaries an scope. So my point was that even if there are symbols with the same name in a library, it would be reasonable to expect that this scenario shouldn't occur in the confines of a module. And in that context the second model of ownership make more sense And to be clear, I was never advocating for namespace to be removed or to put symbols in namespace based on module, that would be a breaking change &amp; a nasty hack. I just wish that, independently of any namespaces that may exist, there was a way to consider that symbols are owned by module and that there was a language facility to resolve any conflict that may occur between modules. Here is a stupid proposal to hopefully better illustrate my point //Module A export class Foo {}; //Module B export class Foo {}; //current.cpp import A; import B; { Foo f; // obviously fails to compile } //proposal.cpp import A; import B; { using MyFoo = A@Foo; MyFoo f; // uses Foo from the module A ( do not consider Foo from the module B and compile properly) } Other solutions could take inspiration from the `import SYMBOL from MODULE as NAME`syntax that exists in language such as python. In both case it may be useful that import declaration could be put insides scopes { import A; Foo f; } { import B; Foo f; } This is a problem/proposal independent from namespaces but it would offer a way to not use namespace in new code and still have a mean to organize code and deal with conflicting symbols. The mean to resolve a conflict could be added later, but it requires what you called the 'strong model of ownership' (and probably that the module name be part of the abi) Does that makes more sense to you ? Is there a summary or an explication of why the weakest model was chosen ?
I've develed a little bit in OpenGL contexts. Is it worth pursuing anymore, OpenGL seems impenetrable from my perspective.
Metashell has to be the one of the most underappreciated projects in the C++ world. 
While final itself doesn't seem like a bad idea (hopefully will prevent crazies from deriving from std::vector), this specific optimization seems fairly pointless. Anyone has a non-contrived example where this is useful? (and even then, it just saves explicit specification of function at call site). I mean, its kinda cool compilers do this, but 'power' is a bit much for this.
I can only push forward open sourcing abandonware ! Really nice idea :D
**Company:** [Christie Digital](http://christiedigital.com) **Type:** Full-time **Description:** We make digital projectors based on DLP technology. But the real interesting stuff is projection mapping - taking a bunch of projectors and stitching them together to make a single canvas, and projecting onto screens, buildings, 3D models... [almost anything](https://www.youtube.com/playlist?list=PL7CBEC9E4CFDB1FD9). Basically, [we paint with light.](https://www.christiedigital.com/en-us/projection-mapping) We are looking for experienced C++ devs that like pixels and math, machine vision, machine learning,... But really, the most important thing is just _good coders_. Coders that can make abstractions and write clean code. I assume you can figure out the rest once you get here. **Location:** Kitchener-Waterloo, Ontario, [Canada](http://www.usnews.com/news/best-countries/quality-of-life-rankings) **Remote:** Unlikely. **Visa Sponsorship:** Unlikely. **Technologies:** We are currently mostly using C++11 under Windows. As we now have a member of the C++ committee on the team (that you get to work closely with! - even less exciting than it sounds!) we are pushing forward towards the latest standard. We also like Boost (of course). And OpenGL and other 3D technologies and open source libraries. And I have to admit (sorry) - knowing Javascript wouldn't hurt either. Seems to always be a web angle somewhere. **Contact:** check out our [job postings](https://www.christiedigital.com/en-us/about-christie/careers/canadian-careers) and [apply online](https://apply.hrmdirect.com/resumedirect/ApplyOnline/Apply.aspx?req_id=435003&amp;source=435003-CJB-0). For imaginary bonus points, figure out the email address I use on the boost lists, and email me at that address. Or some other email address of mine, besides my all-too-obvious gmail one.
I were not at CppCon, but I think materials from those classes are the property of the teachers. At NDC Oslo in June this year, I attended Concurrent Thinking by Anthony Williams, and that material is his material. If he would release it, it would be at the discretion of Anthony.
Maybe one big master thread with links to all the videos, and encourage users to post separate threads for any talk that they think is interesting enough to have it's own thread. Any talk that somebody actually finds interesting enough to discuss will have a thread, and all the links will be available. Win win?
[We won won!](https://www.reddit.com/r/cpp/comments/55load/cppcon_2016_videos_megathread_now_with_flair/)
Yeah, but we only wanted an even number of wins!
First of all, I think you meant `{return f.x;}`though that's really beside the point. I think if you wanted to argue that `Foo::stuff()` would clash with `[[extension]] void stuff(Foo f)`, that's a non-argument since C# got this sorted ages ago: the class wins over the extension, every time. &gt; Ignoring an attribute shouldn't change whether something compiles I'm not sure where this idea came from. In C#, ignoring an attribute emphatically *does* affect compilation: for example, having a `[Conditional("DEBUG")]` attribute means the definition is only included if `DEBUG` is defined, and compilation can fail it it's not. (This is not good design, but a fact nonetheless.) I think, if you're not happy with attributes, a specific keyword will do. For example ``` extension int x(Foo f) { return f.x; } ``` where `extension` is just a keyword I made up (similar to e.g., `inline`). The point is, it doesn't really matter *how* this is done. I'm ok with any syntax-compliant extension that gives me extension functions without any significant effort and doesn't try to make the D-style assumption that `x.foo(y)` is somehow everywhere equivalent to `foo(x,y)`. The principal model is already proven to work (C#) with a single keyword `this`, as in ``` public static void something(this string s) { ... } ``` So there's no reason why a similar construct would work in C++, and I don't see how this can cause any problem with existing code. Same goes for lambda notation of the `foo.filter{it.bar&gt;0}`: I don't see how this would actually clash with anything. And yes, both these changes would cause changes in the construction of the compiler, which I think we can all live with.
Getting a thread for each video = win, because we can watch all the videos. (But there are a lot of un-necessary threads.) Getting a master thread and letting people post their own discussion threads = win win, because we get to watch all the videos and extra chatter is kept to what people actually want to talk about. Master thread plus individual threads for every single video = win win win, because it's the previous win win, plus the extra single win. (But again there are a lot of un-necessary threads.) Clearly, a two won solution is optimal, and the two odd won solutions are suboptimal. I'm not sure what a win win win win would be in this case, but it's probably fine.
Yes, my point is entirely about using an attribute for this instead of something like a keyword. Attributes do step out of bounds in C# and Java, but that doesn't mean they have to in C++. Ultimately, it doesn't change the idea, just how to express it.
/permissive- is being implemented from scratch to be robust and well-tested. /Za's behavior isn't being changed because that would affect existing builds. Currently, /permissive- and /Za enforce largely non-overlapping rules, but we eventually expect /permissive- to outright supersede /Za.
Disclaimer: I didn't watched the video neither I looked at the thread yet! But MISRA C++ exists as well! Let's not compare apples and oranges. For the rest... I mostly see pay for what you use stuff (except maybe exceptions). Good domain specific coding guidelines enforced by validation tools would give all the safety needed with much more language tools than plain C. A comment on RAII, I don't see how it is a broken concept!
OGL 3 is hardly modern at this point
&gt; As far as I know, today we have no way to specify in B.h that macros defined in A.h shall not be visible in C.h. Adding this ability, in my opinion, is big enough change to require separate justification. If we can't pick which macros are visible now (when we are using headers) why we need to have such an ability when we use modules? Part of the motivation for modules is to add this ability to be isolated from macros. You can find the justifications for this elsewhere. The thing that Richard's talk is trying to justify is why we would want macros to be visible sometimes anyway. &gt; As a separate note, is the ability to export macros from module necessitate changes to preprocessor (to make it aware of modules mechanism)? If so, will it break existing projects (code and other preprocessed assets)? It does require a change in the preprocessor. In Clang's implementation of modules the statements that cause a module to be imported are handled both in the preprocessing phase and in later phases. Of course for clang's implementation a change was necessary regardless of exported macros because the preprocessor had to be taught to not textually include anything for `#include` directives that refer to a module mapped header. There should be no breakage of existing code due to the preprocessor changes. These changes have no effect unless modules are enabled, and when building code with modules enabled all the export of macros means is that the same pre-modules interface can continue to be exposed. Breakage due to enabling modules can occur but has nothing in particular to do with the processor; E.g. changes to modularize code can break other code that depended on non-modular behavior.
I've tried to program in "modern" OpenGL. My conclusion is that no matter what you do, someone is going to tell you that you're doing it wrong. I went back to (or rather remained at) writing scientific visualizations in OpenGL 2.x/3.0 and haven't looked back.
This is off-topic for our sub; /r/cpp_questions or StackOverflow would be better.
I guessed you weren't agreeing with most of those statements since you probably wouldn't have post it on /r/cpp otherwise ;-) I agree there is a great deal of misunderstanding between the C and C++ communities, mixed with crossed misunderstanding regarding the application domain or platforms. I would love to see C communities to understand that more language features doesn't mean a mess. In many cases C++ with a controlled subset of its libs and feature can be much safer that even a safer subset of C. And it would be much more productive! Anyway, that's how I see it ;-) Edit: I would also like to see C++ community understand how heap allocs, code size bloat, exceptions and other performance/memory features heavy are trouble for embedded development.
You're right, good point
&gt; "You don't enforce the class guarantees when using the class(T&amp;&amp; constructors, only for make_xxx(T&amp;&amp;). I can see that you are trying to avoid throwing in a constructor, but I think that's preferable to breaking the guaranty of each class." &gt; Could you elaborate? I missed that the constructor for `NonNull&lt;T&gt;` was private, so that point doesn't apply
Agree it's a ridiculous statement, but I would still point out that really nice [thread and article](https://m.reddit.com/r/programming/comments/55ueci/summarizing_garbage_collection/) that shades the boundaries between GC and ref counted memory management. Quite nice!
Hi Steve. You mentioned during one of your builds that you were creating help files. Is that generally available? Still using SHFB myself.
From the top off my head: - not very trained people in programming, to not make a mess, use C because it is simpler. - C++ not available in some embedded system, maybe. If you have properly trained people, there is absolutely *no reason* to use C over C++ in my opinion. Why? Because the ecosystem is mature and it allows you to code solutions with equal, or even better performance (std::sort was a typical example vs qsort before, I do not know nowadays about optimizers), and more strongly typed (will fail at compile-time, not at run-time). Of course, understanding more things takes more time, but, it is an investment, since your solutions will look simpler. At the end you could end up doing a mess in C (lots of function pointers vs virtual functions in interfaces, object-oriented C, vs C++ out-of-the-box support, copy non-pods by accident or having to code much of these copy functions by hand...) that in C++ are simpler things.
I've done a lot of development in C, C++, python, Java, etc. My overall take on those points is that in my experience, C++, when you control for the same size codebase &amp; team &amp; not looking at any particular niche of software development, lets you write easier-to-read (&amp; consequently maintain) code while eliminating or drastically cutting the probability of very serious classes of errors, reducing cost to generate the software (i.e. quicker to develop feature-set, quicker to fix bugs, the consequences of bugs is less severe, etc). It's also the same reasons I would use to recommend Java for some projects &amp; Python for others. Pick the language whose strengths play well with the problem-space you are developing (&amp; frequently mix so that you can pick up the slack when the strengths are only well-suited to a sub-set). At this point however, I'd say C++ has fairly convincingly (to me anyway) taken over most of what was previously C territory (except perhaps some embedded environments &amp; even then I might still go with a restricted subset of C++ rather than suffer through C). Does that mean always C++ vs C? For me, 99% of the time yes. Does this mean C++ for everything? Definitely not. Continued...
You can still use qsort in C++ if you need to. Compatibility for the win! Another question that arises is if an explicit specialization could do some code hoisting and avoid generating code.
I agree and disagree... when you know that your memory usage is already thight, you wont even want to use std::sort... I'll give a real case scenario I had some years ago. We were running some code on the SPUs of the PS3 (which had mainly 256KB for both code and data). At one point we had to sort some stuff in that job. qsort was already used in some code we were uploading to the SPU, using std::sort in just one place would have bust the memory usage. Using it twice would have bust twice! What I mean is that in really tight memory constraints, it's not about "premature optimization is the root of all evil", it's about what you can do or not.
We use C++ on our desktop apps, and C in our embedded devices. Arguments for sticking with C on our embedded devices are: * We have a lot of legacy embedded C code that works, and C has worked great for us. There is tooling, libraries, examples vendor documentation. Why change? * Most other people are using C on embedded, so most libraries, examples, and help documentation are in C. C++ may be suitable, but why blaze the trail and be the first/early adopter? * Compiler support and tooling. C compilers are robust and problem free. Are all the C++ toolchains going to support all the sublties of C++11/14/17 and the STL, and be bug free for all the embedded platforms? This is a big probably not. Please, prove me wrong here. * Training and ability to hire people. Web people know JS/CSS/HTML. Most embedded people know C. * Determinism about performance. I know, I know, I know, ok, I'm a C++ programmer. I know that C++ *can* be as fast or faster than C. Most embedded platforms have to be tightly controlled by interrupt handlers. There is concern about exceptions, destructors, and amortized performance and how they interact with interrupt routines at the highest level of embedded performance. This spooks our embedded devs, with good reason IMHO. By real time, I mean, you have to adjust the missile guidance control surface at sub microsecond precision or all the astronauts die kinda real time, not "my angry birds game doesn't stutter and looks real good" real time. Look, I'm one of you. I'm a C++ programmer, but I don't want to get into a long winded, pedantic and subtle internet debate with staunch C++-for-embedded people refuting each one of my claims - I'm just trying to pass on the discussions I hear. But, please go ahead, and post them, I'd be interested in reading. But almost nothing you can say is going to get me to go into work tomorrow, wave the C++ flag, and really push hard with the business case that we need to stop everything and switch to C++-on-embedded. If I can get on a high-horse here for a minute. I just want to say that in general, the C++ community seems to be incredibly naive and lack any appreciation for the unrealistic level of skill and dedication it takes to both problem-domain experts *and* C++ experts. The comments in this thread imply that our embedded people aren't *skilled*. So in addition to being experts or knowledgeable in RF, analog electronics, digital electronics, signal processing, electronics noise, circuit board layout and tracing, fabrication, materials science, mechanical engineering to name a few, we're now expecting them to read /r/cpp and and stay on top of all the nuances of C++ 14/17 and what the latest news is on const_expr if in lambda functions and how they interact with variadic templates so they can use the nightly build of clang on their embedded devices? Maybe some of you work on teams where you have people or teams dedicated to each area of these areas, while throwing a few PMs to manage them all. But I work in the real world with real budgets. On my team I'd take a great electronics/embedded/digital guy who can program passable C over a C++ expert with passable electronics any day of the week. 
I'd still do it. For me, it would be better to see that something is failing and then optimize that part to make it fit than try to make it fit in the first go. In my opinion, it's more like "make use of abstractions until you can't anymore. Only then remove them." sort of thing. That way, you benefit of the abstractions while developing, which can help you focus on the problem itself. When the abstractions start getting too heavy, replace them with the optimized structure. The good thing about that if that if it works with the more memory-expensive abstraction, it will work later with the optimized one. Oh, this is assuming you are constantly running tests, by the way. 
Somebody came up with a contrived example where a uniqiue_ptr took one extra instruction over a raw pointer. So *of course* smart pointers are horribly slow and broken.
These are all completely reasonable arguments for not using C++. Hopefully many of them will change over time. More support from vendors is the biggest thing that would help C++ for embedded systems (where C still dominates). I think it's much more likely that embedded vendors will support C++ than say another language like Rust, but the absolute easiest thing for them to do is keep supporting C.
You know, not all development is done from the ground up. You may need to deal with multi-year code base. You may need to deal with supporting many features already there. You may be already short on all the features of your platform (memory or disk or cpu time). You would still try it maybe, but when you have let's say 120.75kB of code + 135kB of data and your max is 256kB... calling std::sort would bust the available memory. You just don't even need to run it to know it won't work, just look at the binary size! Again I don't say std::sort is bad as it is, I still use it when it's needed. But there are cases (embedded context mostly) where I won't use it because it wouldn't even work. In other embedded context, it might worth to call std::sort so the performance is more important than memory consomption, but it all depends.
&gt; Python, Go, &amp; Javascript are far better choices Disagree. Actually, I don't know much about Go, so I can't speak to that one. I'd argue that teaching a statically typed language is better for beginners than teaching a dynamically typed one any day. Static typing means that a whole class of errors can be caught at compile-time - or when you're writing code, if you use a decent IDE. Type errors are much more apparent as well. From looking at the code, you can know that your function returns a House but you're trying to assign it to a variable of type Dog - that's not going to work, especially when you try to pass that Dog into a function that takes a Fish. With a dynamically typed language you don't get any of that - you'll only know that you have a type error then you actually run that code. This means beginners won't get feedback as quickly as they could, which can definitely be a big pain. You could reply that I'm stuck into a type-centric way of thinking, that working without types is just as valid of a way of thinking and is in fact easier for beginners. I disagree. Additionally, I don't think Javascript's type coercion is in any way a good thing. Perhaps the teacher won't talk about it, perhaps the teacher will actively discourage it, but sooner or later a beginner will make a mistake and it'll come into play, especially with the lack of explicit types. Language features that make experienced programmers scratch their heads aren't something I want to show to beginners. What would I teach to beginners? Something statically typed, something with a strong standard library. Something without NULLs would be nice as well. Given the fact that many standard libraries provide an Optional or Maybe type I almost never have a use for NULL. I'd suggest Haskell, or a similar functional language. Static typing? check. No uninitialized variable, lurking in the shadows until they can crash your program? check. Simple syntax that's familiar to something students already know (math itself)? check. Kotlin also looks very promising, although I haven't gotten a good chance to dive into it in depth. It's statically typed with relatively simple syntax. it runs on the JVM, letting you use the vast wealth of Java libraries that are already out there. It also has no NULLs by default - you can have a type that can be NULL, but you have to explicitly say that you want that. Other than that, idk. All languages have their quirks, but some have safer quirks.
Thank you for the acknowledgement. My guess is that JavaScript (or similar) will see a prominent rise in Embedded before C++ does (or if ever): the low level core will remain in C because of momentum and tooling, but the IoT and low price/ease of integration with inexpensive touch enabled LCDs will necessitate emulating the responsiveness and look/feel of smart phone interfaces and so hardware providers/SDKs and developers will look to copy/emulate the direction that mobile/web interfaces are going. Just my prediction. Again, not that C++ *couldn't* do any of these. But the perfect storm of existing code, industry momentum, etc, tough business case. i.e. "Our smart devices has a node.js/css/html interface that millions of budding developers can use" versus, "our embedded platform SDK is nearly C++17 conformant" ...
Devirtualization does save you an indirection to the vtable, but IIRC the more important aspect is that by devirtualizing a function call (especially in a tight loop) you can enable other optimizations that could cause a huge speedup, I've heard cases of a 10x improvement.
Yes that does make sense. Guys like Dan Saks and Anthony Williams have classes they teach outside of the conferences, perhaps the stuff they taught at CppCon was derived (subset) of their "professional" classes. That said, the professionalism and quality of the presentations were exceptional.
This is off-topic for our subreddit; StackOverflow or perhaps /r/programming would be a better fit. That said, a CS degree is not a degree in software **engineering**. A CS degree is not as important as technical expertise and experience in this industry.
We do not ask for these materials; I don't think instructors are able to provide it for free, for most of them this is how they make a living.
Industrial C developer here, we produce a machine vision library that is used in factory and machine automation, with &gt; 3 M LOC and around 30 developers working on it full time. The library is written completely in C, with some critical parts in assembler (though that has gotten rarer with the new Intel compiler versions). We evaluated if we should and could start using C++ features recently, but decided against it. The main issue was that one of our embedded targets does not have a proper C++ compiler (yes, in 2016). This was a blocker. Secondary issues were doubts that people would use C++ "correctly". There was a strong sentiment from some of the lead developers, who have done C for 20+ years, that there are potential "hidden costs" in C++ that can accidentally be triggered, such as copying large data structures with a single assignment, lots of code duplication with templates etc. Personally, I was strongly for moving towards C++. While C does give you a lot of control with few things hidden behind abstractions, overloads and the like, it is also significantly slower to write and more expensive to maintain. Many of our bugs, such as uninitialized memory, memory leaks, double frees etc., could be eliminated completely by using the correct C++ features.
I dont see how exceptions are non-deterministic. On the scale of determinism, it is likely more deterministic than thread scheduler or garbage collector.
I like Go (and use it for the job) but it constantly violates DRY principle. Don't get me wrong - the language is very nice to work with. But it's niche is quite limited. 
Literally. Truly saves me a lot of time doing a lot of trial and error and I don't even use any other feature except SCALAR for checking. I basically use it while learning about sfinae, c++ make_index, trying out variadic templates etc. Can you tell me a bit more about your usecase? 
Yes, the question is, why you have an object of known dynamic type with virtual function call in tight loop (unlikely), and why haven't you just used the function statically then? int test(B* b) { return b-&gt;B::value() + 11; } It's a little less safe (so 'final' is a good thing), but optimization - i don't find very exciting. &gt;I've heard cases of a 10x improvement Im interested in situations where such cases arise _and_ are not caused by broken design.
Is it possible to try out coroutines in Clang? There is the "-fcoroutines-ts" option. But when I try to compile, it says: "error: you need to include &lt;coroutine&gt; before defining a coroutine" Where do I get the coroutine header?
&gt; They have a higher chance of increasing the set of supported targets using a well tested / popular architecture rather than having their own back-end. That has been disproved by Go compiler actually. &gt; And gcc is probably not suitable because of licensing issue and architecture. MIT and Apache are compatible with GPL. Also - language itself can be implemented based on specification. But that's not the point - there are TONS of C compilers. Texas Instruments for example. One of the key thing about C is that it's more like high level assembly.
No. I have dabbled in ORMs and they universally suck. First, C++ in this current state is a poor language to build an orm on top of. You need some sort of reflexivity or dynamic code generation to make an ORM somewhat elegant. The schema duplication issue is also a hard-one to solve. Then there is the blackbox issue. It's not evident what the stack is doing behind the scene. Mostly regarding caching, large queries, etc. And then you start to introduce join into the mix and all hell breaks loose.
 // the possible types std::string string; int integer; bool boolean; double double_float; std::vector&lt;JsonValue&gt; array; std::map&lt;std::string, JsonValue&gt; object; Isn't it possible to use a union, or std::variant or something like that? 
[deleted] ^^^^^^^^^^^^^^^^0.6762 &gt; [What is this?](https://pastebin.com/64GuVi2F/64889)
You may want to implement operator&gt;&gt; for streams. Would be the same as json.parse("file.json") but you also may use the file to work on then.
Oh man, I remember using Allegro with DJGPP. That was the shit.
Even bester than this? https://github.com/nlohmann/json/blob/develop/README.md
The easy ones: - `typedef enum` instead of `enum class`? - no member initializer lists in constructors? - no const correctness? BestJson? I think there is room for improvement.
&gt; std::sort was a typical example vs qsort before, I do not know nowadays about optimizers std::sort still wins, AFAIK.
tl;dr - reasoning about state is easy; - solving problems by adding keywords. HA HA HA OH WOW
What you describe is a typical experience of a Hibernate/EF user. We designed ODB very differently: no magic, mostly one-ORM-operation-to-one-DB-operation mapping. Virtually every week we get requests for magic features such as transparent caching, dirty flushing, etc and we push back every time.
I will take SQLite C API over ODBC any day.
Naming is important to reduce learning time. Clear/longer names are easier to remember than one-letter abbreviation. build2 and b have the issue of being ambiguous in the context of a unix environment with hundreds of existing commands. I hope I didn't come up as harsh or anything, it wasn't my intention :)
Probably the most amazing JSON library for C++.
&gt; Definitely more code! If that‚Äôs a problem, you can type erase the arguments you pass to `std::sort` to avoid instantiating several versions, which is essentially what `qsort` does all the time. So `std::sort` can definitely handle all situations that `qsort` can handle just as efficiently and sometimes more efficiently, *and you can choose the trade-off yourself*.
You only pass unique_ptr if you want to move it. In any other case you can just pass pointer or reference to the object stored in it.
This is indeed one of the valid reasons for C though I‚Äôd add that I would implement the library in C++ and expose a C interface. A notable example of this is the Rcpp package which makes C++ code directly callable from the R programming language, by automatically creating the necessary C wrappers.
True of course. The question is whether even the case of wanting to move a `std::unique_ptr` instance justifies passing it to a function. Personally I think so but some people disagree.
I've added several images to the front of the project page for you. There is also a folder titled 'Screens' within the project if you'd like to check out more (as well as some sample code that actually generated the images). Most effects were achieved by simply changing one or two lines of code, which I think is really cool.
Did someone found the slides ? I really want to read it as as summary. 
What is this "keep it under 500 lines" bullshit?
Choose: - break existing code - don't break existing code, but more fragile ADL - not universal (ie `f.(x)` when you want "universal") So it didn't get approved. But many people want _something_ if only they could agree what that something was, besides unicorns. We all want unicorns. It may come back, but I'm not sure in what form. EDIT: alternative summary: - nice syntax - simple lookup rules - break no existing code pick any two.
The paper claims it doesn't break exisiting code. Can you give an example?
All presentations will be available.
[removed]
The future that /u/GorNishanov described in the second part is actually a *deferred* future (like the future returned by `async(std::launch::deferred)`). It does have the advantage that you don't need synchronization, but it's also useless if what you want is an *async* future, which is unfortunately the most popular scenario. 
There was a thread on here that discussed its pitfalls in great length, but I can't seem to find it. :( **Edit:** Found it [here](https://www.reddit.com/r/cpp/comments/46s6g0/unified_function_call_syntax_a_case_for_xf/).
 struct X {}; auto f(X x) -&gt; int; template &lt;class T&gt; auto foo(T x, int) -&gt; std::conditional_t&lt;true, int, decltype(x.f())&gt; { return 0; } auto foo(X, char) -&gt; int { return 1; } auto v = foo(X{}, 0); Today, the value of `v` is 1. With UFC, the value is 0.
I don't see how modules adds any kind of ABI support. In fact, IIRC, it was explicitly one of the things they're not considering adding with it (along with smarter decoupling of private members from cascading recompilation as I mentioned). The only thing modules is targeting is improved compilation times on medium-big software projects.
I don't have any experience with Go. It just seemed like a better teaching language for beginners, but your right - it's probably a better teaching language for network &amp; threading related concepts rather than general purpose. That being said, if I had to pick Go vs C++ to teach a beginner, I would probably pick Go (even though I don't know it at all &amp; am fairly proficient in C++).
I honestly don't believe UFCS is all that useful. From my perspective, all it does is obfuscates what's actually being called for sugar. And yes, I've played around in languages that feature it, such as rust and nim. I just don't find it particularly compelling. And I'm willing to admit part of that may be me being a crotchety old man, but I honestly do believe it's not all that useful in a practical sense (I understand the template argument though).
Exceptions are expensive. In C, the happy path and error-case path both tend to be about the same in expense. In C++ where exceptions are used for error handling, you gain performance on the happy path due exceptions not costing anything*, but handling errors can be very expensive. So exceptions generate non-determinism in expected timing -- not non-determinism in destruction. Of course if this is an issue, don't use features in C++ that can throw. However this eliminates a large portion of the standard library and is the same as D experts saying to C++ developers "you can program in D without using the garbage collector". Possible, but difficult. &amp;nbsp; \* The "0-exception overhead" doesn't really take into account the tables that must be generated. The additional tables do increase binary size and can have a non-zero overhead. It's often still better *on average* than using error codes, but it sometimes isn't zero despite the claims.
Is this kind of SFINAE that looks for member/free-standing functions the only code that would break with UFCS? Are there any non-SFINAE related cases?
&gt; But that's not the point - there are TONS of C compilers. Texas Instruments for example. But even for C, I'd rather use gcc. It is much more likely to optimize things well. You would think chip developers would want to use gcc too since they could focus on only part of a compiler instead of a full compiler and a standard library. Oh well!
&gt; Finally, we note that modules are a "front end" notion with no effect on traditional ABIs ("application binary interfaces"). Moving to a module-based library implementation therefore does not require breaking binary compatibility http://www.open-std.org/JTC1/SC22/wg21/docs/papers/2012/n3347.pdf Nope. Modules are (smartly) decoupled from ABI as the ABI problem is a completely separate issue. In fact, the generated module files are an implementation detail &amp; there's nothing in the standard guaranteeing or encouraging compiler writers to support sharing of those files or even supporting them between versions of a compiler. So updating the toolchain means you'll need to blow away the module cache (or hopefully the compiler is smart enough to know to ignore old versions).
I don't believe so. The proposal also says that &gt; Apart from SFINAE tricks, this should be a pure extension that gives meaning to previously ill-formed programs.
Succinctness trumps utility. aka "C style code".
You can see how your library does against other JSON libraries if you submit it to https://github.com/miloyip/nativejson-benchmark 
The nlohmann library is truly amazing, agreed
A definite me too. ODBC is crap and very often has a lot of hidden caveats in the various implementations. I keep going for things that use the database API instead at least the vendor's tools will be somewhat written using them (+ hidden APIs) and so they often work well even if they can be very cryptic.
&gt;&gt; context switch is quite expensive It is indeed true of fibers (aka stackful coroutines or userland threads). But, it not applicable to the C++ / LLVM coroutines. For example, for a fiber on amd64 (Windows), suspend looks like this: [boost fcontext jump asm](https://github.com/mirror/boost/blob/master/libs/context/src/asm/jump_x86_64_ms_pe_masm.asm). Which is a lot! For a C++ coroutine, suspend look like: ret void The purpose of this talk was to explain in details how C++ coroutines work. It seems I did not do a good enough job :)
Sure. In the clang test folder for coroutines there is an Inputs/coroutine.h and Inputs/generator.h that you can use to play with coroutines. You can see more examples in this test folder: [clang/test/CodeGenCoroutines](https://github.com/GorNishanov/clang/tree/coro-post-cppcon-master/test/CodeGenCoroutines) For best results, use coro-post-cppcon-master branch for LLVM and Clang from https://github.com/GorNishanov . Use -fcoroutines-ts and -fno-exceptions for the clang command line. (Changes are being upstreamed at the moment, so soon you should be able to just use the trunk of LLVM/Clang.)
Ironic. 
For the most part, whenever someone says "doesn't break existing code", we really mean "normal" code, not including SFINAE tricks. (Unless they talk about sfinae specifically, of course.) This will only get worse if/when reflection shows up. It may be that eventually any language change is a breaking change...
except we don't get paid to be on the committee.
The change would have made the VS system_clock::time_point layout-compatible with their FILETIME structure, making system_clock::time_point more easily integrate with FILETIME associated OS calls. As a partial solution to that problem Billy O'Neal graciously wrote some FILETIME/system_clock conversion functions and posted them here: https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes#FILETIME
Fair enough, and we all thank you all for your efforts. You're still part of the group responsible for keeping C++ useful to everyone, so a breadth of concerns is very important for you to have. 
Absolutely, the code with compile on anything that SDL2 can, whether that be command line compilers (gcc/g++) or an IDE like Visual Studio or Codeblocks. No windowing system is necessary to manipulate images, you can even output any generated graphs as their own local image files if you'd like (as well as the altered images themselves). It is also very cross platform and can compile to Windows, Mac, Linux, Android, iOS, and I'm fairly sure Raspberry Pi. The previous versions of SDL were able to compile to basically anything (including even the Sega Dreamcast apparently), and it wouldn't be difficult to port this code to those older versions because surface functionality worked in essentially the same way.
Excellent, and good luck! I signed up as well :-)
 template &lt;class U1, class U2&gt; constexpr pair (U1 &amp;&amp; u1, U2 &amp;&amp; u2, typename std::enable_if &lt; std::is_convertible &lt;U1, T1&gt;::value &amp;&amp; std::is_convertible &lt;U2, T2&gt;::value &gt;::type * = nullptr); Adding a third argument to the constructor probably isn't the way you really want to do SFINAE. I think you want something more like this: template &lt;class U1, class U2, class = typename std::enable_if&lt;...&gt;::type&gt; constexpr pair (U1 &amp;&amp; u1, U2 &amp;&amp; u2); 
What is this thing? I see a lot of these types of websites but they never seem to lead to anything tangible that could help someone get a job.
This guy's fake enthusiasm almost killed me. Like a cheap preacher from the US. Also giving a talk about somebody's else great work and smart tricks looks weird no matter how much you are kissing his ass. 3/5.
edit: fixed That's a good point, not sure why I wrote it that way. It "works", technically speaking but I'll fix it as soon as I get a chance.
Can anyone explain the following behavior to me? #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; class GpsSpeed { public: static int gps(int s, std::vector&lt;double&gt; &amp;x) { // s = distance per "s" seconds if (x.size() &lt;= 1) return 0; std::vector&lt;double&gt; sections; sections.resize(x.size() - 1); for (int i = 0; i &lt; sections.size(); ++i) { sections[i] = (x[i+1] - x[i]); } for (auto&amp;&amp; sct : sections) { sct = sct * (3600.0/s); } auto maxHourlySpeed = std::max_element(sections.begin(), sections.end()); std::cout &lt;&lt; std::setprecision(9) &lt;&lt; *maxHourlySpeed &lt;&lt; std::endl; // outputs "72" return std::floor(*maxHourlySpeed); // returns "71" }; }; When called with `std::vector&lt;double&gt; x = {0.0, 0.02, 0.36, 0.54, 0.72, 0.9, 1.08, 1.26, 1.44, 1.62, 1.8};` and `s = 17`, at sections[1], will contain the value "72", yet `floor`of that returns 71? I compared with the other solutions but I can't figure out this weird behavior.
I recall this was formally proposed and the proposed syntax IIRC is void bar(SomeType *this, MaybeOtherArgs arg); someType.bar(arg); I don't remember why it didn't make it any further. 
Howard really likes the word "proleptic". Seriously, though - this was a really good talk, and an awesome library.
&gt; This is a problem/proposal independent from namespaces but it would offer a way to not use namespace in new code and still have a mean to organize code and deal with conflicting symbols. You want to avoid using the existing feature to solve the problem you mention and instead introduce a new way to do the same thing, a way which is tied to another orthogonal concept. What's the value in avoiding namespaces? What's the value in tying together orthogonal concepts? How would all the existing complicated name lookup rules, e.g. ADL, work with the new feature? The code you show already works with namespaces: `using MyFoo = A@Foo;` would just be `using MyFoo = A::Foo;`. I don't see any benefit from your suggestion. &gt; Is there a summary or an explication of why the weakest model was chosen ? The weakest ownership model wasn't chosen. The P0273r0 discusses the options and recommends the one that was chosen. If you're interested in these features I'd recommend reading at least N4456 and P0273
Slide 29: why `decay_t&lt;&gt;` before `tuple_size_v&lt;&gt;` (or at all, actually)?
Because `tuple_size` doesn't accept references. As I mentioned, `tuple_size_v&lt;const tuple&lt;int, int, int&gt;&gt;` is 3, but `tuple_size_v&lt;tuple&lt;int, int, int&gt;&amp;&gt;` is bogus.
Increase your precision to 20+ to see what `*maxHourlySpeed` is really storing.
Can you elaborate what were the reasons from changing the epoch? Was it just that you would break ABI compatibility or something more fundamental about why epoch should be 1970?
Only C++14. No access to compiler options. Drop down list of C++ language version only lists "14". Nothing to indicate that third-party libraries are present. Documentation is non-existant. Has VIM/Emacs editor support, but no other utilities like clangformat. ~~I pretty much bailed as soon as I realized there was no boost support.~~ From `boost/version.hpp`, `BOOST_VERSION` is defined to be `1.54`. It's not toggleable anywhere (include-and-go). `__clang_version__` is defined to be `3.6.0 (tags/RELEASE_360/final)`, so definitely no RangeV3 support. -isystem /runner/frameworks/cpp fatal error: &amp;#39;range/v3/core.hpp&amp;#39; file not found #include &amp;lt;range/v3/core.hpp&amp;gt; ^ 1 error generated. From [github](https://github.com/Codewars/codewars-runner-cli/blob/master/lib/runners/cpp.js), we can find the default compiler flags. function compile(args, cb) { args.unshift('clang++-3.6', '-stdlib=libc++ -std=c++1y'); exec(args.join(' '), cb); }
constants are fine. do it like this static const char * const cMyMessage = "Hello";
That isn't a constant. It's a modifiable pointer to const char. And you shouldn't do this in a header (you get a separate copy per "translation unit" that includes the header). Beginner questions are off-topic for this subreddit, as the sidebar advises. 
Tried to use boost's `string_view` for one of the solutions and it didn't exist, suppose I should have checked version.hpp before assuming. Dug around for other info though.
Is there a place I can read more about all of the proposals for this, their pros and their cons? It would be nice to know about all the different proposed syntax for this.
Just fyi to everyone, I'm working on a proposal to cement the 1970 system_clock epoch into a future C++ standard. This was both motivated by this aborted VS change, and encouraged by the VS team as a result of this experience.
&gt; I see a lot of these types of websites but they never seem to lead to anything tangible that could help someone get a job. Are you genuinely interested in this? I have been working on a personal project that I want to turn into something similar to what you describe: being able to show skills to get a job through unofficial (as of now) certification. In your opinion, how would a site like that would look like? I have already a few things, focused on learning: core C++ (modern and non-modern, since non-modern is an industry requirement also, IMHO), Modern C++/STL, probably there will be more. They were multiple choice tests basically. Do you think coding live would also be a good addition? I was pursuing, as a first step, some kind of non-official certification, given that me and other two people have extensive experience in C++. 
Do you think there should be `std::ctie()` producing a tuple of `const` references?
Oh look, an insightful, on-topic comment without the often seen attacks on the presenter, how refreshing!
 using first_type = T1; using second_type = T2; Why do you need this? T1 and T2 are not any less expressive than "first and second types". ~pair (void) noexcept = default; Should probably be ~pair (void) noexcept(std::is_nothrow_destructible&lt;T1&gt;::value &amp;&amp; std::is_nothrow_destructible&lt;T2&gt;::value) = default; 
Yeah, I was just ending up with &amp;quot;'s everywhere :(
Thanks for pointing out the `noexcept` qualifier (habit of mine, in all the other code I write there's never a reason not to mark destructors as `noexcept`). It's actually redundant and could conflict with the calculated qualifier because it is defaulted. The change is up on the post and in the repository. To answer your question: `first_type` and `second_type` are part of the public interface for `pair` ([cppreference](http://en.cppreference.com/w/cpp/utility/pair)).
&gt; I thought it was implied that it would be an implicit first argument Unfortunately, nothing is "implied" to a compiler. They work off of painstakingly precise rules. The C++ grammar specifically is not friendly to the concept of introducing identifiers without an explicit declaration. There's a reason why types come before identifiers, why new function declarations require the `auto` keyword, why `typename` has to be sprinkled around templates, and so on. While many other languages aim to have grammars that are _context-free_ and can happy deduce the meaning of an identifier from its surrounding tokens and grammatical constructions, C++ (for historical purposes) is not one of those languages.
It's probably time the standard has something like: std::are_nothrow_destructible&lt;typename T, typename ...Ts&gt; 
If you're referring to extension methods, note that C++ is a different language than C# and the ease of doing anything in C# is irrelevant in the context of C++. C# does not have SFINAE or the full flexibility of C++ templates. C# does not have argument-dependent lookup. C# doesn't have to think about textual-inclusion header files. C# does not do a lot of things that C++ does and hence has a larger space for language extension. It's clearly not impossible or Bjarne and Herb and others wouldn't have worked on it in the first place; it's very clearly not a cut-and-dry easy thing to work in, though. If you mean the terse lambda functions, note that we already have a specifically marked function with minimal grammar: the C++11 lambda syntax. You're not going to get much more concise than that without introducing ambiguities, which is one of the more important reasons why that grammar was chosen in the first place. ES6-style new functions are just not possible in C++ without restructuring how the entire language's grammar is formalized (and then getting compiler vendors to accept speculative parsing requirements).
&gt; What's the value in avoiding namespaces? What's the value in tying together orthogonal concepts ? Namespaces offer weaker guarantees than modules could. It's not hard to imagine symbol collision in two separate projects that, for example, decided not to use namespaces. Namespaces work if all parties agrees, modules could enforce a stronger guarantee ( the symbol would be tied to a larger entity, rather than a name-based, open, logical grouping). Furthermore, I do not agree that modules and symbol ownership should be considered as orthogonal concepts and I don't see the point of having a symbol being part of two distinct groupings. &gt; How would all the existing complicated name lookup rules, e.g. ADL, work with the new feature? Good point. But that a question that is certainly workable. The rules that worked for namespace could be adapted to work for modules. &gt; The code you show already works with namespaces: using MyFoo = A@Foo; would just be using MyFoo = A::Foo;. I don't see any benefit from your suggestion. Indeed, it's the same thing, except you eliminate one of the two grouping facilities. There is no value in modules vs namespace at the call site ( beside a stronger guarantee that you are using the correct, unique symbol), but it simplify the declaration and you only have to remember one location information for the symbol. &gt; If you're interested in these features I'd recommend reading at least N4456 and P0273 Thanks, I've read P0273, interesting read. They mention the ownership &amp; namespaces issues, then brush them off. Some interesting titbits &gt; We believe that is the right choice for C++, but in order for it to function, the exported interface of a module must still follow the namespace discipline. So many libraries don't &gt; In a modules system with full ownership semantics, we expect that libraries ¬≠¬≠ especially those written by inexperienced users of C++ modules ¬≠¬≠ will frequently abandon namespace discipline because the two ¬≠level linkage semantics prevents most problems It's already happening :( &gt; However, the language provides no way to resolve the inevitable name conflicts: there is no way to explicitly qualify a name with a module name... But there could be ... or partially import a module‚Äôs interface, for instance I can see partial imports be able to lead to better compilation times, would I been wrong to assume that ? &gt; More generally, we think that C++ should have only one large¬≠scale namespacing mechanism (beyond the scope of an individual source file or module), and that namespaces should continue to be that mechanism I tend to agree that a single solution is better in a perfect world. But in such perfect world, I'd argue that this solution should be module ownership. However, namespaces being there and widely used, they cannot and should not be removed. But I don't see why not offering an alternative/better tool for newer codebase. 
Really great talk, Where can I read about MSVC's implementation of string? 
"why the hell is there no error" The code contains no syntactic error. Welcome to C++; you have enormous power here, and with great power comes great responsibility. C++ has been designed with the principle that you shouldn't pay for what you don't want to use; if you want bounds checking, then it is up to you to use something that provides bounds checking - for example, vector::at(). If you don't want bounds checking, use a naked array as you have done. Choose the right tool for the job; you have chosen to use a naked array, so you have chosen to have no bounds checking. 
And you would call that a runtime check?
Could you explain how Mana differenciates itself from other C++ frameworks like [Silicon](http://siliconframework.org/) or [Crow](https://github.com/ipkn/crow) ?
std::array::operator[] does no bounds check
but it has checked std::array::at()
Function templates didn't use to support default template arguments, so you had to put it into parameters like that. But that's fixed these days.
And usually on uses at() in Java?
It's probably 71.9999999999999999999 but the question is why, and why does it work if you do the whole calculation at once, i.e. `sections[i] = (x[i+1] - x[i]) * (3600.0/s)`? Isn't that a big flaw? I would think that my algorithm is correct but yet it doesn't pass the tests. Would you consider this a bug, or a correct solution?
&gt; To answer your question: first_type and second_type are part of the public interface for pair So why does one then not simply use `...pair&lt;first_type, second_type&gt;` directly instead of using T1 and T2 and then having these `using` directives?
I don't think I particularly need UFCS but the choice is crystal clear: &gt; nice syntax &gt; simple lookup rules. Ugly syntax is not an option when there is a less ugly way, and C++ rules are already quite complicated, so don't complicate them any more. Some people will cry if you break their existing code but you have to look forward here. Think future, not past. Nobody will care 5 or 10 years after the breaking change went through. And there's a vast amount of compiler switches and tools that help to safely upgrade step by step, you just have to be willing to use them. Any company that doesn't, will forever be stuck in the past anyway.
Lots of Iterables in Java use .get(int index) method which is straight analogue of ::at() since Java has no operator overrides.
Qt is one of the cross platform standards of making GUIs: qt.io If you are looking for an alternative in C++11: nana is worth a look, http://nanapro.org/
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com).
Seems to me most of the tasks are nearly pure maths problems that happen to use code instead of pen&amp;paper to scribble down the solution. 
It can be made to do so, but I seem to recall that it requires an least one optimisation level ( -O ) to turn on the dataflow analysis, and some other factors as well. As an aside, with optimisation, this particular example code would be simply turned into main: mov eax, 0 ret so there's nothing to warn about. I know I have had trouble in the past getting gcc to warn me about bounds overrunning (although generally only when I've created a contrived example to try to provoke the warning; in actual code, I just use a vector).
Some people play chess quizzes, others do code katas.
When trying to sign up, I get a problem to solve: int multiply(int a, int b) { a * b; } I have to 'figure out why the above code doesn't execute properly'. So I changed it to: int multiply(int a, int b) { return a * b; } And when I try to submit it, it says: &gt; Connection Status: Assigning a server &gt; Server Execution Error &gt; Request Timeout: Process didn't exit cleanly. wat? Are they expecting me to worry about overflow while signing up?
`typename pair&lt;int, float&gt;::first_type` wouldn't work if `first_type` were the template argument instead of a typedef
Ah I see! Thx!
I think you could not mention that you're a java programmer )
[nope, it doesn't](http://coliru.stacked-crooked.com/a/a50b913b92666382)
Simply because in other context the method value() could be used by a function which just takes an A* a. That won't be devirtualized. A pre-C++11 solution would have been having two different methods in class B, one virtual and one nonvirtual, the virtual calling the nonvirtual, at the cost of creating some confusion to the users of your API. You can do that, but to be honest having a keyword doing the dirty job, and leaving your code clean, is quite handy.
https://moderncpp.com/
I'm too old for these dick waving contests.
https://groups.google.com/a/isocpp.org/d/msg/std-proposals/5fa8cMR68J4/mRh0eAHyCQAJ
Thanks for this. So, to be honest, I think then they're probably using a different compiler with different behavior, or these's even something wrong with their setup....
I remember! It's 3d buzz. 
In this case, but if the index is not known at compile-time, you're still going to blow your foot off if you're not careful. I mean, in the real world why would you try to accesss the 99th element of a 5 element array anyway.
If you don't particularly need UFCS, maybe you should choose the option I forgot to add: - none of the above That is basically what the committee chose (so far). In general, we try really hard not to break code Making code not compile is fine, but having old code compile in new ways, with different functions being called than previously, is quite dangerous. Literally dangerous considering C++'s use in real-world devices (medical, vehicles, power plants, ...)
Slides were lagging behind the video. New version was reuploaded. New link is here: https://www.youtube.com/watch?v=8C8NnE1Dg4A 
Tell us how you really feel about memory leaks.
I know why swap should be noexcept I just thought it was required for all types used in the standard library. And you can throw from destructors if you mark them `noexcept(false)` but I thought that you must not use these types in the standard library, so you could just use unconditional noexcept.
it might be better for the ISO cpp google sight propasal. I do not trust StackOverflow I been burnt by them before.
I just looked it up: The standard does say the behavior is undefined if any destructor throws unless otherwise specified ([res.on.functions]/2.4). I couldn't find an exception (no pun intended) for pair's types so you could use an unconditional noexcept there.
&gt; the question is why You are calculating an approximation, not an exact result. Floating points try to represent infinitely many real numbers (base-10) into a finite number of bits (base-2). See [Goldberg's "What Every Computer Scientist Should Know About Floating-Point Arithmetic"](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).
Is there a big difference between the two. I have used string_ref for years and haven't looked at view yet as I often just use it to simplify the number of functions I need and use the two begin/end iterators from there on
&gt; Literally dangerous considering C++'s use in real-world devices (medical, vehicles, power plants, ...) Well, there's hopefully an up to date list if you update compiler or C++ standard with all these things that may silently change behavior. And then, if I'm the maintainer of such a high-risk codebase, I have the knowledge and appropriate tools available to check all this (unit tests and static analysis come to mind, but I'm sure there's much more one can do). I get your point but the point is as well that many of these new features bring more safety as well if they're used. I'd rather trust my life to a machine that uses C++11 smartpointers, owner&lt;T&gt;, and all that awesome stuff, than 20 year old code with raw pointers and a leak or two somewhere. In any case I definitely agree with your point on if I don't particularly need UFCS, then my answer is "none of the above"! :-)
I'll have to look at that. Thanks. 
[deleted] ^^^^^^^^^^^^^^^^0.1524 &gt; [What is this?](https://pastebin.com/64GuVi2F/58514)
No need to be this complicated. I'd use a different approach entirely: #include &lt;algorithm&gt; #include &lt;array&gt; std::array&lt;int,10&gt; arr( { 0,1,2,3,4,5,6,7,8,9 } ); std::random_shuffle( arr.begin(), arr.end() ); // your answer is the first 5 elements of arr 
This is a reuploaded video that fixed slides lagging a few seconds behind the presentation. Previous discussion thread is here: https://www.reddit.com/r/cpp/comments/55l50q/cppcon_2016_gor_nishanov_c_coroutines_under_the/ 
this is probably a stupid question, but what does well formed mean in this context? &gt; the entailed assignments must * be well formed for the types T1 and T2 btw, this has snuck into the rendered text at one point: &gt; data-preserve-html-node="true"
I explained it in the post you replied to. This will be my last response to you.
True. FYI, OP, if you're using C++14 you should use `std::shuffle` instead.
Ah, ok, thanks. Looking forward to the next part.
It's like he was a closet memory-leak hater.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). 
Static analysis-time check.
Nobody is asking for a VM (maybe except Bernstein?) Just don't fuck us more than the hardware already does, using the utterly stupid pretext that an obscur DSP we never heard of would have fucked us if we tried to run our unrelated code on it. 
I prefer "run with a decent set of compiler warnings and use static analysis".
Unless I missed it no such functionality is described in the draft TS. You can't have cyclical dependencies between modules, so it should be possible to pretty much solve C++'s static initialization order problems. I.e., before static initialization for a module or TU is performed, static initialization for its imported modules must be completed. Of course static destruction just occurs in the opposite order. Static initialization order within a module would still be indeterminant, however. If this were done then all you'd need to do to get 'module initialization' and 'deinitialization' would be to define a global variable with initialization/destruction in the module.
I notice in the modules TS that 7.1.2 requires that inline functions must be defined in the same translation unit of a module in which it's exported, meaning inline functions will have to be defined in the module interface files. This seems to me to be unnecessary. I don't see any reason that inline functions need to be defined like this any more than templates, and I don't see any similar requirements for templates. The compiled representation of a module will have been produced from all the module's translation units, so even if an inline function definition isn't in the module interface file, it will still be available in whatever the compiled representation of the module is. This will mean that with modules the ability to separate interface from implementation is even better than with headers, since you won't have to clutter up the interface file with the definitions of templates or inline functions.
Suppose you don't like the tiny code duplication in `bool op==(T const&amp; L, T const&amp; R) { return tie(L.x, L.y) == tie(R.x, R.y); }` and would like to factor it out and have a `T::tied()` member to be called as `bool op==(T const&amp; L, T const&amp; R) { return tied(L) == tied(R); }`. Then `T::tied()` exposes a tuple of modifiable references and could be abused. Of course, one could define `tied()` as a lambda inside the comparison as `bool operator==(T const&amp; L, T const&amp; R) { auto const tied = [](auto const&amp; t) { return tie(t.x, t.y); }; return tied(L) == tied(R); }`, but then there is still some code duplication between `op==` and `op&lt;`, and for some classes `tied()` might need to be a member (or friend) of the class in order to access the underlying representation. I'd like a `std::ctie()` to apply `std::as_const()` to all its arguments (or to call `std::make_tuple` with `std::cref`). 
The tied() member function would need to be const, in order to be called on L and R. There's no actual problem to solve here.
Thanks for the link, I actually just watched it this morning after I finished writing the blog post! I did elect to use the `O(N)` recursive implementations everywhere for this. I did that mainly for readability, but you're right, in production it's much better to use the `O(log N)` implementations. I'm thinking about writing a follow-up series once this series is complete about optimizing the implementation, and so that would be an obvious thing to include.
So if I understand, the only benefits you're describing are that having modules participate in naming would do two things: It would enforce a specific naming scheme on everyone and so eliminate conflicts between differently named modules, and it would mean people no longer need to write `namespace Foo{}` around their exported declarations. The latter I see as having negligible, if any benefit. The former I think is almost a pure detriment. In C++, _where_ names appear is important in a way that's not true of most other languages. Providing certain interfaces depends on where names appear. E.g. certain things need to be in the same namespace, or in associated namespaces. If you try to tie modules into this as an enforced naming mechanism then you are removing the ability to provide certain interfaces. Take for example a module that provides a template and expects other modules to provide explicit specializations for it. Either you're going to have to change template specialization or this will be impossible. This should make it clear that modules and namespaces are orthogonal, and why more than one kind of grouping is needed. For modules to best perform their task as an architectural building block they should not prevent the other kinds of groupings necessary in C++ for defining certain relationships between architectural entities. &gt; Namespaces offer weaker guarantees than modules could. It's not hard to imagine symbol collision in two separate projects that, for example, decided not to use namespaces. Namespaces work if all parties agrees, modules could enforce a stronger guarantee ( the symbol would be tied to a larger entity, rather than a name-based, open, logical grouping). With p0273 we already are getting a stronger guarantee from modules: if there's a collision in exported entities then we get an error (when both are imported into the same TU), and no collision is possible between non-exported entities. In other words, the entities are 'tied' to the the larger entity of the module. The only difference is that you're suggesting instead of an error we should have a way to refer to entities in specific modules. However you haven't addressed the name linking problem that's brought up in p0273. Solving that that impacts system ABIs and will need coordination even between systems to do things like update the Itanium ABI. &gt; ... or partially import a module‚Äôs interface, for instance I can see partial imports be able to lead to better compilation times, would I been wrong to assume that ? I can't say for sure but it doesn't seem to me that that would provide any significant savings. Importing symbols should be pretty lazy, so all unused symbols should mean is that there are more elements to search through to find the symbols you do use. &gt; I tend to agree that a single solution is better in a perfect world. But in such perfect world, I'd argue that this solution should be module ownership. However, namespaces being there and widely used, they cannot and should not be removed. But I don't see why not offering an alternative/better tool for newer codebase. I'm unconvinced that using modules as you suggest actually does offer a better tool for newer code, or that having that instead of namespaces would be the best solution in a perfect world. As one example of that, it would then be much more cumbersome to do what can be done today with a bunch of nested namespaces in a single header. 
Ask your IDE vendor to support that in their auto-completion. We don't need to alter (and in many people's opinion, confuse) the grammar of the language to support what amounts to already-possible tooling improvements. As an aside, downvoting without explaining how this doesn't contribute to the conversation is akin to admitting you can't support your own position. Downvote away.
My point was that in production, it's much better to get the compiler's effectively instantaneous implementation, instead of logarithmic recursion in a library. Then use pack expansions to do all the heavy lifting.
Right, okay that makes sense. For the post I wanted to show how one *might* implement it, sans compiler intrinsics.
I would post one link to the project there and every chapter here.
How does the compiler know to bind the values stored in `values` to `it`? For example: ``` int a=1, b=2; values.filter{a &lt; b}; values.filter{b &lt; x}; values.filter{x &lt; y}; ``` what about functions taking two other functions as arguments?
Some of your requirements seemed oddly specific but overall, that article was actually a lot better than I thought it would've been, given that click-baity kind of title. It really sounds like you're looking for a web developer though.
This would probably be better in /r/cpp_questions
Exactly no. Nothing personal, but seem's you have no idea what "rockstar cpp" developer should know.
Do you think that would be the case even if the branch were always correctly predicted because the branch only ever goes one way?
With respect, I disagree. The OP's company and even the nature of their business are not mentioned -- this is clearly not a job advert. I think "what you should know for your next C++ interview" might have been a better title, but then maybe that's why I'm not in marketing... nonetheless, I think the article will be of interest to developers browsing this sub, and IMO it's fine for it to stay where it is.
Well, the article specifically says "we are not looking for a rockstar [developer]", whatever one of those might be. But since you say "exactly no", what would your preferred list contain instead?
Do you take colour spaces into consideration? For example, do you convert sRGB into linear space before applying image processing?
Agreed, I love c++ and will probably go thru my whole life never being able to get a job programming it, but this outlined very specific flaws I have in my current knowledge of c++ in relation to what people deem 'professional/expert level c++ knowledge'. While I love to entertain the idea that I could be ready to get work in this field, this outlined some solid points for me to research as a c++ hobby programmer. I actually saved some of the list of 'things you should know' (that I kind of know but couldn't explain to someone) so I can practice my knowledge of them.
Branch predictors aren't perfect and it would still dilute the instruction cache. No solution will ever be as fast as simply ignoring the possibility of overflow as signed ints are allowed to do anyway, so the best solution is probably to just teach developers to prefer signed types any time that math will be done and they don't actually care about overflow behaviour.
Looks like a fair enough list to be honest, got a fright on the first item listing RAII where I had one of those "what the hell is that" moments. Looking it up (Resource Acquisition Is Initialisation) gave me the much more pleasant "oh, yeah, I know that" moment. The main thing you are looking for in a C++ developer is pretty low level technical knowledge of how the computer works and how the language maps to that. These seem to be the things covered in the list. I'm sure someone could be a perfectly competent C++ developer without knowing all that stuff but the obvious question then would be why use C++? What I would say is missing is some questions about source control, bug tracking, automated build processes etc. Pretty much anyone who has commercial experience will be well aware of them but it's surprising how often you will find someone with a good deal of experience who hasn't used one or more (the fully automated build process being the main culprit). Edit: Just a bit curious really, why the down-votes on this? Only thing I can imagine is the statement about a good C++ developer needing low level technical knowledge but given Stroustrups own definition, "C++ is a general-purpose programming language with a bias towards systems programming", that seems fair enough. If you're hiring an entry level programmer sure, it doesn't much matter but a senior C++ developer they absolutely need to know that stuff because when your project needs something tricky like a custom memory manager, performance optimisation or just fixing some weird bug that crops up under weird hardware configurations they'll be the ones expected to be able to fix it.
In that case you would have two copies of every function that used unsigned types in the binary which would increase the binary size dramatically and put a ton of pressure on the instruction cache. it is also a pretty hard problem to determine ahead of time if a function has the possibility of overflowing an unsigned type, meaning that the check would be way more than a conditional jump.
I am working on a C# project where I decided to change from a class name defined in an xml file as the source of what class to instantiate to using an enum that is made from a simple string. So the final solution was at least somewhat typesafe. Unfortunately, C# enums are not the same as C++'s enum class.
&gt; All the best developers have random hobby projects Incorrect.
I had a very similar UMR also in string processing. I was decoding Windows UTF-16 to UTF-32 and the code was just a little bit simpler if I always pulled the next wchar_t for handling surrogate pair case. Unit tests pass, looks good. But very infrequently there'd be a crash. Luckily I had a threading stress test for strings left over from when we were trying to make sure we had probably killed the COW bugs due to the underlying std::wstring implementation and I could get that to crash about once every 40,000 operations. Turns out if the final NIL was the last 2 bytes in a page and the next page wasn't allocated that was causing the crash. Didn't happen very often, but there you go. Moved the NIL check earlier and everything was fine.
An actually reasonable moderator? Well, that's a pleasant surprise! (and I mean it honestly, having seen some quite unsavoury and hypocritical ones of late). Kudos!
So singletons are just across the spectrum bad things now? Shouldn't it depend on what it's being used for?
(Just FYI: I'm not the original poster and have no connection whatsoever, I was just interested in an alternative argument :-) )
I can't beat the explanation of redditsoaddicting but relevant standardese is Page 963 of n4606. &gt;template &lt;class InputIterator&gt; &gt; constexpr typename iterator_traits&lt;InputIterator&gt;::difference_type &gt; &gt;distance(InputIterator first, InputIterator last); &gt; &gt;Effects: If InputIterator meets the requirements of random access iterator, returns (last - first); otherwise, returns the number of increments needed to get from first to last. &gt; &gt;Requires: If InputIterator meets the requirements of random access iterator, last shall be reachable from first or first shall be reachable from last; otherwise, last shall be reachable from first. 
But what if you actually need global state and functions working on this state? Even though this is probably overused, there are situation where this is actually needed. // Example Edit: I have an i/o interface that reads/writes and &gt;caches&lt; data which is used at different places in my application. 
Then why not just use global state and functions?
I would say in that case you should consider modeling the global state by passing immutable data through a queue or stream-type data structure. But, in any case, putting singletons in a `class` obscures the meaning of your code and prevents it from being compiled efficiently. It's an antipattern along the lines of webpages where everything's in a `div`.
&gt;Anyway, in all of your examples, the compile-time side of constexpr doesn't apply because the arguments are not constant expressions. Woops. That's a bug in my code. I didn't intend for that to be the case. &gt;Your function is wrong in two ways. First, it has no constexpr specifier. More unintended bugs. &gt;Second, parameters are never constant expressions. I'm afraid this adds to my confusion. If parameters are never constant expressions, then how would one be able to write a `std::distance` such that the *result* is a constant expression? Perhaps I have a fundamental misunderstanding of `constexpr` functions. &gt;Let's take a simpler example of a possible iterator that isn't solely based on a pointer - an iterator that stores the beginning pointer and an index. Your example definitely illustrates the point, but I was thinking specifically about `std::array` or `T[]` because `std::begin/end` are also being made `constexpr` in 17. *** constexpr bool operator==(const Index_iter&amp; other) const { return (_arr == other._arr and _i == other._i) or (_i &gt;= _size and other._i &gt;= other._size); } `_arr == other._arr` this is the crux of my question. How does the compiler test equality of these addresses when they are not determined until runtime even in a `constexpr` context. That is, what does it mean to give an address identity at compile-time?
Thanks for the pointer to the standard.
I guess I don't see that a single branch at the beginning of an arbitrarily large function would really dominate the performance that way. edit: ah, I guess maybe it wasn't clear that I was indeed talking about a single check at the beginning of the function. Yes it would mean you'd have duplicate functions in the executable, but that's why I said that it would hopefully be far away and known to be cold. I'm imagining that the compiler would only make these duplicates when it thinks (or is hinted) that there's a benefit to doing so. I'm also imagining that the compiler could see what the maximum possible number of increments of the indices are so that that can be the number it uses in the single check. I understand that GCC actually does do this kind of specialization for some functions. I don't recall if what I saw had to do with signed vs. unsigned numbers though.
Because the singleton pattern (meyer's) is about this but with added thread-safety and init ordering ?
[removed]
I have hobby projects: * All the projects my kids are involved in. * Replacing the sprinkler heads. * Clearing out the gutters. None of them are programming of course. I really enjoy time with my family -- OK, not completing the Honey-Do list. While I do think of potential projects, I dont have the time to devote to them like I did when I was 22.
&gt; We are looking for street-smarts not book-smarts. The context of this was that they don't want the applicants to reel off the text-book definitions without having insight in what they're talking about. They don't come across as anti-theory at all to me.
&gt;The company where I work needs another experienced C++ developer. That means another round of technical interviews and another round of disappointing applicants. Wow I bet you're just thrilling to speak to
With a little snark, it is "I only work with platforms that do X, the language standard should standardize X, instead of leaving it as UB.".
Programming questions in interviews are nonsense. Nobody writes programs on paper our days. Looking at private projects of a possible applicant is one way to deal with this. Otherwise send them a task before the interview and ask them to bring the solution with them. Then you can talk about their solution and why and how they solved it. All your questions sound a bit like, oh look I know so much, what do you know? If I am invited for an interview I tell the people I am not the one with the best knowledge about the STL or library XYZ but I know where to look for information and I am a fast learner. I just got a new job and I wasn't asked a single technical question in the interview. We were talking about my live, my former employees and projects. They wanted to know if I can work with customers and if I am able to express myself in a reasonable manner. They wanted to find out if I fit in the team. Okay I have quite some projects in my github repository. This might have *saved* me from the technical questions part. Read this article from 2003 if you want to know how others are coping with this problem: http://www.artima.com/wbc/interprogP.html
Not sure.
I disagree. Sometimes your singleton is a abstract class and you get back the concrete class. Secondly it makes it easy to test the behaviour as you can instantiate it independently.
Unfortunately I don't teach or read programming books myself, so I don't have any suggestions. This is a bit off-topic for this sub. I'd suggest asking on /r/cpp_questions or StackOverflow
That would actually be an great response to the question (maybe not the getting up and leaving part) - singletons are generally to be avoided. Nevertheless, knowing how to implement a singleton shows that you understand enough of the language to be useful and opens up the discussion to follow-up questions.
Yes, but to badmouth the project shows a lack of appreciation of that. Working with legacy code is a skill you should have aquired. Edit: Downvotes interesting! Do you not think you should have to deal with legacy code? Do you think you should be able to bad mouth having to work with it? I think your failure to deal with it *does* make you part of the problem!
It needing to exist in multiple places and exist for the life-time of the application, stick it in main. It does not make it a singleton, it makes it exist higher up the tree, maybe it's an instance, that is only created once, but passed by reference. I Think the point is that not all scope problems (in fact hardly any) require global mutable state. For example you can with something that exists in main, catch an exception, and restart your main-loop (maybe serializing as much as you can so you can hide or make less painful a restart). Of course in production code... I wouldn't panic so much, everyone is right. Most managers won't allow you to fix that crap once it's shipped unless it hits their pockets.
Not using singletons. :) Or in less facetious words, passing into every function the stuff that's necessary for it to execute without relying on global state. That way you can rely on predictable inputs and outputs for any function since it no longer relies on an (unknown) global state, which makes writing tests a lot easier.
Some problems are best modeled using Singletons. It's true that singletons are just globals by another name, though they can be much easier to debug. And isn't that the main problem with globals? Static variables are another form of limited global that's easier to debug, since they're typically limited to one file or class. If you hate Singletons that much, you've been drinking some kind of kool-aid. I'm guessing TDD.
Everything you think will be hard about programming turns out to be easy. Most people get bit by choosing bad designs, following bad ideas (especially kool-aid ideas), and coming up with solutions so complicated they can't fully understand them. Figuring out syntax and algorithms? Not that hard, really. Learning a language? Not so hard. Being a good programmer? Rather hard.
&gt; That is, what does it mean to give an address identity at compile-time? `nullptr` has meaningful compile-time identity, and happens to be the default value for a value-initialized literal type. ;-]
&gt; I'd love to go around and steer companies in the right direction... and then leave. XD I am joking, but aren't those called "Seagull Consultants" - they swoop in over a project to land on the interesting parts, make lots of noise and crap everywhere - then leave.
[Wandbox](http://melpon.org/wandbox/permlink/KsOs1DDANjjKwcYb)
[This](http://melpon.org/wandbox/permlink/eH1IQPERTyXLW9zk) does not work :( *(EDIT: [it's a bug](http://stackoverflow.com/questions/39916804/can-c17s-template-argument-deduction-for-class-templates-deduce-local-types))* #include &lt;iostream&gt; template &lt;typename TF&gt; struct scope_guard : TF { scope_guard(TF f) : TF{std::move(f)} { } ~scope_guard() { (*this)(); } }; int main() { scope_guard sg0{[]{ std::cout &lt;&lt; "hi\n"; }}; } --- prog.cc:6:5: error: 'scope_guard(TF)-&gt; scope_guard&lt;TF&gt; [with TF = main()::&lt;lambda()&gt;]', declared using local type 'main()::&lt;lambda()&gt;', is used but never defined [-fpermissive] scope_guard(TF f) : TF{std::move(f)} { } ^~~~~~~~~~~
I'm in the same boat. I think the article implies that the best developers have personal programming projects going on. 
I don't like the word programmer. It doesn't describe well what you do. Computer scientists program, computer engineers program, mathematicians program, physicists program... Calling yourself programmer is like calling yourself sentences writer, when you are a novel writer. Reading this article, I got the feeling that I would nail the interview and was surprized that the author feels like it's hard to find skilled people.
I don't think `initializer_list`s are ever deducible.
Totally awesomesauce :) No more std::make_tuple.
Fortunately, [this is actually a bug!](http://stackoverflow.com/questions/39916804/can-c17s-template-argument-deduction-for-class-templates-deduce-local-types)
&gt; The following is a list of the areas I like to cover when interviewing. If both the applicant and you have a couple of hours at disposal then sure .... you'll be able to cover all of the topics. In my opinion this is way too much things and details to cover in a single round of interview. &gt; I am not a fan of extensive coding exercises in interviews but I usually get the applicant to write a simple Singleton implementation and then perhaps make it thread safe. It is worrying how many people get it wrong. Quality discussion about the implementation of thread safe singleton will let alone take you probably half an hour.
Not only that, but in some cases it is required to avoid complex control flow or gotos. [Example from my code](https://github.com/SuperV1234/ecst/blob/d54d7cec72f0020f04fa738bd8088c317c31a33b/include/ecst/context/data/data/data.inl#L18-L41) where scope guard is necessary as f_step could return void (would need an explicit specialization otherwise).
What about a singleton service provider, into which you inject all your various services, those for production use, and those for testing, mocking etc? It's essentially the same as injecting into every constructor or function, except encapsulates into a single service provider, so far less onerous on your function signatures as the number of services increases.
I think I'm not following something here. AFAIK the singleton pattern is only concerned with the fact that only 1 instance of a object should exist, it does not mandate that you should access it globally instead of passing as a parameter. As long as you are passing your singletons as parameters, I can't see how they become (unknown) global state.
No mention of clang-analyze, or -fsanitize=address with leak sanitization ?
Singleton patterns normally provide a static accessor (eg. *Foo::Get()*), so you don't need to pass the singleton instance around everywhere, but this also means the singleton can be obtained from anywhere in code (ie. global state).
&gt; If parameters are never constant expressions, then how would one be able to write a `std::distance` such that the result is a constant expression? The parameters themselves aren't, but the function as a whole can be if the arguments are (note that I make the distinction between the parameters being part of the function and the arguments being the values passed in). It's all about the fact that `constexpr` code must work at runtime as well. A `static_assert` on a runtime parameter value wouldn't work, so it's disallowed. People have certainly asked for the ability to do compile-time things with a parameter, but the best we have now is Hana's method of encoding the value in the type. The way to write `std::distance` would basically be to take the normal implementation and slap a `constexpr` onto it. The compiler does the hard work of running it all at compile-time if the result is used in a compile-time context and the arguments are all known at compile-time. &gt; I was thinking specifically about `std::array` or `T[]` because `std::begin/end` are also being made `constexpr` in 17. In this case, it really is more trivial than my iterator. Calling `begin` and `end` on an array returns a pointer, so your own iterator implementation is needed since the pointer can do all of that anyway. `std::array` likely returns a pointer, but can technically return a class like mine if it wants to, or a small wrapper around a pointer with debug assertions or something. That said, my example does use an array and could add support for `std::array` rather easily. &gt; How does the compiler test equality of these addresses when they are not determined until runtime even in a `constexpr` context. That is, what does it mean to give an address identity at compile-time? I don't have a great answer. I'm pretty sure there's no way to actually inspect the value of such a pointer at compile-time (to, e.g., print it at runtime). I guess one way that you could think about it is having `constexpr` variables be regular runtime variables in the compiler. Compile-time pointer values could hypothetically just be the runtime addresses of these compiler variables. Now that said, I still have a hard time wrapping my head around the implementation of `constexpr` in the compiler, especially for functions. Perhaps it can be thought of as creating an AST for the function call and *requiring* that the AST is optimized to a single value (the return value) when that function call is in a constant expression. The point there is that the compiler has all of the context it needs with respect to pointers and whatnot for each call, but you can't actually get into the compiler's information. If you're interested, Scott Schurr had a two-parter `constexpr` talk at CppCon 2015.
[removed]
Careful. int arr[] = {0}; std::tuple t{arr}; // error auto t2 = std::make_tuple(arr); // tuple&lt;int*&gt; The tuple constructor doesn't decay arguments. int i = 0; std::tuple t{std::ref(i)}; // tuple&lt;reference_wrapper&lt;int&gt;&gt; auto t2 = std::make_tuple(std::ref(i)); // tuple&lt;int&amp;&gt; static_assert(std::is_same&lt;decltype(t), decltype(t2)&gt;{}); // fails The tuple constructor doesn't unwrap `std::reference_wrapper` into a reference.
Really poor analysis of tooling imho...
It's not really an analysis. It's a rant.
You're missing the point here. If an interviewer is asking about singletons - it means they're using them. Which means that their code smells and there should be a really good explanation of why they write such shit.
Is it considered an issue right now? Seems like `std::tuple` is missing some deduction guide.
Your button is fucked up in Chrome: http://i.imgur.com/FpXprEH.png
You need a deduction guide for that, so until libstdc++ add one for vector. Of course, while playing around you can write one yourself, notwithstanding the UB. 
For program exit codes and anything that uses an int/enum return to indicate status, sure. If a function only has yes or no, I'd sooner expect a boolean. 
You can use this form though: std::vector v{{1, 2, 3, 4}};
I was agreeing with you! (Just adding more reasons why the assumption was incorrect.) ;-)
I've been programming less and less in my free time ever since I started on the path to doing it professionally. Sure doesn't mean I don't enjoy my work or try out new things anymore. 
Ugh. Could only find this. http://pete.akeo.ie/2011/10/building-and-running-clang-static.html Maybe if you try with the Clang/C2 toolset and pass the --analyze build flag ? There is also CppDepends which does exactly this behind the scene (but it is paid).
I have a version of CppDepends that they gave me, I'd forgotten about that as it had seemed to be more of a 'enforce corporate coding standards' kind of thing. Will try it again. And will take a look at the link. Thanks!
There are a lot of "coding standards" check but also the sanity ones. I don't remember if they are enabled by default, but it is the most complete tool I saw. It takes a very long time however.
You could argue either way. There will probably be some discussion on it if there hasn't been already.
&gt; ``` constexpr std::array&lt;int, 3&gt; y; std::distance(begin(y), end(y)); // Result is a constant expression ``` The iterator type of `std::array` - as with most ranges in the standard library - is implementation defined. This is not guaranteed to be a constant expression in C++17.
Member functions `begin()`, `end()`, et al are all `constexpr`, so while not guaranteed, it would be surprising if basic operations on the iterators were not also `constexpr`.
I am a little bit angry with this article and I want to rant about it. &gt; Experience with OS APIs (Win32, etc). You do realize that a big portion of C++ developers are basically divided in two groups: Windows and Linux. If you want a C++ dev for linux system, why ask Windows API, he probably knows very little about it. &gt; Agile methodology, experiences, pros and cons. I've never seen a single developer who wouldn't understand what agile is after 4 hours training. Really, this should not be a requirement in any way. Just teach them what Agile is, they already know C++, it won't be hard for them. &gt; Network programing. If you hire a network programmer for a specific job, go to hiring thread. Otherwise there are a lot of fields for C++ developer without any networking involved. &gt;SQL and databases, XML, Json parsers. Same as above. And please, who in 2016 writes their own xml or json parsers? &gt;I usually get the applicant to write a simple Singleton implementation and then perhaps make it thread safe. It is worrying how many people get it wrong. How do you know you are not getting it wrong? &gt; ...projects you have been working on. If they suck you were part of the problem. It is never a fault of a single developer that his project sucks (unless he is a lead developer or he is the only one developer for a project). This is why companies have project managers, Agile, HR departments, directors etc.
You're going to be surprised...
;-(
 class person : public linked_list_node Shoot me now.
Walking out of any place that has a code anti-pattern seems like setting a high bar for yourself. Every place has something you could criticize them for hiding under the rug.
You don't need a singleton for those either though. The point is to restrict instantiation of an object to one instance. 
I looked this up for your sake, but was pleasantly surprised - https://www.youtube.com/watch?v=EZ7Fjsr6Ebk In seriousness though, I can imagine if I were a student (i.e. had not yet worked around other developers), watching a video of someone do their work could be very valuable.. and in fact, watching someone work in any unfamiliar environment can provide interesting details/insights that tend to be missing from written descriptions.
I simply struggle to understand the need of locking down an object to this degree. You say there should only be one of them? OK. Make only one of them. I used to have singletons in my code, but switching them to mere single instances simplified everything. If a second instance somehow gets into the code, it means the developer didn't sufficiently research the object before using it, the code reviewer didn't catch it, etc. But for crying out loud, will creating a second instance launch nuclear missiles? Find the problem. Correct it. Move on. I'm sure there are perfectly valid reasons to have singletons, but they are few and far between. Meanwhile, I continue to run into singletons where the creator later realizes we do want multiple instances. Tearing out the singleton usage then causes real problems.
&gt; I've never seen a single developer who wouldn't understand what agile is after 4 hours training. Really, this should not be a requirement in any way. Just teach them what Agile is, they already know C++, it won't be hard for them. Seconded. I put 'agile' in the same bucket as things like XML. It's not a particularly deep skill. It can be explained and mastered in no time.
It is if you enable the debug heap (which is disabled by default in VS2015).
If you don't use it until its initialized, nothing. If you use it while it's uninitialized, typically the behavior is undefined (in actuality, the variable is just storing whatever bytes happen to be in its memory state.) Most programmers prefer every variable to have as few states as possible as it makes your program easy to reason about. If your variables are always initialized, you never have to worry if the variable has been initialized or not what a certain point in the code.
\*C.GULL\*
nice ! if anyone is interested in dabbling in a multimedia Qt app, I added some somewhat easy to grasp issues to the label. https://github.com/OSSIA/i-score/issues?q=is%3Aopen+is%3Aissue+label%3AHacktoberfest 
That seems reasonable. I'll wait until at least the first post on the algorithms, as I'm not sure how much interest there would be (outside the community) in the utilities and tuples libraries.
Author here, thanks for the feedback. &gt; Experience with OS APIs (Win32, etc) I ask about this because a lot of candidates that claim Windows experience (for example) really have only used libraries that wrap the API at a high level. Not having used Win32 (or Posix, or whatever) directly is not a deal breaker, we are just trying to gauge experience. &gt; Otherwise there are a lot of fields for C++ developer without any networking involved. Sure, but our company is not in one of them and every job I have ever had has involved some level of networking code. It is very common. &gt; SQL and databases, XML, Json parsers. Ditto. Nobody is going to ask you to write an XML parser but a senior developer should know what XML is and perhaps a method or two of dealing with it. Accessing databases is also very common. Again, lack of knowledge in one area is not a disqualification but we would be overjoyed to find someone who knew a socket from a Json node. &gt; ...projects you have been working on. If they suck you were part of the problem. I think I may have overstated this point in the article. If you have projects you are not proud of it would be acceptable to talk about what went wrong and fine with me if those reasons were out of your control - we have all been there. It is excessive complaining and blame shifting that will hurt you. 
Two-phase name lookup announced [here](https://blogs.msdn.microsoft.com/vcblog/2016/09/20/cppcon-2016-latest-and-greatest-for-c-developers/). `&lt;any&gt;` header is present in [current NuGet packages](https://blogs.msdn.microsoft.com/vcblog/2016/04/26/stay-up-to-date-with-the-visual-c-tools-on-nuget/).
std::conjunction agrees with you.
Dependency Injection and some sort overarching state management. So rather than having a Singleton DB service, you have an application which instantiates a DB service and manages to give its children access to the dependencies it needs. This allows you to have much more control over the execution and you can add/remove things easier especially for testing/mocking/debugging. For larger software its very important to have much more control to move things around and manage dependencies. If its a small project and you're not going to be maintaining it for a long time its perfectly acceptable to use a singleton and move on... but In larger projects you sacrifice a lot of control.
&gt; I ask about this because a lot of candidates that claim Windows experience I totally agree when you say it this way. Claiming to have experience that your don't have isn't a good way to get a job. Just the way you presented it made it look like you want every C++ programmer you interview to know this things. &gt; Sure, but our company is not in one of them and every job I have ever had has involved some level of networking code. It is very common. ... Accessing databases is also very common. Well, then you have to specify this: "So You Want Me to Hire You as a C++ Developer *in this particular niche of C++ development that I'm working in*?". Because I am, for example, right now working on a project that runs completely on user desktop.
Non-0 for success plus an errno equivalent beats 0 for success.
Just keep in mind this introduces a potential future problem: std::vector v{{"abc", "def"}}; for (const auto&amp;x : v) { std::cout &lt;&lt; x &lt;&lt; " "; // abc def } Someone comes along and decides that instead of using `"abc"s` and `"def"s`, they'll make this a `std::vector&lt;std::string&gt;`: std::vector&lt;std::string&gt; v{{"abc", "def"}}; // UB - crashes on WandBox for (const auto&amp;x : v) { std::cout &lt;&lt; x &lt;&lt; " "; } 
&gt; std::vector&lt;std::string&gt; v{{"abc", "def"}}; // UB Why is this UB?
Probably not quite what you are looking for, but each of these is definitely skillset-enhancing ;) https://github.com/lava/challenges
Yet still no initializer if.
And we're targeting full C++ 98/11/14 Standard conformance in 2017. Off the top of my head, the remaining issues are: * Expression SFINAE completion * Bugs in current 11/14 features, especially having to do with the ordering of initialization of statics, but goodness knows where else (thank you for your bug reports!) * Two-phase name lookup. The parser changes should be sufficiently complete for us to get two-phase done early next year. No promises but it's likely enough that you could probably win a few bets with your colleagues. * The C99 preprocessor. This is probably the last thing to come. But we'll get it in 2017. There are lots of other great changes in VS "15" outside of the language itself. We've got initial CMake support. We've got "Open folder" for loading code that wasn't written in VS. We've got a new, fast installer. We've got faster solution load, faster debugging, and faster linking. If you haven't looked at a new version of VS in a while you should definitely check it out. More details on the [VC blog](https://blogs.msdn.microsoft.com/vcblog/). And I'm going to raise the flag once again that we've [moved the layout of the VC++ tools on disk](https://www.reddit.com/r/cpp/comments/56c46x/breaking_change_alert_visual_c_tools_directory/). I don't want to self-promote but it's important that people find this out before they try to move their codebases to the new VS. Edit: clarify that we don't have C++17 conformance scheduled yet, given that there is no C++17. 
That is not actually correct. P0273r0 goes with the result of the vote at the Lenexa meeting. At that meeting, I advocated the strong ownership model (I still hold hopes that as we get more experience, the committee will reconsider this). 
"Partial import of interface" is something you need to work out in full details before further discussion: how is name lookup going to work? Especially ADL. You need to present a fairly complete analysis.
Are you referring to Thomas K√∂ppe's selection statement with initializer proposal [P0305r1](http://wg21.link/p0305)? If so, this was just discussed in Jacksonville and Oulu. We're prioritizing conformance with the existing standard over new features, although we have gotten a number of new features completed under the [/std:c++latest switch](https://blogs.msdn.microsoft.com/vcblog/2016/06/07/standards-version-switches-in-the-compiler/). Edit: fixed the paper link, thanks /u/tambry! Edit: Better paper link from /u/blelbach 
Correct me if I'm wrong but this could be calling your lambda twice since copy elision is not guaranteed yet. You should put some force inline attribute there.
There was a good [SO question](http://stackoverflow.com/questions/24112281/c11-initializer-list-fails-but-only-on-lists-of-length-2) on it. It uses the stupid iterator pair constructor for `std::string`, passing one string initialized with the pointers for these string literals treated as iterators^1. Removing one set of braces would prevent this, and it wasn't until now that I found a plausible reason for accidentally having double braces. --- ^1 : std::vector&lt;std::string&gt; v{ { "abc", "def" } }; ^^^^one string^^^^ ^^^^^^initializer list^^^^^^
What about C99 (C11) support? One of low-hanging fruits would be adding missing format specifiers to printf-family functions (like `z` for size_t).
That was already [supported](https://blogs.msdn.microsoft.com/vcblog/2014/06/18/c-runtime-crt-features-fixes-and-breaking-changes-in-visual-studio-14-ctp1/): &gt;The following length modifiers are now supported: &gt;hh: signed char or unsigned char &gt;j: intmax_t or uintmax_t &gt;t: ptrdiff_t &gt;z: size_t &gt;L: long double
What about special math functions?
So, is there a proposal for unsigned types with undefined overflow?
Intrusive LL has it's place and use. Last time I wrote one was a cache with eviction policy. It's pretty sweet to use same node for linked-list and AVL/RB. Not visible to the outside, though.
Sorry for the issues, we've been reworking our infrastructure for added support and it was offline briefly yesterday. 
Also apologies, we've been updating our infrastructure for added support and it was offline briefly yesterday. 
Improved C support--and conformance--is in our plans. We'll get (and keep) C++ conformance first. 
At this point in time, I'd rather have `if-constexpr` (no more tag dispatching, yay!) or structured bindings before two-phase lookup. But great to hear we can look forward to a fully conforming complier soonish!
I like that one. Column six doesn't tell you enough? 
This is a great talk, and it's gotten me very excited for coroutines! /u/GorNishanov Hurry up and land it in Clang!
Extended constexpr is missing and c++17 stuff as well. Would be nice to have an up to date table there or on msdn!
Btw, re language features: any update on eta of fold expressions?
nice, don't know how I missed that (i remember reading that blog post). This is not the only missing feature though.
Is the CMake integration going to be completely separate from VS Solutions or will there be some kind of integration between those two? For instance, I am currently using `include_external_msproject` to add a C# project to my CMake generated solution, so I can switch easily between my C++ part and my C# part. Do I still have to use the CMake generator for that in the future? Also, do you plan to contribute modules support for CMake?
Take as long as you want. I'm just bitter about having to implement it for libc++ :-P.
Bugfixes, mostly for interactions between templates, parameter pack expansions, and constexpr. If you are *really* interested, there's a rough list of them in [config.hpp](https://github.com/Microsoft/Range-V3-VS2015/blob/master/include/range/v3/detail/config.hpp#L111); you can grep through the fork sources for occurrences of `RANGES_WORKAROUND_MSVC_XXXX` to see the actual workarounds.
Could you clarify what you're referring to as not correct? I'm not sure I understand what you mean. edit: okay, I think the issue is that when I say the "weakest" model wasn't chosen I'm referring to the weakest model described in p0273r0, which is even more weak than the model you describe as "weak". So there's the "strong" and "weak" models you described earlier, but there's also an even weaker model. I thought it was important to point out that the model that was chosen was not actually the weakest of those considered.
You may try PVS-studio, which was advertised a lot on this subreddit. 
Thanks for the proper link. I do that all the time :/ We won't create a /std:c++17 switch until there is a C++ 17 :) You should interpret "latest" to mean "draft standard". Also, be aware that the bar for breaking changes is lower under the /std:c++latest switch. If the committee introduces a compatibility issue we're not going to fret about it under until it's under a default switch in the compiler. 
Hey cool! Awesome! Thx :-)
What would be really nice is having a non-confusing versioning system :P
No, it just means you are not passionate enough on your current job. Which may be a bad sign, actually. (Will this person be passionate about the new job then? Or just spend all their energy to side projects?) Moreover, many companies prohibit having side projects. 
D'oh! No, you probably mean Sutton and Smith's [Folding Expressions](http://wg21.link/n4191). Same answer as above :) Edit: Better paper link from /u/blelbach 
No two-phase yet. See my comment above.
Personally I don't really understand much the point of having a year version, it seems a _lot_ of software does this these days. I'd be fine with just naming it Visual Studio 15. The people that user VS aren't exactly general population anyway. With that said, I guess it's obviously not a huge deal. The updates for VS 15 looks awesome. Thanks for the awesome work!
I see, thank you! I won't mind breaking changes because if something's going to break I'll be glad to fix it, as the newest draft standards are awesome enough to warrant it.
take a look at Boost.Hana
I think it's more like calling yourself a writer. Yes, lots of people write sentences as the main part of your job, but a writer is also a meaningful job title. It's very similar with programmer. If you're a writer/programmer, the sentences/code is the main output of your work. If they're a tool to do other things, you're not a writer/programmer. 
Even better, use a lambda in an IIFE way! std::string x = [&amp;something]{ switch(something) { case (bar): return "bar"; case (foo): return "foo"; case (baz): return "baz"; } }(); 
Good. I was looking in the VS2015 folder the other day and it's a mess. There's so much stuff spread all over the place that some of it is probably entirely unused at this point, and only included because no one notices it.
It would be awesome if you could try out the new Preview 5 installer and let us know if you feel like we didn't do a good job at the cleanup. we really want to get this right, but we rely on feedback to do the final tuning for what the right granularity and defaults are. thanks!
Let me pass this along to the team. modules for Cmake is further down the path than we are at right now :) we care a lot about modules!
But they have binary compatibility guarantied. The transition should be easier than previous version jumps.
So I can use my VS2015 static libs? If so, that's really nice!
I have no idea what that means in this context :(
&gt; it's likely enough that you could probably win a few bets with your colleagues That's good enough for me.
FYI GCC already support this in trunk and it'll be available in the next version.
Thanks, I'll take a look, they have an eval download... Though it looks like another "enterpricey" thing where you have to buy multiple licenses and they don't even show you the cost until you contact them (never a good sign IMHO). 
I worked with C++03 until the beginning of the year. Being leak-free in C++03 is relatively easy, and I don't see much advantage in C++11 there.
&gt; I'm tired of coding standards that mandate Hungarian notation all while not knowing the difference between Systems Hungarian and Applications Hungarian. I never spoke Hungarian, I prefer Types.
You reversed your versions. In VS 2015, the IDE is 14, while the compiler is 19.
VS "15" will receive final branding (not announced yet). It is a new major version of the IDE and is **not** an Update to VS 2015.
Yes, we are guaranteeing bincompat in the compiler/CRT/STL. You can mix VS 2015 RTM/Update 1/2/3 and VS "15" RTM object files and static libraries without anything super bad happening. **However**, this is not ideal. The ideal thing to do is to compile everything with the latest released version, so you get all of the bugfixes present in that version. For example, mixing VS 2015 Update 3 and VS "15" RTM will not necessarily activate the major fixes I did in std::vector, depending on what the linker picks.
I am utterly unconvinced by that bzip2 example. The correct way to fix it is to have [indexes of type `size_t`](https://godbolt.org/g/vuwkFJ), not to change the sign of short indexes. As soon as you use [`-ftrapv` or `-fwrapv`](https://godbolt.org/g/uWqyDL)---which the compiler is free to do on its own---you will get the same pessimizations as with `uint32_t`. I really don't understand this recent trend of promoting signed integers as a sane default even for sizes; they're much more complicated to reason about. 
Thanks, fixed. 
Isn't –°++17 standard pretty much finished with only some voting/check from international ISO members left (if I understood the process correctly)? Maybe one small feature may slip in or slip out but it's mostly complete. Or I misunderstood something and there is still a chance of some noticeable change?
great work!
Still against them, because they hide the dependencies. To make things less onerous on the function signatures, reduce the coupling between the components. Pretending that the coupling doesn't exist by hiding it in global state does everyone a disservice. http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/
Please see Herb's [Oulu trip report](https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/). Two things to note in there: 1. We may still be reviewing the next standard at the July 2017 meeting. 2. It's only recently that compilers implemented the standard quickly. Hopefully we all get it done soon, but give us a chance :)
MS's support for C++ has come a long, long way in the last ten years - it's now world-class. Thank you for giving us the heads-up, very much appreciated!
thanks! 
we are doing a bunch of work on solution load improvements. I'd love to know if it didn't solve your problem: https://blogs.msdn.microsoft.com/vcblog/2016/10/05/faster-c-solution-load-with-vs-15/
True, I hadn't considered logging. That is a bit of a special case, because logging doesn't have any effect on the return value of a function, nor does it change the action of a function. For lack of a better term, it is a pure side effect. I think I agree with you, that pragmatism is needed, but that I tend very much against global state. I'm currently working on code that has a number of configuration parameters passed around through global state, making it hard to predict what any part of the code will do in isolation.
It's definitely possible to write good C++ code regardless, but unique_ptr eliminates a huge number of simple mistakes like (the biggest leak I recently fixed) forgetting to delete the pointers in a vector&lt;T*&gt;. Sometimes you can refactor that into a vector&lt;T&gt; and save yourself a lot of trouble, but sometimes you really need to own pointers, in which case unique_ptr is a wonderful tool.
Write some lock free code. (It'll take a while. You'll hate life. That's expected.) Write a lock free queue, specifically. Then take your lock free queue and write a thread pool that uses it to queue tasks. You can get an interview with a lot of places if you can put both of those on your resume (and actually back them up when asked about them).
I agree about the log files, because those don't affect how a function runs. I disagree about preference files, because it means that behavior is silently changing without having any visible coupling.
The question is: `values.filter{a &lt; b}` Does `a` or `b` get bound to each value in `values` or neither, acting as a constant function? Does this code generate an error since it's semantics are ambiguous, or are they clear? `values.filter{b &lt; x}` Does `x` get bound since the surrounding scope doesn't declare it? `values.filter{x &lt; y}` Assuming neither `x` nor `y` has been declared in the outer scope, do we assume that this should cause an undeclared variable error?
But why? http://i3.kym-cdn.com/photos/images/facebook/001/016/674/802.jpg
I would love to try VS15 preview 5 but preview 4 won't uninstall in my vmware fusion 8 virtual machine ("setup operation failed", I can provide log if you want). Since there is no other way to uninstall apart from within the 'installer' application then I guess that machine is stuck with the preview 4 installation. Also I really still don't understand why there is so much effort to separate the components and allow separate downloads when you still have to download the win10 sdk. It still ends up being a few GBs. Why even allow and champion that you can download the compiler by itself if it wont work?
There is a way to call multiple of bases: #include &lt;utility&gt; template&lt; typename index_sequence, typename ...F &gt; struct scope_guard_base; template&lt; std::size_t I, typename F &gt; struct scope_guard_wrapper { F f; }; template&lt; std::size_t I, typename F &gt; F &amp; get(scope_guard_wrapper&lt; I, F &gt; * sg) { return sg-&gt;f; } template &lt; std::size_t ...I, typename ...F &gt; struct scope_guard_base&lt; std::index_sequence&lt; I... &gt;, F... &gt; : scope_guard_wrapper&lt; I, F &gt;... { using base = scope_guard_base; scope_guard_base(F &amp;&amp;... f) : scope_guard_wrapper&lt; I, F &gt;{std::forward&lt; F &gt;(f)}... { ; } ~scope_guard_base() { (get&lt; (sizeof...(I) - 1 - I) &gt;(this)(), ...); } }; template&lt; typename ...F &gt; struct scope_guard : scope_guard_base&lt; std::index_sequence_for&lt; F... &gt;, F... &gt; { scope_guard(F &amp;&amp;... f) : scope_guard::base{std::forward&lt; F &gt;(f)...} { ; } }; #include &lt;iostream&gt; template&lt; std::size_t I &gt; struct F { F() { std::cout &lt;&lt; I &lt;&lt; std::endl; } void operator () () { std::cout &lt;&lt; I &lt;&lt; std::endl; } }; int main() { F&lt; 0 &gt; f{}; scope_guard _{f, F&lt; 1 &gt;{}, F&lt; 2 &gt;{}}; }
I use CMake and this is a welcome addition, but CMake's language still leaves a lot to be desired. Wish somebody would clean that up. 
Agreed with your edit.
You appear to be working from heavy hypotheses that you need to surface clearly. For example, this: &gt;The compiled representation of a module will have been produced from all the module's translation units does not match current implementation strategies deployed. If what you suggest is _required_, it would constitute a severe impediment to achieving better build throughput.
I'm much more scared by anything that says K&amp;R C. main(argc, argv) int argc, char** argv { AAAAAAAAAAARGH }
What would you change for instance ? My main pain points are `get_property(myOutputVar ...)` instead of `myOutputVar = get_property(...)` and generator expressions being unable to be indented on a new line when nested.
Interesting, I should try that. Last time I checked, it was clang-format + maybe Clang SA tools if you didn't use anything too exotic with Windows SEH.
I mean they could skip a version number and make it all even out, but that would just be ridiculous.
It's really gratifying to see uptake and interest in the server mode. I'm glad others are able to take to the design so readily. I spoke to /u/marian_l and his team back in April about what the CMake server makes possible, but this is the first result I'm seeing. Looking forward to seeing more, getting more feedback, and converging with the updated protocol (designed with QtCreator in mind) that just hit CMake master and 3.7-RC!
Regardless of whether dereferencing a null pointer in some platform is a defined operation or not, as far as the C++ standard is concerned it is *always* undefined behavior; the compiler can do whatever it wants, including just letting the operation just go ahead as planned.
ill try this
&gt;[**peel a bag of potatoes in 50 seconds [1:06]**](http://youtu.be/HznsmTY45Zs) &gt; [*^iam ^goofy*](https://www.youtube.com/channel/UCaIRHwCGcJR2LHUeAe7bYyA) ^in ^People ^&amp; ^Blogs &gt;*^22,883 ^views ^since ^Jun ^2014* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
So how big of a saying do Kitware/Brad King have? If they don't want something, is it not going to happen?
If they're not using singletons - then why ask about its implementation?
Correct, but Brad would like to see a new language for cmake just as much as anyone on reddit :). I probably have a better idea of the refactorings that need to be done in order to make a new language possible though. I've been refactoring CMake internals for a long time to make space for things like that, so I could provide guidance to the willing.
for simple tools wxwidgets is more than enough. I have used successfully in commercial apps as well
That one was voted into the C++17 CD at the last meeting (June). The Visual C++ Team has to consider prioritizing C++14 conformance (which cumulatively includes C++98, C++11), and high profile TSes, and quality (bug fixes), and the hot new stuff that just got voted into the draft. Be a little patient :-)
How so? WG21 has not even done a ballot resolution yet -- scheduled for the next meeting in Issaquah, next month. If things go as planed, we **may** have new C++ standards stamped C++2017, but WG21 and ISO bureaucracy never cease to surprise. You don't want a major C++ compiler to create confusion as to the C++ standard version.
Why not just bump the version number to 16, then drop the year altogether ? It would even leave the door open to a 6 months cycle !
I _generally_ support writing code that enforces rules at compile time. I agree with not increasing cognitive burden where possible. I just see this as a situation where more important values come into play. I'm more calling out the idea that "if we create two, the world will explode". It'd be like recreating all of map&lt;T&gt; _just_ to make it a singleton version. No, we should just have a map placed in a logical place where it can live alone instead of constructing a singleton fortress for it.
There is a way to achieve this with less complexity: let macros alone, and let the existing `#include` mechanism handle them the way it always has. The transition story does not have to be complicated -- simpler is better. One key takeaway from Manuel's great talk is: if you want to get compile-time improvement, well your headers have to be modular. I thought that was an important lesson learned from the experiment. 
&gt; I wish I could use valgrind. I'm pretty much stuck with the OS and compiler and project structure that the client has given me though The closest analogue I can think of for Windows (also works on Linux, Mac, and Android): http://www.drmemory.org/ * https://github.com/DynamoRIO/drmemory * https://en.wikipedia.org/wiki/DynamoRIO#Dr._Memory * http://www.dynamorio.org/ Try it out, perhaps it's close enough for your purposes?
Sure. The case I ran into had no valid reasons. They were simply ignorant to even the most basic LL implementations. The only way they could get it working was to have various classes extend the node class.
There is no such thing as a simple Singleton implementation :) Also, you want to hire a senior programmer. Maybe you don't need to, maybe you do. But anyway, that is what it sounds like you are looking for. In this case, talk about your projects, the financial aspect of the whole deal, and you will probably find the person you need. A lot of company expect to find a seasoned developer for the price of an intern. And forget to make them or the projects attractive. It's a two-way street. 
I often sound as a ranty/cynical guy, but I must say, firing QtCreator and having all sort of static analysis going on real time courtesy of clang is pretty freaking awesome. And it can only get better. Also, I totally love VTtune and other tools by Intel. They are unfortunately expensive but It's definitively something to consider having in a company.
I'd settle for s-expressions at this point. 
Last I looked there were some rumblings on the mailing list about why a LUA port wouldn't fly
here's a hello world Qt example with CMake : https://github.com/eugenkiss/7guis/blob/master/Qt5/OnlyCPP/counter/counter.cpp
The same reason you would ask a candidate to implement breadth first search or any other thing you don't necessarily expect them to implement in practice: you think it's an interesting problem to watch them solve, which is doable in a short period of time.
This sub is for discussions, articles, and news about the C++, not for advice/questions about a personal project. You can post in r/cpp_questions if you still need more help.
Presenter here -- I'm happy to answer any questions about this talk or more generally about CUDA support in clang. The documentation about how to build CUDA with clang is at http://llvm.org/docs/CompileCudaWithLLVM.html.
If Preview 5 doesn't install under VMWare Fusion I'd appreciate a log, thank you. I'll send a note to have someone on the VS team try that scenario out. The C++ install requires a lot of components--the libraries are large, and runtimes are compiled multiple times (debug vs. release, target architectures.) We have compilers for a number of architecture combinations. We could factor the install ad infinitum but at some point the returns diminish. Edit: A Windows SDK (8 or 10) is required to build an app that targets the Windows subsystem, that's true. 
It's likely to be the final release scheme. But this is in preview, and things can change. "In a typical Preview 5 installation, %VCINSTALLDIR% would point to %Program Files(x86)%\Microsoft Visual Studio 15.0\Common7\IDE\VisualCpp." 
I was hoping the article would talk about dependency management :( I honestly think we should all be just talking about this and nothing else. I love C++, and the sad state of build+dependency management in this language makes me cry when compared to virtually any other language. And don't get me wrong, I have no problem finding libraries and somehow getting them to work with my applications for all the platforms I'm targeting. The problem is that, due to the current state of affairs (no standard dependency manager), all the C++ libraries are HUGE! You have a library for training neural networks? Chances are you'll have to implement/copy-paste your own shared_ptr implementation, because otherwise, in order to support pre C++11 compilers you'll have to depend on boost!!! (Note: I love boost for application development, but it's simply an unacceptable dependency for a library). In summary, the lack of a reliable dependency manager results in bloated libraries that re-implement core-abstractions, so they all introduce their own vocabulary to express similar concepts.
Excellent!
Beginner questions are off-topic here; please read the sidebar.
Can you please point out in the spec where such a distinction is made?
My understanding was that gcc/clang have `c++1y/z` switch until they are sure that the number is certain. And C++17 being pretty much complete since the Committee Draft was voted to be shipped. Anyway, it's hardly an important issue, especially considering that VS didn't have any std flags at all up until recently)
(All citations from N4606.) [conv.ptr]/1: &gt; A _null pointer constant_ is an integer literal with value zero or a prvalue of type `std::nullptr_t`. A null pointer constant can be converted to a pointer type; the result is the _null pointer value_ of that type and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a _null pointer conversion_. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion. A null pointer constant of integral type can be converted to a prvalue of type `std::nullptr_t`. [ _Note:_ The resulting prvalue is not a null pointer value. _‚Äîend note_ ] and [lex.nullptr]/1: &gt; The pointer literal is the keyword `nullptr`. It is a prvalue of type `std::nullptr_t`. [ _Note:_ `std::nullptr_t` is a distinct type that is neither a pointer type nor a pointer to member type; rather, a prvalue of this type is a null pointer constant and can be converted to a null pointer value or null member pointer value. _‚Äîend note_ ] Here a formal distinction is made between a null pointer constant (which must be represented by `0` or `nullptr`) and a null pointer _value_ (whose representation is specified as implementation-defined in [basic.compound]/3). So the only _actual_ requirements are that null pointer values can be made from null pointer constants and that null pointer values compare equal to each other; there is _no_ requirement that null pointer values must be represented with address zero, or that address zero is special in any way.
It used to be called 'cmake daemon' because that sounded more 'local' to me. https://steveire.wordpress.com/2016/01/24/cmake-daemon-for-user-tools/ It's CMake telling eg Visual Studio and QtCreator about the build system using IPC, instead of generating project files.
To keep it symmetrical with std::to_chars?
thanks for the info andrew. I'm always tempted to switch over to vs but the size just puts me off. I always end up sticking with qt creator and a 100mb gcc. I'm on osx so being able to test things on vmware is what I'm after. Cheers :)
Well, I don't see anything in GCC documentation (for trunk) that says they have `-std=c++17`. See https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html 
Yeah, silly Ubuntu on this one. I am trying not to build boost, but may give up on that, and 1.58 does not have string_view. Too bad there isn't a repo that has the latest deb's
it's a header only lib. you just need to extract boost_1_62_0.tar.gz somewhere and -I your folder
Suppose during the conversation it turns out that the interviewer disappointingly lacks knowledge of certain areas of C++ which are not necessarily needed but using them makes the code better (more expressive, readable, robust, etc.) As someone who wants to surround himself with people more knowledgeable than self, how should the interviewee approach this? How would the interviewer handle it if the interviewee's answers hinted at better knowledge than the the interviewer? 
Wasn't there an attempt a few years ago to replace the CMake scripting language with Lua, and even a working branch?
I'm getting a link request not found error (I'm on mobile if that matters). 
/u/STL gave more details in the comments [here](https://www.reddit.com/r/cpp/comments/4zeeg4/c1417_features_and_stl_fixes_in_vs_15_preview_4/d6v7jd7) and [here](https://www.reddit.com/r/cpp/comments/4r8n41/what_are_some_reasons_why_visual_studio_seems_so/d4zolll)
&gt; I now have two programs. Well said. That's the reason why I hate everything related to building C++ projects. 
Why's that any sort of advantage?
What does thrust or similar support look like on LLVM? CUDA is great but using raw pointers sucks.
&gt; you said that gcc doesn't generate ptx but I thought that it supported offloading through openacc to ptx. Yeah, I think I heard the question as "does GCC support CUDA", which as far as I can tell it doesn't, but you're absolutely right that gcc can target ptx through openacc. I don't know much about it, though. &gt; also is it possible to write in cuda and generate code to run on amd/ati? It is theoretically possible, but it is not possible today with clang/llvm. I don't know a lot about AMD GPUs, but I would expect that among the challenges would be * somehow dealing with code that implicitly assumes a warp size of 32 (or not, maybe you just redefine WARP_SIZE and wash your hands of this), and * handling the many CUDA intrinsics. Right now, most of these intrinsics are implemented as inline assembly (ugh), which is obviously not going to work. You'd have to make llvm understand these instructions and add lowerings for them to amd GPUs. I understand that AMD has a tool that translates CUDA to something they can run, and that it's a "90% solution". I haven't tried it to understand how and how well it works.
The YouTube link or the llvm documentation link? Both work for me, though. Maybe the LLVM server was temporarily having problems?
Is it still broken for you? It works for me...very odd.
Honestly I don't know the state of clang's opencl support. Like you say, it exists, but...that is all I know, sorry.
Thanks. I'll look around elsewhere. 
This is a bit off-topic for our subreddit; you may want to try /r/cpp_questions or StackOverflow.
My first attempt at using the new generalized constexpr support caused the compiler to generate a dynamic initializer function for a constexpr global variable. That's not actually allowed by the Standard, is it? 
&gt; That's not actually allowed by the Standard, is it? No, it is not. If the initializer expression is a constant expression, the variable must be constant-initialized. If the initializer is NOT a constant expression, the compiler must diagnose your ill-formed attempt to initialize a constexpr variable with a non-constant expression.
Since it can be bundled it is irrelevant, we install cmake anyway and size does hardly matter. On anything but windows it is present already anyway. But there also exists duktape - tiny js interpreter as cool as lua.
First time I actually seen the concepts syntax. The "Negative One requires" looks really great!
You might be insterested in [Meson](http://mesonbuild.com) instead. It is exactly what you want, a simple DSL designed to express build definitions and *nothing else* and which is not Turing complete by design (and never will be). [Github project here](https://github.com/mesonbuild/meson).
I find it funny how everyone started expecting the year to match the major version number since it "accidentally" happened in version 10.
Is the compiler supposed to be listed as a new toolset? I installed it today with the Desktop and Games with C++ work loads, and I'm not seeing the relaxed-constexpr ([and no new toolset in the options](http://imgur.com/a/XcPPj)).
Why so much hate ??Any specific reason?? üòé
Close. nvcc includes a fork of llvm, but not, to my knowledge, clang. Their front-end is entirely different from ours.
&gt; Are there any known portability issues? Is this equally usable on Windows? It's currently linux-only. There's no deep reason for this, beyond, we don't have the machines or customers on Windows. I don't think it would be hard for someone to make it work on Windows. &gt; Also, has anyone done systematic benchmarking between this implementation and the usual NVCC toolchains? Not to my knowledge.
Interesting. Thanks for sharing! Downloading now
Unsigned indices and sizes make some cases easier (you cannot have negative size/index), at the cost of making different things harder. One of the first bugs that made me really go WTF? and scratch my head was blindly subtracting 1 from `vector::size`in a for loop. This made my for loop try to iterate from 0, to `UINT_MAX`, (ouch) inside a signed int, which is not really possible (double ouch). A signed size would prevent this.
Yeah, but let's face it, Intel dominates the CPU market.
The way they did so was through skullduggery and sabotage. They certainly killed AMD using nothing more than their compiler. In fact, they were subject to antitrust laws because of the way that they screwed over AMD.
&gt; Boost is a huge beast, and a pain to compile if you don't have it prebuilt for your platform. - Boost is a collection of libraries, not a library; few need building, most are header-only. - Boost.SmartPtr in particular is header-only. &gt; edit: Think about why people want boost::asio to go to the standard library? Because they want to be able to use it as a base abstraction, without forcing boost down their users' throats. ASIO is first and foremost (and has always been) standalone, and is header-only when targeting C++11 or above. Scripts shoehorn it into Boost's ecosystem for major releases, but active development is done in isolation. In essence you're arguing _for_ Boost here, as ASIO needed to be part of the Boost ecosystem in order to get enough traction to warrant proposing to the standard, even though it was always available without Boost. I get it. People like hating Boost. It doesn't make any _sense_, but you're not alone.
&gt; Extrapolating your answer &amp; edited answer above, I guess your response could be that on platforms where 0x0 is a valid address to write into, then NULL by induction then cannot have 0 as its bit pattern (because if it did, then accessing 0x0 would have to be UB). Right. &gt; What is a valid bit-representation for NULL on this platform that doesn't result in UB for what should be well-behaved code. As per [basic.compound], it's pointedly implementation-defined (i.e. "not the standard committee's problem"). The overall point was that reading/writing to address zero is a programmer error IFF a null pointer value is represented with zero. In general, a program shouldn't know _or care_ about the value of a pointer, only whether it is or is not the same value as the null pointer value, which may or may not be zero (null pointer _constant_ not withstanding).
&gt; I get it. People like hating Boost. It doesn't make any sense, but you're not alone. No, actually I happen to be one of those people who like loving Boost. One of those that check the Boost candidate library review process regularly. I wish you didn't make this a discussion for or against Boost. I know most of Boost is header only, but it doesn't change the fact that it's effectively monolithic, as in you can feasibly only have ONE version of it as a global dependency of your whole project. If I'm wrong here, please surprize me, but can you really #include smart pointers from Boost 1.56 and some ASIO headers from 1.55? That will probably fail miserably. So, do you see how this is bad for modularity? Hundreds of megabytes of C++ headers and you have to stick to a single global version. With enough dependencies that transitively depend on Boost, you'll eventually deplete the set of Boost versions that satisfy all of them. I know that because of this state of affairs Boost tries to be backward compatible as much as possible, so if you need 1.55 and 1.56, you can probably just stick to 1.56, but that's only a workaround, because in an ideal world, libraries SHOULD be able to break compatibility in future versions. Otherwise they can't evolve. So, I'm not blaming the developers of Boost at all. They've probably made the best choices given the way things are. I'm trying to argue that the problems with Boost is just the logical conclusion of the lack of a dependency manager.
Looks promising. I'm curious to see these benchmarks once the library becomes more productions ready (fault tolerance especially). 
&gt; But I'd guess that's not what you're getting at... ;-] Thanks for saving me the trouble. It feels strange for me to be on the side that appears to be against Boost for once :) Now I'll go celebrate having reached an agreement with someone on the Internet :)
First things that comes to mind is for example converter from XML to JSON and backwords. Fairly simple, but you can nicely architecture it with C++ features
As someone who sadly can't go to the conference, I'd like to thank the people responsible for paying for, filming &amp; editing the videos. The editing + sound quality is most of the time top-notch, which is far from always be the case in other C++ related conferences. On the negative sides: I usually stay clear from all the diversity debates going on in the other side of the pond, but, there was only one woman in the pool of presenters (and her talk was a bit on the abstract side). I loved Kate Gregory's talk in 2015, I wouldn't have mind another one this year. ^(Also, can we get Scott Meyers to un-retire ?) :) Anyway. Thanks again. 
Seriously, these are the highlight of the year in terms of conference presentations on youtube. As someone who currently can't make it out, thank you!
Steve, you may have misunderstood my comments. I highly commend your numerous efforts in simplifying access to cmake projects for the use in tools like IDEs etc. Perhaps one day you could take the solution to a higher level, and define a generally applicable API that can be used between build description/generators and users of said systems distributed build systems, IDEs, static analysis tools etc. That way your efforts could acts as a sort of LLVM-like middle layer between 'languages' (cmake, scons, make...) and targets/consumers (IDEs, build systems, tooling etc) 
You should know that C++ is a multiparadime language, not solely for OOP. If youre just learning try to keep it in mind, otherwise youre just pigeonholing yourself.
It was never filmed on account of it never being given. Signed wins by default. :P
Aha, yes, I was expecting something like that. Fair enough. Functional/flow programing is a proven technique to solve the problem of parallelism. Of course, it turns out that functional programming has it own set of problems, and one of them is certainly "As programmers, we don't understand it well enough," so a new library that makes things more semantic sugary and gives you some system to follow is very welcome. Unfortunately, these days I'm working a lot on DSP-like code - where I've actually been converting someone functional code to be applicative/mutating - so this won't work for me today. You can appreciate that this code, that originally made copies of long lists of colors for each operation, is much faster (over an order of magnitude, nearly two orders of magnitude in one common degenerate case!) now it's running "in-place". But my hope is eventually, when the plumbing is all fixed, I can provide a functional superstructure, where all the computations are done at the end with mutators behind the scenes. But I'll bear you in mind. I always want more parallelism to get all those cores up and working. :-)
Well, what about _detecting_ failure? Failure is always possible. A system that sometimes fails silently is dangerous. A system that rarely fails but clearly tells you when it does is fine. 
One more note here about your code on https://haptork.github.io/easyLambda/docs/real-world/: it's hard to read and hard to understand. No matter how I resized the page, I wasn't able fit all the code in the page without scrolling because it's so wide (though part of that is your page's style). And those levels of parens and function calls - hard to see what call belongs with which thing. I understand - and approve of the fact! - that you want a functional style - but that doesn't mean should try to entirely imitate LISP. You want to try to attract people to show off how great and how simple your library, not show off how clever and intricate this library allows you to be. Using intermediate variables is something that isn't idiomatic in LISP but it is in C++: like this auto data = fromFile&lt;string&gt;(argv[1]); auto risen = ezl::rise(data.rowSeparator('s').colSeparator("")); risen.reduce&lt;1&gt;(ezl::count(), 0).dump().run(); It also has a documentary purpose. Look at two variables `data` and `risen` - those expose that fact that I don't really understand what they do. :-D If you wrote this, you could give them clear names that DO explain what they do. EDIT: You should be upvoting people's comments if you don't hate 'em. :-)
/u/JonKalb In your lighting talk [‚Äúunsigned: A Guideline for Better Code"](https://www.youtube.com/watch?v=wvtFGa6XJDU) you mention another lightning talk from James McNellis, however I am unable to find this. Are all lighting talks uploaded?
I will update the master thread tonight, hopefully.
This would be better asked on /r/cpp_questions or StackOverflow; this is off-topic for our sub.
&gt; it is usually more efficient, for small objects, to use static allocated memory (the stack) than dynamic allocated memory (the heap) Objects living on the stack have *automatic* storage duration, not static. -- Some remarks: 1. Doesn't compile cleanly (missing `&lt;utility&gt;` for `std::move`) 2. Doesn't support perfect forwarding of constructor arguments (so it's not currently possible to host atomics for example). 3. Your helper should be `inline` if you want to avoid ODR issues.
Why would it be?
I may have overlooked it, but I have not seen my talk on Channels on YouTube. It may be because of the change of date.
You are right, since I understand the difference between "int a" and "static int a", I should have been able to avoid this confusion. Thanks to you and 3ba7b1347bfb8f304c0e, I fixed the problem in the README.md. Of course, sadly, the problem remains in the name of the class, and in the name of this post...
According to [this](https://www.reddit.com/r/cpp/comments/56newq/all_cppcon_2016_videos_are_now_on_youtube/d8kwvp1) it never happened.
it requires backend support that hasn't been done in c2. 
It looked like something was unclear from reading your post, so I thought more information would be useful. Sorry if I misunderstood something!
is there any reason not to use the standard library coding conventions for this project? make_StaticConstructor just looks plain wrong.
Seriously, get more female presenters next year. It's no wonder women feel excluded from the industry. EDIT: A clarification because of the downvotes. I didn't mean that the CppCon organizers went out of their way to create this disbalance, and I'm quite aware that this is very much representative of CS as a whole. I just meant that we should consciously try a bit more to make women feel welcomed in CS.
Hmm, maybe we should have inheritance for threads then, when you post a comment to the base thread, derived threads also receive the commnet. We should of course have multiple inheritance though. I think we should also have subreddits that are parameterized over other subreddits! How about inline subreddits! You should be able to type `[]{...}` and start an anonymous subreddit from a comment.
Currently, the runtime errors / exception in a process can be caught in a process with exception handling. The main function of every examples runs inside a try block. If a node fails then the default behavior of standard MPI without any fault tolerance extension is that the program keeps waiting for the process before aborting the whole program. The fault tolerance extension for the ezl library should focus on improving the node failure case.
We had a joke here about Schroedinger's cell phones. Since Schroedinger had no cell phones, he can't have had a cell phone that was on. So all Schroedinger's cell phones were off. But the negation of that statement says they're all on. Typical Schroedinger. All his cell phones are both on and off. But apparently `fold(and, map(is_on, schroedinger_cell_phones))` is `true` after all? So Schroedinger's phones are on! Just to say: claiming that 'booleans form a monoid under conjunction' is just off topic. The reason that accumulation should return the identity is a better reason, but wrong: `accumulate(begin, end, initial, op)` has an 'initial' element to cope with the empty set. I agree that it's _convenient_ to have zero string's concatenated result in an empty string. Or the sum of no numbers be zero. But I can't generalize that just because we're used to that.
Awesome, thanks for all your work on this. Are the poster sessions going to be posted online?
Recursion is a trick now? If you want to educate beginners in using C++, why not use the standard library and use std::iota() to build your list of numbers?
So it seems like if I start a new project [I get new toolset options.](https://i.imgur.com/MZpKHjI.png) Which seem to fix the problems I was having. I'm unsure what I have to do to "upgrade" my current project/solution to be on the new toolset since the option just isn't there.
‚Ç¨ 80 seems excessive. You can get a softcover copy of TC++PL 4th edition from http://www.bookdepository.com for about ‚Ç¨45.
There also was this talk with Stephanie Hurlburt as co-presenter. This leads me to a related question: I cannot seem to find the video for this talk: https://cppcon2016.sched.org/event/8Mw8/texture-compression?iframe=no&amp;w=&amp;sidebar=yes&amp;bg=no Was the talk cancelled?
Sorry to dash your hopes; but it is not satire. It's merely an insightful video.
I suggest Professor Melissa O'Neill, she does interesting work on random number generators, also co-authored a proposal to improve usage of the &lt;random&gt; header.
in your example why did you need to sync the threads after doing something explicitly on thread 0 just to be able to do something on that same thread? could you have done both atomic calls inside the same branch and then called syncthreads afterwards?
Is this code correct: template &lt;class T1, class T2&gt; constexpr T1 &amp;&amp; get_helper (pair &lt;T1, T2&gt; &amp;&amp; p, bits::index_tag &lt;0&gt;) noexcept { return stl::move (p.first); } This seems similar to giving out reference to a local variable. 
Im just fooling around while learning C++, and want to think ouside the main, for once i leave college. Last night I tried to make two "long int" arrays with 1000000000 elements each, but DevCpp GCC++ was compiling that at the speed of snail. I settled for this, to conclude my array learning yoloment: https://pastebin.com/wZ8MTPyt At least i learned how to printf with unique width per variable. It was equally satisfactory and productive as the day i made an infinite for loop with this inside: Xclass *xc = new Xclass() ; Everyone should try that one at least once, but not before opening task manager :)
&gt; Recursion is a trick now? My reaction exactly...
Thank you for your contribution, but this content isn't suitable for our sub. You are not showing anything novel, nor is the material particularly educational.
It's not quite good enough to build Boost with C++14 enabled (at least, not on the beta version I have). Getting there, though. 
Yes
Our AI overlords will be very productive with it
Oh I see. Bummer. Thanks for the clarification.
You should activate your windows.
&gt; It takes an rvalue reference to the pair (hence why p is not local) That's exactly why I said its a local variable to the function, since you got it be rvalue reference. 'p' is now an lvalue and local to the function. Also, I must add that the code is wrong only on the basis how the return value is used: auto &amp;&amp; v = get_helper(...); // This is 'not' ok auto v = get_helper(...); // This is ok
"KDevelop" "Windows"... now THESE are two words I never imagined could be used together in the same sentence.
I'm sorry, that's just not the case. The parameter p is still a reference nonetheless. The object to which it points is either a temporary object (with lifetime at least as long as the original call to get), or a moved-from lvalue. In neither case does p refer to an object local to the function. Yes, actually your usage of auto&amp;&amp; in the above *is okay*. The only thing that declaration means is that the type of v is deduced and undergoes reference collapsing. The object v can, in fact, be constructed with a temporary (or an rvalue reference returned by a call to get).
Ah, thanks. I see what you're referring to now. I don't believe that VS "15" Preview 5 has the ability to switch between v140 and v141. We're building out these scenarios. Right now if you take a project from VS 2015 and open it with VS "15" P5 you should get [an upgrade dialog](http://imgur.com/gallery/Urw5O). After clicking "OK", the project is now using the v141 Platform Toolset. But I'll let you in on a little secret: right now the compilers in v140 and v141 toolsets are the same thing. 
Thanks, I think App Verifier is doing that for me but will take a look. 
Now try with 10000.
I'm actually interested in finding a better name. I've never really liked static constructor, but I wasn't able to find something better yet. Of course, after the discussion that happened here, I think Automatic_constructor would be better, but it's still not as good as I'd like it to be. The idea is: you choose the moment you construct the object, but you do not have to use a pointer to do it. Anyway, if anybody has an idea, I'm interested.
Probably nothing. Honestly, I thought about Boost Optional late, when I was almost done with this class. Then, I went very rapidly through the documentation, and I wasn't quite sure that Optional is doing *exactly* the same thing that StaticConstructor is doing. Maybe one advantage of StaticConstructor is that it is very lightweight: you can read its code in 2 minutes. Of course Optional has a lot of other advantages.
No official plans at this time. I was just explaining why they don't work yet
His solution was vastly more complicated than the problem he had.
I've made some edits to track what's going on (there's two versions): http://coliru.stacked-crooked.com/a/fe9b675403e8fbfa http://coliru.stacked-crooked.com/a/98de9654160eb836 The difference comes in constructing a temporary object of type `std::pair &lt;Test, Test&gt;`. Those calls to the move constructor you saw in your original program were *not* from the definition/initialization of `auto &amp;&amp; r` and the call to get. They were actually from the construction of the temporary pair object. So, like I said, get does not return a reference to a function local object.
While I agree with them, my post was about what point they are making. The way they look at it, which is the same as I look at it, is they need a language where they can target the actual hardware, not the specification of the language. &gt; This would lead to writing code that runs on x86_64-Windows-MSVC++ triplet only, which is hilariously bad idea, even though I've been paid fairly well to unfuck these kind of things in the past. But this is what they, and I, actually need. What makes it a bad idea? I mean, they care about the machine code that's being generated and how that machine code talks to the operating system. They have to care about that, they make games, not web apps. Why am I getting downvoted?
The relevant code is __shared__ int shared_sum; shared_sum = 0; __syncthreads(); if (threadIdx.x % 32 == 0) atomicAdd_shared(&amp;shared_sum, sum); __syncthreads(); if (threadIdx.x == 0) atomicAdd(out, shared_sum); The question is, why do we need the second syncthreads? The reason we need it is because when we read shared_sum during the second atomicAdd, it needs to contain the sum from all the threads in the block. Threads in a block don't run in lockstep, so you need to sync.
Thanks for the feedback :) There is going to be some changes on Friday to the blogroll...
Why exactly is the last example not valid in the current proposal? Is it just an "oversight" or are there implementation difficulties?
I agree there should be more. But I would also point out that cppcon aims to and appeals to people who tend to be very experienced in the industry, people who have been there a long time. And since we're only now starting to make improvements in diversity, it makes sense that it is harder to find women for these speaking positions than, say, a Java or python con. Even the males at this con seem to be, on average, older than what you would see at a python con. So yeah, it needs to improve. But it is understandable why cppcon might lag behind other conventions in this regard. Luckily it should only improve from here. 
Thank you Jon and the many others involved for all the planning and hard work required to pull this great conference off. Top flight!
Everybody's collectively, probably.
It surely helps a lot that KDE is built on top of Qt and that Qt is very portable.
I'm not sure whether you know what you are talking about: For instance, given that KDevelop uses clang in the background, it has 100% correct code completion and code navigation, also for all sorts of template metaprogramming. Of course alternatives exist, but I have yet to see IDE's that do those things equally well. :-) So no, it's not ridiculous at all, especially since KDevelop is free software. And the KDE libraries are all portable, so there is no reason think of KDE as Linux only... For instance, we also have [Kate on Windows](http://download.kde.org/unstable/kate/), and it's working pretty nice.
&gt; The reason it is IPC is to avoid ABI/architecture issues. Do you think that a simple "client" library could be built on the receiving side ?
Title should be "Performance cost of size_t vs. uint32_t"
I've tried to get the upgrade dialog on two machines, and it just doesn't seem to want to pop up. Is there a way to force it? Like I can open up the solution in VS 15 P5 and it just chugs along using the toolsets I already had available in 2015. As for the v140 versus v141, it seems like when I'm using v140 I'm using the toolset and compiler from my VS 2015 installation, not some v140 toolset and compiler from VS 15 P5. Or did you mean some possible future VS 2015 update will be using the same compiler from v141 since it's the same? (Binary compat wise) Side note: I would compare the error strings for the following snippet: https://gist.github.com/playmer/ace67f3b35aef24877dbe1826fda971f (BooleanCompare should be marked as a const function.) The one from Clang/C2 is much better than the one provided from MSVC. Admittedly I should study constexpr more, but that's the point of me playing with Clang/C2 and the preview in the first place! Thanks for all the help!
&gt; But this is what they, and I, actually need. What makes it a bad idea? I mean, they care about the machine code that's being generated and how that machine code talks to the operating system. They have to care about that, they make games, not web apps. What makes it a bad idea is force compatibility or lack thereof. If you avoid platform specific behaviour as much as you can (ie, you restrict yourself to language's standards and publicly documented APIs with guarantees), your code won't die, just because new version of VS shipped.* Something similar goes for original Simcity, which used a memory after free, because at the time of its development Windows' allocation patterns let it. Now, this changed with Win95, but because MS is stupidly dedicated to backwards compatibility, instead of telling the people who "knew how that machine code talks to OS" to get fucked and fix their shit, they instead detect if Simcity is running and change the allocations around it. WinZip decided to read pointer off stack frame, where they noticed a OS returned text (pointer to ASCII C-string) resided, instead of using OS API. Obviously this changed over time, as Windows have gotten better at internationalization, and WinZip started crashing... to fix this, there is now code that takes the unicode result, changes it to ASCII and plants the ptr to where WinZip is looking. ... There are literally hundreds of cases where people wrote code that kinda worked on the very specific platform, that relied on guaranteed behaviour and Windows is paying the price. If they instead decided to throw non-functioning shit back, you would be paying the price. ... "But that is old and sucky code by stupid idiots, we have gotten better" you might say. And you would be right, but the reality is, that even Carmack makes mistakes, and those mistakes mean that every single GPU driver in the PC space has to detect when Q3 is running and modify its behaviour, so that it doesn't crash. ---- * MinGW would be guilty of this, if MS wasn't willing to bend over backwards to accommodate people who do dumb shit. They link into internal library, instead of external, so MS is now locked into keeping that one compatible and has invented new scheme for their own use. 
&gt; (BooleanCompare should be marked as a const function.) If you mean it should _implicitly_ be marked as `const`, then under C++11 rules it should, but under C++14 rules it _shouldn't_.
"KDE Libraries" are something different than they used to be. If you say that word today, you mean something like the KDE Text Editor, the internationalization framework, or the widgets addons like a color picker. Those tools do not exist in the "native" set of libraries, or at least not to this extent. There is absolutely no reason why those libraries shouldn't work on Windows (and in fact, they do quite well).
&gt; No no, (I think, if I'm understanding you right) that code snippet is supposed to be an error. It should be explicitly marked const to compile. (Right?) Oh, yes, you're right of course &amp;ndash; `test1` is implicitly `const`, thus `BooleanCheck` would have to be explicitly so. Apologies for the noise. :-]
&gt; Apologies for the noise. :-] Totally fine, I'm very new at this section of the language so I'm quite happy to be corrected or be given more context.
I'm not sure why I got the dialog but you didn't. This feature area's under development now. I'll mention to some folks that this happened. Thanks for the heads up!
My impression is that he was complianing about the mixed camel + snake case style. You could use the standard `mk_*` style (like `mk_shared`, `mk_unique`, etc.), and turn it into `mk_static_constructor`. You could abbreviate it even further, IMO: `mk_static_ctor`. You could also simply remove the underscore and make the style more consistent: `makeStaticConstructor`.
We're not in 2010 anymore. There was a huge effort to modularize kdelibs to make applications depend less on a full KDE environment which culminated in the creation of the [KDE Frameworks](https://community.kde.org/Frameworks). They were separated into several different tiers: Tier 1 libraries depend solely on C++, CMake*, and Qt; Tier 2 libraries depend on that plus other Tier 1 libraries, and so on. Even though all frameworks are released together once a month, they're not coupled, which means you don't need to depend on all of them to get the functionnality of just one of them: all frameworks were kept small and serve one single well-defined purpose, so they can be easily integrated in any Qt application. I, for example, use one single framework in an application I work with and it only adds ~170KB of overhead in it. So, no, depending on KDE libraries does not mean bringing half of KDE's environment. And it shows: the whole download is just 90MB, just a bit more than Qt Creator (which is 85MB on Windows). Clearly, using the KDE frameworks did not add a huge dependency overhead as you claim. Please, keep the KDE-4-era myths in the KDE 4 era. --- *Maybe qmake is also supported, but I'm not sure.
Not really, if you read the comments, it seems GCC 6.0 sees no difference in the generated code...
Also, set `/sdl` or equivalent. Defense in depth :)
The .suo file might have something to do with whether you see a prompt or not. If you want to explicitly invoke the upgrade, right click on the solution and select "Retarget solution". 
They provide the ability to easily use the libraries with qmake, but they are all built with cmake
Thanks for the confirmation
Qt Creator, CLion (not really "native" since java), few smaller ones.
Unfortunately GDB support is left out in the current version (due to some issues in the way we communicate with GDB under Linux vs. we *would need* to do it under Windows). It's on our TODO to fix that and ship GDB integration in the next installer release.
Wow. That's actually just kinda shit.
Very very cool. Like a preconfigured sane emacs setup haha Okay, last question :) When I run my CMake I'm generally using something like ccmake (on Linux) and cmake-gui (on Windows) to adjust all the build toggles. Is that all visible from KDevelop too?
Howard Hinnant: Everything You Ever Wanted To Know About Move Semantics https://accu.org/content/conf2014/Howard_Hinnant_Accu_2014.pdf
I think such things could be made, yes. The cmake-browser which I made with Qt and the KDE Kate plugin in the video are sharing a Qt-based library. I could imagine someone maintaining that and someone doing similar for java etc.
Almost everyone initializes their engine by a single integer from random generator. Mersenne twister has huge state and almost everybody initializes it with single integer, that gives you only 2^32 different sequences. Correct usage is to gather enough "true" random bits into vector or array and pass this data through seed_seq like interface into mersenne twister constructor. 
Ugh, I fail reading comprehension forever. My brain saw "C(const C&amp;)" and went nuts.
Unfortunately you are not going to find anything in the c++ standard library to help you connect to any database. Since you want to connect to SQL Server, Microsoft recommends you use [odbc](https://msdn.microsoft.com/en-us/library/7wtdsdkh.aspx) which is a pure C API.
We can sidestep the division, which is by far the biggest bottleneck here. The standard libraries love to use division for some reason, but we can go with a more bit-oriented approach, which trades more potential RNG calls by no divisions (beware, ugly hack code below): size_t clz(uint32_t x) { return __builtin_clz(x); } size_t clz(uint64_t x) { return __builtin_clzll(x); } template&lt;typename RandomIt, typename URNG&gt; void shuffle(RandomIt begin, RandomIt end, URNG&amp;&amp; urbg) { using T = std::make_unsigned_t&lt;decltype(end - beg)&gt;; std::independent_bits_engine&lt;std::remove_reference_t&lt;URNG&gt;, sizeof(T) * 8, T&gt; rng{ std::forward&lt;URNG&gt;(urbg) }; auto func = [&amp;rng](T bound) { assert(bound != 0); const T mask = (T(1) &lt;&lt; (sizeof(T) * 8 - clz(bound))) - 1; for(;;) { // On average we loop less than twice here const auto value = mask &amp; rng(); if(value &lt; bound) return value; } }; if(end - begin &lt; 2) return; auto next = beg; for(T i = 2; ++next != end; ++i) { auto offset = func(i); std::iter_swap(next, begin + offset); } } With the author's benchmark, this runs as quickly as `pcg_shuffle`, while generating twice as much random bits; using a native 64-bit generator would be more appropriate here.
It's okay. Your brainpiler had a small bug, but it's fixed now.
Nope! But if you use it from the command line, you can use it from the built in konsole. 
Install an adblocker and you don't have to watch the ads.
It's up now :P
Both qtxreator and kdevelop are based on Qt so I don't see your point.
So how does this relate to undefined behaviour? The problem is that the platform could define behaviour that you could use on that platform. You're just giving examples of when people used undefined behaviour because the platform never defined it.
TIL about "temporary lifetime extension"
I didn't write about [N]RVO here because the scope of these articles is preparing the documentation for a small talk in my company about Efficient Modern C++, where I want to show use-cases for latest C++ where using one of the latest features helps in optimizing the code, making it safer (maybe with drawbacks, as it is, in this case). Nontheless, that's quite a good idea for a followup. Thank you :)
You're too used to work on the string class itself, I suspect :)
I can't see it, why should it break at run time?
To clarify (it‚Äôs my comment), in GCC 6 the difference vanishes when using `uint64_t` throughout. I didn‚Äôt compare stdlibc++‚Äôs `std::shuffle` against Daniel‚Äôs 32 bit `shuffle`.
Do you many this Clang/C2 ? https://blogs.msdn.microsoft.com/vcblog/tag/clang/ Or do you mean this one? http://llvm.org/builds/ 
I use mingw for gcc not visual studio. I tried using clang but bit defender quarantines all files as heuristic. I tried uninstalling it but it failed. Hopefully tomorrow I can enable windows defender but the uninstall failing might be forewarning that it's FUBAR. For now I need to sleep.
Wow, I'll take it!
This is off-topic for our sub; r/cpp_questions or StackOverflow would be better.
Pretty sure we've had this thread before, removing. Message me if I'm wrong.
I am not so sure about dangling reference point you make in number 6 in your blog: &gt;Create on-the-fly and store the result I happened to have answered one similar question on SO http://stackoverflow.com/questions/38226443/const-reference-to-member-of-temporary-object/, but even after reading the standard several times, the wordings used in it still seems very ambiguous. If the wordings as understood are correct, then its probably not a 'dangling' situation due to lifetime extension of the parent object. I am hoping some experts here to clarify that :). 
Change log http://dlib.net/release_notes.html
The "C++ Annotations" is free online and very well written in my opinion. http://www.icce.rug.nl/documents/cplusplus/ 
See the neighboring comment :)
&gt; while in the example I'm receiving a reference Ah, yes, I did not pay enough attention to that. Thanks !
I'm not understanding what problem you were having: the working form you show works as expected, and the broken one doesn't compile, as expected. In what case was it hanging?
Integer divisions on x86 perform proportionally to the divisor's size. So 64-bit divisors are much slower than 32-bit ones, something like 23 cycles on 32-bit versus 35-88 cycles on 64-bit. Avoid integer divisions at all costs.
&gt; What is this process called? I'd generally call it serialization. There are a lot of tools for it around. There are human-readable (ish) formats like XML and JSON and YAML, or binary formats like ProtocolBuffers and Cap'n Proto (there are a lot more that I left off).
Phew, good thing you're not forced to install it!
The thing is, this guy is the blind leading the blind as far as developing in C++.
A Tour of A Tour of C++
This is great, /u/STL! Can you start publishing this sort of list for the compiler as well?
Out of curiosity, how does `default_order_t` break the ABI? Not particularly happy about having to zap it from cppreference again...
Yeah, I want to know this as well. Also marking a feature as "doomed" made me laugh.
I was replying to the &gt; Why using an application that takes half it's native environment of OP 
It's because it's the real user syntax and not something for library implementors or the rare edge case "requires-requires".
I thought it was typelists.
Are you Stephan Lavavej? If so, I must thank you for the Channel 9 STL videos you'd done a long time back. The material presentation was spot on, and I really enjoyed the Algorithmic Complexity bits in particular! Grand job on that. You really must do more tutorial videos - you have excellent pedagogic skills! And oh, I couldn't thank you enough for the MinGW builds on nuwen.net as well!
Fair enough, I was just asking out of curiosity ;). Thanks for taking the time to communicate with users and developers on reddit, twitter, etc.
The case in which it hangs is from my modified version on [this post](https://www.reddit.com/r/cpp/comments/56unqk/optimizing_return_values/d8mtxi2) in which I added C(C&amp;&amp;); and C&amp;&amp; operator. It compiles but when run it just hangs leaving me to have to cleanup by going into command prompt and manually close it as no message shows up.
+10000 :-)))
Hi. I have benchmarked it wrt reckless as well. Take a look at https://github.com/Iyengar111/NanoLog#latency-benchmark-of-guaranteed-logger
Of course they don't want their submissions accepted based on gender, nobody's implying you should do that. But yes, just reaching out would go a long way. Thank you so much for being considerate about this!
my visual studio does not have that option. i cant use clang with visual studio at the moment what do i do
Looks good. Is there a wsy to easily extend it? I need android and ios support.
In my own code, string_view really shines by using it in the core string functions. Things like trim, replace, transform, find, append, endsWith, etc. The stuff you're most likely going to be calling with string literals. Eg if(s.find("&lt;!DOCTYPE&gt;")) s.append("&lt;html&gt;"); You're saving the need to allocate and free string objects here, like const string&amp; would force you to. Even if that string fits into SSO (and most do), that has a lot more cost than a simple string_view class would. (if you're fancy enough with extents, you could even extract the length of the string at compile-time for string literals.) I'm not sure if the C++ standard library will be able to change its const string&amp; parameters to string_view where applicable at this point, but it'd certainly be helpful if they could.
Edit: Ignore my comment for the most part. After finishing reading the article i'm very excited for the rest of series, and I was being too nit-picky. I'm looking forward to reading the whole series, but just half-way through the first post and there's a lot of strong statements that are not quite factually incorrect, but misleading without intimate knowledge of the topics at hand. &gt; "and all method calls to be looked up in a hash table‚Äîhardly speedy" This is a very relative statement. It is NOT wrong, but "hardly speedy" needs context here. Hash-table look ups are by far faster than linear lookups, and (here I assume what the author meant) a lot slower than knowing immediately where the function is without a lookup. &gt; "Although we use caches to speed this up, we can have a very strong connection between the memory usage of our program, and how slow it is. Slower code usually means greater power usage to do the same computation, which means software that runs devices hotter and drives down battery life tremendously." This paragraph as a whole is *not* wrong. However, it seems that the author is implying that main memory utilization is the main cause behind slower code. This is true by itself; memory lookups *are* slower than pure CPU computations, e.g. while(1) 1++; However, there are a lot of reasons that a program can be slow, even if all of the data is hosted entirely in the L1 cache the entire life of the program. After all, the author mentions today's bigger computers, I can only assume he means today's latest technology, which has ever-expanding cache sizes. Then the author talks about slower code usually meaning greater power usage to do the same computation. I'm not even sure that this is correct however. I could easily intentionally slow down my code with, for example, calls to sleep(), and it will not necessarily use more power than a program without these calls. It in fact will, but that is due to the number and types of instructions, not that the code itself is inherently slow. Slow code does not mean more power usage; inefficient code means more power usage. The summary comments at the end of the above quoted paragraph are hyperbole for dramatic effect. Don't get me wrong, I'm glad the link was shared, and I do intend to read it all. Additionally, the author *does* appear knowledgeable. I just wish people would stray away from hyperbole and hand-waving in order to be dramatic. Your writing can stand on its own without grand, slightly misleading and generally imprecise summaries. Perhaps this article was written for an audience that would know enough about the topics at hand to know what the author meant, and if that's the case then I apologize for being a grouch. 
I do understand that developers want performance, but can someone please explain to me why there are so many logging libraries and why they are particular obsessed with low latency and performance - what is the (typical) use case for these logging libraries? 
What are these the coroutines they are talking about? I can't catch the name.
Hi, one use case is in electronic trading systems used in prop trading and banks. Logging is needed but should not be a significant time consumer relative to the logic of the trading system. For example, if the algorithm to split orders across exchanges takes 10 microseconds, a logger taking 5 microseconds to log the order details may be deemed slow.
If this is the same then it's already fixed ( still to be deployed ) https://connect.microsoft.com/VisualStudio/feedback/details/2563889/compile-error-c2996-recursive-function-template-definition-is-emitted-for-supposedly-compilable-code
Curious, what are its advantages over `std::bitset`?
I really liked this article. As a non-advanced user of C++, can you explain how exactly all this is zero overhead? You mean everything is done at compile time and thus there is zero runtime overhead? Also, why not throw an exception during an overflow/underflow? (lines 176-208 of integer.hpp) Thanks!
&gt;I really liked this article. Thanks. &gt; As a non-advanced user of C++, can you explain how exactly all this is zero overhead? You mean everything is done at compile time and thus there is zero runtime overhead? No, it's just something the compiler can optimize away. &gt;Also, why not throw an exception during an overflow/underflow? (lines 176-208 of integer.hpp) Because exception would give it a well-defined behavior, which it should not. Over/underflow is *undefined* behavior, so the compiler can assume it does not happen and optimize away. There is just a debug assertion for convenience to the user. 
Really interesting work. Have you done any benchmarking to see if things like UB for unsigned over/underflow makes a significant impact in any existing codebases? 
No, I have not. People listed the lack of UB under/overflow as disadvantage of `unsigned` and I wnated to improve it, so I've tried to make it possib;e.
&gt; It is harder to use incorrectly because you can easily call the function without thinking too much, but you cannot easily access the value of the function without thinking too much. I see your point and to an extent I agree but OTOH, "without thinking too much" is exactly the reason it is called `back()` and not `back_if_not_empty_else_GTFO()`. At some point, the burden must be put on the caller to do reasonable things at reasonable times. The suggestion that this change would actually eliminate bugs seems like wishful thinking to me -- developers will just rationalize it as "well, that will never happen here so..." and just write the same code they would've written anyway.
Have you read the previous post? I outlined it in more detail there. If it returns an optional and I forgot, the compiler would remind me if I use it as value directly. Of course, if I then just go on and call `value()` it doesn't help. But I still think it would be an API improvement, but definitely not usable everywhere.
&gt; if I then just go on and call value() it doesn't help This is what I'm arguing -- it won't prevent them from writing incorrect code, it will just make the code slightly uglier. 
Very nice!
Which reference book would you recommend? 
You mean the anniversary of the day he passed away?
The fix for this issue shipped in Visual Studio 2015 Update 3.
&gt; The stuff you're most likely going to be calling with string literals. Eg if(s.find("&lt;!DOCTYPE&gt;")) s.append("&lt;html&gt;"); Just do `const string g_doctype = "&lt;!DOCTYPE&gt;";` and then `s.find(g_doctype)`, and then no ABI break is necessary like would be to switch an existing `const string&amp;` API to `string_view`. &gt;Even if that string fits into SSO (and most do), that has a lot more cost than a simple string_view class would. [citation-needed] If it fits in "small" mode it should be much easier for the compiler to analyze, since it knows the target is a sized built-in array. With string_view the compiler sees a pointer that could point anywhere. &gt;I'm not sure if the C++ standard library will be able to change its const string&amp; parameters to string_view where applicable at this point We can't do that because it would break ABI. We can add overloads where they would be unambiguous though, as was done for `basic_string::find`, for example.
&gt; use references instead of pointers, pay attention to implicit conversions. So? that's important. Doesn't matter how much it is repeated. &gt; There are cases where you have to use pointers because you don't know if the data exists yet, or was created correctly, and in those cases, it is absolutely appropriate to use pointers and null pointer guards. That has nothing to do with the design of the function. If the function must not be passed with a nullptr you might as well use a reference. If you have a pointer that *might* be null, that is the callers responisibility to handle that. On the other hand if you have a function that can handle a nullptr, you wouldn't consider creating a reference. &gt; you don't like it when the language tries to handle brittleness in a pretty elegant way ( with implicit conversions ). I have nothing against implicit conversion, my types are implicitly convertible as well. I have something against *dangerous* implicit conversions. You must not be able to silently convert a long long to a short, yet you can. You must not be able to silently convert -1 to an unsigned, yet you can.
Looks great. I'll try out your boolean type. I really hate that C++ implicitly converts between bool and integral types.
It is absolutely *not* a disadvantage of `unsigned`. I love everything about this post, except this decision.
I just discovered this technique a few days ago. It allowed me to write some generic math code where an argument was either present or not (in which case it was empty struct). Cool stuff.
I don't really agree with what you've done with the unsigned type here. In deploy mode, `--` is not checked. This means that the reality is that when your real code is running, your unsigned type can get silently corrupted. Of course, this is contagious. The set of natural numbers is not closed under subtraction. That means that there can never be a performance conscious, safe type representing natural numbers that supports `--` and `-=`.
Having typedefs in tags can be useful; `true_type` and `false_type` are the best examples. They allow you to "smash" a derived tag to its uppermost base. There is an important difference between the tag dispatch and SFINAE disambiguation for vector's constructors - tag dispatch doesn't properly respect explicit constructors, while SFINAE does. (This is what caused `vector&lt;vector&lt;int&gt;&gt; v(11, 22);` to stop compiling in C++11, and rightfully so.) This article should talk about tag inheritance, passing by value, and slicing (which is fine and good for tags). It should also probably talk about iterator tags and how overload resolution works to provide logical AND semantics, which is pretty cool (overloading (InIt, InIt) versus (RanIt, RanIt) does what you want).
So far you've claimed zero overhead with zero proof to back that up. Can you show us the assembly to prove that it has zero overhead?
There was a link in the blog post that shows the assembly code for a decrement on an unsigned value.
I like Accelerated C++. Short, sweet, to the point
I tried to solve some of those issues as well : [FlaggedT](https://github.com/I3ck/FlaggedT)
If you're saying you agree, then what are you arguing with?
One way to work-around this problem is to semantically interpret `unsigned` as N/2^n-1 N and `int` as Z/2^n-1 Z and expect your your program to behave accordingly. This is not easy to do in C++, as it will not do the necessary mathematical checks, but you as a human understand math. If you receive n,m in `int` and use (n+m) then you should also consider the case (n+m)&lt;n or (n+m)&lt;m. If your application will explode in case n+m overflows then you should check whether it does; but if everything still works even after n+m overflows (suppose an `unsigned` represents rotatation from 0 to 2pi radians, so UINT_MAX+1 is still a valid rotation) then you're good. The key is to know the invariants. 1/0 can be solved two ways. You could make `operator / (ts::int, ts::int)` to return `optional&lt;float&gt;` so that 1/0 returns some `UNDEFINED` value. Secondly, you could make `ts::float operator / (ts::int, ts::int_star)` so that rhs of operator / is a member of multiplicative group Z* = Z-{0}. Well, this is more complex solution because then you'd have to find ways to prevent class ts::int_star to attain value 0 and you should ideally do it in compile time and not runtime (otherwise you'd have to check every time operator = is called); of course, there are ways to do this with minimum runtime check.
This looks great, especially the benchmarks. Thanks for sharing!
Did you tried it?
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; using namespace std; int main () { if (minimum = true) hours = 10 return 0; } 
Chandler Carruth said as much in his CppCon talk this year. For example, [this slide](https://youtu.be/yG1OZ69H_-o?t=1994). He was more explicit about having both [here](https://youtu.be/yG1OZ69H_-o?t=2784).
Nice article! I think a lot of people underappreciate the self-documentation aspect which you mentioned. You see dynamic languages like Python where interfaces need 20 line docstrings, and then you see languages like Haskell where a function's type signature can be enough to document its entire behaviour. I think efforts like these are a great step to push C++ towards the latter ideal.
One question: What is your rationale for having your integer type not be default-constructible to 0? To me, it makes sense to not have a default constructor given that containers play nicely with such types and that we have things like `std::optional`. However, I'm all for a default constructor when there's a natural default, and 0 is a pretty natural default for an integer IMO. Now one could argue that 1 is the proper default in many cases (in particular, the monoid of integers over multiplication), but I see 0 as universal enough to be completely expected and unsurprising. Edit: Now that I think about it, there is a conflict with traditional C integer defaults and every other integer default.
Nullptr and zero are not the same thing. They are distinct types. On such platforms as mentioned, if the compiler sees you dereferencing nullptr, it knows there's UB. If the compiler sees you dereferencing a pointer that you explicitly set to zero, it's going to dereference zero and it's up to you to ensure that's a valid address. Three things to note: 1) The compiler can often tell nullptr apart from zero even if nullptr is represented with zero. If it can see both the setting of the pointer to nullptr and the dereferencing of the pointer in the same context, then it obviously already knows the pointer is nullptr. If the compiler can't see the setting of the pointer to nullptr (because it was done in a different function in a different compilation unit, for example), it just sees that the pointer contains zero, so if it wants to it can just attempt to dereference the pointer anyway because it's UB so who cares. The program will segfault on a PC, and it will happily dereference the address 0 on platforms that allow it. 2) The compiler is allowed to represent nullptr with a value other than zero. It can use 0xFFFFFFFF instead if it thinks dereferencing zero is common on the platform it compiles for. 3) If a compiler sees you dereferencing a pointer, it can just assume it's not nullptr!
The `co_await` proposal is one of the worst that's ever been made to the C++ standards committee. The only reason it's being seriously considered is that Microsoft are pushing it really hard. It's objectively worse than the resumable expressions proposal, because it's simply not possible to implement the `co_await` proposal efficiently. 
&gt;The Iterator design pattern, as described in the famous Gang of Four book, is undoubtedly one of the book‚Äôs most successful and widely adopted design patterns. What an obnoxious statement. Like almost everything in that book, there's nothing original or special about their 'pattern'. This so-called 'design pattern' that people frequently claim was first created or first popularised by the 1994 Design Patterns book dates from at least 20 years earlier.
I provide typedefs that are either my wrappers or built in ones depending on a macro. This allows to conditonally disable the wrappers. If I had a default constructor, it would change behavior if you use disable the wrapper, so I have not done it.
The author should probably touch on the inconsistencies of `auto`. auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list&lt;int&gt; auto x2 = { 1, 2.0 }; // error: cannot deduce element type auto x3{ 1, 2 }; // error: not a single element auto x4 = { 3 }; // decltype(x4) is std::initializer_list&lt;int&gt; auto x5{ 3 }; // decltype(x5) is int
&gt;The content of your article does matter. You've submitted this post and library to /r/cpp and I hope you are at least open to reasonable criticism. I'm always open to criticism. :) If many people disagree with convincing arguments I write a follow-up post listing those arguments. I have done that a couple of times now. &gt;Okay, so instead of &gt; void foo(int* ptr) { assert(ptr); } &gt;I should use: &gt; void foo(int &amp; ref ) { // Do something } Yes. &gt;If I do this, I get to sprinkle my null checks at each call site. &gt; if( ptr ) { int &amp; i = *ptr; foo( i ); } That's a necessary consequence, yes. &gt;What if I don't want my code sprinkled with null guards that wrap the call sites for foo()? Why wouldn't I just make the function take a pointer and use a null pointer guard? If you do that, your original function looked like this: void foo(int* ptr) { if (ptr) // do sth else // do sth else } Which is totally fine. But in this case there was never a precondition in the first place so no need to use a reference. It's perfectly fine to use pointer then. (Also one could consider using my `optional_ref` there depending on wether you need a pointer or a reference that might be null) 
Would be nice to see a build time benchmark. In my experience using std::function instead of other alternatives _greatly_ increases build times. It's the main reason I don't use it. It's one of the cases where something is so generic that it ends up being bloated. I guess it's more of a problem with templates though.
My library Boost-lite also has a fixed latency fast logger called ringbuffer_log: https://github.com/ned14/boost-lite/blob/master/include/ringbuffer_log.hpp. About 1.3 microseconds without stack backtracing, about 33 microseconds with backtrace (Windows). Unlike other loggers, mine never allocates memory at all, it simply wraps over the oldest entries. It's policy driven, so you can choose it to use memory mapped files or other forms of storage. It defaults to a std::array. It's portable, and runs on anything with C++. It's not nanosecond performance, but that's because it's threadsafe, the atomics introduce a big slowdown.
You can use simple static (local, or `constexpr static` at class scope) POD arrays to store (and retrive) results of a type traits for a parameter pack constituents. It allows you to completely avoid the using of `std::variant`/`std::visit`, replacing it with simple index. Except the acquisition of a names of a data members you can use [this approach](http://codereview.stackexchange.com/questions/142804/get-n-th-data-member-of-a-struct) (slightly modified) to get an access to the data members. Though it is not as generic as your approach currently, due to a limited functional of a structured bindings.
Tr√®s int√©ressant, the blog is added to my reading list. Although seeing C++-style comments in assembly was a bit disconcerting. ;)
As mentioned in the slices most of it is generated. So ... Can we get the generator and the source material (probably just a version of `windows.winmd`)? Edit: removed *compiler* before *generated*. Wrong term.
Compile times are certainly an issue for a class of c++ developers. It never bothered me because the compile times were already on the higher side :) (and also it gives me some time to relax in between ;)). But, yes, it could be a concern on large projects and needs to be looked at.
Your comment doesn't make sense to me. How can Windows API be portable?
Between compilers. I.e: building Windows programs with gcc.
Can I just have the Win32 API back please?
This is how the proposed Boost.PFR works, right?
Good idea, I hadn't thought of that. I might add it. I do also want to add string -&gt; member mapping.
I can't find Boost.PFR. Can you give me a link, please.
Discussed as "POD Flat Reflection" a.k.a. PFR on the Boost devel list: https://github.com/apolukhin/magic_get There is a CppCon talk about it too.
I'm a iOS dev mainly, and I got to say it seems to be pretty much a copy paste from Apple's Foundation library. Probably nice for people wanting to do Windows only apps, and from Microsoft a way to provide developers tools to populate their app store.
But this is from the very first paragraph or their documentation: &gt; It allows you to both author and consume Windows Runtime APIs using any standards-compliant C++ compiler.
Isn't this changed in C++17? I heard that it will no more be possible that auto deduces an initializer_list...
This is the proposal: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html If you notice, the example is identical to my own. 
I can only up-vote once but I *promise* I pressed that mouse button SO HARD. 
Interesting, that makes sense. Have you considered trying to get any part of this library into the GSL? It looks like a good fit to me.
&gt; The difference comes with internal_ptr&lt;T&gt;. This holds a pointer to another object within the data structure. It is an internal pointer to another part of the same larger data structure. It is also reference counted, so if there are no root_ptr&lt;T&gt; or internal_ptr&lt;T&gt; objects pointing to a given object then it is immediately destroyed, but even one internal_ptr&lt;T&gt; can be enough to keep an object alive as part of a larger data structure. This sounds awfully similar to the aliasing constructor ([#8 here](http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr)) of `std::shared_ptr`. What difference is there?
Not mine, but here's a fairly complex console-based application: https://github.com/llvm-mirror/clang
LOL. Good one! 
WinRT is a really neat set of APIs that solved a bunch of compat issues and the various versions of win32 as well as. Net. It allows Windows API to be called from c#, c++ and html/Js. A lot of very smart people solved a bunch of really complicated problems and mostly elegant ways. There's a lot to be learned about language design API design and Os APIs by looking at this code
Wow! That's solid advice!
Except it was actually designed in the late 90's and was called COM Runtime, before .NET was born.
An EBNF to BNF convertor: http://www.codeproject.com/Articles/1089463/Convert-EBNF-to-BNF-Using-parsertl-lexertl
Well, most of these features existed prior to C++11 in boost and other libraries. 
I program in postmodern C++, using nothing but self-referential code, obscure references and an overall rejection of logic and standards.
Yes, its great to have them in the standard. And no question, that they should be used preferably today. Doesn't change that these ideas were then over a decade old. With Alexandrescu giving the style its name in his book in 2001.
What is so nightmarish about copying bunch of DLLs to folder with your executable?
I'd be happier with "correctness and readability trumps everything".
*post*modern C++ maybe
I think that all these talks about diversity just further discourage active participation (of experts in the field) because the first thing that is noted is gender/race/etc. and the more people talk about the topic the more annoying and evident it became. If people would just focus on the technical stuff and not on who presents it would a lot easier to take a part in the process.
Do lambdas just return function pointers?
I tend to write *impressionist* C++. It looks great, but not entirely sure it's working as intended.... ;)
Pre-modern C++ for me was DJGPP.... ;)
How does the capture work? It's always confused me. 
I would say that is close enough.
Its an anonymous class, a lambda is a type with call operator. At least when you capture variables/state, otherwise it might be allowed to be a function.
What is the timing, when you put that variable on the stack instead of calling new?
Wow that looks great! I haven't dug in to your repo yet ; what library did you use for visual styling? Is this Windows, Unix?
Fair enough.
This is correct, it creates a class with operator() const.
AFAIR the library uses conversion operator template and linear representation of a tree of tags. It is C++14 approach. Currently there is a partially implemented structured bindings feature in clang++. It allows one to decompose a class into its constituents with following restrictions: all non-static members are public and all the bases are empty.
An article with this title should consider testing the performance differences of *copying* the pointer. That's a real world usage where certain differences would really show.
Right, and at the time it *was* modern. But the language has changed drastically since, and there are now safer and cleaner ways to use it. "Modern" is a moving target. 
I don't think so. [value] is by value and [&amp;value] is by reference. If value was const it will be a const reference, but if it wasn't the only workaround I know about is to actually make a constant reference outside of the lambda and capture that.
I'm not sure why you say it's not possible to implement it efficiently. Have you listened to /u/GorNishanov's CPPCon 2016 cost about what's going on under the hood? It seems like his Clang implementation (v2 of coroutines if you will with v1 being in VS) is optimizing coroutines like crazy. The only valid argument, at least IMO, then for resumable expressions would be the viral vs non-viral claim but I'm not as qualified as Gor to respond to that.
The standard didn't just improve though, it opened up whole new paradigms and made others mostly unnecessary. Modern C++ (using my definition) is code that is designed to take advantage of these paradigms. It does things that would be impossible or stupid under previous versions of the standard. If you use raw pointers outside of special-purpose, self-contained classes, you're not writing modern C++. If you pass in a vector&amp; to a function to hold results instead of just returning a vector, you're not writing modern C++. If you're using new/delete regularly, you're not writing modern C++. If you're prepopulating a vector with a series of calls to push_back... well, you get the idea. The old ways still work, but they're more dangerous and/or laborious. If you're still using them, you can't call your code "modern" (even if you are Andrei Alexandrescu). 
The viral vs. non-viral claim is more important but I get massively downvoted for mentioning it.
Huh. I didn't know there were disagreements on what "modern C++" means. To me it's always meant C++11 and newer, since C++11 marked a major shift in idiomatic C++ with the advent of move semantics, unique_ptr, and all the other stuff. It could even refer to the new policy of regularly revising the language every third year.
This is what I feel as well. C++11 felt like a different beast thanks to lambdas, `unique_` and `shared_ptrs`, rvalue references and a `std::` library to match these changes. 14 and 17 seem like refinements of that theme. Also, not everyone uses boost so you can't say that it's not modern because boost already had the features. They may pioneer it but if you polled all C++11 devs I'd be surprised if more than 1/3 of them used boost.
Build the tool once, then have a bat file for building. &gt; set PATH= ... D:/cpp/tools/b2/bin &gt; b2.exe --build-dir="D:\cpp\libraries\boost_1_58_0\boost-build-gcc-4-8" toolset=gcc --build-type=complete stage Just needs a few tweaks for every version of compilers, but one could easily add that to the script. But I'm not a PowerShell wizard, so I'll do it by hand...
&gt; its clear that you should always use the newest language/library features available to you. Of course. And code written against a modern standard is modern C++. Code that isn't... isn't. &gt; preferring generic code over runtime/concrete code That's a design choice that depends on what you're building. Using generic code where it makes sense to doesn't make your code modern, it just means you know what you're doing. Using templates for anything and everything you can is just the opposite. 
&gt; It's fast &gt; LOG_INFO &lt;&lt; "Sample NanoLog: " &lt;&lt; i; Mine is faster. With this syntax, you are always going to evaluate all of the arguments no matter what. With a syntax that looks like this: LOG_INFO("Sample NanoLog: " &lt;&lt; i); I can - eliminate all log calls of a certain level at **compile time** if I wish to do it. Alternatively - have the macro unfold to something like if (unlikely(Logger::currentLevel &lt; INFO)) { Logger::log() &lt;&lt; "Sample NanoLog: " &lt;&lt; i; } to, again, avoid the argument evaluation. "unlikely" or "likely" can be controlled in compile time according to DEBUG/RELEASE build. 
Thank you! I was also surprised by "it's simply not possible to implement the co_await proposal efficiently.". If /u/holomorphological has any questions about this year CppCon talk: https://www.youtube.com/watch?v=8C8NnE1Dg4A . I will be glad to answer. With regard to viral vs non-viral, I guess, it depends where you are coming from. I used to write async code with callbacks with hand-crafted state machines that looked like this, for example: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio/example/cpp11/echo/async_tcp_echo_server.cpp. With C++ coroutines I can write the same code much simpler with the same or higher efficiency. Similarly, if you used to write code with future-like things with .then, you are getting great simplification and higher efficiency with C++ Coroutines. If, on the other hand, you have a large body of synchronous code that does blocking calls and hope that it can become an efficient asynchronous code with no changes, you might wish for something like [P0073 On unifying the coroutines and resumable functions ](http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0073r2.pdf) proposal. 
It has quite a few users; some people are just more comfortable on the command line. It's useful, quick, and then it gets out of the way.
The rough pattern is "Have a problem, Solve a problem." Once you have some problem, like "it crashes with my input" or "it gives bad output," you suddenly have an interest in something specific and you can narrow down what you are looking at and focus on parser or code generation or something.
.NET and WinRT are certainly related, but the former predates the latter by about a decade. That said, WinRT was definitely developed with full knowledge of .NET and help from their designers. 
Does it compile?
overly explicit scope and namespace use in an attempt to add semantic value to otherwise understandable code. i'm looking at *you* std::
It does not evaluate the arguments. Have a look at the code. The macro will expand so that it will short circuit based on the current runtime log level. So it will just be a if check and the log line parameters never getting evaluated. 
It's reasonable for everyone to GPL their software?
Clang source is actually very well documented. ClangSema is a good place to start if you want to jump into the heart of the compiler. You can also play with the RecursiveASTVistor to learn the AST, which is surprisingly intuitive. There are many examples online, although many are outdated.
I s'pose that's completely possible. I didn't know such a distinction existed. Edit, doesn't CLI imply a user interface? Or is it only commands sent through arguments?
g++ has better standards compliance than MSVC. MSVC has made leaps and bounds in the last couple of years, but still, it's good to not lock yourself into one environment. 
A lambda is an object of unspecified struct type (like a functor from C++03). It doesn't do anything that functors can't do already, just provides considerably easier syntax. Capture is like the struct having member variables of the captured type (whether reference or not) that are initialized by passing the capture-arguments to the constructor. Lambdas with no capture can be converted to a function pointer, because the equivalent functor could make its `operator()` static.
No, but the implicit lambda type's _call operator_ is `const` by default, which means that the capture variables are effectively `const`. One can declare a lambda as `mutable` to have a non-`const` call operator so that captures are effectively non-`const`: `[val](auto const&amp; arg) mutable { val += arg; }`
No library, all custom. Windows, Unix? Both and more. It's portable, runs in XTerm, Cygwin's term, or the new Windows Linux subsystem.
Easier? Well for some yes. You, for example, see a web app as easier. Others spend their time at the command line (/r/commandline !) and are more efficient there. /u/tyrellj is right.
Xcode or CLion
I don't mean easier in terms of using it. I mean in terms of developing it. I think it's objectively easier to make a web app and format the data like the screenshot does. Visuals like that in a CLI app take a loooot of work! It's great that something like this exists for the command line....but the thought of developing this versus an equivalent web app gives me anxiety.
I meant easiness in terms of implementing rather than using. I spend most of my time on the command line / text editor when working so I'm no stranger to people being more comfortable. But...visuals like that in a CLI app take quite a bit of work.
Some of the biggest features of Modern c++ are smart pointers, the auto keyword, move semantics, and lambdas. It's a massive improvement over c++98 in terms of maintenance, ease of writing code, and flexibility. Check out Scott Meyers' "Effective Modern C++" for a great run through of some of the new features
Hey. Where's the C++ connection here? I see "C code" as column header in one of the tables in this article. This doesn't appear to be about C++ (and thus would be off-topic).
&gt; Bjarne himself (!) that you should not use unsigned for everyday use. Too bad `std::size_t` is returned by half the standard library.
Maybe because we get to use gcc extensions on Windows via mingw but Microsoft compiler does not provide any builds for any os other than windows. So in the end their extensions are here to entangle us in cycle of dependency and keep us on Windows platform where gcc just makes us depend on compiler but not a platform.
I didn't claim the Windows API should be portable, I claim that it should be hidden from view so as that libraries allow for writing portable code.
Did you even try googling "qt licensing"?
as_const is trivial to implement, but VS2013 doesn't support generalised lambda capture (i.e. capturing an expression rather than just a variable name). The closest you'd get is: ```auto&amp; cvalue = as_const(value); [&amp;cvalue]{}```
I mean, if I want to statically link I have two choices, GPL or pay for a commercial license. I'm fairly well familiar with their terms. 
According to this chart - https://www.qt.io/licensing-comparison/ GPL is only for the several (obscure?) sub libraries. the rest is LGPL. 
I will be messaging you on [**2016-10-14 17:50:52 UTC**](http://www.wolframalpha.com/input/?i=2016-10-14 17:50:52 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/57bn6z/performance_of_raw_pointers_vs_smart_pointers_in/d8rimwc) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/57bn6z/performance_of_raw_pointers_vs_smart_pointers_in/d8rimwc]%0A%0ARemindMe! 9 Hours ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d8rin7a) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
gcc is just one compiler among many.
Thanks for sharing. :)
New feature: all videos are now in the video section, including channel9!
The term that I know is ‚ÄúText User Interface‚Äù (TUI) in contrast to ‚ÄúCommand Line Interface‚Äù (CLI) on the one hand and ‚ÄúGraphical User Interface‚Äù (GUI) on the other.
It's also worth checking the performance of smart pointers in a multithreaded test. 
[removed]
[removed]