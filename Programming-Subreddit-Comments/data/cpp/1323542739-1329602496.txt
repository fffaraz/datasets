Poco C++ libraries, it does abstract threading, but no inherent parallelism. There are some good constructs for thread pools and tasks etc though. Also see this thread: http://stackoverflow.com/questions/569481/platform-independent-concurrent-programming-libraries-for-c You also want to look at http://www.concurrencykit.org/ 
To do serious game development, you can't rely on the platform's compiler to be up to C++11. Nor can you rely on exceptions and/or rtti (although I removed them from the list anyway).
&gt; The only safe and correct way I remain unconvinced that this is _the only_ safe and correct way to do it, and that `string s(max + 1, '\0'); int len = snprintf(&amp;s[0], ...); ... s.resize(len)` is unsafe. Especially given the way the new standard seems to codify certain string properties common to most existing implementations. &gt; *You shouldn't have to use `snprintf`!* In the ideal world, where all interfaces are C++, yes (though many would shudder at the thought). In the real world both Linux and Windows API are C, most libraries provide C interface, and on Windows you even can't provide C++ interface from a DLL. So my question is valid. Oh, and sstream is absolutely terrible, if anything I would use Boost::Format, but sometimes it's not worth the hassle.
As a general rule of thumb, if you ever find yourself listing a .cpp file in an `#include` then you're doing something very wrong. Header files don't generally contain any code, only declarations of types, macros, function prototypes, etc. So let's say you have a simple project that consists of an implementation of class foo as well as a driver, i.e. something with a `main()` function that instantiates the class and does something with it. You'd have: - foo.h: defines class foo, and #includes any headers necessary to resolve types used in that class. If the class had a `std::string` member, then foo.h should `#include &lt;string&gt;`. - foo.cpp: implementation of the class. This should `#include "foo.h"` as well as any headers needed by the implementation. - main.cpp: implementation of the driver. This should `#include "foo.h"` as well as any headers needed by the driver. If the driver uses std::string, then main.cpp should `#include &lt;string&gt;`. It's perfectly fine to wind up including a header twice, that's what include guards are for. That's it. In your project/makefile/link command you'd list foo.cpp and main.cpp. You don't compile headers, they are only for inclusion. And you never include .cpp files, they're only for compilation. There is a complication when you start using template classes, as they must be included in every compilation unit, they cannot be linked in. This is an exception where you do have to put code in a header that's included. If you want any functions or members inlined, their implementation has to go in a header as well. But you can ignore those cases for now. 
The only thing you need to know is this: `std::string` does not guarantee two-way interoperability with C strings. That fact *alone* makes it unsuitable for what you're trying to do. It may work on the standard library implementation you're using. Hell, it may work on 90% of all standard library implementations. That's still not *working*! &gt; So my question is valid. Your question is about manipulation of C strings. Very few C libraries do string manipulation that you can't just as easily do in C++. &gt; Oh, and sstream is absolutely terrible Please, no. Why do you hold this belief? Is it some irrational drivel about performance? Because if so, you are wrong. If you don't like the sstream API — what is it about it you don't like? Right now it seems like the primary reason why you're doing things wrong is that you don't like to do them right. We can't help you with that. :)
Yeah, but you do know what C++ was originally called, right? It was C with Classes. It might have all that other nice stuff, but it's not like there's really anything special about it.
Does Clang have their own non-standard extensions though? I think they just implement some of GCC's non-standard extensions since their major goal is to be a drop in replacement for GCC. 
&gt; The only thing you need to know is this: `std::string` does not guarantee two-way interoperability with C strings. I don't need two-way interoperability with C strings, whatever that might mean. I need to be able to directly write data to the string's buffer, because there are some C APIs that do that. The new standard seems to guarantee that I'm allowed to do that, provided that I use `&amp;s[0]` to access the underlying buffer. &gt; Your question is about manipulation of C strings. Very few C libraries do string manipulation that you can't just as easily do in C++. No, my question is about working with various C API functions which write character data to user-provided buffer. I definitely do not intend to use `strncat` on C++ strings, if that's what you are thinking. And I feel weird that I even need to argue that yes, there is a lot of C APIs which do that and for which there is no C++ equivalent (for example: Linux, Windows, Oracle Tuxedo). &gt; ease, no. Why do you hold this belief? Is it some irrational drivel about performance? No, it has nothing to do with performance. Write me an equivalent of `printf("%04d: %.3f", x, y);`.
&gt; I don't need two-way interoperability with C strings, whatever that might mean. Please consider what you're saying here. If you don't know what it means, how do you know that's not what you need? :) &gt; The new standard seems to guarantee that I'm allowed to do that, provided that I use `&amp;s[0]` to access the underlying buffer. This is true given *at least one of two criteria*: 1. `std::string` guarantees that its internal representation is zero-terminated. 2. The C API you're using does not expect the input string to be zero-terminated, but takes a separate `length` parameter. The first is, to my knowledge, not true. So for this to work reliably, you need to be absolutely fucking sure that the second holds true. Most C standard library (libc) functions expect zero-terminated strings, and so do most other C libraries. &gt; Write me an equivalent of `printf("%04d: %.3f", x, y);`. Okay: #include &lt;iomanip&gt; using namespace std; cout &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; x &lt;&lt; ": " &lt;&lt; setprecision(3) &lt;&lt; y; Of course, it's not equivalent: My version is type safe and doesn't contain obscure risks of buffer overflow exploits. ;)
&gt; the header files don't get compiled A question about this: is it the task of the compiler to skip files ending with *.h* or i could actually try to compile such files?
How long do you expect it to be before platforms ship with C++11 compilers?
&gt; If you don't know what it means, how do you know that's not what you need? :) I don't need the standard to explicitly allow "two-way interoperability with C strings", that's what I know. &gt; This is true given at least one of two criteria C functions that use the same buffer both as an input and output argument are extremely rare. Zero-termination is an issue only for input arguments, and there I use `.c_str()`. For output arguments zero-termination is not an issue, _even_ if C++11 doesn't require it, which I very much doubt. &gt; Of course, it's not equivalent: My version is type safe and doesn't contain obscure risks of buffer overflow exploits. ;) It is also verbose as hell, doesn't allow one to see the resulting form of the output more or less clearly, and does not allow localisation. There's a reason there are tens if not hundreds of alternative implementations, including Boost::Format (which is also typesafe).
You could and you should.
The task of the compiler is to compile and link every file you (or your IDE) pass to it as an argument. So there's simply no need to pass any header files as arguments. You *could* compile a header file, but you would be using header files incorrectly. E.g. g++ -c *.cpp g++ -o a.out *.o
You are designing your software in a horribly broken way, and I weep for the guy who will one day have to find the obscure bugs caused by your stubbornness. &gt; It is also verbose as hell That was the price of type safety before variadic templates in C++11. With variadic templates, it is almost trivial to write a type safe `printf`-clone. However, Boost.Format is a perfectly fine alternative, as you mention, but your refusal to use superior solutions in spite of ample evidence is, as I said, hard to work with. We're done here.
I am simply saying that what you say is not true: there are no well known C libraries that manipulate C strings and must be called from C++ because nothing else exists.
There is nothing magical about header files. They don't even need to be called ".h"; you can put any kind of C++ code in a bunch of files and treat them however you like. In other words, a "header file" is a just convention, a way to structure code, admittedly a convention so embedded in C/C++ culture that tools often know how to deal with them, and everyone expects programs and libraries to use them. So, back to your questions. Imagine a world where header files don't exist; in other words, a world where `#include` does not exist. Now imagine we have a file called `foo.cpp` that implements the function `foo()`: // foo.cpp void foo(string s) { ... } The function is used within `foo.cpp` and all is well and good, since it's declared in the file and the compiler and linker will be able to find it. Now imagine we work on the program some more and need to use `foo()` in other places outside `foo.cpp`. For example, `bar.cpp` may have this: // bar.cpp void bar() { foo("Hello world"); } This won't work, of course: The compiler, when it's compiling `bar.cpp`, will not have the declaration of `foo()` anywhere, because even though you are compiling both files at the same time, `bar.cpp` is completely isolated from `foo.cpp`. To fix this, we add a declaration. Now `bar.cpp` looks like this: // bar.cpp void foo(string s); void bar() { foo("Hello world"); } Now, when we compile `bar.cpp`, it will compile cleanly because it has the declaration required. So far so good. Any function needed from outside a file can be "imported" by declaring it. This goes for classes and other types of declarations, too. But as you can imagine, this is not a method that scales: What if we have to import dozens of declarations? Even hundreds? What if those declarations change over time — then we have to go back and not only change the original declarations, but also every place where the declaration is redeclared, or "imported". That's why you use header files. It's just a convenient place to share declarations that are needed by more than one module, thereby avoiding having to repeat it all the time. By stashing all your stuff in a header files, you only need to declare the stuff once, and other files can just include the header file. `#include`, in fact, does just that: It inserts the contents of the header file right into the parent file, as if everything was just one file. There's no "module" management logic to `#include` — it works purely at the file level. That's also why you need "include guards" to avoid stuff being included twice, which could cause problems.
You can never tell, that's the problem. There is a version of gcc for the Ps3, but it's always a few versions behind, so it will support some C++11 features, but not all. I haven't checked, but with the X360 compiler being VC++ based, it probably supports the same stuff as its x86 counterpart. On the iPhone, if you use C++ you have to compile with clang, which doesn't yet support [all features](http://clang.llvm.org/cxx_status.html). You can't really presume that any particular features are available on all platforms. So you'll have to find out specifics about what you're know you'll be working on and stick to that limited feature set, or code yourself into a corner when you later decide to support something like the 3DS (that was just an example piece of hardware because Nintendo have historically used CodeWarrior, but it could be any new hardware). 
&gt; You are designing your software in a horribly broken way &gt; but your refusal to use superior solutions in spite of ample evidence Ironically, right now there's exactly zero unrefuted evidence/arguments left behind your conviction that using std::string as a buffer is unsafe. Also, seeing that we finally are at the personal insults stage, I'd like to remark that I at least design real, useful software, rather than fantasising about designing software in a world where you don't need C interop.
Right. Not if you think increased programming productivity with high performance retention is nothing special.
Good call. I don't do game development, so I'm not familiar on the state of the available compilers. 
It's cool and all, but all in all, the syntax is pretty much exactly the same. There may be some new keywords, but it's really the same syntax.
I find throwing an exception an overkill in this case. It would be really nice if operator[] could return a type like Option and Maybe in functional languages. It could be done with boost::variant but its a bit inconvenient to access the value from the variant.
Quite the generalization. The assumption here is that when looking something up in a std::map, not finding that something constitutes an exceptional situation. The piece of code doing the looking-up could be very capable of dealing with a look-up failure, and thus not need to raise an exception.
The exception being thrown on failure in the template is just an example. Of course, anything else more suitable for a particular context could be done here. In this case, I was trying to replicate the future C++0x's std::map.at(), which does throw an exception. As does std::vector.at(). Use of these methods are deliberate enforcement of the pre-condition that the element is in the container. The point of the post was to demonstrate how to wrap up the handling of the element access in a generic way, so that the rest of the code can be succint and clear. 
&gt;You could compile a header file, but you would be using header files incorrectly. Actually, you would be using them correctly (at least for gcc) - such action creates a precompiled header. 
It would be easy enough to write a variant which takes a default value to be returned in case a value isn't found.
This is a helpful and good explanation. That doesn't change the fact that it appears you're writing a program about porn.
The problem with that is that `operator[] const` returns a const reference, which means you need an extra value for every map you make, and this is a problem when your value type is large. And I guarantee that a bunch of code relies on the exact return type of `operator[] const`. I really wish C++ had a standard maybe type that wasn't a pointer.
&gt; Ironically, right now there's exactly zero unrefuted evidence/arguments left behind your conviction that using std::string as a buffer is unsafe. No, you just blindly ignored it. :) `std::string` is not guaranteed to store its internal representation in a C compatible way. Thus, it is unsafe.
&gt; std::string is not guaranteed to store its internal representation in a C compatible way. Thus, it is unsafe. I understand that it's a very complex idea, probably pushing your intellectual capabilities to the edge. It consists of two parts, and you kinda have to keep both in mind simultaneously -- you might even have to stop other distracting activities such as breathing and swallowing saliva while you try to wrap your mind around it: C functions that use the same buffer both as an input and output argument are extremely rare. Zero-termination is an issue only for input arguments, and there I use `.c_str()`. **For output arguments zero-termination is not an issue**, even if C++11 doesn't require it, which I very much doubt.
Dude, just lay it the fuck off. It's not going to work, and plenty of people have explained to you why. Now make a proper solution, many of which have been suggested!
&gt; It's not going to work, and plenty of people have explained to you why. You are doing it wrong. When you want to prove that something is true, you have to repeat it three times personally and in the same comment. Like, "It's not going to work, it's not going to work, it's not going to work".
It sounds like you're describing [boost::optional](http://www.boost.org/doc/libs/1_48_0/libs/optional/doc/html/index.html). boost::optional also has familiar-looking syntax (like a possibly-NULL pointer) and doesn't construct an object in the "no object" scenario.
So nobody has ever wrapped a C library for use in C++?
No, seriously, you can downvote me all you want, but where has anyone explained to me why it's not going to work? You, personally, half-convinced me that there's no requirement for storing the terminating zero in the internal buffer, but as I explained it's irrelevant (and I still am not entirely convinced). Links to other explanations, please?
http://www.reddit.com/r/cpp/comments/n4uvq/c11_stdstringdata_still_not_usable_as_a_buffer/c36a2sy You have to understand the fundamental error you are making: You are making assumptions about the internal representation of `std::string`, that are not guaranteed by the standard. It may work in practice, you may even write code that happens to not rely on a consistent internal state of `std::string`, but some time in the future, or with a different compiler, or when someone has made changes to the code assuming that `std::string` works as expected, or the library you're using is updated with *only slight* changes in requirements, weird bugs *will* crawl up, and you *will* spend hours or days trying to fix your code, when you could have just designed it *right* from the beginning.
&gt; http://www.reddit.com/r/cpp/comments/n4uvq/c11_stdstringdata_still_not_usable_as_a_buffer/c36a2sy &gt; The problem with using a std::string as a buffer is that a std::string keeps track of the length. If the C library function copies a shorter string (putting a null terminator in the middle of the buffer), then the std::string will return an incorrect value for std::string::length() and std::string::size(). This can really screw you up elsewhere. That's not a problem at all. I, of course, resize my string to the size returned by the C function, and that's it. Next argument? &gt; You are making assumptions about the internal representation of std::string, that are not guaranteed by the standard. I've read the relevant parts of the C++03 and C++11 standards, and it seems to me that the latter provides all the necessary guarantees. What am I missing, exactly?
What about my_map.find(value)? With safe iterators dereferencing map::end would be an exception anyway. 
I said "there are no well known C libraries that manipulate C strings and must be called from c++ because nothing else exists". I did not say no one will ever use C++ as a wrapper for C functions. 
I'm only learning C++ myself, but I've found out about those two you've mentioned plus a whole load more in "Effective C++: 55 ways to ....". I would definitely definitely* recommend this book. There are lots of idioms in C++, prefer const ref over copying and pImpl (pointer to implementation), which I see the point of, as it reduces compile time length, but it suprises me that people way the benefit of short compile times over the effort involved and the increased chance of messing up protection (public, protected, private) when using it in conjunction with something which later needs to be inherited from. \* repeated word is intentional
&gt; Very good book, short and to the point. I agree with the first part. Whilst the book is short &lt; 300 pages, it is kind of a book you have to read from cover to cover as it isn't very reference style at all. I would definitely recommend it though. For me, the current book I am reading "Effective C++" is the one that very deliberately, obviously and helpfully shows you the difference between C and C++, at both a technical level and a design level.
&gt; Resource allocation, of course. You never have to release memory, or close a file, manually. The compiler does that for you. More importantly, it means you don't have to keep track of the memory you allocate. Yes you do. Only stack based objects get destructed. So this: auto p = new Object(); which creates an object on the heap creates a memory leak if you don't do: delete p; My problem with your post is that it's fundamentally wrong. In fact, you haven't illustrated a single difference between C and C++. You're application uses stack based variables, and C has automatic management of stack based variables as well, so your app in C++ would look like this: char[] f (const char *a, const char *b) { char[255] ba; char[255] ab; string_concat(ba, b, a); g(); string_concat(ba, b, a); h(); return ab; } int main() { printf(f("Hello ", "World!")); printf("\n"); } This application above has automatic memory management and will not contain a memory leak. It is as safe as your example. 
It is a bit of a stretch to be searching for C++11 idioms this early. At least well accepted idioms that have proven themselves. I'm not sure what level you are at here but do look into the works of Scott Meyers and others that have focused on design patterns and practices that lead to better code. 
stream operator overload for custom types. std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; mc) { os &lt;&lt; mc.my_member &lt;&lt; mc.some_func(); return os; } Make the operator a friend function if you need access to private data. So then my_class mc; std::cout &lt;&lt; mc &lt;&lt; std::endl; And the print container idiom std::vector&lt;my_class&gt; vect(50); //can be any type or container //do stuff with container std::copy(vect.begin(), vect.end(), std::ostream_iterator&lt;my_class&gt;(std::cout, "\n"); Moving away from streams, there is the C++11 shared_ptr idiom Herb Sutter demonstrated in his build talk int i=9; auto int_ptr=std::make_shared(i); //creates a shared pointer to an int Efficient vector filling. std::vector&lt;int&gt; transform_list(const std::list&amp; l) { std::vector&lt;int&gt; vect; vect.reserve(l.size()); std::transform(l.begin(), l.end(), std::back_inserter(vect), myfunc); return vect; } This way you do not assign to an already constructed variable (like you you specified size in the vector constructor) nor are you pushing_back blindly forcing the vector to reallocate because you have reserved the space.
I am familiar with it; I read the first edition a few years ago or so (I've been only learning C++ for more than 10 years and still a beginner :D). I just looked it up and saw it's been updated for C++11 (so I will probably buy it - along with More Effective C++ when I get my next batch of books). Thanks.
&gt; It is a bit of a stretch to be searching for C++11 idioms this early. I figured as much, but I got a surprise recently when I read about copy&amp;swap - which is not that new and which I didn't know about :(. &gt; I'm not sure what level you are at here I have ~ 7 years of using C++ professionally, but I started learning it before the 98 standardization (I was in high-school). I've read both the Effective and More Effective books and they changed the way I wrote C++, but that was a few years ago.
Thanks. I'm already doing some of that. Here's some code I wrote last week: template&lt;typename C, typename T&gt; std::basic_istream&lt;C,T&gt;&amp; operator &gt;&gt; (std::basic_istream&lt;C,T&gt;&amp; input, IdFeaturesPair&amp; value) { input &gt;&gt; value.id; std::copy_n(std::istream_iterator&lt;int&gt;(input), value.features.size(), std::begin(value.features)); return input; } template&lt;typename C, typename T&gt; inline std::basic_istream&lt;C,T&gt;&amp; operator &gt;&gt; (std::basic_istream&lt;C,T&gt;&amp; input, IdIdPair&amp; value) { return input &gt;&gt; value.media &gt;&gt; value.cluster; } template&lt;typename P&gt; std::vector&lt;typename P&gt; LoadPairs(const boost::filesystem::path&amp; filePath) { typedef typename P value_type; typedef std::istream_iterator&lt;value_type&gt; input_iterator; std::vector&lt;value_type&gt; result; result.reserve(1000); std::copy(input_iterator(std::ifstream(filePath.string().c_str())), input_iterator(), std::back_inserter(result)); return std::move(result); } client code: auto clusters = LoadPairs&lt;IdFeaturesPair&gt;("data/clustering/refClusters.txt"); auto ids = LoadPairs&lt;IdIdPair&gt;("data/clustering/refIds.txt"); 
No problem, I'll add some more as I use them
Your style looks good, no detection of Java in C++ or C with classes which is good. all I would say is user typedef more, I personally wouldn't bother with std::basic_istream&lt;C,T&gt; in almost all cases that is just std::istream The reason I would use that is the deeper you dig the more "implementation dependant" things tend to get. I am not certain as to whether the stream implementation using basic_stream is defined by the standard. Also do not forget that in C++11 that an ifstream can take a std::string instead of a const char* so you only need to do std::ifstream(filePath.string())) Although I am fairly sure that boost file system provides it's own very similar streams which still descend from istream so it is kosher. boost::ifstream(filePath);
&gt; Also do not forget that in C++11 that an ifstream can take a std::string instead of a const char* [...] Thanks. The reason I had to write std::basic_istream&lt;C,T&gt; is that my library has to use a C library that works with `char*` and is loaded in a unicode-supporting application that works on wide chars. I even had to write string widening and narrowing functions like: inline std::string narrow(const std::wstring&amp; source); inline std::wstring widen(const std::string&amp; source); 
Fair enough can't argue with that.
&gt;&gt; It is a bit of a stretch to be searching for C++11 idioms this early. &gt;I figured as much, but I got a surprise recently when I read about copy&amp;swap - which is not that new and which I didn't know about :(. Indeed, it's not new by any stretch, and not at all related to C++11. I first learned about it in Exceptional C++, by Herb Sutter. See http://www.gotw.ca and http://www.gotw.ca/gotw/
&gt; delete p; Sure, if you really want to shoot yourself in the foot, you can play around with `delete`, and have memory leaks. However, should you want to program in C++, you'll use smart pointers and proper containers. &gt; so your app in C++ would look like this: Uh... What? In C++, you'll use `string`. &gt; char[] f (const char *a, const char *b) I'm not sure what language that code is written in. I didn't manage to make g++ nor gcc accept it.
I never said there was a well known C library, I said sometimes you have to do it because the world is messy and being able to put that data directly into a std::string saves some headaches. This is hardly a controversial statement.
More C++ Idioms wikibook sounds exactly right. Just be careful not to use everything for the sake of it. Use commonsense idioms for your team, or if it's just your toy project, go nuts and have a laugh when you look back a year later ;)
&gt; Just be careful not to use everything for the sake of it. Yeah ... that's why I was asking for practical/used idioms. I can find lots of idioms for C++, but I wanted to know what other developers found particularly useful or turned into a coding habit. For example, it is a habit for me these days to define `begin(), end(), size()` and `swap()` when I am exposing a sequence of items from a class, so that I can call std::begin/std::end and &lt;algorithm&gt; functions transparently.
The solution provided [here](http://www.reddit.com/r/cpp/comments/n4uvq/c11_stdstringdata_still_not_usable_as_a_buffer/c36b5zl) three days ago will work, with the problems I've been outlining for you in great detail, which ZMeson also explained: &gt; If [...] you know your STL implementation will correctly support the use of std::string in this way, and you're not concerned about portability, ... Really, the fundamental issue is not one of whether it "works", but the fact that it is a complete abuse of the way `std::string` and data encapsulation is expected to work. It will confuse everyone else working on the code, and yourself in 3 months, and there is *no good reason to do it*. That's the point I'm trying to get across. *Why are you even considering this type of hack?* Your initial post hints at performance — well, unless you have the profiling data to indicate that this is indeed a bottleneck in your program, you're *doing it wrong*.
Sorry, I only just noticed your links are to More C++ Idioms as well. Mine was actually just a quick "pity" reply that I dashed off because there were no comments at the time. On the topic of sequences, don't forget `empty()`. I've seen plenty a seasoned C++ professional writing `seq.size() == 0U` where size is O(n)...
- Type-safe enumerations and bitfields. Commonly just some simple Type2Type or Int2Type class with state and arithmetic and bit operations overloaded. - For custom data structures, thin templates and EASTL style allocators (allowing realloc) - Limited and very targeted use of policy classes - Liberal use of boost::noncopyable, and noninstantiable (not in boost) - Tag dispatch instead of specializing function templates - Dependency injection of sensible types. You want to be able to mock out certain objects in a relationship. Don't go crazy and make the underlying map type a template parameter in your application logic
[PIMPL](https://en.wikipedia.org/wiki/Opaque_pointer) is a good one. class PublicClass { struct PrivateClass *d; public: PublicClass(); ~PublicClass(); }; struct PublicClass::PrivateClass { int x; }; PublicClass::PublicClass() { d = new PrivateClass; d-&gt;x = 42; } PublicClass::~PublicClass() { delete d; } This lets you define the private class in the cpp file, and leave the implementation details out of the header. Speeds up compilation. Slows down execution marginally. Very related to RAII.
Read all 102 (and counting) GOTW articles.
I don't see what you are making efficient in your vector example? You still need a list to take elements from which has to be constructed some how.
What is myfunc in your transform_list function?
What's an idiom?
He's pre setting the length of the vector instead of just blindly appending to it. The vector standard can do a bunch of different things for allocation depending on the os/compiler but they would all require creating a new buffer every time your append runs over the current buffers size. Here the vector is the right size initially so no reallocation required. I think with C++11 you can further push the envelop with a move instead of copying it into the vector. However I'm not sure how to do that or if it's implementation specific.
Oh, the lack of portability... Look, I have to explain it again: if you want something to become true, you have to repeat it yourself, three times, in one comment. Repeating it over several comments or linking to other people repeating it won't work. (I hope my sarcasm is not going over your head...) &gt; but the fact that it is a complete abuse of the way std::string and data encapsulation is expected to work. I've read the new standard, and it seems to me that it's exactly the way `std::string` is supposed to work. The standard gives me explicit guarantees regarding the internal layout and the situations when I'm allowed to exploit it directly. Why does it do that, Simonask? If you want to challenge my understanding of the standard, please do, or at least have the decency to repeat "it's unportable" three times in a row, as is tradition. &gt; It will confuse everyone else working on the code, and yourself in 3 months No, it wouldn't. As I said before, I'm not calling `strncat` on string internals, I use this in the wrappers over the C API that I have to work with, it is expected to have non-trivial code there, and I document it. &gt; Your initial post hints at performance — well, unless you have the profiling data to indicate that this is indeed a bottleneck in your program, you're *doing it wrong*. I disagree. The reason is the same as for why I don't bubble-sort even the data about which I'm absolutely sure that it wouldn't contain more than a hundred elements and the function where I do it can't possibly become a performance bottleneck. Premature pessimization is evil. I don't write prematurely pessimized code unless I have a good reason to, and I don't see any good reasons here.
You're wasting my time, as well as your own. The time you have spent defending this really bad idea (interlaced with copious amounts of insults, not atypical for r/programming, unfortunately) could have been spent writing a proper encapsulation for a C-compatible string buffer. I can only pray that I will never have to maintain your code. Go away, please.
QT is a different kettle of fish, it is generally less thorough than the standard and frequently likes to shallow copy. In this case the c string will be valid until the ";" but as I said, there is not point, because you can do boost::ifstream(filePath); the boost iftream descends from ifstream (more or less) so should work in all the same functions. 
temporaries used like that should have their lifetime extended to the end of the statement - ie there isn't (and shouldn't have been) a problem with either piece of code. EDIT: as long as the function doesn't squirrel away the pointer for later use...
Yes this is bang on, the code around the example is mearly windows dressing as an example of when one might using it (IE a sequence operation of known length). I do not believe that the std::back_inserter is clever enough to "move" items out of the list but if you don't mind hand coding it push_back can take an R-value (&amp;&amp;). Final in C++11 contain have emplace_back. so if you had a constructor like: myclass(int x, int y, std::string s); //ctor then you can do this. int i=9; myvect.emplace_back(i,6,"hello"); or whatever.
&gt; could have been spent writing a proper encapsulation for a C-compatible string buffer. Now this is just stupid (sorry for the insult!) I want to get an std::string. I don't want a custom std::string replacement which gives me more guarantees (which? You are remarkably elusive about concrete details, sorry for the insult!). So, if we agree that replacing all strings in my application with a custom class is not good, then at some point I'd have to convert the hypothetical custom string to a proper string, which would involve copying the data, which is what I want to avoid in the first place. Sorry for the insult, but that's a totally stupid idea, with no merit whatsoever, sorry for saying it like it is!
purely an example it could be a lambda, function pointer, std::function, functor doesn't matter.
Thanks, is that worse case for all containers? I ask because for most containers it shouldn't be to hard to keeps track of it's size therefore O(1).
Well, ok, if you put it like that.
I agree with spinwizard69 that it's too early to identify C++11 idioms. However, let me show you one I'm experimenting with. Here's the problem: I want to initialize a const variable, but the code to do the initialization is too complex for a single expression (and too simple for me to want to write a function). For example, locking and unlocking a mutex. Right now, I just lose the const and write code like: int some_var; { // a couple lines of code some_var=init_value; }; I'm experimenting with keeping the const and using lambdas for this. The code would look like: const int some_var=[]()-&gt;int { // a couple lines of code return init_value;}(); BTW, I am aware for a gcc extension that handles this case: the '({})' construct. However, my project is cross platform so I can't use it.
With respect to programming, an [idiom](http://en.wikipedia.org/wiki/Programming_idiom) is a commonly used, language-specific pattern used to solve a particular problem, usually one not addressed by the language itself. It's very similar to definitions 2-5 from [here](http://dictionary.reference.com/browse/idiom). For instance, RAII is an idiom used to aid memory management. Another would be a pattern for (more) safely reading data from a file line by line while allowing for good error handling: std::ifstream in(/* file goes here*/); std::string line; while(getline(in, line)) { std::istringstream line_stream(line); // parse data using line_stream }
The window dressing is what confused me. I got the resize but wasn't sure if the rest of it was supposed to matter since if you're copying a list to a vector you've got issues elsewhere if efficiency is your concern.
Even if the container doesn't track of its size, empty() can short-circuit as soon as it encounters one element, so it's always O(1). As for size(), I can't think of a standard container whose implementation is worse than O(n).
One that I'm messing with is the single assignment operator= to handle both lvalues and rvalues: mything&amp; operator=(mything rhs) { swap(*this, rhs); // Assume swap makes no copies. return *this; } The argument is passed by-value. Now, assume that rhs binds to a named object, i.e. mything x; mything y; x = y; Since we're making a copy of y in the assignment operation anyways, we're not losing any efficiency by taking it in by-value (we are doing the copy in the call, essentially.) Now what about the case where we assign from a temporary? mything make_thing(); mything x; x = make_thing(); Here the variable rhs would have been created through mything's move constructor (if we defined one) and since we don't do any more copying inside the actual function body, we create no overhead. So long story short, I think this is the most efficient way of defining assignment operators for custom objects. It's basically the copy/swap idiom without the explicit copy (the copy is done, if needed, when constructing the arguments to the function.) EDIT: I guess this is already pretty well-known. Either way, it's how I define assignment operations for all of my custom types.
what's the error?
What problem are you having?
And the for loops should be &lt; not &gt;= since the arrays go from 0-19 and why do you have a for loop when you are incrementing the loopcount in your function? edit: And why are you checking the value of numberArr[loopCount] before you set it in the while?
I assumed I needed the for loop as otherwise it has no method of counting how many times it has gone through the function to read the input? second part, where am I checking the value of numberArr[loopCount]?
You can accomplish the same thing with the while loop like so: while(loopCount&lt;MAX_SIZE &amp;&amp; numberArr[loopCount]&gt;=0) but you probably want to reverse it with a do while instead since you want to get a value before you check it. You can also accomplish it with just a for loop. After you get the number check to see if it's negative and if it is, do a break; if (numberArr[loopCount]&lt;0) break; in either case, if you're looping within the function, don't loop when calling the function.
I've now fixed the while loop by making it a do while, i've also fixed the loop conditionals. still receiving the error, one unresolved external.
You should be more specific about what error you are having when seeking help. Without pasting and compiling this though I can see a few problems- 1.) You forgot to put a # before your include 2.) arrPrint is expecting you to return a value. 3.) arrPrint isn't even called 4.) loopcount starts at 0, so it will never be greater than MAX_SIZE Also, please repost your code at [pastebin](http://pastebin.com/) so the formatting doesn't get mutilated.
Yea I'm not totally clear on how the back_inserter works, it seems to be a fancy append behavior for working with standard objects and myfunc would just be a standin for the operator function required by transform. It seems like if your dealing with a 0x/11 friendly compiler this may not be necessary (based on [this.](http://stackoverflow.com/questions/6211575/proper-way-move-semantics-to-return-a-stdvector-from-function-calling-in-c))
I think a connected directed graph which only holds the root node would be O(n log n), since it'd have to not only go through the graph while also checking that it hasn't visited each node before.
I don't know about idiom, this seems like an intended application of lambdas.
&gt;For example, it is a habit for me these days to define begin(), end(), size() and swap() when I am exposing a sequence of items from a class, so that I can call std::begin/std::end and &lt;algorithm&gt; functions transparently. I always feel dirty when I do that, Is it considered a good practice?
It is: Not only does anyone reading your code realise immediately what they do, but big parts of `std::` and `boost::` are defined with that in mind. For example, you have `std::begin` and `std::end` functions. These functions can be customised for your classes (if you define a custom iteration interface). If your class exposes begin() and end() functions, they will work similar to the standard containers. 
Out of interest is this supposed to be C++ or C. Just there is nothing that says that this is C++ if you meant to be writing C++ I think the following will help you out a bit. Firstly #inculde &lt;stdio.h&gt; should be #include &lt;cstdio&gt; next void main() should be int main() streams are generally preferred over printf (although some disagree) so you would generally use: std::cout &lt;&lt; "Please insert up to 20 numbers for input. negative numbers will indicate you have finished." &lt;&lt; std::endl; and scanf should be: std::cin &gt;&gt; numberArr[loopCount]; Finally gernerally speaking CAPS is reserved for MACROS to highlight how ugly they are. constants generally don't get this treatment (as you would get stick of them with all the const refs you will use). 
Dirty? I feel awesome when making containers and container like stuff!!! I love defining swap, begin, end, cend, cbegin, size, value_type, iterator, const_iterator, iterator_traits, size_type... and I try and get O(whatever) correct where possible. Doing so makes the language work for you, as utnapistim as the std, boost, intel TBB libraries suddenly work with your home spun types.
You use a for loop when you know exactly how many times you need to execute the piece of code; use a while loop when you don't know how many times it will be executed. 
&gt; while(loopCount&lt;MAX_SIZE &amp;&amp; numberArr[loopCount]&gt;=0) This is wrong. numberArr is uninitialized. There are all random values inside. &gt; and why do you have a for loop when you are incrementing the loopcount in your function? This is fine. Because he is passing loopCount by value, so all changes to loopCount in arrFunction won't change loopCount in main.
Your arrFunction declaration have signature of: &gt; int arrFunction (int,int); But your definition of the same function have signature of: &gt; int arrFunction (int, int *); ( "int NumberArr[]" is the same as "int *") The same thing is wrong for the arrPrint function. Then, in for loops: &gt; for (loopCount = 0; loopCount &gt;= MAX_SIZE; loopCount++) The first part sets loopCount to 0. MAX_SIZE is already 20. Then C++ checks if the (loopCount &gt;= MAX_SIZE) condition is true. 0 &gt;= 20 is false so C++ won't run your loop at all. That's the same for one in arrPrint function. Next thing: your arrFunction's loop is wrong. Since the function is declared to return integer (that's the int on the start of the line), function must return something always. So if (numberArr[loopCount] &gt; 0) is false, program wont run into loop at all, and C++ will be very confused because he won't know what to return. Another error is that numberArr array is not initialized up to this point. That means it is filled up with random values, and thus numberArr[loopCount] will give you something random at that point. Third error in that function is that even if (numberArr[loopCount] &gt; 0) is true and the program enters the loop, you will exit the loop on the first run because there is return inside. Return is returning from function, no matter where you are now. You can have 20 loops, in function, but return will exit all the loops and return from function. I hope you are aware that your loopCount++ won't change loopCount in main. Only loopCount in arrFunction. function arrPrint seems ok (besides the &gt;= thing). It's good practice to send array as first parameter, and length of array as second, but your code works good anyway. And, lastly, you need to add \n to the end of strings in printf. Otherwise everything will be printed in the same line. \n stands for newline. In the main you have constant MAX_SIZE. This is usually done with marco when possible, because it's better. You initilize loopCount to zero and then set loopCount to zero again in for loop. You have unused variable tempInput. For loop is unnecessary Here is the code that works: #include &lt;stdio.h&gt; // First argument is not int, but int *, // because we are passing array, not single integer // // Second function is void, // that means it doesn't return anything int arrFunction (int *, int); void arrPrint (int *, int); // This is better than const int in many cases #define MAX_SIZE 20 // Main should be declard as int. // It's not a must. But it's good practice. int main () { int numberArr[MAX_SIZE]; // Notice the \n on the end printf ("Please insert up to 20 numbers for input. \ Negative numbers will indicate you have finished.\n"); // No loop is needed because loop is in arrFunction int size = arrFunction (numberArr, MAX_SIZE); arrPrint(numberArr, size); // It's good practice to tell OS // if the program was succesfull. // // 0 means succesfful. // Anything else means some error occured. // // Only use if main is declared to return int. return 0; } // First argument - array, // Second argument - length of array, // Return value -&gt; how many integers user filled into array. int arrFunction (int *arr, int N) { int i = 0; do { // (arr + i) is the same as: &amp;arr[i] scanf ("%d", arr + i); } while (i &lt; N &amp;&amp; arr[i++] &gt;= 0); return i - 1; } // First argument - array. // Second argument - length of array. void arrPrint (int *arr, int N) { for (int i = 0; i &lt; N; i++) printf ("%d\n", arr[i]); } 
yeah, I did say that, twice... &gt; And why are you checking the value of numberArr[loopCount] before you set it in the while? &gt;but you probably want to reverse it with a do while instead since you want to get a value before you check it.
In the future, use [Pastebin](http://pastebin.com/) for sharing your code, so the formatting is maintained.
Upvoting, agree with this completely, if I hadn't learned C before I started working in C++ I would've missed out on a lot. I'd also like to add this link to the mix [programming praxis](http://programmingpraxis.com/). Has some great challenges on it.
Sorry.
&gt; C and assembly C as assembly is a boring and misleading cliché. Undefined behavior and other constructs of the C standard gives the compiler a lot of freedom. Memory accesses, weak typing and modifications expressed in C code are not necessarily valid C and it is easy to break the rules even if you think it should work (strict aliasing etc). When this happens, you're pretty far from assembly.
Ok, starting to get a little sick of all the PVS-Studio marketing.
Games, Music players and Video players are far from simple. They may look and seem simple from the outside, but they are very complicated on the inside. Sorry. Libraries are essentially lumps of code that somebody else wrote and packaged up so that you can call their code from yours. That's all there is to it. Creating a window, or buttons, or anything like that depends an awful lot on the underlying operating system - how you do it in Win32 is different to X11 is different to Mac is different to ..... Something like SDL exists as an abstraction layer so that SDL knows how to do it on all the different systems and you only need to know how to call SDL. You can download and read the SDL code to see exactly how that works if you want - but I warn you it really is complicated in some cases!
[Here](http://lazyfoo.net/SDL_tutorials/index.php) are some SDL tutorials.
Isn't c# better for games/windows and the rest [](/raritywut)
No, you should buy books: 1. Accelerated C++ 2. Effective C++: 55 ways to ... 3. Exceptional C++ I'm currently on 2/3 but this appears to be the only way to get a proper education on C++. As someone who knows C and Java, C++ is a hairy beast and you can't write Java code in it. For example this is wrong: MyObject::MyObject(AnotherObject input) { // object constructor takes another object called input this-&gt;input = input; } That's perfectly acceptable in Java but is not recommended in C++. This is also bad: public class MyCustomString : public std::string { //inheritence public: //additional string functions... private: MoreShit* another_data_item; } That has a memory leak in it ^. There are tons of things you have to be aware of that are different from Java. Java is not just a VM version of C++ with slightly different syntax. It is a whole different world. C# you can learn with online references, C++ you can't.
&gt; So how would a function, for example create a window space to work in, or buttons you could press. That's a framework (reusable code written by someone else). You find someone who has done all the hard work and simply write your apps against their API and link your program to their library. Two frameworks providing this are QT and GTK+ on Linux as well as wxWidgets (Cross Platform) and whatever Microsoft's GUI Framework is called. Try installing an IDE like codelite. It comes with template projects you can use and will also setup the library paths for GUI apps automatically. So you say "New GUI App", hit the play button and see a graphical C++ app. Then you can read the docuementation and modify it...and when it all makes sense, move back out of the IDE if you want to your normal editor.
Really, read Accelerated C++. It's pretty much the only book for beginners in C++. Also, since you come from Java, you'll want to remember that in C++, by default, you manipulate objects, not references. For example, `a=b` means that `a` is now an independent copy of `b`. Another consequence is that you use `new` far less often in C++ than in Java. Last but not least: learn one language first. Don't try to learn C# and C++ at the same time. (In fact, you probably want to learn C# first, since it's far closer to Java than either is to C++.)
Thanks, ill buy the book &amp; use the online resource for now. I'm still just learning about the basics (using of header files..etcetc).
Totally agree, use books, ignore any Java you have learnt multiparadigm languages are a paradigm in their own right. I would also advise not learning c# at the same time as C++ the best way to learn C++ is with books, and the ONLY way to get good at it is with experience, so the more time you can spend with it the better. You should learn when to use what features, IE: inheritance is reserved for run time polymorphism, generics (TMP) for compile time and when possible preferential over inheritance. You should learn when to use the functional style to manipulate data sets with the std algorithms and functional tools. Learn when to use which memory management tools (destructor, unique_ptr, shared_ptr...) (I would also add deriving from std::string will only leak if you try and destroy is as a string, but it is still bad).
How to make fewer errors at the stage of code writing. Part N4. http://www.viva64.com/en/a/0078/
No.
I would not advise learning from that site, it teaches things backwards, dealing with nitty-gritty implementation details (basically the C stuff) before the really meat of the lanaguage. An example of this is it teach you a lot about arrays long before you reach vectors and the STL. My the time you get to the STL stuff you will have already in bad habbits. Same for Partial template specialization, who needs to know that BEFORE learning to use a vector or list. You don't need to know (although it is good to leran) exactly how something is implemented to use it effectively. Furthermore the writer seems very preoccupied with the silly things like the quality of your comments, and using Hungarian notations (which is generally not used in C++ but it is naff). I really would recommend reading a book on modern C++ programming, it is possible to learn just offline but you have to be very discerning and know what is good code and bad before doing so (which is a bit of a catch 22).
I agree about the books. Those are excellent ones. The only thing I have to add about the OP is to not confuse C++ and C# - they are two completely different things. As for your examples, though. And I'm not trying to be pedantic here, just promote discussion. The first one, there's not actually anything wrong with it (although we're missing the class definition). There are things I wouldn't do (such as, depending on how complex `AnotherObject` is, I wouldn't be passing it by value to a ctor, and I'd probably be using an initializer list in a ctor). // input is a member variable, and also a function argument. 'this-&gt;' is not needed // to disambiguate in initializer lists - compiler can figure it out. this-&gt;input will // be a copy of the function parameter. MyObject::MyObject(AnotherObject const &amp;input):input(input) {} The second example - that one's tricky. There's actually no memory leak there per se, but it's one waiting to happen: * You have a pointer as a member variable. That's fine - you can do that. Just remember that it isn't destroyed automatically, as it would be in Java. You need to remember to destroy it on your own in the destructor. In modern days we'd probably use a smart pointer (C++11's `std::shared_ptr&lt;&gt;` or `boost::shared_ptr&lt;&gt;`, maybe, depending on the task at hand - there are other types of smart pointers). * There isn't anything wrong with inheritance. Generally, the `public` inheritance means "is a", while `private` inheritance will usually mean "has a". There is also `protected` inheritence. * `std::string` does not have a virtual destructor. So actually, it *can be* bad to inherit from std::string. The problem lies in the fact that it is possible to manipulate the base class and cause a memory leak if the dtor for the derived class is not called. There are ways around this - it includes a factory function for making `MyCustomString` (and a private ctor accessible only to the factory function), as well as private inheritance. It's generally a bad idea, though. So yes, C++ *is* a tricky beast. If you ask me, the rewards outweigh all of this. Get Accelerated C++. I've only thumbed through it in book stores, but it was *way* better than the crap books I learned from years ago. It teaches you the C++ way of doing things *first*, and really, it isn't as bad or hard or dangerous as some say. Before the STL, people used C++ as "C with classes". That was bad. Nowadays, it's much better.
First, this is a gross oversimplification, but I think it gives the broad perspective, the big picture, you're looking for. Sure there are going to be slight errors by ommission or simplification... --- The code someone else wrote is going to be a combination of code like what you write, and code a bit more bare metal. Eventually, the layers of abstraction will work their way down to an API, a generic interface, provided by the OS that, for example, abstracts the notion of a video card. This code interacts with a driver, which is code written probably in C and assembly, and compiled into binary, specific for that piece of hardware and whatever microprocessors reside on the hardware. Code like the windowing API, where you have widgets and buttons and dialogs, will use code to generate color values and patterns, colors like gray and patterns like a button, that are written to video buffers, just large arrays of memory. This will be in a specific format the video hardware and/or driver will understand and know how to communicate through the physical interface, up the cable, and to the monitor. Vector graphics are really coded instructions that describe how to draw a thing. Another method will use prepared video buffers and copy from source to destination, and composite a video image. Bitmap fonts and many 2D games rely on this technique. 3D games rely on Vertex Buffer Objects, which are arrays of points organized into triangles and volumes. The fixed 3D API will communicate to the driver this set of points, and the driver will do much of the math for drawing projections of 3D objects into a 2D buffer. You will need to study Linear Algebra for game programming to get a better sense of this. Shaders subvert the drivers predefined operations and you can do all this yourself. Old games like Doom did all this right on your CPU back in the Intel 386 days... 3D games have many buffers for colors, textures, special hardware accelerated effects, blur, and more. --- The layers can be written in different languages. Your program, written in FORTRAN, for example, simply has to comply with the calling conventions of the executable binary it is interacting with, a DLL, another process, or the OS, for example. Often, this is built into your compiler for your hardware platform and OS, so you don't have to even think about it. Sometimes, and I've never had to do this personally or professionally, you have to write that communication layer yourself. A little knowledge in assembly probably goes a long way here. --- So, that cout you use to write to the console window? You might not realize it, especially if you're using Visual Studio, but you're linking to a library, either statically, where static libraries are prewritten code that gets folded directly into your program, or dynamically, where that code is loaded into memory at runtime and occupies it's own execution space. That library is a gateway into the OS and/or your windowing system, and thus, your video driver.
First, this is a gross oversimplification, but I think it gives the broad perspective, the big picture, you're looking for. Sure there are going to be slight errors by ommission or simplification... --- The code someone else wrote is going to be a combination of code like what you write, and code a bit more bare metal. Eventually, the layers of abstraction will work their way down to an API, a generic interface, provided by the OS that, for example, abstracts the notion of a video card. This code interacts with a driver, which is code written probably in C and assembly, and compiled into binary, specific for that piece of hardware and whatever microprocessors reside on the hardware. Code like the windowing API, where you have widgets and buttons and dialogs, will use code to generate color values and patterns, colors like gray and patterns like a button, that are written to video buffers, just large arrays of memory. This will be in a specific format the video hardware and/or driver will understand and know how to communicate through the physical interface, up the cable, and to the monitor. Vector graphics are really coded instructions that describe how to draw a thing. Another method will use prepared video buffers and copy from source to destination, and composite a video image. Bitmap fonts and many 2D games rely on this technique. 3D games rely on Vertex Buffer Objects, which are arrays of points organized into triangles and volumes. The fixed 3D API will communicate to the driver this set of points, and the driver will do much of the math for drawing projections of 3D objects into a 2D buffer. You will need to study Linear Algebra for game programming to get a better sense of this. Shaders subvert the drivers predefined operations and you can do all this yourself. Old games like Doom did all this right on your CPU back in the Intel 386 days... 3D games have many buffers for colors, textures, special hardware accelerated effects, blur, and more. --- The layers can be written in different languages. Your program, written in FORTRAN, for example, simply has to comply with the calling conventions of the executable binary it is interacting with, a DLL, another process, or the OS, for example. Often, this is built into your compiler for your hardware platform and OS, so you don't have to even think about it. Sometimes, and I've never had to do this personally or professionally, you have to write that communication layer yourself. A little knowledge in assembly probably goes a long way here. --- So, that cout you use to write to the console window? You might not realize it, especially if you're using Visual Studio, but you're linking to a library, either statically, where static libraries are prewritten code that gets folded directly into your program, or dynamically, where that code is loaded into memory at runtime and occupies it's own execution space. That library is a gateway into the OS and/or your windowing system, and thus, your video driver.
My first example was to promote efficiency. If you didn't use an initialiser list, C++ would construct the object (and all it's children) explicitly for you using a default constructor. Then, when you say `input = input`, you actually use an assignment operator to perform the assignment, so it isn't quite doing what you expect. It's copying from one instantiated object to another. And for the second one, as you clearly are aware, std::string's destructor is not virtual, so you run the risk of freeing only the bottom "half" of the object. I chose those examples, firstly, because that was all that came to mind, and secondly, because they look like the correct thing to do in Java. With C++ and Java's syntax actually quite close, there is certainly a little appeal to skip "what you think you know". I see you know your stuff though!
No.
&gt; Then, when you say input = input, you actually use an assignment operator to perform the assignment, so it isn't quite doing what you expect. It's copying from one instantiated object to another. **EDIT**: Actually, re-reading what you wrote, you're correct - it's already constructed inside the ctor. But that's why I probably wouldn't use a default ctor for the `input` object - compiler would complain. But of course default ctors can be useful. Not actually. :) You may be surprised. As long as there's a copy ctor, it's using that. Consider: $ cat example.cpp &amp;&amp; g++ example.cpp &amp;&amp; echo 'RUNNING:' &amp;&amp; ./a.out #include &lt;iostream&gt; struct S { S(){} S(const S&amp; /*s*/){std::cout &lt;&lt; "copy ctor called" &lt;&lt; std::endl;} S&amp; operator=(const S&amp; /*s*/){std::cout &lt;&lt; "operator= called" &lt;&lt; std::endl;} }; int main(){ S a; std::cout &lt;&lt; "Use of syntatical copy ctor: "; S b(a); std::cout &lt;&lt; "Use of syntatical operator=: "; S c = b; return EXIT_SUCCESS; } RUNNING: Use of syntatical copy ctor: copy ctor called Use of syntatical operator=: copy ctor called 
Adding to that, that's the thing with C++: sometimes there's a "correct" way to do something, and there's also the *right* way to do the same thing. 
No.
The version number isn't really a guaranteed measure of stability and it would be wrong of you to assume that. For example, Gnome Calculator just turned 10 years old, so they bumped the version number to 1.0. All a version number means is that it is a sequel, in spirit at least, to an earlier version of the software.
The word you're looking for is API. The operating system provides APIs for creating windows, buttons, etc. And libraries/frameworks provide APIs on top of those APIs to simplify their use. But API is just a fancy term for a collection of library functions. It could be an explicit library like SDL, or it could be a library provided by the operating system. You're missing the whole point if you dismiss this as "just using some code stored from somewhere else." That is exactly how you do anything. If you took a GUI application and really stepped down the call chain, you might see the application calling into a framework, and then the framework calling a Win32 API function, and that function calling a lower level internal function, which calls a yet-lower level function, until eventually you get to the point where there's some code deep down that draws the individual pixels of a button into a memory buffer and then displays it. This might involve the graphics driver and low level code, and might be buried so far down the call stack that you'll never see it, but it's eventually there.
&gt; For example this is wrong: (...first code example...) If AnotherObject's size is less than/equal to sizeof(void *) and is a cheap-to-copy flat memory structure then this example would be correct if you would use an initializer list. For any bigger/non-trivial object you should use a const reference, but then you don't need the ugly initializer list at all.
Short answer: No. Slightly longer answer: It depends on so many things it is not possible to answer this question with a simple yes or no.
This is a full version of the issue. http://ideone.com/l5mlX #include &lt;iostream&gt; using namespace std; class AnotherObject { public: AnotherObject() { cout &lt;&lt; "Default Constructor Called\n"; } AnotherObject&amp; operator=(const AnotherObject&amp; ao) { cout &lt;&lt; "operator= called\n"; } }; class MyObject { public: MyObject(AnotherObject input) { ao = input; } private: AnotherObject ao; }; int main() { AnotherObject ao1; cout &lt;&lt; "here we go\n"; MyObject mo(ao1); }
I've been actually amazed of how awesome pvs-studio turned out to be. Plus, this was a neat read. It's worth the time to at least look at the tool to get an idea what it is capable of; I typically just went with clang static for dealing with small things, but the tool has definitely shown its merit in the 64-bit realm. Plus, their [64-bit lesson set](http://www.viva64.com/en/l/) is a fun read. I've been using it in the process of porting Doom 3 and it's been seriously awesome. They're really supportive of students, so if you're trying to do a talk at a university in comparing static analyzers (my example) or just want to learn a bit more about their product then send them an email and ask away. There have been a few oddities from time to time, but it's very interesting to see it in action to say the least; I do wish I wasn't a under a VM all the time to use the tool, but the seamless integration with visual studio is pretty nifty. I am currently using clang as my preprocessor and it all seems pretty quick too. As [Carmack said](http://twitter.com/#!/ID_AA_Carmack/status/75763219536429056), you will find bugs. 
Which is why I very rarely have classes with default ctors, especially when it isn't really the norm for the class to be default constructed. :) Also in general, if I need to overload operator= (for any other reason than making it private and undefined to mute a compiler warning, which I'll usually use `boost::noncopyable` for anyway), I generally think again harder about what I'm doing. There's usually a better way to approach it. That's not to say it's not justified under some circumstances. 
I’d say figure out where you can keep applying it. I’d probably still consider myself a beginner in C++—don’t know anything about C++11 and the word “Madagascar” comes to mind when thinking about my total experience—but in so many parts of my life, I’ve noticed that I’ve just got to find that *hook*. To learn guitar, for example, I just had to have that *one* easy but awesome song to fall back on to keep my interest and act as a springboard for further self education. This is probably way more meta than you wanted. Sorry. I’m going to be trying looking at source code for games, or something, myself. Source code seems a good way to go, though I'm hardly one to talk. Though I did find the book *Teach Yourself C++ in 10 Minutes* to be very good. I learn best without excess cruft, and this book is very terse. It has some mistakes, but nothing fatal. It works particularly well for someone who’s already learned C++. That is—it was perfect for me when I was picking the language back up. And then there’s just the general internet. I’ve got a bookmarks folder full of just interesting things I’ve searched out. Like *style guides*, unit testing and documentation tools (I like doxys and UnitTest++, myself), and funny anecdotes. [Full disclosure: I’m the farthest thing from an expert, with no *real world* experience. I'm not really sure why I typed this whole thing.]
If you would really like to advance your knowledge of C++, there are several routes you could take: First of all, for OpenGL, there isn't much out there better than this: [http://www.arcsynthesis.org/gltut/index.html](http://www.arcsynthesis.org/gltut/index.html) Win32 programming is fun; there are loads of interesting tutorials out there. Here are a few: [http://www.flipcode.com/archives/Win32_Window_Skinning.shtml](http://www.flipcode.com/archives/Win32_Window_Skinning.shtml) [http://zetcode.com/tutorials/winapi/](http://zetcode.com/tutorials/winapi/) [http://www.winprog.org/tutorial/](http://www.winprog.org/tutorial/) WinSock is good stuff to learn, too, as it will allow you to code network applications: [http://johnnie.jerrata.com/winsocktutorial/ ](http://johnnie.jerrata.com/winsocktutorial/) To go more cross-platform, you could learn SDL: [http://lazyfoo.net/SDL_tutorials/ ](http://lazyfoo.net/SDL_tutorials/) Also, you could try to go a bit lower-level and learn C and x86 assembly, which would give you a deeper understanding of what your C++ code compiles to. You could also try more ambitious projects, such as writing your own kernel or working on an embedded system. [https://savannah.nongnu.org/projects/pgubook/](https://savannah.nongnu.org/projects/pgubook/) [http://win32assembly.online.fr/download.html](http://win32assembly.online.fr/download.html) [http://viralpatel.net/taj/tutorial/booting.php](http://viralpatel.net/taj/tutorial/booting.php)
Keep programming things, and don't stop. The best way to master programming is to keep at it for a very long time. Think of interesting problems you want to solve, and solve them. These problems may be games. If you have a cool idea for a game, try implementing it. You will run into a lot of problems you never knew existed, and you will find solutions to them. You can then continue finding and solving more problems forever. 
Check (and probably improve) your understanding of the language: http://www.gotw.ca/gotw/
There's a [video series](http://www.corensic.com/Learn/Resources/ConcurrencyTutorialPartOne.aspx) for C++11 concurrency that I have enjoyed as well.
Absolutely, GotW is a great resource, you know it is good, when it was written in the 90 and still valid today.
Then again, between 1998 and 2011, nothing had changed, and while some features were added in 2011, the philosophy of the language didn't change much.
&gt;"What if those declarations change over time — then we have to go back and not only change the original declarations." If declarations are to change, then the usage of the functions will also have to be changed. So, either way we have to go and change all the files where the function is used. Am i right in saying this?
I don't see anything wrong with the code you have posted. You could try to use [boost.lexical_cast](http://www.boost.org/doc/libs/1_48_0/doc/html/boost_lexical_cast.html) example: std::string str = "BlitDraw " + boost::lexical_cast&lt;std::string&gt;(_SpriteID) + " " +....
Which compiler are you using? More importantly, which locale are you using? Try this: ss.imbue (locale("C")); 
I think we're going to have to see more/all code. The bug could be elsewhere. 
That last bit of code seems to have fixed it, thank you.
If you're going to use C++ I'd recommend using a vector instead of an array. In that case, you'd do this: std::vector&lt;int&gt; numbers; for(int i=1; i&lt;=100; ++i) numbers.push_back(i); Your program is probably going to run into a bigger problem though. On most systems, an `int` is 32 bits, which means it only goes up to about 2 billion. The number you're trying to factor is about 600 billion. Your compiler probably supports the `long long` type which goes up to 9 quintillion, so use that instead of an `int`.
Here are my suggestions to be taken with a grain of salt. Consider that I'm not a professional C++ programmer at all. Further we are in a transition period where C++11 has become official. The rational advice is to learn the new methods that C++11 affords us, but good sound information and well accepted books are pretty thin right now. Given that here are some suggestions: Normally I recommend Accelerated C++ as a beginners text, however I'm assuming C++101 has covered that. For old C++ I'd recommend getting Scott Meyers series of books if you don't have them now. For C++11 I don't have a recommendation for texts so you will have to resort to the Internet for now. In the end though C++11 is a huge update to C++ so I'd recommend focusing on updating your skills to do things the new way. In the long run you will be far better off. As to coding you need to apply updating your skills to something you are interested in. If you have personal interest in a project it is far more likely that you will put in the effort to write good code to support that project. Get involved in LLVM, CLang and friends.. Why? Well for a couple of reasons, one is that it is a large dynamic code base that is open to study. Second everybody and their brother seems to be adopting at least parts of this system of tools. Third they have a nice static analyzer. Even if you aren't interested in compiler technology, the projects code base is rather modern. Maybe there is a forth in that CLang generates some nice diagnostic messages when you bork your code. Look for a public project to get involved it that has someone willing to mentor you. How well this will work varies as styles may clash but it is a potential good play. Follow this forum and others to review C++11 postings and links to tutorial. I can't promise that they are all good code or demonstrate a deep understanding of C++11 but they will expose you to lots of variety in applications and implementations. Understand that what is accepted as good practice with respect to C++11 feature will likely evolve a bit over the coming year. The good thing here is the comments sections in the blogs, sometimes as much is learned from the comments section as anywhere else. Get outside and hike a bit or skinny dip to clear ones mind. There is more to life than coding. 
Yes. It's basically just more work if you don't collect the declarations into header files. As I said, a header file is mostly a convenience. The breakage will be easier to understand and remedy — let's say I have a library, and I change `void foo(string)` into `void foo(string, int)`. If I use header files, then any client apps that use my library will get a warning about the function expecting two arguments, not one. But if the client code doesn't use header files, but declares `void foo(string)` in its own code, then all its code will *compile* — it just won't *link*, because the function `void foo(string)` will not exist anywhere. That's bad.
You need to check up to half the number minus one. *Edit:* Corrected below. Thank you!
Correction: [sqrt(n)](http://en.wikipedia.org/wiki/Primality_test#Naive_methods)
No, Gabbriel had it right the first time; the problem is to find the largest prime factor, not to find whether or not the number is prime. Counterexample: 52 = 2^2 x 13, where stopping before sqrt(52) would only check divisibility by up to 7. schwanstabilo will probably want to carefully reconsider the possibility of getting rid of the array completely. My approach would be from the other end. I'd actually generate the prime factorization, just keeping track of the largest factor, which uses a lot less storage. Or at least that's what I would start out to do; I'm sure that details would change as I tinkered. In the end, of course, be sure to test your code on some small inputs for which you know the answer. 13, 49, 64 and 100 cover a few different possible code paths. 
Oops, should have read the problem more carefully! Turns out gabbriel and I were both wrong, since you could have n = 2*&lt;large prime&gt;.
Or divide by each prime as you find it.
Incidentally, Herb Sutter is updating GotW for the C++11 era: http://herbsutter.com/category/c/gotw/
Unrelated to the C++ side, but, if you are going to be working through Project Euler, i would recommend learning some prime number sieves. They can really help speed up computation.
Looks like some useful suggestions in this SO thread: http://stackoverflow.com/questions/4557356/tips-on-reducing-c-linking-time
Still not really what I'm looking for. I'd like to be able to analyze output from the linker and figure out what's causing the long link times so that I can focus on those issues. Right now I'm fumbling in the dark...
You could try profiling the linker when running it on your project, and if you're using `ld` you may want to look at the output with `--trace` turned on to get a better idea of what it's doing. I don't see any more verbose debugging flags, though. 
Which platform? How long, for how many MB linker input / output? Debug or Release? Incremental or Full? I've never had excessive link times for incremental links in debug builds. Release builds with full link could be better, but they normally aren't needed so often. [VS team blog has a so-so article on linker throughput](http://blogs.msdn.com/b/vcblog/archive/2009/09/10/linker-throughput.aspx). Link time code generation and profile-guided optimizations significantly increase link times. Beyond disabling these and throwing in decent hardware I haven't found anyhting reasonable for improving link times. 
If you're using the GNU toolchain, check out the new linker (gold). It's a heck of a lot faster than the traditional linker (ld). Even if you can't use gold, make sure you're using the latest version of ld, as they are constantly making improvements to link time. (E.g. better string hashing/comparison, which I believe is one of the main hot spots in the linker.) Also, you might look into using relocatable objects (ld -r) also known as partial linking. This is a way of combining object files, but not like static archives which is still a collection of separate object files. This resolves any symbols between the two, while leaving the rest still undefined. It's a way of doing the link in parts instead of all at once. 
I've observed that in big projects, link time is mostly IO bound. I've had success with setting the linker temp directory to a memory filesystem.
I'll try that approach tomorrow.
In my experience, indiscriminate use of templates is most often at the root of long link times. Templates get instantiated for every compilation unit, and it's the linker's job to eliminate duplicate instantiations — this is not in itself particularly costly, but the extra I/O caused by bloated object files can be. One way to measure the unnecessary overhead is to take the sum of the size of the `.o` files and subtract the size of the resulting linked binary (dynamic library or executable) — the result is the amount of code eliminated by the linker, in bytes. If this amount is disproportionately big, you may want to look at some tricks for eliminating template instantiations. If you're using C++11, you can use the [Extern Template](http://en.wikipedia.org/wiki/C%2B%2B11#Extern_template) mechanism with frequently instantiated templates to dramatically reduce the number of duplicate instantiations (and compile time in general) — at the loss of inline optimizations, unless you use Whole Program Optimization (which generally increases link time more than it reduces compilation time, while also generating faster code). If you're not using C++11, you can analyze your code and see if there are lots of redundant instantiations (for instance, you may choose to conflate uses of `std::vector&lt;char&gt;` and `std::vector&lt;unsigned char&gt;`, or uses of `std::vector&lt;Foo&gt;` and `std::deque&lt;Foo&gt;`, depending on use case). EDIT: berium's correction.
Windows, debug, full. I guess we just have to wait until computers are faster.:/
Put all of your code in one big function, with liberal use of `goto`. 
Unity Build: you can try making a all.cpp file that #includes all of your other .cpp files, this can be annoying to maintain, but it leads to massive speedups of both compilation and link times (compilation from only including any given header once instead of however many times and linking because there's nothing to link except external dependencies). I can't find the article I first remember reading about it in that had really in depth benchmarks and showed improvements in compilation/link time going from just short of 10 minutes to less than a minute using this method.
&gt; One way to measure the unnecessary overhead is to take the sum of the size of the .o files and subtract the size of the resulting statically linked binary (.a) — the result is the amount of code eliminated by the linker, in bytes. Static library (.a) is just an archive containing all the object files. You need to either use the executable size minus object file sizes or shared library (.so) minus object files.
I would suggest that you take a look at http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes make a prime list up to what ever you're comfortable with. (up to a few million should be very fast). Then write yourself a prime factorization function (for each prime, does it divide perfectly? if so divide the number and keep looping (http://www.mathsisfun.com/prime-factorization.html)) Good luck!
You are, of course, completely right. My mistake. `.a` files will not suffice, but the same approach with the resulting binary should give a decent idea, depending on the number of statically linked system libraries.
The line quotient /= current; should be replaced with while(quotient % current == 0) { quotient /= current; } Otherwise, for example, the prime factors of 27 would be computed as [3,9]
The line "w6 = w5 &amp;&amp; (w4 || w5));" has an extra parenthesis. Also, it usually helps when asking for help to include the full program, #include iostream, typedef wire_type, etc, so people can just compile and see errors for themselves. Lastly, style notes - why use a struct and specify public access for everything? I always like to reserve structs for C-style POD, just to differentiate (maybe personal preference). Also, the operators || and &amp;&amp; traditionally return a bool. Overloading them in this way works, but can be very confusing to programmers reading your code later on. Roguewave had a DB library that was used in some software I was working on. It took me a bit to understand why "AddToQuery(Clause1 == Clause2)" because AddToQuery didn't take a bool. Turns out they overloaded the comparison operator to return a Clause. 
That's a good point too, but VC++ 2008 express seems oddly okay with this error...hmm. I'm a bit confused why this is - anyone have an explanation? The copy constructor is being called at the end of operator||, but that's the only new object being created (for the temporary) before operator&amp;&amp;(wire&lt;sig_type&gt; &amp;).
thank you, I am making the appropriate adjustments
yes after I changed it to 'const', I received this error: error: passing ‘const wire&lt;bool&gt;’ as ‘this’ argument of ‘sig_type wire&lt;sig_type&gt;::operator()() [with sig_type = bool]’ discards qualifiers programs/boost/signals/test5b.cpp: In member function ‘wire&lt;sig_type&gt; wire&lt;sig_type&gt;::operator&amp;&amp;(const wire&lt;sig_type&gt;&amp;) [with sig_type = bool]’: it'd seem to work, because the operator()() gives w() the functionality, but it didn't. strange that it worked on VC++ 2008.
There you go: sig_type operator()() const { return _s; } And why not like this: #include &lt;string&gt; #include &lt;iostream&gt; template&lt;typename sig_type&gt; class wire { public: wire() : _s() {} wire(sig_type s) : _s(s) {} // make it a functor sig_type operator()() const { return _s; } // resets the signal of the wire void operator()(sig_type s) { _s = s; } // Why are you making &amp;&amp;, || and ! non-const functions? // Additionally, doing this means that you can only use your type with sig_types that implement operator&amp;&amp;, ||, ! // as functions that return the type of the same type. That is true for bool only wire&lt;sig_type&gt; operator&amp;&amp;(const wire&lt;sig_type&gt;&amp; w) const { return wire&lt;sig_type&gt;( this-&gt;_s &amp;&amp; w._s ); } wire&lt;sig_type&gt; operator||(const wire&lt;sig_type&gt;&amp; w) const { return wire&lt;sig_type&gt;( this-&gt;_s || w._s ); } wire&lt;sig_type&gt; operator!() const { return wire&lt;sig_type&gt;( !this-&gt;_s ); } private: sig_type _s; }; int main() { wire&lt;bool&gt; w4(true), w5(false), w6; w6 = (w4 || w5); std::cout &lt;&lt; "w6 = (w4 || w5)" &lt;&lt; std::endl; std::cout &lt;&lt; w6() &lt;&lt; std::endl; w6 = !w5; std::cout &lt;&lt; "w6 = !w5" &lt;&lt; std::endl; std::cout &lt;&lt; w6() &lt;&lt; std::endl; w6 = w5 &amp;&amp; (w4 || w5); std::cout &lt;&lt; "w6 = w5 &amp;&amp; (w4 || w5);" &lt;&lt; std::endl; std::cout &lt;&lt; w6() &lt;&lt; std::endl; /* Try this with your solution * wire&lt;std::string&gt; w1("Test"), w2("Test2"); std::cout &lt;&lt; "w1 || w2" &lt;&lt; (w1 || w2)() &lt;&lt; std::endl; */ } 
If you want to just optimize for link time then this is the way to go. Of course that'll make your incremental compile time get worse. There's compromises possible -- splitting into some number of cpp files that include the others is one approach you could take.
I found a fix thanks to your comment. I placed this converter in the class, and then removed the () from the local variable w. I'm still not sure why the first way didn't work, but no matter. // make a converter operator sig_type() const { sig_type s = _s; return s; } 
thanks, that worked perfectly... didn't use **const** in two place where I should have.
Since your doing digital circuit simulation (operating on bits), overloading the bitwise operators &amp;, |, ~, ^ would make more sense semantically than overloading the logical operators, and would avoid some of the problems that would happen if you ever used something other than wire&lt;bool&gt;. Also note there is no logical operator equivalent to the bitwise XOR ^ . While the bitwise ^ works on bool, if you're going to overload one you might as well do them all instead of a mix of logical and one bitwise operator. The bitwise operators also send a clearer message to users of your code who would be right to expect &amp;&amp; to return bool, not wire&lt;T&gt; or T. wire&lt;uint32_t&gt; a(0), b(1); bool c = a &amp;&amp; b; // Normally can write this, but wire&lt;uint32_t&gt; has no conversion to bool. wire&lt;bool&gt; d = a &amp;&amp; b; // Would expect to be equivalent to: wire&lt;bool&gt; d(c); if (a &amp;&amp; b) { ... } // Again, no conversion to bool. Also, as implemented, the operators modify *this, which again violates expectations, a &amp;&amp; b should not have the side-effect of modifying a. [nuzzle](http://www.reddit.com/r/cpp/comments/nilk8/overloading_operator_problem_w_functors/c39epma) provided some nice changes and suggestions. I would just change &amp;&amp; to &amp;, || to |, ! to ~, and add ^. Using the bit-wise operators also makes more sense if you consider some possible extensions of your design to more complicated digital logic...
Remember to use initialization lists instead of assignment in your constructors: http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.6
BTW. mach_override does the same on MacOS and LD_PRELOAD appears to be good enough on Linux.
Thank you for your suggestions. I've incorporated all of them in my code and am now using bitwise operators instead.
Yes, that is far better practice. I see now. Thank you.
thank you, I used some of this but dropped the boolean operators for bitwise operators
Here is a link to code for the Sieve of Eratosthenes (http://www.algolist.net/Algorithms/Number_theoretic/Sieve_of_Eratosthenes) It should help you figure out how it works.
you know, I'm starting to realize that already this morning. I'm re-organizing it into very basic functors with function modifiers instead of operator overloading.
On modern machines, the link takes disproportionately long in "wall clock time". The trouble is that the link has to be done on a single processor/core. I can watch my cores' activity as I compile - they're all lit up to 100% - and then when I link - only one of them is lit. You should also jump back a step and say, "Is this worth investing much of my time in fixing?" It seems unlikely that you are going to even knock 50% off the link time! Is that really worth hours of labor? Perhaps you need other small tasks to work on during the compilation phase? As to specific suggestions as to how to fix it, the other suggestions on this page are good ones. 
 * Read: Effective C++ * Read: More Effective C++ * See compiler flags listed in fromwithin's post. Note: I've found the -Weffc++ to be overly sensitive sometimes. * Routinely compile using multiple compilers. Don't allow any errors on any of them. I suggest gcc, clang, and icpc. * Always test with Valgrind's memcheck tool; don't allow for any memory errors / warnings. * Read some good code. E.g. the LLVM code.
Stroustrup's new book is also good for beginners. However it's much longer than accelerated c++.
I have a feeling that Stroustrup's new book is for people who want to learn programming, starting with C++ -- which is a pretty ballsy idea. Accelerated C++ is more for people who already know another language.
wxWidgets? Do they still use there stupid conventions like no namespaces, no templates, to templates, C comments... I get why they did it but standardisation was a long time ago, I aren't going to use library that is stuck pre 1998.
Is "= delete" of the same concept as " = 0" for pure virtual functions? And if so, what else is possible after a function declaration?
Before having concepts, we could have improved template error messages. Suppose we have this code: template &lt;class T&gt; class g(T &amp;t) { t += "hello"; } And this application of the above code: int i = 0; g(i); Then, a good error report would be this: g(i): type 'int' for parameter 'i' does not support 'operator += (const char *)' required by function 'g(T &amp;)'. 
Why not allow structural typing for templates? Seems simpler to talk about and a lot of existing theory already laid out. 
Not quite. = 0 declares that the function is a pure virtual function (setting the pointer to 0). = delete declares that that function should not be implicitly defined by the compiler. Recall that if I create a struct struct silly { int x; float y; }; The compiler will create some default functions for me. Specifically my silly class looks like this: struct silly { int x; float y; silly(); // made by the compiler silly(silly const&amp;); // made by the compiler ~silly(); // made by the compiler silly(silly&amp;&amp;); // made by the compiler silly&amp; operator=(silly const&amp;); // made by the compiler silly&amp; operator=(silly&amp;&amp;); // made by the compiler }; Saying something like this: struct silly { // ... ~silly() = delete; // ... }; Tells the compiler that I do not want a default destructor made automatically for me. I can specify that I want only what I explicitly write by using the explicit keyword in a new context now: // NOTE: Not sure if explicit goes here, or after the struct keyword. explicit struct silly { int x; float y; // ... that's all folks! }; Furthermore you can explicitly take in the default function by using the default keyword: struct silly { int x; float y; silly() = default; // default constructor silly(silly const&amp;) = delete; // cannot copy silly silly(silly&amp;&amp;) = default; // but we can move it! silly&amp; operator=(silly const&amp;) = delete; // cannot copy silly silly&amp; operator=(silly&amp;&amp;) = default; // but moving it is fine! }; These keywords allow you to fine-grain control which default functions the compiler will make for your objects :-) 
This is painful to look at (desperately needs terser syntax): template&lt;InputIterator InIter, class OutIter, Callable&lt;auto, const InIter::value_type&amp;&gt; Op&gt; requires OutputIterator&lt;OutIter, Op::result_type&gt; &amp;&amp; CopyConstructible&lt;Op&gt; OutIter transform(InIter first, InIter last, OutIter result, Op op);
Except that "= 0" is purely language syntax, it does NOT set anything to zero, and especially doesn't set any function pointer to null.
True. I was just mentioning that to draw a parallel. Virtual functions can be though of as an extra pointer indirection, so "assigning" it to 0 somehow makes sense. Even though that's not what's really happening. Can we do the same with nullptr? That might make things a bit more clear also: struct silly { virtual void do_stuff() = nullptr; // same as = 0? };
Could you elaborate? 
If you're looking for books that contain info on auto, lambdas, and any other new C++11 stuff, you're going to have to wait a little bit, as the standard is still very new. If you're looking to get started though, I would suggest something like [Effective C++](http://www.amazon.ca/Effective-Specific-Improve-Programs-Designs/dp/0321334876) which contains a bunch of specific things you can do to write better C++ code. For learning the language, something like [Programming - Principles and Practices using C++](http://www2.research.att.com/~bs/programming.html): it's an intro to programming textbook that focuses entirely on C++. I know you're not a beginner ;) but I've heard really good things about that book.
&gt;I want to become a game developer Honest advice. Don't. 
But I want to make games :( Can you elaborate?
It's hard for the compiler to infer at what compilation level the type mismatch happened. Concepts can pinpoint exactly that level. 
A lot of the best developers also really want to make games. It's our dream! The result is lots of talent to be taken advantage of by the industry. You might work with some of the best developers but you will all probably make LESS money than working anywhere else. And you'll probably work LONGER hours than almost anyplace else. I recommend doing what Notch did, work on your own simple games. Write them in any language you feel like, even Java. Look what it's done for him. 
It's not that bad if it's a little bit better formatted: template &lt; InputIterator InIter, class OutIter, Callable&lt;auto, const InIter::value_type&amp;&gt; Op &gt; requires OutputIterator&lt;OutIter, Op::result_type&gt; &amp;&amp; CopyConstructible&lt;Op&gt; OutIter transform(InIter first, InIter last, OutIter result, Op op);
GCC pretty much does that (gives the same error message as if you had locally said 'i += "hello"'). The problem is when templates are nested. What should the error message be in the following code? template &lt;class T&gt; void g4(T &amp;t) { t += "hello"; } template &lt;class T&gt; void g3(T &amp;t) { g4(t); } template &lt;class T&gt; void g2(T &amp;t) { g3(t); } template &lt;class T&gt; void g1(T &amp;t) { g2(t); } template &lt;class T&gt; void g0(T &amp;t) { g1(t); } int main() { int i = 0; g0(i); } It's going to be complaining about template arguments to g4(), which you might not have a clue about when you're calling g0().
You should check out the free version of [Unity](www.unity3d.com) to see if game development is for you, if it is what you think it is, etc. You can use your C# skillz to get the flavor of game development. Oh and there's Microsoft's XNA Studio, which uses C# and managed code. Sorry I don't know a link for that off the top of my head but it should be easy to find. Then if you want to get into C++ you can maybe check out one of the free engines, like [Irrlicht](http://irrlicht.sourceforge.net/) or one of the many engines listed [here](http://devmaster.net/devdb/engines). Use the search facility to search for engines by language. Learning C++ is as difficult/easy as any other language. Everybody has different opinions and the only way is to plow through enough books until you find an author that speaks your language. I recommend a O'Reilly Safari books online subscription for this. As somebody else noted, a couple of the whiz bang C++ features you asked about are still pretty new and bleeding edge. They are barely implemented in compilers, let alone documented (because who in their right mind documents anything, huh?) Also I doubt if you would find any engines using these features yet. Good luck. You're on a slippery slope and you're going to need it.
I think the real advice is: Don't become a game developer slaving away for one of the large studios producing multi-million dollar games.
No, pure virtual is still only `= 0`
I don't know if I'm missing something here, it seems that he's saying that in order to have a constrained template call an unconstrained template all the author has to do is add requirements to the constrained templates parameters until it compiles. Isn't this obvious? Especially if the mechanism to verify the concept is to use an _archetype_.
Everyone _thinks_ they want to be game developers, but the hours are terrible and the jobs are few.
The only compelling reason to prefer pointers is to document function calls. Defining a function to take const reference only for const functions and then pass editable value by a const pointer...again, for documentation only.
The [standard advice](http://www.parashift.com/c++-faq-lite/references.html#faq-8.6) is to use references when you can and pointers when you must. &gt; I have observed though that some of the problems I occasionally run into would not exist with pointers. Like what?
A reference is useful in all situations. Basically an aliased value. The const-ness is automatic and the simplicity is very clear. I use it to symbolically represent a NULL-checked pointer. Very clear. Don't check it again... because it shouldn't have a NULL value after its been passed.
Bullshit. I'm a game developer at a big developer and good developers are always in demand. The jobs aren't few the number of applicants are. If you have good communication skills, aren't an asshole, and are pretty bright (answer intermediate C++ questions and show some problem solving ability you can get hired as a junior programmer pretty easily). 45 hour workweeks are standard, with periodic crunches - 10 hour days for a week to a month. Some developers are worse than others (never work for anything owned by Rockstar). But many professions have workers that work more than 40 hours to get ahead. The point is that the work is interesting and demanding. You work with quality programmers and you get better. You have to learn math, hardware, how games work, etc, etc. If you want a challenge go into games. Certainly working for a small indy company might be your thing, but don't do it yourself - the whole purpose is to learn from people. Work with the best and you learn the best. Doing simple means you stay simple. And more likely than not you'll work even more working by yourself, and then you'll fail and no one will buy your little indy game because for every Notch there are a 1000 indy/iPhone developers trying to make rent. Once you go through the basic C++ books just test yourself with Effective C++, More Effective C++ and Effective STL. They aren't first books for learning, but they are a great way to test whether you have a decent grasp of the language. Just imagine in an interview being asked a bunch of questions out of these books. Oh and learn linear algebra. If you don't know what a cross product is then don't bother applying. Games isn't about C++, games are about graphics, math, physics, collision detection, ray casting, AI, dead reckoning, UI, pathfinding, modelling, animation, kd-trees, BSPs, etc. C++ is the least important part of my job, but I write it most of the day and have to be pretty damn good at it. I spend my time reading collision avoidance research papers rather than the latest C++11 spec. Games are very late adopters of most language features. The current project I'm on uses lambdas, auto, override and nullptr just because it's a PC only title, most console titles won't adopt these things until they're standard across all compilers and SDKs. And frankly those language feature are little bits of sugar that you'll just pick up by seeing in use. The only really hard topic is templates and they're not new and you gotta know them well. But frankly most job applicants have trouble with a pointer versus a reference - too much Java at university these days methinks.
&gt;good developers are always in demand. True, but the games industry gets more and more dedicated developers because very few of us dream of making corporate BS software. That doesn't mean the games industry doesn't value developers. If you are a good developer you always get paid well. I'm only saying you'll probably be paid a bit *more* in a more boring old industry. &gt;with periodic crunches - 10 hour days for a week to a month. I don't mind working more than that for start-ups where I'm a partner. If I'm just an employee, doesn't matter if it's for a small or big company, then crunches are not something I'm willing to engage in. Sure lots of badly run companies have crunches. But being a good developer means you don't have to work for those companies if you don't want to. All I'm saying is that in the games business regular 10 hour day crunches for up to a month are not looked at as anything wrong or out of the usual. 
You cannot use std::ref with a reference to an abstract base class in visual studio 2010 because of a bug that tries to instantiate it. That is the main one I was dealing with today. I am storing some points in an array so that I can present one to the underlying user as a reference. Initially I was having some trouble with this, but it worked out. * I should add that in the last example it is also needed to maintain a list of these things. (and array means vector).
Do buy Accelerated C++. It'll give you the foundation of your understanding of C++. Remember, C++ is not garbage-collected, and that makes a huge difference in how you program. Once you've got the basics, you can grasp the rest (including the new C++11 features) shouldn't be too hard. You might want to follow [Sutter's blog](http://herbsutter.com/). Be warned though: game programming can be very low-level. By that I don't mean "close to the hardware", but "outdated software". I'm not even sure you can use C++98 yet if you target the Playstation.
I believe that for a guy who's already a programmer and wants to learn C++, Accelerated C++ is the way to go.
Can't really think of a time when they would be useful, apart from interop with legacy code. I prefer boost::optional or shared_ptr's if I am ever tempted to use pointers.
When dealing with libraries I tend to get error messages traced back to my code - something that looks almost like a stack trace ending up at a template instantiation or function call somewhere I recognise. To me the big problem with GCC's error messages is that the types printed out are enormous. I don't care about the allocator on the vector unless I made a point of defining it myself.
Structural typing allows you to define an object by its interface rather than its name. So a function can say "I will take any object that has a `foo` method". Polymorphism requires virtual functions though, but if you implemented templates with structural typing you get the benefits of specifying the interface to a function with the power of templates.
I don't see anything wrong with it in an embedded situation, where your function expects the address of a hardware resource. 
Uhm. Whenever they need to be re-assigned?
Be sure to know the difference between const Type * Val and Type * const Val.
This is what a shared_ptr or unique_ptr is for. You can use make_shared() with a movable object and not have to worry about new and deletes.
Do you use any naming conventions to indicate that a variable is a reference? I'm no fan of hungarian notation, but I've found a few naming conventions (including using a 'p' prefix for pointers) to be useful. 
References are an optimization of copies. Use references ONLY if you could replace the reference with a copy and still be semantically correct. References are ALWAYS const. Exception: when doing stuff that the std requires to be references. This will keep you sane.
Cool, I've thought about that before. But half of me is still worried about performance -- though I suppose the compiler always has the option of not emiting virtual calls. And this might silence all those folks that say "templates are just macros". This sounds a lot like GHC's implementation of typeclasses, right?
&gt;C just does what it needs to do, not more. All its pieces just fit beautifully together. Have you seen the latest proposed standards? 
&gt; Use references ONLY if you could replace the reference with a copy and still be semantically correct. References are ALWAYS const. Don't agree. I always prefer void fill(std::vector&lt;int&gt;&amp; out) to void fill(std::vector&lt;int&gt; *out) because it saves me at compile time from accidentally or unintentionally passing 0 into the function, and I don't have to check against it.
References cannot be null? are you sure? int *p = 0; int &amp;r = *p; and there you have it, a reference to an int at address 0.
The appropriate error report in this case would be: g0(i): type int of argument i does not support operator += (const char *) followed by a list of calls that lead to g4.
Never heard of assert? Using a non-const reference like that just makes the calling code ambiguous.
This is exactly what concepts are supposed to provide. The concept check is like a structural type match. For example, the StrictWeakOrdering concept defined by the STL requires for the type to have a less-than operator.
It does increase ambiguity, but it solves The Billion Dollar Mistake-class of problems. And that's a tradeoff I'm happy to make. asserts are totally insufficient to handle this, for a huge class of software where production input is only approximated in dev and test builds.
stupid comment! I don't see why a GUI library would need templates and why namespaces would be mandatory when writing a library. What I want from a GUI library is that it works and is easy to use, which is the case.
Type T is instantiated for g0, initially.
Apparently, it's not that hard since there are already two major compilers that pinpoint exactly that level: msvc and gcc. It's just that the reports they produce are not that good. 
From Section 8.3.2.5 of the [C++11 draft](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf): &gt; Note: in particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the "object" obtained by dereferencing a null pointer, which causes undefined behavior. You can do anything (theoretically) in a C++ program if you use undefined behavior, and that's obviously not what zzing was talking about.
Why not just `std::vector&lt;int&gt; fill()`?
= delete is not just for disabling auto-generated special functions, you can use it on any function including free-functions. What it does is remove the signature from the overload set during overload resolution.
You don't see why a gui library (ANY LIBRARY) should need a namespace? really? The whole point of namespace to separate your program in to logical sections, I would MUCH rather have wx::widget then wxWidget any day of the weak. I don't want my GUI in the global namespace, that is reserved for main and C functions only. The thing is wxWidget is not C++ it is C with classes, the type of thing that we are trying very hard to discourage, modern C++ is a far superior use of the language. WWBD, what would boost do, it definitely wouldn't look like wxWIdgets. I hope for a day I can initialize a text box with a std::string or anything that can be lexically_casted. I really, really don't want to have to use wxString or a const char* it is just ugly.
A valid pointer describes a location in memory. The difference of two pointers is a type (*ptrdiff_t*) that can be converted to a size type (*size_t*). Further, a size can be added to a pointer to get another pointer, which may or may not be a valid. These are all the assumptions you should (or need) make.
&gt; The whole point of namespace to separate your program in to logical sections Does this prevent you from using the library ? (no for me) &gt; The thing is wxWidget is not C++ it is C with classes If I see the class wxDialog, for example, this seems to be c++: `class WXDLLIMPEXP_CORE wxDialog : public wxDialogBase` `{` `public:` ` wxDialog() { Init(); }` `...` `};` Concerning the strings, you can use wxString::mb_cstr() to convert to a std::string. But wxString is the class, so you have methods to manipulate it. I don't see what's ugly (contrary to char arrays). The magical thing with the wxString in the last versions of wxWidgets is that it handles unicode transparently. In the standard c++, you have std::string AND std::wstring which is completely ugly. 
... but it basically describes it as an int (possibly of non-int size), right? Obviously the compiler only allows certain usage for the type, I know that.
Pointers are just a number that stores a memory location within the address space of your program. The details of how an address maps to virtual and physical memory are up to the linker and the operating system (in protected mode at least). On x86-32, `sizeof(int) == sizeof(`*any pointer*`)`, but the size of pointers and integers doesn't necessarily have to be the same. To get a rough idea of where things are being allocated, here's a short program that prints the locations of globally, locally, and dynamically allocated variables: #include &lt;iostream&gt; using namespace std; int a = 0; int main() { int *p1 = &amp;a; int b = 0; int *p2 = &amp;b; int *p3 = new int; cout &lt;&lt; p1 &lt;&lt; endl &lt;&lt; p2 &lt;&lt; endl &lt;&lt; p3 &lt;&lt; endl; delete p3; return 0; }
Pretty much answers it, thanks. &gt; The details of how an address maps to virtual and physical memory are up to the linker and the operating system (in protected mode at least). So the actual number stored in the pointer could be for the relevant segment or for the entire memory, again depending on platform? EDIT: Way to open up new questions :P Why are the global and local variables so far apart (0x474008 and 0x22ff10)?
On my machine, this prints the following: 0x804a0d4 0xbfeaff30 0x86bf008 So the global variable is at the lowest address, probably quite close to the addresses of the executable code. The variable created by `new` still has a fairly low address, because there wasn't much else already allocated. The automatic variable has a very high address, because on x86 the as the stack builds up, it goes from higher addresses to lower addresses (somewhat counterintuitively). If you run the program several times, the first address will always be the same, because it is hard-coded into the executable. The other two will vary depending on the whims of the operating system and the new operator.
Not being namespaced doesn't stop from using the library but it does mean I would rather use a better library whenever possible. (qt is a little better, but not by much). The best I have seen is WTL, but isn't much help on linux. Inheritance doesn't mean that it is in C++ style, that just means it might be more Java in C++ than modern C++. (Which is also not great). And thanks for highlight something else I don't like. What the fuck is: WXDLLIMPEXP_CORE Macros are grim at the bests of times this is just plain bad.
&gt;Why are the global and local variables so far apart ... ? See my other reply in this thread.
It does, but there are pitfalls, so don't make that assumption in your code. E.g., if some pointer P is pointing to the location referred by number N, pointer P+1 will not refer to N+1. It is best if you think of pointers as memory addresses. Then, if P refers to the location of an object O in memory, P+1 refers to the location of O's next neighbour. Don't assume anything about exact numbers, since they depend on how objects are laid out in memory, which is dependent on the hardware, OS &amp; other factors.
So locally created variables are pretty much dynamically assigned (albeit to a consistent area of memory)? It seemed to be a pretty static address. Is this because there's nothing else using the program's stack at this time? Or are stacks shared...?
Yes, pointers are just ints. Memory is addressable, and the mail boxes have numbers on them.
&gt;So the actual number stored in the pointer could be for the relevant segment or for the entire memory, again depending on platform? Pretty much, yes. Be careful using the word "segment", though, as it has a special meaning in this context. If you were programming in real mode on an old PC, or on some embedded system where there isn't much of an operating system, then a memory address might actually directly represent a physical location in RAM. In protected mode, which is what most modern operating systems and hardware use, suppose you try to access a particular memory location. The operating system, taking advantage of hardware capabilities, will find out which page of memory this address corresponds to. It will look up in a *page table* where in physical RAM this is, and possibly reload the page from the hard disk if it has been swapped out. This is all transparent to your program, which just sees its own address space. It's not even a feature of C++, but of the operating system and hardware. What you can't do is say, if I'm allowed to access both 0x474008 and 0x22ff10, then any address between those must be fair game. You have to request the memory from the operating system first, so it can keep track. You'll probably get a segmentation fault because the operating system will notice you're using an address it hasn't allocated to you.
Ok, makes sense =D
Stacks aren't shared. Even if you were running two programs at the same time and they happened to have variables with the same address, they wouldn't be shared because of the virtual memory system. But the stack will usually have a comparitively high address, because if you nested many functions, the stack would grow to low addresses. Bad things would happen if the stack grew into the addresses used by other data.
&gt; But the stack will usually have a comparitively high address, because if you nested many functions, the stack would grow to low addresses. Bad things would happen if the stack grew into the addresses used by other data. How is it decided how big a stack would be? Too big and it's a waste of a lot of RAM, too small and you get what I would presume could be described with the term "stack overflow". A recursive function could overflow any stack though, right?
So if I get this right, in protected mode for the first step the value in the pointer is more like an identifier which my program sends to the operating system, which in turn finds out where in memory (or on disk if swapped) this memory really is. Or relates this id to some true memory location. To make my question clearer, assume we have a super small computer with 100 bytes of mem (but lots of swap space, page size 50bytes). I hold a pointer which points to address 42 1) is this physically byte no 42? now i ask the os to get the value at this address. It finds, that the page was swapped on disk and reads it from disk. So even if at some point of time 42 was byte no 42, now it unswaps, but it moves this page to physical address 40, making the relative physical position byte no 92 Hope this is clear enough? If I'm right about this, how would it be handled, if I do some pointer arithmetic and add 2 bytes to 42, making it 44? Assuming I had requested enough memory?
It's not a waste of RAM to go for a big address for the start of the stack, because most of the addresses in between the global variables and the stack haven't been allocated to your process. The addresses I was getting for the addresses of my automatic variables are greater than the amount of memory I have in this machine! So it can't possibly be wasting RAM that doesn't even exist.
So if the stack is dynamically allocated, what happens if it runs into something else that's dynamically allocated?
That's pretty much right. Pages of 4096 bytes are the usual standard on x86. You could probably expect the pages be loaded into memory aligned to the page size. And if the page happened to be reloaded some time later to a different part of physical memory, then things within that page would still have the same relative positions. But all of this is happens transparently for your program. You wouldn't be able to tell what was happening without using something like a kernel-mode debugger. I've searched around for a good explanation of this stuff, and found [this page on how Linux does virtual memory and paging](http://tldp.org/LDP/tlk/mm/memory.html).
You get a Stack Overflow and your program crashes. The stack is capped at a certain size, and memory allocated from the heap will never be in the potential stack space.
The operating system will typically allocate a certain maximum stack size to a process. It won't put non-stack stuff into the process's address space within those bounds. It will trigger a stack overflow if the stack attempts to grow beyond those limits. On Linux, you can use `getrlimit()` and `setrlimit()` to find and change this value (and others). But if the default stack is too small for your program, there's almost certainly something wrong your design. Like you were nesting way too deeply or recursively, or creating enormous automatic variables when they should be on the heap, or in an object of a class that uses the heap behind the scenes (e.g. `std::vector`).
Oh cool. I didn't know that! 
&gt;So if I get this right, in protected mode for the first step the value in the pointer is more like an identifier which my program sends to the operating system, which in turn finds out where in memory (or on disk if swapped) this memory really is. The value in a pointer is a location in memory. From the perspective of your program, that's where the story ends. All of the magic involving Translation Look-aside Buffers, CPU caches, and swap space are invisible, and irrelevant to your program*. The Virtual Memory Model that the OS sets up for a program, acts precisely as if memory were a simple, linear array of bytes (which, ironically enough, is precisely what the hardware implements....), each addressable via a 32-bit (or 16... or 8, 64, or 128... Your Hardware May Vary) address; if you have a pointer to byte n, and you wish to access byte n+1, simply increment your pointer by 1**. Additionally, because the memory model your program sees is a *virtual* memory model, every program on the computer lives in a different address space, meaning that two programs can use the same memory address at the same time, without conflict. Which means that you are free to write programs without regard for what other program are doing - on some systems, even the OS lives in a different memory space. "*" However, knowledge of these things can allow one to write faster programs. Look into cache-aware algorithms for common tasks such as sorting, for example. ** But be careful, if byte n+1 is not mapped in your address space, you will segfault. Also, accessing memory in such fashion is a GREAT way to induce buffer-overflows.
Returning a vector by value is potentially very costly.
But you can't conditionally remove candidate functions, so you can use boost/std::enable_if in that case.
Most stuff with computers are "basically ints", except maybe floats.
Now, are there any legitimate cases of using = delete outside of stopping automatically-created member functions? I mean, if I don't want a signature to appear in the overload set I can just not write the signature in the first place. Maybe if you're interfacing with someone else's code you can use it to remove conflicting signatures, but I have a feeling that that problem won't pop up too much since we have namespaces.
On Windows, you need macros to handle __declspec(dllexport) and __declspec(dllimport) (which is not standard c++), to export and import functions from a Dll. There is a solution with DEF files, that I do not remember, and which is painful! But if you have a pure c++ to do this, you can tell me ;)
* Disable implicit promotion/conversion. * In the context of Templates. * Documentation purposes. 
make -j8
Zzing did not say anything about a well-defined program, did he? 
Isn't that what Concepts are doing? (defining the allowed interface for the template)
Clarification is whenever the memory being pointed to by the pointer needs to be changed should you use a pointer. When you just need to change the type being pointed to you should use a reference. Another reason to use a pointer is for some pointer arithmetic, however iterators now accomplish this same task with regards to stl containers. This can still be done by the addressof operator in local scope of the function needing this functionality.
The only thing worse than a programmer is a clever programmer.
Why? it's not so rare to dereference a null pointer into a reference. It's important to know that a reference might be null, especially when you are debugging a program. 
Not in modern compilers. Be aware of RVO and use it to your advantage.
Yes, they are. Pointers contain addresses of the things they point to. 
Not acceptable in any code that I get to review. Feel free to assert(), ASSERT(), CHECK(), etc all you want at the top of your function, but DO NOT obfuscate behavior with non-const references. If you REALLY need it, it is trivial to whip up a NeverNullPointer class that has zero runtime cost and encapsulates the safety check. Instead of: void fill(std::vector&lt;int&gt; *out); ...you get: void fill(NeverNullPointer&lt;std::vector&lt;int&gt; &gt; out); It can ever turn calls like: fill(NULL); ...into compile-time errors. Calls like: vector&lt;int&gt; *p = NULL; fill(p); ...are still runtime errors, though.
_Everything_ in a computer program is some sort of integer. All you can ever process in a digital computer is numbers! Data structures let us agree to interpret these numbers as something else - a pointer, a string... In the case of pointers, it's important _not_ to think of pointers as "regular old numbers". For example, you can't add two pointers - but you can take the difference between two pointers in some cases, and yet you'll get a different result than you would if you thought of the pointers as integers. Think of a pointer as a "special number" that only has a very few legal operations on it. Pointer arithmetic is hard, and it's easy to make mistakes initially, but there isn't much to it and once you understand it fully you'll never make mistakes again. A great way to get a good feeling for this is to spend some time in a debugger with different sorts of arrays and look at a lot of memory locations.
Heap grows up, Stack grows down. Can't explain that. If the 2 meet, you're out of memory somewhere. Usually means a stack overflow.
int, float, double, pointers, references can be interpreted as if they were "int" stored in memory, simply because that's how almost all the computer architectures work. But the compiler interprets them differently, if you increment a pointer it will sum sizeof(value_type) instead of simply adding one, you can use the de-reference operator (*) on pointer and cannot do the same with an int. Sure if you really want to you can treat them as if they were int, or better yet a "ptr_t" witch is an integer that can always fit a pointer. But on the other hand you can do it with most native types, that's why we have "reinterpret_cast", this will probably break your program in unexpected ways since the compiler will not know anymore when a value can be aliased or worst it will assume that some value cannot be aliased. So this assumption is usually something that will come back and bite you.
Hmm. I would "whenever they need to be re-assigned, otherwise use references." That should cover everything.
Right I am just clarifying for the novice here. Because two possible values can be reassigned with pointers, the memory address and the type value.
Yes, a float is 2 ints :D
In addition to the "in general, yes": C/C++ leaves that open to support platforms where this isn't the case. On x86 - 16 bit, "far" pointers (i.e. pointers that could address the entire address space) consist of 2x16bit segment:offset. The respective linear address was segment*16+offset, so "32 bit int arithmetics" would have worked incorrectly. On some platforms 0 is a valid address, so the "Null pointer" has a non-null binary representation. On these platforms void * p = 0; assigns a non-null value, i.e. the result is different from void * p; memset(&amp;p, 0, sizeof(p)); On some platforms which natively only have "machine word" pointers, char pointers consist of a native pointer and an offset, thus `sizeof(char *) != sizeof(int *)`
&gt; Not acceptable in any code that I get to review. . . . Calls like: vector&lt;int&gt; *p = NULL; fill(p); ...are still runtime errors, though. Sorry, but that's insane. It's a minor increase in obfuscation that any competent human is capable of understanding, in exchange for the literal elimination of an entire class of bugs that's so severe it's literally named The Billion Dollar Mistake (in programming language design).
Huh. I learned something today.
Sounds plausible, I wish C++ people would just read some type theory so we can all talk to each other in the same language.
With templates you avoid the virtual calls completely, the trick is you can just specify what aspects of the incoming type are relevant to you. As others have pointed out Concepts seem to be doing this already C++ people are just using different words.
&gt; it's a waste of a lot of RAM Actually, no. Let's say you allocate one gigabyte of memory: void* ptr= malloc (0x40000000); You're using one GB worth of address space. In 32-bit x86, you have only 2 or 3 GB address space for your application; in 64-bit x86, you have something downright enormous, so, you don't care about 1 GB. You're using one GB worth of virtual memory. No big deal; the OS just has to remember you have allocated 1 GB. However, so far, no pages (indivisible chunks of memory -- each is 4 KB IIRC) have been allocated, since you haven't put anything in there. Now, suppose you do put stuff in there: memcpy (ptr, some_source, 0x40000000); Well, **now** the OS has to store your data somewhere. You have used 262144 pages of memory. The 1 GB worth of data is somewhere -- some pages might be in physical RAM, and some other pages in the swap. I suck at explaining, and it's probably half-wrong anyway. So, you definitely should read the apt-named "[What every programmer should know about memory](http://lwn.net/Articles/250967/)". 
+ccache
Int *p = 0; is aways equivalent to int *p = NULL; The standars says that of 0 is a valid address the compiler has to compensate in some manner to make so 0 == NULL.
you mean doubles ;)
nooooooooooooo, they are 'basically' \[u\]intptr_t's though.
No they are not the same thing according to the standard. An implementation *may* allow you to convert between them, but the results are implementation defined. Many people will tell you they are the same, do not listen to them. In practice they are correct, but we are talking about C++, not practice, and C++ says they aren not the same.
Addresses need not be representable as `int` though. Such a conversion is implementation defined and may not result in anything usable.
&gt; Int *p = 0; is aways equivalent to int *p = NULL; Yes, and I didn't say anything to the contrary. I said that the null pointer - represented by 0 in C/C++ - does not necessarily have an all-bits-zero binary representation.
I am not sure about a checker, that would take writing a parser then the rules behind it. However you could try using atomineerutils in your organization with these rules defined. If you aren't using visual studio though, there's nothing to see here, please move along.
As notbacktowork said, to check the content of any C++ program would require a lexical scanner and a parser of some sort. If all you're doing is checking for general styling guides, you can ignore the majority of the C++ grammar. using ANTLER (or even flex and bison) to produce your scanner and parser would be recommended. I've written a C parser by hand and it is just brutal. Really all you need to do is identify class/struct blocks, function prototypes or definitions and their arguments. I wouldn't attempt to use Regular Expressions to parse it. Regexe implementations tend to be rather slow. Generating the lexer and parser will result in fewer complications related to writing the Regular Expressions necessary to parse the code.
&gt; On x86-32, sizeof(int) == sizeof(any pointer) not true. pointers to member functions may not be sizeof(int). class dummy; std::cout &lt;&lt; sizeof(int) &lt;&lt; " " &lt;&lt; sizeof(void(dummy::*)()) &lt;&lt; std::endl; gives 4 16 (at least with MSVC) 
C++ is insanely difficult to parse. My advice would be to modify your expectations a bit. 
Not every problem is best solved with software. Try a social solution instead: 1. Make clear what the conventions and expectations are. 2. Let everybody know there is a $25,000 bonus that will be paid out when the project ships, split equally among all team members. 3. Every violation removes $100 from the pooled bonus. 
That's a tautology, because `stddef.h` defines `NULL` as #define NULL ((const void *) 0) or something similar.
Cue Clippy: "looks like you're trying to enforce noob style..."
&gt; On x86-32, sizeof(int) == sizeof(any pointer), but the size of pointers and integers doesn't necessarily have to be the same. This is where the `intptr_t` and `uintptr_t` types come in handy. Integers that are guaranteed to be large enough to store a regular pointer. (Aside from the nitpick about pointer-to-member, which is a very special case.)
Originally, and conceptually, yes, pointers were and are just numbers. This is not the whole story, though. Remember that C and C++ are typed languages, so the pointer's type is relevant here. Different pointer types can have different representations, and they're not always simple numbers. Consider an `int *` on a simple 32-bit architecture, such as MIPS (which is often taught in universities). Here, the word size is 32 bits, and memory is byte-addressed with 32-bit addresses. Here, the `int *` is pretty much equivalent to an `int`. But suppose we were talking about a `char *`. In MIPS, this is still pretty much equivalent to an `int`, because memory is byte-addressed. But suppose you were working with an older, or weirder, architecture where memory is word-addressed, such as PDP-7 (the architecture on which C and UNIX were developed). One word will often store more than one byte of data, perhaps 3 or 4 bytes. So now your `char *` must encode two pieces of information: the address of the word, and the offset within that word. This is no longer equivalent to an `int`. The take-away here is that, while it's often helpful to think about pointers as if they were numbers (and memory as a flat array), this is not actually true. It's *almost never* safe in C, and if possible *less safe* in C++, to treat a pointer as a number and manipulate it. The safest way to think about pointers is as opaque objects that support certain operations: dereferencing (i.e. `*` and `-&gt;`), adding and subtracting offsets, and taking differences. **tl;dr:** No, pointers can be very different from numbers, though it's sometimes helpful to pretend they're numbers *for conceptual purposes only*.
This is a great way to put mediocre developers (who love following coding guidelines but produce shitty code) above talented developers (who can do magic but rarely care much about strict adherence to rules). 
Sorry yo, you can still trick references. #include &lt;iostream&gt; int foo(int &amp;i) { return i+10; } int main() { int *i = NULL; return foo(*i); } It's a non-conforming program, but it can still happen. Only now you can not defend against it. So I restate my position: References are an optimization of copies. Use references ONLY if you could replace the reference with a copy and still be semantically correct. Function arguments arguments of reference type must ALWAYS be const qualified. But you're welcome to disagree. Just don't send me any code to review. Edit: I forgot to address the obfuscation. Given: int your_local_variable = 12354; MyFunction(your_local_variable); Can you tell me whether your_local_variable will still == 12345 after MyFunction() completes? No you can not. Not without looking at the header for MyFunction(). And even then, you might not be able to tell. You might have to go look at the code for MyFunction(). And that only covers TODAY. What if MyFunction() changes implementation and you don't notice it. *That* is insane.
Once C++11 takes hold, you don't even need to depend on RVO - rvlaue references FTW.
More like one int split up into two parts, each of their size depending on how much precision they need.
Why is that so? 
In C++11, with macros and introspection using SFINAE(since C++11 allows SFINAE for expressions), you can easily emulate that. For example, I have a macro that defines traits like this for checking if it has a find member for a container: TRAIT(has_find) ( type(iterator), type(value_type), member(find, this_t::iterator (const this_t::value_type &amp;)) ); Here is another one that checks if it has size member function: TRAIT(has_size) ( const_member(size, size_t ()) ); The trait is then used like a every other trait by calling has_size&lt;T&gt;, to check the trait for type T. Its slightly different than concepts, because a trait is always applied directly to class. The trait always check if the class has a type, member(or static member) function or variable. Hence thats why it always has a "this_t" type which refers to the class its checking. Whereas a concept is more generalized and can check relations with many other types. The has_size concept would be defined like this: auto concept HasSize&lt;class T&gt; { size_t T::size() const; }; This could be done with a macro in C++11 also but would turn into an ugly mess. Now ultimately these traits can be used in functions for function overloading like this: template&lt;class T&gt; FUNCTION_REQUIRES(has_size&lt;T&gt;) (size_t) count(const T&amp; x) { return x.size(); } All this can be done in C++11. 
Have you created a Unicode aware program on Windows? How do you used std::string to handle Unicode characters. Either you use std::wstring or something like wxString which which essentially wraps std::wstring on Windows and easily ports to Linux.
Can't agree more. wxWidgets is C++ as used in the real world. It gets the job done.
I'm all for consistent look &amp; feel, good clean code &amp; all that, but what you've described sounds like my version of hell. "p" in front of pointer variables? So when I see foo-&gt;bar, (or *foo), that's not enough of a clue? The p is redundant visual noise. Do I have to put g_ in front of globals too? (Don't use 'em, but if I have to maintain code with 'em, I'm already pissed as it is. And where there's one, there's more. And now I have g_'s flying around everywhere.) You're admirable for trying to automate the thankless task, but it's not that easy (as others have pointed out -- I like the social engineering solution with the $25,000 pot, even though we all know at the end of the month the pot would be at $0 and then it's just like "Well, fuck it now!") Sorry, I'm a little punchy right now. My point - which doesn't help you - is that I'm glad I don't work where you do. "We've got tons of globals everywhere, control flags passed around, race conditions abound, but goddamnit, every pointer variable in our system starts with a "p", so we've got that going for us." **Not saying that's the reality at your place**, your team might be the best of the best, it's just been my experience that the size of the coding standard, and the intensity &amp; fervor with which it's enforced, is inversely proportional to the team's (focus / abilities / excellence / whatnot)
A member pointer isn't really a pointer in the conventional sense -- it's not a memory address. It's more like an offset or an index into the class's vtable. But -- and I'm a little hazy on the details here -- there's a problem when you have multiple inheritance, as there will be multiple vtables, and calling a member function will require thunks/fixups to the 'this' pointer depending on the type. So a member function pointer has to encode RTTI data that lets a call site figure out the right vtable and whether a thunk is necessary based on the runtime-type, and so that's where the extra data comes from, as it's really several words of data not just an address. 
What a pointer is depends on the [data model](http://en.wikipedia.org/wiki/64-bit#64-bit_data_models) of the platform you are using. In the glory days of the 8086, we had [16 bit pointers with segment registers](http://en.wikipedia.org/wiki/Intel_8086#Segmentation), of which 4 bits were used, giving an address space of 1MB (2^20). 
There are multiple tools that can do that, but probably the most mature and easiest to use would be [mozilla's dehydra](https://developer.mozilla.org/En/Dehydra/Using_Dehydra). You might also want to try [cppcheck](http://sourceforge.net/projects/cppcheck/files/Articles/) or [vera++](http://www.inspirel.com/vera/), but I would say (a) their parsers are not as complete, (b) they are cumbersome to script.
code reviews should be mandatory . or check out the python script that google uses for their standards enforcement
Haha, every one of those rules goes completely against my preferred style.
I missed answering this question. If you use "something"_someliteralname then the literal is a string. For string literals (raw, unicode, whatever) there is no template literal operator definition: only the run-time literal operator is available. So to answer your question: the first one is an integer style literal as per the linked blog post (i.e., you can use the template or normal function versions of the literal operator) and the second requires the string literal function (i.e., not a template function) and is strictly run-time.
You might want to look at Doxygen and its XML output.
Note that if you manage to do that, you should slightly modify the program so that it actually fixes style breaches instead of detecting them. That way, the programmer types his code, and once it's done, he uses your program just before the commit.
Yes, it's still two integers just they're unusually sized.
Sadly, when your environment has hundreds of concurrently active development branches the insane still don't learn that code does not document itself. There is a reason we have language standards, ABI standards, API standards, etc... which are not embedded in a single instance of code.
Maybe you can use cppcheck? It is open source, so it should be possible to extend it with your rules
&gt; Can you tell me whether your_local_variable will still == 12345 after MyFunction() completes? No you can not. Yes, I can, by looking at the definition of MyFunction. &gt; Not without looking at the header for MyFunction(). Literally one keystroke.
I've written a Pascal parser by hand where I didn't have to deal with braces (OK, begin/record and end :-) hidden in macros (an upvote for anyone who points out a common usage of this in the implementation of a formal standard.)
So recursive functions doing heavy work are a bad idea then? I didn't like recursion anyway ^.^ If the heap and the stack are growing inwards towards each other, doesn't that mean that all the space in the middle is wasted? Or does the OS create "impossible spaces" of sorts using virtual memory (so that the stack and heap might physically have no space between them and will start growing elsewhere if needed)?
Yeah, I know this much. I've incremented pointers by sizeof(sometype) to flip through arrays (mostly cstrings) and that sort of thing.
So on most platforms they're encoded like an int, but on some platforms like the PDP-7 they're encoded as a different datatype that stores an address and an offset, and possibly as even weirder things on other platforms. Correct?
Thanks, that makes sense.
About the braces, I can recommend artistic style (astyle). It is an indenting tool that can also fix the line on which braces start and end. It doesn't help with your naming conventions though.
Thanks for the clarification. Hadn't considered that.
&gt; So recursive functions doing heavy work are a bad idea then? I didn't like recursion anyway .^ Recursive functions doing the work isn't always a bad idea, but if the recursion is getting so deep as to trouble the stack size limits, then you're doing something wrong. (Most decent compilers can do tail-recursion optimization, so certain recursive algorithms don't trouble the stack much anyway. But destructors can prevent the optimization being possible.) The function call overhead often makes an iterative solution more efficient than a recursive one. Recursion is nicer to write in Lisp and it's relatives than in the C family. &gt; If the heap and the stack are growing inwards towards each other, doesn't that mean that all the space in the middle is wasted? Or does the OS create "impossible spaces" of sorts using virtual memory (so that the stack and heap might physically have no space between them and will start growing elsewhere if needed)? The "impossible spaces" are simply parts of the program's address space that haven't been allocated any memory yet by the OS.
&gt; (Most decent compilers can do tail-recursion optimization, so certain recursive algorithms don't trouble the stack much anyway. But destructors can prevent the optimization being possible.) What? Does the compiler optimise things in a way that will stop the recursions just stacking up on each other? &gt; The "impossible spaces" are simply parts of the program's address space that haven't been allocated any memory yet by the OS. ... so you can have more address space than you could possibly fit in your RAM and page file? 0.o
Shameless plug: My company's [static analysis tool](http://www.vigilantsw.com/sentry/overview/) has a Python plugin API and provides a parse tree for you to inspect, among other things.
&gt; What? Does the compiler optimise things in a way that will stop the recursions just stacking up on each other? Only when the recursive function call is the last thing to be executed. &gt; ... so you can have more address space than you could possibly fit in your RAM and page file? 0.o Yes you can.
"Neat!" on both counts.
I had the same problem some time back and my decision was to use the Python bindings of libclang. I had to patch libclang so more of the AST was exposed (this is available in the 3.0 release) and updated the Python bindings a bit. https://github.com/holtgrewe/linty I am in the process of writing "linty", a style and code convention checker for C++ using libclang and Python. The code is far from finished and documentation is yet sparse, but you might be able to remove all the debug output and just add a small tree checker for your stuff. This is a little weekend project of mine and I'm currently working on ~~stealing~~ porting the indentation code from the Java checkstyle project. Any help is appreciated, simply drop me a line through github or Email. **TLDR** [Here's](https://github.com/holtgrewe/linty) the start of a C++ style checker in Python. Ping me on github to talk about collaboration.
More: * [type] - [prefix] - [sample] * char - ch - chSign, chType * wchar_t - wch - wchSign, wchType * int - i -iNumber * int16_t - i -iNumber * unsigned int - u - uNumber, uSumProfit * uint32_t - u - uNumber * uint64_t - u - uNumber * size_t - u * bool - b * unsigned char - uch * short - s * unsigned short - us * long - l * unsigned long - ul * long long - ll * unsigned long long - ull * float - f * double - d * value_type - v * iterator - it * size_type - u * auto - _ - _value * std::string - string - stringName, stringThisIsATest * std::vector&lt;std::string&gt; - vector - vectorTest * CString - string - stringTest * CDocument - document - documentMyApplication * CThisIsALongClassName - TIACN - TIACNMyObject // abbreviated words, use first letter
When you gather all of your smart people in one place to apply your group brain to the task of making this chunk of software as correct, robust, and efficient as possible, you need to focus on things that will help make that software better. I assert that the issues you mention have never, in my experience, contributed to code being correct, robust, or efficient. * Is there documentation that says what the function is intended to accomplish? If not, then why are you wasting your time reviewing the code? This is engineering, not literature or art, we judge based on what it does and how it does it; not how pretty it looks. In practice, I've found so many bugs in code where the lack of such documentation led to multiple maintainers with conflicting ideas. Never will you see a more fertile land for the spawning of hideous bugs. * Is the code cut-and-paste from another source? If so, cite the source. Then be sure and document any changes made and why. It's not just the legal thing to do, it helps maintainers find any associated discussion of the code. For instance, they might realize that the code you copied from Textbook Foo completely lacks any checks for corner cases discussed in the text but omitted for brevity from the example. And sometimes people will discard and rewrite code just because it was clipped from a source that has known drawbacks (for instance, it is not appropraite to cut and paste textbook examples into production code, when the textbook SAYS that it is leaving out all sorts of edge cases and error management). * Are there comments in the code documenting any nontrivial algorithms used, or interesting modifications to standard algorithms, or interesting code transformations made to cover corner cases or to improve performance? In short, comments that tell *why* the code is doing what it is doing? Get one guy fixing a bug, who misunderstands the *why* ... and you find that he just introduced several hard-to-diagnose bugs in the process. * Is the code actually legal code, or does it wander out into UNDEFINED OPERATION space and explore for a bit, latching onto a fools-gold nugget IMPLEMENTATION DETAIL that happens, on this platform, today, to generate results that look good? * Did you turn on all the compiler warnings, then *READ* the warning messages, and put solid thought into avoiding whatever practice triggered them? NO, I do not mean blindly adding casts to get the compiler to STFU, I mean actually addressing the root problem that the compiler is trying to warn you about ... I mean, really, you think the compiler guys sat there and thought, "Hey, wow, I can notice this obscure thing that does not actually matter and generate a pesty warning about it"? No, what they did was notice "hey, there is this way of coding this kind of thing that tends to make the code less robust, how about we warn the user about it?" Not that all warnings are veins of gold to be mined. But they are always a good signpost pointing at a potential trouble spot. If you *really* intended to write the code exactly in that way ... put a comment in the code about why you are doing this risky ugly thing that maybe busts the type system, *then* add the duct-tape (er, casts or whatever) to make the compiler be quiet. You know, so you don't have to next-error over the five hundred warnings in the project that the review team agrees are "OK to ignore" to find the one that came up because someone deleted an extra line. And be prepared to spend a few minutes discussing the duct-tape in a code review, someone may have a better way to do what you were trying to accomplish, which avoids whatever platform dependency or undefined operation or type-system-breaking step you thought you needed to sneak past the compikler. * Has this nontrivial function been tested? All code paths executed, with results that are consistent with the documentation? Yes, I am aware that testing is a recursive problem, because the test code needs to be tested, and the only end of that recursion is a test system that can test itself or an arbitrary stopping point (no, we will not write code to test the code that tests the code that tests the test code ...) But yeah, code reviews should focus on: * what is the code supposed to do? * how does this algorithm work? * when does this algorithm fail? * does this code implement the algorithm? * are you sure? * have you checked? [/endrant] Too many years fixing operating system kernel bugs. I'll be ranting about this crap until the time_t's roll over. 
Prefixing members with m_ isn't hungarian notation. The main thrust of HN is to encode the type into the variable name. The m_ thing is more of an accessory there.
What I mainly found difficult in writing it was that I kept changing my parsing method and rewrote the darn thing maybe six times. As long as you expand macros before doing any real parsing, the braces arn't much of a problem.
I'd do it as a gcc plugin. Alternatively you could piggy (pardon the expression) back on Oink: http://daniel-wilkerson.appspot.com/oink/index.html
The declaration looks like this: void MyFunction(int &amp;offset); You CAN NOT say with any certainty that MyFunction does not modify the argument, unless you look at the code. Non-const references are a blight, as implemented.
Sort of, keeping in mind that it's quite common for sizeof(int) to be not equal to sizeof(int*). Sometimes a pointer is sizeof(short) or sizeof(long long). The size of pointers varies and the size of "int" varies, and the two things don't necessarily track each other. It's just asking for trouble to think of pointers as ints in the general case. Everything is a bit string, but a bit string is *not* always an "int", despite various comments to the contrary. All of this becomes more clear if one takes a few classes on machine architecture.
Exactly. I don't think the C standard gives many requirements about how pointers are encoded, just that the standard operations that have to work on them.
It doesn't matter. Code Coherency trumps personal taste amongst a group of people...
The problem is we want to avoid wasting so much time on the peer reviews. When you work at a huge corporation, people want to write their feature/fix their bug and move on. It's only the select few who care about the standards that end up spending so much time. Automating would enforce it and to be honest it is a good automated problem. Python has python lint that checks your code conforms to the PEP
Nice. I'm on vacation but I'll take a look when I get back. Is there a free evaluation version?
I'm on vacation right now but this is very cool! I'll be messaging you in the new year for sure. I'm all for expanding an open source project. 
To be honest the p prefix helps so much. When you're working with DDI calls and huge driver code base sometimes you see arguments being passed into a function but you're not sure if it's a pointer. Out of all the conventions, the p prefix has been the most useful and helpful. It helps you spot quick errors all the time. 
Prefix should inform the programmer how the variable work programmatically. Hungarian notation is what has destroyed a very good programming technique because hungarian notation tries to do two things, and it does those two things badly. It tries to inform how the variable should be used programmticly and has some information on what the variable is. This may have been good long time ago when monitors could hold 80 characters or less for each line doing C. Today when programmers have big screens and is using C++ hungarian notation is really bad. Focus the prefix on really simple rules how to use it when you are coding for that language. That will make the code much easier to handle. Finding bugs etc. is done much faster compared to when it difficult to memorize what each variable is.
What's really crazy is how everyone is posting how they hate the coding styles I've mentioned. I understand the idea of personal taste and how good code documents itself. The truth is however when multiple people work on the same codebase it is not about personal taste but just that everyone uses the SAME style. For the curious, some styles in some languages actually do affect code quality. There's a great yahoo JAvascript talk where he describes how people love the brace style argument. The inventor of jslint however spits an error if you don't use the style he chose. Turns out in JavaScript, one brace style can lead to hidden parser errors.... 
Yes, you just have to request it from the "Try Sentry" contact form.
std::vector&lt;int&gt; * const out is superior to just passing the pointer. It fixes accidentally assinging the pointer itself.
i thing RVO is still faster than rvalue references and hope its not totally replaced by std::move stuff.
See Vera++.
The X-macro stuff is definitely interesting; perhaps create a new article on X-macros and link it to the C preprocessor article?
Hmm..just started running some on our 2/3 million line code base and found an invalid string assert in a switch statement default...I don't have access to some of these tools to do more analysis, though.
That's a really good way to ensure that people will *never* point out each other's violations of coding guidelines, because they each have the knowledge that if they do, they'll cost the other person $100. Whip/carrot works *extraordinarily* poorly with talented developers.
Funny how history matters. If you look at all the money that has been spent on optimizing C/C++ compilers plus all the money that has been spent on buying and developing static analysis tools, it would probably dwarf the cost of making a powerful statically typed language fast. But with history it makes sense that it was cheap to get C/C++ fast enough and then build the other tools up with it.
I just saw a glitch in the Matrix
There's some material here: http://en.wikibooks.org/wiki/C_Programming/Preprocessor#X-Macros -- perhaps you can create a link to it in the Wikipedia article.
I'm a huge fan of wxWidgets, though for me glCanvas was screwing up in 2.9 on OSX...
I agree that token concatenation (and stringification!) should be in his article - as these are both significant features of the pre-processor. But with all due respect, I agree with the editor and not you when it comes to "X-macros". Unless I'm missing something, they aren't a feature of the preprocessor - it's just some convention that some C or C++ programmers are apparently using. I myself have never seen one, despite over 20 years using C and C++. My suggestion to you would be to make small edits to add descriptions of token concatenation and stringification to the article. If you have any issues with that, come back here and we'll help you out. And if you're really gung-ho about these "X-macro files" then write a separate article about it, and once that's working, add a link to that article from the cpp one. EDIT: I'd also add that after thinking about "X-macros" for a while, I've concluded that they're a Bad Idea with few if any redeeming features. This is what C++ templates are for! If you're doing something that complex, use the standard idea, templates, and then the next guy has some hope of debugging or fixing it (and that "next guy" might be you). 
Big discussion: http://www.reddit.com/r/programming/comments/nov8m/john_carmack_on_static_code_analysis
Sorry you've had this experience. This seems to be the way Wikipedia is going - for some reason, the admins are convinced there is too much information and the main problem is cutting things down. I used to frequent it for some design patterns but one of the admins deemed them not notable enough for the fractions of a cent a year it takes to host them and deleted them. :(
The truth is that the removal of token concatenation and stringification is what really got to me. I can live without X-macros (which are mostly a C programmer's trick), but the former can be a real gain in productivity and I believe they should be given a lot of space in the C preprocessor section.
Beautiful. Great work. I have always wanted to play a space game that allows you to walk around ships that you can fly. 
It probably wasn't intentional but he kinda implied that the move to C++, from C, lead to more errors. I'm fairly sure that isn't what he meant in the fifth paragraph bit I kinda chuckled at the idea. 
Try opening up a conversation with the administrator. Frankly it would be smarter to attempt a rational discussion with the maintainer first than to come here. You would atleast have the benefit of his point of view. All that being said I often find that Wikipedia articles and other net based resources end up rambling and including only loosely related info. In otherwords I'm a fan of concise and focused articles. Articles with LINKs to related materials. So if you believe there is value in the missing info create your own entry and link to it. It is a free world (still) so create a solution instead of complaining. 
Cheers bud, thank you! I wasn't sure what fellow programmers would think of this, and I'm happy to see we're being well received! 
That's not a very clear clarification. :) A reference can be used to change an object in memory. But the reference cannot be changed to refer to a different object.
All variables are technically objects in memory. Where a reference can only change the value of the instance of the type, pointers can change the memory location being pointed to as well as the instance of the type being pointed to. I hope you were being facetious. 
I'm not. I'm saying that this is not a very clear way to put it: &gt; Clarification is whenever the memory being pointed to by the pointer needs to be changed should you use a pointer. Do you change *which* memory the pointer points to, or do you *mutate* the memory to which it points? You meant the first, but the second is more likely to be understood from that sentence.
They're very useful for storing a set of messages (e.g. diagnostic/error messages) in one place. I use them extensively in some of my projects, and I first saw them used in this way in the LLVM codebase.
How about you try a project that's not empty. Add a main.cpp file, and put int main() { return 0; } And then compile
this is what i did first of course. i wrote some code, tried to compile, failed, stripped it down to basically what you wrote, then tried again. i noticed now, however, that for some reason i got a virus alert from AVG when trying to build the project, that warned about virus in the exact same file that couldn't find. ( "...projects\myEmptyProject\debug\myEmptyProject.exe") &lt;-- this one. i tried to search the folder, but there is no such file still. only a pdb file with same name. my avg have never interacted with VS before, neither before or after my reinstall
I'm sorry, I don't know too much about Visual Studio, but you should try configuring AVG to ignore all of your Visual Studio folders to see what happens. And I know I'm going to get downvoted for suggesting it, but you can always try snagging a copy of 2010 (which I'm pretty sure there are legitimate legal means of getting) and upgrading to see if that resolves your problems. 
What about www.cplusplus.com's [C++ Language Tutorial](http://www.cplusplus.com/doc/tutorial/)? It's been a while since I messed with C++, and was thinking of looking into that tutorial/website before going back to the books I saved from college. Would you say your assesment of OP's link carries over to the one I've linked?
How many people built this and how long did it take please? It looks fantastic.
I actually would go further: uninstall VS 2008, disable or even uninstall AVG, reinstall VS 2008. If the issue is gone, AVG is the problem. try to make it work with VS, or switch to a different AV solution, like Avira or MS Security Essentials if you are into free AVs. 
does the complete path "...projects\myEmptyProject\debug\" contain any special characters (or spaces)? or is it longer than... lets say 260 characters? it seems to me, that the compiler has some hickup during the build process. perhaps you should give us the complete build log to investigate further...
[Second part. ](http://blogs.msdn.com/b/dowens/archive/2006/01/25/517736.aspx)
AV programs like to yank files and put them into quarantine before you can get to them. Add your projects folder to AVG's list of exemptions and try again. Just out of curiosity though, what virus is AVG reporting?
Effective C++ by Scott Meyers 
I know your pain: that is the exact book I bought when I wanted to learn C++. I suggest this one as a general purpose/beginning C++ reference: http://www.acceleratedcpp.com/ 
An excellent book, but not for learning C++
As tenebrousx said, it's a great book but you can't learn C++ from it. Once you know C++ you'll definitely want to pick up a copy though. C++ has a lot of landmines built in and this is a great resource for avoiding them.
Eeyup, seconded.
Ah thank you, just me as the programmer, with one other as an artist. Timewise iunno, maybe a year? Worked on it off and on, just recently going full force to push out a good game.
I like Josuttis as a standard library reference. It might not be your traditional "Learn how to program" book, but it will remain on your shelf long after you've tossed out the rest of your beginners books. (I also notice that he seems to have a C++11 book coming out soon.) http://www.amazon.com/Standard-Library-Tutorial-Reference/dp/0201379260/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1324964906&amp;sr=1-1 I learned C++ from Dietel &amp; Dietel 1st Edition, but I noticed that by the 4th edition the book had gotten a bit obnoxious. Maybe they've corrected some of that now that they are on their 8th edition? If nothing else, at least they have been doing the C++ book thing for well over a decade. http://www.amazon.com/How-Program-8th-Paul-Deitel/dp/0132662361/ref=sr_1_1?ie=UTF8&amp;qid=1324965103&amp;sr=8-1 
The parashift-FAQ unfortunately is a bad source of information on this topic. It claims that a reference IS its referent. That's wrong, the two have different lifetimes. Getting an invalid reference is just as easy as getting an invalid pointer. The fact that references obscure the fact that a parameter might be modified swings the balance solidly toward preferring pointers where you have an option (i.e. except for special member functions and operator overloading).
You really are confusing the terminology. There is no such thing as a "static member of an object". There are only static members of a *type*. A type is not an object. A type is a prototype defining the size, layout, and behavior of objects, which are then called "instances" of that type. Accessing members requires an instance. The this pointer is only needed if no other instance is specified. There's no such thing as "calling an object" as you persistently use. There's also no such thing as internal access vs external access. There's only access from functions inside the type and friends of the type (both of which can use private members), access from functions in derived types (can use protected members), and access from unrelated functions (can only use public members). return foo.i; doesn't call anything, except for possibly a type conversion if the return type of the function isn't the type of i. But in this example the types agree.
I think it is the possibility of virtual inheritance that really bulks up the member pointer, though I think that Microsoft found a way to change its implementation in one of the more recent versions to put member pointers on a bit-diet.
AFAIK, there are two decent books to learn C++ from scratch: Accelerated C++, by Koenig and Moo, if you already know a programming language. Programming: Principles and Practice using C++, by Stroustrup, if you're just starting to learn programming.
Please share the experience.
I has had a similar error. Try adding mt.exe to the AVG exceptions. The error is caused AFAIK by the fact that some programs of visual studio are intrusive with the executable that are generating
That's a good point. [Here's](http://yosefk.com/c++fqa/ref.html#fqa-8.6) another discussion with more issues.
So, you're probably an undergrad learning C++ for the first time and thought it'd be cool if you made a website explaining the basic concepts so people in similar situations would have something to start with. That's cool, but here's what you're doing wrong (and why people downvote you). First, there are tons of websites like yours, only much more polished and with proper explanations. Second, your examples are visually horrible (too much whitespace, no syntax coloring...) and a lot of them have nothing to do with C++ (e.g., all your sorting algorithms look like they're implemented in C). There are other things, but these are the main ones. Just my 2 cents.
I like the general idea of this site, but in my opinion it is not quite ready for public consumption yet. * #include &lt;iostream.h&gt; // Should be #include &lt;iostream&gt; * cout &lt;&lt; "hello"; // Should be std::cout &lt;&lt; "hello"; * std::vector is generally better than messing about with new[] * Don't do char employee[20]; std::cin &gt;&gt; employee; // buffer overflow if the user enters a longer string. // Do std::string employee; std::getline(std::cin, employee); * One example had #include &lt;process.h&gt; , this is not a C++ header file. I suggest you try compiling all the programs with more than one compiler with strict standard compliance flags. Oh, including http://www.comeaucomputing.com/tryitout/ . And keep getting feedback from C++ forums(but before you do at least get rid of the iostream.h, or it will hurt). Edit: formatting this was tricky.
I believe C++ Primer also became good when they brought in Mrs Moo(the fourth edition).
Seriously, this has to stop. To the OP: Everyone appreciates that you enjoy C++ enough to want to teach it to others, but you shouldn't be trying to teach it if you haven't even cracked open the standard. It's 2011 and a lot of your examples are wrong even by 1999 standards of what C++ was.
When I read a title like "Arrays and pointers" (part I ch 4), I'm wary. Is it actually a book about C?
&gt; TCPPPL To make it short, it's a reference book (and YMMV on how good it is), not a book to learn the language.
What experience? Effective C++ is a book to help you improve your knowledge of the language, once you've got the basics down.
Prefix vs No Prefix Function that doesn' use prefix, sample taken from here [SuperFastHash](http://www.azillionmonkeys.com/qed/hash.html) This function is using five local variables. To understand whats going on in function that doesn't use prefix you need to check declaration. If function is complex that will be problematic because you need to have a lot of facts in your head. What if there where 10 variables or a lot of functions to understand the taskchain #define get16bits(d) (*((const uint16_t *) (d))) uint32_t SuperFastHash (const char * data, int len) { uint32_t hash = len, tmp; int rem; if (len &lt;= 0 || data == NULL) return 0; rem = len &amp; 3; len &gt;&gt;= 2; /* Main loop */ for (;len &gt; 0; len--) { hash += get16bits (data); tmp = (get16bits (data+2) &lt;&lt; 11) ^ hash; hash = (hash &lt;&lt; 16) ^ tmp; data += 2*sizeof (uint16_t); hash += hash &gt;&gt; 11; } /* Handle end cases */ switch (rem) { case 3: hash += get16bits (data); hash ^= hash &lt;&lt; 16; hash ^= data[sizeof (uint16_t)] &lt;&lt; 18; hash += hash &gt;&gt; 11; break; case 2: hash += get16bits (data); hash ^= hash &lt;&lt; 11; hash += hash &gt;&gt; 17; break; case 1: hash += *data; hash ^= hash &lt;&lt; 10; hash += hash &gt;&gt; 1; } /* Force "avalanching" of final 127 bits */ hash ^= hash &lt;&lt; 3; hash += hash &gt;&gt; 5; hash ^= hash &lt;&lt; 4; hash += hash &gt;&gt; 17; hash ^= hash &lt;&lt; 25; hash += hash &gt;&gt; 6; return hash; } Same function with prefix, prefix used is char* - pbsz, int - i, uint32_t - u inline uint16_t _get_16_bits( const char* p ) { return *((const uint16_t*)( p )); } inline uint32_t hash_key( const char* pbszText, int iLength ) { uint32_t uHashKey = (uint32_t)iLength; if( iLength &lt;= 0 ) return 0; int iCase = iLength &amp; 3; iLength &gt;&gt;= 2; /* Main loop */ for( ;iLength &gt; 0; iLength-- ) { uHashKey += _get_16_bits( pbszText ); uint32_t uTemp = (_get_16_bits(pbszText+2) &lt;&lt; 11) ^ uHashKey; uHashKey = (uHashKey &lt;&lt; 16) ^ uTemp; pbszText += 2*sizeof (uint16_t); uHashKey += uHashKey &gt;&gt; 11; } /* Handle end cases */ switch( iCase ) { case 3: uHashKey += _get_16_bits( pbszText ); uHashKey ^= uHashKey &lt;&lt; 16; uHashKey ^= pbszText[sizeof (uint16_t)] &lt;&lt; 18; uHashKey += uHashKey &gt;&gt; 11; break; case 2: uHashKey += _get_16_bits( pbszText ); uHashKey ^= uHashKey &lt;&lt; 11; uHashKey += uHashKey &gt;&gt; 17; break; case 1: uHashKey += *pbszText; uHashKey ^= uHashKey &lt;&lt; 10; uHashKey += uHashKey &gt;&gt; 1; } /* Force "avalanching" of final 127 bits */ uHashKey ^= uHashKey &lt;&lt; 3; uHashKey += uHashKey &gt;&gt; 5; uHashKey ^= uHashKey &lt;&lt; 4; uHashKey += uHashKey &gt;&gt; 17; uHashKey ^= uHashKey &lt;&lt; 25; uHashKey += uHashKey &gt;&gt; 6; return uHashKey; } 
The first two paragraphs of that chapter(via http://my.safaribooksonline.com/book/programming/cplusplus/0201721481/the-basics/ch04 , maybe it works for you too) should ease your fears: &gt; The language defines two lower-level compound types - arrays and pointers - that are similar to vectors and iterators. Like a vector, an array holds a collection of objects of some type. Unlike vectors, arrays are fixed size; once an array is created, new elements cannot be added. Like iterators, pointers can be used to navigate among and examine the elements in an array. &gt; Modern C++ programs should almost always use vectors and iterators in preference to the lower-level arrays and pointers. Well-designed programs use arrays and pointers only in the internals of class implementations where speed is essential. Edit: Oh and on the next page they've even emphasized the sentence "Programs that rely on the built-in array rather than using the standard vector are more error-prone and harder to debug" and drawn a scary-looking bomb next to it. So it assumes a mainstream position on these issues. 
Reading the page-and-a-half you linked to did ease my fears... but made me notice the style of the book tends to make for a tedious read. Why can't every author write as well as Sutter?
I thought the cartoony bomb livened things up somewhat, although it was a little scary too.
Pictures in general are more often than not a mere distraction, and they never make up for weak style.
I think he meant exactly that - systems got more complex and more developers work on them. Not all of them can be superstars now.
Thirded; It is the best getting started book I know of. You will need others later but this is the one to start with One caveat, C++ has a new standard that will result in changes to texts to reflect what should be considered good programming. The problem is such texts are slowly rolling out with nothing universally accepted as a good text. So starting with Accelerated C++ is just a strategy to get going and may require that you relearn a thing or two when good texts covering the new standard come out. 
Give it a shot. Writing well is a gift, because the vast majority ave trouble bringing clarity to their thoughts. As to giving it a shot, like you said few texts are well written. If you find you have the hack we will all benefit. 
Thinking in c++ by Bruce Eckel. Good one I've used to learn the langage while being students. http://www.amazon.com/Thinking-Introduction-Standard-One-2nd/dp/0139798099/ref=pd_sim_b_1/190-9785840-9713239 
Nah, I suck at writing. And English not being my first language, doesn't help. &gt;Writing well is a gift I know, and I know too well I don't have the slightest talent in that domain.
You're arguing semantics, to be absolutely clear I should have said when you need to change the address where the object is in memory a pointer should be used.
Wrox's Professional C++, 2nd edition recently came out and has a lot to say about the new C++ 11 features.
Where did the ode to this great book go.
Honestly, I never managed to read more than a few paragraphs. 
Equally honestly I can easily see why both the structure and style of "The C++ Programming Language" may leave a reader cold. Personally I was impressed by it, particularly by his style of prose.
In my first year as a computer science major, I used this book: http://www.amazon.com/Programming-Problem-Analysis-Program-Design/dp/1423902092 It uses good examples to give you a thorough understanding of how the language works. Pointers are usually the most difficult thing to understand if you're coming from a higher level language. The book doesn't spend too long on inheritance - but inheritance in C++ is a huge pain in the ass and it's hard to describe it concisely. Good luck.
The Dietel books are very good and start from zero.
For beginner code (I presume) it's rather clean and well organized. Keep it up! #define is required for some specific problems, but because it causes so many problems in practice, the C++ standard has gone to great lengths to make it unnecessary in most of the cases where it was historically used. Consider replacing your defines with "const int" and "const char*". It won't change the efficiency or functionality of what you've written, but as you continue to write the compiler will be aware of those types and will warn you if they are possibly being misused. (In short, you'll get the type safety that C++ normally provides)
there is a magic "-1" peppered in there. consider replacing it with a descriptive symbol, as you already did with the other cases. goto is not evil, whatever my coleagues says. instead of chaining if's and setting flags, place a single goto with a well named label. setVars is evil. rule of thumb: function names should be so explanatory, that no comments should be needed. globals are generally frawned upon, but in this case they are ok. just use them really carefully, generally wrapped in accessor functions to control their usage. use switch only if the design suggests that the program can expand its logic in this place. swich (curplayer) case 1 is a wtf for me. only throw class-based exceptions, preferably descendants of std::exception. it saves considerable pain in the long turn. again, for a small prog as this one, it is an overkill. practise a lot, learn from smart people and have fun! ninja edit. I agree, #define must be used as little as possible. prefer enums or consts instead.
if ("y" == str || "yes" == str) is abomination. I do not write formal English from right to left because i fear that i may miss a full stop. Instead I dial up compiler warnings level to max and use sane compolers which catch such problems from miles.
Clong is my favorite compoler 
Camel back variable names too? It's very nice what you've done. Readable too!
I wouldn't worry too much about your 'system' calls -- this is a pretty pragmatic solution to something that can get quite hairy. I'd consider pulling these out into their own functions though. For example: void clearScreen() { system("cls"); } Then, if you ever get to the point where you want to do this "properly", or to port it to another platform, you've got a single place to change. It also helps someone reading the code to comprehend what it's trying to do.
In "printBoard" you've got a pretty complex control structure that looks like this: for ( ... ) { if ( ... ) { continue; } else if ( ... ) { continue; } if ( ... ) { } else { } } Now, looking at it from this viewpoint, the continues aren't necessary. This would be equivalent: for ( ... ) { if ( ... ) { } else if ( ... ) { } else if ( ... ) { } else { } } However, I'd be tempted to try and decompose this a bit more. Something like: void printBoard() { for ( ... ) { for ( ... ) { printCell(table[i][u]); } } } Then your logic can get a bit clearer. This line: if (i + 1 &gt; 0 &amp;&amp; i + 1 != tablehieght) (BTW, you've consistently misspelled "tableheight") Is quite hard to understand. i goes from 0 to tableheight, so "i + 1 &gt; 0" will always be true. The second part, "i + 1 != tableheight", I believe is trying to spot when you're not on the last row. I'd generally expect to see this as "i != tableheight-1" -- to my eyes that's more idiomatic, but not necessarily more or less correct. Of course you could make this even more explicit here: bool isLastRow(int row) { return (row == tableheight-1); } And then change the condition to: if (!isLastRow(i)) 
Some thoughts on idiomatic variable names. The ones that are striking me the most are the loop indices and passing "i" around (eg as a parameter to editBlock). Generally, I would only ever expect to see single character variable names in a few contexts. 1. *Loop indices* - these are commonly i, j, k. for (int i=0; i&lt;100; ++i) { for (int j=0; j&lt;100; ++j) { } } Some people prefer to use longer variable names for loop indices: for (int row=0; row&lt;100; ++row) { for (int column=0; column&lt;100; ++column) { } } Ultimately, this comes down to preference. However, you need to be aware that many people will see 'i' and expect it to be 'the outermost integer loop index' and to see it used in some other way will cause them some amount of confusion. 2. *Coordinates* - single character names for 'x', 'y', 'z'.
The main problem is that the code is broken and does not detect win/loss correctly. In `isGameOver`, the line `if(checkWin(player1) == player1)` should read `if(checkWin(player1))` since `checkWin` returns a boolean (and similarly for `player2`, of course). Other than that, the code looks good to me. There are some small issues, many of them already pointed out by others: You should prefer `const` variables or `enum`s to `#defines`. You should spell `tablehieght` and `isVaild` correctly. If you give your function a name like `isGameOver`, most people would expect the function to return a boolean flag indicating whether the game is over. In your case, however, the function returns 0, or -1, or a player number. I think you should call such function `GameStatus` or something similar, to avoid confusion. I would also consider creating a dedicated `enum` type for the game status being returned, to make the function signature self-documenting. What's the point of the try/catch block? I don't see any `char *` being thrown. Is it thrown from some library function? In any case, throwing `char *` seems like an awkward choice of exception type: the code throwing a C-type string must handle buffer allocation whenever it wants to throw some runtime-generated string, and the catcher must then handle deallocation. Why not use `std::string` or, perhaps even better, something derived from `std::exception`? The `switch(curPlayer)` should be an `if`. There's also no point in testing whether `player2` has won immediately after `player1`'s move, so even `switch (isGameOver())` might be replaced by an `if` and a call to `checkWin` (and a separate test for draw, which can be simply implemented by counting the number of moves). The whole `main` function is rather long and deeply nested. I would consider separating the logic of a single game into a separate function `playOneGame`, say. Then you wouldn't need to call main recursively (a bad idea in itself, bleeding stack like this), and you wouldn't need the global flags like `firstrun` or `isPlaying` to manage the control flow. Instead you would just call `playOneGame` repeatedly from your `main`. Using NULL for integer 0 is a mistake. NULL should only be used for null pointers, until your compiler starts supporting `nullptr`. I'm surprised your compiler didn't emit a warning for this (my gcc does). You do compile at maximum warning level, don't you? Using `o` for a variable name is dangerous. One day you will confuse it with 0. Inside `checkWin`, when you iterate over a diagonal, you don't need two iteration variables `i` and `u`, each incremented separately in a different way. Instead of `if (table[o][i++] != player)` you can just write `if (table[o][o] != player)` and get rid of `i` (and similarly for the other diagonal). If you insist on incrementing two variables in your loop, you should at least increment both of them simultaneously in the `for` clause, to make your intention clear. 
That's all preference. Correcting a typo is far more important, in my opinion.
&gt; if ("y" == str || "yes" == str) These are called [Yoda conditions](http://stackoverflow.com/questions/2349378/new-programming-jargon-you-coined). That was a good idea in the 80s when we first started doing this - now your compiler will warn you if you accidentally put an assignment in your comparison statement (and if you don't have your compiler set up to warning you of this and a large number of other dumb things, you should rush to do so right now). You should be trying to write code that's as predictable and understandable as possible - code is written once but read at least ten times. Yoda conditions are a bad idea.
Aren't most "big" games made in C++?
That's really a matter of taste. Also, class names are almost always in CamelCase in C++ - Microsoft does it, Google does it - so naming functions that way too isn't a good idea. 
- You are not not modifying the argument, pass argument as const reference (const std::string&amp; AbsolutePath). - The default constructor of std::string is initializing it as an empty string, no need to do it explicitly. - The recursive way is much cooler. - NSFW.
You're not returning anything from your sort functions. 
Wow. I looked at your quote, then at the code, then back at your quote, and typed a paragraph about the code being perfectly well defined and idiomatic ... ... then I *finally* saw that neither initialized the index variable. I want to say that -Wall -Wextra would warn about this, but I figured trying first might be a good idea. Alas, G++ 4.2.1 does not give warnings for this: % cat forcheck.cc #include &lt;iostream&gt; using namespace std; int main( ) { size_t n = 10; for (size_t i; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "bye!" &lt;&lt; endl; } % g++ -O2 -g -Wall -Wextra forcheck.cc -o forcheck % And of course, the obligatory verification that indeed it is not being initialized to zero: % ./forcheck bye! % I notice you are using "stdafx.h" -- this is specific to Microsoft Visual C++, is it not? So our nattering about turning on all the warnings in GCC isn't going to be directly applicable. Substitute whatever you have to do to get your compiler to warn you about everything possible, and if possible, turn those warnings into errors. ( Now, let's see if my included code looks OK, or if it needs editing to look right ... the live preview looks odd. ) [edit: yeah, despite severe oddities in the live preview, the post came out OK. ] 
Someone called these sorts of things "Yoda conditionals", because it's sort of like the backwards way Yoda talks.
It'll warn you if you turn on optimization though.
He's an engineer. He traded more risk of errors for some benefit that made it worth it.
&gt; std has a lot of symbols - and I can assure you that you don't know what all these symbols are. Just as important, more will be added in the future, potentially changing the meaning of your code.
Very beautiful game. reminds me of [Wipeout](http://www.youtube.com/watch?v=e5nfFE5WVVw)
Glad I included the version number, then. 4.2.1 is what happened to be on this box -- latest MacOS and getting the compiler from XCode. I should have done the test on a Linux box that has more recent tools. 
Hi Steve. I've added an example to my op above. Sorry, I realise I'm not being very clear. I realise that this is a compile-time optimisation and not a run-time. The goal would be to have cpp build special case scenarios for sequences of opcodes that occur in the compiler source. So either when groups of opcodes are generated immediately in succession.. or, during the compilation stage, recursively calling the compile function after each opcode generation, passing in the previous opcode as a template param to the compile function. (So if the vm had 64 opcodes there would be 64 versions of the `&lt;typename previous_op&gt; void compile(...)` function) The goal is to have lots of extra opcodes generated, compile-time, that encompass sequences of activity that can occur in the compiler during its runtime activity.
Version 4.2.1 was the last release of gcc to be licensed under the GPLv2 (released 2007-07-20.) Everything since has been GPLv3, which is objectionable to Apple due to patent indemnity clauses, leaving them no choice but to keep 4.2.1 limping along indefinitely, without being able to look at or backport any bugfixes, changes, or improvements made by the gcc community in the last four and a half years. Apple understandably threw all their resources behind the BSD licensed LLVM/clang, which is the default compiler in Xcode. They still include gcc because I suspect there are probably some codebases that clang can't quite handle yet, but I also suspect that they don't care too much about gcc features or bugfixes, it's just a legacy component now. But I'm not an OS X person so take that with a grain of salt. Clang doesn't catch the error when compiling, but its static analyzer does notice: $ clang++ -O2 -Wall -Wextra -g forcheck.cc -o forcheck $ clang++ --analyze forcheck.cc forcheck.cc:7:22: warning: The left operand of '&lt;' is a garbage value for (size_t i; i &lt; n; ++i) ~ ^ 1 warning generated. This is clang 2.9. There have been improvements in this area in version 3, so it might catch it during compilation. 
Right now I can only think of the following: http://bartoszmilewski.wordpress.com/2011/07/11/monads-in-c/ // Mostly "The "Compile" Metafunction in C++" part, but to understand it you have to read the rest. You might also be interested in the following ("Compiler Construction Toolkits", but, again, it's recommended to read everything): http://cpp-next.com/archive/2010/08/expressive-c-introduction/ http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/ (this last link is probably the closest to what you have in mind, see also other articles from the Expressive C++ series).
What modifications to the sound are you talking about? If you want to have signal processors working on it in real time, consider writing a VST or LADSPA host. Maybe take a look at how lmms does that.
I'm talking things like delay, echo, chop, etc.. relatively simple effects. Which all need to be able to **added**,**removed** or **modified** on the **fly** (real-time). I'll have a look at the stuff you mentioned. Hope fully you'll be around if I have more questions.
Depending of your platform of choice, ASIO or JACK might be good keywords to search, especially if you want near-realtime performance.
Heh, yeah in hindsight I may of done so. The curiosity was more one of "Hmm.. I wonder if I could use this to do that.." with a vague idea, which then kinda solidified after I asked the question (which was later added as the example). But yeah, certainly don't *need* to do it with metacode. You're right. I may just end up doing it like that - custom grouping common opcode groups as extra instructions, then running some passes over the resultant code looking for those patterns and exchanging (for the OPCODE_ABC patterns). That certainly ticks all the boxes for what I was *thinking* could possibly be done with meta. *"Could anything* ***else*** *be done too?"* Hmm.. probably not that adds much more optimisation. This is probably 95% good enough. You're right. Overthinking. I should thinking in terms of *"how can I best achieve this goal, given these tools?"*, not *"what can I achieve given these tools and thought patterns?"*. Although ironically the later did lead to the goal in the earlier. So maybe such patterns do have uses.. if you rethink it after. (That being said if anyone *does* still have any ideas about this kinda stuff I'd still love to read over any of it.)
Them there looks like some good reading. Thanks!
 ptr01 = new int(71); //creates an int in memory and stores the memory address in ptr01 ptr02 = ptr01; //now pointer 1 and pointer 2 point to the same place (*ptr02) = 81; //Dereference ptr02 to get the memory location of 71 and change the value to 81 cout &lt;&lt; (*ptr01) ; //should print out 81 because you changed the value of memory that ptr01 and ptr02 were pointing to. You need to change ptr01 = ptr02 to the other way around. Right now you are setting the pointer ptr01 to 0 because ptr02 is equal to 0. You want to change ptr02 to ptr01 so you can change the value of the memory address returned by new. 
you're not calling new on ptr02, so when you do ptr01 = ptr02; *ptr01 = 82; // Here you are writing to NULL which is an invalid operation you're also calling delete on 2 pointers (though it's safe in this case since they're both NULL) but only calling new once. because you are setting ptr01 to NULL you have a memory leak from the new int(71) call This is stylistic, but setting pointers equal to NULL (or nullptr if you're on a newer compiler) is more informative to someone reading your code as to what you're actually doing. This is being pedantic but that's especially important when you're learning. Your cout isn't very accurately labeling the output. This would be more accurate cout &lt;&lt; "The value pointed to by ptr01 is " &lt;&lt; *ptr01 &lt;&lt; &lt;&lt; " The value of ptr01 is " &lt;&lt; ptr01 &lt;&lt; &lt;&lt; " The address of ptr01 is " &lt;&lt; \&amp;ptr01; I think this program is closer to what you are trying to accomplish: #include &lt;iostream&gt; using namespace std; int main() { int* ptr01 = new int(71); int* ptr02 = NULL; cout &lt;&lt; "The value pointed to by ptr01 is: " &lt;&lt; *ptr01 &lt;&lt; "\nThe value of ptr01 is: " &lt;&lt; ptr01 &lt;&lt; "\nThe address of ptr01 is: " &lt;&lt; \&amp;ptr01; cout &lt;&lt; "The value pointed to by ptr02 is: undefined" &lt;&lt; "\nThe value of ptr02 is: " &lt;&lt; ptr02 &lt;&lt; "\nThe address of ptr02 is: " &lt;&lt; \&amp;ptr02; ptr02 = ptr01; *ptr02 = 85; // Here the * operator dereferences the pointer and you are modifying what it's pointing to. cout &lt;&lt; "The value pointed to by ptr01 is: " &lt;&lt; *ptr01 &lt;&lt; "\nThe value of ptr01 is: " &lt;&lt; ptr01 &lt;&lt; "\nThe address of ptr01 is: " &lt;&lt; \&amp;ptr01; cout &lt;&lt; "The value pointed to by ptr02 is: " &lt;&lt; *ptr02 &lt;&lt; "\nThe value of ptr02 is: " &lt;&lt; ptr02 &lt;&lt; "\nThe address of ptr02 is: " &lt;&lt; \&amp;ptr02; delete ptr01; // Don't call delete on ptr02 since it points to the same block of memory ptr01 = NULL; ptr02 = NULL; } [Check out this video for a good overview of how pointers work.](http://www.youtube.com/watch?v=f-pJlnpkLp0)
yes that work, I saw my mistake thanks a bunch!
Is there much difference in use between VST and PortAudio? How much has to be re-written between a stand-alone and a VST plugin?
Following my post about using the bare output of the API, I just found this: http://maximilian.strangeloop.co.uk/ It's an MIT licensed audio/synthesis library. I'm not suggesting that you use it as is, but at least have a look through the code to see how it works. It's probably worth taking a bunch of code like the mixing and pitch shifting. Also, look at Juce, as mentioned elsewhere. It's what Mackie Tracktion is based on and has a load of audio-related stuff built in.
fmod user here, PS3/360/PC games. Their event system is broken (at least it was a couple of years ago). We don't use the high-level event system at all, just the low-level sound libraries. We forked those and fixed them ourselves. Their code quality is turds. I haven't heard any complaints about the Miles sound system, but haven't used it. OpenAL or DirectAudio is what you want. What's the target platform?
For style points, you can declare multiple variables in the same declaration. As such: double x, y, z; You can initialize them: double x = 0.0, y = 0.0, z = 0.0; You can span multiple lines: double x = 0.0 , y = 0.0 , z = 0.0; But understand that the *variable* is the pointer or reference, not the type. By this I mean: int val = 7 // This is an integer of value 7 , *ptrVal = nullptr // This is a pointer to an int, pointing to null. , another_value = 2; // This is an integer of value 2 When you learn about functions, you can do the same thing, by return type: int f(), x(char *); // Two function declarations, both return an int. x takes a parameter. Many developers say this is a bad practice, as it makes code harder to read. I disagree whole heartedly. It helps you think about what you're doing and ensures you change an individual or groups of variables types thoughtfully. It also avoids a lot of redundant typing and unnecessary verbosity. When in doubt, use your head. --- Modern common wisdom suggests you shouldn't use NULL when assigning null to a pointer, contrary to other wisdom posted here; always use zero, or if you're compiler supports the the C++11 standard in part or in whole, nullptr. Zero ALWAYS represents a null pointer, it's in the standard, and is unambiguous. With NULL, you're never quite sure what it represents; it's defined at least twice in the C standard libraries, and is known to be redefined multiple times with different values which lead to all sorts of problems. --- Be mindful of the atomic bomb that is "using namespace BLAH", it's a bad habit to get into. You pollute the entire file with the std namespace, and, as you approach projects larger than a single file from a book, it will bite you in the ass. This very problem kills me with std::numeric_limits and it's min/max functions, and the min/max macros. This also highlights how macros are evil and should be avoided at all costs. It's better to scope things in explicitly, as you use them, or at the very least, being quite mindful of scope. If you want unfettered access, try limiting your scope to just that function. In the body, between the curly brackets, you can place your "using namespace std;", and then only that function body is effected. --- Regarding your code, your cout statement can span multiple lines, so you only have to write std::cout once. Since you know you did your assignment wrong, upon fixing it, don't delete both pointers, you can only free memory once. I think you either know that or will find out the hard way. You can't free memory you've already freed. But do assign both to null once you're done, as you have done. --- Here's some damn useful resources as you are just starting and are progressing. I'm sure you will refer to these things and back to these things many time as you progress. I still do, and I've been doing this professionally for many years. Careful not to get lost in this material so early in your education, your understanding will develop, and all this will become increasingly awesome: [The C++ FAQ](http://www.parashift.com/c++-faq-lite/) is an optimistic view on C++. [The C++ FQA](http://yosefk.com/c++fqa/) is a pesimistic view on C++. The guy is not wrong. Read both in tandem, and heed the FQAs warnings. [The Guru of the Week](http://www.gotw.ca/gotw/) is no longer updated, but is still relevant. This will learn you some shit. I found it mind opening. These exercises will take you on a journey your book or learning source cannot/will not go. [Secure coding](https://www.securecoding.cert.org/confluence/display/seccode/CERT+Secure+Coding+Standards) in both C and C++ will teach you some good habits. Buffer overruns and overflows are STILL all too common in C/C++, and security is our responsibility, taken lightly all too often. Be sure to read the comments at the bottom of each suggestion. --- Finally, once you learn about pointers, and you got that shit down cold, start using smart pointers. If your compiler supports C++11, read up on std::unique_ptr and std::shared_ptr, as well as std::make_shared. There is no std::make_unique, much to my frustration. If your compiler doesn't support C++11, download, build, and install the Boost library, and use their smart pointers, for now. In fact, install the Boost library and use it anyway. The point of a smart pointer is that your memory is managed; in more advanced use cases, when an object is destroyed (you'll get to that) or your code throws an exception (learn and love them), you won't end up with memory leaks. You'll never have to write another "delete" again, and your destructors will be mostly empty. **TL;DR** I wrote all this because I didn't sleep well last night and I'm relying heavily on coffee. I hope you find this stuff useful at this point without feeling overwhelmed.
Cool thanks.
For C++11 features supported by VS2010, I've got a guide at [cpprocks.com](http://cpprocks.com). Like you said, there's not much information on C++11 out there, which is a pity because I'd like it to become the norm as soon as possible.
You and me both. C++11 adds so many great features to the language.
Lacks which headers should be #included for each algorithm and container.
The algorithms are either in &lt;algorithm&gt; or &lt;numeric&gt;. Container headers match container names, with the exception of unordered_multimap and unordered_multiset which are in &lt;unordered_map&gt; and &lt;unordered_set&gt; respectively. I didn't have enough space to provide a full reference! :)
The notion of a multiset (http://en.wikipedia.org/wiki/Multiset) is actually quite useful. Algorithmically, an unordered_multiset gives you the ability to store multiple equality-comparison-equivalent copies of the same element in the container, but, simultaneously, gives you the ability to query the element's existence quickly. This is the purpose of an unordered_multiset, to allow you to query if the container has &gt;= 1 copy of the element in amortized constant time, while actually allowing you to have multiple elements which are technically "equal".
Why would you want to target all of them? PNaCl isn't a VM. What do you think they have in common?
Thanks for the reply.
Out of curiosity, how successful is cpprocks.com in terms of income? It seems like (a) a good way to get around having to deal with a publisher (b) a nice way for developers to learn [copying &amp; pasting from the PDF files makes things easier] but (c) awefully expensive [books by Meyers, Sutter, and Alexandrescu by comparison can be had new from between $20 and $50; granted they don't have C++11 books out yet though].
I should probably have linked directly the essay http://herbsutter.com/welcome-to-the-jungle/ and not the blog post that introduce the essay (by the same author)
Finally.. an O(1) lookup container in the base language :D 
Wow, thanks. I basically live in linux and I've always assumed this was a POSIX std. So that doesn't work on windows? OSX?
~~When using the convert algorithm, do I have to download the boost library?~~ It seems I didn't fully understand what boost was, I'm going to read up on it a bit and get back to you, Thanks!
FORTH is the answer! :)
Nonsense! Tools will evolve with and will be built to best exploit advancing technology. These tools will be built mostly by bright, young programmers, who astonish me everyday, and not by old curmudgeon C++ programmers like myself and Herb Sutter.
IIRC, the previous poster of that article did the same mistake.
I'm pretty sure they mean this but using array syntax and loops: int a0=1; int a1=2; int a3=3; int a4=4; int *p0=&amp;a0; int *p1=&amp;a1; int *p2=&amp;a2; int *p3=&amp;a3; *p0*=*p0; *p1*=*p1; *p2*=*p2; *p3*=*p3; If you still can't figure it out from here then let me know. 
Silence! :) Tools, libraries or operating systems cant solve this problem for us. Only programming languages can. Why? Because the problem is the sequential nature in which we write our applications. It simply does not scale and needs to change dramatically.
 #include &lt;iostream&gt; using namespace std; int main() { int * ptrs[4]; //array of four pointers int a[4] = {1, 2, 3, 4}; //array of four values int i; //assign array elements to pointers for (i = 0; i &lt; 4; i++) { cout &lt;&lt; "Address of " &lt;&lt; i &lt;&lt; " is " &lt;&lt; &amp;a[i] &lt;&lt; ", has value " &lt;&lt; a[i] &lt;&lt; endl; ptrs[i] = &amp;a[i]; // ptr[i] = address of a[i] cout &lt;&lt; "Ptr " &lt;&lt; i &lt;&lt; " points to " &lt;&lt; ptrs[i] &lt;&lt; ", has value " &lt;&lt; *ptrs[i] &lt;&lt; endl; } //square them for (i = 0; i &lt; 4; i++) { *(ptrs[i]) *= *(ptrs[i]); // multiple ptrs[i] by itself (*= operator) and assign to itself. *(ptr[i]) means value the //pointer points to } //print them for (i = 0; i &lt; 4; i++) std::cout &lt;&lt; i &lt;&lt; " = " &lt;&lt; *(ptrs[i]) &lt;&lt; endl; } http://ideone.com/lemv7 &gt; am confused about the contents of the pointers, the array of the pointers doesn't contain anything, how can you then assign the address of another array to it? Pointers are like ints, that hold the address of the bucket in the array. An array is a number of buckets in a row so "A" look like this: 0 1 2 3 &lt;--- offset in array, what variable i is always set to a `[ 1 ] [ 2 ] [ 3 ] [ 4 ]` And b, the pointers, looks like this: `[ address of a, 0 ], [ address of a, 1 ], [ address of a, 2], [address of a, 3]` One array does not address another array. The _values_ of one array, is infact a collection of individual pointers, which _can_ point to certain addresses inside another array. Since my second array got all the elements of "a" inside it, I can minipuate the whole of "a", indirectly from it, which is what I do. 
&gt; the array of the pointers doesn't contain anything What leads you to say that? It contains four pointers. Each of those pointers can point so something, and so the addresses of those somethings can be assigned. Don't think of it as assigning the address of an array to something, think of it has having four integers and four things that can point to integers. They happen to be held contiguously in an array but they certainly don't have to be, they could be four integers floating around at random points in memory. 
there's an error right in the first page, listing 2 also leaks. i wouldnt trust anybody to talk about memory management if they make basic mistakes.
Remember that pointers are actually numbers (memory addresses), ints if you wish, just declared differently by also specifying the value that is stored at that address. This is basically a (huge) aid to program correctly. So (assuming 32bit platform), a[4] array is four 4-byte numbers stored in memory. Then you create another array, of pointers. This is in reality also an array of four ints, but it will store four addresses where a ints in memory are. eg. ptrs[0] = &amp;a[0]; The expression &amp;x gets an address of x and *p accesses the value that is stored at an address p. The kind of the value is specified by the pointer declaration.
Have to disagree with you on that one nowbacktowork. The D &amp; D C++ book is problematic in a few ways. I taught a grad level C++ course back before Stroustrup's "Programming: Principles and Practice using C++," when there were no good text books in C++. I used the D &amp; D 3rd Ed. because the previous instructor had and started looking for a better one. As far as I can tell, there were no good C++ text books until "P:P&amp;PUC++" (there were and are some others that are acceptable). I think the D &amp; D business model is based on cranking out new editions regularly so that students can't get by with used books and they are up to their eighth edition now. I haven't seen the latest, but a review on Amazon says that it has changed little from the previous. I have looked at some editions since the one I used to teach with and they didn't show much tendency to fix the problems I saw. There were many, many small flaws with the book. Example code that sets a poor example of how to write code. Statements that were either wrong or were technically correct, but left a false impression. Questionable emphasis: not enough time spent on some important topics and too much on lesser topics. But the single biggest issue relates to their business model of just quickly adding some new stuff and calling it a new edition. "New" language features like the string class and the STL are added on at the end and not integrated into the rest of the book. We can't "Look Inside the Book" for the eighth edition, but we can in the seventh and the string class isn't introduced until chapter eighteen. The STL is introduced in chapter twenty-two. (I do see that there is now a section on vector in chapter on arrays. I don't know what edition had that edition.) Understand that even when I was teaching out of the third edition, the standard was old news and the string class and the STL should have been taught from day one. Which is how it is done in all the books that Fabian4 and zootsuit have recommended. I think D &amp; D might be a cut above Herb Schildt, but neither is acceptable.
Excellent recommendations Fabien4. These are my go to recommendations for beginners. By the way, I'm something of a collector of C++ books and I've found an amazingly quick way to get a rough order of magnitude check on the quality of a C++ book. There are very few C++ books published by Addison-Wesley are not good and very few C++ books published by anyone else are are good. Of course Addison-Wesley publishes quite a few C++ books so finding the right one for a particular user's purpose may take some thought. Being a quality book doesn't mean that it is for every reader. 
Unless I'm misunderstanding your question, VST and PortAudio are totally disjoint. VST is a synth/fx plugin API, and PortAudio is a cross-platform audio I/O interface.
I wrote a cross platform OpenGL rendering engine in C++ that's ported to Linux, iOS, OS X, Android and Windows. From my experience, it's best to keep your Windows port in sync at every stage in the development of your application. I find that I'm most productive in Linux but it's not fun when you run into surprises after spending a few weeks knocking things down and hitting roadblocks getting it to run on Windows, especially when you need to demo in short time and you misjudged how much effort it would take to get that done. 
That's cool, I'd agree with that line of thinking - developing on Linux and making sure it works on Windows - kinda my workflow at the moment. However, I would add one thing as benefit of getting things working on Windows... visual studio debugging...rocks :) I'm interested, why did you roll your own renderer, when there are multi-platform ones available?
Link? 
D:
You can't put a "back door" in a language. In an implementation (compiler, linker, or runtime library), yes, but not in the language.
Obviously I'm joking here ... but weaknesses in the languages or the standard library can be exploited. For instance the c standard library printf etc can be exploited for buffer overrun attacks ...
&gt; They're both ways of getting audio into and out of a bunch of code. The VST interface allows a VST host to control and use an effect plugin. Only part of this is audio transfer. PortAudio is a library which actively translates your calls and buffers from its interface to that of the underlying OS interface. Similarly, the MySQL API and the C++ standard library both allow one to output and input arbitrary-form data but their applications are unique. &gt; If I wrote an effect, how much of it could stay the same between the VST and the standalone version? The processing code (the code applying the effect to the audio) would be similar, if not the same. No one would use a standalone effect, though. Effects are written with standard interfaces like VST (or LADSPA, or Audio Units) because people use effects in a greater scheme, like music production or live performance, where often many effects just like yours are chained together and used in sequence. &gt; otherwise you'd only need to swap PortAudio calls for VST calls to move audio in and out. Yes, and to port a gtkmm application to MFC, all you have to do is swap library calls. Looks like you've got this all figured out.
 | （╯°□°）╯ $$$ | 
It's not letting me view it. Anyone have it uploaded somewhere else?
I don't get it.
Can someone mirror this on imgur or something? I dunno if it's just my mobile internet or what but goldns.ru just ain't doing anything.
The link is currently down, but **the original can be found in both authors' webpages**: [http://fearlesscoder.blogspot.com/2012/01/c11-lands.html](http://fearlesscoder.blogspot.com/2012/01/c11-lands.html) [http://jimblog.me/?p=11644](http://jimblog.me/?p=11644) (in Russian) These are the same guys who made the old version (from 2009), you can find links to it on their pages. *Disclaimer*: I haven't seen the one posted by the OP (since the site is down), just assuming it's the same one, since it's a map called "The C++ Lands" posted yesterday... how many of these can there be? :)
Day 1 Agenda Announced: http://channel9.msdn.com/Events/GoingNative/GoingNative-2012?sort=sequential&amp;direction=desc&amp;term=&amp;d=1
Upvote in thanks.
If you are debugging and the this pointer is null, go up the stack and look at the object you are using to make the call. Somewhere you have a line of code something like: myWidget-&gt;showItemProperties(..); Your error is likely that 'myWidget' was never actually set using myWidget = new ItemViewWidget(...);
You might also call a method of a NULL reference. Good luck in checking all your pointers and references !
Why on earth are you using raw pointers?
Because boost shared pointers are bloated, and "shared" pointers aren't actually that much of a good thing maybe.
Yeah stupid mistake:( I ashame of it :) But it's a good lesson for me. Thank you.
Microsoft wants C++ to be proprietary. They don't want C++ code to be easily transferable from unix to windows and vice versa. That's why they have screwed C++ so much in the past, and that's why MFC is so much tied to Win32. Even the main() function for windowed applications is different. 
&gt;Don’t get me wrong, this is still a very very good book (and one I refer to fairly often), but the fact that the standard text on C++ all but ignores something as core to the internal operation of C++ as the Stack is telling indeed. In my experience, this is symptomatic of the disconnect between programming language and underlying implementation that exists in the academic mindset. I expect this is because some processors don't support a stack as such. A long time ago when developing code for IBM 370 series mainframes which didn't have a stack, we reserved a memory area for a stack and a register as a stack pointer, and wrote push and pop macros accordingly. What do modern c and c++ compilers do if the processor doesn't support a stack?
class my_class : public your_class, public his_class {} What's _super? This extension is limited to single inheritance: surely it's been adopted from Java -er, sorry, .NET- and it is unusable in generic C++ 
From a technical standpoint i don't have an issue with them using that in code that's not portable in the first place. But it does add another keyword you need to 'know about' when looking through that code. As for myself ... i'm not touching that with a ten foot pole.
basically, do you need the object to live more than the scope in which it is created? then use shared_ptr, else use unique_ptr. in other words: - if you create a unique_ptr, the memory space holding the created object will be destroid when the unique_ptr itself its destroyed (usually in the end of the scope it was created), this denies the object to live longer than the scope it was created because it can NOT be owned by another unique_ptr. - shared_ptr use it when you want to pass the object around without caring, it has a "reference count" (not a REAL reference count like COM for instance, but close enough) and it will only destroy the object when that count is 0, it can be at the end of the scope or it can be much later if the object was passed around, because it can be copied or "pointed" by another shared_ptr. hope i helped. EDIT: as for replacing ALL raw pointers, usually thats fine but it really depends on what you're building and trying to acomplish, there isnt a specific rule on when to use share, unique ptrs or raw pointers. usually inside a class raw pointers are fine because you can control their destruction using the destructor. what i usually do is: need pointer only inside a class that wont be passed around? use raw pointer, else use unique, shared. there are exceptions ofc.
This is effectively using unique_ptrs to create a sink behavior right? So you could also use them for instance to pass a data packet out to a function / thread that will destroy it safely upon terminating it's scope.
&gt;Should I use std::unique_ptr in place of all raw pointers? No, not all pointers own their pointees. When you clear up the ownership of the pointee, it suddenly becomes very clear which pointer to use for pointing to it.
Yeah, this is something I'd expect to see in an x86 assembly language article. There's nothing about the C specs that require procedures to set up a stack frame. All you really need to understand is scoping rules.
&gt; basically, do you need the object to live more than the scope in which it is created? If you only need an object to live for the scope in which it was created, you allocate it on the stack and don't use pointers at all. Right?
Yep, furthermore because there's no requirement for a stack frame, modern C/C++ compilers implement tail call elimination.
usually yes, except when you dont know what object to create until runtime (polymorphism) or you just want to allocate a raw array and you dont know the size yet. you might want to create a Car object or a Train object (both deriving from Vehicle) at runtime according to the way the application is running, only way to do this is by using a pointer and dynamically allocating memory (or by using smart pointers). that would look something like: void foo(bool train) { unique_ptr &lt;Vehicle&gt; vehicle; if(train) vehicle = unique_ptr &lt;Vehicle&gt;(new Train); else vehicle = unique_ptr &lt;Vehicle&gt;(new Car); //use vehicle at whill, and let it be destryed by itself }
 ptr = 0; ref = *ptr; // I don't believe this crashes, the compiler doesn't /need/ to deref it yet. ref.fn(); 
&gt; Moving from msvc9 to msvc10 resulted in some runtime crashes in some certain type class construction lists. (ie: object(data) : member0(data), member1(member0.somedata) {}). In case you didn't know, member0() and member1() above get called in the order of their definition in the class, not the order you call them in the initializer.
Exactly. This very well may result in a crash (depending on initialization order). It is often cited as bad practice to initialize one member with the data of another in initializer lists.
It's just been launched so it's too early to tell how successful it's going to be. I just want to comment on (c) - I think the price isn't high considering that it's more specific and in-depth than a book is likely to be. It saves a lot of time on research. Also, as you said, there aren't many books covering C++11. Personally, I'm happy to spend hundreds or sometimes even thousands of dollars on educating myself online, as long as I see that it's going to save me time or provide new opportunities. 
Aren't we all...
Since unique_ptr supports ownership transfer (it is movable), it's not restricted to one scope. However, the restriction is in the ownership (unique_ptr = ownership restricted to one pointer, shared_ptr = ownership shared among possibly multiple shared_ptr instances).
Nice example. I actually did something like this using auto_ptr (when unique_ptr was not available) where I received an auto_ptr from a factory. You can shorten the code by exploiting unique_ptr's reset member function.
I fail to see the benefit. Also, I'm a bit concerned to see the word "override" in combination with example code that has nothing to do with overriding. It's just scope-based name hiding since none of the functions in the base classes are virtual.
Thanks for that hint. The [FAQ](http://eigen.tuxfamily.org/index.php?title=FAQ) however says: "However, currently Eigen parallelizes only general matrix-matrix products (bench), so it doesn't by itself take much advantage of parallel hardware." I tried and found that matrix-vector products are not yet parallelized. 
Great, somebody has already done all the work! Looks like I will give [Armadillo](http://arma.sourceforge.net/) a try.
&gt; vendors like MS or GNU have added compiler specific extensions to benefit users. There is no benefit in changing main() to WinMain() or using PASCAL calling convention in the Win32 API (for example). &gt; Also the M in MFC stands for Microsoft. It makes business sense that they would want only windows users to benefit from the MFC libraries. You don't get it. Microsoft doesn't want you to use MFC. They want to drive you to other Microsoft programming languages. Microsoft doesn't make their own products using MFC. 
 &gt;There is no benefit in changing main() to WinMain() I really dont understand what your point is. You maybe confusing two things. WinMain is for Win32 programs, you can still write portable c++ code using visual studio and continue using main() as your process entry point. Its obvious that win32 programs cant use main as their process entry point. &gt;or using PASCAL calling convention in the Win32 API (for example). There is a benefit. A caller cleanup convention requires an extra instruction per function call to fix up the stack pointer after the function returns. &gt; Microsoft doesn't want you to use MFC. They want to drive you to &gt; other Microsoft programming languages. Microsoft doesn't make their &gt; own products using MFC. So dont use MFC. If you want to write windows GUI apps in c++ there are dozens of alternatives.
Are you perhaps thinking of Cinder? http://libcinder.org/
Yes, Windows Forms is the easiest alternative. They don't care whether you use C++ or not, just that you use it on top of one of their proprietary platforms. Using the Win32 API, MFC, or any other GUI platform Microsoft offers should simply depend on what level of control over your application you need, and how much time you're willing to devote to learning the platform. Convoluted or not, they're there for a reason. Whether or not you use it doesn't effect MS in any way anyway. 
order is retained properly (warning levels maxxed). While it may be "bad practice" it is perfectly legal and a compiler causing a runtime crash on that construct while not complaining during is a broken compiler.
if this is the last exercise of the series, i would start by reading all the previous ones. the exercises are meant to start easy and get harder... and if they dont do that, get a new book, because clearly they're not helping you.
If you're working on the Mac, Windows or iOS you might consider Cinder - http://libcinder.org/ It's a heavier dependency than CIMG or similar, but the things it brings in addition to image I/O are likely to be helpful to the rest of your project.
Why is your first instinct to use a framework? All you need is a single format, such as [PNG](http://www.nongnu.org/pngpp/). You can do conversion to other formats trivially with external tools. If you really want to skip libraries entirely, then forget BMP and [use PPM](http://www.reddit.com/r/learnprogramming/comments/nlph9/is_there_a_way_to_visualize_a_2d_array_as_a_color/c3a76a3) which is the simplest image format ever. Do the conversion to a real format using the tool of your choice. 
What about the good 'ol Boost with [GIL](http://www.boost.org/doc/libs/1_48_0/libs/gil/doc/index.html) and the [BMP extension](http://opensource.adobe.com/wiki/display/gil/Contribute+to+GIL)? edit: [EasyBMP](http://easybmp.sourceforge.net/) seems pretty straightforward too.
Why do people continue to post these sorts of questions? This is reddit. Get the pun? [i]read it[/i]. This is not a Q &amp; A forum for programming help. If you want that - try stackoverflow (and this sort of question will be close as not really a question). Are there no mods at all?
Just wondering, are you writing to files because you want to render high resolution?
Check out [Armadillo](http://arma.sourceforge.net/). It's about the nicest interface for matrix maths in C++ I've seen, and it does a whole bunch of optimisation via template meta-programming that removes a lot of the bloat that can crop up with this sort of coding style. It backs onto LAPACK, so any high performance variant of that should give you the performance you need.
Win32 GUI programs cannot use the regular main() function as their enrty point. They have to use the WinMain function. My point is that Microsoft does these small changes to C++ so as that programs written under Windows cannot be compiled for Unix, locking programmers and users in Windows. While there is indeed a performance benefit in using a Pascal calling convention, it is also a big vendor lock-in benefit. Microsoft did not have to use the PASCAL calling convention in every function of the Win32 api, because not all Win32 functions are performance critical. The reason all Win32 functions are PASCAL has more to do with not allowing the user code to be easily compiled in other platforms. You don't get the point. C++ is a fine language, but in order to turn users to Visual Basic, Microsoft had to make its major C++ toolkit a very low quality piece of software. Not only this drove programmers away from C++ and to Visual Basic, but also prevented MFC from being ported to other platforms. 
&gt; That makes zero sense. If you were going to target two platforms you would not be using native win32 api anyway. You already need to use some sort of portable GUI library. That comes after the fact that Win32 is not easy to duplicate on another platform. If Win32 was extremely well written and very easy to duplicate, some would be tempted to duplicate it in another O/S, so as that more Win32 programs are transferable to that other platform. &gt; There are probably thousands of function calls inside the OS code. Every function call would require a few extra bytes. Which idiot would intentionally use an inferior choice? Also these kinds of decisions were very important in the 90's when nobody had any cycles to waste. Even otherwise you are not forced to use that in your code. That is valid only for performance critical code. Most of Win32 functions are not performance critical. Even WinMain() is PASCAL (i.e. WINAPI), even if it is called once. &gt; C++ is the wrong choice for the majority of software. C++ is a systems programming language. Unless you're writing embedded software, high performance sofware, games, system libraries, etc, you should not use C++. Writing good C++ code requires a developer with decent programming chops (i.e. high pay). VB code can be written by anyone who takes some beginner programming course. You are very wrong on this. C++ is a much better programming language than VB, provided that the library you use is well written. As a C++ programmer and a VB programmer (both VB6 and .NET), I'd take Qt (the best C++ toolkit) over VB anyday. C++ got a bad reputation mostly because of MFC. At the time C++ was considered a hot language, in the 90s, MFC was advertised by Microsoft as the way to write C++ programs on Windows. However, MFC does not make proper use of C++. MFC actually misuses C++ to the point that people think C++ is a horrible language. 
How are you calling it? I'm guessing your not specifying the class like, class-&gt;static_func()
The issue with CIMG was that I couldn't get it to work. I will give Cinder a try. Have you tried using it with MSVC++ Express?
http://ideone.com/yOhED
I'm really not understanding what the problem was as I just compiled this program using multiple static methods and it worked just fine... #include &lt;iostream&gt; using namespace std; class StaticClass { public: static void method1(); static void method2(); }; void StaticClass::method1() { cout &lt;&lt; "Hello method 1.\n"; } void StaticClass::method2() { cout &lt;&lt; "Hello method 2\n"; StaticClass::method1(); } int main(void) { StaticClass::method2(); return 0; } 
&gt; And if method2() accesses a non-static private variable in StaticClass? How could that ever possibly work?... Hate to sound condescending but that's a pretty basic C++ concept. And it wasn't OP was asking about either (he was talking about invoking a static method from another static method in the same class)
&gt; And when invoking a static method from another static method within the same class, you don't think there would be any changes made to the object? **THERE IS NO OBJECT FROM WITHIN A STATIC METHOD**. I'm am bolding this because it is very important to understand when developing C++. Static methods "within a class" are only namespaced to that class, in every other regard they are plain old C-style functions. e.g. struct Foo { static void doSomething() { ... } }; could be essentially robotically converted to : void Foo_doSomething() { ... } with the exception of the difference in public/protected/private access rules. Even if you try to call a class static method through an object, no `this` pointer is provided to that static method. They are plain functions, nothing else, and so trying to change object member variables or class non-static methods from within a static method is *always* an error.
There must be something you are not showing us. Your code as posted should not generate an error.
http://ideone.com/kkO0U You have to use a non-static function to edit member variables of the class, but it can be done from within a static function. "It works very easily if you do instantiate the object with static member functions." The code is an example of what I meant.
Oh and thanks for trying to make me look like an idiot. I would have provided this code earlier if I was on a computer with a compiler before. Never mind that the OP's problem was solved. I am well aware that you can't directly manipulate private data members from within a static function, but you can make calls to non-static member functions IF the object has been instantiated. 
Deleting all your previous responses and then making one "ah-ha" comment dosent bode well for your understanding of Cpp....
Yeah... what does deleting comments on reddit have to do with my understanding of C++? I deleted them because I'm new on reddit and I thought the negative points on my karma would go away if the comments did. Clearly, I was wrong. That was a reflection of my misunderstanding of reddit, not C++.
I doubt the issue is Java. Are you using all the most aggressive JVM performance options? Contrary to popular belief Java numeric performance tends to be very, very good. 
If I were to venture a guess, it'd be no. Smart pointers would also invoke destructors which doesn't make sense for a function pointer. Also, in the case of virtual functions, function pointers are not necessarily the standard 32 bits but sometimes a data structure for the vtable, which would mess with the dereferencing. Why do you need to use function pointers? Especially with smart pointers?
Smart pointers are "smart" because it deallocates the space that the pointer points at. To have a deallocation you need to allocate something. But since function pointers are not allocated you don't need to deallocate them, thus negating the need for smart pointer for that memory space.
Smart function pointers doesnt really make any sense, as you dont have to (cant in fact) manage memory that is used by a function. Thus only 'dumb' pointers to functions make any sense. That said, the smartest of them would probably be 'std::function'. Its a pretty smart guy for being a dumb pointer. 
It's probably because of section 13.3.1 paragraph 5: During overload resolution, the implied object argument is indistinguishable from other arguments. The implicit object parameter, however, retains its identity since conversions on the corresponding argument shall obey these additional rules: * no temporary object can be introduced to hold the argument for the implicit object parameter; and * no user-defined conversions can be applied to achieve a type match with it. Function pointers are not classes; they have no implied object. Therefore, you're allowed to convert to them since that wouldn't introduce a temporary object. You might then ask "why doesn't this conversion happen if `operator()` is static, and therefore has no implied object?", but the standard says that member operators must be non-static, so that never happens. Also, it's easy enough to write `void Y::operator()(int i) {Functor()(i);}`, and that makes it explicit that you're acting on a temporary object, not yourself.
Thanks for this, this whole thing came up capturing the functions from the dlsym() function so I can register plugins similar to the [pugg project](http://pugg.sourceforge.net/doxygen/pugg_plugin_8h_source.html). I'm working in a Linux framework however.
When I first realized why my program was not compiling I suspected it was just something I was misunderstanding in the code. It makes sense that you wouldn't need smart pointers for things that aren't strictly objects, the whole thing kinda stuck in my head thou so I figured I would ask!
I'm modeling what I'm doing in linux off [this msvc code](http://pugg.svn.sourceforge.net/viewvc/pugg/example/Plugin/Plugin.cpp?revision=17&amp;view=markup). Getting it to work has been quite the learning experience so far, I expect a few more major issues will crop up before I even get to the point of being warning free (which won't be till well after I solve a namespace issue I'm having presently).
&gt; You have to use a non-static function to edit member variables of the class, but it can be done from within a static function. Sure, but it can also be done from *any* function, as long as rules on member public/protected/private rules are obeyed. You could just as easily declare some function in a completely different translation unit as a friend. 
&gt; This post was asking about "Static method invocation from within a static method within the same class." That's what I demonstrated with my first code sample! Why are we discussing other things then?
I've hit a few marks throughout that hurt, but what I'm actually trying to implement is the [nuclex framework](http://www.nuclex.org/articles/5-cxx/4-building-a-better-plugin-architecture). pugg supposedly is a reference implementation of it that was a bit easier to get my head around.
I'm not writing this as an msvc friendly code base, I'm moving it to linux. And I'm not doing ref counting the way they are in pugg, part of this whole effort is to get it moved to shared/unique ptr's as necessary. edit: thou you do bring a good point up about freeing the library I'm going to have to review that when i sit down with the code again, I could be shooting myself in the foot atm. edit2: looks like dlopen/close are ref counted as well so this advice holds true in linux, I should have realized that sooner.
I have no idea. You asked why I said what I said (even though it seemed to help the OP), and I gave you my reasons. They weren't good enough so I kept going until I got to a compiler to demonstrate what I meant. You can see in that code what I meant by changing class variables within a static member method. Also that instantiating the class is obviously required in order for it to work. 
Sorry there are just too many inaccuracies in your post that I'd rather just let it go than argue with you over it. Goodbye. 
I don't understand. You should represent your image as a big array in memory as you're generating it, so your WritePixel function would absolutely be just an array access. You only need to worry about writing to a file at the end when the image is fully rendered, and at that point it's just a simple loop to dump the contents of the array to whatever image format you're writing. 
At 16000x9000, the big array solution just doesn't work. When you're writing on to the raster then just write that to a file, you're taking advantage of the fact that Java natively writes the file for you. FAR more efficiently than going through a nested for loop to write to the array. Even if beneath it all there was just an array for the image, I'm pretty sure the makers of libraries and compilers made the methods I use to interact with that "array" very robust, very efficient, and completely beyond my understanding. 
I just spent the last 15 minutes writing a well thought out response. Then I realized that it really doesn't matter. I don't care about being downvoted at this point. You're not trying to help with my understanding of C++ , and should know that I'm very familiar with the fundamentals of object oriented programming, C++ or otherwise. You're arguing with me about the "spirit" of static methods? Code doesn't have "spirit". Someone said it wasn't possible, when I knew damn well it was, and I proved it. Do you think that it's a freak accident that it can be done in the first place? Notice one key difference: a static method can not change variables of the same object, it can change variables of the same class. The latter provides an exception to the former in that, if the static method is being called by an object, and passes itself to the function, the method may change the object itself. I don't make a habit of passing objects through functions _unless_ they are pointers to the object I'm passing. If I don't want them to be changed in the process I pass them as const. It really doesn't matter what class the method belongs to, or what kind of objects are being passed to it. P.S.: Just because you can't, off the top of your head, conceive of a reason to do something, doesn't mean there isn't one. 
1) you've hijacked 'remove' (set_remove_if) and applied it to an erase algorithm. 'remove' already has known semantics within the stl. Best if you don't do that. 2) You have 2 full implementations of your algorithm (member function &amp; non-member function). You should use mem_fun internally within the member function implementation and forward the call to the functor object implementation. 3) You're passing your iterators by value. You could possibly justify this in the case of using 'rangeBegin' as your increment target, but you aren't doing this. 4) 'itTest' defined at the top of the function. C might require this, in C++ it's considered better to restrict your locals to within the scope they are used. 5) You've tied your implementation to std::set twice (by function name and parameter declaration). The algorithm is applicable to multiset, map, multimap, unordered_map, etc etc. Drop the 'set_' from the name and generalise the template declaration type - just use T and drop the 'Key', 'Comp' and 'Alloc' template parameters. 6) Earlier in your post you hoisted the iterator declarations out of your for-loop and noted that it was likely to reduce the overhead as 'end()' would only be called once. This pattern (anti-pattern) is highly unlikely to affect performance in any meaningful way as the implementation of 'end()' is going to be inlined and the compiler is better at optimisation than either of us. If allowed to permeate your code this pattern could cause you to miss issues down the line when using container operations which invalidate all existing iterators (admittedly mainly std::vector). *edited * for formatting
Cool. If you want to get involved that'd be great! The mother project is a network confmgmt tool. LibIPvX is one of four libraries that need work before the tool becomes useable, and ready for release. But really, a central idea of this library is that it's portable to other projects too, given the commonalty of IP :) If you're interested in writing some code, send me a PM :) 
hey thanks for the tip.
If Microsoft developers needs this feature, there is a design problem in their application. I suggest everyone not to use non-standart features like this.
It would be better (instead of using raw disk I/O) to just mmap the file you're writing to and the let the OS take care of the raw disk I/O calls. This could also provide better overall performance than the totally in-memory array case.
Thank you VERY much for your feedback! :) You have very valid points. Regarding a couple points: 2) I wrestled with this very issue a lot. The team I work with doesn't use &lt;algorithm&gt; or &lt;functional&gt; at all. (I can't blame them very much since we don't yet use compilers that support C++ lambdas?) I am trying to ease them into it which is why I settled on keeping the member function overload instead of requiring the use of mem_fun. Now you're making me re-think this. I will have to discuss with a couple of the developers to see what they think will help adoption. 5) I originally tried to develop the algorithm to work with standard associative containers, however I came to point where dereferencing the iterator for std::map introduced a challenge. Which iterator member should we use -- key or value (first or second)? How does the user easily specify which one they want to use? This would be much easier to deal with if we had access to C++ lambdas, but we don't have access to those compilers yet. :( That's why I tied it to std::set. You're right though that the algorithm could be used for set, multiset, and unordered_set. I should change that. (And if you have any suggestions on how to easily make the code applicable to map, multimap, ... I'm all ears.) Also, the reason for the name was because remove_if was already taken and I was stuck with the idea that the algorithm was similar to remove_if. But you're first point is valid and I will be renaming the algorithm. Thank you again very, very much for you input.
Hey there! I'm looking at your github stuff, I think you're defintely talented and would make a great contribution to libipvx. Do you have gmail? what timezone are you in? Dan
I would recommend something similar to the second approach. Storing the smart pointer also saves you the hassle of manually cleaning up after the vector: std::vector&lt;std::unique_ptr&lt;base&gt;&gt; vec; vec.push_back(std::unique_ptr&lt;base&gt;(new derived()));
That doesn't work. You'll never be able to get the derived class back out of the vector, since it only has enough space allocated for the base class. edit: since this is a very important point for people to understand before they try this approach and fail, I'm upvoting you to get you back to +1.
Look up "slicing".
There's nothing wrong with storing a smart pointer; in fact your second statement is flat-out wrong. std::vector&lt;std::shared_ptr&lt;base&gt;&gt; vec; vec.push_back(std::make_shared&lt;derived&gt;());
I was all set to tell you that this is not supposed to work, but it works. I'm using g++ with "-std=c++0x". int main(int argc, char * argv[]) { std::vector&lt;std::unique_ptr&lt;a&gt;&gt; vec; vec.push_back(std::unique_ptr&lt;a&gt;(new a())); vec.push_back(std::unique_ptr&lt;b&gt;(new b())); for (int i = 0; i &lt; vec.size(); i++) vec[i]-&gt;func(); } This is managing to call virtual functions in the dervied class. I had read that this does not work because "std::unique_ptr&lt;b&gt;" is not derived from "std::unique_ptr&lt;a&gt;". I verified that the destructor for each element in the vector is being called when the vector goes out of scope, as well. Did I mess something up in some catastrophic way, or is this really the perfect solution? 
I agree that in the practical case it doesn't matter, but I think that I would like to do things right, because once you decide that not trapping an error is okay because it is hard to trap an error, it's easy to just stop trapping errors. I make the assumption that it's possible to write correct code in C++, without going insane. I'm just trying to find the way to do it. I treat everything I write like the mars rover, because bugs fucking suck, and when I tolerate one, it's a failure of character. 
With these smart pointers the destructor is bound during construction, so you will get the expected behavior in this case. What you read is correct, *myTemplate&lt;A&gt;* is an entirely different type from *myTemplate&lt;B&gt;* in the general case. The trick here is that *unique_ptr&lt;b&gt;* is convertible to *unique_ptr&lt;a&gt;* if b* is convertible to a*. Since b is derived from a, the latter is true, which is why your code compiles :)
The only reason I'd suggest ignoring it, depending on the application, is because another thing that sucks is over-design or over-architecting something that doesn't need it. If a programmer makes something that should be simple unnecessarily complicated, bugs will be harder to find. If, on the other hand, you roll with the assumption that you're not going to run out of memory and you end up running out of memory anyway, the resulting crash or unhandled exception will be *trivially* easy to debug. edit: Yes, I'm aware there will be hordes who disagree with me and who couldn't bring themselves to leave these kinds of loose ends, but I'm just offering my opinion anyway :)
Why don't you do: base * d = new derived(); vec.push_back(d); And if it fails, just ``delete d``? Or do something else? Anyway you still have ``d``.
One thought that struck me is that you are trying to handle an out of memory after it has occurred. You might be able to design your system so that this code is never called if memory is low. This pushes responsibility for the oom handling to the caller, who might be better placed to deal with it. 
What it comes down to is, is the "push_back(new thing())" idiom correct? And if it is not correct, what is correct? It turns out that it is not correct, so I just want to know what is correct. That's the point of this. I want to do things, and my brain is full of tools to do the things. If the tools are stupid, it make sense that I figure this out and change them, rather than using stupid tools to write wrong code forever. In the original example, it's a pain in the butt to avoid leaking. Pointers don't invoke destructors, so if you say ... Derived * ptr = new Derived(); ... in some function some place, you are screwed if you throw before you either put that someplace that has a destructor that knows to remember to delete it, or immediately do a try/catch block, and have the catch delete it. It has been my experience that people can't ordinarily say, "our error trapping model is to crash", but that is what ends up happening, and I want to know enough about C++ that I know how to program defensively in order to avoid that. Trying to fix this one problem, in a project that will likely never ship, has made me a better programmer, because I am more aware of problems caused by raw pointers now, and I can write a different line of code to avoid the problem. Why argue that I should write the old line of code instead of the new line, when the old line contains a bug, and the new one does not? edit: Wiped out on a word. 
If emplace_back fails, a and b will be deleted properly. emplace_back really is just syntactic sugar for what you're doing with push_back, it forwards its arguments into the unique_ptr prior to the actual allocation.
We're talking about C++ here, a language used in many embedded and critical/sensitive environments. Simply put you are not fucked because you ran out of memory, not even close. In my case I use C++ for the development of high frequency trading systems, and while it might only be 1 in a million where some fluke causes me to run out of memory, I have to ensure that scenario is handled gracefully instead of just throwing my hands up in the air and saying fuck it, just crash. The usual approach to this is to pre-allocate a chunk of memory right at program startup that you can use in case you run out of memory. This chunk is large enough to run any code you need to ensure a proper and safe shutdown, such as in my case cancelling any pending orders, submitting any final orders to settle an account, sending out any notifications that need to be sent and then when all that is done flushing out as much data as possible. All of this clean-up code runs strictly using the memory that was pre-allocated for it, including the stack space it uses (this is accomplished by reserving a thread to run this code in at start up and just having this thread wait on a condition variable to trigger it). The idea that running out of memory is the end of the world and you just give up simply is untrue of a lot of C++ system developers.
I fixed the word I missed in the comment you responded to. It seems to me like this is mostly about being exception safe or not. I'd rather be exception safe. I'm already looking at my code to try to program defensively, and it doesn't take a lot extra to try to understand these mechanisms so that I can program defensively in these cases as well. If I'm calling into code that I don't want to understand the inner workings of, i.e. most of the STL, and I'm leaving myself open to weird problems because exceptions can orphan hunks of memory, this is a larger problem that what to do if you run out of memory. In this case, it was an out of memory error, but in other cases, it could be an exception I'm throwing myself as a rational aspect of normal code. The notion of "allocate a pointer in auto memory and do something that is not fully trusted before saving it" is clearly a pitfall, and one that appears to be perfectly solved with "std::unique_ptr". Raw pointers in C++ are scary. I'll be using smart pointers a lot more often. PS. There is a lot of down voting in this thread. It's not me doing it. 
I don't think defects should be intentionally introduced into code, even if it seems intuitive that the defects will manifest extremely rarely, or that if they do, they will manifest trivially. If I start using that idiom, I will use that idiom every time I want to put a newly allocated polymorphic thing into a container. Since the idiom is defective, I may as well figure out what the right idiom is and stop using the wrong one. The right idiom is not that much more typing. 
This page explains some of this: http://www.learncpp.com/cpp-tutorial/44-type-conversion-and-casting/ As an aside though, it's pretty easy to write small programs to try and find the answer to questions like this. For example: http://codepad.org/aono8N0O 
Do you mean you want the value of a variable? If you wanted a constant then you'd just put it in your text! Using cout you'd do something like: cout &lt;&lt; "Text " &lt;&lt; variable &lt;&lt; endl; 
Additionally, if you want to assign some text and then a number (in another variable) to a string, this [link](http://stackoverflow.com/questions/191757/c-concatenate-string-and-int) will help.
damyan is correct. The string library in c++ is about strings. The stream libraries are about a wide variety of data types, so if you want to convert between text representation of multiple types, that's a better bet. 
Ok so here is what I have: const double CAR = 300; cout &lt;&lt; "Car Payment " &lt;&lt; CAR &lt;&lt; endl; 
I've tried [Armadillo](http://arma.sourceforge.net) with multi-threaded BLAS that's part of Intel's [MKL](http://software.intel.com/en-us/articles/parallelism-in-the-intel-math-kernel-library/) - works great. Simply enable use of BLAS in Armadillo and then link with relevant MKL libraries instead of standard BLAS. [ACML](http://www.amd.com/acml) from AMD may also have multi-threading BLAS. 
Yes, a locally declared std::vector full of raw pointers is another great source of errors, which are also avoided, with need for neither code nor concern, by std:unique_ptr. 
Alright thank you
Well, exceptions in C++ are usually, pretty exceptional. I wouldn't think of them as errors because they're generally nonrecoverable, like the one from push_back(). push_back() only throws an exception when it fails to allocate memory. If you are using your own allocator, chances are you've probably thrown one there first. If you are out of memory it's probably time to just kill the process anyways because it's going to fail on the next allocation. The elegant way to handle this is to not handle it, you're just cluttering up your code trying to catch these. 
Well, unique_ptr doesn't have a copy constructor either, but it has a move constructor.
Accelerated C++ by Koenig and Moo ? Effective C++ by Scott Meyers?
This 10 part video tutorial series is an excellent starting point for learning about the STL: http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Introduction-to-STL-with-Stephan-T-Lavavej/ It's effectively a tour of the "most useful" parts of the STL aimed at those familiar with C++ but with little or no knowledge of the STL.
Had to do this as 2...3...4? separate posts - Reddit doesn't like long posts :( *edit* aha! Reddit doesn't like code :) unless it's indented struct Eg { Eg(int val) : val_(val) {} int val() const { return val_; } bool fn() const { return val_ % 1; } bool operator&lt;(Eg const&amp; rhs) const { return val_ &lt; rhs.val_; } private: int val_; }; bool EgTest(Eg const* eg) { return eg-&gt;val() &amp; 1; } template&lt;typename T&gt; T const* extract_value_ptr(T const&amp; valtype) { return &amp;valtype; } template&lt;typename T, typename K&gt; T const* extract_value_ptr(pair&lt;K, T&gt; const&amp; valtype) { return &amp;valtype.second; } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, typename T::iterator begin, typename T::iterator const&amp; end, F const&amp; fn) { while (begin != end) { typename T::iterator tmp = begin++; if (fn(extract_value_ptr(*tmp))) container.erase(tmp); } } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, F const&amp; fn) { erase_if(container, container.begin(), container.end(), fn); } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, bool (F::*fn)() const) { erase_if(container, container.begin(), container.end(), mem_fun(fn)); } int main() { set&lt;Eg&gt; egset; map&lt;int, Eg&gt; egmap; erase_if(egset, &amp;Eg::fn); erase_if(egset, &amp;EgTest); erase_if(egmap, &amp;Eg::fn); erase_if(egmap, &amp;EgTest); return 0; } 
It is not cluttering the code to use "unique_ptr"; that is what it is for. It totally solves this, appears to have no down-side, and allows other code, which would otherwise be necessary to write, test, and remember to call, to be removed. Why do languages bother to have error trapping mechanisms if people insist that it is hopeless to use them? There is no convincing argument not to use "unique_ptr" other than that people are not used to using it, and they are not used to using it because they write idioms with defects in them without thinking about them, regardless of whether or not they are creating bugs that really will manifest. This is just a more modern incarnation of the "buffer overflows do not matter" attitude that C programmers got away with for decades. 
http://www.sgi.com/tech/stl/stl_introduction.html (it's also an excellent reference).
Came here to recommend the same, upvote: it's old but still very relevant. 
"Concept" is current C++ terminology for "a set of type requirements" (See the section "Concepts and Modeling" of http://www.sgi.com/tech/stl/stl_introduction.html ). You are referring to a proposal for a way to declare a concept in a program, and have the compiler enforce it.
Well, that is just seems silly. I would expect that the associative containers' methods would return similar types. I wonder why that is. Yes, you're correct. But it is a surprise to me. Go figure.
With regards to my earlier reservations, I suppose I could do something like the following. (Please note that this doesn't compile; But I think you can sort of see the direction in which I am trying to go.) struct Eg { Eg(int val) : val_(val) {} int val() const { return val_; } bool fn() const { return !!(val_ % 1); } bool operator&lt;(Eg const&amp; rhs) const { return val_ &lt; rhs.val_; } private: int val_; }; bool EgTest(Eg const* eg) { return eg-&gt;val() &amp; 1; } template &lt;typename T&gt; struct examine_value { T const* operator()(T const&amp; valtype) {return &amp;valtype;} }; template &lt;typename K, typename V&gt; struct examine_value&lt;std::pair&lt;K, V&gt; &gt; { V const* operator()(std::pair&lt;K, V&gt; const&amp; p) {return &amp;p-&gt;second;} }; template &lt;typename T&gt; struct examine_key { T const* operator()(T const&amp; valtype) {return &amp;valtype;} }; template &lt;typename K, typename V&gt; struct examine_key&lt;std::pair&lt;K, V&gt; &gt; { K const* operator()(std::pair&lt;K, V&gt; const&amp; p) {return &amp;p-&gt;first;} }; template&lt;typename T, typename F, typename E&gt; void erase_if(T&amp; container, typename T::iterator begin, typename T::iterator const&amp; end, F const&amp; fn, E const&amp; examine = examine_value&lt;typename T::value_type&gt;()) { while (begin != end) { typename T::iterator tmp = begin++; if (fn(examine(*tmp))) container.erase(tmp); } } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, F const&amp; fn) { erase_if(container, container.begin(), container.end(), fn); } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, bool (F::*fn)() const) { erase_if(container, container.begin(), container.end(), mem_fun(fn)); } template&lt;typename T, typename F, typename E&gt; void erase_if(T&amp; container, F const&amp; fn, E const&amp; examine) { erase_if(container, container.begin(), container.end(), fn, examine); } template&lt;typename T, typename F, typename E&gt; void erase_if(T&amp; container, bool (F::*fn)() const, E const&amp; examine) { erase_if(container, container.begin(), container.end(), mem_fun(fn), examine); } int main() { set&lt;Eg&gt; egset; map&lt;int, Eg&gt; egmap; map&lt;Eg, int&gt; egmap2; erase_if(egset, &amp;Eg::fn); erase_if(egset, &amp;EgTest); erase_if(egmap, &amp;Eg::fn); erase_if(egmap, &amp;EgTest); erase_if(egmap2, &amp;Eg::fn, examine_key&lt;std::pair&lt;Eg, int&gt; &gt;()); erase_if(egmap2, &amp;EgTest, examine_key&lt;std::pair&lt;Eg, int&gt; &gt;()); return 0; } 
Wrong link. [The right link is here](http://www.cppstdlib.com/sopa.html). Frames, in 2012‽ I guess his website hasn't been updated since the late nineties?
What a badass.
They probably have reserved right of first refusal on future works. He can probably choose another publisher after some time period. Can't say for certain though, speculation only, IANAL.
I want it all already; back to work, standards body!
[r/learnprogramming](http://www.reddit.com/r/learnprogramming) is the place to post questions such as yours.
Been anxiously awaiting this new edition for the past year. In fact just before it got announced I almost bought the first edition, after years of not being able to afford it. It's too bad that I will have to wait longer, and there is a possibility that it won't be released at all, but it's all for a good cause. Good on Josuttis for speaking up against his publisher.
Doesn't work with C++, what is it even doing here?
There seems to be several things in D that are being proposed. Ranges, numeric separators (though I imagine other languages have this too), and static if are immediately recognizable. I've been wondering how much influence D had on C++11. It's certainly had some influence on the proposals for this next version.
... Your company has a policy against templates? Sorry, dude, that must suck. I'm sorry for your loss. I don't have any suggestions for you, just those few words of sympathy.
Thanks :S I'm trying to get them to use templates and STL. Their reason for not using STL is "It's not thread safe." so they then go and create the same containers (just non templated) also not thread safe! *palmface*
Must be a games company. They suffer from reinventing-the-wheel-in-c-style something bad.
it's actually a multimedia driver company ;)
I suppose that this policy was made around 1995, and never modified.
&gt;However are coding policy is that we cannot use templates... My first reaction is that whoever is responsible for that policy should be drug into the street and shot. Then the non-asshole part of me thinks that there has to be some reason (outdated compilers, compile times, code size, readability, debugging, the Torvald's "how does it map to assembly" argument...). I'm interested in the reasoning behind this. &gt;Are there any mature libraries that have linear algebra or even math &amp; data structures BLAS and LAPACK are pretty much de-facto standards with many different implementations available under many different licenses. It's heritage goes back to the '70s so its API is mature to the point of being archaic. Many of the templated C++ numeric libraries are implementations of BLAS functionality, or are direct wrappers over a C or FORTRAN BLAS library. If templates aren't allowed, you probably want use a C or FORTRAN BLAS library and/or write your own C++ wrappers if you want to go OO. I haven't used BLAS or LAPACK directly, it's always been through wrapper libraries or templated implementations, so others may be able to give more detailed advice.
My initial gut feeling was also that static_if is out of place in C++. As if we are inviting #ifdef into the heart of the language. Atleast before it was not let indoors but was kept outside with all the other wild dirty animals. But the examples in the proposal look neat.
Sound like a different way for them to say "I'm too great to learn my tools." Whoever made that argument probably doesn't understand templates, the STL or "thread safety". At least work them up to templates. Avoiding the STL because of "thread safety" may be somewhat defensible, but why the prohibition on templates? Guilt by association? I hope they at least pay you well...
&gt; "It's not thread safe." So no **int**s, either?
blas/lapack can be a huge PITA for cross platform. win32 builds have always been a huge PITA for these. I notice there's some pages on win32 ports but those look to be non trivial requiring you have lots of compilers available.
I'd get the policy changed, or ask for a rational explanation or leave. First there is always the possibility of a rational explanation though I don't know what it would be. The no templates because they aren't thread safe may be valid or it may just be an excuse shipment one dreamed up because they don't understand templates. Sadly it is more likely somebody doesn't understand or like templates than a rational excuse existing. Just don't dismiss that they might up have an excuse. In any event I'd seriously consider leaving the organization if they can't offer a sound technical justification for their policy. Let's face it c++11 is here now, to stay at this place of employment for too long will significantly impact your skill level in the long run. 
My wish for a future C++: A proper module system, preferably one that allows a file to contain both interface and implementation parts. Get rid of the antiquated #include system.
EASTL is a good example of games companies love for reinventing the wheel, badly. They could have extend STL or used boost. But they had to go and write their own non-standards conforming clone. EA is not in the data structures and algorithms implementer business. They cant hope to maintain and optimize this library as well as a company like EDG and microsoft or a big thriving community of experts and computer scientists like boost. I doubt a fair review would find any performance gains (you cant compare debug checked iterators against release versions). Now with the rest of us using the improved and extended C++11 standard library, EASTL is stuck forked off old C++98 land. 
I believe they are just typedef from templates
As I said: &gt;EA apparently had good reasons to [reimplement good portions of the STL](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html) **beyond NIH**. While NIH may have played a part, that document I linked explains [many more reasons](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html#Motivation) for going with their own implementation, some of which may no longer be true almost five years later. C++11 wasn't an option five years ago and still isn't on all platforms they develop for, and Boost isn't an STL implementation. Extending the STL is effectively what they did. I think the memory alignment issues are illustrative. How would you have addressed that problem in 2005? How about today on the PS3?
&gt;"It's not thread safe." That's quite odd. As pointed out by bitrex, even ints are not thread-safe (depending on the architecture and the size of the int). STL is very upfront about exactly which functions need to be guarded to make them threadsafe. Honestly STL is no harder to use in a thread safe manner than anything else. In fact, building your own container classes you'll almost certainly have *more* thread safety issues than with STL. This seems like a very misguided policy, or at least an amazingly poor justification.
The proposed module system ([pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf)) should take care of this. It indeed has interface and implementation as two sections of a single file.
&gt;Leveraging c++11's rvalue references and implicit std::move helps a lot with performance of these type libraries if you write them to be readable. I'm not up on this; how so?
Intel math kernel library
Well I guess it's more a question of tradoff. Getting them to work properly can be a bid development effort, and we'd rather put that effort into other things. And the perceived benefit is quite small. We make extensive use of asserts and such - I guess we try to spend time fixing the causes of problems rather then thinking about how we'd recover from them. But to be honest, I'm probably not the best guy to ask about exception handling. We don't even have the discussion about whether we'd do it.
been using these 2 for years now. stdint.h for file and memory io. no short, int or longs anywhere. it helps a lot with portability.
The reason you're finding it difficult to find such libraries is because there's no good reason to not use templates, so libraries just use them. What you need to look for are C libraries, such as RyGuyinCA suggested.
D is the Plan 9 of programming languages: Not widely used, but a ground for experimenting with new features.
How can the two types both be large enough to store the maximum size of an object? The C standard, atleast appears to disagree with this claim: http://functional-orbitz.blogspot.com/2011/07/c-gotcha-of-day-ptrdifft.html
Oh google ... you never fail to [impress me (pdf)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3340.pdf).
I'm not sure if you're agreeing with me or not, but just to save my rear a quote from the OP: &gt; The type's [ptrdiff_t] size is chosen so that it could store the maximum size of a theoretically possible array of any type. However I can't agree with what you said here: &gt; So ptrdiff_t is not guaranteed so be large enough to store the maximum size of an object, because it has nothing to do with object sizes. Certainly `ptrdiff_t` is related to sizes in some way. What happens if I create an array whose size is the maximum value of `size_t` and then subtract `&amp;arr[MAX]` and `&amp;arr[0]`? That difference is the size of the object and it is unrepresentable by `ptrdiff_t`.
Actually templated code is pretty much the fastest way to do it in C++. Which is why linear algebra C++ libraries tend to use templates. :P
Actually, I posted that link. Saw this post, looked up his website, saw his SOPA stance, posted link to proggit... got post deleted for non-programming content after nearly 1k upvotes. Oh well, at least it got the word out.
ptrdiff_t is just about friggin useless. Taken from N1570, the C11 final draft &gt; When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object; the result is the difference of the subscripts of the two array elements. The size of the result is implementation-defined, and its type (a signed integer type) is ptrdiff_t defined in the &lt;stddef.h&gt; header. If the result is not representable in an object of that type, the behavior is undefined. In practice though, user allocations are less than the maximum size of the address space. 32-bit systems only give 2GB to the user anyway, so signed integers are wide enough. Likewise, 64-bit systems do not use all 64 bits (48 or so?) for physical address space.
Yes. That's what I'm saying. Speed is a major reason to use templates. That's why Blitz++ (and all the followup libraries like Boost.uBLAS, Eigen, etc.) were able to beat Fortran.
You need to point out the difference between the STL and the rest of libstdc++. collections and algorithms are fine to use. The mess, especially with false thread contention comes from std::string (cow forms) and the iostreams train wreck, especially with the locale penalty.
Aha. Sounds like a pretty good idea, thanks for explaining.
It works fine here: http://codepad.org/2JDwyYjY It is possible that optimizations are occuring that prevent the destructor from being generated or called if you are doing this test in release mode. 
Well like someone pointed out the "destructor" would be called on the pointer (which being a pointer doesn't have a destructor, but you get the idea, just like if ints were being stored there - PODs or "plain old dataypes" don't have explicit destructors). Just think about the common usage of containers of pointers to other objects. There might be many containers all having pointers to the same objects. You wouldn't want the objects that they are pointing to to disappear if one of these containers was cleared.
ok so - pointers themselves doen't have destructors, but what it points to does (the end portion is obvious to me, but the first portion isn't/wasn't). Am I stating that correctly? Is there a write up of this for more info? Googled a bit and will still try, but maybe there's one handy. thanks again
Pointers can point to anything, not necessarily a class that has a destructor (ie. ptrs to primitive data types). If you think about it, the collection only manages things of the type that is defined, so if you say std::vector&lt;T *&gt; it doesn't manage the memory for T, but only T *, and it doesn't make any assumptions as to how T needs to be cleaned up. Not to mention that if you have more than one reference (ie. 2 lists each with a ptr to the same object), then the collection can't call the destructor without knowing that the other reference is not in use. If you instead used smart pointers (which you generally should be if you're doing C++), the ref counting on the smart pointer would trigger the destructor on the object that is being pointed to as expected.
Just think of all the types in C before classes and destructors, etc. None of those things need destructors because the language/compiler knows how to clean them up. Once you start creating your own types it doesn't know what to necessarily do. These types are PODs: http://en.wikipedia.org/wiki/Plain_old_data_structure Similar to the case of a vector of pointers to objects not freeing up the actual objects being pointed to when the vector is cleared, there is the case of a destructor with a pointer to an object in the class. When the destructor is called only the pointer is cleaned up (the classes own data members), what the pointer is pointing to is left alone.
I'm not sure what you are asking. Do you want to justify right?
Been there, quit that. They wouldn't let us use STL because it's slow and "not mature enough" (that was 2 years ago). And then they made us write a map container in one day - it was "faster", "maturer" and had no bugs! *palmface*
Destroying the address in your address book does not necessarily imply that the house should be torn down, so C++ does not tear down the house, even if to *you* the address book is specifically a list of houses to tear down. You can manually manage this, or replacing "push_back(new CFoo())" with "push_back(unique_ptr&lt;CFoo&gt;(new CFoo()))" is likely a better way to do this, since the "tearing down" idea is built into that class of smart pointer.
I probably would not recommend this book to a "complete beginner". But for me, this book was very useful and I think this is due to my previous programming experience. So, yeah, if you have years of programming experience and want to learn C++, this book should be on your radar. But I do like AC++ as well.
One good rule of thumb is that if you had to call `new` explicitly to create something then you're on the hook for a corresponding call to `delete` (which will call the object's destructor.) Moreover, if your container only holds pointers and you delete the last copy of the pointer to an object without deleting the object itself, then you've just leaked memory, as that object still exists but you have no way of referring to it. In general you should think really long and hard about using raw pointers in C++. There's probably a better way to do whatever it is that you're trying to do. 
It's still [not exception safe](http://herbsutter.com/gotw/_102/). 
Yes I need to put the input spaced over. Is there any way I could do that?
&gt; so far so good The problem is, you have no means of gauging just how far off you are. Your question in this thread is really a basic question that you should have known from any good C++ book. C++ is not a good language for a "Try It And See" mentality. I can tell you from experience, I have met many people who have taken this approach and their actual C++ understanding has been very lacking. If you feel it is working for you then I'm in no position to tell you it isn't, but history suggests C++ is a language much better learned from a structured approach.
Got it. Thank you.
If a PDF link is a problem for you, your setup is broken.
[Relevant](http://www.reddit.com/r/sex/comments/oss2q/my_girlfriend_is_always_masturbating_in_the/c3jrwvi)
It's not a problem, more an annoyance. Like unintentionally opening a video file. Then I have to wait for it to load, and in this case open an external program. I'd rather save it for later when I have more time.
When I click on the link, Firefox merely asks whether I want to open or save the file. I just press "Esc"; no waiting is involved.
I would be curious on what anti-patters you could find in [ROOT][1]. This is the major framework used in High Energy Physics experiments (i.e. the software build to find the Higgs will most likely use it). The results should be interesting since it was developed by people with a Physics background (not CS) and has seen a lot of fixes lately since it is part of Coverty's OSS program. Still, I suspect there are probably many glitches left since it evolved from a rather quick-n-dirty design from the early days of C++. There is an option to build with `cmake`, but I cannot test your requirements for Visual Studio (no Windows machine in sight here). [1]: http://root.cern.ch
http://wxwidgets.org/
http://opencv.willowgarage.com/
I second this wholeheartedly. And somehow I'm a little afraid.
Linux? UNIX? Windows? Username of what?
If it did destroy the object referred to by the pointer, then it would be impossible to put a pointer to an object in two containers at the same time, which would rather defeat the point of using a pointer in the first place...
It usually exists in a environment variable on the relevant system. This [SO](http://stackoverflow.com/questions/631664/accessing-environment-variables-in-c) page might help.
These are tools frequently used in scientific computing: http://icl.cs.utk.edu/lapack-for-windows/VisualStudio_install.html I'm a bit confused about your tool because I wasn't aware of anybody using Visual Studios, the future is GCC or if you have money ICC.
cin &gt;&gt; username;
&gt; I doubt I'll get a chance to do an implementation for you today (have to earn a crust) but if you have trouble give me a reply/PM and I'll knock one up over the weekend. I'm sorry I haven't replied earlier. I've been quite busy with yearly performance reviews. I understand what you're saying, but I'm having a bit of trouble translating it into code. if you do have free time and could knock something out quickly, I'd be really quite interested in learning the trick. Thanks again for all your feedback!
[GetUserName](http://msdn.microsoft.com/en-us/library/windows/desktop/ms724432%28v=vs.85%29.aspx) (Google search string for future reference: "msdn get user name", with msdn refering to the Microsoft developer website)
Well, this might not be the same league of projects as others mentioned here, but I am wondering how Battle of Wesnoth would pass the test. After all, it's an open source game which is used by many as a base for their games or at least as one of the projects for analysing game engine design. 
Try [HippoMocks](http://www.assembla.com/spaces/hippomocks/wiki). I'm interested what it can make of it especially as it toes the line of what you can and cannot do (and quite often oversteps it knowingly). I'd love to see in how far your software sees what's going on. 
The basic idea is to extract the type of the target of your test function - this is already done in the erase_if wrapper which takes a member function (F::). For the case where the test function takes a reference to the target the 'examine_type' specialisation extracts the correct type. The 'examine' struct is then specialised with std::pair both ways round to match the determined target type. struct Eg { Eg(int val) : val_(val) {} int val() const { return val_; } bool fn() const { return !!(val_ % 1); } bool operator&lt;(Eg const&amp; rhs) const { return val_ &lt; rhs.val_; } private: int val_; }; bool EgTest(Eg const* eg) { return eg-&gt;val() &amp; 1; } template &lt;typename T&gt; struct examine_type; template &lt;typename T&gt; struct examine_type&lt;bool (*)(T const*)&gt; { typedef T type; }; template &lt;typename M, typename F&gt; struct examine { M const* operator()(M const&amp; valtype) const { return &amp;valtype; } }; template &lt;typename K, typename M&gt; struct examine&lt;pair&lt;K const, M&gt;, M&gt; { M const* operator()(pair&lt;K, M&gt; const&amp; valtype) const { return &amp;valtype.second; } }; template &lt;typename K, typename M&gt; struct examine&lt;pair&lt;K const, M&gt;, K&gt; { K const* operator()(pair&lt;K, M&gt; const&amp; valtype) const { return &amp;valtype.first; } }; template&lt;typename T, typename F, typename E&gt; void erase_if(T&amp; container, typename T::iterator begin, typename T::iterator const&amp; end, F const&amp; fn, E const&amp; examine) { while (begin != end) { typename T::iterator tmp = begin++; if (fn(examine(*tmp))) container.erase(tmp); } } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, F const&amp; fn) { erase_if(container, container.begin(), container.end(), fn, examine&lt;typename T::value_type, typename examine_type&lt;F&gt;::type&gt;()); } template&lt;typename T, typename F&gt; void erase_if(T&amp; container, bool (F::*fn)() const) { erase_if(container, container.begin(), container.end(), mem_fun(fn), examine&lt;typename T::value_type, F&gt;()); } int main() { set&lt;Eg&gt; egset; map&lt;int, Eg&gt; egmap; map&lt;Eg, int&gt; egmap2; erase_if(egset, &amp;Eg::fn); erase_if(egset, &amp;EgTest); erase_if(egmap, &amp;Eg::fn); erase_if(egmap, &amp;EgTest); erase_if(egmap2, &amp;Eg::fn); erase_if(egmap2, &amp;EgTest); return 0; } 
Your game looks awesome! Have a read of "Effective C++" by Scott Meyers, it does a superb job of explaining the little gotchas and nasty details of C++ by showing you examples of common pitfalls and explaining *everything* that is going on in a clear and concisely written style. I think I learned more from that one book than from every C++ class I ever took in college. 
ACE framework http://www.cs.wustl.edu/~schmidt/ACE.html
I know they do not fit your build requirements but both Boost and Qt would be good candidates where an improvement would benefit a huge number of projects using them.
This would be a great one to try.
Figure 4 is terrible. The code is correct, because it checks for _M_X64 first, but the figure incorrectly claims that _WIN32 isn't set for Win64 code. Furthermore, checking for macro definitions is wrong, since some compilers set one macro to 1 and the others to 0, it is necessary to check the macro value and not just presence.
I don't know what is your goal but if you want your library have a lot of users (even for commercial software for exemple) you should chose a more permissive license than GPL v3. The current license is ok if you want it to be used only by free software (or strictly internal software). 
It would be very interesting to see what your tool thinks about sqlite codebase.
Already: [Qt](http://www.viva64.com/en/a/0075/).
Awesome job!!! :) The only complication that I can see is is someone wanted to use the algorithm on the following: map&lt;Eg, Eg&gt; egmap3; erase_if(egmap3, &amp;Eg::fn); But we don't encounter that in our project and I can't think of a good reason why someone would want to do that.
map&lt;string, string&gt; rather than a custom user class highlights the issue with this more effectively... (as I think it's more likely to happen in real code) You'd have to have a think and try a few use cases of how you'd like to make it easy for your users to grok - possibly erase_if_key/erase_if_val functions. 
Thanks, I saw this document as well. Sadly, the regex `/concept.*&lt;.*template/` matches no example or sample in that document. It is quite an interesting read though. I'm surprised as well at the lack of concept inference -- in Haskell I need only write `let f x = x * x` and `f` is assumed to be (translated into C++ syntax): template &lt;Num T&gt; T f(T); Where `Num` is [defined](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num): concept Num&lt;Eq T&gt; requires Show&lt;T&gt; { T operator+(T,T); T operator-(T,T); T operator*(T,T); T operator-(T); T abs(T); T signum(T); T fromInteger(Integer); } That is, it inferred from my use of `+` that I was using the Num typeclass. Of course, Haskell doesn't have operator overloading to deal with -- operator `+` is only defined for Nums and nothing else. ... Being a library writer in C++ is going to get a lot more formal. 
I admit I don't know Haskell, But you are right. I cant see automatic concept map inference from operator to concepts working in C++ when operators can be overloaded and where operator "+" work for different concepts like iterators and numbers. I guess there is bigger point that a types syntax is not enough information to map a type to a concept, that there is semantics not captured in syntax. In the old proposals there was some debate about concept maps .. and to what degree they should be automatic or manual. But it was all rather verbose ... I guess that is what the new proposal is about. Avoiding concept maps by defining some fundamental axioms. But I just skimmed the document also. If you are into c++ concepts ... here is another new article I have not read yet: http://cpp-next.com/archive/2011/12/a-breakthrough-for-concepts/ 
Nope. That's undefined behavior. [It's a violation of the aliasing rules](http://www.reddit.com/r/programming/comments/ov41t/stupid_float_tricks/c3kho2d?context=3) to access the value of a `double` through a `long long *`. Don't ever do this. Permissible alternatives include a union or `memcpy()`.
Plus the union version will almost always be easier to read.
You may find this helpful: http://altdevblogaday.com/2012/01/05/tricks-with-the-floating-point-format/
&gt;Permissible alternatives include a union or memcpy(). And don't forget how the endieness of the processor affects your results.
Thanks, I'd read that article already too, which confirmed my earlier suspicion that polymorphic lambdas were axed for no (theoretical) reason. Dave Abrahams is a smart guy, and it's certainly a non-trivial problem to work out, but I was confident that a solution was in close reach if only the effort was available. I understand the practical reasons, of course. Unfortunately that article shed no light on higher kinded concepts either.
GCC warns about this in many cases thankfully. Don't know about MSVC or clang.
We're going to need more info here... what's the name of the library you want to set up? Do you actually *have* the library (.h and .a files)? Do you have any knowledge of linux in the first place or is all this completely new to you?
Oh boy. I see you have absolutely no idea what you are doing. I'm going to try and help anyway, but I'm not really sure how far we can go here. I've downloaded the source files linked on the website in your description... I see one of the later chapter's programs has a "game.cpp" file in it... is that what you are working on? It looks like that is using all standard libraries except for wxWidgets (as evidenced by the "#include &lt;wx/wx.h&gt;"). If that's what you need, you can probably get it through your package manager... what distribution of linux are you using?
I was just about to link you to a page I found with instructions for this, but it looks like [snarkhunter](http://www.reddit.com/r/cpp/comments/oxb4k/graphics_question/c3ks8cs) found it while I was typing. That page should probably be all you need.
Yeah I just clicked on it and ran the bloody program. Thanks for the assistance! :D
Designed to cater to the younger, mediocre kids. Just as benthecoder said: "If you aren't enjoying coding in general, maybe you shouldn't be a programmer. I don't need "achievements" to get satisfaction when coding." 
stdafx? auto_ptr? No CMake? Also there is not really anything in terms of functionality yet. You shoud try to get something substantial that works first. Then make a library out of it.
Hi, Are you looking at the repo under thefoss project, or under my user? all the auto_ptr stuff is gone 
thanks for the CMake idea, that's a great little tool that i hadn't heard of ;) 
hey thanks, looking into it i agree it's a bit restrictive. i think the LGPL might be more suited? considering i want it to be included in commercial projects whilst retaining the open-ness of the library itself?
Hi! Thanks for the tips! I am not a c++ programmer so I tried... I'll try to check over that! I did not know it was an undefined behaviour hehe! Easier to do VHDL and FPGA :)
Trust me, there are more than 4 errors. 
Could you be more specific about his misconceptions.
In order to help you out, I am going to list everything that is wrong with your code, in order of appearance. * Preprocessor directives like "include" are required to have a "#" prefix * You aren't using iomanip at all, so don't include it. * You aren't being clear how your data is presented...the argument to your function is an array of standard strings. Usually a string is stored as one standard string or as an array of chars. * You declare your recursive variables globally. * You declare A twice, once as an array of strings, once as an array of characters. * You initialize the array of characters as...something. An initializer list containing a constant string? I don't really know what that is supposd to be. * main should be declared int main(int,char**) * A doesn't exist in main, unless you are referring to the global one * countvowels(A[index]) is the correct function call syntax, but you are passing A[index] to it, which is a character not a string. * Your cout statement prints the text and not the value of the variable. * system("PAUSE") is considered harmful * EXIT_SUCCESS is good, but requires you to include cstdlib * if(A[index]==0) doesn't make sense, because A is an array of strings, then A[index] would be a string * A[index]=='a' .... is not part of any if statement, so the entire thing does nothing. * A[index]=='a' || 'e' || 'i' .... is not how you compare to multiple things at once...that happens to be valid syntax, but it doesn't do what you think it does. The correct thing would be A[index]=='a' || A[index]=='e' ... * return countvowels(A-1) makes no sense, because A-1 makes no sense. A is an array of strings. Even if A was a string, you still wouldn't be able to subtract one from it. 
Ah, I kinda got carried away, really there is only one part related to the lesson (using recursive functions) I'll snip that out.
&gt;* main should be declared int main(int,char**) Both int main() and int main(int, char **) are valid declarations of main in C++. Since he isn't using command-line arguments, his declarations is appropriate. The rest of your comments stand.
Side note: never post screenshots of code. Use pastebin and post the actual code, so that it can be copied and pasted. The answer is that when you use the extraction operator to read a `short` from `cin`, that consumes input up until, but not including, the newline. At the point after `cin &gt;&gt; sc3` there is still a newline in the input stream, which is read by `cin.get()` immediately. If you want to wait for a keystroke -- which, by the way, is extraneous and not necessary if you run the program properly -- then you need to consume that newline character which you can do with the `.ignore()` method. 
If by "won't stay open" you mean "the window closes at the end of the program", then that would be because the program itself opened the window, so it of course doesn't need it anymore when it terminates. Try running the program from an already open command prompt. EDIT: Sorry, I think I missed part of your question, though Rhomboid has provided the correct answer here so I won't go into detail about that. But still, you really shouldn't be running a command line program like a standalone application. You should always launch these types of programs from a command line.
There *is* no difference, that's the thing. I even e-mailed it to my teacher and he said that it should work just fine. Running it without debugging produces the same result--it asks the three questions, then will display the average for about quarter of a second and then close.
I can, and that actually works, but we're not supposed to use it.
Well I'm just a beginner as well so I can't help you any further unfortunately, but if the teacher said it was fine then I wouldn't worry about it.
Either remove the endl before the cin.get() command, or throw a cin.ignore() on the line before the cin.get(). 
Putting a decimal number into an int will truncate (important: it will **not** round) the number down to the whole number before the decimal. Use a float or a double to hold decimal numbers. 
First, integers. Integers are whole positive or negative numbers - 3.5 isn't an integer, but -42 is. Note that when you say 'int D' the compiler assumes this is a signed integer - another type is 'unsigned int', which essentially means it's positive. Details for another lecture. Given that, what happens when you do something like: const int E = 3.7; Well 3.7 isn't an int, it's a float or double (I forget honestly). So how does it take a float and stuff it into an integer? Well, as luck would have it, C++ has certain conversions readily available, this being one of float to int. In this case, I believe it will truncate the float, so 3.7 becomes simply '3' when you try to assign it to an integer. Float vs double - the difference is precision. Each variable is only so many bytes internally. With an unsigned integer on 32 bit architecture, the largest number you can store is around 4 billion (2^32). Floats are different - there are an infinite number of numbers between 0 and 1. A float is less precise than a double. So if you take a long decimal, such as 3.1415926535897932384626433832 , put it into a double and a float, then output both, the double will be closer to the original number, although both will slightly off. In simple programming projects, use one or the other, and just stick with that. Lastly, you argue that X, Y, and Z aren't what you expected, but how can we know what's going wrong with what you have above? When asking for help, list or link the whole program (if small) **with formatting**. You have no idea how annoying it is trying to debug programs without formatting. Hopefully someday you will, keep at it :)
So D E F are constants I define when writing the program. X Y Z are variables that the user will input once the program is compiled. Both use decimals/floating point numbers. Using "float" didn't store the floating point numbers or the decimals and neither did "double" for either constants or variables... it rounds them to the nearest whole number.
Could you show us the whole code? It would be easier to understand where the mistake is.
In the end, the people most willing to post something on a topic are those who least likely should (lol irony). Just like how most c++ blogs and websites are astoundingly early undergrad, the majority of posts that are questions here about c++ will be as well. I don't know about you folks, but I'm not subscribed to a news site about c++ to listen to every undergrad's first semester questions. Google searches, textbooks, and professors abound. Up-to-date news about c++ does not. 
The type of the constants in your code is `int`, not `double`. There is an implicit conversion double --&gt; int, i.e. you can assign a double to an int without any type cast expression. Most compilers will emit a warning, though, since you lose precision and not all doubles can be represented as int. 
As incursus already recommended: use cin.ignore(); cin.get(); to wait for a keypress. **Explanation:** *cin &gt;&gt; value* will wait for a complete line of input, but only read as much as it needs from the input. The "return" you hit at the end of the line becomes part of the input (usually a `\n` == 0x0A in ascii) . So after you enter a number and hit return, it reads the number from input, the return remains unread. The next *cin &gt;&gt; value* first includes all whitespace - this is, space, tab, line breaks etc. Then it reads the second value. Again, your return remains in the buffer. The same for the 3rd *cin &gt;&gt; value* cin.get() only reads one character from stdin. You will get the return (or anythign you entered after the number on the last input). `cin.ignore()` simply throws everything away that's still in the input. **Experiment** try to enter all three numbers - separated by a space - on the first input. Here's the output I get for this: Score1:1 2 4 Score2:Score3:average is 2.33333 Why? **Commentary** In my opinion, istream/ostream do their job, but they need a lot of micro controlto make them user friendly (or even work as intended). Welcome to C++, though: puzzling behavior that's completely logical after a lengthy explanantion is a common pattern here. 
I'm sympathetic - but there isn't much to be done about it. I personally downvote a lot of pre-elementary questions - I note that this reddit often has most of the top new stories in negative numbers - and perhaps as this place matures we'll get more. 
[Effective STL](http://www.amazon.com/Effective-STL-Specific-Standard-Template/dp/0201749629) hands down. I already had some experience under my belt when I read it, and it did resolve my "STL shun". Easy to digest, well, written, interesting, and takes you way beyond containers. 
I looked at the HEAD of master of the github repo at the time.
On the "carrot, not stick" side, it's worth noting that StackOverflow has a really excellent C++ community. Maybe one of the last excellent communities left over there.
fuck you asshole
I agree with this completely. There doesn't seem to me to be any reason why we should be pushing new users away from this subreddit. If someone asks a question that can be answered here, great! If it can't or an answer already exists on SO then it doesn't put anyone out to make a pointer in the comments. &gt;Since i do not know anything about the administrative side of a subreddit: Isn't there somekind of way to move questions to /r/cpp_questions? I'd be happy to answer questions/give advice (as far as my limited knowledge allows me to). Basically, no. 
In my (limited) experience with C++, a new line command before a cin.get(); causes the program to "skip" the cin.get(); when it runs. It's like the program sees the new line command as the keystroke that would normally be required to take you past the cin.get();. The cin.ignore(); fixes this, but removing the endl should also work. 
There is plenty of news about C++ around, i follow Sutter's and other gurus blogs, boost developments, various related twitter feeds, stuff coming up in libraries in Freshmeat, C++11 progress, modern C++ books coming out, parallel C++ trends etc etc. I agree that beginner questions should go elsewhere, and stackoverflow is designed for that - but even there there should be a low barrier of just "did you even google it ?"
I tried your suggestion and couldn't get it to work. It still compiles, it just doesn't hold the decimals. I'm really puzzled. Thanks for the pastebin tip, I'd never heard of it!
The difference between two pointers is the length between them, that meaning is imparted by the standard.
[Here](http://pastebin.com/Pz3h0s0a) is what I tried. Try to run it and we'll see from there.
I got through a course in C++ and I would still be scared to ask a question on stack overflow. I might ask a question on there after working in C++ for 5 years....
Grrr, DrDobbs apparently can't make a decent mobile site. I get forwarded to the home page :-(
Yeah such a shame. Works fine for desktop browsers.
Why would you be scared to ask ? It is there for that purpose, and lots of people would jump gladly at the chance of answering a few simple questions sometimes and getting the points or badges or whatever for it there.
I hate those sites that do that. :-(
No problem, I'm glad it works. Your problem is that you used the wrong variable at some point. You used (x-(y/(D*z)))*(x+(D**z**))-E/(F*y) Instead of (x-(y/(D*z)))*(x+(D**x**))-E/(F*y) You should be all set now!
Just because there aren't many "news" articles on C++, it doesn't mean we should water things down with non-news articles. I especially don't appreciate "help me with my homework" kind of questions. They normally have a generic "Help me with C++" or "I have a C++ question" subject so to actually figure out what's the questions you have to go and read the body. I don't bother.
TIL that the C++ I'm using has lambda expressions. 
The article mentions the costs of std::function, but I wonder - shouldn't move semantics take care of unnecessary deep copies? Why don't the implementations use move constructors?
For my taste the examples are more complicated than they have to be. For example: double a; double b; // ... struct { const double&amp; a; const double&amp; b; } p = { a, b }; [&amp;p](double x){ return p.a * x + p.b; }; can be shortened to [&amp;](double x){ return a * x + b; }; All the std::cref nonsense is as unnecessary if you simply capture your stuff by reference ([&amp;]).
Yes. The gnu C++ compiler that I downloaded a few weeks ago has it, or something approximating it. g++ -std=c++0x That's a zero. Whatever it is, it ate this: std::for_each(itBegin, itEnd, [&amp;](CFortune::CSeg seg) { mapOrder[seg.First()] = mapOrder[seg.Second()] = undefined; } ); and produced correct code. 
Agreed. I think its difficult to actually get someone to do your homework in terms of source code. The 'educational entitlement' of most of the programming forums (fora?) i have seen so far is to remind the OP to do exactly this (post some code) and then help out with debugging, which for me does not classify as cheating.
&gt;class CSlideBarGroup Judging just by naming convention, its pretty obvious something is amis there. CSlideBarGroup::CSlideBarGroup(CSlideBarGroup&amp; Group) { new (this) CSlideBarGroup( Group.GetName(), Group.GetIconIndex(), Group.GetListBox()); } And this one just phisically hurt. Dont do this people ... please.
It makes it unfriendly to people that are too lazy to actually troubleshoot and research their problem. To the end that is unfriendly, the closed answers that are duplicates generally have one or more links to answered posts that accurately answer said duplicate.
Perhaps more about how initializer lists can be used would help here. Where this idiom falls flat is for const data members. I see you touched on the delegation from the new standard which is good. But for that example wouldn't a default parameter be the obvious choice?
Of course, you can often use the default parameters. But the article about something else. I wrote about this way so as not to distract the reader from the main theme.
I usually go one step further with my lambdas. [&amp;](const double &amp; x) -&gt; double { return a * x + b; };
A double is a float with more accuracy. For your purposes, either should work. Floats are typified by a decimal point. The compiler will use ints until it sees that it is using floats, so if you want to make sure, use constants that include decimal points. For example: cout &lt;&lt; 2 / 3; will display "0", which is likely not what you want. If you say: cout &lt;&lt; 2.0 / 3.0; the compiler will know that you mean floats and you'll get "0.66667" or something similar. It takes some getting used to. "2 / 3.0" works, as does "2.0 / 3", but: cout &lt;&lt; 2 / 3 + 1.0; will output "1.0". When in doubt be explicit, and use the compiler to answer questions. 
Ah I definitely overlooked that. Everything is currently working as I need it to. Thanks so much for your responses and help!!
The point of that example is that when your lambda captures a reference to a single struct, rather than capturing each variable individually, the resulting closure object is smaller and can be efficiently stored inside `std::function` without heap allocations.
Great idea! . . . . Unless you're using COM...
What is the end game here? Sometimes, when I see someone asking for something that doesn't make a lot of sense, the problem is that they are trying to do something that does make sense, but not in a way that would do it... Perhaps if you told us why you wanted to be able to do this, we could advise.
How many c++ programmers are there? I would hope most are trying to stay current with their knowledge of the compilers and libraries they are using.
Interview question?
Thanks for the link! This is exactly what I need. I'm still somewhat shocked that in 2012, this isn't already in the standard library or even boost.
Boost ASIO has robust http client implementations as usage examples. You can use one of those as is, or customise to send/process extra headers if needed. Once you start getting the response back, boost/property_tree has a working JSON parser. This should cover your needs. Once you get it working, maybe you can optimise the parsing via a Spirit-based parser, and clean up the example ASIO client. 
Not being thread safe is huge for me. I'm working with a brilliantly written templated thing (not a C++ expert) and it just fails. Googling now for info on templates and threading, as I wasn't exactly sure where the problem was. Thanks. [edit] this doesn't seem to be an issue actually.
You don't need a network library (i.e. sockets), but a HTTP client library. As `kouteiheika` said, libcurl works pretty well.
This is a quality of implementation issue. Compilers are encourated to implement capture-by-reference of stack-allocated objects by storing a single pointer to the stack frame in the closure object. To my surprize, GCC (up to 4.6.1) does not yet support this kind of optimization.
Minimizing network traffic is one of the main benefits of bulk fetches and inserts/updates. I believe all the APIs for commercial rdbms engines; Oracle (OCI), IBM (DB2/CLI) and SQL Server (ODBC) support bulk operations. 
Sure. But as with any library, the abstractions make all the difference in the world.
I think deservedly so. It's just surprising to me that this software hasn't existed for years. It feels very late-to-the-game to me. Regardless, I'm very thankful for the pointer and am happy to have a good library to use.
Thank you for posting the link to urdl. I've been messing with cpp-netlib most of the day trying to compile against it and now I've given up. VS2010 / Boost has something weird going on with iterator compatibility testing. urdl on the other hand was spitting back rest responses within 5 minutes of downloading it. It's very simple to use and understand.
You messed up your formatting. Don't you kids ever read your own fucking messages? [See also this thread](http://www.reddit.com/r/cpp/comments/p0a3h/please_direct_entry_level_questions_to_stack/).
I've given up with cpp-netlib. After messing with it for most of today I've been unable compile a debug build that doesn't crash after hitting some incompatible iterator check. There's something weird going on with VS2010 and Boost. Release mode works fine though. Somebody else posted a link to urdl and that is working very well for me. 
C &amp; C++ work off of millions of libraries (curl for example), but they tend to be very careful about adding bad code just to have a richer set of functionality in the standard libraries.
silverlight, boo! chrome's native mode stuff looks pretty promising even if its only x86 for now.
Make an object that contains a member variable and a member function that calls itself recursively. edit: I answered the question because if it's an interview question it's a bad one, if it's a homework question it's a cruel one, and if it's just a question there's no harm in answering. The answer I gave gives room for some creativity on implementation in either case. Also, if my answer is dumb, maybe someone will say so and I'll learn something. 
For fetches network traffic can be minimized using pre-fetching. ODB enables this feature if the underlying database supports it (e.g., Oracle). As I mentioned above, when using bulk operations, there are a lot of database-specific restrictions on the buffers that can be used to send/receive the data. Just as an example, with ODB you can persist a class like this without any problems: class person { public: std::string first_; std::string last_; }; However, if we were to support bulk operations for this class, then we would have to bind the first_ and last_ members as buffers for the corresponding columns in the underlying statement. Obviously this cannot be done for std::string (not for fetches, at least). So one would have to use the "native" buffer instead of std::string, something along these lines (using Oracle OCI as an example): class person { public: char[200] first_; sb2 first_size_null_ind_; char[200] last_; sb2 last_size_null_ind_; }; Would you be ok with using something low-level like this? Another alternative would be to still declare the first version of this class and use the so-called "image type" which is generated by ODB. It is essentially the low-level, "buffer" equivalent to the original class. We could also do copies. For example, for fetches, you pass a vector of person objects, ODB makes an equivalent vector of images, binds that to the statement, bulk-fetches the data to the images, then copies the data over to the vector you passed. What do you (or anyone else, for that matter) think?
The reasons for using Silverlight are made clear in the comments on Herb's post.
Calling main is forbidden by the standard. Otherwise should work.
We should *encourage* those to also try find help elsewhere - simply because of the rather low throughput here. Pushing them away might not be the best for ths subreddit.
If you mean 'high-level' seriously there is no way around [The Elements of Programming](http://www.amazon.com/Elements-Programming-Alexander-Stepanov/dp/032163537X/ref=sr_1_1?ie=UTF8&amp;qid=1328126632&amp;sr=8-1) by Stepanov. Although the stdlib is not fully implemented the way envisioned here, it gives a lot of insight into design decisions.
You need to look at [POCO][^1]. BOOST is also nice, but forces you to a slightly lower level. [^1]: http://pocoproject.org/index.html
Not so much, I don't see how flash isn't a solution but silverlight is. Whats the major difference between the two except that flash is widely supported and more stable probably. Html5 I can understand. 
Glad you were able to solve your problem, but please next time read the sidebar: &gt; **For C++ questions, answers, help and advice see [r/cpp_questions.](http://reddit.com/r/cpp_questions)**
Try Poco. It is designed for that.
I've done some work on tiny microcontroller systems that didn't even have an OS beyond "after-boot-jmp-to-some-address-and-go". It sounds like you are arguing that C++ needs to be a lowest common denominator language and I disagree. Not every C++ implementation implements the entire standard. In fact, does anybody other than Comeau even try to? 
Interesting. I covered most of what he said in a postgraduate computer architecture course, and while he explains the current situation very well I don't agree with all his predictions. While assuming that we will start to slow down drastically from Moore's law is probably good from an efficiency engineering standpoint, the same prediction has been made several times over the last 30 years too. The definition seems to widen, however - where it is currently based on transistor size, number of cores, etc we will probably see a move to compiler/language technology providing the benefits and other areas we probably haven't discovered/mastered/implemented cheaply yet (e.g. better cooling technology, transistors made from other materials like graphene or diamond, IC level photonics, memristors.) In terms of compiler technology, there's all kinds of things we can explore that aren't commonly used at the moment.
What Dascandy said! A struct is a class. Just add a constructor and/or methods. 
This could get really complicated depending upon what you want to do. If you are trying to solve the general case of creating an enormous data wad of diverse objects by reading in stuff from a file, this has likely been solved or discussed somewhere. If you are just trying to make one kind of thing that initializes itself base upon a string, you can make a constructor that takes a string as a parameter, and sets up the object based upon what you learn when you parse the string. For example "x=5;y=6;name=bill;" would not be hard to parse.
I am doing the former, I've handled the rest of it already (I think) or at least can handle it. I want to take each line in turn (which is an object definition in this other code) and get the various paramters of this definition into some distinct variables so that I may make many copies of said code, adjusting/subsituting values to produce a large dump of code from a template (which is what I am reading from here and decoding) and a list of other attributes.
Read a constructor as "when this function finishes this object is what its name says it is" and a destructor as "when this function finishes this object has ceased to exist and was all cleaned up properly". If your construction fails (due to some reason) you throw an exception. Net result is that when you have a line of code SomeObjectType someObject = SomeObjectType(); after this line of code you either have an exception to catch (and a try block around this) or a valid usable object. When this gets natural, you'll notice that it makes the code a lot easier to read. Also, the destructor is called *automatically* for objects that are on the stack, when you exit their stack frame. So, in the above case you're guaranteed to not forget to delete that object.
I agree exception handling should be introduced, but for the time being I think I'ev cracked it... but the code still won't compile. Is there any reason that converting a string into an int using stringstream will not work inside a class? compiler seems to have a problem with me using stringstream(string) &gt;&gt; int (declared in private section of class) edit: lol, my stringstream issue was a missing ')'. Think I'm all good now, thanks man!
ok, new problem. Now my class works great, trouble is I want to perform the function multiple times (decoding many lines of code with this). I set my constructor to do the work, so it happens on declaration. I can't declare the same thing multiple times so I've either got to use pointers or not have a default constructor and call the function each time with the new value. Is the latter the best way? edit: clearly is, did it all by myself *sunglasses* Thanks again for your help. 
Is each line its own logical thing, as in, equivalent to a single struct full of data? Can you post the code or something equivalentish?
Another interesting data point could be running MySQL/PostgreSQL on Windows too. 
Yes, the most widely quoted feature that was only present in Comeau used to be export template. This feature has been deprecated in C++11. And it is a core language feature. All other major vendors shipped complete standard library versions including TR1. Almost all are approaching full library support for C++11 (minus the bugs that are still to be discovered). 
I personally forgive them because I don't know what the state of platform independent streaming is like. You just missed Alexandrescu on variadic templates by the way, great talk. I recommend checking it out when they put up the downloadable videos.
Alexandrescu's slide with the gasp rageface made my day.
Move semantics, awesome
As a matter of fact, iostreams suck for pretty-formatting numbers. You'll want to use [Boost.format](http://www.boost.org/doc/libs/1_48_0/libs/format/) or something like that. 
Why does this 7-month old rant reappear? (See [other discussions](http://www.reddit.com/r/cpp/duplicates/p6dnl/strncpy_just_say_no/))
I'm not sure that I'd want to point beginners at Boost when they're just getting their heads around what a loop and a variable is. It's pretty frustrating seeing the tasks that these students are being given. It's as if they're designed to give them a tour of all the worst bits of C++.
Don't use `endl`. It's ugly, weird, and verbose. It flushes the stream, destroying performance. It makes code harder to understand, because so many people use `endl` for no reason that you'll never spot the places where the flushing behaviour is actually necessary. Just use `'\n'` (or `"...\n"`).
It is probably in there because it's in Stroustrup and all the other classics, and it was supposed to make show superiority of C++ - by making an ugly problem typesafe. &gt; (Example for the ugly problem: &gt; if (rareCondition) printf("%s", 12); ) I, too, find iostreams ambitiously designed, not quite living up to those ambitions and hard to use in the sense that it's easy to get wrong (ios:fail/bad/eof). Some of this is due to underlying complexity, but still. With variadic templates in c++0x, printf and equivalents can be made type-safe (for a limited number of arguments also for earlier versions), so it boils down to a matter of taste.
False and irrelevant, respectively. By the C++ Standard, effects of endl(os) are: "Calls os.put(os.widen('\n')), then os.flush()." In other words, it's explicitly defined in terms of putting out '\n' to an ostream (here: to an ostream "os"). No additional guarantees are made compared to '\n', including but not limited to no cross-platform portability guarantees. Note that (from the link you've provided): "When writing a file in text mode, '\n' is transparently translated to the native newline sequence used by the system, which may be longer than one character." In general, the use endl should be restricted to very specific cases when you want to flush the buffer in addition to putting the '\n' to an ostream; by default, if your intention is just to put '\n' then you should do just that.
Unfortunately, streams are completely useless for any real-world applications. There's no way to store a "sequence of calls to &lt;&lt;". Often I want to _look up_ a format string and then apply it - no way to do that for &lt;&lt;. This goes from being a nuisance to being end-of-game for internationalization issues. &lt;&lt; forces the order of arguments to be the same as the order of output - and that's often not true in other languages.
Use printf() for now, introduce IOStreams later (maybe when you're covering file I/O).
Mildly cleaned up: http://codepad.org/XzBWhdNN The really right way to do it would be to have the width &amp; precision stuff be per field attributes so that said code could be cleaned up further. The primary advantage you get is that it is easier to encapsulate formatting logic and ensure type safety (think about what would happen if one of your %f's accidentally became a %s").
Then just use a variadic templated type safe printf. 
&gt; ten year old knowledge Twenty year old, actually. C++98 was already far more advanced than that. Actually, if C++ teachers knew about the C++ of 1998, instead of the C++ of 1990, it would already be quite great. If you want to actually learn C++, your best bet is Accelerated C++, by Koenig and Moo. It's still by far the best introduction, even if it predates C++11. 
Day 1 was awesome. Looking forward to tomorrow's talks.
What do you mean that it will conflict with BSTRs defined in all other libraries? if there is another library where there is also a BSTR typedef, the original code wouldn't have compiled anyway. 
I strongly recommend that people use iostreams when learning C++. Printf aggregates everything that C++ was created to remove. It uses variadic macros, strings to decode the input from void*. All three of these are considered bad. Where as iostream is an example of everything C++ added, polymorphism, function overloading, operator overloading... The next key issue is that streams allow you to easily specify the text form of a custom class. For example std::string is not a primitive type but it can be 'streamed' std::cout &lt;&lt; my_string; you have to call c_str() to use it with printf. furthermore you can extend the functionality. class my_class{ int a,b; }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const my_class&amp; mc) { os &lt;&lt; mc.a &lt;&lt; mc.b; return os; } then from this point in you can just do std::cout &lt;&lt; mc &lt;&lt; std::endl; This is very powerful. The down side is the error feed back you can get from streams can be very awkward and specifying format require to you diving into &lt;iomanip&gt;. They can also become very verbose, for example std::cout &lt;&lt; "volume: " &lt;&lt; gallons &lt;&lt; "g" &lt;&lt; std::endl; instead of std::printf("volume: %d g", gallons); but as previously mentions once you start dealing with complex types this is no longer true. The reason you may see printf in production code is a lot of them time good chunks of it are ported from C which has to use printf, and it is strongly advised that you don't mix iostream and printf. Finally, it would be nice to see then tidy up iostreams or replace it with another C++ solution (using variadic templates for example) however in it's current for it is definitely preferential to printf
Not (completely) possible if the format string is a variable.
Good point.
&gt; furthermore you can extend the functionality With one addition: if you try to access private members of a class (like in your example) you have to declare `operator&lt;&lt;` as a friend inside the class else the members won't be accessible to the function.
For normal (non-bulk) operations we bind the above-mentioned image type and copy the data between the image and the actual object (except for certain cases of LOB/long data which go directly into the object). Such images are cached (along with the prepared statements) and are bound only once, so this works very fast. To employ this approach for bulk operations we would have to allocate an array of such images, not just one. People who want to use bulk operations in the first place are probably very performance sensitive and may want to optimize the client-side overhead as well. So the extra memory and copying can be problematic. I guess we could by default use the image array/copy approach so that one can use a nice object interface but also allow the use of an array of images for hard-core optimizations.
.. someone pointed out that you could hook up to the media player stream with VLC. By the way, were there any C++ announcements yesterday, from Microsoft? 
Would you really want to do that? The job of `operator&lt;&lt;` is to format the visible state of an object. If it needs access to private members, maybe the class's public interface is lacking?
&gt; Would you really want to do that? Sometimes, yes. You can even argue that you want to do it most of the time. &gt; The job of operator&lt;&lt; is to format the visible state of an object. Not exactly. Its job is to put a representation of the object into the stream. That representation does not have to be only what's publicly exposed. &gt; If it needs access to private members, maybe the class's public interface is lacking? Maybe, maybe not, but that concern is somewhat orthogonal as the interface affects the usability of a class and doesn't inherently have anything to do with how you serially represent that object. Consider the case when you serialize the object to be stored in a file or sent over the network in order to be reconstructed later, something that might be done to save the state of a game, for instance. Here, all members are extremely important as they represent the actual state of the object, but a good interface would not expose every single member; that completely violates the principle of data hiding. Furthermore, a well-designed class isn't simply a container for members to be set and retrieved via functions. The majority of functions in a well-designed class will actually *do* something meaningful, utilizing its members to accomplish the goal, all without the caller having any need to know what's inside the class. As such, formatting using only the public interface would also do work, potentially much more than serializing the internal state directly. It may help to think of friends not as something external to the class, but as part of the public interface of the class. See also, [this](http://www.parashift.com/c++-faq-lite/friends.html) and questions 15.8-9 [here](http://www.parashift.com/c++-faq-lite/input-output.html#faq-15.8).
Why not just rewind, it's just one keypress? Also use the mplayer scaletempo filter and speed it up.
The secrets are: 1. `future`s, `mutex`es, and `condition_variable`s use the Microsoft Concurrency Runtime, not regular Windows threads. 2. The VC11 beta has range-based for loops, even though it wasn't announced beforehand.
I can't quite remember which books I tried reading before. This was 9 months ago before I started to learn C#. I've just recently started brushing up on my C++ skills for a job I'm hoping to get and I'm trying to further my knowledge (the project I'd be working on is quite large so I'd like to know everything I can). Can you spell out the two books you mentioned? Google searching the abbreviated names are giving mixed results. :/
Just one thing to keep in mind. With great power comes great responsibility. Its pretty easy to turn your codebase to shit by indiscriminate use of templates (well, could probably be said about any feature). Also, most of template magic will probably be used only in library code (as in, generic stuff that doesnt do anything, but helps you to do so).
Yes using templates, especially &lt;algorithm&gt; and &lt;iterator&gt; has immense power and should change your programming style for the better. The graph is innacurate. I find myself now becoming aware of certain deficiencies in certain implementations and look for better ones. Of course c++11 compliance substantially shrinks the field. And then there's issue where stupid template tricks make code truly illegible and break all sorts of compilers (boost for one).
Part of being an advanced c++ programmer is the realization that object inheritance is grossly overrated and overused and should be avoided unless absolutely necessary. And then you notice java and c# force everything into inheritance (the 90's just won't die!)
A good book on design that has a more mathematical undertone is Stepanov's* [Elements of Programming](http://www.elementsofprogramming.com/). If you want to get really good with writing generic code, I would give his book a read. *The guy who created the C++ STL.
A meta template is a technique used to instantiate templates which can be passed around as parameters to other templates. It's pretty useful for doing things like creating parametric policies. A basic example of a meta template would be say a policy class for unique ownership of a resource, like so: template&lt;typename Deleter&gt; struct UniquePointerPolicyMetaTemplate { template&lt;typename T&gt; struct apply { typedef std::unique_ptr&lt;T, Deleter&gt; type; }; };
Gotcha: IntelliSense won't recognize the range-based for loops!
I believe you. Can you please elaborate?
Consider the books in the answers here: http://stackoverflow.com/questions/112277/best-introduction-to-c-template-metaprogramming Incidentally, there's also some useful stuff here: http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms
Disclaimer again ... I made a post longer than I thought and a little off topic for those focused only on C++, I have to stop this shit ... Sorry OP for the parasitic message :/ You can skip the cool-story-bro by getting to the TL;DR (goto TL;DR :D)... The way I've learned programming language is actually a little weird ;). When I was younger (far before getting into EE school), I was mainly doing basic EE stuff (kind of amateur projects for kids, low skill level kits etc.), and I came to a point where I had a PIC16F84 and didn't what the fuck I was doing ... So after frying it (obvious ;) ), because I didn't have enough money to buy anything else or a real programmer, but the internet was slowly coming alive (that shit was expensive here :/), I got an emulator and coded a full automation project in PIC ASM, which worked the way I intended on the DOS emulator but I never completed the real thing unfortunately. I don't remember but by then I think I also had somewhat designed the schematic for the electronics that should have gone with it. Not to brag or anything (ok maybe a little :D) but I was 14 at the time ;). So after that I got a little too much into gaming, which brought me on one side to some beginner stuff with delphi, and on the other to some PHP stuff for guild management. But then I was pretty bored with delphi and wanted to be able to use a powerful language for game programming, so I chose to start learning C++ without even knowing C before, everyone was saying that it was an enhanced version of C, so that was better, right ? (when actually it changes so much the way you program that they don't have much to do with one another other than syntax, except when you just use C++ as obj. C). So from there I programmed my first LCD controller over I²C over parallel port in C++, made with scrap components I had, and I found more rewarding to have built a real world device that I control than just doing stuff on the screen (though I still enjoy that). So I made my own parallel port PIC programmer at this stage, from components taken from an old motherboard (for signal buffering), and started actually programming in C. Also did some python stuff that was not well received by some stupid open source developers, but fuck those guys. THEN I went to EE school with pretty lame boring programming courses where I knew pretty much everything, which is even worse when you're forced to be present there, and C++ was obviously taught by someone who had zero experience in real world applications. There were even errors in the C class test that passed on GCC that the C teacher thought would create an error, or I taught another one that did "practical" class that you could do multiple value assignments in the same enum, etc. That's not even talking about the electronics stuff because I can always rant about that shit too. **TL;DR**: I learn PIC ASM, then bases in delphi and PHP, then C++, then what I can do in C from the C++ background, then get into EE school and rage there while learning on my own other languages. So in retrospect I think that as long as you don't think that because you know 1 language you know everything in programming, anyone can be a good programmer in any language really, and it's absolutely true that the more you understand the underlying principles, the more you'll have a chance at creating good programs, because you won't even need to remember the details of the top level rules, you can just deduce them (e.g. vtables). It's actually critical in embedded systems, and the reason why a lot of EE development never switched to C++ really: you have to master C++ to understand all the possible ramifications your code will have in terms of processing power and memory usage, even static, you don't want a constructor to be calling code when you're not expecting it for example. On a PC you don't really care about that, you can just profile that shit away if it poses a problem afterwards. *"Unfortunately"* I have a tendency to like to use the features of the language I'm using, by just actually looking for them ("there's no way what I'm doing can't be automated"). So from experience I ended with very powerful macros in C for example that showed me what I wrote in the previous post. For example I used a two level [X macro](http://drdobbs.com/184401387) system for a pretty big enumeration that was being reused in multiple parts of the code to avoid copy-pasting everything all the time. This way there was actually NO possibility to get desynchronization between the files including it, no need for an external code generation script. This would give the guy who did that template graph a hard-on probably, BUT I understood what price you pay by doing that OTOH, and the exact same thing happens with C++ or another flexible language sooner or later. Also the more languages you know, the more likely you are to get frustrated by lack of feature I think. I have a hard time handling stuff like java and python without getting frustrated for these reasons, but I perfectly understand what are their strengths as well. For example, if someone has only coded with static typing in small projects, he will probably only think of it an outdated annoyance when in fact it's incredibly powerful just from a development point of view. I have done PC to embedded control with python (pretty much forced to) and a program that stops sending commands to the motion controller in the middle because you made a typo in your script and have to restart everything is VERY annoying, and sometimes even worse than that. You end up having to either do a typing system in python (lol) or trying to catch and recover from everything (lol too), or the only real solution: catch and stop everything else that was still running. 
I suggest you read all the best practice books by Scott Meyers and Herb Sutter. In my opinion they will help you more than any patterns book. Patterns are quite OO centric. OO has fallen out of favor in C++, in favor of generic programming. Make sure you know STL like the back of your hand.
&gt; OO has fallen out of favor in C++, in favor of generic programming. Can you elaborate on that please? 
Huh. I've always been incredibly pro-OO in C++ and C#. I'll research this a bit and see if I'm overdoing it a little.
Yeah, this is one Microsoft project that I'm willing to give plenty of a chance. It will be interesting to see if GCC or others implement this.
You mean, like C++/CLI and Office Open XML?
Spec looks more reasonable than most of MS's C++ specs lately. It actually makes sense, contains some details (2.3.1 specifically) that I was hoping for in its intro and seems to be well thought out (at least, the part I read). I do think more work needs to be done to get this properly rolled out on targets and I think AMD should pick up a major part of the work within their fusion program (as it's a direct extension from that). As a generic thing, it seems to be allowing functions / function pointers to be tagged for a specific target or subset of targets in that the target implementation is optimized for that target and restricted to what's possible on such a target. They include cross-tag calls (to more restricted calls for example). Will have to take another look tonight, but it seems like a clever idea.
This is completely untrue. It very useful in the case of being able persist data to different storage locations by simply adapting an iostream interface on the storage. Most orm use this concept. My day job uses this concept as well to persist data objects between xml, json and byte streams. It is also very useful for structured data and the reader not having to understand the underlying data structure, the object knows its own format.
Yes, but does it have enough real-life use cases? What type of applications are targeted here? It looks like there are already whole lot of solutions, like Direct Compute, OpenCL, Cuda, OpenGL thing, and their usecases overlap 100%. Is there room for this as well? All of these are pretty limited in usage anyways, just having C++ doesnt seem like such a big improvement to warrant ditching current solutions. But then i could be wrong and it could be 'big' indeed.
C++AMP is in an entirely different league to DirectCompute, OpenCL, and CUDA. C++AMP conceptually sits at a much higher level than any of those libraries - kind of akin to where OpenMP is on the stack (except much less of a hack than OpenMP is). C++AMP gives you a high-level way to express your problem in C++, and it's the compiler's job to compile and parallelize it for whatever the target platform is - be it GPGPU, cluster computing, computation on the cloud, or just plain old multicore CPUs.
In /r/cpp no less.
I thought that the primary goal of node.js is to allow you to write in javascript. I.e. it is not only an easy webserver.
I was vaguely aware of "printf() is bad" but no one had ever explained why before (I had no idea that you could manipulate it to read/write from the stack like that). Thanks Andrey, excellent article.
So it's just a reactor pattern in C++?
There is no reason to avoid native threads in C++. If your server is swamped by multiple connections, then either put it behind a connection manager, or scale your http sessions over mutliple servers. I can be wrong of course, so please correct me.
By avoiding threads, you avoid all the issues that go along with them - concurrency, synchronization/locks/mutexes/etc., deadlock, and so on.
Also leveraging multiple cores, low latency...
Not true. Node.js takes full advantage of multiple cores and has extremely low latency, and I expect this project will too. The difference is that you're not the one writing the multi-threaded code; all the code you write is guaranteed not to execute simultaneously. However, any blocking call you make is handled in an elegant, multi-threaded way. As an example, consider a simple web server: var http = require('http'), fs = require('fs'); http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/html'}); fs.readFile('index.html', function (err, data) { if (err) throw err; res.end(data); }); }).listen(1337, "127.0.0.1"); It listens on localhost port 1337 and upon receiving a request, loads the file `index.html` and returns its contents as type text/html. Now here's the cool part: it takes full advantage of all cores of your system, handles multiple requests at a time and has extremely low latency, yet all the code I wrote is guaranteed to execute single-threaded; that is, for example if I declared a `var i = 0` and incremented `i` with each request, `i` would accurately increment and not need to be synchronized, because no part of the code above is executed simultaneously. If two requests hit at the exact same time, one request is put on hold while the other is handled. But in this case, handling a request is simply writing the header, calling `readFile`, and then the handler function is done and the second request does the same. Meanwhile, the call to `readFile` is handled in another thread (asynchronously) because it doesn't involve any of our JavaScript; so that's where the multithreading comes into play. Request #2 is handled while request #1's file is read, and once request #2 is done (i.e. it's called `readFile` and returned), request #1 can write the retrieved contents of the file while request #2's `readFile` is being processed, and then request #2's file contents are written. Basically, the power lies in being able to multitask within node.js's library, yet guarantee that the script code is never run simultaneously. All the asynchronous calls (which is practically every function in node.js) are executed in another thread and allow another request to be handled while the call is waiting to be returned. It creates an effect similar to an assembly line, which is extremely efficient. And this, in a nutshell, is why the reactor pattern, and thus node.js, is awesome. Sorry I wrote so much; I'm just extremely impressed by node.js, passionate about its capabilities, and concerned that so many people dismiss it as being single-threaded when in fact it's **far** from it.
God no. A rambling mishmash of C++ topics. One can do worse but there is absolutely no reason to buy this book now that Stroustrup's new introduction to C++ programming is available. 
Absolutely amazing book. Makes all other introduction to C++ books look either dated or dated crap. 
This is what you are looking for : http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list Another resources - http://www.cplusplus.com/ and http://en.cppreference.com/w/cpp
Get this book! NOW! 
Node handlers are not multi threaded, that is half the point. Node does have a thread pool for dealing with syscalls though. 
vc 11 will have much more c++ 11 support, but there really isn't a compiler today that has full c++ 11 support.
I was making a coming-of-age joke. Anyways, gcc is way ahead in c++11 support. I hope VC11 gets to the same level as gcc4.6 at least.
gotcha, I am really more interested in seeing when the compilers will fully support the concurrency and stl enhancements in c++ 11.
anyway, congratulation ! 
I think they started out different, and converged over time. There are a couple other differences between struct and class that are mostly syntactical, like I don't think you can inherit a struct from a class, and you can't say template&lt; struct T &gt;. I would avoid using structs to save yourself the headaches of the few corner cases, though some use the struct keyword to easily differentiate PODs from classes. (Lookup Plain Old Data if you don't know what a POD is) 
I liked it, except for "Whenever you get a chance to take a C++ class, do so". That's totally beneath most people. At least wrt the kind of post-college classes I /have/ taken. Instead, work through Herb Sutter's 'Exceptional ...' series... 
&gt;I don't think you can inherit a struct from a class…. A struct *can* inherit from a class -- and vice versa.
Remember that C++ is backward compatible with C. Struct originates from C where it has no access specifiers, so everything in a struct is implicitly public. If C++ had given structs any other default access, then it would break backward compatibility.
Which indeed leads to the biggest difference, structs are (or can be) compatible and used directly with C apis. classes cannot. 
Threads works find on gcc 4.6.x (I can't speak for stability) but in my applications it is working just fine. (including mutexes and locks) That said regex is entirely missing last time I looked.
Absolutely positively yes to the book list on SO. But the other "resources" you listed are barely useful for reference, and terrible for learning from.
Someone who already knows Java is not "someone who already knows how to program". Someone who already knows Java, Python, and Scheme or OCaml probably knows how to program, but until you've used more than one paradigm, you're doomed to unlearn most of what you know. 
From what I've seen of Herb Sutter's talk, it seems highly unlikely. They talk about adding some of the missing features of C++11 to VS2012, so there may be hope (feature pack or such) but from my (short) experience with Microsoft products I am guessing they will try and push the new version.
Besides private and public stuff, you can have methods in classes where as in structs they are not exactly supported the same way, however with function pointers you can get it to do the same thing, which is what classes do anyway its just syntactically different in how you do it.
Well that is new information to me, and somewhat dulls my idea of Node then. I was under the impression that pretty much any async call in Node was multithreaded with the other async calls, just because I thought it would make sense. I agree with you with your points about multiple processes too. Hmm...
They're all async calls anyway, so what does it matter?
I loved this talk. Bjarne Stroustrup kept talking about adding maybe "one thing" to the next C++ standard (and if there's enough consensus around that one thing). I really hope static if ends up being the "one thing". I've recently been taking a stab at writing a C++11 variadic variant class to see how hard it would be to get something like algebraic datatypes in my C++ code. My code would be *much* easier to write (and maintain!) if I had access to a static if.
Yes, it's an excellent feature and should definitely make into TR2. On the other hand, I dread compiler implementation times. constexpr by itself is a bitch. Add static if on top? I fear we won't get it within a reasonable time span. Personally, I feel polymorphic lambdas are more important for most users. If you ask me, that's a game changer of the same magnitude that non-polymorphic lambdas will prove to be (&lt;/nostradamus&gt;). That said, the C++ standard library is most in need of an upgrade. Getting boost::filesystem, tinyxml, and something akin to cpp-netlib would be a huge step forward.
I do agree that polymorphic lambdas is probably the most important feature that should be added. 
How is this different from concepts? Yes I watched both talks ('cept for the end of concepts), I know they /are/ different - my take would be, that static_if is less ambitious, and more practical, but perhaps would result in more scattered, unrelated definitions, whereas concepts is trying to make a more elegant and unified taxonomy of properties. But, perhaps, Stroustrup et al have less of a handle on the whole thing (500+ concepts?). But really, my comprehension is perhaps low; I wouldn't mind being enlightened by someone with a grasp of both. *edit*: I guess it behooves me to rewatch at least the end of the concepts video... 
static_if is only a third of concepts. There three parts to concepts essentially: 1) Check constraints on template parameters(which is like static_if) 2) Check that templates only fulfill those constraints that is says it will(for example, it wont say `is_forward_iterator` and then inside the function it does `it += 5`) 3) Provide a clean introspection interface, to easily define these traits(or constraints). (No need to resort to SFINAE to find if a class has a begin(), and end() method) 
I have to agree with you. It would be a shame if something like a static if were to be adopted without the foresight of how it could be integrated with "proper concepts". Static if seems like a quick hack to me, to be honest. At the function template level, it does not seem to be more powerful than SFINAE/enable_if. Apart from modular type checking (checked templates prior instantiation) concepts are supposed to offer another important feature: Overloading and overload resolution based on the constraints. With simple static if or enable_if where overload resolution ignores the constraints you'll more likely to run into ambiguities.
Thanks for all the replies everyone, I wish I had more to say to add to the discussion, but everyone has already said what I guess I assumed from the beginning. I'm not sure I understand the design decisions though, why not just keep structs like they are in C to maintain backward compatibility and then use classes for, well, classes... 
You can use standard in and standard out, and then you can check whether or not the given output matches the input you gave it. The algorithm contest I have been to does this: They list how they will give my program the data and how I should output the result. I then upload the code and it then begins "attacking" my program with input to check if I got all the cases correct.
or just use the express compiler. that should plug into something (I personally don't care about the VS gui and avoid at all costs. I think last time i even accidentally started the VS gui was probably 2006).
 $ man expect 
Just want to say something: I/O redirection was about the coolest thing ever when I first figured it out. We'd just written a program to play infinite games of craps, so I had it keep making bets based on an input redirect from a file with y 20 y 20 or something similar. By the way, the command was like ./blackjack &lt; values.txt Cheers!
Wait for VS11.
THAT IS IMPOSSIBLE IT IS CALLED THE HALTING PROBLEM RAAAR
This is the basis for most "autograding" programs, I suspect. With redirection in mind, your code probably neither knows nor cares that the input and output are files, not the terminal, so fancy dancing around with expect, or ptys, or whatever, just makes the autograder harder for that grad student to write. The core is just: ./program &lt; input &gt; output diff output expected The poor grad student tasked with turning that idea into an actual autograding program (because, you know, most profs are too lazy to do this bit themselves ; ) gets to figure out things like dealing with student code that does not compile, crashes, or loops forever, while dealing with a collection of input files. But yeah, I/O redirection is extremely cool. 
&gt; I'm actually surprised it hasn't yet been replaced yet with a refactored api. Care to propose one? I think everyone agrees that the interface is poor. However nobody can come up with a better one. Either their proposal isn't powerful enough to be useful in some very important cases (not always defined until someone wants to poke holes in your proposal - but generally everyone agrees the hole is important), or their proposal is too complex to be of use. (iostreams fails in both of the above). Remember, your proposal needs to be better, not just different. 
Is it the same with GCC or LLVM/Clang?
I just ran the code compiled 64bit only (apparently it's a PITA for me to cross compile 32bit). gcc -std=c++0x -march=native -O3 -ftree-vectorize -o sse sse.cpp -lstdc++ (gcc version 4.6.2 20120120) It seems your hand rolled SSE loop is slower than the compiler optimized version (I'm frankly not surprised though). Dot product double - 0.0228735 Dot product SIMD double - 0.0240497
I have to agree, if the compiler can use SIMD instructions then it will almost always be better than you in using them. You get the benefit when you have to modify the structure of the code to be able to use them (IE the compiler can't 'see' the case in which they are relevant). I'll take a whack at 'beating' the compiler in a bit.
&gt; comp*il*ed....comp*li*ed Well, there's your problem. I can fix 'er, but it'll take a course in basic English.
Yes i know about compiler optimizations, but in my environment MSVS C++ 2010 Windows 7 win32 version is significant faster than x64 version. Also in win32 version function with manual SIMDs gives some performance improvement. What can be the reason? 
I don't have visual studio installed so I can't answer that. Have you looked at the code that it generates? 
Why guess, when you may know for sure? objdump/vc disasm both and see for yourself.
Oh, you've never made a typo?
&gt; if the compiler can use SIMD instructions then it will almost always be better than you in using them. I don't have any experience with vectorising things myself, but I'd always heard that it was a weak spot of a lot of compilers (at least compared to the other optimisations performed). I was under the impression that in non-trivial cases hand-written SIMD would handily outperform the compiler. Perhaps I heard wrong, of course. One thing for sure, though, is that if you want the compiler to output decent vectorised code you're going to have to do half the work to get the data laid out nicely anyway.
I can't think of any compiler or language level features that have ever been back-ported from a bleeding-edge/preview into a previous or current release compiler. I'm sure there are examples of it, inevitably someone will provide one, but to me the entire idea seems against the best interests of Microsoft. They want to move licenses and as such they need a compelling reason for their users to re-up. VC++11 is the carrot. 
In slide 9 he says you shouldn't use `auto` for expression templates. This is reminiscent of a [blog post I wrote](http://lanzkron.wordpress.com/2011/02/21/inferring-too-much/) a year ago. Does anyone know if there's any thought of adding a way for type creators to opt out of type inference? (e.g. `operator auto`).
Suggestion: Include the timer.h header in your blog entry and link to the reddit post of [this](http://c-vision.com.ua/?p=111) for context. edit: [Found it](http://www.reddit.com/r/cpp/comments/pnkhk/c_program_compiled_for_x64_is_slower_than/).
Pointers of any kind should be generally avoided or eliminated in C++11. Rvalue references and move semantics eliminates one of the biggest previous uses of pointers: where you want a function to allocate a large object and return it. Now you can just do it by value: vector&lt;int&gt; make_large_vector() { vector&lt;int&gt; v(5000); .... return v; } auto v = make_large_vector(); Move semantics ensures that this large object that is returned by value is done efficiently -- as efficiently as returning a pointer, but without the added burden of the caller having to be responsible for remembering to delete it. No pointers, smart or otherwise, are necessary. And even if you have a case where you do need shared ownership, for functions that simply need to observe an object you pass a const reference, not a smart pointer. Passing a smart pointer by value incurs a significant overhead (atomic increment) and is generally not necessary. And for things that aren't expressing ownership, like a child pointing back to its parent in a tree, smart pointers are not necessary -- just use a raw pointer. Pointers in C++11 should be reduced to a few rare use cases, unless you're a library implementer.
How do you resolve polymorphism and dynamic_cast without pointer support? What you are really suggesting is a better/automagic heap management which I cannot argue with. But removing pointer support would be a serious rework of the language. Pointers in the hands of the lazy can be bad, but they are an inherent part of the language that would take away from its power.
How about add move semantics to your class and change this: std::for_each(m.begin(), m.end(), [&amp;](const Vector&amp; v) { Vector2 r(0,0); r.x = Dot(axisX, v); r.y = Dot(axisY, v); (*i2) = r; ++i2; }); to: std::for_each(m.cbegin(), m.cend(), [&amp;](std::vector&lt;Vector&gt;::const_reference v) { Vector2 r( std::move( Dot(axisX, v) ), std::move( Dot(axisY, v) ) ); (*i2) = std::move( r ); ++i2; });
Sorry I'll clearer, what I was trying to say was that is the compiler can see the potential for vectorisation (like when the data is laid out contiguously) it's efforts are almost always (in my experience (without inline asm)) more fruitful than hand optimization with intrinsics, this is because the compiler can work at a lower level. That said the compiler has to be able to find these situations which is where they typically struggle, in the case where you can see the benefit but it is too indirect for the compiler than optimization with intrinsics can make a big difference. I have experience with the intel ICC compiler which is known to be a good at vectorization, gcc may fail to vectorize what icc can, in which intrinsics useful again.
This std::shared_ptr&lt;Foo&gt; p = std::make_shared&lt;Foo&gt;(); can be written as: auto p(std::make_shared&lt;Foo&gt;()); This isn't too bad.
Right, I lost sight that this was really comparing the compilers problem optimizing the same code differently based on the target platform.
Basically what I've found is that you shouldn't get cute when coding. Be straightforward and direct, doing things systematically. I've seen too many coders try to "get cute" with stupid statement compression, etc thinking that would speed up the code when all the cuteness did was confuse the compiler and generate slower code that is harder to maintain.
I hear this same complaint all the time, pretty much a personal preference. You could still put each statement on its own line like so and be just fine. std::for_each(m.cbegin(), m.cend(), [&amp;](std::vector&lt;Vector&gt;::const_reference v) { Vector2 r( std::move( Dot(axisX, v) ), //!&lt; dot the x axis and move it std::move( Dot(axisY, v) ) //!&lt; dot the y axis and move it ); //!&lt; construct it (*i2) = std::move( r ); //!&lt; ugh, move out the way ++i2; });
If you need to dynamic_cast you've already done some wrong (the design). :D. avoided is the key word, they aren't wrong but should only be used when you have to, like when you need a mutable reference to some thing with a an at least as long life time that you do not have owner ship of, or in a poly morphic collection `std::vector&lt;base* &gt;` (polymorphism can and should still be done with ref where possible).
Right, exactly this. I just used the explicit call in my example to show exactly what was happening.
OK. What happens now when I throw a class child_a2 : public child_a { ... }; vec_a.push_back(child_a2()); into the mix? Kaboom. Object slicing. Have fun cleaning up the mess. How do we avoid this mess? Oh, yeah. With pointers.
Yes order is one of the situations where you might need to to dyn'_cast&lt;&gt;, however I think that I would much prefer to have it done through a strong base class interface than with a series of if(dynmaic_cast&lt;child_1*&gt;(c)){...} else if(dynmaic_cast&lt;child_2*&gt;(c)){...} not to mention that it is really quite slow especially when the number of types build up. 
There's no kaboom. Object slicing is (presumably) undesirable in this situation but not dangerous. You have to purposefully write a pathological class and/or copy/move constructor for something to go wrong here.
How do I store an array of objects subclassed from a common type?
Definitely -- I agree the sorting itself ought to be done through the base class. I bring up the sorting issue because I have a case where I need the base classes sorted, and when I use them I need to dynamic_cast some of them.
Well I am glad someone agrees, this place seems full of javaites :D I personally compile where possible with RTTI off which removes the use of dynamic_cast&lt;&gt;, I personally far rather store an enum in the base, at least this way I don't have to dynamic_cast (this approach should still be avoided where possible). This way you can at least switch on the type, then static_cast. Plenty of production code does this. enum class child_type : int8_fast { child_1, child_2... } ; class base { public: const child_type type; //else where switch(base_p-&gt;child_type) { case child_type::child_1: //and so on. This has the cost of checking the type in the base, the static cast if need will compile out (pointer conversion).
Why should a move assignment do a swap?
I've never heard "putter" for ptr so many times before. I mean, I'm used to cdr being "could-er", but I don't get why ptr turned into "putter" instead of "pointer". Is this so common? Other weird ones I've heard are "char"/"care" and "star"/"pointer-to-a"/"x-pointer". It was also kinda funny how, to a man, the answer to the "what non-native language do you use" question was "uh, a script or something, I don't know." Also, my C++ culture is pretty bad and I don't know all these guys by face, would have been nice to see an intro segment or something. Fun to watch, though.
The socket part is pretty straightforward, and there are plenty of good socket tutorials out there. What's difficult is that you would need to reverse engineer the network protocol that Minecraft uses (or maybe it's already documented somewhere, I don't know.) The point is that the "what to say" is much, much harder than the "how do you say it." Also, "can this be done" is almost always the wrong question -- the answer is almost universally "yes, but...." A better question is "how much work is it to do this" or "what is the best way to accomplish this." 
[Using PVS-Studio from the command line (without Visual Studio solution file)](http://www.viva64.com/en/d/0007/)
No problem for check Notepad++: 1) Old: [Free license for the PVS-Studio static analyzer for developers of free open-source software](http://www.viva64.com/en/b/0092/). 2) [New trial mode](http://www.viva64.com/en/b/0128/).
If you have to reverse engineer the protocol, I suggest just firing up Wireshark on your PC and inspecting what gets sent to a server when you use it.
You're being excessively extreme, and this has nothing to do with freedom. What if someone came by and asked how they could automate MS Word? And you told them to switch to LibreOffice, 'cause it supports Python Scripting? Well, that sounds reasonable. Then they receive some Word document with VB script or whatever stupid stuff MS puts in there, and then they come back and ask how to use it in LibreOffice. Well, now the solution is to use MS Office instead of LibreOffice. Great. You've been really helpful then. The question isn't, "How can I learn how to communicate with a server?" The question is, "Can I use a C++ program to interact with a Minecraft server"? Is Minecraft the easiest program to interface with? I doubt it. Does it "actively [attack] your ability to interface with it?" Very possibly. Could it be infinitely more worthwhile to program against than Minetest? Definitely. Like it or not, nobody really cares about Minetest. At least MS and Apple might copy some nice features from Linux distributions they think are good. I doubt Notch is ever going to even want to copy anything from Minetest. Nobody wants to write software for something and see their software never used by anyone except themselves. Anyway, you know what's a bigger threat to our freedom? Reddit. Sure, they give you all the source code for basically the entire site. You know what they don't give you? The copyright to your comments. They own that.
Learn about network sockets *first*. [http://beej.us/guide/bgnet/](http://beej.us/guide/bgnet/) Write/Copy a few of the test programs and tweak them to see what they do. Then, try and write a chat server and chat client w/ what you know from the above. Use what you've learned about server/client interaction to write a Minecraft client.
From a marketing standpoint, you should analyse OSS projects with the most vocal fans. That will get you the most exposure. Have you run static analysis of any OSS Kernels? :D
Actually, he wants to analyse projects that have a high probability of having programmers who work for a rich company with a Visual Studio stack.
This isn't just about cleanliness btw- this reduces compile times and also reduces circular dependency issues. 
Note that you can just as well forward declare a type used by *value* inside a signature, as long as you are not defining the function. class A; A foo(A); // correct
Meh, I have done some, I don't spend enough time in the language to learn its idioms correctly, I am just fast in C++. bear with and ill knock up mine
If you've never done any sort of socket work, I would not recommend learning by hacking around with Minecraft. I would also strongly suggest using some sort of framework (pick one you are comfortable with) that does all the socket-shit for you. Raw socket work - and Wireshark - ain't for the novice. You also did not explain why you want to do this in the first place. That being said, the protocol seems to be somewhat documented at: http://www.minecraftwiki.net/wiki/Classic_Server_Protocol and http://www.wiki.vg/Main_Page
[I don't have the PVS-Studio menu in Visual Studio Express Edition after installation. Why?](http://www.viva64.com/en/d/0008/#ID0EINAC)
There's still the problem of the reliance on VS.
char is an abbreviation of character and is therefore pronounced "care". As for ptr = "putter", I believe I picked that up from JonCaves in the last 5 years. It is useful because it indicates that the word pointer has been abbreviated. For example, I pronounce shared_ptr and static_pointer_cast differently, so you can hear the spelling. (Occasionally, I say "shared pointer", indicating that my conversion is not yet complete.)
We are using GCC in an enterprise environment; not all of C++11 is already implemented, but except for some bugs in 4.4.x with "enum class" just about all of what's there works well, and some of that has made life a lot (!) easier. 
[Wikipedia as usual has a nice rundown of the available options.](http://en.wikipedia.org/wiki/Comparison_of_parser_generators) 
The freeze date for Squeeze, after which no new features can be added, was 2010-08-06. At that point, gcc 4.5.0 was less than 4 months old (2010-04-14). It's generally advisable to not rush into using x.y.0 releases with gcc, as there are usually a few bugs as these are the first releases after the merging of major features or refactorings. gcc 4.5.1 had just come out days before (2010-07-31) and so obviously it missed the cutoff. Debian generally releases on a two year schedule. If you're comparing it to something like Ubuntu that releases every 6 months, then of course it's going to seem "chronically out of date", but it's not designed to be. gcc 4.7 is currently in stage 4, which means only regressions and documentation fixes are allowed in, in preparation for the 4.7.0 release that is planned for March or April. As the freeze for Debian Wheezy is currently scheduled for June, it seems that there will be a similar situation, with Wheezy getting only gcc 4.6. That's probably okay, as there are only about a [half-dozen C++11 features new in 4.7](http://gcc.gnu.org/projects/cxx0x.html). 
Hmm, really don't see how it is. Looks neat though.
Parsec looks cool, and I'd never heard of it, so I'll be digging into it some.
Yeah, I've been playing with spirit some, and I'm *already* getting that feeling. That's one of the main reasons I asked here.