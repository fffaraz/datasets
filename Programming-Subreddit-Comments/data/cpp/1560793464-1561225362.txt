A lot of things about lambdas are clearer if you remember that a lambda is basically a struct with an overloaded operator(), and the captures are basically it's member variables. Capture by value is equivalent to having a value member, and capture by reference is equivalent to having a reference member variable. If we keep to that pattern, then &amp;&amp;foo would be equivalent to having an rvalue reference as a member variable, which is a real thing and very different from moving the value into the lambda capture. Plus, since std::move is a destructive operation, it's important to have it spelled out explicitly in code. I'd hate to have to debug a use-after-move error where the root cause is this new syntax that moved the value unexpectedly.
Duktape (the C library) uses goto quite a bit, particularly for error handling - its definitely slightly odd initially, but its generally easy to understand if 99.9% of the calls are just goto error; I think goto has an unnecessarily bad rap, the dogma of "goto considered harmful" has really done a number of something that's actually pretty useful in specific circumstances
&gt; under c++, it tells me that a function should have only a single exit &gt; &gt; Right. That has been considered good practice for a long time across most (all?) c-style programming languages. It's not a hard-and-fast rule but generally a single exit helps in maintainability and readability. I thought this was basically considered a meme rule now? Multiple exits are super helpful for writing functions with eg guard clauses
Having spoken to the original person who proposed this functionality at least 3 separate times (Alan Talbot) and having started writing the paper myself before doing some initial information gathering in the Committee, I can assure you nobody wants labeled loops. They are very nice and would make a lot of my involved loops and switch statements better where lambdas would bloat my executable code size and worse, but the need is not strong enough in the Committee. For some reason, Control Flow is the one thing a lot of language designers get passionately upset over and impose all kinds of funky restrictions. I don't expect this paper to pass anytime in the next decade: save your effort for a rainy day.
I've seen an actual engineer get quite upset about it.
Reddit and the world at large is filled with trolls, no need to understand the logic of the disheartened, smile and walk by.
"Who knows in the future" is imho a bad guide for technical decisions ;) If you compile everything yourself, I'd switch to c++17. Where "switch" means, add the c++17 flag to your build file, make sure all tests still pass and use the new features whenever they make sense when writing new code i.e when you are anyway refactoring old one. No reason to rewrite working c++11 code.
You seem pleasant. You do realize your original sentence made absolutely no sense in context, right?
&gt;If you would want to force compiler to evaluate something at compile time, wouldn't it be simpler to do something like (pseudocode): &gt; &gt;`int x = std::is_constant_evaluated(f());` &gt; &gt;Which #error's if this can't be evaluated at compile time? You can force f() to be evaluated at compile time by declaring x as a constexpr variable. constexpr int x = f(); The purpose of consteval is not to force compile time evaluation. It's for functions that should not be possible to call at runtime for whatever reason.
But you did say that "One uses `auto&amp;&amp;` in range-for when they intend to move the iterated arguments" which is imprecise if not misleading. You use `auto&amp;&amp;` when you want to mutably bind to anything (including proxy iterators) in a range-for, which could conceivably include moving but most of the time doesn't. In fact, moving objects out is probably when I _would_ use `auto&amp;`. If I want to move the original elements I don't want to support proxy iterators!
Thankfully in c++17 *if constexpr* can do a lot of the things we needed SFINAE tricks to do earlier in a much more readable and sensible way. Hopefully once we get reflection, even fewer things required will need SFINAE tricks.
Unfortunately, Raymond (usually sharp) misses the forest for the trees. The solution is template&lt;typename R&gt; bool ranges_equiv(R const&amp; left, R const&amp; right) { return std::equal( std::begin(left), std::end(left), std::begin(right), std::end(right), std::ref(equiv) ); } This is exactly why `std::ref` exists in the original STL: it's for taking references to function objects. Unrelatedly, `begin` and `end` are not customization points, so trying to find them by ADL as in Raymond's post is (A) wrong and (B) doesn't work for built-in arrays.
&gt; You can force f() to be evaluated at compile time by declaring x as a constexpr variable. Unfortunately that's insufficient unless you actually use `x` in a context that requires a constant expression: constexpr std::integral_constant&lt;int, f()&gt; x{}; As you show it, it only enforces that it must be _able_ to execute at compiletime, but it may indeed actually execute at runtime.
People keep telling you it is a bad idea, and describing why, and you seem to not notice. `&amp;&amp;` never, ever, ever triggers a move in C++, barring a `static_cast&lt;Type&amp;&amp;&gt;(val)`. You want to add syntax such that it triggers a move. This is bad. Your *only* argument that it was good was your analogy to `auto&amp;&amp;`, which people pointed out was nonsense, and you are getting bruised over people pointing out it is nonsense. It would be better if it was `&gt;&gt;==&lt;&lt;` or some other otherwise unused sequence of symbols rather than `&amp;&amp;`. Making `&amp;&amp;` trigger a move here would make people who get confused and think `&amp;&amp;` could trigger a move elsewhere get more confused, and make people who are looking for moves in code worse off. The only remnant of an idea left after you discard `&amp;&amp;` is "wouldn't it be nice for capture by move to be less typing". Which is **movivation for an idea** not **an idea**. Yes, it would be nice if all syntax was shorter and more clear in all cases! That is about as obvious as it comes. With no useful sugestion on how to improve the syntax here, there is no value. So dismissing `&amp;&amp;` ends the suggestion; unlinking `auto&amp;&amp;` dismisses `&amp;&amp;`. As to why? Assignment was added after capture was. Capture was added at the same time rvalues and move semantics where. Assignment was simple and solved a bunch. It left some cases imperfect. Nobody has seen it worth the effort to perfect those cases; lambda evolution tends to go towards simpler code in simpler cases, not simpler code in complex cases involving move capture.
If people used their real names, they'd be a lot less flame-y in their posts. Anyway, thanks for your thoughts.
if constexpr is nice to get rid of a few things, but I think even more enable_if trickery will disappear with concepts, which I'm really eager to go play with
yes
The problem with r-value capture is that they won't move anything. l-value reference or r-value reference, it's still a reference. What you want is capture by value by moving argument into the new value. This is different than r-value reference captures.
A little late here, but just wanted to say this was a fantastic episode. Daveed is very articulate, and had so many interesting things to say. Thanks!
Right, in C++, *the* way to use the move operator is `std::move`. It would definitely break the principle of least surprise to have `&amp;&amp;` mean `std::move` in this context but in no other contexts. I'd like to see a slightly more compact way to express this pattern -- and, to be honest, `std::move` itself is quite verbose for what is a pretty low-level/abstract topic that could easily be an operator. I don't know what would be syntactically available, but I do think it would be cool/easier to parse to be able to use something like `!variable` instead of `std::move(variable)`.
You might be interested in Folly‚Äôs Synchronized&lt;&gt; which is a similar approach to the problem of managing shared data: https://github.com/facebook/folly/blob/master/folly/docs/Synchronized.md Note it handles a number of interesting use-cases, including shared and exclusive access (and upgrading between the two), and locking multiple objects at once.
It seems that he omitted or twisted too much information, that the remains no longer make any sense. In the code shown, `equiv&lt;T&gt;` is a non-static member function, which means it cannot be passed an argument, whether by value or by reference.
GCC 9 with \`-fconcepts\`, and go play!
You'll end up with a mix of C++11/14/17 if you just flip a switch. This is kinda typical nowadays though, but not everyone want to go that road. You don't want to see a mix of boost::shared\_ptr/std::shared\_ptr in different parts of code, do you? For the same reason some people don't want to mix different C++ dialects. But as i said, majority of the C++ projects is a mess of C++98/03/11/14/17 which will never be refactored because as you said, there is no reason to do that. And soon it will be C++98/03/11/14/17/20.
"Traditional" engineering uses a well known set of common practices (requirements, etc.). In industrial contexts and also others, some programmers practice engineering in that way. Even in those contexts, others might need some form of supervision during all their career -- yet still be useful to perform less innovative tasks. I suspect that people who claim there is no difference either have absolutely no idea about that, or in the complete opposite direction have no idea that some programmers do not use (even the most basic) engineering practices. This is not a judgment of value on my side: the same can be told from physicists and so over, yet there are situations where it is fine to not do engineering -- for example physicists are not less competent in their core discipline just when they do not practice it in an engineering context: the two are not that much (at all?) correlated. Simply I think that a general confusion on terminology is not useful for anybody.
i use 'programmer' more as job than as a role. an astrophysicist (role) writing some mathematics package is as much of a programmer (job) as a software engineer (role) doing the same. software engineering as a role carries connotations of programming with engineering principles (maintainability, extensibility, robustness, cost reduction, etc.), rather than the 'as long as it works' approach usually taken by people with other primary professional disciplines no one hires 'programmers'; they hire astrophysicists or software engineers or whatever, a function of whose job includes programming
Be more specific about "hostility". I mean, I did point out how people had already told you your idea was bad, but that is an attack on your idea, not on you. Dismissing ideas as bad isn't *hostility*. It isn't being fawning or coddling either; that could be the issue? They pointed out why your analogy was poor, and why it doesn't support your position. And as you didn't state **any** support for your position other than that analogy, this implicitly makes your argument for that position bad. Go look at your original post. Erase what you meant to say, and read what you said. You made a proposal, said it would be "nicer". As support, you talked about an analogy. That, and the word "nicer", was the whole of your argument to add that syntax to the language. Then asked why it wasn't already done. --- In fact, I see lots of hostility from you, but not any from anyone else. I'll cite cases. You are complaining about people "not answering your question" and instead "showing off". Those are direct attacks on the person who is trying to help you, at your request, when they point out that your analogy seems to be nearly completely unrelated to the proposal. In fact, you follow it up with more questionable statements, like: &gt; One uses `auto&amp;&amp;` in range-for when they intend to move the iterated arguments which sure reads like you don't understand what is going on. They point out why this seems to be also unrelated or indicate a misunderstanding, and you start insulting them. --- As for my real name, I'm not sure why you need it, unless it was intended as a deniable threat. Regardless, you'll claim it isn't a threat, which near zero information content. Bye.
&gt; template &lt;class _InputIterator&gt; &gt; vector(_InputIterator __first, &gt; typename enable_if&lt;__is_input_iterator&lt;_InputIterator&gt;::value &amp;&amp; &gt; !__is_forward_iterator&lt;_InputIterator&gt;::value &amp;&amp; &gt; ... more conditions ... &gt; _InputIterator&gt;::type __last); Unfortunately this is not correct: it allows `vector(some_istreambuf_iterator, 0)` because the second parameter is made a non-deduced context. (I see where this snippet comes from, and I believe it's a bug of this standard library implementation.) &gt; Here's a simplified version of its declaration in the cmath header: &gt; &gt; template &lt;class T&gt; &gt; typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;, bool&gt;::type &gt; signbit(T x) &gt; { &gt; // implementation &gt; } This seems to simplify too much, because there need to be a `::value` after `std::is_arithmetic&lt;T&gt;`. &gt; `std::enable_if` is a rarely used construct. I find it interesting that the article claims this when it also says "There are hundreds of references to it in the C++11 standard template library." &gt; Finally I'll note that the C++ standard library uses the verbose, "clumsy" version of `std::enable_if` without defining more complex versions. This seems to mix "standard library" and "some specific standard library implementation".
This is silly, engineering existed long before "common practice" and professional bodies were established
&gt; That has been considered good practice for a long time across most (all?) c-style programming languages No. Thats not what single exit means. Its about always returning to the same code( and "most(all?) c-style programming languages" dont even allow returning to different functions). Theres nothing wrong with guard clauses, they lead to more readable code - less unnessecary nesting
&gt;Why would i want to inspect something if i know what type is it. Type is a complete description of a.. well, type. The problem is with e.g. pointers/refences to base class which real type can not be figured out at compiletime because it is yet unknown. This is why you might need reflection - to inspect an object at runtime. The proposal is for *static reflection*. In other words, compile time stuff. It could be used to remove boilerplate, and it's probably going to be used mostly in templated code where the type you reflect on depends on the template arguments. You could for instance "loop" (at compile time) over all enumerators in an enumeration which could be useful if you want to write a to\_string function for enumeration types or if you want to verify that an integer value corresponds to one of the enumerators in an enumeration. You could also loop over the data members of a class which I guess could be useful if you want to do serialization without having to list each individual data member for each class. These are just some examples. You will of course also be able to check if a class has a certain function but that will use the static type of the reference/pointer (not the dynamic type of the object).
&gt; Unrelatedly, `begin` and `end` are not customization points. They absolutely are. I'll give citations later if you need them but I'm on mobile at the moment. Agreed re: the rest!
&gt;This is exactly why std::ref exists in the original STL: it's for taking references to function objects. (Okay, assuming that your comparer is a callable object with a operator(). I guess Raymond hadn't done that part, which is why it was problematic.) Not sure if I'm interpreting this correctly, but `std::ref` works with any lvalue satisfying _Callable_, meaning any lvalue that works with `std::invoke`.
If engineering did exist even without common practices, then what was it? The history of engineering is interesting, however there inherently were commonalities, otherwise there just isn't a word. As for a "young" discipline, my turn to find that silly; the "software crisis" sentiment dates from ~50 years ago. That more than a complete career. That's more than what it took to develop the nuclear industry from scratch. And that's why I find it highly illusory to think that not enough happened in that period as far as software engineering is concerned. Specialized knowledge and practices evolved a lot, *and* general engineering practices found quite naturally their way to be applied including when software is involved, because there was not even much difficulty in doing so and some projects need it (most of the time: big projects and/or projects with strong components from other fields and/or critical projects). We all know of some transformations that build our current field in the same way others have been built, gradually: structured programming, version control, etc. Engineering as a transversal discipline very much also do exist, and my point is that even using state of the art *specialized* practices (for the purpose of programming, in our case) is not sufficient to pretend doing engineering in some contexts. The *transversal engineering* practices are quite similar regardless of the technical fields they can be applied to. This has not very much to do with "professional bodies" in my opinion. That is more adequately defined by actually doing a job including those transversal practices, and even in some regulated countries the bulk of such work is not necessarily performed by Professional Engineers.
Of course a library should have a consistent interface, but beyond that I don't see a problem if different parts of the code use whatever technology was available when they where last touched. "All or nothing" is imho unrealistic, unnecessary and imho harmful in the sense that it slows down adoption.
‚ÄúI am a programmer. On my 1040 form, that is what I put down as my occupation. As a programmer, I write programs. I would like to present to you the cutest program I ever wrote.‚Äù - Ken Thompson, [Reflections on Trusting Trust](https://www.archive.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf)
It's a bit naive to think that all engineering work done in "old engineering fields" rigourously follows procedures outlined by international standards or similar. From what I've seen lots of work done by automotive engineers is just as ad-hoc as much of software engineering. I'm fact even many of the so called "real engineers" are often software engineer in practice as much of engineering has become computerised
They didn't always mean the same thing. Engineers used to be the document writers that designed the blueprints, and developers were the coders that put the thing together. The problem is that most of the engineers were too busy to code but they wanted to code and were the best at it. This led to programmer-engineers as a preferred role to straight engineers. From an HR standpoint I still separate a strictly developer-engineer from someone who designs and implements software within a QMS. I just don't say that to the developer's face and we start making up new titles to differentiate them.
&gt;"I would argue that aesthetics are a minor factor in software engineering" And is not a minor factor in other engineering either, a rocket nor a factory needs to be beautiful, but ask them for their drawings, specs and documentation (assuming no spaghetti in their drawings) I'm that they have a defined style like this http://www.metrication.com/drafting/images/layout.gif And the dopamine inducing documentation of each function, well, in a factory all cables, all pipes and all tanks are fully documented its purpose, connections, capacity, inputs and outputs, tagged and even color coded (like the pipes in the talk). But those cost money/time and don't generate "real" business value :(
I partly agree with you; however I would more inclined into naming sloppy practices as such if they are inappropriate for the application (not all applications of the same level of criticality). I've also seen my lot of EE who did most of their schematic by feeling rather by checking the fitness by doing the math -- and then we are back at the: is this appropriate (a risk taken to go faster) for the application, or is the application critical enough that this is just endangering the users. Now I don't think it matters at all that they are using computers to do their work. They just mostly use specialized applications on said computers, most of the time they do not create complete new programs (although some of them script, probably extremely outside of SW engineering practices, but it does not matter for what they are studying with their scripts; and also obviously there are a few people that are both expert in SW engineering and other engineering disciplines, so that they can create such engineering software tools)
SFINAE feels like doubling down on untyped generics (templates) and function overloading. While it does solves some problems that these features introduces, it does so by making the language significantly more complex. All these problems disappear without complexity by just removing overloading, untyped generics, or both.
Sure, it's your codebase and you can do whatever you want with it. You might as well change coding style in the middle of the project and write only new code in that style leaving everything else in old style, it's all a matter of a preference.
Yup. If you write 'code' that looks like 'code', you have failed.
Yes I agree with you, and not the person giving the talk. I see it as a bad programmer vs a good programmer. I was simply explaining that OP had read the title and made assumptions, this is nothing to do with people from Engineering backgrounds.
I am not the person giving the talk. I see it as a bad programmer vs a good programmer. I was simply explaining that OP had read the title and made assumptions, this is nothing to do with people from Engineering backgrounds.
Thanks, I will check it out. I do handle all the cases you mentioned and provided examples on the page.
I think everyone has a different idea of when necessary clarity becomes needless beautification. You can't let a bunch of new programmers who are barely literate in C++ loose on your code and tell them not to care about how things look. There are some standards beyond 'it compiles'. &amp;#x200B; But surely you've met experienced programmers who perhaps fuss a little too much over their code? And that despite all the care and attention they give it, it somehow still isn't that legible or easy to modify for others? All that time they spend on it makes them a worse judge of how an outsider perceives it, and eventually they'll declare it's self-documenting and stop bothering with comments.
It's extremely inconsistent with what &amp;&amp; means.
You're suggesting something you mark with a &amp;&amp; wouldn't be a reference? That seems inconsistent.
Read your responses back. You'll see that it's not just everyone else being "hostile".
&gt; too busy building tests for some insignificant part of the code 100% code coverage because it is 2019. That also includes branch and conditionals. Not that hard if your code is good, and you've had some practice.
Usually EEs. I don't know any CEs or MEs who write code.
This is super platform dependent and I don‚Äôt think anyone should care about this unless you have some quirky real-time micro controller with very strict timing requirements.
Pure curiosity from my side.
Note that a ‚Äúless than or equal to‚Äù is a ‚Äúgreater than‚Äù with the operands swapped.
&gt;Since the &lt;= operator feels like it would have to do 2 comparisons CPU's - even Reduced Instruction Set Computer architectures - typically have an instruction for less-than-equal operation. No need for two operations. &gt;while stating that the top one would be faster since the bottom had to do an extra operation (add one through each iteration). This seems like a straw-man argument (or the argument was never about the difference between &lt;= and &lt;). Both &lt;= and &lt; can be used to write a loop with the same number of iterations.
Yes, it does seem inconsistent, and again, I apologize that I came across as seriously suggesting a fourth meaning for `&amp;&amp;`. Of course that can be (and ought to be) rejected in favor of something else that solves the purported problem. My real interest involves a common scenario involving lambda captures of moved values. Lambdas can often show up when we are introducing *deferred* execution. Say we started with: Value value = ...; store(std::move(value)); and we then wanted to defer the storage. We'd rewrite this with something like the following, which of course would avoid a copy with a move to the lambda capture context: Value value = ...; schedule([value{std::move(value)}] { store(std::move(value)); } Mechanically we did what makes sense to set up the lambda capture, but this is a pattern that works more for the requirements of lambda captures than for the actual code being written--i.e. it's busy work. The existing pattern 1.) introduces an extra `std::move`, 2.) requires an extra identifier for `value` that is often redundant (as would almost always be the case when we're moving a value), and 3.) simply looks cluttered with the extra parenthesis and braces. While the current developer experience of using lambdas occasionally involves deliberation on whether we would want to capture-by-value or capture-by-reference, i.e. should we say `[foo]` or `[&amp;foo]`, I am wondering if there has been past interest or is room for future interest in a third type of capture that moves. And if this feature would be a "nice thing to have", what syntax makes sense? In other words: if `[foo]` means to make a copy of `foo` by calling the copy constructor which you can also get by saying `[foo{foo}]`), then what syntax might mean to make a copy of `foo` by calling the move constructor? PS I do understand what the three meanings of `&amp;&amp;` are: 1. logical-and infix operator 2. to declare an r-value 3. to declare a universal reference, only in the context of `auto` and template parameters.
The argument was specifically about the speed between the two styles (either adding one or using the &lt;=). But even I know that an operation to add would be slower than an operation to compare. So then I just got curious if it would have multiple operations to do the comparison.
Hmm, not that I read again, it seems that your question isn't about the different number of iterations (which there are a different number). Are you asking about the addition in `j &lt; i + 1`? There's no need to do that on every iteration. It can be calculated once, and used repeatedly: end = i + 1; for(int j = 0; j &lt; end; j++) A good optimiser should hopefully do this transformation for you.
&gt; But even I know that an operation to add would be slower than an operation to compare. the compare itself is faster but the branch after is slow
Curious, why would you move instead of just passing by reference?
Pryings, ground would you move over or else of equitable passing play by remark? *** ^(This is a bot. I try my best, but my best is 80% mediocrity 20% hilarity. Created by OrionSuperman. Check out my best work at /r/ThesaurizeThis)
In many parts of the world, ‚Äòsoftware engineer‚Äô falls under the purview of a professional engineering society. For that reason I cringe whenever I see engineer in a job title for an entry level position.. I am not a software engineer. I am a software developer, or programmer, or .... I work with hardware developers, power supply designers, digital designers, etc.. some of them are certified active members of the provincial professional engineering society, but not all. Only rarely is the word ‚Äòengineer‚Äô in the job title, and that usually means it was a job requirement. This has always seemed straightforward to me. Is it not the same everywhere?
The idea of pragmatically assessing the business impact of software changes is sound, but boy does the message come off as "Anything I think is not valuable is ideology, and everything I do think is valuable is fitness". This in itself is a form of ideology, in other words we have learned that subjectivity is subjective.
As far as I know, they're exactly the same. Both &lt;= and &lt; compile into a single Assembly instruction on x86.
In practice, this is irrelevant to speed. i+1 will be evaluated once, outside the inner loop (see loop invariant code motion). Therefore not affect the inner loop performance. Additionally, a lot of compilers normalize loops into a != comparison, and I suspect both will give the exact same assembly code. It's typical of teachers to not understand true performance issues as they frequently lack practice. Additionally, it's easier to explain simple ideas (such as doing less operations) versus concrete issues (such as branch misprediction).
If you really care about that kind of minute details, then what you should really do is take the habit of always writing `++i`, not `i++`.
There's really no point in speculating about what the compiler may or may not do. Here's the benchmarks: http://quick-bench.com/_-sXV49F94w8wuvUHfOFB66CD88 TL;DR: in unoptimized mode, clang produces slightly different assembly, but there's no significant difference in performance. In opt mode, clang produces identical assembly.
Im in that habit, I was just copying his code as exact.
I‚Äôve run into a small issue with this pattern and I‚Äôd love if someone had a thoughtful workaround. When some strict subset of state representations share some common object, but the object is expensive to copy, where is the best place to put that object and what is the best way to keep state transitions relatively cheap? I‚Äôve never been able to think of anything much smarter than allocating the object on the heap and holding it by unique_ptr&lt;LargeObject&gt; in the states that need it. Also, if you want to reuse memory you‚Äôve allocated already to prevent unnecessary future allocation, you might prefer to have storage outside of the variant that serves as a (maybe single-object) memory pool, or you might need to add the unique_ptr&lt;LargeObject&gt; to states that don‚Äôt really need that data just to keep the memory alive. Not super clean.
How so? a&lt;=b is not equivalent to b&gt;a when b == a. Am I misunderstanding?
You're right, I must be tired Zzz Was thinking of `(a &gt;= b)` and `!(a &lt; b)`
Because the value is going out of scope.
I mean, we're getting concepts pretty soon in C++20, which participate in overload resolution. From what I messed around with in compiler explorer, I pretty much won't need SFINAE anymore in the hobby thing I'm working on, since it looks like the most constrained overload is the one that gets picked, unlike right now where you have to manually exclude all overloads except the one you want via SFINAE and it sucks
CPPP trip 2019 anthem [https://www.youtube.com/watch?v=U06jlgpMtQs](https://www.youtube.com/watch?v=U06jlgpMtQs) &amp;#x200B; XD someone has to do it!
He's not talking about &lt;= vs &lt; but the +1 in the inner loop. In practice this toy code is something that is unlikely to have a difference as it is easy for an optimizer to deal with, but this is still good practice to not make the optimizer work too hard.
There's a meaningful distinction. You may not encounter it in software organizations, but if you dive into a normal corporate IT environment, you're likely to find plenty of programmers. Even interviewing people coming out of colleges will show some major gaps between the types of training. As an example, if I ask a candidate coming out of a school like MIT, CMU, Stanford, Northwestern, etc "what was your favorite class", the answers I get talk about the types of problems they learned how to solve. If I ask the same question to someone coming out of a school not known for their CS program, the answer will be something like "I really liked the C# class". One set of schools is teaching students how to solve problems, the other is teaching students to write programs. Both have their uses, but ...
If you think an electrical engineer's code is bad, you should see a programmers circuit diagrams or mechanical designs.
if constexpr is mostly about doing things you would do with tag dispatch. concepts is moreso about doing things you would do with sfinae.
I'm guessing you arent that familiar with engineering certifications. Which is normal. its not a very popular thing to talk about and it varies region by region. In the US, "engineer" is not a controlled term. anyone can claim to be an engineer. In some countries, engineers are more like lawyers, where you can get in trouble for claiming to be an engineer without the proper certifications. Those certifications do exist in the US. Students pursuing most major engineering degrees like mechanical or civil engineering can opt to take the "Fundamentals of Engineering" exam or FE. Its not that hard if you went to a good school. Now you graduate and start work. You can be called an 'Engineer' at this point in America. But you dont have all of the power of a Certified Engineer. You cant sign/stamp drawings or plans yet. After working under a CE for 5 years, you can opt to take the "principles of Engineering" or PE exam. If you pass this then you are an Engineer int he eyes of the law. Great! Now when drawings come across your desk you just look at them and if they look okay then you stamp, right? Wrong, they do exactly what you suggested in your comment they look at the evidence. The look at the math and designs and verify that everything is correct and accurate. They do this piece by piece, drawing by drawing. Checking math and formulas and standards. And when they are satisfied, they sign. Their signature means "not only was all of this work reviewed for accuracy, it was reviewed by an expert on the subject matter". Being against the accreditation of engineers but desiring the minimum education is kinda of nonsense because they are one in the same. Accreditation is just the minimum degree of education necessary to be considered an expert. Accreditation doesnt take the place of evidence, it enforces that evidence.
Shooting for 100% code coverage is sometimes a good goal to have, but achieving that doesn't necessarily mean code is "good". Bugs often still lurk in code bases with 100% coverage. Moreover, writing good tests takes time. More tests also means more constraints on a projects and can sometimes make it challenging to make critical adjustments. &amp;#x200B; If a project is small, not expected to be widely distributed or reused then writing a bunch of tests might not make sense. If a project contains a bunch of code for some auxiliary functionality that isn't critical for the main functionality then it might not make sense to spend a bunch of resources testing it. etc. &amp;#x200B; There are many cases where shooting for 100% coverage isn't necessary and is a waste of resources. However, many dogmatists will ignore such statements as blasphemy without considering that principles that work in their narrow domain do not necessarily apply across all domains.
I understand your curiosity and I asked myself the same question multiples times, but the answer for 99% of developers is just write whatever is clearest. As a general rule, optimization is only needed in critical paths, usually after profiling to see that something is severely suboptimal, which usually comes down to efficiency of algorithms as opposed to nitty gritty.
`std::move` does **not** move anything. &gt; It would definitely break the principle of least surprise to have &amp;&amp; mean std::move in this context but in no other contexts. So, I'm afraid the principle is broken, because that's what it means. You [with `std::move`] cast a (non-const) lvalue to a rvalue, i.e. you have now made a lvalue moveable, hence it will be moved from.
I would argue that any project much over a day of effort without tests is starting to bog down unless the code is doing something so fantastically simple that it can't screw up (which would still be easy to test). The constraints that tests place upon code are only really constraints if your design is in continual flux; which means it wasn't well planned or architected. This is the amazing thing. So very few people know how to make software. They can program, they can solve problems, but they don't really no how to plan and structure code. This is not easy. For instance I would be willing to bet that less than one programming company in 10 is using discrete math or graph theory to examine how their code is going to hang together. This too will make it "slow" to build things. But the result is that when you start coding at one end, you just plow along until you get to the other. It doesn't need to be one giant perfect plan. This still works with agile. But you do the planning in two types of stages. One is an overall plan of how the big bits will hang together, then each smaller bit (or sprint in agile world) is planned on its own. Strangely enough, you get to the end with a working codebase that doesn't have the "It works and that is good enough" mentality. This is where unit tests simply validate two things. One that the code is actually doing things you wanted it to; and the other is that you will know if it generally stops doing the things you wanted it to. This massively accelerates the speed at which solid code is laid down. You know the code you are basing the new code works, and you know the instant you broke something and exactly where it broke. This could be because you just made a mistake, or the code you were depending upon just went weird. The key is that you don't spin your tires trying to figure out what the heck is going on. I have seen many a large project where as the end approaches it is a game of whack-a-mole where new bugs are being discovered and created in some weird dance; greatly interfering with forward progress. People joke about how the last 10% of a project takes 90% of the time and effort. Generally this does not happen in a project with 100% code coverage. The last 10% takes something around 10%; crazy.
Guilty as charged.
&gt; engineering existed long before "common practice" and professional bodies were established So did medicine. Should anyone be able to call themselves a medical doctor?
It sounds like the guest lecturer had a good point not presented that well. This is a real issue with real-world gotchas, but the given code sample is too simplistic. The main issue with the extra operation on `i + 1` is only an issue if the compiler doesn't optimize it out by computing it once for the whole inner loop. This is a common optimization called loop invariant hoisting, and all modern compilers do it. It's important to note, though, that the language says that `j &lt; i + 1` is evaluated for each loop and the compiler has to _prove_ that optimizing it out is safe. Any little thing that _might_ cause `i` to be modified in the inner loop invalidates this and forces per-loop evaluation, and this happens more often than people think. For `i + 1` the performance difference is tiny and not worth worrying about, but for a more complex expression like `sqrt(i)` it's more noticeable, and the notorious `strlen()` can cause a really bad and classic performance bug here. I'm also going to throw it out there that `j &lt;= i` and `j &lt; i + 1` aren't always the same in C and C++. They are in this case with the types and loop counts involved, but with `unsigned int`, it's possible for `i + 1` to overflow to 0. That's another case where an optimization that looks trivial actually isn't, and sometimes the compiler can't actually optimize the way you'd expect for a very subtle reason. As for `&lt;` vs. `&lt;=`, modern CPUs generally have all six comparison operators as a single operation with the same cost. On some really old CPUs like a 6502, there were cases where some of the comparisons did have to be done as two operations, because the CPU could directly compute `&lt;` and `=`, but `&lt;=` had to be done as a composite operation. Even then, it was still sometimes possible for a good programmer or compiler to flip things around to do it in one operation.
I do love this editor, but it is a memory hog. Other than that, definitely worth a go if you want a fast, clean ide.
The inner loop of the first code is doing `i` iterations. The inner loop of the second code is doing `i+1` iterations. That is the most likely cause for any performance difference.
Yeah but the inner of the first also starts at 1 compared to 0. There is no difference in number of iterations
..? If `i == 4` then the first code iterates over {1, 2, 3, 4} while the second iterates over {0, 1, 2, 3, 4}.
For integers `j &lt;= i` is the same as `j &lt; i + 1` (ignoring overflow) so they both end on the same number but since they start on different numbers they will not do the same number of iterations.
same, some PEs don't seem to appreciate it
One of the best explanations of SFINAE I‚Äôve seen. Thanks for the resource OP
Not in Canada - here "Engineer" is a protected title, like Doctor. You need to be a licensed Professional Engineer (which itself has a whole bunch of requirements - graduating from an accredited school, having a certain amount of experience, passing an exam, and maintaining a certain number of professional development hours) in order to have an Engineer title, even in software. I believe the same is true in a few US states (at least Oregon, I think a couple others).
Lots of people are telling you that modern compilers will optimize both pieces of code to the same assembly in the end. This is true but irrelevant. It is irrelevant because the assembly you see is a lie; the processor isn't really running instructions in quite that way. First, modern CPUs branch predict. On something like a loop, they predict the branch is taken, and will chug along doing iterations until they find it is time to stop. The pipeline doesn't stop to check whether the bound is satisfied or not, so any extra additions -- if they are there -- will have minimal impact on the overall time taken to complete the loop. But even that is not quite right. Modern processors all do some form of out-of-order execution: the machine will continue chugging as long as there's a calculation it can do with the data it has available. Incrementing loop counters is one of the most common operations, and one of the easiest to optimize, so don't be surprised if the actual result for the new loop counter is ready several iterations before it is needed. The same goes for a loop bound such as i + 1 in your "&lt;" version. That stuff will get computed long before it is needed so the performance impact of the extra addition, if there's even one at all, will be rigorously zero. Bottomline: the naive view, that the machine is executing one instruction at a time, and that "more instructions = worse performance", is next to useless when it comes to talking about these sorts of micro-optimizations. Focus on writing a good algorithm and let the compiler worry about these details, unless you have good reason to believe you know better.
On my part of the world being a Software Engineer is a protected title, certified by the Engineers Order, which also validates which universities are in fact teaching Engineering degrees in computing. One just does not call oneself "engineer" after a 6 months bootcamp.
Concepts are used in SFINAE. They don‚Äôt remove its need, they just add a new angle in which to consider it. Tripping down.
&gt; I find it interesting that the article claims this when it also says "There are hundreds of references to it in the C++11 standard template library. Coding for std is a totally different beast than your everyday code. There are parts of c++ that are intended to be useful for low-level work like std, but not for the majority of users. The deep dark parts of concepts will be no different, and they should also not be used commonly (by common users, not by line count...).
Very honest report, interesting to hear the newbie experience. Would have been nice to know what you took away: what did you find out about modules? How will you change your approach in light of emotional programming? Just a bit more depth needed really. Sorry to hear about the turbulence you suffered on the way in to France. Hope it doesn't put you off C++.
There is a standard paper about customization points by Eric Niebler that covers these.
The same holds true for refl-cpp. No runtime impact with -O1 on clang and -O2/-O3 with GCC or MSVC.
Oh, this is me! Thanks for posting to reddit :+1:
Thanks for the feedback, I'll go back in a couple of days and flesh out a couple of parts now that I'm settled back at home. Thanks for reading üëç
A much better solution seems to me to be to use a (potentially thread_local) function static member object, i.e. turn your LargeObject into a Meyers' singleton.
If the click-bait title was hoping to draw more viewers, well, didn't work on me. Has the exact opposite effect, actually.
And if I need a second state machine of the same type?
That was not a requirement in OP's question [at least, how I read it], but nothing stops you of having an array or a vector of those things as a function static member object and access the one relevant to the specific state machine in question.
Better keep that left hand wrist straight while playing bass if you don't want to risk getting repetitive strain injury in the long run.
You are missing out on some real C++ news, I think. Follow the good C++ bloggers. I, for one, don't care about boost, stackoverflow or CMake. You should really make it in C++, man :)
I'm not sure automated post announcement for "good C++ bloggers" (we also should define "good") will be valuable. But good (highly rated) SO question are valuable. Let's say I didn't knew why C++ metaprogramming is not recommended in space environment, but because of this bot I know :) https://stackoverflow.com/questions/56557596/why-is-c-template-use-not-recommended-in-a-space-radiated-environment
Then I think just following /r/cpp is better than following a twitter bot. Here we have the better content curated by the users.
&gt;onstexpr is nice to get rid of a few things, but I think even more enable\_if trickery will disappear with concepts, which I'm really eager to It is a good one, yet if one is interested then I'd encourage to read c++[C++ Templates Complete Guide 2nd edition](https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121). This is hands down, the best source of knowledge of C++ Templates. Authors of this book in fact coined the term SFINAE :)
Everyone have preferable data sources, I glad to see that /r/cpp is enough for you.
Basically SFINAE is kind of a hack, that we all accept, therefore term has been coined for it. Moreover it's needed. Yet It will be greatly narrowed when concepts arrive, can't be certain yet it can be possible that SFINAE for C++20 would not be needed at all.
That's too few sources. I am subscribed to 146 C++ blogs of my interest in Feedly.
I think the fact you make a mistake about the number of loop iterations, and can't see it even after multiple comments warning you about it, is a pretty good reason to avoid the &lt;= and +1 style loop :-)
146? Do you have a list you can share somehow?
anyone know when the videos will be available for online consumption?
I mean, the claim lacks enough support from the article, and the evidence in the article seems to suggest exactly the opposite. The claim might be correct, but it needs some elaboration, and even then, I'm not sure whether it's relevant to the main topic of this article.
Intel SSE2/AVX2 have limited compare operations for integer vectors (GT and EQ). Nothing a simple De Morgan sleight-of-hand won't fix: // (a == b) --&gt; _mm_cmpeq_epi16(a, b) // (a &gt; b) --&gt; _mm_cmpgt_epi16(a, b) // (a != b) --&gt; !(a == b) --&gt; not(_mm_cmpeq_epi16(b, a)) // (a &lt; b) --&gt; (b &gt; a) --&gt; _mm_cmpgt_epi16(b, a) // (a &lt;= b) --&gt; !(a &gt; b) --&gt; not(_mm_cmpgt_epi16(a, b)) // (a &gt;= b) --&gt; !(b &gt; a) --&gt; not(_mm_cmpgt_epi16(b, a)) The variants with NOT operation have theoretically double the cost but for practical reasons may be even more; the not-operation is non-trivial as it requires either a constant load (all bits set to 1) or compare operation to generate the all bits set to 1. a = _mm_xor_si128(a, _mm_cmpeq_epi8(a, a)); // ! A should be equal to itself, so the compare will produce "true" which sets all of the bits in the register to 1. Then we XOR with the all bits set, yielding bitwise NOT operation. Just an example of ISA where we only have "&gt;" and "==" compare operations. The 64 bit UNSIGNED variants are even funnier.. // SSE4.2 static inline mask64x2 compare_gt(u64x2 a, u64x2 b) { const __m128i sign = _mm_set1_epi64x(0x8000000000000000); a = _mm_xor_si128(a, sign); b = _mm_xor_si128(b, sign); return _mm_cmpgt_epi64(a, b); } // no SSE4.2 static inline mask64x2 compare_gt(u64x2 a, u64x2 b) { const __m128i sign = _mm_set1_epi64x(0x8000000000000000); a = _mm_xor_si128(a, sign); b = _mm_xor_si128(b, sign); __m128i diff = _mm_sub_epi64(b, a); __m128i flip = _mm_xor_si128(b, a); __m128i mask = _mm_or_si128(_mm_andnot_si128(a, b), _mm_andnot_si128(flip, diff)); return _mm_shuffle_epi32(_mm_srai_epi32(mask, 31), 0xf5); } Yeah... the FK? SIGNED 64 bit is at least reasonable.. // SSE4.2 static inline mask64x2 compare_gt(s64x2 a, s64x2 b) { return _mm_cmpgt_epi64(a, b); } But once again, only GT and EQ.. so the rest have to be synthesized.. AVX512 finally addresses all of these issues and is super fun to program with, and/or generate code for. It's also super-rare and AMD doesn't support it at all. But it's very cool stuff. :) So, say, C and C++ have these operators and hardware doesn't the point is that they can be still supported with the &gt;, == and !. If there is no !, then ^. :_)
Nice! In addition to the above mentioned links, which are a really good start, I'd welcome updates for new ISO papers, new videos from the major C++ conferences and new worthy C++ Books, blog and vlog posts from the best C++ sources. As long as you only include the few big C++ tools and libraries that most of use, I'm fine with such updates too. What I don't want is that you include small pet library and tool projects as well as non-authorative blogs and vlogs that floods the flow with annoying and uninterested updates every now and then. Tips on some sources: - http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/ - https://clang.llvm.org/cxx_status.html - https://gcc.gnu.org/projects/cxx-status.html
Thanks a lot, this is a great advice! I also was thinking only about core parts of the language and its infrastructure.
I like to say that I'll take people calling themselves "software engineers" seriously the moment they have to pass a standardized, complex and exhaustive examination to obtain that title.
&gt; This is exactly why &gt; std::ref &gt; exists in the original STL: it's for taking references to function objects. I must be misunderstanding, because `std::ref` doesn't exist in the original STL. And it's original purpose is not for taking references to function objects, it was for making `std::bind` capture by reference instead of by value.
But tag dispatch, for many, is something you'd do with SFINAE. Thus the circle is complete. Well, except for that gap.
I do not see an option in Feedly to export my subscriptions, unfortunately.
Well, if he's putting so much emphasis on comparisons without incrementating properly, I wouldn't take his optimization advice too seriously...
Lets not forget concepts
There is a good list of C++ blogs on the right side in https://akrzemi1.wordpress.com/
It's almost like people aren't very good at tasks they havent been trained on and practiced a lot.
Are the number of participants mentioned somewhere? With such surveys I always wonder if trends in the numbers are an indication of the actual trends in the industry or more just reflecting a different set of participants.
Yes, the rough count is mentioned in the general section. https://www.jetbrains.com/lp/devecosystem-2019/ It says "almost 7000".
Thanks. Of those, 20% say that they have used c++ at all and 9% use c++ as their primary language, so I guess we are talking around 1000 c++ developers that have taken part in this survey.
Write a logging library. That's a popular choice.
Yes, I was (perhaps wrongly) simplifying by saying that it means "move", but `&amp;&amp;` and `std::move` do not mean the same thing in any context I'm aware of. `&amp;&amp;` is part of the type of an rvalue, while `std::move` actually converts to an rvalue and can be thought of as more as an operator. The equivalent here would be if Obj o; Obj o2(&amp;&amp;o); called `Obj`'s move constructor (which of course it does not).
Open source projects.
In France, the term "engineer" is not protected (although you access it after an equivalent of a master, a bachelor would not be given an engineering role right out of school). But the term "graduated engineer" is protected. You have to follow a approved 5 year-long formation to be able to put on your resum√© "ing√©nieur dipl√¥m√©" and somebody lying about it can, in theory, be imprisoned for a year and pay a 15000‚Ç¨ fine.
Is this a real question? Yes if you copy some one else‚Äôs code from there product line for line and sell it as your own that‚Äôs a major copyright violation. Why are you even asking that, do you lack any kind of common sense?
&gt; Other engineers share their knowledge and software engineers don't? I think software engineers are very open about sharing knowledge for the most part. I don't see other professions out there with public outreach programs, or the equivalent of "everyone can code" bullshit. I think engineering, say, physical systems requires a lot more scrutiny and therefore knowledge-sharing than software engineering though. In many cases it doesn't matter to anyone in the business what the software looks like or how it came about because they only care about it working reasonably well.
Give us more informations. Are you interested in a particular topic?
Doesn't sound like line 4 line to me. Sounds like he used Quack Engine as a reference material / Copy paste to get the functionality down, and is currently working to understand what was copied.. Please refrain from writing down what you think demonstrates 'lack of common sense'. Regards
The OP explicitly mentioned that he/she doesn't just copy the code.
but one thing I always wondered is about stories like "X didn't want the licence to go from GPL to MIT, so we removed their code and rewrote it". must since it does *exactly* (more or less) the same thing, the new code can be quite similar or identical without looking at the original. Then what happens then? Also, when does it starts or stops being an infringement? (similar to the Sorites paradox)
Did you encountered any problems during the developpement of your 3D game? Write something generic that solves that and make it a library.
A bit out of topic here but what 3D engine did you use to create a 3D game in C++ ? I've been meaning to give it a shot but I don't which way to go.
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c22cjj/using_code_as_a_reference_infringement/erh68a1/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Just a few notes though: My code doesn't exactly do the same thing, which is why I am asking this in the first place. I didn't even get to using the Quake engine as a reference until I got into unknown territory. Everything else, the base architecture, the UI, these are all original works. I already had to adapt Quake's solutions to my own when I referenced it. My major concern is really what you just said. *When* does using references stop becoming infringement.
This exactly, except I didn't copy any code at all. I specifically avoided doing that, in order to avoid copyright infringement. I rewrote everything myself.
Yes, this is a question, in case you missed the obvious. I'm not literally copying the code and just pasting it into my work, I'm trying to learn how game engines work, and I'm using Quake like a reference, or a tutorial if you like. Sounds to me like it's you who's lacking any common sense, but judging by your profile you might as well be a painfully obvious troll.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c234tr/good_c_booksresources_to_read/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
https://www.chromium.org/ :)
'Tool provided by my IDE', 'I rely on a system package manager' says it all really: folk would rather not have to think about such things if they can get away with it. Which is fair enough as we are here to design problems to solutions, not go looking for solutions to non-problems.
Generally, when big companies do this, one person deletes the undesirably licensed code and another person, who never saw the original code, comes in writes the new code.
I used these libraries sdl and openGL.
&gt; When does using references stop becoming infringement. Your question is a legal one. In the same way you wouldn't hire a plumber to tend to your garden, you shouldn't rely upon programmers to answer legal questions that could impact upon your business. Now, if you're doing this as a hobby, from a practical perspective there's likely no harm done -- unless your hobby becomes insanely popular, and someone decides to pay attention to you. If you decide to publish something for commercial purposes (i.e., fat wads of $$$$) then you should consult a lawyer to determine your liability. After all, WHERE you publish your commercial work matters every bit as much as WHAT you publish and only a lawyer would know what questions to ask to properly ascertain your liability. Copyright law in this area is complex, and evolving. As to the WHAT of what you are publishing, the Quake source code is available under a GPL license. &gt; The code is all licensed under the terms of the GPL (gnu public license). &gt; You should read the entire license, but the gist of it is that you can do &gt; anything you want with the code, including sell your new version. The catch &gt; is that if you distribute new binary versions, you are required to make the &gt; entire source code available for free to everyone. &gt; . . . &gt; &gt; The primary intent of this release is for entertainment and educational &gt; purposes, but the GPL does allow commercial exploitation if you obey the &gt; full license. If you want to do something commercial and you just can't bear &gt; to have your source changes released, we could still negotiate a separate &gt; license agreement (for $$$), but I would encourage you to just live with the &gt; GPL. You would do well to read up on the GPL license scheme. https://en.wikipedia.org/wiki/GNU_General_Public_License Reading this should give you a starting point in understanding how the license binds you, what it expects of you, and what you should expect of it.
I'm shocked at the disparity between Clang (32%) and GCC (66%). I would have guessed the numbers would be reversed. Maybe I just live in a bubble? Also, who are the poor 10% of users using a "custom" compiler? This one just made me laugh: &gt; The majority of C++ developers claim that Python is the language they like the most. Having made a career out of wielding foot-guns, it's always nice to write non-perf-critical code in a language without surprising edge cases.
Check the codes licence and refer it to a legal professional. People saying ‚Äòof course‚Äô or ‚Äòobviously not!‚Äô don‚Äôt mean anything. This is a legal question for legal professionals not programmers.
&gt;I'm shocked at the disparity between Clang (32%) and GCC (66%). I would have guessed the numbers would be reversed. Maybe I just live in a bubble? I think it might be because of embedded systems? We had a custom Gentoo installation where I interned that we couldn't install anything on, so we made do with GCC. I'm willing to bet there are other companies that do something similar out there (or who just use GCC because it used to be a standard).
That has been debated and tested before. If you've read the source code, there's a high chance you could be creating derivative work. To do this right, you need to adhere to a [Clean Room Design](https://en.wikipedia.org/wiki/Clean_room_design).
I can't help but agree with much of what you just said. However, many people (non software engineering types) don't know how to properly constructing larger projects or have even wrestled with large code bases. Moreover, they don't take the time to learn the available testing/CI infrastructure because they are only interested in stringing together things that are relatively simple. Even worse, learning and applying these principles may seem like a waste of time for the scale at which they are working (maybe rightfully so) and will ever work on. Even once someone learns how to test it can feel like a chore to properly test everything -- especially if one knows that the scope of the project is (and will ever be) small. &amp;#x200B; It seems that one only begins to see the value in the principles that you listed after dealing with a project that have ballooned into something much larger than they originally anticipated. Then it is natural for one to invest in learning and applying these things. It seems to me that this is **partially an education problem**. Essentially, *where does a non-software engineer go to learn about planning and structuring code in a manner where the value of such is clearly communicated?* As far as I can tell: the answer is nowhere. One is left to create one or more spaghetti projects and hopefully stumbling across these principles when the time is right, or develop their own solutions to these issues. &amp;#x200B; I can admit to not being a software engineer. The only reason I know anything about testing and whatnot is by learning from experience and being fortunate enough to work on projects that applied these principles. Beyond that, I feel as though I'm stumbling around in the dark -- learning things that are hopefully pertinent. &amp;#x200B; What makes the situation frustrating is that there is an immense amount of pressure not to learn and apply these things because there are other aspects to work that demand attention. Once could say that it is also **partially a priority conflict**. How does one communicate to their boss that spending precious time on testing is prudent when there are pressing time constraints? Or even worse, maybe the boss is even more ignorant about software engineering and sees no value in testing. Or more likely, it is challenging to construct a strong argument to give to a boss on why testing work is more valuable than doing X, Y or Z (which sometimes, might actually be more valuable -- *heretical words, I know*). &amp;#x200B; There does not seem to be a silver bullet to these challenges. Unfortunately, there aren't enough software engineers who have enough domain specific knowledge to write all the code in the world. I feel like this talk was trying to encourage people to just write code, get work done, start projects and learn. However, I think it kind-of missed the mark and gave some bad advice in the process.
The GUI was problem for me, I just used the title bar for all communication. So I'm thinking of a library which can be used in any openGL application for GUI, you can provide a layout and it will take care of rendering.
graphics, networking, algorithms, maybe audio
So CLion‚Äôs users number is similar to Visual Studio? Sure
I mean specifically for cpp, vs is really big for c# etc but doesn‚Äôt have cross platform which is probably where the vs code lie is they like vs but use linux. But thats just a hunch, if you add vs and vs code its not that close.
I like the professionalism, it‚Äôs a different data source. ‚ÄúIf you happen to like twitter, then try this out‚Äù
&gt; Having made a career out of wielding foot-guns, it's always nice to write non-perf-critical code in a language without surprising edge cases. Also probably because Python has a very nice package management system with pip. It's always amazing how easy you can work with Python by simply installing and then importing the library you need. It's in my opinion one of the biggest weaknesses of C++, the lack of any kind of standard tooling. We have like 5 million different package managers, build tools, meta build tools, meta meta build tools, ...
Upvoted for Quack Engine.
I wouldn‚Äôt mind another temperature monitoring program. It would combine your language of choice, graphics, hardware and could add some network based features in (I‚Äôve seen weather included once). Imagine sidebar diagnostics but more in depth I‚Äôve just never really seen anything that is close to cross platform cpu temp monitoring. Ideally, actual core temp and other system readings. Very finicky and challenging to code since there are a lot of system challenges that get presented, but I don‚Äôt know much about the topic. Have you seen iStats for mac? Its very feature rich, and paid. You could maybe take it paid if you thought you had the project in a place where its worth money. I would absolutely buy a license to a program that is cross platform monitoring and I can just go to the website and download it for whatever system I‚Äôm on.
Legal questions are off-topic here.
How would you disambiguate passing container of elements vs single element sequence in which the container is that single element?
How would you disambiguate passing container of elements vs single element sequence in which the container is that single element?
Why don't you try to make your own GUI library? An example is [github.com/ocornut/imgui](https://github.com/ocornut/imgui)
Although I find it hard to imagine what a sensible use case for this would be, on the rare occasion you could just wrap the object in a static extent span.
Comment is superfluous and adds nothing to the discussion, therefore downvote. Proper way to show appreciation is to upvote the post, not add noise comments.
&gt; but I think it doesn't allow for mutation Elements why?
It would been interested to split between gcc and arm-none-eabi then I suspect we would have a clearer idea of how much of this is 'embedded'.
I've only glossed over the OP's use-case, but I've had a use case where I've got a `SingleValueVector` struct, that abstracts to a vector of a given size with a specific value, but doesn't take up the memory footprint of an actual stl vector.
For all that is holy, please never do that. Let's say I have a nice and properly tested algorithm for 'T&amp;&amp; container' written with your rules. It has a statement: if (size(container) &gt; 1) Then someone tries to be fancy and uses your trick to work with a single object. So far so good. The moment anyone adds .size() to their single object everything explodes. After the long nuclear winter, archaeologists of the future discover that this was your line to blame because: * The dev's intention was to check the size of the passed range (which is 1, because we are passing a single element). * The code now checks the size() property of the passed element, which is entirely unrelated to the 1-sized range that you implicitly passed. It can be 0, it can be 35, or it can be 1 (so that it accidentally passes your unit tests and explodes only in production). * Moreover, since this .size() is there for an entirely different reason (and no .begin(), .end(), etc. are provided), the rest of the code is inconsistent. Like, size() == 0, and yet begin() != end().
I apologize for the offtopic, this just seemed like the best place to ask.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c228fm/please_give_me_a_project_idea_to_work_on/erhqtwp/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Qmake has 9% usage share. Since the only reason to use Qmake for anything is Qt, it would indicate that more than 10% of *all* C++ development is Qt development, which is quite amazing.
But isn't it easier to use the binding feature of emscripten and the CMake toolchain file?
 std::vector&lt;int&gt; foo() { std::vector&lt;int&gt; arr; arr.resize(10); // or reserve and use push_back then. return arr; }
You can start learning go right now, they do exactly that as \*normal\*.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c25lks/i_try_to_return_an_array_from_a_function_does_the/erhscus/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, it's exactly as you said, your array is local to the function, and you're returning a pointer to the first element of this stack allocated array. So after the function returns, accessing via the pointed is undefined behavior. One solution is to wrap up the array in a struct, then return an instance of that struct. This will take advantage of the implicit copy constructor and return a copy of the array: ``` struct myarray { int a[10]; }; myarray too() { myarray m; m.a[0] = 12; ... return m; } ``` Or better yet, use std::array, which is pretty much the same thing, but with operator [] overloaded so you can use it like a regular array, and it also can be used with algorithms. Finally, if you want a dynamically sized array, use good 'ol std::vector instead. Hope that helps!
&gt; ... but &amp;&amp; and std::move do not mean the same thing in any context I'm aware of. `std::move` is a cast [as in 'change the type'], so after applying a 'function' `std::move` to `T`, it now reads `T &amp;&amp;` to the compiler, so now it can be moved from. It's not the same. because the context is different, `std::move` only makes sense to be applied to non-const lvalues.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c260t0/need_help_on_a_function/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yeah, the bindings make the JS side a lot easier to write, and the toolchain file makes everything nearly seamless. &amp;#x200B; Still, it can be useful to know how to do things manually like this, in case you need to debug something complicated.
The main usecase is fast and efficient ads
What you are saying all makes sense. Assuming that the type for \`value\` defines a move constructor, there would be be an implied move into the lambda capture context using the purported \`\[&amp;&amp;value\]\` (or whatever syntax is better).
lol I would've never noticed. Thank you.
Yeah, I mean I agree that moving into a lambda should be easier. I just agree with others that `&amp;&amp;` is not the right syntax as it implies something different. What I'm kind of saying is there should be an operator that converts to an rvalue (just like `std::move` does) but is less verbose, and then we'd use that. But all of this is really unlikely as C++ is pretty operator-dense already.
I assume that the "static extent span" is \[this\]([https://en.cppreference.com/w/cpp/container/span](https://en.cppreference.com/w/cpp/container/span)), which makes sense in a C++20 way. It's usually also not so bad to have a \`std::vector\` or \`std::array\` that only has zero or one items in it. &amp;#x200B; That said, \`std::optional\` already provides a pointer-like interface - it has \`operator\*\`, \`operator-&gt;\` and \`operator bool\` - even though it's not a pointer, and AFAIK there's no conflict between that and the container interface. The pointer interface is a convenient interface when you're expecting zero or one items. The container interface is similarly a common, convenient interface. &amp;#x200B; That is, IMO it's not really about a "sensible use case", but about conforming to expected interfaces of generic code. &amp;#x200B; There's a style/religion side to this too - IMO using \`std::optional\` helps to express intent, and potentially \`std::zero\_things\` and \`std::one\_thing\` could do the same specifically by highlighting the weird case. &amp;#x200B; That said, though conforming to an expected interface can be an issue in theory, in current C++ this isn't a real issue AFAIK. I "pre-invented" \`std::optional\`, but for the same reasons that \`std::optional\` now exists, and only ever remember using the container interface so I could use a range-based \`for\` to test for and name the content concisely. With C++17, we can do that with \`if\` (and even have an \`else\`) anyway. &amp;#x200B; And even if there's a case, that's a case to have special-case container types, not to treat any non-container as a container that only contains itself (with infinite nesting?)
Emscripten is the past. Modern clang (&gt;=8) alone can generate WebAssembly. Just add -target=wasm32-wasi --sysroot={compiled wasi-sysroot} to your flags and profit.
Most likely just the sampling bias.
That might work fine for small projects, but Emscripten is a collection of various tools, not just a compiler. Filesystem management, dynamic module loading, JS bindings, etc. are all rather difficult to get right without proper tooling. There's also the various libraries which have been ported to Emscripten, which I doubt would simply work standalone.
&gt; Hardcover: 832 pages Well that's why I've been always struggling at template programming.
I'm in agreement there, to the extent that `&amp;&amp;` has gained enough meanings that adding another meaning would be confusing. _But it is worth discussing._ My original suggestion of `[&amp;&amp;value]` was not made in ignorance of the existing meanings of `&amp;&amp;`. Instead, it was patterning after `[&amp;value]` which is actually is using a new meaning for `&amp;` (i.e. it is not `Value::operator&amp;`): it means to define a value in the lambda context using the type `const Value&amp;` or `Value&amp;` (depending if `mutable` was used in the lambda expression) and that its value should be the reference to the input `value`. In other words, the `&amp;` token to the left of the value coincides with the type modifier used to define the type of the captured value. Now, suppose that `value` (inside the lambda body) were instead moveable as designated by `[&amp;&amp;value]` in the capture expression. Should the type of the captured value be `Value&amp;&amp;` (the `&amp;&amp;` token to the left of the value becomes the type modifier of the captured value.) Perhaps, if one thinks the captured value should be a r-value. I can think of arguments for and against that.
Don't forget, that gcc is still the default compiler on many linux distributions (including red hat) and things like mingw on windows. I believe Facebook also uses gcc. Also, as mentioned by others, many embedded toolchains are at least based on gcc.
I studied their differences and I have to say that though emscripten (with fsstcomp backend) might be the best toolset for wasm32-their-weird-abi in JavaScript right now, their dominance won't last long because 1) wasi over emscripten's own sys interface 2) their fragile ABI becomes a problem when you want to use compiled wasm in third-party toolings like lucet, which only supports clang ABI. In the future I believe emscripten would be wasm-js-runtime , just similar to the behavior when EMCC_WASM=1 is set.
The jist of this talk is what goes through my head when people complain about the complexity of C++, and then also complain about undefined behavior in the standard. I feel like they could have avoided a lot of the complexity of `std::variant` by just throwing UB in the spec.
Yes, it may be surprising, depending on perspective. `[&amp;&amp;value]` (or whatever syntax is better) would mean two things: cast `value` using `Value&amp;&amp;`, and assign the result to the captured value using the move constructor.
&gt; Optimally the caller would not need to care wether the functions takes 1 or more elements. That is _very_ arguable. :) From my perspective, I would consider it a _very bad API design_ to not be explicit about this stuff. An arbitrary element is not a single-element-range. Pretending otherwise is confusing, stinks of black magic, and is unteachable. More specifically, there are plenty of algorithms that rely on SFINAE tests on thins like `std::begin` in order to detect whether something is range-like, and your proposal would break all of that code, which is not ever going to happen (whether or not you agree with my previous feelings on the subject). Given C++17/C++20 semantics, it's also _really_ not that big of a deal to use a `span` or the proposed [`view::maybe`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1255r2.html) in these cases at the call sites. :)
I think it's not losing your sanity with JS.
I'm uncertain why an overload of `std::size`, presumably implemented as `return 1;` to imitate a single-item container, would mysteriously result in 0, 35 or whatever. AFAICT OP is suggesting that a single object could pretend to be a single-item container of itself, which would therefore logically implement the container interface such that its size is 1, not zero or 35 or some random/undefined value. Am I mis-reading? BUT... I do still think it's a bad idea for non-containers to provide the container interface. Weird-case containers maybe, but those weird-case containers must be separate from the content. Apart from conflicts with other uses of `size` etc, one potential explosion is that some meta-programming library code might see that single-item self-container as an infinite tower of nested containers, and try to recurse that whole tower.
Many used cmake (for example kde project) and some part qbs, Qt is cool framework.
&gt; Modern clang (&gt;=8) alone can generate WebAssembly. Just add -target=wasm32-wasi $ clang --version Apple LLVM version 9.0.0 (clang-900.0.39.2) Target: x86_64-apple-darwin17.7.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin $ clang -target=wasm32-wasi x.c clang: error: unknown argument: '-target=wasm32-wasi' $ Thanks, Apple!
&gt; It should focus on accreditation of the designs, process and the product (like is actually done) for the use that it claims to do and must have all the "evidence" to back up its claims. And how would you propose we do that without first accrediting some individual(s) as being qualified to evaluate the evidence? If you don't certify the people, then nobody is qualified to certify the design.
Appleclang 9 is something like llvm 5-6 ish
Apple clang is a joke. Use homebrew.
Hey, I'm looking for work for the summer as a freelancer since it's summer time. I've been learning C++ for half a year, I'm really a newbie but I get most concepts and can do easy and intermediate tasks. I live in Hungary and I can do remote job. I don't have any previous work experience with C++ yet, so that's why I'm writing this comment. I hope to have my first job at least during the summer :) If you're interested, DM me or add me on Discord, my name is GreenMage#8709 . Thank you :)
FYI: QBS was deprecated in favor of CMake.
What happens when I pass in a Square, which happens to have a `.size()` function (returns the area of the square). Does `std::size(sq)` return 1 or the area of the square? Also, my thread library uses `begin()` to mean start the thread... Basically, this is all "duck-typing" which can work great, but also causes you to get your leg bit off by an alligator because "if I squint hard enough, everything looks like a duck". Consider an as_single_range(T&amp;) function that turns single items into ranges, but is a explicit about it. Also consider that you want some kind of functor/monad library, not a range library. You are trying to make everything a range, instead of making functions that work on everything.
Sure, but not implicitly. A box containing an apple is not the same as an apple, and autoboxing apples leads to insanity. Especially when you oass a crate, which could be a box or not depending on whims. Start with a span. Next, have a funxtion that makea a monospan. Now callers who want the apple boxed can function( monospan(x) ) and do it on purpose.
Well of course you would need to be careful. With c++20 you could check if the class fullfils the container concept. If it doesn't it is probably safe to treat the object as a single element container. std::size, std::data and others would not even call the elements member functions then. For c++17 or lower, I'd imagine you could check if the object provides all container like member functions (size, data, begin, end, ...) to see if it is a container.
OK - I thought you meant conflicting interfaces, but I didn't really follow your explanation, which reads to me like something was being treated as a duck for no reason other than being disguised as a duck. The devils advocate argument is that your disguised non-duck is only treated like a duck if you pass it to something that expects a duck anyway, and why would you do that if you don't want it treated as a duck? Even so, better to keep the container and content roles distinct. If we disguise everything as a duck by default and encourage people to treat everything like a duck by default, then the purpose of static typing has at least partly been defeated and conflicting interfaces will cause bugs that drive us quackers.
At this point Apple just use whatever version number is guaranteed to confuse us all the most, and appear to be actively removing stuff that is in mainline clang (\`std::filesystem\` I'm looking right at you). &amp;#x200B; Not cool Apple, not cool.
Can you please clarify, I am not excatly sure what you mean. I'll try to guess for now. I think you mean a function taking one or more containers. I will probably have to perform additional checks and special cases, at which point, I might as well just scrap everything and perform similar checks and specials cases for single elements... Your question made me answered mine. Thanks :)
Not that I disagree with you that C++'s less commonly known feature set is innovative in it's own way But I'm really confused why you'd call async innovative. That's been around for a very very long time as a general concept, and specifically the Networking TS is (roughly speaking) just Boost::Asio. Am I misinformed?
The big issue with linking C++17 programs against C++11 or C++14 programs is going to be API issues. To the best of my knowledge, the Big Three compiles (MSVC, GCC, Clang) are all fully ABI compatible between these three versions of the C++ language standard.
Thank you for the help. Your explanations were clear and concise. The one thing I'm left wondering about is the fact that std::string has SSO which would apply in these cases making the data not heap allocated. I guess because the string ctor is not constexpr regardless of SSO, this initialized object couldn't be as well. Is that how it works?
I though not hard enough I guess. Yeah, there would always be at some reference wrapper like solution. Thanks. Probably makes sense to use single\_view then, if explicitly stating it at call site is a good enough solution.
Thanks for the anwers. They were very insightfull. To summarize: My idea would not even work for functions taking one or more containers. One would need to handle the special cases, and might as well handle the single element as one. It is also dangerous if the types implement some of the container functions themselves, but with different meaning. I think it could be probably worked arround though. Adding overloads for single elements might break existing code, which depends on the existence of those overloads to check if something is a container. This seems to be the strongest counter argument and in my opinion invalidates my idea. Some say this would be bad API design. This is subjective and everyone might see this differently. I still think allowing something like this, could make some template code more convenient to write. Whether to expose this in the API is something everyone has to decide themselves. std::ranges::single\_view at call site would work. I forgot that there is always a reference wrapper / pointer solution to make something mutable. Using something like span and adding and implicit constructor would probably be the way to do it. I found that vulkan.hpp uses vk::ArrayProxy&lt;T&gt; to do exactly that. ([https://github.com/KhronosGroup/Vulkan-Hpp/blob/master/README.md#passing-arrays-to-functions-using-arrayproxy](https://github.com/KhronosGroup/Vulkan-Hpp/blob/master/README.md#passing-arrays-to-functions-using-arrayproxy)). TL;DR: Don't do this. Not everyone might like such an implicit conversion. A similar more explicit result can be achieved with std::ranges::single\_view, but might be ugly. Implicitly conversion could be realised with span like types with implicit constructors.
I mean, when I do `f(vector&lt;int&gt;{1,2,3})` did I pass a sequence of three ints or a sequence of one vector of ints?
Yes, indeed. There are proposals to make the default constructor constexpr, but SSO is a quality of implementation detail not mandated by the standard so there's no way to make any of the constructors constexpr regardless of the input length. :-/
A bit late to the party, here's my two cents, for what they're work. At my last job, we used a C++98 implementation of the STL with MSVC2015 and gcc... 6? Not sure on the GCC version. So we had access to most of the C++11 language features, and a small number of C++14 features, but were significantly limited by the STL implementation we were using. (STLPort for what it's worth. Don't ever use it. It's no longer maintained). Regardless, I ended up having to implement a whole bunch of stuff from C++11 myself, and retrofit those missing features into other parts of the codebase. Generally the C++11 features that I implemented resulted in faster compile times, and less bugs. And I say less bugs because the process of re-implementing the code in the "modern" way inevitably uncovered various corner cases that the original code didn't catch properly. Some of which were caused by compiler bugs covering up implementation bugs (or vice versa). Going forward, it's going to take a lot of money to convince me to use anything older than C++17. The amount of code that I write that fundamentally depends on C++17 is a lot, and I have no interest in going backwards. So, go straight for C++17. It really is worth it.
People have been asking for a nicer way of specifying op() template parameters on callable objects for a while, and no way has been forthcoming. Special-casing lambdas is a bad idea.
For the compiler it would probably also impossible to disambiguate if two overloads exists, one taking multiple containers and one taking multiple ints, unless maybe when explicit template parameters are used or additional arguments. Another thing I haven't considered, which makes my idea in its form even less viable. Well, I guess adding overloads for std::size and friends won't fix my problem. Probably best to look for a different option.
Their methodology section seems pretty solid so I feel like the skew is probably reduced and ms having a 45% market share seems pretty fair. Idk unless you see a glaring issue with the methodology.
See "Can I export my sources as an OPML file?" sect6. https://blog.feedly.com/opml/
It blows my mind that a lot of people use static code analyzers and 35% voted "None" for quality tools, but valgrind which makes wonders is not even on that list. Just like boom, mind blown.
A bubble I would say. There is a HUGE amount of legacy code being worked on, and there isn't really any business benefit in moving it from GCC to clang. I mean GCC isn't broken, so there aren't great incentives for moving away from it. I use GCC almost exclusively and it never provides any troubles. I don't see any advantage in moving to clang. GCC works for Windows, Linux, Embedded. GCC comes default on pretty much every Linux distribution and getting it updated isn't terribly difficult.
I'm really keen to contribute to this. Hybrid CPU-GPU scheduling, distributed parallelism, fibers + task based concurrency. Will look into how I can contribute to the parallel algorithms codebase
[removed]
No, it's not safe, regardless of what you are checking. In your notation a line SelectRandomElement(obj) has no meaning unless you can guarantee that obj will never change it container-ness during the entire lifetime of your code (which for C++ is typically measured in years). In many cases you can't control it, because you are writing a templated function yourself. People put iterable objects in containers all the time, add range-ness during random refactorings (because, dunno, "it was inconvenient to write users_group.GetUser(i); ranged for loops are better"), and sometimes remove it ("Since April we recognize two kinds of users and you are expected to call users_group.happy_users() and users_group.unhappy_users().") My point is: * When you change the concept and the code doesn't compile anymore, it's not scary: you can go and fix the code, and some other people can review your changes. If it compiles again and the changes look sensible, it's likely to be fine. * When you change the concept and the code still compiles because of some implicit magic, with a completely different behavior, that's some nightmare fuel. You have no idea what changed and where, and your only hope is that some test will catch the change. Look, if your project for some reason is full of single-element ranges (which for me sounds like an indicator that you are doing something weird), just write your own easy-to-type ObjToSpan helper and be happy.
Valgrind is useful when chasing a specific problem, but it's too slow and generates too many false-positives to run in CI for large projects.
I have quite a bit more experience than some professional, licensed, engineers that I know, but my region of the world does not offer any kind of certification for software engineering. While I meet the prerequisites to take take the appropriate exams to become a licensed engineer in my location, those exams would be completely off-topic for my software engineering. The exams offered are either Mechanical, Civil, Electrical, so on and so forth, or "generic". And the "generic" version of the exam is essentially a random sampling of the other topics. While I don't disagree with you in the philosophical sense, the practicalities are simply that there are areas of the world where it's not possible to become a licensed engineer, or not practical (my case).
I‚Äôm not sure Id call that ‚Äúnews‚Äù. Would be more like a cpp tips bot at that point.
&gt; If he can move a sugar cane plant, why can't we integrate two code bases? Because Antonio has a budget measured in the tens of millions, or even billions, and probably a year or three, involving hundreds of people. My team has a budget of $500,000 (our salaries), 5 people, 6 months, and all of our other work to continue to get done. That's why.
Can you add a license?
I'm ok with any name while it's doing what I need :)
&gt;teroxial wtf is that
Accreditation is not education. It's an attestation that a specific level of attainment has taken place based on the specific standards of that Accreditation body. Sometimes Accreditation requires education, but not always. It depends on what's being Accredited, and by who. In the generic sense, "Accreditation" does not imply a specific level of education, though it often might.
I added a license file for GPLv3. I already marked my headers with it but forgot to include the full license file.
Honestly, `f&lt;` already has two meanings to the parser: `f` is a template or `f` is being compared. The syntax everyone keeps asking for adds a third: `f` is*^(Close enough) an object of a type that has a templated function call operator. This is one area of parsing I'd really rather not complicate further.
https://godbolt.org/
These kinds of responses are always frustrating. I have done my own testing, but I'd like to ask the community for their response, in-case I've missed something or if there is a novel solution. Also, this way, the answer is shared with the community. If you think the question is bad for the subreddit, then report it.
People using their website are more likely to use either VS with their tools or their own IDE. So that would introduce a sampling bias I guess. Not sure how they got the people to reply so can't say how much of an influence it would be.
A function that doesn't affect global state and has a constant return should always be inlined with optimizations, and turned into the result.
I want to up-vote this more than once!
It's pointless to talk about hypothetical situations because in this case accreditation is directly linked to education. That's not always the case in every profession, it it is the case in the situation that we are talking about.
To be honest, in production clang does not bring much. gcc has catch up by a lot about warnings, and clang is no longer far faster as before. gcc remains [far] faster in many cases. So there aren't that many reasons to switch to clang.
[Boost](https://www.boost.org/doc/libs/release/libs/core/doc/html/core/ref.html) says: &gt; `ref` and `cref` were originally part of the Tuple library by Jaakko J√§rvi. They were "promoted to `boost::` status" by Peter Dimov because they are generally useful. And apparently it's also used by `function` library.
&gt; I have done my own testing Then you should had included the results of those tests so they could be, as you say, "shared with the community".
Right, and I get that frustration. But again, I‚Äôd rather get assurance or correction from the community by getting their opinions. That way I can eat multiple sources and really see if I‚Äôm being dumb or not. The ‚Äúsharing‚Äù is done by discussion in the comments.
The pointer is never pushed onto the stack; it is passed in a register in all ABIs I am aware of. This is unlikely to be optimized out unless the entire call is inlined. However, closures are not *just* objects equipped with a call operator ‚Äî if they have no captures, they are *also* implicitly convertible to a plain old function pointer, which behaves exactly like any normal pointer to any old function, no hidden parameter, no special ABI sauce, and no overhead to optimize away.
Yep, Concepts is basically duck typing where you check all the duck properties, not just one or two. And conclude, "well, it might not have been a duck, but it was indistinguishable from a duck, so who cares".
People are trying to help you help yourself, and you're dismissing them. When you encounter a difficult area and need help, it is most effective to say "here's what I'm trying to understand, here's what I'm doing, here's what I've seen so far, here's my interpretation" and then ask what you're missing/getting wrong. If you posted assembly output and said you didn't understand a certain part, or were unsure if it were consistent across implementations, that would be one thing. Instead it appears that you haven't done any research yourself - regardless of whether you actually have, nobody else is psychic. In any event, this question is off-topic here.
The person and I had a message discussion, and I agree, I‚Äôm sorry. Although, how is it off-topic? People discuss compiler specifics here all the time. I‚Äôm not trying to be combative, just sincerely don‚Äôt understand why it would be considered so.
It's a judgement call, but "quick questions" are more suited to StackOverflow. There's a limitless number of such questions that could be asked. Posts of the form "here is an interesting technique to consider using", "here are gotchas you may not have known about", "here are new optimizations that may influence how you write your code" are more actionable. Questions are sometimes acceptable when they're larger questions about how to write code; this one is very narrow. I'll undo my removal of this thread. Thanks for understanding.
That‚Äôs understandable, and thank you. I‚Äôll try to be more rigorous/reasonable in future posts.
Not really pointless, no. The accreditation is not the same as the education. One of the states in the U.S. (unfortunately, i don't recall which at the moment, sorry) started offering software engineering licensing recently, and the way they did it was "Either a bachelors degree from an appropriately accredited university, or X years work experience with proof" Further, simply having the education / work experience isn't enough. You also have to pass the F.E. and P.E. exams (But it's currently the "generic" exam which has nothing to do with software engineering and is basically all civil / mechanical engineering stuff that few software engineers would ever have a reason to know). So in many situations, the accreditation also asserts an education, but it is not the same thing as the education itself. But not in all situations.
Sorry but why? Isn't that just another case of "look what I can do" instead of a real use case? Where would you need a thing like that? Where would you use such a lambda in a way "as general as regular functions"?
Yeah, and it makes me angry: they fcking *created* clang!
If the function call gets inlined, the this parameter obviously gets optimized away. If it doesn't get inlined, it can't get optimized away, because it is part of the ABI spec. If the function call of a lambda doesn't get inlined, the is a good chance however that the lambda or the call chain is so complex that one parameter more or less doesn't matter.
How about `f.&lt;int&gt;()`
Here is the `build2` package page including CI results: https://cppget.org/libstud-uuid/1.0.2
Async relates to the Coroutines TS, not the Networking TS (though in practice the latter will benefit from the former).
Async relates to the Coroutines TS, not the Networking TS (though in practice the latter will benefit from the former).
"Dependency-free" &gt; `libuuid = dlopen ("libuuid.so.1", RTLD_LAZY | RTLD_GLOBAL);`
In my experience, I had to mark such methods as const and noexcept to have it inline and/or perform the empty base class optimization. (This was a number of years ago with GCC, it may well have improved since then).
I don't see any problems with that syntax choice (minus the expected "Why is that dot even there?!"). I'm pretty sure I've seen it suggested somewhere before, probably in response to someone suggesting the obvious syntax.
Saw that [too](https://github.com/libstud/libstud-uuid/blob/44ab55056d93a9b38175e90018d85107f7a9aa5a/libstud/uuid/uuid-linux.cxx#L69) and wondered what he meant by "dependency free".
Wonder if it is a common enough problem to make standardizing a solution worth while. Maybe even a generalized manner that works for all member operators like this: `o.&lt;T&gt;(arg), o.&lt;T&gt;[arg], o.&lt;T&gt;+=arg, o.&lt;T&gt;&gt;&gt;arg ...` but the last one seems problematic.
I agree. This seems such a rare used-car that I doubt it is worth worrying about.
I think that makes some sense. They basically have to be pure functions for it to always inline I suppose. The always-inline attribute would guarantee inlines happen too
Because `/proc/sys/kernel/random/uuid` is not fun enough! :)
I would expect an type changing its containerness would result in different contained elements, which would trigger compile errors in many cases. But I see you point. My idea seems to be the wrong route. Probably going for a ObjToSpan helper.
GCC isn't just "not broken"; it's a great compiler.
&gt; only reason I know anything about testing and whatnot is by learning from experience and being fortunate enough to work on projects that applied these principles I don't think any school actually teaches people how to build software.
UUIDs requires randomness, and you cannot have proper physical-world-entropy-based randomness without any kind of system call, so you are bound to have a dependency at some point.
So, it can‚Äôt be optimized away unless it‚Äôs inlined because this is defined to be this way in Itanium ABI? Just making sure I understand the first paragraph.
One option is to use tag dispatching: ``` template&lt;class&gt;struct type{}; template&lt;class T&gt; inline constexpr type&lt;T&gt; type_c; int main(){ []&lt;typename T&gt;(type&lt;T&gt;){}(type_c&lt;int&gt;) auto f = []&lt;typename T&gt;(type&lt;T&gt;){}; f(type_c&lt;int&gt;); } ```
I think he means you don't need to link anything. (ambiguity at its finest, I guess)
Sure, but calling another UUID library to generate a UUID is very different from just using a system call to get some randomness.
To approach it from the other direction, the cost of passing an extra unused parameter approaches zero in real world code. As long as no memory access is required, it consumes only instruction decoder resources in a modern out-of-order cpu which are unlikely to be a limiting factor if you have any dependency chains, indirection, calls etc. in the rest of the relevant code.
&gt; Sure, but calling another UUID library to generate a UUID is very different from just using a system call to get some randomness. but libuuid is not just a random library, it comes along in util-linux and is part of the kernel source tree. That would be like refusing to use anything else than kernel32.dll on windows.
Fine, but I would tend to assume that a "UUID generation library" would, you know, _generate UUIDs_, rather than just farm out that extremely key piece of functionality to an OS-provided library. While there's obviously a place for libraries that just provide a uniform interface to OS functionality, I'd want it to be made clear where that's the case. Calling it "portable, dependency-free" makes it sound like it'll be easily portable to, for example, an embedded environment with no "OS" to speak of. That's obviously not the case here.
It doesn't matter what the ABI is; if the compiler doesn't know what the body of a member function is at the point it emits code to call it, it has to pass the this pointer.
I bet most 32-bit Windows software will use `__thiscall`, which passes `this` in `ecx`: https://docs.microsoft.com/en-us/cpp/cpp/thiscall?view=vs-2019
&gt; makes it sound like it'll be easily portable to, for example, an embedded environment with no "OS" to speak of. well, how would it work if you are on a ¬µc and don't have any gettimeofday() nor rand()-like things ? it's not like you can generate UUIDs out of thin air.
&gt; -you need to re-write part of your code another time when switching to C++17 Are you using changed `{}` init, `std::auto_ptr` or something deprecated? C++17 does not really bring any significant breaking changes. There is practically nothing to rewrite.
`libuuid.so.1` is present on pretty much every Linux system (see another reply in this thread for details). In a sense it's like `libc` or `libdl`. However, its headers and `libuuid.so`/`libuuid.a` may not. &gt; Fine, but I would tend to assume that a "UUID generation library" would, you know, generate UUIDs, rather than just farm out that extremely key piece of functionality to an OS-provided library. An OS-provided UUID generator is the only implementation that I would personally trust for, as you put it, this "extremely key piece of functionality". One key feature of `libstud-uuid` is that it makes sure that the generated UUID is actually unique, which, turns out, is not a given. See the source code for the gory details.
Plenty of microcontrollers have hardware random sources and clocks and even if you're using one that doesn't you certainly don't need an entire OS just to host a clock and/or RNG. Most likely the vendor's support library already has those functions. "Version 4" UUIDs are basically just large random numbers, so really are generated out of "thin air".
Google C++ Style guide? No, thanks. I'm surprised that so many people use a guide that is in opposition of many language conventions.
While I agree that it's a rare case, it's one that is perfectly possible. We can argue about its uses and if it's worth implementing it or not, but it's something that caught my attention, as they don't behave as one could expect them to.
True, yet authors cover way more than just templates. I've myself learned a lot.
At enterprise level introducing static analysers it is still an uphill battle, regardless of the language.
Gotta take that Java syntax to the next level!
I just do conda install libuuid to make the problems disappear.
&gt; as they don't behave as one could expect them to. Why? A lambda is an object which has a call operator. Your examples show exactly that. So which part is unexpected? Templates were meant to generalize operations on operands (or groups of operands) so you can do `add(foo, bar)` and stuff. Not using an operand is already (kinda) abusing. Now putting lambdas in the mix even more so. That's why I asked for a use case for such trickery. What does warrant such a using? Isn't there a better (cleaner) alternative?
Reminds me of a quote by jwz: *Some people, when confronted with a problem, think ‚ÄúI know, I'll use regular expressions.‚Äù Now they have two problems.*
If the compiler versions you or the users of your code want to use support C++17, then switch. But you shouldn't rewrite existing working code to C++17 constructs, but write new code with C++17 features.
Oh man, it REALLY blows my mind that someone may release software in C++ without checking it with memory debugger beforehand. This is hardcore. This actually reminds me of heartbleed disaster when valgrind was showing memory problems for years, but openssl developers were saying this works as intended and it's a false positive. Mind blown. Also now i see the truth.
Compiling some code that as the misforntune to contain some Qt libraries. Suddenly linking crashes because libSM.so doesn't contain the correct version of libuuid. Huh? worked on Fedora 28, why won't it work now on F29? I have no clue what libSM is or what it does. I have no clue what libuuid is or what it does. Okay. whatever. dnf tells me libuuid is up to date... huh... Should I check the library, grep the error etc etc. turns out conda install libuuid -c xorg-utils or whatever made the problem go away. That's how things should work.
Give me one reason I should use this over [https://cs.chromium.org/chromium/src/base/guid.h?l=18-26&amp;rcl=802206d751786026d7b4a5ee307f2e529bd2f052](https://cs.chromium.org/chromium/src/base/guid.h?l=18-26&amp;rcl=802206d751786026d7b4a5ee307f2e529bd2f052).
This approach makes it unusable in fully-static binaries, since you can't use any of the `dl*()` functions in such cases.
I did a cursory look, and it seems to pull quite a bit of other bits and pieces (see, for example, `rand_unit_{fuchsia,nacl,posix,win}.cc`). My other concern would be whether this implementation actually makes sure it has a good source of randomness, which is a tricky area that, similar to cryptography, best left to the experts.
If you are static-linking all the way down to `libc`, then yes. Though in my experience this is not something that is commonly done (the result will only be usable in a very controlled environment). But we could probably add support for linking `-luuid` explicitly in such cases, if necessary.
My code can compile with gcc 9 under msys2/mingw64 but cannot compile with clang 8 due to some error in the system stl (from gcc). So there is no choice. I'm sure there are a lot of people in similar situations.
I'm not sure I understand your point about the executable being usable only in a controller environment - statically linking gives you only the kernel ABI as a dependency, which has been stable for at least 20 years now.
I think you don't get what I mean. Suppose I'm inside some function, and I want a lambda that looks like `[]&lt;typename T&gt;(){//...}` for some weird reason. Obviously, one could define a function outside that function with that same signature, and still get the job done with no problems. What I mean is that, doing the same thing with a lambda, you'll end up with a call like `lambda.operator()&lt;type&gt;();`, which is far from the way we expect it to be called (`lambda&lt;type&gt;();`, just like a regular function). Maybe you and I know why those lambdas can't be called that way, but many less experienced C++ programmers could be stuck with a compiler error, not knowing why their code is not compiling. I don't disagree with you; it's just a little flaw I see in tamplated lambdas. It may be not worth it trying to fix that, but at least we can argue about it.
I get that. I'm asking about 2 things: 1. What that "weird reason" could be. I can't imagine any valid reason (see above) 2. Someone implementing this will probably understand the error: The point where one runs into this error is the point where you realize a lambda is rather a callable struct (aka functor) than a function. This should have been known earlier, but well... And a "less experienced C++ programmer" does probably not use a very advanced thing like a templated lambda without arguments. This mixes 3 rather advanced things together.
It's been a while since I did anything like this but I remember there were some issues with `glibc` loading some of its components dynamically. As a result, your binary may try to load such a component from a different version of `glibc`. I also remember that the general recommendation was to link `libstdc++` statically and leave `libc` alone. But this might be outdated information. In any case, I am not denying that this could be a valid use-case and we are willing to support it in `libstud-uuid` if/when there is demand.
how do you build it? the README is lacking that information and I don't see a Makefile or a CMakeLists.txt.
just a question: how would you use that? pluck it out from the chromium source code?
I've just found another use case (if it's valid or not, I don't know): `auto f = []&lt;int N&gt;(){}; f.operator()&lt;5&gt;();`. I'm not justifying the use of it. I'm just saying that, to me, it's a flaw in lambdas or callable objects in general.
Or a nice little helper function template &lt;typename T, typename... Ts, typename Func, typename... Us&gt; constexpr auto invoke_lambda(Func f, Us... us) { return f.template operator()&lt;T, Ts...&gt;(us...); } template &lt;typename Func, typename... Us&gt; constexpr auto invoke_lambda(Func f, Us... us) { return f.operator()(us...); } int main() { auto f = []&lt;typename T&gt;(auto y) { return static_cast&lt;T&gt;(y) + 1; }; auto a = invoke_lambda&lt;int&gt;(f, 42.5); auto g = [](auto z) { return z + 2; }; auto b = invoke_lambda(g, 10); return a + b; }
You have a good point.
That is unfortunate. It is a very useful skill that can be applied in virtually every domain.
Yes, we need to clarify this in the `README`. It is built with [`build2`](https://build2.org) which is what we are using. But see also https://github.com/libstud/libstud-uuid/issues/1
I guess I was just suggesting that sometimes it's good to lead by example. Also don't forget that the people replying are human too and get jaded by seeing too many questions where the asker hasn't put in any effort. But also equally, I was a bit sarky with my reply too, was no need for that from me.
Have you considered using /proc/sys/kernel/uuid? Maybe that‚Äôs not present in all Linux distributions, but I‚Äôd wager it‚Äôs in the majority. I suppose that it‚Äôs even more minimal than the library dependency.
You should consider a license.
Beats reimplementing (likely badly, compared to hundreds of man-hours that were put in the OS implementation, and compared to the expertise of people who did it previously), doesn't it?!
Why can't one dl\*? (Honest question).
I'm surprised gcc is so high. I assumed Clang took the cake.
Yes, I looked into it but as you say it's not clear since which version of the kernel it is available. On the other hand, `libuuid.so.1` is present on every old distribution (like Debian 7 "wheezy") I could find. Additionally, I could not find any uniqueness guarantees/indicators (unlike for `libuuid`). But it could be a viable alternative if there are some clear benefits to this approach.
Glad that it was considered. Nice work!
First clang needs to catch up in hardware and OS support, specially embedded ones.
While the license (MIT) was mentioned in the `README`, for GitHub to recognize it one has to add a `LICENSE` file. Fixed, thanks for the report!
‚Ä¶ and on Windows it relies on WinAPI, and on macOS it relies on the macOS Core Foundation framework to generate the UUIDs. In other news, every ‚Äúdependency free‚Äù C++ library *ever* depends on a C++ compiler and virtually all depend on a C++ standard library implementation and runtime. Criticising this appears to me as the height of silliness.
On Linux the kernel can only load fully-static programs. Anything related to shared library loading is handled by a program called the dynamic linker (which is usually part of the system C library). This program provides hooks for all the `dl*()` functions, which do not exist for fully-static binaries.
&gt; pretty much every Linux system "portable"
Yes, parts of certain `libc` implementations are indeed loaded dynamically at runtime. You can however work around the dynamic linking requirement by not using the parts that depend on it (you will usually get a linker warning if you do). There are also `libc`s that are designed specifically for static linking, even one which is maintained by the kernel developers - https://mirrors.edge.kernel.org/pub/linux/libs/klibc/
In LTCG mode (LTO) MSVC does have an optimization which removes unused parameters, just as if they were never in the function signature to begin with. Both callsites and the function itself are compiled assuming the rewritten signature. This can only happen if we see every possible callsite. It also typically can't happen for address taken functions (including any virtual functions), because in those cases it's more or less impossible to know every possible callsite.
As lambdas are often called indirectly it's not that simple. Some devirtualization has to happen to inline them sometimes.
ABI specs are an agreement between the compiler and external users of the produced code (which, in practice, are typically different invocations of the same compiler) - not between the compiler and itself. MSVC isn't bound by the ABI when it can prove it is compiling a function and every possible caller.
This is correct; however compilers typically compile in bottom up order so often we do know the body of a function at the point we're emitting code to call it. And sometimes we do a prepass over all the code we're about to compile and make note of a lot of interesting things, then go back over it a second time and actually compile it (LTCG mode).
Err... Sorry, having trouble seeing how Coroutines TS has anything to do with asynchronous programming. Resumable operations, sure, but not "asynchronous" in the sense of "hey you, do this thing, let me know when you finish". https://cplusplus.github.io/networking-ts/draft.pdf See section 17.6 -- Asynchronous read operations.
Apparently LLVM is currently experiencing a lot of issues. Someone from LLVM told me that in a software engineering view, LLVM is a disaster. For those kind of reasons google is running their own spin on LLVM. Forgot the name though
You can just use \`boost::thread\` since \`std::thread\` is just another implementation of a cut down \`boost::thread\` interface. IMO, boost equivalents are better than \`std\` ones because boost development pace is much faster than that of the standard C++ library. Once a library gets into \`std::\` it code rots in there, IMO, because it is much harder to change and evolve \`std::\` than \`boost::\`.
What you're talking about is when you take a lambda and wrap it (type-erase it) into a `std::function`, and then you call the `std::function`. *That* involves a virtual call. Calling the lambda itself ‚Äî invoking the lambda's own call operator ‚Äî cannot possibly involve any virtual calls, because the lambda's call operator is never virtual.
could you exemplify? Seems like you are asking for a custom allocator
&gt; How would one fix such a bug by using standard C++ code? Transform recursive algorithm into iterative one, with explicit (std::)stack management.
Surprised by so a high percentage of people not using test frameworks
oh god, another one?
It's called stability and it's vital for many if not most users of C++.
Previous discussion here: https://www.reddit.com/r/cpp/comments/c21ft6/the_state_of_developer_ecosystem_2019_c/
How about Effective Modern C++? Have you taken a look at it yet?
on top of this, using boost is not always an option in industry.
I'm not completely aware of the current state of [http://wg21.linki/p0484](http://wg21.linki/p0484) , for a historical discussion I'd suggest viewing Patrice's presentation [https://www.youtube.com/watch?v=iDztwNhIVVM](https://www.youtube.com/watch?v=iDztwNhIVVM)
I don't understand what you mean by \`(std::)stack\` management. \`std::stack\` is the data structure, not a way to interact with the execution/process stack or stack size.
Sorry, late to the party here. I couldn‚Äôt answer it better than has been done above! I too am awaiting a stable release before rolling out it as our build system. That being said, I have been impressed again and again with it.
Two such papers were looked at in 2016: [p0320r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0320r1.pdf) and [p0484r0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0484r0.pdf). 484 applied committee feedback and went on into 2017 as [p0484r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0484r1.pdf) and there doesn't seem anything newer in public record. Meanwhile, boost.thread supports this and is portable and reliable.
I believer the commenter is suggesting managing a stack manually (located on the heap) and iteratively executing functions in a loop, instead of relying on automatic stack management via recursion.
That I understood, but \`std::stack\` has nothing to do with The stack.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c2k23e/advanced_cpp_material/erkpfw4/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, I am referring to when lambdas are passed around, stored into std::functions, or otherwise decay/convert to function pointers. I view this as the "typical" usage. Direct invocation of a lambda is a direct call, as is passing in a lambda object as a template parameter to a function (which is also quite common).
I was suggesting that std::stack could very well be used for manually managed heap-located "The Stack".
That's the point. They're saying to use std::stack to reimplement the other stack (but with support for arbitrary depth).
Removing this one as an exact duplicate.
Sorry I can't help it - it's \_gist\_, not \_jist\_ :-) Also unrelated to your comment but what's with the ":-)" in the speaker's name? Am I missing the joke?
I am in the 1% with kdevelop? I don't get it, why do people like vs code so much? I tried it and found it far inferior to kdevelop. Also, I look forward to being able to switch to c++17 as over two thirds of us...
Yes, but for as far as I know and according to [http://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/](http://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/), 'deprecated' only means that qbs will be no longer maintained by the Qt Company. If I understand things correctly, it \*might\* be maintained by 'the community' in the future, see [https://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/#comment-1205579](https://blog.qt.io/blog/2018/10/29/deprecation-of-qbs/#comment-1205579) If that will actually happen... I have no idea... (for the record: I have never used qbs, I'm just trying to keep up with things by tracking build system info and references at [https://github.com/BartVandewoestyne/Cpp/tree/master/tools/build\_systems](https://github.com/BartVandewoestyne/Cpp/tree/master/tools/build_systems) ;-)
I am in the 1% with kdevelop? I don't get it, why do people like vs code so much? I tried it and found it far inferior to kdevelop. Also, I look forward to being able to switch to c++17 as over two thirds of us...
&gt;my interest is in learning how to make cell phone app games with c++. Are you a masochist? lol
I don't see how that's a masochist. I hate pain &amp; suffering. I suppose I will put up with Python tutorial then before jumping to Cpp.
I tried codeacademy and i didn‚Äôt like it at all, i didn‚Äôt feel things were explained nearly well enough, i switched to books and have been going through them slowly and have found my understanding improved greatly, still a complete novice but certainly better for switching to books, primarily programming and principles 2nd edition then will most likely move onto something by scott myers
What he means is that aside from focusing on your problem of creating the game, with C++ you'll have to also focus on the language's very elaborate feature set. It is a LOT to keep in mind, especially if you are a beginner.
&gt; Sorry, having trouble seeing how Coroutines TS has anything to do with asynchronous programming. Quote of the year right there! Err... I'll just respond with [another quote]: &gt; Coroutines address the dire need by dramatically simplifying development of asynchronous code.
I have no idea what you mean by "the language's very elaborate feature set". So, you people are saying it's hard to program a cell phone app game with c++ for a beginner?
It's a tweet with a shortened link to a blog post to a humble bundle. Actual content: https://www.humblebundle.com/books/programming-packt-books?partner=promodays
Lambdas implicit function pointer cast clones the call operator into a static member function and gives you a pointer to that.
&gt;I have no idea what you mean by "the language's very elaborate feature set". I mean C++ is a HUGE language compared to many others. Which means it's a double edged sword. C++ has a lot of power. It can do practically anything you'd want to do with it. On the flipside it doesn't hold your hand while your working with it, meaning there are a lot of "gochyas" to watch out for (like holding on to a reference when the referenced object has gone out of scope, for example). &gt;So, you people are saying it's hard to program a cell phone app game with c++ for a beginner? This would really depend on the phone, the app and the beginner. The probability for it to be hard is pretty high, however.
In addition to what others have mentioned, C++ isn't the primary language for programming the two most prominent mobile platforms. iOS requires that your programs be at the very least wrapped, if not written entirely, in Objective C, a very different language from C++. Android supports C++, but most of the Android community uses Java. Unreal Engine handles this for you, so C++ would be useful there, but Unreal C++ is its own flavor with a lot of complexities on top of the normal C++ feature set. I don't want to discourage you from learning C++, it's an excellent language and I love it. I would just lower your sights from making cell phone games to making simple PC games for a start, and even then, I would recommend you get started with Unity in C#.
I think, after I teach myself the basics of C++, I will look for some open source codes for C++ games. If I can understand the codes enough, I can probably edit them to make my game.
Wait, so smartphone games don't use C++? Cause it sounds like C++ is a hassle, and if I don't need it, I don't want to bother learning it. Should I study C# or Java instead to make smartphone games?
They're for simplifying asynchronous code. They are not, themselves, asynchronous.
If you're just getting started, I recommend C#. Unity (very popular game engine, fairly easy to use) can export to both major mobile platforms. There are lots of good tutorials online, Google should turn up good options for you.
Can I make smartphone games with C#?
A game engine is a set of tools to handle a lot of the necessary parts of making a game: graphics, physics, platform specific functions, and a lot of the infrastructure on which the actually game logic gets built. Unity is the most popular game engine for small projects. When you use it, there are options to compile your game to run on mobile.
So, I don't have to learn C++ to make smartphone games? I can learn C# instead? And C# is more convenient and easier?
I agree.
Not all correct in detail, but right enough for you to be able to get started. I'd also recommend checking out /r/gamedev's sidebar. There'll be plenty of info there you can dig into.
Thanks.
I think this link will help you understand what you're up against: https://en.cppreference.com/w/ Good luck!
It's just my pathological english textualization (I mean that I just can't write proper english): teroxial (or maybe teroxical) means to me beautiful C++ code in business/factory application domain (and that means to me Windows services with relational databases, handhelds still with Windows CE, Web/Https/Jsonrpc, PLC (Siemens Simatic), automatic robot/conveyor interfaces etc.) - and I have ledzeppelical impression that teroxi(c)al C++ means to everybody else (at least here) heretic or even disgusting wannabe-Java-C#-like code filled with strange alienated patterns like linsql: language integrated SQL without external ORM tools, implemented only with C++ standard compiler and preprocessor - based blessed unholy macro: #define sql(...) = #__VA_ARGS__##_sql;
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For those wondering why anyone would actually want this, as always it's us embedded folks doing weird stuff. When running a task switching capable is on a microcontroller (like freertos), you do not have virtual memory, so fragmentation easily becomes an issue. That combined with how little ram we get (32KB? Woh, look at mr moneybags here with his unlimited power consumption) means we want to precisely control how much ram we give for each individual stack. With freertos that's just an argument to the task creation function, but once we want to get fancy and use std::thread, was loose that ability, which often is a deal breaker.
I would like to explain my own experience as a college student(Our intro to programming lecture was in c++) First week of the class we were told to install linux on our systems and most of the students installed linux as a vm and some others as dual boot. We learned little to nothing about compiler/ide options out there and we started using gcc and vim right away for the whole semester. (This was how most people learned c++ in my class) My experience was a little different. I knew I could use my windows machine to program in c++ but I needed an ide so I took a look at my options there were some popular options out there but only usable idea with decent UI were Clion and VS. So I downloaded VS first. I was new to programming but I am pretty good with windows and in general with computers. But this was no easy process, it was confusing as fuck trying to enable my c++ code to compile on windows. My code gave me weird errors and stackoverflow was not really helpfulz Later on I downloaded cygwin and tried to set it up and had ton of problems with it too. Then I tried Clion and ot was basically the repeat of the VS problems I had but this time it compiled! So I did some of my assignments on there but it was still not a smooth experience I always had some weird errors and problems with the ide and compiler clang wouldnt accept something on my code whereas gcc on out cluster had no problem compiling the exact same code. So I gave up and coded everything on the cluster with vim and compiled it with gcc. Then I found out about linux subsystem on windows and I have been using gcc on ubuntu subsystem on windows 10 with Visual Code ever since. Second best experience I have had with programming and compiling following programming on Linux. Also even in advanced classes all of our profs are using gcc as far as I can tell.
This was my experience with clang too
Which CMake toolchain file are you two talking about? Is there one in emscripten that I'm too blind to see?
I see now. Thank you.
Scott Meyers‚Äô answer was that you simply shouldn‚Äôt, because it‚Äôs always a mistake. If you need container-independent code, use iterators.
That's just, like, his opinion, man.
something approximating ` void fn(std::ranges::Range auto&amp; container) { //do what you need } ` will be possible in c++20 (probably).
What about using `native_handle` and then using the handle for your specific platform? I know that for GCC and Linux the handle is the POSIX pthread_t type.
Taking anything that matches the concept of having a begin and end function that gives you objects that meet a suitable iterator concept is basically equivalent, just makes the calling a little easier at times.
It‚Äôs called ‚Äúexpert opinion‚Äù for a reason. Do you know what depth and length of research Scott does before he comes to what you cal ‚Äújust an opinion‚Äù?
Kinda like poor man‚Äôs ranges?
although you may want `std::ranges::View auto` instead (Range auto&amp; is like taking a std::vector&lt;T&gt;&amp; while View auto is like taking two vector iterators by value).
I haven't seen this syntax before. Is it possible to put a concept in front of auto to force the type it derives to to match that concept?
I'm gunna assume he said this before ranges were a "thing"
I haven't seen this syntax before. Is it possible to put a concept in front of auto to force the type it derives to to match that concept?
Yes I do. And do you know what "appeal to authority" is?
yep! it's the same as ` template&lt;std::ranges::Range R&gt; void fn(R&amp; container) {} ` you can also write `void fn(auto T)` wherever you want in c++20 and it will give you a template.
Ranges aren‚Äôt containers. :) But of course he did, as this was Effective STL that predates ranges by well more than a decade.
Basically. You can even write a container like class that can construct itself from anything matches those concepts automatically. Then you can use that to standardize your interface with them, though official ranges will basically always be the better option when they're available.
Right. They aren‚Äôt generalized containers. As far as I understand.
man pthread_attr_setstacksize. Just look at man pthreads, they have tons of routines for changing thread properties.
Yes, I do. And do you know what ‚Äúrefer to existing published research‚Äù is? And do you know what ‚Äústraw man‚Äù is? Cs√∫sztat√°s in Hungarian.
IIRC in most threading models stack size cannot be modified after a thread has already been created
That's why I made my containers polymorphic. You can do all of these types of things very easily, without templates. Of course, with collections design, it's sort of whack-a-mole mode. Every decision to do X probably means you can't do some Y or have trouble doing some Y.
It‚Äôs funny how I always easily succeed when I am not trying (and fail when I do). Like here, with my previous comment I did not mean to be an a-hole...
That opinion was from over a decade ago. With concepts and better templates it is much less of a mistake and sometimes useful to allow passing generic container like objects. Ranges kind of epitomizes when it is useful I believe.
That opinion was from over a decade ago. With concepts and better templates it is much less of a mistake and sometimes useful to allow passing generic container like objects. Ranges kind of epitomizes when it is useful I believe.
That opinion was from over a decade ago. With concepts and better templates it is much less of a mistake and sometimes useful to allow passing generic container like objects. Ranges kind of epitomizes when it is useful I believe.
That opinion was from over a decade ago. With concepts and better templates it is much less of a mistake and sometimes useful to allow passing generic container like objects. Ranges kind of epitomizes when it is useful I believe.
it's quite good at dealing with projects that have "special snowflake" build systems. It's completion engine is also pretty good about recovering from errors and working dispite not knowing everything about your project. I &lt;3 kdevelop but last time I used it the whole ide would crash if clang crashed while doing completion. They've probably moved to clangd by now though.
Ranges aren‚Äôt containers and I don‚Äôt think anyone has ever claimed that they are.
perhaps many of the interviewed developers work at google :D
I think you should switch to semi-automatic :D
a lot of embedded toolchains are based on clang too. also GCC is a very, very good compiler. Would be neat to see the overlaps in compiler usage.
Ranges would like to have a word with you
My internet is flaking out. Must've caused the retries to actually each post separately. Deleted all the ones without replies.
Ranges are not containers. They do not create container independent code more than iterators do. They do enable much much nicer way of expressing such code though. Ranges are awesome.
Yeah. Something weird was going on there. I hope the net cannot do that with online orders. I‚Äôd hate to get 15 pizzas. :)
They can be used basically anywhere where one would've wanted to accept a generic container argument. They are not containers in and of themselves but they can work as views into containers that allow container agnostic implementations without having to just take in iterators.
Just use vector. Is there really any other standard container besides vector?
Ok, maybe I miss something but as far as I understood ranges they do not enable what Scott describes as ‚Äúcontainer independent code‚Äù. Basically they enable what was earlier possible using iterators but in a much smarter and nicer way. With more automation. But they cannot ‚Äúundo‚Äù those differences between containers that make container independent code not possible. Like they won‚Äôt make it possible to do a quick sort on a singly linked list. It is possible to make code that can result in a sorted range and looks the same regardless of input (except infinite input, even god does not have enough time to sort that) but the result will not be the same. The O complexity, will not be the same. So while doing that code with ranges (on a specific container) may make sense, and ranges enables the syntax, making that into a template (lets call it an algorithm) that can work on any input is probably a mistake as it‚Äôs actual behavior (memory use, computational complexity) will widely vary depending on the nature of the input. So my understanding was that while ranges allow us to use syntax that flexibly accepts different input (as if it were, different iterator categories), but it does not promise and even cannot promise to generate code that behaves the same independent of the type of input. And to me, that would be container independent code. To me, for any algorithm, the O complexity is an essential part of its contract.
You can use `RandomAccessRange` if you require random lookups in constant time. Also all containers are ranges, but not all ranges are containers.
Random access is an iterator category, not a container category. Is there a SequenceRange? Is there an AssociativeRange? Those are container categories.
From a quick browse seems neat! From [here](https://github.com/libstud/libstud-uuid/blob/master/libstud/uuid/uuid-linux.cxx#L45), // Use a union to cleanly cast dlsym() result (void*) to a function pointer. template &lt;typename F&gt; static inline F function_cast (void* p) { union { void* p; F f; } r; r.p = p; return r.f; }; is this just a wrapper for a clean way to cast the return void* to the correct function pointer type? The alternative being reinterpret_cast but this expresses intent better and you can't accidentally cast to anything? Are there any other pros or cons to this approach? Seems quite nice actually. Also [uuid/uuid-linux.cxx#L11](https://github.com/libstud/libstud-uuid/blob/master/libstud/uuid/uuid-linux.cxx#L11): `using namespace std`. I thought it was "common knowledge" this was bad practice as per massively upvoted stack overflow questions such as [this one](https://stackoverflow.com/q/1452721/8594193) even if it's only used in the implementation file? Am I wrong, is there a reason in particular *to* use it here for instance? On a related note to this since you're *the* build2 guy, a question about projects and build2. How does or how do you envisage a project such as this working with multiple build tools like cmake, build2, ninja etc? For example if I wanted to use this project and I was using CMake but your build scripts etc. are build2, how would I do it? Is this possible currently, or something you do/don't aim to support in the future/ever? Is the answer simply (but perhaps somewhat sadly) to maintain both build2 and cmake build files in the project? From an admittedly cursory glance at the build2 faq I don't see anything answering this, apologies if the information is there but I've missed it.
It seems we had different meanings to what we meant by container independent code. I just meant code that could run with any container with equal correctness, much like how passing iterators allows. While I do think the O complexity of algorithms is important I think there is benefit in the generic approach that depends on its inputs. Many abstract classes end up implementing algorithms that depend on the O complexity of the abstract members which is often different with different implementations after all. Starting with that tends to be easier to develop and maintain in my experience. If later it was found that the generic code was a performance bottleneck you could write specializations for the containers it was inefficient on. Overall at this point I don't see much of a difference between using Ranges or similar constructs for code that can run with different containers versus passing iterators to do the same.
OK. I try it with different words. I‚Äôm saying that container independent code is an illusion. It is possible to write certain code so that it will compile and they will (let‚Äôs say) all calculate 42, given the same values as input using different containers. But the actual characteristics of the resulting machine code may be very different depending on the container.
Being able to work with boost containers or stdlib containers is really valuable in a lot of contexts.
Writing code with the same syntax has actual benefits as long as it is used to create concrete code with well understood characteristics. Perhaps I have seen too much bad code in my life. Suppose SQL. I write a query. It will behave very different on a database that has certain indices defined and those that don‚Äôt. And it‚Äôs changed O may make it prohibitively expensive but so that it only manifests itself beyond certain amount of data that it is unlikely to get in tests. I guess that I have seen too much badly behaving code because people thought that the same syntax means the same behavior. Because it can create the illusion of container independence. But it is an illusion only. Because of another container needs twice as much memory, which I don‚Äôt have...
Basically your last sentence made my point for me. Ranges do not allow code to be any more independent of the containers than iterators did. Only with a seriously more amazing syntax.
As for polymorphic behavior that offers worse O complexity than the interface/base class promises in its contract: that‚Äôs just badly broken code. A concrete/final implementation of a virtual function must fulfill the contractual obligations of the interface it implements because its users program against the contract of the interface. And Liskov et cetera.
sure, but often my function is just iterating through the whole container, or I want to be able to use both std::vector and something like QVector (which has the same perf garentees but focuses more on abi stability over strict perf).
Ok. But those two sound like the same thing. Contiguous sequences. No wonder it matters not how you iterate through it. And I am not saying it is not possible to write code that will work similar enough for a reasonable set of containers. That was already possible with iterators. My point is that once we are trying to go beyond that, things get harder, error-prone (by users who don‚Äôt familiarize themselves with what‚Äôs happening behind the scenes) to outright impossible (due to increases to the needs of compute resources such as CPU time or memory). I guess I am an old and broken record as I can just keep repeating the same message: beware of the illusion of container-independent code.
What's wrong with a computer science masters?
&gt;Is there really any other standard container besides vector? Yes?
&gt; Also only libc++ STL properly uses fancy pointers. This.
I think the comment was intended to be sarcastic. The fact is that msot of the time, you should be using vector.
How much do you pay? I'm willing to call programming 'coding' but I will have to charge extra.
Not just small embedded microcontrollers, either. One of the platforms I work with has 8GB of RAM and an x64 CPU, but defaults to 64K of stack space for worker threads unless you override the thread creation parameters.
I'll spare you the effort, I'm only freeloading at the momentüòÇüòÇ
&gt; it‚Äôs actual behavior (memory use, computational complexity) will wildly vary depending on the nature of the input. Call std::lower_bound on a sorted container with random access iterators. It'll work, and it'll give the answer in logarithmic time. Now try the same on an std::list. It'll _still_ work, but the answer will be given in linear time. This is not a mistake. It's a _feature._ I mean think about it: if you knew ahead of time that using any container would result in the exact same time and space complexity, the containers would be interchangeable so you might as well pick one and stick with it. On the contrary, the performance differences between the various containers can be an important reason why you'd want to write generic code -- so you can empirically pick the best one, now and tomorrow when your requirements change. It _would_ be a serious mistake if the algorithm crashed or gave a wrong answer. But the Standards Committee and the STL implementers thought about that. An algorithm that takes random access iterators will fail to compile if passed some weaker type, whether or not you wrap it in something else. template &lt;typename Container&gt; void my_sort(Container &amp;container) { using std::begin; using std::end; std::sort(begin(container), end(container)); } ... std::list l{2,3,0,1,-3}; my_sort(l); // won't compile. If you're paranoid and/or aren't relying on some STL algorithm that will fail in this way, you can SFINAE out containers that don't satisfy your constraints: template &lt;typename Container&gt; auto get_iterator(Container &amp;&amp;c) { using std::begin; return begin(c); } template &lt;typename Container, typename Pred , std::enable_if_t&lt;std::is_base_of_v&lt; std::bidirectional_iterator_tag, typename std::iterator_traits&lt;decltype(get_iterator(std::declval&lt;Container&gt;()))&gt;::iterator_category &gt;, int&gt; = 0 &gt; void my_stable_partition(Container &amp;container, Pred p) { using std::begin; using std::end; std::stable_partition(begin(container), end(container), p); } Ugly as hell, but luckily we'll soon have concepts to take care of just this sort of thing. And ranges, for that matter, which do exactly what we want.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c2qpyb/projecthelp/erm0200/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; and it will give you a template. So, am I to understand this will follow template type deduction rules? What happens if I call `fn({1,2,3})`?
Right. I picked vector almost every time. list? you mean vector associative array? you mean sorted vector etc
Even when you needed a map? Interesting.
Elvis "The King" Presley, etc. It has been part of his signature forever, don't know where it started.
Neat
A sorted vector of pair&lt;key,value&gt; typically has better locality, whereas a map is spread out over small allocations. Sorry for being a facetious with my glib answer. I don't mean to put down the article. It makes sense that a function should be able to abstract away the container ie "this function adds up all the elements, I don't care what container is used". That makes sense. And it isn't easy to do - either you end up with templates (which isn't always practical for large functions), or you end up with a virtual call per element. So what I typically end up doing is realizing that even though I want the generic function, all the places we need the function actually all use vectors anyhow, so just use vector. And if I do really want to work across any container, I often don't pass a container nor begin/end, I pass a "source" function that I pull elements from. So it could be a container or a stream, etc. that is more generic than a container or range. https://godbolt.org/z/qGryBP
I never said it‚Äôs a bug. It may become a bug if someone is unaware of it. I said it has different characteristics, hence it‚Äôs not container independent, hence container independent code is an illusion. The other thing I stated was that as far I can tell ranges provide no more container independence than iterators, except they do so with a more amazing syntax. You made up a straw man and are arguing with it. And I know what the committee does, being on it and the reflectors since 2003. :) And working for the past 5 years right next to a past LWG chair, I am even more amazed about the amount, detail and precision of the work being done.
Since Ranges are just a pair of iterators his assumption is still valid.
ranges are not always pairs of iterators, you're thinking of views. (All views are ranges)
&gt; . You made up a straw man and are arguing with it. No, actually, you did. You're assuming entering into this discussion that a "container independent" algorithm would have to run in exactly the same way and in exactly the same time on any container. As I pointed out, that assumption is not only incorrect (nobody wants that), it makes the whole project moot (no point in different containers if they're all the same). What people want is precisely the same container independence as provided by iterators, but with a syntax that's not horrible. So ranges really is the solution here.
Holy crap that's impressive. I'm still doing SFML c++ 2d rendering and particle effects and that takes me about 2 hours for a javascript ported game. One day when I have enough courage I'm going to tackle 3d and this video blows my mind!
Regarding pointer casts, I don't believe it is actually legal to cast a non-function pointer to a function pointer with `reinterpret_cast`. Regarding `build2` and other build systems, yes, it's a though problem. One approach is for build systems to agree upon a common interchange format, like `pkg-config`. In fact, `build2` automatically generates `pkg-config` files for libraries that it installs (see [Package Consumption](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#guide-consume-pkg) for details). Unfortunately, CMake does not support `pkg-config` preferring its own description file. It's possible that at some point we will add support for generating that in addition to `pkg-config`. But, overall, if you are using multiple build systems, there will always be friction and inconveniences, unfortunately.
What would be your preferred solution for this case: link to `libuuid.a` explicitly (and thus require the presence of the `-dev` package or equivalent) or use `/proc/sys/kernel/random/uuid` (which may not be available on older systems and does not seem to come with any uniqueness guarantees)?
You are welcome to contribute CMake support.
Bisqwit is awesome at C++
Even better is that this is under msdos with cpu rendering i believe.
There is a difference between stability and stagnation. std::thread has stagnated after its initial addition to the standard with the minimal interface it got in c++11 - I guess because no one cared enough to add the more advanced functionalities to the standard and instead just sticks to the platform specific APIs or Boost.
Casting via union is undefined behaviour in C++, it is not legal to assign one member and read another one. The portable way is to use memcpy to copy bits from one variable to another one. C++ 20 will have [std:::bit\_cast](https://en.cppreference.com/w/cpp/numeric/bit_cast) just for this, and it is rather trivial to implement.
awesome talk!
Fix this mess: https://cplusplus.github.io/LWG/issue2089
So then why the opengl api calls? :P
It's Mesa, the software implementation of OpenGL.
It really doesn't. If you read it the buck pretty much stops at rand\_util\_\*. &amp;#x200B; Its source of randomness is (on POSIX for example, similar arguments apply for all other platforms) "/dev/urandom" ([https://cs.chromium.org/chromium/src/base/rand\_util\_posix.cc?l=33&amp;rcl=031cc19658aa4eda7aa803a77ea0b0487e11408c](https://cs.chromium.org/chromium/src/base/rand_util_posix.cc?l=33&amp;rcl=031cc19658aa4eda7aa803a77ea0b0487e11408c)). Note that \`base::RandBytes\` (aka \`crypto::RandBytes\`) is used throughout the codebase for security critical purposes. This is security sensitive software used by north of a billion users. If you have concerns about the quality of the source of randomness it's using, then I suggest you reach out to the Chrome team. In other words, using this code \*is\* leaving it to the experts.
Yes.
For me, the comment I replied to, seemed to indicate that the project implemented software rendering.
It does, through mesa's software implementation of opengl...
Inplementing software rendering -&gt; writing your own rasterizer etc. To be honest, at this level of complexity even a non-optimized version would work okay.
As long as you document the runtime dependency on `libuuud.so.1` all should be good (the way you worded it in the readme makes it seem like there are no runtime/linktime dependencies required). My initial response was just an observation. As you said in the comments in your code, your implementation works in a majority of cases on pretty much all distros. If you care about generating fully static binaries you do have to make an effort to get them, so not caring about/supporting this use case in your library is perfectly fine.
My first thought was: template &lt;typename T&gt; using Box = std::array&lt;T,1&gt;; But your way is better.
I usually lurk at conferences on youtube. This time I was there and...oh boys it's another thing ! Awesome.
So I just glanced at this at work. Commutative properties of operatator+ vs operator* and whatnot. Was this a suggestion for a general algebraic definition? Or does this exist already?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c2u7iy/humble_bundle_c_books/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`std::invoke` directly into the language.
&gt; MSVC isn't bound by the ABI when it can prove it is compiling a function and every possible caller. Sure, but that is usually only possible for functions with internal linkage (static or inside as n anonymous namespace) and even then I'd be very suprised if any compiler did this. So far, I've seen very little interprocedural optimization that didn't rely on inlining first.
Are you saying the msvc toolchain actually does perform this optimization?
Constexpr destructors. Hopefully this gets fixed in c++20.
Terse lambda syntax.
How was the text editing recorded and played back? There is 0 backspace hit and the time at the top isn't sped up so it's not a straight recording. But it's also not just a dumb script that types in the contents of another file because there are some human-like copy/paste/edit moments. Any idea? EDIT: well I should have read the video description before asking. For anyone else wondering, see https://bisqwit.iki.fi/jutut/kuvat/programming_examples/opengl-example-FAQ.txt
he is, but has a more c like approach to thing
128 bit atomics
I don't do a lot of C++ coding these days and I'm not sure if this qualifies as a minor change, but I would really like to be able to do something like: namespace foo const { and have everything in that namespace be `const` unless explicitly declared `mutable`. Const-correct code by default!
should it be also done for structs/classes? where `struct X const { int x; void f(); }` would be equivalent to `struct X { const int x; void f() const; }`
This is pretty amazing.
*oh no*
I‚Äôm not assuming, I‚Äôm staying. Take a peek at the standard. Big O is part of every algorithm‚Äôs contract. So no. I made up nothing. You did.
It allows narrowing as any other function does. What is your point?
Complete opposite in his latest stuff. He uses all C++ features extensivly
constexpr threads
I also did not state that (implied by you) people want algorithms to provide the same runtime characteristics when run on differently structured data. I, however, stated, repeatedly, that ranges provide no more container independence than iterators did, except with a much more awesome syntax. So essentially you are arguing with something I have never said using almost the same word I used and exactly the same meaning in your conclusions. That is a classic case of straw man.
Simplifying initialization rules. For example, there are [more than a couple of bullets in reference initialization](http://eel.is/c++draft/dcl.init.ref#5). Many of these are unnecessary complication. (Implicit user-defined conversion are pretty rare and discouraged. Implicit conversion to _reference type_ are even rarer.)
But then there‚Äôs reference_wrapper :/
Hiding complexity, helpful. Hiding complexity guarantees, not helpful.
That's what I usually use as well. Well, with a VScode plugin but yeah.
Just that the issue suggests to use list initialization, so allowing aggregate initialization with parens somewhat sidesteps the issue.
Not in my business, where we build everything from sources.
This is compiler specific. Tthe incompatibilities should not be between the language versions (unless you're doing something super weird like return auto_ptrs,) but between the compiler ABIs (which usually depend on version.) I'm not 100% sure, but I seem to recall that MSVC said Visual Studio 2015, 2017, and 2019 have a stable ABI. So 2019 should be able to use 2015 and 2017 compiled libs. G++'s ABI stability is a source of some issues, IIRC. Such as really poor std::tie performance that structured bindings don't suffer from. So they are usually stable. I know nothing about clang. My work hasn't began to use it anywhere. In any case, you will need to check for literally every compiler version you want to use.
Well I just want to simplify the rules, not completely remove conversion to reference. To be more specific, currently three bullets in [dcl.init.ref] involve user-defined conversions ([5.1.2](http://eel.is/c++draft/dcl.init.ref#5.1.2), [5.3.2](http://eel.is/c++draft/dcl.init.ref#5.3.2), [5.4.1](http://eel.is/c++draft/dcl.init.ref#5.4.1)). If they are fused together, some corner cases (paticularly those involving multiple conversion functions or converting constructors) might have different behavior. But this will have minimum effect to reference_wrapper because it has only one conversion function.
Nothing, I have a master's degree in AI myself. But the job title of "software engineer", with emphasis on engineer, is, given the current regulatory frameworks, laughable.
&gt; Hiding complexity guarantees, not helpful. How exactly does passing iterators avoid the hiding of complexity guarantees? `std::lower_bound` is a clear example that it doesn't.
But less awesome at scientific reasoning: https://bisqwit.iki.fi/jesus/
Where did I say I am talking about passing iterators?
The editing actions are crafted by a program I wrote for that purpose, and they are played back using https://bisqwit.iki.fi/source/inputter.html ‚Äî which I also wrote.
Python's lack of type-safety is bigger pitfall than all of C++ foot-guns though in my opinion. I doubt that people who like it write something worthy of even several files to implement in it. I prefer to write scripts in it because it "just works" most of the time and has nicer synax than e.g. bash, not because lack of foot-guns.
&gt;I also did not state that (implied by you) people want algorithms to provide the same runtime characteristics when run on differently structured data. If you don't think people want this, why even mention it? If anyone who would ever write a "container independent" algorithm expects it to be "container independent" in the exact same sense that the STL algorithms are "container independent", it is redundant to argue that a stronger sense of "container independence" is not possible. That's why so many have mentioned ranges to you: because in their eyes (and mine) ranges really do solve this problem to the exact extent it needs to be solved.
&gt; If you need container-independent code, use iterators.
&gt; Take a peek at the standard. Big O is part of every algorithm‚Äôs contract. Ok. Look at the complexity guarantees for `std::lower_bound`.
Please read the whole discussion if you want to contribute. I don‚Äôt have the time to keep repeating everything I have already said. If you just want to argue for arguing‚Äôs sake, find someone else to entertain you.
Iterators do not container independent code make, not as the original post seems to imply it in its title.
&gt; Please read the whole discussion if you want to contribute. I have. Like I said, when people say they want "container independent" code, you assume they want something much stronger than what they actually want. Despite your accusations, you're the one arguing against a straw man.
This post is not about lower_bound. If you change the topic as well as make up straw men I have to respectfully decline further waste of time. You are arguing for arguing‚Äôs sake, and I am too old to have time for that.
You are arguing for arguing‚Äôs sake. I am done.
`View` is a non-owning ranges (all types satisfying View are ranges), containers, owning their elements, are not views in the ranges speak https://godbolt.org/z/042MNP
&gt; This post is not about lower_bound. ? `std::lower_bound` is one of the standard algorithms. Its complexity guarantees are part of its contract. Relevantly, it provides different guarantees depending on the type of iterator it receives. Logarithmic for random access, linear for bidirectional or weaker. I fail to see how this is not on topic. I am also confused as to what your position here even is. In another post, in reference to my earlier statement "You're assuming (...) a "container independent" algorithm would have to run in exactly the same way", you accused me of straw manning. Here you not only embrace my assumption, but you seem to imply it is obvious. So what are you even arguing _for_?
So, on the one hand you claim that if you need container independent code you should use iterators. On the other, you claim code using iterators is not container independent. So which is it? Is code using iterators container independent or not?
So the above function_cast is undefined behaviour is what you're saying? [Answers like this one would seem to agree](https://stackoverflow.com/a/11996970/8594193) /u/woltion when you say you must use memcpy to do this legally are you saying if you want to read a double as a long (assuming sizeof double == sizeof long) then you do: double d = 2.0; long i; std::memcpy(&amp;i, &amp;d, sizeof d); // Can now legally read value of i Or are you referring to writing a union member and then reading another one somehow using memcpy? If so, how would you do this? It appears you can convert between a `void*` and function pointer using reinterpret cast [jumping through some hoops](https://stackoverflow.com/a/1096349/8594193) although this just seems to be a different way of invoking UD and is implementation dependent. However Cppreference point 8 on [the page about reinterpret\_cast](https://en.cppreference.com/w/cpp/language/reinterpret_cast) states: &gt; 8) On some implementations (in particular, on any POSIX compatible system as required by `dlsym`), a function pointer can be converted to `void*` or any other object pointer, or vice versa. If the implementation supports conversion in both directions, conversion to the original type yields the original value, otherwise the resulting pointer cannot be dereferenced or called safely. This confuses me. Does this mean an implementation that conforms to POSIX should allow conversion from `void *` to (any?) function pointer "and vice versa" (as per the above quote) using reinterpret_cast and that in that case the behaviour **is** defined *but* this is specific to that implementation?
On the other hand it improves consistency since it means that narrowing is allowed no matter whether you pass an aggregate or not.
The main argument against this would be that platforms don't necessarily have a "stack" of a fixed size or at all, or have multiple! As examples, Itanium has two stacks. Windows has separate stack "reserve" and "commit" sizes in its thread API.
And constexpr compiler invocation
do you mean uniform function call syntax?
This is irrelevant, in my opinion.
No, I'm saying that parenthesis should just work on every class that satisfies the concept `Callable`, as proposed by [P1214](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1214r0.html). It's completely orthogonal to UFCS.
I want to be able to iterate enums and convert an enum to a string and back.
Nobody said **he** implemented the software renderer. Mesa, which is what he used, is a software implementation of OpenGL.
&gt; Is there really any other standard container besides vector? std::basic_string. It's great ;-)
bitset might still be `constexpr` in 20, currently in flight somewhere between library evolution and library
[wikipedia.org/wiki/List_of_data_structures](http://wikipedia.org/wiki/List_of_data_structures)
I quit waiting long ago and did that for myself.
Not the right sub for this.
This works in C++17 with the helpful of template auto and _PRETTY_FUNCTION__ macros. But yeah, it's not standard C++ obviously.
Didn‚Äôt realize. Are you aware of better subs for people learning cpp to ask questions in?
Moving from `std::initializer_list` would be a nice addition.
Ugh, classic clickbait title. Can you not give a summary of what happened? Even just "it went well" or "it went badly"?
I'm not the author, but are you serious? The author included a conclusions section (though perhaps if you read the article, or even skipped straight to the bottom, you would have seen that): &gt; Conclusions My earlier experience with using Qt and Python was with the PyQt bindings. Qt for Python is similar and quite compatible with PyQt. In fact, I took a number of PyQt example applications that we use for Qt training and was able to quickly port them to Qt for Python. It was mostly a matter of changing imports from "PyQt5" to "PySide2", and in some cases a few tweaks such as handling the differences in method names and how signals and slots are handled. As I write this, Qt for Python is in a tech preview status, built against Qt 5.11.1. It is not clear if there will be more tooling coming, like better Qt Creator support. But so far it looks quite complete and stable. Our experience at ICS with Python and PyQt is that large complex (typically desktop) applications can be developed with Python. Users can't tell that it was implemented in Python and not C++. Performance is typically not an issue, and experienced Qt C++ developers can quickly make the transition to Python. Qt for Python offers the possibility to expand the developer base of Qt. Historically it has been hard to find good C++ programmers, and even harder to find experienced Qt developers. Python is widely being used by young people on the Raspberry Pi, for example, so Qt For Python offers the potential for a new generation of Qt developers.
Another great talk by Andrei. I just love his personality; funny, humble, and damn smart!
The whole point of a clickbait title is that it forces you to read the article (or at least click through and earn them that juicy advertising revenue) even if it isn't relevant/interesting to you. Even having a good introduction isn't an excuse for that. Having a good conclusions section right at the bottom certainly isn't. &gt; perhaps if you read the article I certainly did not.
/r/cpp_questions Check the sidebar ;)
It's a pretty straight-forward article.
Use mypy. It‚Äôs awesome
Again, I'm not the author, but you're generalizing here: &gt; The whole point of a clickbait title is that it forces you to read the article (or at least click through and earn them that juicy advertising revenue) even if it isn't relevant/interesting to you. Show me in that article where there is one single advertisement. &gt; Even having a good introduction isn't an excuse for that. Having a good conclusions section right at the bottom certainly isn't. If you can't be bothered to read the introduction or skip to see if there's a conclusion (which there was), then that says more about the reader, you in this case, than it does the author. &gt; I certainly did not [read the article]. Same point as previously mentioned. I have no real dog in this fight since I'm not the author, but I only wanted to respond because I felt your comments to him were unjustified.
I notice you ship full debug info to everyone. Any particular reason? (It‚Äôs awesome please keep doing It)
Well it might be but then I need to answer a question do I love python enough that I'm willing to use language extensions to allow me to write bigger apps in it or should I just keep using python for simple things and use other languages in more complex cases. For me this is not a simple question to answer.
Mypy isn‚Äôt a language extension. It‚Äôs just a static analysis tool.
What I meant is that for simple scripts you probably would not need it and it's likely not worth it to get used to its annotation syntax, setup your editor/ide, etc.. It's good that you don't need separate interpreter to use it but still it looks a little bit like other language than usual python.
Thank you :)
Charles Baddage, Donald Knuth, Alan Turing, Muhammad ibn Musa al-Khwarizmi, Bill Gates, Max Plank, Werner Karl Heisenberg and many more all held/hold religious views. Should we also distrust and discredit all of their work? Grow up.
This question isn't specific to C++. If you really only care about linked lists as they apply to idiomatic C++: https://en.cppreference.com/w/cpp/container/forward_list Or for a doubly-linked list: https://en.cppreference.com/w/cpp/container/list
TL;DR it went well &amp;#x200B; Our experience at ICS with Python and PyQt is that large complex (typically desktop) applications can be developed with Python. Users can't tell that it was implemented in Python and not C++. Performance is typically not an issue, and experienced Qt C++ developers can quickly make the transition to Python.
&gt; would you trust Yes.
It allows the game to generate symbolized stack traces should it need to.
these videos always make me feel like i should be practicing lol
Can‚Äôt wait to make my ScopeGaurd constexpr
Do you talk like this at work or do you reserve your batshit intolerance for internet comment threads?
I'm not sure on that. I strictly work in the Windows world.
Only if your enum is relatively compact value-wise. It also has significant compile time and binary size penalties.
You're underestimating the ability of humans to compartmentalize. This only disqualifies someone as a moral philosopher, and perhaps scientific fields if there's literalist conflicts with the faith (evolution as an example). Will admit that the linked page reads pretty extreme though.
LOL it's Babbage. Thanks for making me laugh.
We have 128 bit atomics. They're just not guaranteed to be lockfree. This is just a quality of implementation matter.
Totally tolerant of him as a person, the same way I'm tolerant of the severely autistic, or retarded. Tolerate but stay faaaar away, you never know when they'll try to bite your face off.
That's not what tolerance means.
&gt; Tolerance: The ability or willingness to tolerate something, in particular the existence of opinions or behavior that one does not necessarily agree with.
Yikes.
thank you
Thank you! Now if you're able to look inside user-defined types somehow, this'll be great!
Thank you for the feedback! &amp;#x200B; There already is an idea on how to do that here: [https://github.com/sharkdp/dbg-macro/issues/6](https://github.com/sharkdp/dbg-macro/issues/6)
You just defined "tolerance" as "the ability to tolerate". Go find the definition of "tolerate".
I think if someone wants to hold these extreme views, that's their right.. but posting them right next to the link for their CV, that to me also demonstrates an inability to compartmentalize.
never too late, thank you for chiming in!
&gt; Allow the existence, occurrence, or practice of (something that one does not necessarily like or agree with) without interference. I never said I'd interfere.
this is a very good news. Only drawback of not going for the C++14 way is that I won't learn it hehe
no auto_ptr and similar things so it should be fine :)
thanks for the hint mate
yep, damn ABI.. they should use one and only one
You mean like one of his more recent videos his [second OpenGL project](https://youtu.be/SktXhGElf7w) which does have lambdas and std::arrays in them, but his style is very much C-hacker, which is ideal for quick little projects like he does. What you don't see is him creating interfaces that abstract away a lot of the C looking parts. Often the entire program will be in main.
Muhammad ibn Musa al-Khwarizmi was a Persian scholar. Knuth is the author of *3:16 Bible Texts Illuminated.*
Off-topic; porting code away from C++ isn't relevant to programming in C++.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c2z7fi/looking_for_a_way_to_display_text_in_taskbar_like/ernk71c/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
if you look at the source, you'll see it uses `std::ostream &lt;&lt; value`, so if that is imlemented you are already set. If you want to format the output specifically for `dbg()`, specialize `dbg_macro::prettyPrint`
Any license for this?
Yes, it's MIT. I now added a badge to the README with a link to the header file. Thank you for the feedback.
That's cool, you can disagree, and all I did was post a link to a public page on his own web site, along with my opinion. Nothing I posted was counterfactual; just a link and my opinions about it. I don't consider that ridicule, and I think the fact that you do might say something about your own insecurities about your faith.
Nice! I make one of these in every project I create out of habit, but not as nice as yours and I call mine `D(...)`.
so you're saying you don't like python because it lacks types, and you don't like the type annotations in pythong because they don't look like pythong without types?
If you target C++17 all std::string members could be replaced by std::string_view, right?
I have been doing it like your example, and the cppreference sample implementation for std::bit\_cast does the same thing. I ran into this same problem maybe 15 years ago (c++98/c++03) when needing to convert dlsym pointers to functions. I understand reinterpret\_cast is now implementation dependent, and quick test shows that recent versions of both gcc and clang allow using it to do the conversion. In practice at least gcc and clang optimize the memcpy away if using it, and the resulting code is identical to reinterpret\_cast.
Add it as a LICENSE file. GitHub detects it, and shows it in the header. https://help.github.com/en/articles/adding-a-license-to-a-repository
done.
&gt;would you trust logic written by someone illogical enough to believe in a Christian god. Belief in god demonstrates weakness in logical thinking. Talking of logic both Aristotle and Gottfried Leibniz also held religious views.
dynamic_bitset and no vector&lt;bool&gt;
So, I will grant you this - being super religious back in Aristotle's time, or even a few centuries ago, was far more understandable and forgiveable. Not only because we didn't have as much technology, but also because it was the overwhelming societal belief. For all we know, all these old pioneers may have just been putting on an act so as to not get their heads chops off by the church. Today, neither of those things are true. To believe in religion today is an insult to the technology we've built as a society, as well as to the myriad people who's race or sexual orientation makes them targets for Christian zealots. Religion is a petri dish, in which intolerance and all manner of other awful mindsets can grow.
Thank you for the feedback. I would like to make it C++11 compatible. But even if we had `std::string_view`, I think it would be a bit dangerous to use it for `DebugOutput`. It would probably work for static strings (like `__FILE__`), but imagine I were to implement a test-object factory like this: auto DebugOutputTestFactory = []() { std::string path = "dummy/path/to/file.cpp"; int line = 42; std::string fn_name = "main"; std::string expr = "2 * 3"; return dbg_macro::DebugOutput(path.c_str(), line, fn_name.c_str(), expr.c_str()); }; DebugOutputTestFactory().print(6); we would get use-after-free errors, right?
I'm really confused, can you point out where I stated that I don't like python or type annotations? My point was that the primary reason for using python could not be safety since in it's default form it's not safer than C++. Everything has its scope of usage and I'm not sure if I'm willing to go extra mile to expand scope of usage of Python for me personally, that's it.
I'd say no, since const data members are rarely what you want. Also makes the whole class non-assignable.
There is a proposal for this though, but yeah, it probably won't make it in C++20. [[[assert: std::disjoint(A,nA, B,nB)]]: Contract assertions as an alternate spelling of ‚Äòrestrict‚Äô](https://wg21.link/p1296)
https://github.com/kw-udon/constexpr-8cc
Not really the same. What I would like is to make my build script in C++ constexpr. Then a buildsystem could be a simple C++ library.
Classic religiophobia.
Ah, sorry about that. The article shows example code in C++ (Qt's native API) and compares it to Qt's Python API (PySide2), so I thought it was relevant on that level, but looks like I was mistaken. Thanks for the clarification!
I'd counter that, since the video starts with a bible passage in Hebrew, a discussion isn't totally off topic. But you are right, I fear religion deeply. I believe it has already caused a lot of harm to many people, and I believe if left unchecked it will continue to do so in the future.
Seems like a minor change to the language that's missing.
I wonder, does C++11 (or even beyond) allow being able to have this also somehow print the function arguments too, if they are simple types (int, char *, string, enum, etc)? For example: int foo(int a, int b){ dbg_args(foo, "mark"); // [example.cpp:23 main(a: 1, b: 4)] mark a = a + b; b = b * 1.234f; return a &lt; b ? a * 1.2f : b + a - 1.3; } I guess this is where logging should be used instead, but figured I would ask since often times when I am doing embedded work with a large not-totally-in-my-head codebase, such that when things go wrong, I would often have to resort to printf style debugging so I can trace logic flow, but having to manually copy arguments into the debug MARK message is cumbersome. If it can be automated that would be great.
In the linked sources to that video he uses; lambda, array, vector, map, tie, tuple and array destructuring. And if you check out his compiler series you can see a lot of std::algorithm use. https://bisqwit.iki.fi/jutut/kuvat/programming_examples/75000/75000.cc
Very cool! For Installation, another common method is to add this as a git submodule. You could also provide a simple CMakeLists.txt so that add_subdirectory adds the required include path.
Hi - Cool graphics. Could have done without the religious passage on the front, though. It's deeply offensive to me, and serves only to alienate. Why include it? Are you implying that your code is the spring of salvation?
Thank you for the feedback. &amp;#x200B; I already added a `CMakeLists.txt` file (mainly for the tests). Hopefully, this should also work with `add_subdirectory`(?).
First you returned total in the while so it will return 1. Second off there is no reason to do this recursive. Sum=n*(n+1)/2
`cout &lt;&lt; "sum = " &lt;&lt; sum (total);` should be n not total, i and n are never used, remove them. Regardless of what your teacher do or say, try not to use `using namespace std;` it's a bad habit to take (instead, type std::cout etc)
Interesting question. I don't know of any way to automatically extract the names of the function arguments. There is `__PRETTY_FUNCTION__` (which we use in `dbg.h` to add the type information), but it strips the actual names of the arguments. For your foo function, we would have `__PRETTY_FUNCTION__ = "int foo(int, int)"`
Looks pretty nifty!
Can't test as I'm on my phone, but it looks good. One thing, though, is that it's usually a good idea to namespace libs with a folder name. For instance, you could put dbg.h into "include/sharkdp/dbg.h" and set the target include directory to "./include". This way, to include your header would mean adding #include "sharkdp/dbg.h". You don't necessarily need to name the folder sharkdp, of course. Could be "dbg" or "dbg_util" or whatever you like, though it's usually nice when it's relatively unique.
Haven't tested the compile time. Is it really so slow? It's just one template instantiation, no?
`template &lt;int N&gt;` `bool prettyPrint(std::ostream&amp; stream, const char (&amp;value)[N]) {` not `size_t N` ?
In case of your test factory, yes it wouldn't worked. I was thinking about the usage behind the macro where normally all strings should be string literals (but I may be mistaken on what exactly is behind compiler macro intrinsic)
It will be. It's needed for constexpr allocation :)
The cost being, of course, dynamic allocations for every iterator, and dynamic dispatch for every iterator advance.
It's not yet in the working draft, so I'm not considering it a done deal. Particularly the fact that it is tied to a much more complex proposal is what's worrying me.
Looks awesome! My only issue is that lowercase short macro names are dangerous in C++ due to lack of hygenic macros. &amp;#x200B; I found this example from llvm [https://github.com/llvm-mirror/llvm/blob/master/tools/opt/Debugify.cpp#L40](https://github.com/llvm-mirror/llvm/blob/master/tools/opt/Debugify.cpp#L40) that I believe would clash with your macro. &amp;#x200B; I personally would uglify it to \`DBG\_MACRO\` or something like it to
Fair enough fair enough. I'm optimistic though!
Oh interesting! For some reason I thought it was in after some post-Kona discussions. My bad. Well I'm optimistic! I would be surprised (and very disappointed) if it gets pulled.
Seems like you are either missing a minor change to your CPU or a minor change to your library's implementation of atomic&lt;&gt;.
&gt;With polymorphic collections and cursors it's pretty easy to create code that will operate on any type of collection over a particular element type without having to resort to template generation at every point Umm yes, polymorphism can be dynamic, can be static. Your approach does not instantiate templates, but has inevitable runtime overhead. C++ supports both for a reason - there is no silver bullet.
Awesome, I was looking for something like this without even knowing it. Question: can I just leave this in and then disable the output by setting a #define? Or actually the other way around: leave them in, but only have them "active" when #define is set? E.g, when I build with `make DEBUG=1` the macro would activate. This would enable a much wider and permanent use as a kind of light weight debug logging. Of course, when "inactive" the macro should still pass through its arguments. Yeah, yeah, I could just build it myself like: ``` #include "dbg.h" #ifndef DEBUG #undef dbg #define dbg(...) (void)(__VA_ARGS__) // or something like that #endif ``` ... but just curious if it's built in.
Iterator interface for std::bitset.
Change every instance of ‚Äùundefined behavior‚Äù in the standard to ‚Äùunspecified behavior‚Äù.
You can do it either way of course. I was just demonstrating this particular way. But, I have to say that I just don't get the current obsession with stuff like dynamic dispatch overhead and such. For 99% of code it will not make a measurable difference at all. So many more things are more important. And of course everyone ignores the significant amount of extra code that heavily templated systems generate. Isn't the cache important as well? What's the cache overhead of having generated the same (often access) code 50 different times throughout the program compared to having one copy of it that gets cached and stays there to be called?
CIDLib supports both of course. But I was under the impression that the STL did not support polymorphic containers? That the only way to do such things was to take the hit of indirect access via iterators, or of course just completely templated code.
Ironically, the presenter doesn't drink either. This is just one of those cases where you are talking in front of a bunch of people and words flow out, like "who doesn't..." and then you think about what you just said after you said it.
Over the years, I have collected some references on this topic. Find them at [https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B98/examples/volatile\_not\_useful\_for\_multithreaded.cpp](https://github.com/BartVandewoestyne/Cpp/blob/master/C%2B%2B98/examples/volatile_not_useful_for_multithreaded.cpp) They are ordered chronologically, withe the latest ones on top. Happy reading! :-)
https://github.com/Neargye/magic_enum
const by default
Thank you for the feedback! I'm pretty sure it's a good idea to use `size_t`, but I'm not 100% sure why/if the version with `int` is problematic. Or is it just semantics...? Because an array size can not be negative?
Is the idea to allow "performance is correctness" tests to allow for catching performance regressions?
Hey, this looks pretty neat! I'm staring it for future projects.
I think it's because int isn't always the same size, but I'm not sure at all
Does it work with vs2013's c++11? It's a special subset
size_t is unsigned as well and represents "maximum size of a theoretically possible object of any type (including array)"
Location: California I‚Äôm looking for an entry-level, full-time position and I‚Äôm willing to relocate. I graduated from the University of Oregon in 2018 with a 3.5 GPA. I have no professional experience but a lot of interesting projects. Lately, I‚Äôve been working on an interpreter and JIT compiler written in C++, which has been an incredible learning experience. Technologies: C++, C, x86 Assembly, Linux, Git, Java, Javascript with React
Allegro is just another C++ game library
It's not hard to make a poor-man's C++11 version of std::string_view. Just a const char* and a size_t, a couple of constructors and comparison operators. That's it!
&gt; For 99% of code it will not make a measurable difference at all. [Meh](http://quick-bench.com/qT6UPFJThva43cPQSnTvhWr7Utg)... If I didn't care enough for this kind of slow down to be a problem, I would probably not be using C++. For some reason, the loop isn't vectorized (probably due to not specifying the arch), if it was, the difference would be even greater.
That's a misleading number, because it's not doing anything else but the iterator bump. In actual fact, you'd be doing something with those elements you are iterating, which would vastly dominate the actual time spent and the difference would likely becoming insignificant.
Good. It's always so pleasant to see marvelous macro with #\_\_VA\_ARGS\_\_ - it makes me cry how on earth someone mortal can imagine C++ without heavenly #
Slowdown from instruction bloat has bit me a few times. Notably, I‚Äôve seen this when operating in tight loops where any indirect calls would be predicted well by the BTB, so there wasn‚Äôt need for specializations (and the specializations actually caused the slowdown).
I might be wrong. I have to admit I didn't check it and offhand I can't tell, why I think it isn't viewed in yet.
Except... For when they are what you want?
Soon.
Yes, the benchmark does only time the iteration. For small loop bodies, like sum or find, advancing the iterator can actually take a good chunk of the iteration time (especially want you consider the loss of optimizations due to the virtual call), and those are the function that you are the most likely to call at several places in your programs and thus the ones you might want to make polymorphic the most. All in all, I think I never felt the need for something like that. Your case might be very different tho, I can see how this could be nice to have in very OO code.
This looks great. I played with DJGPP and OSmesa back in 2001, bu then single textured triangle chocked my CPU. Which make this demo even more impressive.
I suspect you're using C compiler. If you're using C compiler, you cannot work with C++, so cannot use 'using namespace ...' If you got a C++ compiler, remove '#include &lt;stdio.h&gt;', &lt;iostream&gt; is there for printf &amp; scanf. #include "stdafx.h" require, a file stdafx.h file in the same directory. Try to learn basic things first, instead of getting to post questions over the web.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c33qr4/cant_get_cin_or_scanf_to_work_visual_studio_2019/erogaul/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
To what gain? From the standard's perspective, "not defining the outcome of a behavior" and "not specifying the outcome of a behavior" are logically the same.
For something really simple you probably wouldn't necessarily do it that way. As I said, you can go either direction. The collections are templates and you can easily write templatized code that uses them. OTOH, for something where there's a lot more code involved in the loop, it might be well worth doing a polymorphic version that everyone can just call. In a lot of cases it wouldn't be directly happening, but there would just be a method that can take any collection of Foobar items and do some more complex processing on them. Internally, that method can just do polymorphic processing, so it doesn't have to be a template.
I would agree with you. Either `size_t` or `unsigned int` would be more correct semantically since an array cannot have a negative size.
It does not provide polymorphic container wrappers. You no more need support for runtime polymorphism in the type than std function needs it in function pointers. For example, using a short library, I can then write: template&lt;class T&gt; auto push_back = poly_method&lt;void(T const&amp;), void(T&amp;&amp;)&gt;( [](auto&amp; self, auto&amp;&amp; arg){ self.push_back( decltype(arg)(arg) ); } ); void populate(any_view&lt;&amp;push_back&lt;std::string&gt;&gt; target, int count ){ for (int i=0; i&lt;count; ++i) target-&gt;*push_back( fmt::format( "Value #{1}", i ); } and be able to pass in anything supporting `push_back` of a `string`, be it std vector or some custom container you wrote. (the poly method and any view creates a virtual function table for each type converted to any view, then uses it when you invoke it on the any view). Want a larger interface in your function? Just write another poly method, and pass it to the `any_view&lt;auto const*...&gt;` template. Still, iterating over type erasure sucks. We can reduce the annoying overhead with a foreach adapter that either handed buffers of spans or buffers of single element pointers. That'll allow contiguous containers to get vectorized and non-contiguous containers to at least not do 3-4 type erasure operations per step. But that is just me. I'm crazy.
Heretic! Get back to rust traitor.
int is almost never the same as size_t. size_t is generally equivalent to unsigned long long (uint64_t)
That looks C++ like to you? What makes C++ C++ is zero cost abstractions. std is just data structures. It's a library, not a language.
I believe there are already changes too many. C++ is a useless carnival at this point.
And I think it would be fair to say that that's a wee bit less readable :-)
Fun fact: The standard only guarantees `std::atomic_flag` is lock-less, because not all architectures support larger atomic types. Really the only problem was not having `is_always_lock_free` prior to 17, but now that we do you can check if your implementation has a lock free 128 bit type and use it, if it doesn't you can fall back on a different algorithm, or file a bug if it should.
Ah, thanks!
Undefined behaviour and unspecified behaviour are two very different concepts, with two different definitions in the standard. https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior
finally some sanity
Damn, this is the first time I've seen that definition being used. Thanks for the link.
I think it just tries to convert the integers 0 to 256 to an enum value to be able to convert a string back to the enum value. This has some compile cost and you need to bump that limit, when your values are outside those limits.
Explicit type aliases. I would love to be able to say `explicit using Currency = int;` so that `Currency` behaves like `int` but without implicit conversions between the two.
&gt; constexpr allocation Do tell more! Would this let me, let's say, make a constexpr vector and fill it with stuff without having to use a fixed-sized array?
Yes! That is one of the main use cases. There's so many "static vector" implementations. It's clearly something people want! And they're trying hard to get it in for C++20. http://wg21.link/p0784
Frankly sounds like your problem, with a stink of obsession, not mine. As for what it means, it‚Äôs explained here. https://www.youtube.com/watch?v=xVxSAi4sueQ
Data races should probably remain UB.
I have wanted something like this, the only potential complication I could see is that someone might pick the wrong underlying implementation (e.g., int32\_t when a double would be better) or that the underlying implementations get lost in a see of substitutions.
I'd argue it is mostly alien, not less readable. Both as in "how does that work" and "I haven't seen that". But, just like a lambda, what is going on here is explicit and local: we describe the exact interface we are using by listing methods at the function definition. Instead of using some templates from some header file whose relationship to each other depends on reading that header, and whose contents are omnibus. It is akin to the difference between `[](auto&amp;&amp; x){std::cout&lt;&lt;x;}` and `stream_to{std::cout}`. One says what is done, the other names something we presume does the same. Your code reads very Java/90s C++ esque, which may be readable to those used to it.
I spoke ambiguously. I was meaning to say that top competitors are unlikely to use Python instead of C++ because the time limits are tight. (e.g. to differentiate between n and n lg n)
* The ability to specify the type of the counter of std::shared\_ptr (specifically int vs std::atomic&lt;int&gt;) * The ability to move from a const member (without copying) in a move ctor or assignment operator. * Ability to define functions as part of an enum class. *
It's less readable.
Data structures and lambdas, and things like tie and tuple are zero cost abstractions as well. They make it possible to write concise code that does exactly the same (and in exactly same way) as equivalent code in C that would constitute of a heap of small individual statements and variable declarations.
```c++ [const std::string &amp;a, bool b] = f(); ``` instead of ```c++ auto [a, b] = f(); ``` Could be a very useful language feature if not a hard dependency on auto.
Very cool, thanks for contributing this to open source. user-defined type supports as was already mentioned in other responses would be awesome.
I love his Andrei's presentations but I wish the audio quality was better on this one. That being said if you power thru the audio issue, great presentation. Slides are on [Github](https://github.com/italiancpp/itcppcon19/blob/master/Allegro%20Means%20Both%20Fast%20and%20Happy%20-%20Andrei%20Alexandrescu.pdf) on it to follow up with as well since they aren't on the screen.
LibNav's logging functionality has something similar: [https://github.com/Navigator-Data/libnav](https://github.com/Navigator-Data/libnav) There are macros for TRACE, DEBUG, INFO, WARNING and ERROR.
Inheritance based approach forces you to actually inherit the interfaces, which does not work for third party classes. What /u/NotAYakk described is more like defining an interface specifically for use in the polymorphic function and then writing an adapter for your third party class implementing that interface. Except that this way is granular (you aren't likely to define a PushBackable interface, right?) and hides all the boilerplate.
Converting an enum to a string is fast and only requires a single template instantiation. Converting a string to an enum requires an exhaustive (clamped by some low max value, like 256 for example) instantiation and search, making it unsuitable for enums that are sparse or have many elements.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c36biq/is_there_a_way_to_make_this_code_for_effecient_at/eroyrxm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c366n6/rest_api_for_cpp/eroyss8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You can do that in any system of course, but it's pretty orthogonal to whether you use inheritance or not. And having to do it even if it's not some third party thing, but something very common and built it is not exactly a positive, IMO.
Your approach _requires_ inheritance to work, how is that orthogonal? And of course any such type erasure library will have ready definitions for std types.
But this implies that you are unable to write generic algorithms this way, since at that point you have no idea how heavy the item processing is. This basically forces you to have both template and inheritance version of everything.
And when when would that be? Could you provide an example?
Just read through that paper and it mentions restrict sometimes hurting performance. Any reason why
Huh interesting. I can't think of any reason why that is the case.
What operation would you want to enable on this type? That's where all the strong typedef ideas usually become complicated. Addition probably makes sense (but there are counterexamples even to that) but multiplication probably not. What about multiplication with the base type?
You can easily define that if you read a shared variable without proper synchronization, you might read garbage (including invalid/trap values ). That's still a far cry from UB. Same for reading from uninitialized memory.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c34rwv/stanford_cs_106107_classes_self_teaching/erp7r7r/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
One example is: An API function that returns a smart pointer to an object that has important internal details.
This, exactly.
The TL;DR of it is that compiler writers interpret any accidental use of undefined behavior as a free license to do essentially whatever they want with your code, including removing sections of it that don‚Äôt exhibit undefined behavior.
`&amp;my_object::foo` as a short way to get a bound member-function. Doing the same thing with lambdas is so ugly, even `std::bind` still beats it.
Um, there are videos on Youtube with the C++ committee discussing that making `size_t` unsigned was a mistake. Although it is true that an array cannot have negative sizes, there are a lot of corner cases like reverse loops where unsigned makes life hard. There are no tangible benefits to unsigned - you could argue being able to allocate insanely large arrays is a benefit, but if you really want arrays that large I think you have other problems.
It‚Äôs not a great idea to use `size_t`. Look at the Guideline Support Library from the C++ committee, where the `index` type is signed, I think an`long int`.
To be honest, I just opened it, Ctrl+F-d "rust", and sure enough. But it's really great to see some of my favourite ergonomic features of Rust to spread :)
No. "constexpr" is currently required.
You could then add something like ``` #ifndef DISABLE_SHORT_DEBUG_MACRO #define dbg DBG_MACRO #endif ``` Then it would be possible to use the short macro and if it leads to a conflict simply disable it
Doesn't `operator==` exist which does the same thing?
Did not know, was recommended to post my question here. Sorry!
But what about writing? It might overwrite unrelated variable (and affect everything that depend on it), cause stack corruption, or have no effect at all. What's possible, I guess, is something like C's [Annex L](http://port70.net/~nsz/c/c11/n1570.html#L). That is, define most undefined behaviors as _bounded_ (and probably limit the behaviors of remaining _critical_ undefined behaviors so that e.g. they may crash the program, but not create nasal demons.)
There are secret plans for the former.
Unfortunately it is a breaking change and might break compilers' internal invariant (that a object name cannot be the left operand of `::`) due to C++'s funny rules: class Foo {int f();}; void f() { struct Bar {} Foo; &amp;Foo::f // currently means pointer to member of class ::Foo }
There's some work on `bit_iterator` that might open a way for those.
That relies on compiler specific optimizations and doesn't make for nice code. Also if it even does work (I'm skeptical at best) there's almost no chance it works across all 3 platforms and compilers we support.
What you describe with the null check should (IMO) be a compiler warning that can be enabled and promoted to an error. Because unless the code is in some generic context where due to threading it's actually possible for that to happen that just sounds like a bug in the user-written logic that needs to be fixed. If someone writes: ```if (variable) ...``` and then inside that if writes ```if (!variable)``` without some code which could change ```variable``` that's a plain and simple logc error from the programmers end.
Obviously it‚Äôs a bug and I‚Äôd have no complaints about the compiler warning or giving error about it. What instead happened was that the compiler simply removed the null check completely. Without complaining and refusing to compile the code.
&gt; But what about writing? It might overwrite unrelated variable (and affect everything that depend on it), cause stack corruption, or have no effect at all. Why would you want to allow the compiler to randomly write to unrelated variables?
Question Suggestions and Corrections are welcome :)
In this thread: how to feel depressed.
Hebt try tried implementing concepts for over a decade now? Is there any indication that C++20 will actually have them, as opposed to 11, 14, and 17?
They're in the C++20 Standard
Concepts will be in c++20, along a lot of concepts and the range library making use of them https://en.cppreference.com/w/cpp/language/constraints https://en.cppreference.com/w/cpp/concepts https://en.cppreference.com/w/cpp/ranges#Range_concepts
The fact that concepts are not interfaces is very much intentional although the distinction is some what philosophical What concepts are trying to constrain is _algorithms_ rather that _types_ , which allow us to keep a strong distinction between the twos and is more generic and in the spirit of C++/the standard library.
You are correct of course. This is indeed an "abuse" of the Concepts feature, or at least of the original design of the feature. This post is just an experiment intended as an alternative to CRTP, and to stimulate discussion ;)
Damn! Thanks for the explanation tho. Still, I'd be pretty happy if it just worked for `this`.
Dumb question on the templated case: Why can't you hoist the `static_assert` to the struct declaration? ``` template &lt;typename T&gt; struct Rectangle { static_assert(Shape&lt;Rectangle&gt;); ... }; ``` (disclaimer: I dunno anything about concepts...)
If I'm writing a class and I want to accept any collection of whatevers to some of the methods of that class and do something to or with them, or if I'm writing some code of my own and I want to process any sort of collection of whatevers in some what, I know what I'm doing to them. Generic doesn't mean that they have to be standalone things that are the only ones ever used to do that thing. It means that they can accept any type of collection without having to be a template (unless that happens to be advantageous for some other reason.)
I would love to use concepts and contracts in a productive environment, but I guess it's too early for that
what for? anything can be changed
Maybe you (or someone else in the thread) could answer this: what's the point of even putting interfaces in the C++ language at this point? Aren't pure virtual classes the same thing?
Just lke downvotes!
Because the `Rectangle` isn't complete (haven't seen the closing `}` yet). The assertion will fail every time. It works in the constructor because member function definitions, even those written inline, are parsed as if they were defined outside the class.
Not a Dumb question at all! In the words of the immortal Clang: " would be invalid: member access into incomplete type 'const Square&lt;int&gt;' " [https://godbolt.org/z/dktKcB](https://godbolt.org/z/dktKcB) &amp;#x200B; However, It does work just fine with the `static_assert(Shape&lt;Square&lt;T&gt;&gt;)` in the constructor, replacing the uglier `decltype&lt;*this&gt;`. Thank you for the suggestion, I will add this to the post.
I would say that concepts lead to better interfaces since they clearly specify requirements for template arguments. To nitpick, concepts constrain template arguments of algorithms, not the algorithms that require them. I don't think it's entirely wrong to compare Java/C# style interfaces and concepts. They can be seen to serve similar purposes when the comparison is drawn properly (which is easier if we had open multimethods).
You mean abstract base classes? No, they wouldn't be the same. You also need the property that every inheritance of the "interface" is virtual inheritance. Otherwise, with repeated inheritance you, end duplicating the inherited class' data members and vtable.
Trivially copyable bitset, or a portable bitfield. For modeling special function registers and peripheral communication. Sometimes you can use bitfields but that is non-portable. If bit-fields cross container boundaries then you end up with unions, type punning, and all kinda of other UB. This is often hidden behind macros to boot. Kavasir does a great job with a TON of template magic, but is limited to word size registers. Often peripherals have very large bitfields (SD card card CSD register for example is 128 bits. I also use a sat-com device with tons of 256-512 bit registers)
I had not thought of that before. First idea to come to mind would be to enable all by default, then let the user explicitly =delete any they don't want or =default any they want with the base type. I can see how this would cause issues though.
 bool are_equivalent(my_variant const&amp; lhs, my_variant const&amp; rhs) { return !(lhs &lt; rhs || rhs &lt; lhs); }
That‚Äôs a variation function https://en.cppreference.com/w/cpp/utility/variadic You have to manage the parameter pack manually at runtime, as you don‚Äôt have the type information that would otherwise be available from the template parameters. A post like this is preferably asked in r/cpp_questions, for future reference.
It might not be conventional wisdom, but I feel that he does more presentations than he has content for and ends up off in tangents and anecdotes that nothing to with C++. It might be more entertaining to not have a dense hour long talk, but it usually seems to me that there isn't a lot there in most of his recent talks.
I like how this narrows the niche of CRTP: if you truly want compile-time polymorphism (not just an interface), then CRTP is still used, possible with a static assert in the constructor. But now if we just want to declare a certain behavior, we can do this:) For the CRTP and static assert though, would those make an object not default constructable? I would think not but I‚Äôm unsure.
In which case you probably want a full-blown unit system or a custom class (-wrapper). Btw: For simple cases, I like to use class enums (with appropriate operator overloads if necessary).
Speaking of variadic function arguments and variadic templates: template&lt;typename ...Ts&gt; void func(Ts......){} int main() { func(); } Is perfectly valid.
What does incrementing the euphemism treadmill do besides cause confusion and smug arrogance when people use the old term instead of the new one? What a dumb idea.
Basically, don't. Just take a vector, iterators, or starting with C++20 maybe a `span` instead; Something along those lines.
Jeeze this is so much better than sfinae. This is one area where I've thought that cpp has totally lacked in expressiveness compared to languages like Rust and Haskell.
&gt; there are a lot of corner cases like reverse loops where unsigned makes life hard. Isn't this the reason for ptrdiff_t? https://en.cppreference.com/w/cpp/types/ptrdiff_t
Sure. So I'll read it for you. template&lt;class T&gt; auto push_back = poly_method&lt;void(T const&amp;), void(T&amp;&amp;)&gt; `push_back&lt;T&gt;` is a polymorphic method. It's signature has two overloads; it always returns `void`, but it can take either a `T const&amp;` or a `T&amp;&amp;` as input. A polymorphic method is like an interface, but doesn't require support from the thing it is operating on. ( [](auto&amp; self, auto&amp;&amp; arg){ self.push_back( decltype(arg)(arg) ); } ); This defines what the polymorphic method `push_back&lt;T&gt;` does using lambda syntax. Here, we perfect forward one argument and call `.push_back` on the object we are operating on. In short, `push_back` poly_method does a ... push back. The lambda is just glue. In theory it could be fancier; for example, if push back doesn't exist, it could insert (using something like `if constexpr`). (In a theoretical post-C++20 reification/reflection world, we might not need all of this glue code.) void populate(any_view&lt;&amp;push_back&lt;std::string&gt;&gt; target, int count ) `populate` is a function. It takes a view of anything that supports `push_back&lt;std::string&gt;`. And I do mean anything. No `vector` specific or `deque` specific code is ever written by a human to make it compatible. { for (int i=0; i&lt;count; ++i) target-&gt;*push_back( fmt::format( "Value #{1}", i ) ); } here we call the `push_back` polymorphic method on whatever we passed as a `target`. We feed it `"Value #0"` through `"Value #count-1"`. I again admit this syntax is alien. It, however, sort of does what it says it does. The advantage of this is you don't have to reengineer all of your containers to support this kind of polymorphism. Polymorphism becomes the job of the function signature and arguments, not the job of the class. Classes don't have to carry around virtual function tables. You don't have to think up names for every bundle of methods you might want in an interface. You don't have to decide which methods go with which when you design your interface hierarchy. I believe this is closer to Rust style interfaces than anything usually used in C++.
I would say that if a codebase is written using poor practice but is valuable because it gets the job done, then using C++ was probably a mistake from the start‚Äîharder to maintain than easier languages, and you probably aren't getting the advantages from the language if it's sloppy code.
Well, if you engineered them to support it to start with, then you wouldn't have to re-engineer them to support it :-) Which is why I did. Processing things in collections is such a fundamental and common thing that I think its's pretty easily justifiable to support it specifically in the collection system to use as is without extra work (where it's useful, else do the other thing, or do the other thing in more ad hoc scenarios.) BTW, on the Rust front, I think you would actually carry around virtual tables and think up names for every bundle of methods, because you do it in Rust using mixin interfaces called traits. So, presumably in Rust, you might (in theory, I'm not saying they have one) have Iterable and Collector standard traits that things like collections would implement to support such generic functionality. I'm not sure how the issue of the need to support variable argument types works in Rust traits though. And that might be a reason they wouldn't have such a thing. But, in the general case, their only real inheritance is interface inheritance.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c3bhsm/are_parameter_packs_available_in_normal/erq8fzy/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c382xt/which_is_faster_c_or_c_file_open_and_read/erq8h4p/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Undefined and unspecified behavior are different. The first means the compiler can assume it didn‚Äôt happen (and do literally whatever it wants with the code, including ‚Äùsystem(‚Äùformat c: /f‚Äù)‚Äù, while he latter just results in value that‚Äôs not specified.
Philosophical debate aside, it's still quite useful to capture the fact that a type is supposed to adhere to a concept, as an additional type safety annotation. So far, C++ don't offer that and in my opinion this is an obvious gap in the design since it again follows the old duck typing path instead of clearly spelling up what the intended constraints are. Other modern languages (Swift, Rust, Haskell etc.) do a better job with this.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c3dki1/help_is_there_anyone_doing_c_with_vs_code/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Technically, Working Paper. Things (in fact, concepts) can and have been reverted before. Exceedingly unlikely to happen this time, though.
Well, == calls exactly == when the types match. Here, you internally have some function `are_equivalent` you want to call instead.
The blog post is assuming some custom `are_equivalent` function, this would hardcode calling operator&lt; on the equivalent types.
Not sure what you mean. The post I answered to suggested using a function local static variable. If you want to run the same statemachine two times (in parallel or one after another), those two statemachines will share that static variable, leading to broken behavior in one way or another. So I don't think it is a good idea, but I don't see, what allocators have to do with that.
&gt;What I personally would like to be able to do is something like the following: &gt; &gt;`struct Rectangle requires Shape { float area() const; };` &gt; &gt;This way the first line of the declaration of the Rectangle type clearly states that this class satisfies (in a way ‚Äúinherits‚Äù) from Shape. Many years ago, I had the idea of required vs. provided interfaces drummed into me for some Ada and methodologies reason I don't clearly remember any more. It took a minute to see that your syntax does make sense - `Rectangle` requires of itself that it provides the implementation for `Shape`. struct Rectangle { float area() const; }; static_assert(Shape&lt;Rectangle&gt;); Bless me father, for I have sinned against the syntax Gods. Is `Shape&lt;Rectangle&gt;` is a `constexpr bool` expression that I could use elsewhere? e.g. for meta-programming conditional optimisations based on which interfaces are provided/supported?
Maybe, but so what? Does it matter that - in hind-sight - you know better?
From what I understand, this is harder than it sounds because step zero would be for the C++ spec to specify what the stack is at all --which it currently doesn't do. Once that's done, adding tuning parameters would be quite easy. While defining a stack for your machine is probably simply difficult. Formally defining a stack spec that works for everybody (including those craaaaazy embeded folks) is quite hard indeed.
The logical answer would be ‚ÄùIt depends on the cpu / platform. The compiler makes no guarantees either way about which value is actually written.‚Äù
`enum class` are pretty cool for integrals, as they guarantee the absence of any overhead. On the other hand, they don't work with floating points, and validation on construction is impossible when anybody can just `static_cast&lt;EnumClass&gt;(some_int)` (and no better constructor can be defined).
Just return a `ptr&lt;T const&gt;` and you're good to go?
Some details might need to be modified, and others might not. I'm not saying that it's a perfect idea, simply that there's valid use cases.
I could see plopping in an attribute or a contract that just told the compiler (and tools) "I wanna satisfy this concept, please bother me if I don't".
I always wonder what kind of performance hit that would achieve. Because if I go to kind of an extreme and play "snarky devil's advocate" for a second, there's already likely a compiler setting that does about what you want with regards to UB -- it's called `-O0`. For example, consider the situation where you do a read that gives you a random value. You use that as a pointer address and write to it. I don't see any way you can constrain the behavior subsequent to that write, because that could go so far as to overwrite code if you're on a system with no memory protection. If evidence bears out there is very little performance impact I could see constraining *some* undefined behaviors (and in fact the committee has) and even narrowing what the compiler is allowed to do in the presence of UB (e.g. right now the compiler is allowed to make optimizations that will change the behavior even *before* the UB would have been invoked in an informal sense) but I can't see how you can possibly constrain *every instance* of UB. Some things the range of realistic behavior that can't be prevented without unacceptable compromises is too wide. Hell, you could have some weird machine where even a wild read could really hit a memory-mapped I/O address and cause arbitrary behavior.
I don't think there's much talk of standardizing a specialized interface syntax. (Although I don't follow core as much as I do libraries).
oh, seing you are a compiler vendor i have a feature request :D seeing that static_assert(Concept&lt;Type&gt;); will be a very common pattern, would it be possible for the compiler to try to understand these expressions and tell me why the static_assert fails when it does ? :D
That would be a useful feature (actually it would be useful for static asserts say more than "static assertion failed" in a lot of cases). Clang's concepts implementation actually does give you some nice diagnostics in this case. We are aware that this is a thing we should do, and actually also that our static_assert diagnostics are not great in general. I don't know all that much about the status of concepts on the compiler frontend side (and I wouldn't want to promise anything) but we know this will be a common pattern.
It really depends on the application's requirements. I don't think there is a general rule-of-thumb about this.
I don't use C++ in my work, but I feel pretty confident saying that in general at least 95% of programming jobs are going to be leaning heavily on frameworks and libraries, especially when you are starting out. Even if you don't use a public library, the senior devs will have developed some kind of an internal framework that you'll be working with. That's because in a real world job all that matters is that you produce working software, so it doesn't make any sense to spend a lot of time writing new stuff if there's already a tool available.
It depends. I work for Uncle Sam, so importing libs isn't usually an option out if the standard official language specs. We can't have 3rd party libs, doing who knows what, running in secured gov systems. And we're not sitting down to vet every lib line by line ensuring nothing is happening that shouldn't be. So that means sitting down and developing a lot of in-house libs to work with our systems ensuring we have 100% control from ui to hardware.
I mostly mean for new projects‚Äîif you don't expect to have expert programmers working on it constantly, avoid C++ altogether because clean code should always be a priority with C++, otherwise, why not use a language that makes things easier to write and get nearly the same performance as shoddy C++? Existing projects? I agree - you're kind of stuck. In the talk he brings up C++'s strength regarding compatibility with legacy code. I think that's something that new languages really should keep in mind if they want to be successful‚Äîcompatibility with legacy code‚Äîespecially conventions to link to C/C++ code. It's difficult, sure, but I'm hopeful for a future where it's easier to mix components of different languages and select which language is fit for the job.
I believe you can simply write: ``` static_assert(Shape&lt;Rectangle&gt;) ``` omitting &lt;T&gt; at all, because of https://en.cppreference.com/w/cpp/language/injected-class-name
most of the jobs out there is just to maintain or continue existing code which already have the required libraries and its rare to create own, most of the time the results are what matters and the decision to use other library or to create your own is always at the hands of higher ups which always look at the budget or timeframe variables. small teams have more freedom though.
In your case, if you use a library, you probably have a lot of your own domain implementation. People use libraries to save time and effort(library is used by many, so stable and will be maintained for a long time). &amp;#x200B; In my case, I work in custom GUI in embedded devices. We use opengl(already implemented and stable) wrapper to render the ui. Other than more than 100 people maintain the application framework, different subsystems, etc. It's a hell lot of work. Everything needs to be maintained because underlying platform changes, new features are needed, old features are removed, code needs to be migrated to new C++ standards. &amp;#x200B; Coming to the question, pure coding is 50% effort of a software project. Other 50% is spec, field testing, project management and office politics. If some tools automate something,someone needs to develop and maintain that tool. If something becomes very stable, resource allocated is reduced. &amp;#x200B; If you want to work in pure coding, go Java or Javascript. They do the patch release more frequently and they support plenty of features.
I meant, making abstractions, not using them.
It is not a secret anymore :)
It depends on the product you are developing. My own work on a huge codebase is 100% "pure coding".
&gt;This is just one of those cases where you are talking in front of a bunch of people and words flow out Fair point, I guess that's just it!
No. The current situation effectively weeds out people too lazy to take the 5 minutes it needs to get their build system configured. Don't infect us with left-pad bullshit.
I think /u/andrewsutton and Herb Sutter demonstrated in a talk `interface` such as it exists in for ex java was implementable trivially on top of meta classes. The idea being we don't want it in the standard but if someone really wanted it they could implement it
Taking the `ShapeBase` CRTP example and fixing up the identifiers to match their meaning: ``` template&lt;class T&gt; struct ModelsShape { ModelsShape() { static_assert(Shape&lt;T&gt;); } }; struct Circle : ModelsShape&lt;Circle&gt; { float area() const; float radius; }; ``` The problem with this as written is that it means you can never make `Circle` trivially default constructible, because `ModelsShape&lt;Circle&gt;` has a non-trivial default constructor. So it would be better to write https://concepts.godbolt.org/z/tTj91R ``` template&lt;class T&gt; struct ModelsShape { ModelsShape() requires(Shape&lt;T&gt;) = default; }; struct Circle : ModelsShape&lt;Circle&gt; { float area() const; float radius; }; ``` Now `ModelsShape&lt;Circle&gt;` always has a trivial default constructor, but that default constructor participates in overload resolution only when `Shape&lt;Circle&gt;` is satisfied. Yes, because `ModelsShape` is an aggregate in C++17, [`Circle() : ModelsShape&lt;Circle&gt;{} {}` allows a malicious programmer to bypass the default constructor](https://concepts.godbolt.org/z/B71gZW)... but C++2a actually closes this aggregate loophole at the same time as it adds C++2a Concepts, so we're all good there. :)
My answer to metaprogramming things is always to just use Boost.Mp11: bool are_equivalent(my_variant const&amp; a, my_variant const&amp; b) { if (a.index() != b.index()) return false; return mp_with_index&lt;variant_size_v&lt;my_variant&gt;&gt;( a.index(), [&amp;](auto I) { return are_equivalent(std::get&lt;I&gt;(a), std::get&lt;I&gt;(b)); }); }
It depends on the application domain and how far down the stack you are. If you are writing a high-performance database kernel, for example, there are almost no external libraries and you will be implementing many custom data structures and algorithms from scratch. Systems engineering broadly is full of code like this. Higher up the stack, not so much -- there you'll be building on top of the libraries and tooling written by people lower in the stack.
Idk about this real world since I'm a beginner too but I'd guess this thing of utilizing existing code and solutions is the beauty of the field in the first place. Autofilling development environments, endless stream of libraries, easy scripting general purpose languages etc. all make it ever increasingly more efficient to get new software out. No need to reinvent the wheel every time, on the contrary everyone can utilize what someone has already figured out and get something new even more complex and hopefully useful made of that. Sometimes though when this ready made codebase does too much behind your back you need to take steps back and modify the libraries or switch from that high level lang to a lower level language that doesn't create too much for you.
Too big a question! I think a lot of us don't even know where to start... :-)
Agreed. Thats why I said "for simple cases". But as I wrote in another reddit: I really have very rarely the need for an in-between solution where neither a class enum, nor a full blown, custom class (or unit library) are apropriate an I actually would prefer a "strong typedef".
How do concepts, or these "interfaces" compare to something like a Swift protocol?
\*\*Company:\*\* \[Qlarity Imaging\]([https://qlarityimaging.com/](https://qlarityimaging.com/)) &amp;#x200B; \*\*Type:\*\* Full time &amp;#x200B; \*\*Description:\*\* Qlarity Imaging is applying artificial intelligence to improve patient care, by enhancing the diagnostic insights available to radiologists. We are backed by a Chicago-based life science innovator that invests in, builds, and advises bioscience companies. Our initial product is the first FDA-cleared computer-aided diagnosis software for radiology. It integrates images from multiple modalities to assist radiologists in the assessment and characterization of breast abnormalities. &amp;#x200B; \*\*Responsibilities\*\* * Develop, test, and implement features that enable our AI-driven medical imaging products in the clinical workflow * Collaborate with our R&amp;D team in the development of new machine learning algorithms * Deploy software for new customers and coordinate with hospital IT to integrate systems * Identify and implement improvements to user experience (frontend code) * Resolve complex technical issues and facilitate root cause analysis * Compile comprehensive and accurate documentation and technical specifications &amp;#x200B; \*\*Requirements\*\* * Bachelor‚Äôs degree in Computer Science, Electrical Engineering, or related technical field * 3+ years‚Äô experience as a Software Developer, Software Engineer, or similar role * Strong and proven programming skills in C++ * Ability to develop creative solutions, simple design, and elegant code &amp;#x200B; \*\*Location:\*\* Chicago &amp;#x200B; \*\*Remote:\*\* No &amp;#x200B; \*\*Visa Sponsorship:\*\* No &amp;#x200B; \*\*Technologies:\*\* We primarily use C++17 and Qt 5.12. &amp;#x200B; \*\*Contact:\*\* Send your resume to careers@qlarityimaging.com
Hey! Yeah I'm interested in getting started with Rust/C++. Thanks for posting this
**Company:** [Qlarity Imaging](https://qlarityimaging.com/) **Type:** Full time **Description:** Qlarity Imaging is applying artificial intelligence to improve patient care, by enhancing the diagnostic insights available to radiologists. We are backed by a Chicago-based life science innovator that invests in, builds, and advises bioscience companies. Our initial product is the first FDA-cleared computer-aided diagnosis software for radiology. It integrates images from multiple modalities to assist radiologists in the assessment and characterization of breast abnormalities. **Responsibilities** * Develop, test, and implement features that enable our AI-driven medical imaging products in the clinical workflow * Collaborate with our R&amp;D team in the development of new machine learning algorithms * Deploy software for new customers and coordinate with hospital IT to integrate systems * Identify and implement improvements to user experience (frontend code) * Resolve complex technical issues and facilitate root cause analysis * Compile comprehensive and accurate documentation and technical specifications **Requirements** * Bachelor‚Äôs degree in Computer Science, Electrical Engineering, or related technical field * 3+ years‚Äô experience as a Software Developer, Software Engineer, or similar role * Strong and proven programming skills in C++ * Ability to develop creative solutions, simple design, and elegant code **Location:** Chicago **Remote:** No **Visa Sponsorship:** No **Technologies:** We primarily use C++17 and Qt 5.12. **Contact:** Send your resume to [careers@qlarityimaging.com](mailto:careers@qlarityimaging.com)
I'd start with this: template&lt;class T, T...Is&gt; using alternative = std::variant&lt; std::integral_constant&lt;T, Is&gt;... &gt;; template&lt;class List&gt; struct alternative_from_sequence; template&lt;class T, T...Is&gt; struct alternative_from_sequence&lt; std::integer_sequence&lt;T,Is...&gt; &gt; { using type=alternative&lt;T, Is...&gt;; }; template&lt;class T, T Max&gt; using make_alternative = typename alternative_from_sequence&lt; std::make_integer_sequence&lt;T, Max&gt; &gt;::type; An `alternative` is variant of stateless constants. template&lt;class T, T Max, T Cur=Max-1&gt; make_alternative&lt;T, Max&gt; get_alternative( T value, std::integral_constant&lt; T, Max &gt; ={} ) { if(Cur == 0 || value == Cur) { return std::integral_constant&lt;T, Max-1&gt;{}; } if constexpr (Cur &gt; 0) { return get_alternative&lt;T, Max, Cur-1&gt;( value ); } } now, we can `get_alternative&lt; std::size_t, 7 &gt;( 3 )` and it will return a `std::variant` containing `std::integral_constant&lt;std::size_t, 3&gt;`. We then add a function that gets the alternative from a variant: template&lt;class...Ts&gt; auto get_alternative( std::variant&lt;Ts...&gt; const&amp; v ) { return get_alternative&lt;std::size_t, sizeof...(Ts) &gt;( v.index() ); } Solving your problem is now easy. bool are_equivalent(my_variant const&amp; left, my_variant const&amp; right) { if (left.index() != right.index()) return false; auto index = get_alternative( left ); return std::visit( [&amp;](auto i) { return are_equivalent( std::get&lt;i&gt;(left), std::get&lt;i&gt;(right) ); }, index ); } `are_equivalent` compiles down to a jump table (assuming a non-sucky `std::variant`).
https://www.removeddit.com/r/cpp/comments/c2r4y8/woah/ /u/bisqwit: "Frankly sounds like your problem, with a stink of obsession, not mine." Ephesians 4:32: "Be kind to one another, tenderhearted, forgiving one another, as God in Christ forgave you." Guess you're more the "do as I say, not as I do, and definitely don't look at my deleted comments" kind of Christian? Cause let me tell ya, you're "It'S DeEpLy OfFeNsIvE tO mE" sarcasm, that was pretty hurtful dude.
Hi, it's hard to tell where this road may lead to. But in any case, you should just try it. So: - Just do it. - Explain which problem you want to solve. - Add a README that describes how to use the tool. - Listen to the crowd's ideas, proposals, and criticism. - And add a license (like BSD or MIT if you want it easy for people to use the code).
Depends on the project and where you are in it, but anecdotally, in my job, which is my first c++ job, we use only the standard library, so most of it is "pure" code by your definition. That said, in the real world, most of software development is often maintaining, fixing or improving existing code, so unless you are on a brand new project, you might not be writing much fresh code. I spent almost 1.5 years before creating a new cpp file in the project. C++ sounds like the obvious choice for the work you want to do.
These are excellent insights. I will add them to the post tomorrow. Thank you!
As far as I can tell, very little except for some special cases. I used ‚Äùunspecified behavior‚Äù on purpose: The compiler doesn‚Äôt have to make any guarantees about the result. It can be garbage or even cause an exception (unlike implementation defined behavior which has to produce some consistent result). What it can‚Äôt assume is that such an operation simply doesn‚Äôt happen and blindly remove code based on that assumption. So yes, a write to pointer that contained a garbage value could result in more or less random things - at runtime. And the ‚Äùat runtime‚Äù is the key here. The compiler couldn‚Äôt simply eliminate that write just because it thinks ‚Äùit can‚Äôt happen‚Äù. A common example is reading from a pointer and then checking it for null before using the result. On every architecture I know of (around 20+ processors), that results in either an exception or reading garbage / the contents of the first word of memory, which will then be thrown away by the subsequent check. So either no error or a (reliable) crash. But a modern compiler can and does remove the null check, resulting in incorrect execution (and at least one known security exploit).
In the assembly code, why is `takes_raw_pointer` implemented as a `jmp`? I‚Äôm guessing the compiler doesn‚Äôt know how the function is implemented so it can‚Äôt be inlined.
I don't think it takes 5 minutes to consume a random C++ library from GitHub that requires building. I'd like to be proven wrong.
I work in what is probably a medium to large C++ shop. We write a TON of C++ that isn't covered by libraries. That isn't to say we don't grab a library and make use of it, but in my group at least the third party library use compared to our own code is relatively small.
Or that it might be worth standardizing after metaclasses because a small library helper that would see common use is far easier to test and review than a core language change.
They're still default-constructible unless the assertion fails (which was the original goal). What you lose is that you now have a user-provided default constructor, which can change the category of your class. In the case of aggregates, you're not even allowed to `= default` it. If you can't find a suitable member function for this when you need the class to fit a certain category (like aggregate), then it's back to asserting below the class as far as I can think of.
Yes, concepts are basically glorified variable templates. There's even been talk of bestowing some of the concept sugar onto regular variable templates.
If you can get away with toggling configurations on a library to deliver a service, then you probably are in a highly competitive market with a quick rotation of companies and where a lot of people could do the job. In this type of market, a company usually has to constantly look for new customers/projects. On the other hand, a lot of companies invest substantial efforts into improving their products. In those markets, there usually aren't a lot of options and the rotation is everything but quick. In this type of market, a company usually has to improve/innovate to remain relevant, or rely on some kind of lock-in.
This is one reason I'd love to have concept template parameters. `: Models&lt;Shape, Circle&gt;` is far more appealing to me than writing a `Models*` class for every concept I ever want to do this with.
Why is developing things in house faster than certifying existing, working, code?
They changed it back to size_t in C++20.
Well, the existence of the natural notation is an indication that we, C++ concepts designers, did think about the interface case but didn‚Äôt want to restrict the feature to just that ‚Äî ability to constrain several independently developed abstractions is fundamental to concepts :-). That functionality is often underestimated. Also, a type can be used in or can model different concepts, long after it has been designed. So, the conventional notation for ‚Äòinterface‚Äô isn‚Äôt a good fit for concepts in C++.
Actually, we did think about that and concluded the conventional notation for interface is too limiting. More often than not a type will satisfy more than one concepts, long after it has been defined.
It is coming along quite well; the front-end team is just next door... :-) Also, if you are on the most recent preview, I suspect you should have some good support for C++20 concepts... Don‚Äôt tell anybody I said this on reddit ;-)
I don‚Äôt see any.
I got it working on my copy of the compiler after I spelled ‚Äúconcepts‚Äù correctly :)
r/cpp_questions would be a better subreddit. I would also just try googling this.
This might be super obvious, but I would recommend an extremely clean separation of graph construction (the user API) and dot file generation. Let the user build up the entire graph before you generate any output at all. This gives you all sorts of flexibility to replace your translation logic whenever you please, or even add support for graph formats other than dot in the future.
Try cppquiz.org
After a few decades in this business, a huge part of my job is to write as little code as possible, delete/simplify as much code as possible, build libraries that can help my co-workers write less code, and teach my co-workers techniques to help them write less code. But as others have said, how much of the code I do write is ‚Äúpure code‚Äù varies drastically with the project/feature.
Did they? Probably to get rid of all the signed/unsigned implicit conversion warnings when you compare it against `.size()`. Roll on `std2`...
So, C++ has typeclasses now? [https://i.pinimg.com/originals/7e/a0/b1/7ea0b159b7f760d4582445fa91596398.jpg](https://i.pinimg.com/originals/7e/a0/b1/7ea0b159b7f760d4582445fa91596398.jpg)
Probably. I had honestly forgotten about `ptrdiff_t`. The trouble is that a lot of the time we‚Äôre using containers, not raw pointers, so the name doesn‚Äôt seem right, and also the containers use `size_t` all over the place so you have to remember to cast.
If you haven't tried clion, give it a whirl
They also added a `std::ssize()` free function that wraps `std::size()` but returns `ptrdiff_t`.
Any discussion on the fact that some programmers feel that C++ is becoming too verbose and/or arcane?
Hallelujah, I think?
Hi, the comment is visible at least to me. https://i.imgur.com/llG1UAG.png
What is that even supposed to mean?
Exactly what it says on the surface? The language is becoming fairly dependent on templated, verbose functions/algorithms/types that make what would be relatively brief/short concepts in other languages look particularly verbose and arcane in C++. I've seen multiple cases, in /r/cpp and elsewhere, where someone has proposed doing something 'better' using `std::transform`, `std::accumulate`, or some other algorithm, where it was pointed out that the simple loop that it replaced was *far* easier to read. This seems to be a trend, and a frightening one at that (to me).
Oh, don't get me wrong, I too think that implicit conformance is very desirable as well. It just would be nice to have both somehow. Right now, I am using \`static\_asserts()\` after the type definition, which works fine.
Both of those functions have been in the language since standardization, albeit with std::transform seeing an added overload in 17, and additional constexpr in 20.. Your argument against them is more against functional programming than the moving standard, which is fine, just not directed correctly. Obviously functional programming people like suggesting their use. There are big personalities in the community who advocate for this style, I don't think it's really a battle to be one as much as one to put up with. C++ has always catered to different groups. One is a bit of a fad right now for better or worse. Your first paragraph contains your most overlapping (of audience) criticism in my opinion, which seems to be that the standards committee leans too hard on the standard library when language features would do the work better/faster/simpler. I think you'll find more support in that argument as most people seem to agree on that.
&gt; Both of those functions have been in the language since standardization, albeit with std::transform seeing an added overload in 17, and additional constexpr in 20.. Your argument against them is more against functional programming than the moving standard, which is fine, just not directed correctly. Obviously functional programming people like suggesting their use. There are big personalities in the community who advocate for this style, I don't think it's really a battle to be one as much as one to put up with. C++ has always catered to different groups. One is a bit of a fad right now for better or worse. While true, there seems to be a greater push for this since C++11 and the introduction of lambdas which allows a far easier use of them, along with the introduction of a far greater number of pointer types (which themselves I feel are overly verbose and not always well-named) such as `unique_ptr&lt;&gt;`, `shared_ptr&lt;&gt;`, etc. Prior to C++11, I can't really recall ever seeing `std::transform` or `std::accumulate` in the wild, and you'd have been hard-pressed to find programmers who were familiar with them. After it, they and similar functions seem to be present in every single 'best practices' presentation I see (and there are usually comments to the effect that the loop form is easier to read, which isn't necessarily a criticism of functional programming but rather that C++ syntax does not lend itself well to it in the form of readability). &gt; Your first paragraph contains your most overlapping (of audience) criticism in my opinion, which seems to be that the standards committee leans too hard on the standard library when language features would do the work better/faster/simpler. I think you'll find more support in that argument as most people seem to agree on that. To me, they are both two problems *and* one. I've no issue fundamentally with functional programming, but templates in C++ are quite verbose and tend to make functional solutions using standard algorithms... awkward and difficult to read/parse for the programmer compared to loops as though you'd normally find in older C++ or in most other imperative languages. Couple the verbosity and arcaneness of templates (note that I *like* templates) with the fact that the committee leans heavily on the standard library which just magnifies said verbosity, arcaneness (arcanity?), and compile times, and it becomes a much larger problem in my eyes. And I'd still like a way to impose type-based limits on template type arguments in, say, a Java style or such, rather than using a much *heavier* solution like Concepts. Something like template &lt;typename T : FooClass&gt; or something similar. Maybe drop `template` altogether as Stroustrup pointed out was possible initially. But that's neither here nor there, I suppose. Just got me into a ranting mood.
STL is designed to work this way: You implemented your algorithm on a data structure through a view. This view is described through a pair of iterators, and the function describes your intent that you want to do a transformation or an accumulation or other calculations over these data. Yes, for loop are getting easier to write now, but it's too generic to provide a clear intent until you read its implementation, while using STL algorithms appropriately provides a clear documentation as a bonus.
Out of curiosity, what would you call `unique_ptr` and `shared_ptr`?
It's interesting that this paper still urges networking TS to be included in C++20. Though it's not going to happen because nobody reviewed the executor paper in the previous meeting, I'm glad that it's still an priority from direction point of view.
But why are the algorithms so verbose? Why isn't there an overload without the iterator start and end like this: template &lt;typename T, typename I&gt; T accumulate(I iterable, T initialValue) { return std::accumulate(iterable.begin(), iterable.end(), initialValue); } Creating a sum with this is much easier: std::array&lt;int, 4&gt; a = {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(a, 0) &lt;&lt; std::endl; Compared to this: std::array&lt;int, 4&gt; a = {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(a.begin(), a.end(), 0) &lt;&lt; std::endl;
Templated pointer wrappers.
&gt; ... while using STL algorithms appropriately provides a clear documentation as a bonus. That's certainly the hope and intent, but in reality I've found the opposite to be true. I suspect that there are two populations of C++ programmers, and neither is a particular minority most likely - those who love those algorithms and find that they are far easier to use and read, and those who feel the opposite.
&gt;Prior to C++11, I can't really recall ever seeing `std::transform` or `std::accumulate` in the wild, and you'd have been hard-pressed to find programmers who were familiar with them. The &lt;algorithm&gt; header has already been extremely useful pre-C++11; it just got easier to use with lambdas as part of the language. But the claim that there weren't many programmers familiar with these algorithms before is completely untrue.
Fundamentally it's because until C++20 there wasn't a way to turn an iterator pair/container into a range. My understanding is the ranges proposal, which was accepted for 20, actually does fix this. Though I'm not sure where these overloads will live, I'm not too caught up with the specifics of it, as I've never used the \`range-v3\` library. &amp;#x200B; Of course the downside of range-v3 is that it's quite a complex and slow template library. I think simple cases like these probably aren't a big deal, and in fact I've seen many libraries implement similar ideas.
In all the companies I'd worked at, I could count on my hand the number of people who were wholly familiar with &lt;algorithm&gt; in any fashion, and I don't need to use any digits to count the number of people who regularly *used* it. It is most likely going to differ from industry to industry, and I've generally worked in the game development industry. You don't have to like what I'm saying, but saying that my perception of reality as per my experience is untrue is rather unfair. To be fair, I doubt we have any metrics on how many programmers pre-C++11 were: 1. Heavily familiar with &lt;algorithm&gt; 2. Heavily used &lt;algorithm&gt; compared to the inverse, so we cannot really make objective judgment calls either way. I do know that *in my experience*, the header was incredibly uncommon prior to C++11, and even after it it didn't make much headway other than for, say, `std::sort` or other situations where the loop form wouldn't be obvious.
I don't think I could disagree fundamentally any more with the following points &gt;Students cannot be expected to download and install libraries on day #1. Even a requirement to \#include an appropriate set of standard headers can be a burden. Thus, the technique of providing a training-wheels library in the form of a header or precompiled libraries is at most second best. This is a major technical reason that courses start with pointers, arrays, C-style strings, unions, etc., rather than std::string, std::vector, std::variant, and algorithms. - &gt;It should be trivial to include what is needed for teaching; modules should help here and we need an ‚Äúall‚Äù module and/or a ‚Äúfoundation‚Äù module (see also [Clow,2018]) so that novices don‚Äôt have to search a textbook or the web to find out which header to #include to use a foundational feature. Modules should help here. And I think brings me to a major point about C++ that I haven't seen articulated very well Less lines of code doesn't make something simpler to understand. Almost all programming languages are equally hard to learn initially. The things that people struggle with are 1. what is a variable 2. what is a type 3. what is a function 4. what is passing by object/reference/value/pointers/call by sharing/etc and how do i modify things passed into a function and why is it different in every language 5. what is control flow (particularly for loops) 6. what is a struct/class 7. what are data members and functions in a class 8. what the good christ is inheritance 9. polywhatism? 10. what is good code Etc. The important thing to note is that these are *concepts* which are common to 99.9% of languages. These are really the things that I've seen people struggle with overall The most important part of making any programming language easy to learn is consistency, and obviousness. Every feature should work exactly how it says on the tin \#import &lt;all&gt; is thus exactly the opposite of what will make C++ easy to learn. It makes the language inconsistent, and adds an extra thing to learn EG, which one of these two programs are easier to reason about as a newcomer? #import &lt;all&gt; int main(){ std::vector&lt;int&gt; hello; } or #import &lt;vector&gt; int main(){ std::vector&lt;int&gt; hello; } Initially when learning to program, a lot of progress is made by essentially pattern matching. Its therefore significantly more obvious where std::vector comes from with \#import &lt;vector&gt;. Its consistent, and unsurprising. If a user wishes to use std::string, they might very logically reason that it exists in &lt;string&gt;, and therefore it should &lt;all&gt; however will rapidly hit a bottleneck. The beginner will then be forced to learn about how they should really be writing code, instead of having been introduced to proper coding in the first place This mentality of making C++ easier to learn while actually making it more complex is something I've seen absolutely everywhere and it makes me sad, because its often used to justify massive inconsistencies in the language that make it much **harder** to learn, because the language is now inconsistent eg, omitting return 0 from main doesn't make the language easier to learn. It means that beginners then expect they can omit returns from other functions, which leads to undefined behaviour. This teaches bad behaviour that then must be immediately unlearnt by new users. This makes the language harder to learn So without further ado, here's what actually makes C++ hard to learn in no particular order: 1. Translation units. No other language works like this, modules may or may not help depending on how complex it is to set stuff up 2. Integer promotion rules. These are mental and extremely unintuitive. I've been doing c++ for 10 years and I still forget 3. Classes are initialised/constructed unconditionally, whereas primitive types are not. This leads to UB in C++ and extremely inconsistent results, whereas in other languages beginners don't need to learn about this at all. Why is std::string different to uint64_t? 4. Horrible error messages even for basic types. Concepts seem like a good shout here, and recent compilers do a significantly better job at providing good error messages for all kinds of errors which is wicked 5. No requirement to return a value from a function. This leads to UB everywhere, and is an extremely common source of bugs because it can often work how you expect. -Werror=return-type is probably my most productive compiler flag 6. References vs pointers vs values vs move semantics vs shared_ptrs vs unique_ptrs vs weak_pts. There are good reasons for all of these to be like the way that they are. I don't know if there is or even should be a solution, but the reality is that C++ exposes a lot of complexity that other languages try (and in my opinion fail, completely) to hide 7. So many random kinds of UB that are perfectly fine in other languages Etc A lot of this can basically be broken down into two categories 1. Inconsistencies with other languages for better or for worse 2. Inconsistencies within C++ itself So to tl;dr this massive wall of text, please stop using this as an excuse to introduce inconsistencies in the language. The language should be made *more* self consistent not *less*, even if it means slightly more lines of code on screen at once. It'll make it easier to learn, and \#import &lt;all&gt; should romans go to the house!
Mhh I don't quite understand. The code above works with C++11. What does that have to do with ranges? I am fairly new to C++, so I might not see the whole picture here.
Didn't expect to see this for a few more days. I know what I'm doing after work today.
I honestly hope the TS _never_ makes it to the IS in its current form * The committee will likely _never_ be able to standardize any kind of crypto making it unusable on its own. * It was designed long before coroutines and will require serious rework to integrate _elegantly_ with them * Standard executors are still very much in flux and it's doubtful that the TS will be able to be rebased on top of it once executor get merged, sufficiently in time for 23 - and executors are a huge part of asio Asio is also certainly inspiring the work happening on executors and that the most important bits. Maybe we can also extracts bits of it (timers, strands etc) and leave sockets out rather than encourage people to open encrypted sockets to pretend that C++ supports ""networking"". Ultimately, asio is a great library that is usable today and supports crypto, so why wait for the standard to do something not as good ? http://think-async.com/Asio
Sorry, I didn't mean it isn't possible at all, I just meant in the library we didn't have a solution for it. As for why it, or overloads like you're suggesting, weren't added before now, that I can only guess at due to not following it closely. I can say ranges the library/proposal has been worked on for quite some time, I think after C++11 but before C++14, although there are prior examples of similar ideas. Often when the committee sees something like that worked on it seems like they wait until consensus is formed around one solution, and then they wait until that thing is ready. As it was something like this wasn't proposed (or perhaps pushed for) before C++11, and so ranges was the candidate, and it's time is now.
^ This! So much!
Well, I love them, certainly since C++17! There is no simpler way to write correct multi-threaded code than to use the parallel overloads of many of those algorithms (that includes `std::sort` b.t.w.), but `std::inner_product` [so much more than what it says on the tin] and `std::transform_reduce` are extremely useful, and even a simple [MT] `std::for_each`.
Ah ok, thank you. But maybe this is the reason, why people think that C++ is getting too verbose. New language features should reduce code written, while still being easily understandable and sometimes I think new C++ features accomplish none of these goals. The example I gave is the perfect analogy. If the average user implements a sum function he would want it as simple and straight forward as possible, but in the C++ world it needs to be as flexible as possible and thus resulting in more verbose code.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1371r1.pdf Is no one else really jarred by the `inspect` keyword here?
&gt;If the average user implements a sum function he would want it as simple and straight forward as possible, but in the C++ world it needs to be as flexible as possible and thus resulting in more verbose code. Right, but this is not entirely fair. These are design decisions from 20-30 years ago, still needing to use \`begin\` or \`end\` until 20, isn't the language getting more verbose, it's sticking with design language we've had since the language was standardized. &amp;#x200B; Ranges in this particular case solves this problem, at least mostly, I think you might have to explicitly change the container into a range (which I'll agree is a bit not ideal, but it's much easier than current). This is a net loss in verbosity. The problem never got \_more\_ verbose, it always just stayed the same.
Agree with the list of what makes it difficult for beginners, in my experience teaching. Notably the need to learn the toolchain. Students will get frustrated that, even though they‚Äôve gone through the work of writing their programs, that now they need to learn translation units and how to compile and include and link and provide dirs correctly, versus their experience with interpreted languages.
Situations where you are going to want to explicitly parallelize something like that probably aren't the situations I have problems with, as those are already going to have inherently complex forms even as loops. Also, OpenMP is still a thing, of course.
Well java has the import directive and the packages and including them couldn't be easier using and IDE such as eclipse. I think if they want to make C++ easier to learn then having an IDE that is easy to use would be the best option. Nowadays compilers are very smart to tell you what includes you might be missing, so it's not like we are now in a worse spot than 5 years ago.
&gt; Also, OpenMP is still a thing, of course, and works on plain loops. My phone autocorrected that to plainoops, which I recommend as new standard terminology. Even `std::sort`? &gt; Also, OpenMP is still a thing, of course, and works on plain loops. My phone autocorrected that to plainoops, which I recommend as new standard terminology. `Clang + Windows != OpenMP`, so it don't fly. &gt; An issue with things like std::inner_product if you don't use them in a very obvious way is that it will not be immediately clear to someone reading your code for the first time. Yes, you're right. Once you've got the gist, it's oh so powerful, though.
The worse thing about `import all`, is that `all` as to be compiled at the point of use - not only the module interface of _everything_ but, at some point before linking, all definitions associated with _all_. So even if once a module exists, *importing* big modules are cheap, big modules lead to increase compilation because said modules have to be compiled at some point. Small modules and libraries are key to fast compilation in C++. (an analogy in today's world is compiling "Qt" (takes a while) because Qt has a monolithic build system, even if the project might only use QString ( &lt;1% of Qt ) )
Anything with begin and end can be used directly as a range. The only case I'm aware of of needing to wrap a value is C strings and string literals (and the latter will still work if you're OK with getting the null terminator).
Perhaps it's an indication that OpenMP or something similar should be standardized within C++.
I acknowledge some of your points, but I disagree with your conclusion because: 1. There will never be a perfect design for anything. The network TS is not perfect, but it's working fine, so include it now and improve later. 2. The network TS has provided design path to support coroutine as well as crypto, which can be addressed in an amendment or in worst case, 3 years later. 3. Available in ASIO is not good enough because library solution may not be available to some environment that has strict rules about 3rd party dependency, as well as aggravating fragmentation due to other popular network libraries, which may not be a bad thing but still.
Ah, gotcha, that's awesome to hear! I was just looking at a sample (linked below) where it was calling some things I wasn't familiar with. [https://github.com/ericniebler/range-v3/blob/1fd3167e0b67cf41e2486585fb3a44c1ee02e936/test/numeric/accumulate.cpp#L41](https://github.com/ericniebler/range-v3/blob/1fd3167e0b67cf41e2486585fb3a44c1ee02e936/test/numeric/accumulate.cpp#L41)
I think there's been a misunderstanding. I thought you were suggesting `std::unique_ptr`and `std::shared_ptr` were badly named. Unless you're suggesting `std::unique_template_pointer_wrapper`???
It will probably not survive long although I really wish it would
You found one here at least. Plus, such practices has been promoted by various big names in C++ communities, though old habit dies last I guess, and C++ provides choices so people have freedom to pick their best tools, which is good.
The downvoting of your question means that a lot of people were unable to express any arguments against it, but felt that it /should/ be countered by something. That means (1) it's a good question, and (2) that there unthinking C++ fanbois present, and (3) it's an example that the idea of democratic voting about scientific or engineering issues is seriously braindead as a way to resolve such issues, but still a good way to attract people to social sites. The last point has an inherent tension between goals.
In my experience people tend to reach for libraries for general problems (json parsing, HTTP, kafka or redis clients etc) and the pure coding is basically hooking up your business logic on top of those. For example, if you have some service that say ingests external data and processes it to turn it into your system's internal format and passes it on. You'd be coding up the logic for making sense of the data which could be arbitrarily complicated - keeping state, combining multiple sources of data into one stream etc, and it may also have strict performance requirements so you have to be effiecnt in how the business logic code is doing its job. Hope that makes sense!
Is it concerning because it is a common word that might already be used as an identifier? Could always make it co\_inspect! /s
&gt; This is a major technical reason that courses start with pointers, arrays, C-style strings, unions, etc., rather than std::string, std::vector, std::variant, and algorithms. No, its because they want to teach what they consider the "basics of how things/the computer work" (pointers etc.). Also I love sum-types in all languages that actually have them, yet i think exposing newcomers to garbage like std::variant is the best way to scare them away from c++
The amount of ‚Äùpure coding‚Äù depends a lot on what you do and what you count as ‚Äùpure‚Äù. However, based on my experience, very little of any code in most projects is about implementing any classic algorithms. The vast majority is various forms of glue code to move data around, format it and handle all the internal bookkeeping.
I believe using templates to represent those concepts is a defect in the language, particularly given how common they are expected to be in modern C++.
One of my issues is likely, as has been expressed by myself and else, is that many of the concepts in modern C++ *shouldn't* be library templates if they are expected to be heavily used (like pointer wrappers) and that the template syntax should be simplified so that usage of things like algorithms is less arcane/awkward.
(I'm not the previous poster.) My first thought is that `unique` and `shared` would be less verbose, and the 4-character suffix doesn't add a lot. `Unique` as a name for a type clashes with the `std::unique` algorithm, but the latter is also badly named. I think `make_unique` or even `copy_unique` would be better. Algorithms should be named for verbs, not nouns. For semantics, `counted` might be clearer than `shared`. One reason is that the thing pointed to by a `shared_ptr` might not actually be shared (but is always counted). Another is that it might be shared by some other mechanism, perhaps involving garbage collection, where-as `counted` implies the specific semantics of a reference count.
I may be wrong, but for http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0288r4.html#name-options We have/will have: std::**function** std::inplace_**function** std::**function**_ref but then *std::any_invocable* ? Any of first few options discussed is better, at least for me: 3 unique_function 3 move_function 2 move_only_function 7 movable_function
I may be wrong, but for http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0288r4.html#name-options We have/will have: * std::**function** * std::inplace\_**function** * std::**function**\_ref but then **std::any_invocable** ? Any of first few options discussed is better, at least for me: * unique_function * move_function * move_only_function * movable_function
Just curious, why would you put this column before the MSVC? The previous order kinda represented the market share of each compiler (kinda because of the nvcc), but now it doesn't make sense to me anymore.
It's insane to me that the normal way to declare a heap-allocated `int` member within a header file is `std::unique_ptr&lt;int&gt;`. 85% of the type's text just to indicate it's an owned pointer, compared to 25% in `int*`. I wish we could claim `@` or some other unused syntax for unique pointers.
The certification process for the gov isn't as simple as having a senior dev go through and verify the code does what it says it does. Even the software we write goes through an intense verification process before it is deployed, and that process is slightly shorter because it's government software and not "off the shelf" software. It's just one of those things where bureaucracy causes in-house to be faster. Im sure other agencies might be a bit more lax but, from what I've seen as a junior dev, we're a bit more controlled in what we use.
On the plus side, at least it isn't such a pain in the butt to set up reasonable tools that are the same cross platform. Most linux distributions ship with GCC, and msys2 is amazing on windows
So it is next to Clang. You can change it, if you want, I don't mind.
&gt; We fundamentally need: &gt; - Stability‚Äã: Useful code ‚Äúlives‚Äù for decades &gt; - Evolution‚Äã: The world changes and C++ must change to face new challenges. &gt; There is an inherent tension here. We should be very reluctant to break compatibility. People always want a simpler language, a language without complicating ‚Äúlegacy features‚Äù, and get seriously angry if we break code that they depend on. &gt; &gt; [...] &gt; &gt; C++ is complicated, too complicated, yet we cannot remove significant facilities and changing them is very hard. I think that attacking this tension should be the primary goal of the C++ committee. The C++ language contains a lot of legacy, and is becoming more and more unwieldy as new features are added that have esoteric interactions with existing features. Therefore, I am convinced that it is crucial, going forward, for culling to occur in C++. The question, then, is: How do you cull obsolete/unwanted features without breaking backward compatibility? It seems the C++ committee, and the C++ community, have both thrown their hands up judging the problem insurmountable. I refuse to believe it so. --- *Intermede* Have you heard of Rust editions? They were created specifically to deal with this issue! The idea is simple: each edition is essentially a "slightly different" version of the language which remains broadly compatible with other editions. The easiest changes are obviously syntactic changes: a new edition can add a new keyword, for example, without fear of trampling over existing identifiers (such as `dyn`) and it can require a syntactic change (traits used to be passed as `&amp;Trait` and must now be passed as `&amp;dyn Trait`). Crucially, however, it is possible to mix and match libraries and binaries from various editions together: each library and binary indicates its edition to the compiler (just like using `-std=c++14`) which uses the syntactic rules of the corresponding edition to compile the code. --- Could C++ do the same? Of course! Exactly the same? Maybe, maybe not. Rust editions just prove that the problem is NOT insurmountable; the exact mechanism does not matter! Now, with headers, this would have been terribly difficult. I would not fancy annotating each and every header with the version of the C++ standard it uses. C++20 introduces modules, and now we have well defined library boundaries! A single (or a set of) C++ standard version(s) per library is a piece of cake! --- Now imagine what we could fix in C++23 with such a system! I'll start you off with: - Uniform Initialization: `std::vector&lt;int&gt; a{3, 2};` could invoke the regular constructor, with initializer lists requiring `std::vector&lt;int&gt; a{{3, 2}}`, and invoking constructors with parenthesis (`std::vector&lt;int&gt; a(3, 2);`) could finally be deprecated, solving the Most Vexing Parse after so many years. - Zero-initialization of built-in types by default; with the `indeterminate` keyword to be used to initialized them to an indeterminate (but not undefined) value for performance reasons when necessary. and I'm sure that you people have a lot of pet peeves that you'd like to see addressed. Initialization itself is so complicated at the moment...
I hope the voting was done in a sensible manner, not just "which of the following names do you prefer?" because that means two good names could easily hurt each other's chances.
Well, it's too late to change how template is written and we need to get used to it. Remember the success is built upon compatibility with C and the success of modern C++ also partially thanks to backward compatibility with C++98. And Concepts is by definition the requirements of template parameters. No one is fond of verbosity, but we are living in a reality that this is how it is.
Here's why I like that most things are 100% library improvements and don't introduce core language changes. I have both clang and gcc installed. On top of that, I have both libstdc++ and libc++ installed. Only libstdc++ has polymorphic memory resources (pmr) implemented. Once I got gcc 9.1.0 and the standard library with pmr support, I was able to compile code using that even with clang 8. In short, mixing and matching of compilers and standard libraries is possible, allowing older compilers to compile newer code with new, but strictly library, features.
Or use attributes like [[unique]], even. But @ or similar would be ideal.
Why I'd need a `malloc` replacement in c++?
Presumably new secretly uses malloc under the hood
It's actually quite common to replace the standard allocator with ones like jemalloc, tcmalloc or TBB's allocators
Yeah, in the vast majority of implementations. Even greater reason to ask, why I'd need a custom allocator, when even the use of `new` should be minimized.
if you're using anything which uses new under the hood (vector/strings/etc), then it can be useful in performance sensitive applications (eg threading)
Instead of P1789R0, can't we just use "for constexpr" expansion statement (don't remember the paper number) ? I'd rather see std::index\_sequence die, than extended and used even more. &amp;#x200B; `#include &lt;tuple&gt;` `template &lt;typename ...Ts&gt;` `void swap_tuple(std::tuple&lt;Ts...&gt;&amp; lhs, std::tuple&lt;Ts...&gt;&amp; rhs)` `{` `using std::swap;` `for constexpr (size_t i = std::ranges::iota(0, sizeof...(Ts) - 1))` `{` `swap(std::get&lt;i&gt;(lhs), std::get&lt;i&gt;(rhs));` `}` `}`
Link for "[P1272R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1272r2.html) Byteswapping for fun&amp;&amp;nuf " leads to "[P1280R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1280r2.html) Integer Width Literals" paper.
Just so that I understand it correctly, you just set "no" almost everywhere by default? Because for example clang shipped with Xcode 10 supports a lot of C++17 features...
A lot of this information isn‚Äôt correct. In particular the C++11 section - I don‚Äôt know the full extend of the compliance but that table implies it doesn‚Äôt comply _at all_ when I know for a fact is supports many (if not all) of the C++11 features, such as static_assert etc
Just so I understand it correctly: the red cells are the default values? Because I am quite confident that Xcode 10 supports a lot of C++17 features out of the box...
You're right, and it has been done, almost all algorithms in the `&lt;algorithm&gt;` library have a parallel version.
Agreed. Our company has a strict policy on third party dependencies. We have been doing offline apps with command line interfaces for years and clients have had about enough. I sincerely hope for inclusion of Networking and Graphics TS in C++20 so we can finally step into the 21st century.
&gt;level 1 Because someone always has to bring up a religious issue. [http://catb.org/jargon/html/R/religious-issues.html](http://catb.org/jargon/html/R/religious-issues.html)
License is MIT if you‚Äôre wondering (like I was), which is awesome.
The proposal just indicates adding it to the grammar rules. It‚Äôs is not a new keyword for the language.
Great point. I think that would even work out of the bag because all of `iota_view`'s relevant members are `constexpr`? Only real change in your code would be an added `constexpr`: for ... (constexpr size_t i : view::iota(0, sizeof...(Ts) - 1)) { ranges::swap(std::get&lt;i&gt;(lhs), std::get&lt;i&gt;(rhs)); }
If it's not a keyword then you'll need complex disambiguation rules. No thank you.
How big is your stack space?!
With C++20, there is such an overload. See "Ranges".
How cat it work? Expressions `iota(0, N)` and `iota(0, M)` have the same type.
I‚Äôm just pointing out what‚Äôs in the proposal. FWIW, `import` and `module` are also contextual keywords and have already been added to C++20 ‚Äî these join `override` and `final`. I believe contracts (also C++20) introduce `audit` and `axiom`. Contextual keywords are not new. So there are two ways: 1. keep the (in my opinion) sane naming with `inspect` at the cost of adding disambiguation rules 2. drop inspect in favor of a new reserved keyword. WG21 hasn‚Äôt been too keep on adding reserved keywords lately. And the ones they have added lately aren‚Äôt exactly champions of good naming (with the exception of `concept` and `requires`). See: coroutines, consteval
So in the latest [p0709r3 - Zero-overhead deterministic exceptions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r3.pdf), Herb takes a step back and instead of proposing terminate on all allocation failures, he proposes to terminate only on fixed size allocations. While this may be a easier to push though the committee since it more backwards compatible, this is a step backward in my opinion. In particular, push_back on containers can not be made noexcept. I agree that when `new int[10'000'000]` fails, it is not an abstract machine exhaustion. But what about the case when `new int[10]` or `new int[100]` fails? That I think is an abstract machine exhaustion, and is far more common. Rarely do I need to add 10 million new objects to a vector, but adding 10 new objects is far more common. Just go back to the original plan, all allocation failure terminates, and add try_xxx functions to the containers.
IEXCloud is a free API for pulling stock prices etc., I'm not a financial expert but I'm sure you could use this to do some interesting stock predictions. Maybe try a couple different ways of predicting, linear regression, PID, SVM,...
Yes, it works with home grown iota: [https://cppx.godbolt.org/z/rkQEgp](https://cppx.godbolt.org/z/rkQEgp) &amp;#x200B; Nice, P1061 looks like should solve other other use-cases where we need to create helper function just to access elements of index\_sequence. I just wonder if it wouldn't be better it if worked on array-like types, so we could just write: `constexpr auto [...Ints] = std::ranges::iota(0, 10);` `return f(std::get&lt;Ints&gt;(tuple)...);`
Like I said, I hope others can fill in the blanks. The only ones I added are std::any, optional, variant and filesystem. Unfortunately the table defaults to "no". I would have used "n/a" for the others, but I am not sure if it means "info not available".
Why should I favor this over STL? What advantage this has over Qt?
Yes, default is "no".
Hi @dominoe29, I'm too at the same situation, after learning the basis and have done some simple console apps. Any advice to get started into some simple real-world programs? Thanks
Be happy and live long nice life
I really like that idea.
Is there a plan to make this the standard allocator in Windows? The current one has serious issues.
So your clients want &lt;x&gt;, but your company has policies that forbid &lt;x&gt;. Doesn't that mean that someone here made some very bad choices: your company for forbidding &lt;x&gt;, or for requiring C++ instead of some other language, or your clients for doing business with you? I have to ask: why should it be on the C++ community to provide a solution to your entirely self-inflicted problems? No matter what the committee provides, there will always be companies that randomly forbid stuff, but why should they be accomodated?
 Would it be fair to say that programmers who didn‚Äôt take the time to learn to use &lt;algorithm&gt; a decade ago are the same programmers who are now finding modern c++ strange and difficult to read?
There are two variants of for ... expansion statements. One for "heterogeneous containers" like tuples and structs, where each element can be of different type - such "container" must provide tuple like access (std::get&lt;N&gt;, std::tuple\_size\_v&lt;T&gt;), e.g.: for ... (auto&amp; elem : tuple) { printElem(elem); } The other one is for "homogeneous containers" aka all elements are of same types (e.g. vector, array) such "container" must provide access via std::begin/end, so you get: for ... (int &amp; elem : array) { ... } &amp;#x200B; Additionally you can mark elem as constexpr, that way you can use it as template parameter. &amp;#x200B; Read [p1306r1](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1306r1.pdf) for more details.
Why don't we use `std::inspect` \- with the added bonus that you can write `using std::inspect` to 'elevate' it to normal keyword status if that's safe?
This is a really confusing comment. Do your programs not allocate memory at all?
Agreed. The default Windows 10 allocator suffers of nasty slowdowns in heavily multithreaded applications.
`std` is a namespace. You‚Äôre suggesting placing what amounts to a language feature accessible only behind a namespace ‚Äî that has never been done before and would make the compiler‚Äôs job even more difficult. From a parsing perspective with the C++ language, identifiers are `[A-z_]`. Scope resolution `::` is an operator which is only semantically processed well after tokenizing and really only during symbol lookup. Your proposed grammar rule would be horrendous. Fundamentally, why should a language feature be thrown behind a library namespace? Because that‚Äôs wildly inconsistent. They didn‚Äôt say `std::yield` or `std::await`.
I also saw very bad heap fragmenting in some cases leading to excessive memory usage. I can provide a small C++ test program reproducing it if Microsoft is interested.
You realize that adding 10 new objects to a vector may cause an allocation of 10 million when the vector is big enough?
It seems this time they choose to strip `&lt;` and `&gt;`, and everything in between in the title. The title of P0533R5 is displayed as "constexpr for and ", but the actual title is "constexpr for &lt;cmath&gt; and &lt;cstdlib&gt;".
Ah I see! Makes sense
Ah, thanks, I have missed the second form of expansion statement.
&gt; In particular, push_back on containers can not be made noexcept. That is not the only reason why push_back is not noexcept: The copy/move constructor of T can throw an exception.
&gt; Just go back to the original plan, all allocation failure terminates, and add try_xxx functions to the containers. Duplicate every function that modifies the vector? No that's a bad idea. Also this conflicts with maps's try_emplace.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1737r0.pdf
Namespaces are pretty much the only mechanism we have that guarantees that we can introduce new names that will not clash with something already existing. Well, I suppose there's also the practice of writing identifiers with some illegal character combination, like underscore-capital, but that particular memo seemed to have never made it out into the field, and just about everyone and their dog have written source that uses _X style identifiers. You might say "well, that's _their_ problem", and I feel at least somewhat sympathetic to that, but then you get the additional problem that `_Inspect` would be an ugly keyword that doesn't follow any existing pattern either. Sticking it into `std::` on the other hand, comes with the massive advantage that source code that doesn't clash with that particular name can just elevate it into global scope. Moreover, if we go down this road it will be much easier to introduce new keywords in the future, saving us much anguish. As for `std::yield`, there was quite an outcry over the hideousness of `co_yield`. Perhaps `std::yield` would have been the better choice. In fact, perhaps it still can be. As for making things hard on the compiler, it should feel free to special-case `std::inspect` (as a sequence) into the inspect-token, without waiting for later stages. That won't impact later stages. Alternatively, add something like `#language=(c++20)` somewhere, and only allow `inspect` if that line was found earlier during parsing. Apparently Stroustrup hates that though, closing off this simple and straightforward path for language evolution :-(
Man! Can someone explain why u/yahvittu is getting downvoted here? They're not asserting one would never need a replacement. They're just asking and I feel like no one is really answering. Any object in heap space (whether allocated directly using new/malloc or indirectly using RAII principles) used an allocator to get there. So in C++ you should avoid raw pointers, but unique_ptrs still allocate memory using the memory allocator. So even if *you* don't type the word "malloc", you're still calling it indirectly whenever you allocate heap memory like in a smart pointer, a collection, or anything else that might use space in the heap under the hood.
Namespaces are the only mechanism that we have that guarantees no clashing for **library** features. Pattern matching as described in this proposal is a language feature. You will either break things, introduce contextual keywords, or introduce a new reserved keyword. Those are your three options. Anything else is too inconsistent. Also, I‚Äôm not sure how your solution would make `using std::inspect` feasible from a parsing perspective. You mention adding ‚Äústd::inspect‚Äù to the keyword list. A using statement only makes names available for symbol table lookup. Parsing comes well before that.
Your middle paragraph answered my question pefectly, thanks! I actually did not know that the allocator which `new` uses under the hood could be replaced by the programmer.
Thank you.
&gt; This seems to be a trend Trend implies that things are changing over time. `transform` was in the very first C++ standard. What is the alleged trend? &gt; becoming fairly dependent on templated, verbose functions/algorithms/types I don't really know what you mean by this. Every iteration of the standard is less verbose from my perspective. Lambdas and then generic lambdas vs function objects, range-based for vs iterator loops, concepts vs SFINAE, ranges vs iterators, if constexpr vs tag dispatching, structured bindings vs named member access, fold expressions vs recursive templates, ctad vs class factories, ... Sure, some languages do some of these things with less verbosity. Everyone wants less verbosity. But the trend is surely favorable here. &gt; I've yet to see any meaningful responses I don't know what you're looking for, but just arbitrarily demeaning everybody in advance doesn't seem like a good way to find it.
&gt;You will either break things, introduce contextual keywords, or introduce a new reserved keyword. Those are your three options. That's nonsense. Maybe having a std:: prefix is undesirable for whatever reason, but a `#language=c++20`-type statement could be implemented just fine, and would provide a generic mechanism for introducing new keywords into the language. But hey, I suppose we could always go with `static switch` instead of `inspect`. Is that what you want?
Well, that's a big topic, not intended to be gotten into here. I won't say why you should \*favor\* it, because a lot of people around here think that saying anything is in any way better than what they've chosen is to be immediately down-voted into oblivion. I can say what's different about them. CIDLib is a single, coherent architecture, where everything has been designed to work as a system. This is not something the STL can do because it cannot go back after the fact and force functionality on stuff that has been around for ages. And there are bits of the standard libraries that just never get addressed or significantly improved because they are so old and widely used that they can't be fixed without breaking lots of stuff. CIDLib doesn't suffer from those things. Qt, being based on the STL, inherits a lot of the same issues. They cannot force things on the STL either. I've written a number of articles here and on CodeProject about it if you want to see more of what it can do. [https://www.reddit.com/r/programming/comments/a2wnwt/creating\_a\_virtual\_kernel\_platform\_abstraction/](https://www.reddit.com/r/programming/comments/a2wnwt/creating_a_virtual_kernel_platform_abstraction/) [https://www.reddit.com/r/programming/comments/a33i7n/making\_c\_enums\_first\_class\_citizens/](https://www.reddit.com/r/programming/comments/a33i7n/making_c_enums_first_class_citizens/) [https://www.reddit.com/r/CIDLib/comments/b7x1fs/new\_video\_on\_the\_speech\_recognition\_in\_cidlib/](https://www.reddit.com/r/CIDLib/comments/b7x1fs/new_video_on_the_speech_recognition_in_cidlib/) [https://www.reddit.com/r/cpp/comments/algqnc/creating\_an\_object\_request\_broker\_in\_c\_the\_text/](https://www.reddit.com/r/cpp/comments/algqnc/creating_an_object_request_broker_in_c_the_text/) [https://www.reddit.com/r/programming/comments/ac2o4m/creating\_a\_test\_framework/](https://www.reddit.com/r/programming/comments/ac2o4m/creating_a_test_framework/) [https://www.reddit.com/r/programming/comments/a5f2o1/creating\_an\_object\_oriented\_macro\_language\_with/](https://www.reddit.com/r/programming/comments/a5f2o1/creating_an_object_oriented_macro_language_with/) &amp;#x200B; And I've posted a number of videos about it as well: [https://www.youtube.com/channel/UCAxCoATHgFBvqZhxFRnZsfw/videos](https://www.youtube.com/channel/UCAxCoATHgFBvqZhxFRnZsfw/videos)
!remindme 23 days
Yes, but what is more common? Adding 10 elements to a 10 million long vector, or adding 10 elements to a 10000 long vector?
Think of something you wish existed. Code it up.
I will be messaging you on [**2019-07-15 14:50:19 UTC**](http://www.wolframalpha.com/input/?i=2019-07-15 14:50:19 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/cpp/comments/c3pkb7/what_to_do_after_learning_cpp_basics_and_simple/ersianp/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/cpp/comments/c3pkb7/what_to_do_after_learning_cpp_basics_and_simple/ersianp/]%0A%0ARemindMe! 23 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
If my object doesn't have a throwing move constructor(very common) and a throwing copy constructor(should be common once allocations are noexcept), push_back should be noexcept.
Oh. I think most of us thought you were being obstinate. Yeah, that‚Äôs the whole point of new allocators like this one...
There are alternatives, like having a separate allocator for non-throwing allocation. See [p0132](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0132r1.html) for a list.
As much as JS is a terrible language, 'use strict' seems to have panned out pretty well for them I'd love something like 'use not_insane' for c++ that ironed out various corner cases. Built-in types being initialised by default would be amazing
Check out boost::asio, maybe play with boost::spirit, those are fun libs to get your creative juices flowing.
I think i May have not been entirely clear. When C++ has gotten a new language feature which depends on some new name, a new keyword has always been required. How the language has resolved this over the years has been by making a new reserved keyword or allowing something to be contextually a keyword. The former will 100% break code while the latter causes compiler writers to pull out some hair, but the rules aren‚Äôt impossible. And I would support something like `#language=dialect` but you don‚Äôt need to convince me of it. The only problem with this directive is that it would affect an entire TU which would have very mixed results depending on the code the user is including. I‚Äôm perfectly fine with `inspect` as a contextual keyword, but that‚Äôs just my opinion.
You can also give them a custom deleter! If provided, it'll be called when the pointer goes out of scope (instead of just calling the destructor). That's pretty useful when working with C APIs that require you to have an init and a free method, since you don't have to worry about calling the free method manually.
Yeah I think everyone else assumes you're challenging rather than curious. I don't know why they're assuming that though, as your question is worded in a fairly clear way in my opinion.
Already proposed and killed
Was it under the rationale of not wanting to create sub dialects of c++ again?
&gt; honestly hope the TS &gt; &gt;never &gt; &gt; makes it to the IS in its current form I honestly wish you would refrain from commenting in areas where you lack expertise
Is there some problem here because i don't see anything wrong with that output.
I could measure a major performance boost in favor of Windows 10, compared to Windows 7, for both heavy multi-threading and single threading contexts.
Here a recent serious contender from Microsoft (MIT): https://github.com/microsoft/snmalloc
It doesn't say that's the only reason.
!remindme 22 days
OP's point is that the output is different whether you use the `const char*` or the `std::string`.
Is there any test suite for the standard features? I could try running it on my Mac...
I would love solutions that doesn't increase compilation times even more.
There are no problems with the code, no compilation errors, no warnings, no UB, it's all perfectly legal. It works according to the documentation. And when you switch lines 9 and 10 it still works according to the documentation. &amp;#x200B; The thing is, the results of that tiny change will probably surprise you (and possibly weeks or months later if your test coverage is not 100%).
Someone in [the HN discussion](https://news.ycombinator.com/item?id=20249743) pointed out that the [research paper this is based on](https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action/) presents it as targeting being a good back-end for reference counted scripting languages.
Yep.
&gt; C++ is a language for defining and using light-weight abstractions I feel like I want "zero cost" abstractions. If I didn't care about zero cost, I wouldn't us C++ and a lot of the existing friction is due to features that exist today that have too high of an abstraction penalty, resulting in fragmented usage and confusing communication on best practices. &gt; Improve support for high-level concurrency models No. I do not want this. &gt; This is a variant of the ‚ÄúDon‚Äôt leave room for a language below C++ (except assembler)‚Äù rule of thumb from D&amp;E. Where we depart from this principle, we get long-term problems because the semantics easily drifts apart from the rest of the language. Completely agreed. This seems to contradict other parts of the document... &gt; C++ teaching is mostly stuck in a pre-graphics, pre-web world. This is a serious weakness, potentially fatal over the long term OK well so is nodejs and python but you don't see beginners complaining. They do `npm install X` or `pip install X` and go. What is the deal? Why do beginners need to learn the intricacies of cmake and manage external dependencies in git? Why is it so hard to realize that completely divorcing the language design from ISO-standardized tools is a huge problem? Things like high-level concurrency models, graphics, etc should be a single command and import statement away. I feel the committee on the education problem. I've been helping a friend learn C++ and literally one of the first things I had to teach was installing cmake and linking the modern cmake tutorial. That. is. *bonkers*. Adding *non-zero* cost abstractions to just delay the inevitable cliff isn't sustainable or in the student's best interests.
no u
Same here, if there's a test suite I'm happy to run it. Anecdotally, I'm 90% sure that Xcode 10 is exactly Clang 7.0 but with stuff missing from the standard library, most notable `std::filesystem`.
On one side I am amazed from innovation on the other I am bit worried cause it is increasigly difficult to track all the news. Information is spread on many blogs and videos but books are lagging behind. Maybe I am old... But I miss authoritative big books...
I concur. In the context of teaching, C++ is not usually taught because it is pedagogic or because it is going to land students a job. Instead, if it is taught at all, it is because it can be used to seamlessly transition from C into other paradigms. Or maybe as the language of choice for a computer graphics course. Even then, many institutions simply teach C and other languages; and some degrees out there do not even approach any usual/common low-level language.
I also agree with the list, but for the toolchain, I am not sure. You can go very far with a single TU, use an IDE or have a simple Makefile that students copy-paste into their projects (not that different from config files of other languages).
Right, step 1: change the mindset.
How is the second version different from an ordinary range-based for loop?
Why wouldn't you *actually say this* in your post instead of downhere?
I disagree only because C++ is so reluctant (by the committee's own omission) to break compatibility. I mean, if we're willing to introduce breaking changes to get improvements incrementally, by all means. BUT, the committee wants it to be ossified essentially on day one which makes the value proposition of a poorly thought out library negative. As for strict rules about third party dependencies, I view this as a problem with the environment. If you struggle with NIH syndrome, the language and committee shouldn't be working to accommodate you.
Why do you bother writing a comment like this (as opposed to something constructive that addresses the point mentioned). I'm not the OP but I think the OP makes a valid point. You understandably have a vested interest in the TS graduating which is fine, but maybe try and actually defend it instead of throwing shade and resorting to polemic.
Thank you. I'm aware of the site. But as of now the quiz is about C++17. I'm looking for something more generic. Something that's for C++11. But I suppose C++17 wouldn't be far off, but then I could really avoid questions that are specific and new to C++17.
Agree strongly. I say this regularly and get down-voted even worse because I'm practiced at attracting passive aggressive down-voters.
Yep. Sounds like an overwhelmingly moronic process. I'm sorry you're subjected to it!
IIUC for second version to work the size of container must be known at compile time, and loop just get unrolled.
I haven't followed this closely. Why is the TS based on features that are not even in C++ yet? Why wasn't a "simplified" ASIO taken for the standard? If ASIO was too complex to do "right", was there a reason why its scope was not reduced? For instance, standardizing types to represent IPv4/6 addresses, TCP/UDP sockets and network error codes should be general enough that can be used later on for the ASIO-like proposal (and ASIO and other libraries can start supporting those types right away along their own). Even adding the ability to perform synchronous operations on those types (blocking and perhaps non-blocking) should not conflict with the async part of the library (IO contexts, timers, etc.), no?
I think GP was referring to concepts as in the English meaning of the word, not C++ Concepts.
It would be great to have the latest MSVC Preview (even a Nightly!), in the Compiler Explorer. Sometimes I want to test some feature in MSVC and either I don't have time to install a Preview or I don't have a Windows box at hand... For new languages features, doubly useful!