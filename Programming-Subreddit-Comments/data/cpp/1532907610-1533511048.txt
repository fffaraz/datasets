So I'll admit my gut reaction to that proposal was a hard no, but I read through the whole proposal and I now wouldn't really be opposed to it, because it also proposes a way to explicitly state how the programmer wants to handle heap exhaustion, and (if I understand 4.3.3's proposed "try to allocate" functions correctly) to express clearly what parts of our code does and does not want to handle it. The portion of that proposal I probably agree most with is in 3.2: &gt;We must remove all technical reasons for a C++ project to disable exception handling (e.g., by compiler switch) or ban use of exceptions, in all or part of their project So that we can move closer to having fewer project- or company-specific C++ dialects and simply use the standard libraries as they are, and as they were *intended* to be used. The mess that has become C++'s error handling system(s) is a critique I often hear, and one I am more than willing to critique myself, and I would welcome many of the changes proposed in that paper.
oh i agree. its good advice too
Lots of great suggestions in this thread. Personally, I'd like to see a better tool for reporting issues (which is kinda sad, I know). What is currently in there, is a step in the right direction, but it's still far from what I'd like to have. The UI for reporting bugs from within VS and the developer community web page are unbelievably clunky and the text editing experience is terrible. It's very difficult to sensibly format the text and my success rate, when trying to apply code formatting to a paragraph (in such a way that the end result is at least readable, forgetting about making it look good), is well below 50%. That aside, my main gripe is with how difficult and laborious it often is to produce a meaningful repro for issues that pop up in real-world projects. I tend to work with medium to big code bases and whenever I hit bug in VS, preparing a cut-down solution that I can actually attach to the report usually becomes a prolonged (and rather frustrating) exercise. It's not too bad, if it's a mere compiler error (an ICE, bad codegen, etc.), since that often boils down to generating a pre-processed source file and then trying to cut it down. It's usually much worse (at least for me), when I run into a bug in the VS itself or its project system (msbuild), because it usually takes some serious effort to reduce the solution to something that still triggers the issue and can be given to someone outside my company. Just this week I hit such a bug -- in something that is supposed to require a trivial one-time setup and after that it's simply choosing a menu option -- I've already spent three days testing and cutting down the solution, trying to get a simple enough repro, but come Monday morning, I'm going to shelve it, because it's simply not worth the time and it's not worth the effort. And that is exactly what my manager usually tells me to do in such situations: in case of compiler bugs, just rewrite the code to avoid triggering the bug, and in case of VS/project issues, just drop the functionality/feature altogether and move on, rather than spending time on reporting the bug to MS, since it takes way too long and I'm not paid for doing QA for VS. I have no idea what is the right solution here -- I appreciate that this is a difficult problem to solve, so I'm not getting my hopes up. Of course, the best option would be to avoid those bugs in the first place, but I've pretty much given up on that....
Diverging, but also converging occasionally. Both committees are open to pulling in features from the other language to maintain some level of compatibility.
Or you could use C++.
Unless you actually want to work with the characters e.g. based on their Unicode category. Or unless you want to interoperate with something that uses another encoding (like Windows).
Feedback - a random mix of subjective and objective. I've done this before, so I have both experience and strong opinions. *** (thoughts from readme) Using `_w` as a suffix for "initialization from a pointer" is unintuitive, given that `wchar_t` exists in the standard. And then it appears as a suffix on random other functions. `rs_cpy`, `rs_cat`, etc. do not use a suffix where `rs_init` does. Your `printf`s need to use `%zu` for `size_t` arguments. *** (thoughts from declarations) Defining a subset of `RS_MALLOC` etc. isn't handled even though it is, in fact, meaningful. Doesn't allow using alternate allocators that require you to specify the size for realloc and free. `RS_EXPECT` etc. aren't protecting their macro arguments. Your `inline` stuff is weird. I wrote up [a list of inline modes](https://stackoverflow.com/a/51229603/1405588) recently. Is it really worth storing the size and capacity in the struct itself, or are you just doing that to increase the SSO limit (but see below)? Maybe the size is common, but capacity is rarely interesting (and, with some API change, could be implicit for a given API) `PRE_HEAP_ALIGN_SZ` could be written as a single `sizeof` or `offsetof`, given an appropriate struct. Ow my debuginfo, that's a lot of `enum`s. You do know about `const` globals and `-g3` macros, right? `RS_DATA_SIZE` is weirdly and unnecessarily callback-based. One of the first things I did when implementing my own string lib was ad a `struct PointerLengthPair { char *data; size_t size; }` to pass internals around. Various typos in comments. Why does setting the capacity always allocate, even if the requested capacity is small? `rs_shrink_to_fit` ~~probably should at least *try* to allocate.~~ does allocate; the comments are lying. But it should fall back gracefully if it fails. `rs_steal` doesn't specify what happens to the existing contents of the string, nor what the new size is. `rs_erase` should mention `rs_shrink_to_fit` `rs_clear` should specify whether a heap string is `free`d and turned into a stack string. *** (thoughts from definitions) Could include the `likely` logic in the `rs_is_heap` itself so the callers don't have to. Contrary to comments, you cannot check for allocation errors using `errno`, since many functions unconditionally copy into the possibly-NULL pointer. Should allow controlling rapidstring's `assert`s separately from the rest of the program. `rs_data` casts away `const`ness; this means any mutation is UB. Doing it the other way would fix this, since then the function taking a non-const doesn't actually do any changes (and then it's readded for the return). You often end up doing allocations with weird sizes. Though given how much allocators vary, there is no single optimal solution. Ugh. Many comment lines aren't wrapped, breaking display everywhere. 76 characters, please! People generally expect the `clear` operation to leave the string in a state indistinguishable from the initial state. Preserving the capacity violates that. Missing an `insert` operation to undo an `erase` that's not at the end. *** (thoughts from experience) Using a single string type will always lose compared to using multiple string types with the same API. But admittedly that's hard in C ... unless you use `_Generic` I guess. I haven't written much C since that became a thing. (there are various compiler builtins to fall back from `_Generic` safely, with a last resort of unchecked casting after checking size of some member - remember that all mainstream compilers support 0-sized arrays, for example) For reference, my (C++) string types were: * MString: the only mutable string, and even then only allowing changes at the end. It turned out that nobody needed anything more (and even mutation at the end was mostly limited to "remove `, ` from a list you're building), but if I *did*, I would write a rope class. Not contiguous (uses a linked-list of maybe-512-byte buffers), so must be explicitly converted, likely to `AString` or `RString`, to use common API functions. * FString: a special kind of string literal for `printf`, `scanf`, etc. strings. Takes care to keep the compiler informed so that `-Werror=format-nonliteral` works. If I'd ever gotten around to using `gettext` this probably would've included the result of that too, assuming the input was one. Does not support common string APIs, but does support creation of `AStrings` by passing arguments to its `printf` wrapper. Much magic involved here. * `LString`: wrapper for string literals, since they never require ownership. * `ZString`: wrapper for a NUL-terminated `const char *`. Used extensively as a function arguments, since sometimes it's necessary to call functions that expect a C string, but became less popular over time. * `XString`: wrapper for `const char *, size_t` pairs that are *not* (directly) NUL-terminated - although I did guarantee that there is a a NUL terminator out there *somewhere* - although I think the only thing that mattered is "yes, you can in fact dereference the `end()` iterator". Used as the return type for most slicing operations (and there were a lot of those). Used extensively in function arguments. * `VString&lt;n&gt;` - wrapper for fixed-sized `char [n]` buffers. Note that they *still* never needed to. Eventually became unpopular, since silent truncation sucks. * `RString` - a refcounted string. Used extensively for long-lived strings, since SSO with a size over 7 are often a loss - and that would only be possible on big-endian systems anyway. Had an optimization to avoid allocation for `LString`. Note that, since nobody turned out to need mutation, the main argument against refcounting barely applies (and atomics are pretty fast, although my program was single-threaded so I never bothered). * `TString`, `SString` - owned slices of an `RString`, with/without a terminator. Turned out to be never popular; eventually I added a "get `RString` owner, if any" to `ZString`/`XString` for the few cases where it mattered. * `AString` - an SSO with a stack capacity of 255, falling back to `RString` as-is. Ensures the `LString` optimization is used even if SSO would apply. Used extensively for locals and return values, including the return of `printf` wrapper. Note that these were introduced during a refactoring, and written more for correctness/safety/ease-of-use than speed. But the speed certainly never was a problem. Doing it in C, the lack of implicit conversions to XString would certainly hurt. Though I suppose it wouldn't be *too* terrible to have everyone writing new functions write something like: void use_strings(XString a, XString b); #define use_strings(a, b) use_strings(to_xstring(a), to_xstring(b)) since `_Generic` or its fallbacks can make it easy to provide that `to_xstring`.
FWIW, what I did for my `AString` was something like: class AString { char buf[256]; RString *get_heap() { if (this-&gt;buf[255] != 255) return NULL; return reinterpret_cast&lt;RString *&gt;(&amp;this-&gt;buf[0]); } };
MSVC and Clang support it directly. GCC can sorta emulate it with __builtin_unreachable.
Converting a single codepoint as-needed is always a win even in that case. Though most unicode libraries seriously suck ... I'm working on a library to fix that, vaguely inspired by tzdata (in that you can just drop in a new data file every year and your old code will automatically know about new characters, rather than having to update a library)
Fastest at what? strings are all about tradeoffs.
*crickets*
Not to mention that the system may easily do something like invoking the OOMkiller, and (for example) summarily destroy your process, without ever telling it that an attempted allocation is failing. Or it might return a pointer as if it had succeeded, but when you attempt to use the memory, that can fail...
Yeah because `substr` is so handy on utf8 strings. /s
Looking at the C standard draft [here](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf), at page 101 (83 in the file), footnote 95, I read &gt;If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called ‘‘type punning’’). This might be a trap representation. The last phrase makes me think that this is also undefined behavior in C as well, but I wish the standard was more clear on this point.
Er, explain?
Taking e.g. 3 characters starting from 5th character is quite tricky when your string is a utf8 byte sequence. 
Why the hell would you ever hardcode magic numbers in your source code?
I don't use VS (to edit) anymore due to the number of bugs I keep encountering with each update. I have moved on to VSCode which "just works - kind of". I am using clang-format 6.0.0, I have I have overridden the default clang binary for VS2017, but no luck. When I format on the command line, or from within VSCode, clang-format doesn't not trim trailing white space, VSCode does (through an option in my user config). In addition, VS2017's clang integration doesn't really work so well. I have told it to auto format upon semicolon, close brace, and tab, yet it doesn't seem to actually format anything unless I tell it to. Frustrating.
The text you quoted is perfectly clear, and was inserted precisely to clarify that union aliasing is permitted. Not sure how you think there is UB, it literally says that the representation is reinterpreted. The last sentence is noting that the result of reinterpretation could be a trap representation (which may lead to UB), but that's a different matter to the union aliasing being undefined. 
You seem to be missing the point. 
Neither `char32_t` nor `wchar_t` will help you there.
jsoncons was started in 2014. At the time, jsoncpp and RapidJson were the main inhabitants of this space, and I studied them very carefully. I'm less familiar with nlohmann, which came a year later, but will try. jsoncons and nlohmann both look more like jsoncpp than RapidJson, for example, for jsoncpp, jsoncons and nlohmann, json j1(100); json j2(200); j2 = j1; // j1 is copied to j2 whereas currently for RapidJson Value j1(100); Value j2(200); j2 = j1; // j1 is moved to j2 (j1 becomes a null) rapidjson, jsoncons and nlohmann all score highly on parsing correctness and round trip. I think it's fair to say that RapidJson's author Milo Yip can be credited with single handedly raising the quality of both jsoncons and nlohmann, by publishing benchmarks for json parsing and serializing, and contacting the authors of these and other projects about their shortcomings. rapidjson is faster than jsoncons and nlohmann, especially when processing floating point numbers. All of the really fast json parers I know have two things: one, default allocators. And two, a complete replacement of the C++ floating point conversion functions following ACM papers (RapidJson), or not following ACM papers but attempting naive floating conversion that doesn't always work (sajson, pjson, gayson.) Both jsoncons and nlohmann support user supplied allocators, defaulting to std::allocator&lt;char&gt;. Both jsoncons and nlohmann currently, use the standard library functions strtod and sprintf for floating point conversions, and fix up unwanted locale side effects and truncation of zero after the decimal point. I'd expect both jsoncons and nlohmann to move to std::from_chars and dtd::to_chars when these C++17 functions become broadly supported. Both jsoncons and nlohmann support json variant-like types with syntax like json j; j["A"]["B"] = 9; Both support iterators over json arrays and objects. Both support conversion of C++ types to json using traits, but they do it a bit differently. jsoncons allows users to specialize template &lt;class Json, class T, class Enable=void&gt; struct json_type_traits { static bool is(const Json&amp;); static T as(const Json&amp; rhs); static Json to_json(T val); }; within the jsoncons namespace. nlohmann allows users to implement inline functions void to_json(json&amp; j, const T&amp; p) void from_json(const json&amp; j, T&amp; p) in the type T's namespace, found by Koenig lookup. Both have built in support for conversion of the standard library sequence and associative containers, and other standard library types. Both support something like T x = j.as&lt;T&gt;(); // jsoncons T x = j.get&lt;T&gt;(); // nlohmann, or T x = j; // Implicit conversion in nlohmann, not supported by jsoncons I believe get&lt;T&gt; in nlohmann doesn't attempt to coerce different types, i.e. attempt to convert a string into a double, while jsoncons will attempt these conversions. jsoncons supports j.is&lt;T&gt; to check if j is stringently of that type. jsoncons and nlohmann have different approaches, but it's often possible to do the same thing in each. For example, both support JSON Pointer, but nlohmann integrates it with the variant, in nlohmann it is possible to write j[["/baz/1"_json_pointer]; while in jsoncons JSON Pointer is a separate extension, and jsonpointer::get is defined on any type J that supports a specified set of operations. jsoncons supports querying a view on CBOR bytes with jsonpointer::get, while nlohmann supports converting the CBOR bytes to the json variant and applying JSON Pointer there. In terms of features, jsoncons supports JsonPath and conversion to/from CSV files, which nlohmann does not, while nlohmann supports binary format UBJSON and JSON Merge Patch (didn't know about this!), which jsoncons does not. Both support JSON Patch, CBOR, and (in the case of jsoncons, to some extent) MessagePack. For CBOR, jsoncons supports byte strings and bignums, which nlohmann does not. jsoncons is built from the ground up on a streaming SAX-like API (as I understand is RapidJson), while nlohmann currently parses directly into the json variant-like structure, but it looks like nlohmann is also moving towards a streaming API. jsoncons currently offers more options for serializing JSON (as far as I can tell, nlohmann is largely limited to setting an indentation width), but it looks like they have a proposal for quite a nice set of serialization options. 
In c++ this would translate into a small_string&lt;N&gt; template
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/931kkv/where_to_go_from_here/e3a0fy8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It seems you've taken the introduction to programming course. It's safe to say you don't know c++. At this point of my life I tried to make games like Tetris or snake which is I think a nice way to learn the basics of programming. Feel free to choose any programming language, don't feel afraid of moving away from c++. At any point in your career you can learn a lot by learning new languages. Have fun! 
Just a short note: std::string::clear does not change the capacity either AFAIK. 
this is undevined behaviour in C++ if(and i assume this) RString is not a type alias for char/signed char/unsigned char/byte
Just the not-very-much-used ones :D Aside from big beasts like IDEs (which I wouldn't consider just 'text editors' anyway)
Anyone who is serious about unicode handling is not going to use the std provided one but rather something like http://utfcpp.sourceforge.net/
Btw, source code of Notepad++ is awful, don't try to learn anything from it.
Who keeps downvoting this? Can you geniuses not see the GP comment was edited and fixed after this comment was posted..?
**Company:** Copernica: [https://www.copernica.com/en/aboutus/jobs/cpp-developer](https://www.copernica.com/en/aboutus/jobs/cpp-developer) **Type:** Full time **Description:** At Copernica, we develop software for sending e-mails &amp; e-mailmarketing campaigns. As a senior C++ developer you play an important role within our fast growing R&amp;D team. On one hand you contribute to the development of the three products of Copernica and on the other hand you have an important task in guiding junior colleagues. Because we consider the quality of our code as highly important, we pay a lot of attention to the review process. As a mediorsenior you are expected to be able to critically assess, both your own code, and that of colleagues, and then give recommendations on how to improve it. **Location:** Amsterdam, the Netherlands **Remote:** No **Visa Sponsorship:** No **Technologies:** We use C++11 on Linux (Ubuntu()mainly. Additional experience PHP and Javascript will be beneficial: **Contact:** if you are interested, just let us know through: jobs@copernica.com
Would still be a bad idea: Just introducing unnecessary complexity for little gain. wchar/char16_t ... need to die as quickly as possible as general character format (they have of course value when interfacing with Windows API or for certain algorithms).
Most ABIs reserve special memory for exceptions, so the creation of the bad_alloc object will not fail and I've seen very, very few destructors that directly or indirectly allocate memory (Higher level objects often do logging though). Let me ask you a question: How many systems do you know that actually recover from **any** exception? The cases I know of usually recover from an exception by nuking an entire subsystem (i.e. letting the stack unwind to a very high level application logic) and restart it. All of those cases can also recover from bad_alloc in the same way.
AIUI, 2 is the pessimal value for RS_GROWTH_FACTOR. See fir example https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#memory-handling
Or maybe you are missing the point: You almost never want to split your string "at the 5th character". You e.g. want to split it at a delimiter or where the user told you to. In both cases, the function that determines the split position already knows the according position in the string object.
&gt;For example, there is a macro RS\_AVERAGE\_SIZE which should be redefined to the average size of a string within a project. How about just using the method `reserve` and setting it to `RS_AVERAGE_SIZE` or maybe even to double that. What happens to the benchmark results when you do that?
Indeed, the C++ rules for accessing `union` members are stricter than in C. However, C++ has SSO (short string optimization) where the content of the string is stored inside the object if the string is short enough. Internally this is done using a `union`, so this seems to be similar to the approach of the `rapidstring` library. So it looks like the stricter rules of C++ for accessing `union` members are not to blame for the slower benchmark results.
GCC (and hence clang) allow type punning through unions even with that flag turned on. It's an explicitly documented feature: https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-849 
SSO doesn't use union aliasing though; it either stores the SS or it stores a normal string. BTW nobody was claiming that union aliasing was related to the benchmark times.
don't all modern standard implementations feature small string optimization nowadays? I'm probably misunderstanding the problem...
you can't use pointer arithmetic, but it's still simple &amp; linear (just skip `char` starting with `10`, no complicated algorithm).
&gt;VS2017's clang integration doesn't really work so well. Yes totally agree with that, it messes up your text while you're typing too, if you type very quickly it sometimes just jumps around the cursor or deletes some code - and the copy&amp;paste behavior is very bad as well, it pastes wrong content sometimes and auto-formats when it shouldn't (and when auto-format on paste is disabled) (so in essence the opposite of your problem :D). The editing experience has definitely gotten a lot worse for me since they integrated clang-format. (The "old" clang-format plugin works great though!) But overall I'm still quite happy with VS, it's the best editor/IDE/debugging experience overall, nothing still comes close to it in my opinion.
I totally understand your initial reaction ;) But I think that with what is proposed, it will be better for both world. The ones who don't care about heap exhaustion will not have to pay the price of `bad_alloc`. And the ones who cares will have a reliable way to test for heap exhaustion, and to handle it (since currently you can't reliably throw an exception since exception does heap allocation).
UI delay has gotten a lot worse for me since you integrated clang-format support. I see the "clang-format is formatting your document..." popup regularly and it often stays for like 2 seconds. For example when you copy some text to the clipboard and then CTRL+left-click a variable or define in the code and paste, this dialog shows and stays for 2 seconds, even though I don't want it to format anything and I've got formatting on paste disabled in the options. And when you have to replace 3-4 variables it gets even worse, you click=&gt;paste the first one, 2 sec wait for the dialog, click=&gt;paste the second one, 2 sec wait, etc... an operation that used to take 1 second now takes 10 seconds because I have to wait for the clang-format dialog each time.
I got this as well - 95% of the time this is quick, but then suddenly one day you change configuration and it goes "Not responding" for 30 seconds.
\&gt; The C++ front end has experimental support for some of the upcoming C++2a draft features with the -std=c++2a or -std=gnu++2a flags, including designated initializers, default member initializers for bit-fields, \_\_VA\_OPT\_\_ (except that #\_\_VA\_OPT\_\_ is unsupported), lambda \[=, this\] captures, etc. For a full list of new features, see the C++ status page. Good to know.
Just because you can’t think of an use case does not mean there is none. For example, if you are rendering text to a text-based user interface and there is a fixed number of columns of room where to print.
I prefer std::stoX family of functions. In the rare case where I will need to run string conversions on the critical processing path, I will consider something else. Otherwise required for some reason: not on the critical path, so doesn't matter what you use.
There’s an easy fix. Uninstall dev c++, download visual studio developer edition, and continue. Dev C++ is very old and outdated.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Thanks for these suggestions, a lot of them are very helpful! However, there are a few points I would like to address. &gt;Using _w as a suffix for "initialization from a pointer" is unintuitive I actually intended this to mean "with". You initialize a string *with* some characters, you resize a string *with* a filler character. I should probably specify this in the docs. &gt;rs_cpy, rs_cat, etc. do not use a suffix where rs_init does. You shouldn't be copying an empty string, but you can definitely initialize to an empty string, which is why the copying/concat functions don't have the "with" suffix as it's implied you need to provide *something*. &gt;Defining a subset of RS_MALLOC etc. isn't handled even though it is, in fact, meaningful. I am not sure I understand what you mean. It is currently possible to redefine the allocation macros. &gt;PRE_HEAP_ALIGN_SZ could be written as a single sizeof or offsetof, given an appropriate struct. The appropriate struct would be `rs_heap`, which cannot be used as this macro is needed **to create `rs_heap`**. It's a Catch-22 situation. To get around this I manually calculate the size of the initial part of the `rs_heap` struct. &gt;RS_DATA_SIZE is weirdly and unnecessarily callback-based. One of the first things I did when implementing my own string lib was ad a struct PointerLengthPair { char *data; size_t size; } to pass internals around. I originally did it this way, but I wasn't able to figure out how to do it without a small performance penalty. Each time I tried to abstract this away with some non-macro solution, there was always a few more assembly instructions with marginally slower benchmarks. &gt;Could include the likely logic in the rs_is_heap itself so the callers don't have to. This actually cannot be done as some functions expect the string to *always* be likely to be on the heap, even if the average string size is small. For example, if a user calls `rs_shrink_to_fit()`, they are usually calling this on a heap string, which is why `RS_LIKELY()` is used rather than `RS_HEAP_LIKELY()`. If I returned the heap likeliness inside `rs_is_heap()`, there would be a double `__builtin_expect()` for a few if statements, and I don't know if that would work. &gt;Why does setting the capacity always allocate, even if the requested capacity is small? I want to favor the average use case. Most people won't construct a string with a capacity unless it is a somewhat substantial size, just as how nobody `reserve()`'s 8 bytes of capacity. I would rather have the common use case be marginally faster than to speed up the uncommon use case. &gt;rs_shrink_to_fit does allocate; the comments are lying. In theory it is allocating, but what `realloc()` implementation will `free()` the entire buffer and `malloc()` the new buffer with a decreased size? It's like if I specified that `rs_free()` always allocates, it seems strange. &gt;Contrary to comments, you cannot check for allocation errors using errno, since many functions unconditionally copy into the possibly-NULL pointer. That's why the documentation didn't say all functions, only functions `that either intializes or grows the heap buffer`. &gt;Ow my debuginfo, that's a lot of enums. You do know about const globals and -g3 macros, right? There are only two enums. I don't see anything wrong with using them and they are just as valid as const globals.
There is a fixed number of columns of characters. And each character can be composed from multiple code points so you still can't just substr(numColumns) even with char32_t
std::string are inherently expensive because all the crap they do (CoW, locale, ...). This is basically why we have string_view which is basically struct&lt;size_t size; char *str&gt;; and gets rid of most CoW related stuff when dealing with substrings and such (it still cares about locale unfortunately).
There are no string implementations with copy-on-write semantics by any standard-conforming compiler. GCC got rid of it several years ago, and as far as I know current compilers conform do not have copy-on-write strings.
Looks promising, but honestly from modern C++ point of view C APIs are horrible. That would require another library to make everything RAII, add constructors, move semantics, function overloading and other stuff.
Been using the 4.7 beta and rc for a while now, having the clang diagnostics tool is not something I knew I missed but that I could never come back from. Awesome stuff!
&gt; Most people won't construct a string with a capacity unless it is a somewhat substantial size, just as how nobody `reserve()`'s 8 bytes of capacity. You've completely lost me here – if the size of one's data is known at runtime, who wouldn't specify that size to avoid allocations? Are you suggesting there's some actual codebase that constructs its strings two different ways predicated on some magic threshold rather than just always passing the size in..?
In which case you would use `rs_init_w_n()` rather than `rs_init_w_cap()`. If you have a character array and you know the size, of course you use that to your advantage. This is different from initializing a string with a specific capacity. I would assume the typical use case would be initializing the capacity before a loop of concatenations, of which I would assume the string would typically end up larger than 16 characters.
&gt; In which case you would use rs_init_w_n() rather than rs_init_w_cap(). That's making strong assumptions about everyone elses' usecases... What if I'm using the string as a buffer, e.g. for a deserialization protocol? Having an SSO-oriented data structure not use SSO isn't something that makes any sense to me.
Maybe ... the asymmetry of the aliasing rules is confusing. Since `char[]` has *no* declared type as far as aliasing is concerned, isn't it legal after a `new (this-&gt;buf) RString(...)`?
Ugh, stupid meaningless differences from `std::vector`.
- /r/cpp_questions - https://www.boost.org/libs/multiprecision/ 
`std::numeric_limits&lt;double&gt;::infinity()`?
For extra fun, consider characters like `ﷺ` , `ﷻ`, and `﷽` that can't really be written in only 2 columns (and even some of the smaller ligatures have problems). I'm not aware of any column-based rendering system which correctly handles them. 
Yes, if there's an actual `RString` constructed in that buffer then it's fine (though `buf` is likely misaligned here if this is the case).
I was wondering for the same thing.
I co-authored one in college almost 20 years ago: https://github.com/bcardarella/Infinite-Number I can't tell you if it still works or not in current C++ but the basic idea is that each digit was a node in a linked list. Then each digit was an absurdly high base value. The calculations were done with bit shifting to achieve something very fast. We published a paper on this: https://dl.acm.org/citation.cfm?id=378763&amp;dl=ACM&amp;coll=DL and I have been trying to get the ACM to correct my last name ever since "Cardarell**a**" not "Cardarell**o**" We never published it under a license but feel free to steal what you want if it is useful.
I want is 100% precision
actually the asymmetry is not confusing. you may only reinterpret to objects if they are really alive at the given position. with the only exception that you may access everything as a byte,char or unsigned char to make bytewise access possible. if there is an RString living in the given buffer (like with `new (this-&gt;buf) RString(...)`), you may access it without violating the strict aliasing rules. but in this case you must use `std::launder` in C++17, since you are obtaining the typed pointer from an address of a different type. see https://en.cppreference.com/w/cpp/utility/launder under Notes, second bullet point
&gt; if you consider IDEs In that case you should also consider Visual Studio which, until some time ago, was written in C++. IIRC, the newer versions are an almost complete rewrite in .NET though.
Quick question, if I use your code, what is the speed of 0xfffffffffffffff \* 0xfffffffffffffff ? (I don't have a lot of time in my hand right now because I am 15) Mine is 8430 nanoseconds (May be improve in the future by multiply in a new way) My CPU is Intel(R) Pentium(R) CPU G2010 @ 2.80GHz and my OS is Windows 10
\&gt; One of the reasons we do not have good developer tools is because we choose to not pay for them. I think this is bogus: paying for things makes them better, but things not being open source makes them harder to understand in detail, harder to fix, and therefore harder to use in practice. In a lot of cases this just isn't a win. I'm generally, personally, a lot more interested in supporting a for-pay project that's like "Hey here's my pet project developer tool, it is open source, I have hacked on it off-and-on for a while, it's not my full time job, please support me on patreon if you find it useful at work" Here's a relevant sound-byte from Chandler Carruth Meeting C++2015 keynote talk, explaining why, for instance, I would never choose to use a compiler that isn't open source, for any purpose, unless for engineering reasons there were no alternative in that situation. [https://www.youtube.com/watch?v=FnGCDLhaxKU&amp;t=1h42m20s](https://www.youtube.com/watch?v=FnGCDLhaxKU&amp;t=1h42m20s)
Fair enough, you make a strong case. I'll change it to conditionally allocate if the requested capacity is larger than the stack capacity.
or you could use _with instead, heh :)
This was 20 years ago, I have no idea
[removed]
&gt;All operations are done in terms of A &amp; B: A Function B. &gt; &gt;A = 1152921504606846975 &gt; &gt;B = 1152921504606846975 &gt; &gt;Answer = Empty List &gt; &gt;Please choose an option: \* &gt; &gt;operator\* tooks 441319 nanoseconds &gt; &gt;Answer = 1329227995784915870597964051066650625 &gt; &gt;Press any key to continue. Hey, at least its working, but sadly this 20 years code is not fast enough than my code, but hey, at least you helped me!
It's a C library; I'm pretty sure spelling out full words causes UB or something. ;-]
if I recall there was a memory leak that I didn't get around to fixing, that could be the culprit but with the smaller numbers here it may not be a factor
Yes, that is a really good start: find something that interests you, maybe first a small thing. We are happy to accept any patch :)
&gt;All operations are done in terms of A &amp; B: A Function B. &gt; &gt;A = 1 &gt; &gt;B = 1 &gt; &gt;Answer = Empty List &gt; &gt;Please choose an option: \* &gt; &gt;operator\* tooks 45819 nanoseconds &gt; &gt;Answer = 1 &gt; &gt;Press any key to continue. I think that's very not optimized code, even my code is not optimized at all, it took 29690 nanoseconds with 0xFFFFFFFFFFFFFFF\^2
As soon as you calculate 1 / 3, you'll get a repeating decimal and use up all your memory.
Yeah, but I said I don't want double/float like type so the result should be 1 / 3 = 0 1 % 3 = 1 etc...
You're looking for [arbitrary precision arithmetic](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic). The most common ones are [Boost Multiprecision](https://www.boost.org/libs/multiprecision/) or [GMP](https://gmplib.org/) and there's a longer list [on wikipedia](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software).
I think you've made your point!
Here is again, why this benchmark is useless - you are capturing the effect of memory allocation. Unless you completely isolate it, it's worthless. On a Pixelbook, under crouton, I've compiled your app like this: clang++ -O3 -std=c++17 -stdlib=libc++ StringViewTest.cpp Then ran it like this: time -p operf -g -l ./a.out nofile 10000000 The timings... are not that important, roughly 18 secs for std::string case (15 for the more optimal version), and roughly 10secs for std::string_view. Here is what's important: opreport -l -g Using /home/malkia/p/StringViewTests/oprofile_data/samples/ for samples directory. CPU: Intel Skylake microarchitecture, speed 3600 MHz (estimated) Counted cpu_clk_unhalted events () with a unit mask of 0x00 (Core cycles when at least one thread on the physical core is not in halt state) count 30000045 samples % linenr info image name symbol name 522 25.9186 (no location information) a.out splitStd(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) 346 17.1797 malloc.c:3086 libc-2.27.so free 332 16.4846 (no location information) a.out splitPtr(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) 183 9.0864 malloc.c:3028 libc-2.27.so malloc 169 8.3913 (no location information) a.out splitSV(std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;, std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;) 117 5.8093 malloc.c:3521 libc-2.27.so _int_malloc 111 5.5114 (no location information) libc++.so.1.0 /usr/lib/x86_64-linux-gnu/libc++.so.1.0 94 4.6673 (no location information) a.out splitSVStd(std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;, std::__1::basic_string_view&lt;char, std::__1::char_traits&lt;char&gt; &gt;) 77 3.8232 memmove-vec-unaligned-erms.S:217 libc-2.27.so __memmove_avx_unaligned_erms 41 2.0357 (no location information) a.out split(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) 14 0.6951 (no location information) no-vmlinux /no-vmlinux 8 0.3972 malloc.c:2760 libc-2.27.so systrim.isra.1.constprop.11 Now count what percentage of time i spent in malloc/free/int_malloc/etc. e.g. while this may be a valid benchmark test for a concrete system, under concrete situations (e.g. young heap), it's completely uses in the face of millions of already existing allocations, or completely different allocation scheme. If allocation/deallocation takes such signifcation amount of your benchmarking time, then you are not benchmarking the right thing. Sorry to be that harsh, but it's rather pointless. Apart from that, great find about find_first_of - I guess there maybe still point to it, but if you change your benchmark to almost completely avoid the c/c++'s library malloc/free - then it'll be even more convincing - and show much different results. One hint: maybe you can have a very simple allocator that just increments a global pointer to the next avail memory from a huge preallocated blob of memory... and never call free. 
Try out [MPFR](https://stackoverflow.com/questions/19688442/how-to-install-mpfr-and-gmp-for-c-on-visual-studio#38176221). It's a highly optimized library that can do integer or floating point operations to any desired precision. Testing the speed of 0xfffffffffffffff \* 0xfffffffffffffff is not a useful test because it's such a small test it will be very fast on any reasonable system. Try comparing the time to add two integers that each have 100 million digits, or try multiplying two numbers that each have 10000 digits.
This is quite cool, will take a look tonight when I get a chance! 
For reference, the same project in Qbs. It is worth noting that the Qt handling in Qbs is just a module written with normal Qbs constructs. import qbs CppApplication { name: "project" Depends: { name: "Qt"; submodules: ["core", "gui", "widgets"] } files: [ "project.qrc", "window.hpp", "profile.hpp" "main.cpp" ] }
r/cpp_questions
Oops, taking my question over there thank you!
&gt; One hint: maybe you can have a very simple allocator that just increments a global pointer to the next avail memory from a huge preallocated blob of memory... and never call free. https://howardhinnant.github.io/stack_alloc.html
So with the StackAllocator, as proposed by @dodheim - the results are quite different - https://gist.github.com/malkia/15bd4936d29c9a40f55b4959c048ee88 This shows how brittle benchmarking things is. It's one thing to benchmark a whole specific system - say a game on a game console, and another to benchmark indivdiual pieces/libraries/etc. I certainly am not also doing this right, and haven't been doing it right through my career, still learning. Just wanted to point it out. 
Increasing xmx to some value more than default 2Gb might help then. That's the -Xmx line in vmoptions. However, before doing that you might want first to enable memory indicator in: Settings/Preferences | Appearance &amp; Behavior | Appearance | Windows options | Show memory indicator and to see if you really come close to the limit. If not but you still have lags, dumps a CPU snapshot and report it to us: https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems
It's a common myth that 2 is a terrible factor; but myths are myths. The truth is that the best factor will depend on (1) the current capacity and (2) the memory allocator that you are using. In particular, all modern allocators use slab allocation for small amounts of memory, in which case there is no re-use when going from one slab class to the other regardless of the growth factor. Instead of picking growth factors based on the moon, I wish there was a standard interface to *ask* the current allocator to give us the capacity of the "next bigger for exponential growth" chunk of memory; this way it'd be tailored to fit nicely.
&gt; The second improvement comes from JFT who also implemented the algorithms using pointers and not iterators. That also gave a lot of speed increase. `std::string_view::iterator` is already a pointer in libstdc++ ([demo](https://godbolt.org/g/6WhByS)), so there's literally no difference between the two: https://godbolt.org/g/rEZmCF I'd say slightly more investigation here is warranted before just saying "pointers are faster than iterators".
There is also another thing that just realized. Even if you make the allocator "dumb" (like the StackAllocator) - you'll now have the effect of the different L1/L2/L3 cache sizes, this combined with the tight loop of the benchmark could completely skew results. It's not that comparing these two are like comparing apples and oranges, but more like comparing oranges and peeled oranges (for lack of a worse analogy...) 
Awesome! Would you consider releasing an executable?
Neither `string::clear()` nor `vector::clear()` change `capacity()`. The only difference is vector defines it that way whereas for string it's not actually specified, but all impls do it that way because it avoids a ton of allocations when re-used (plus you have `shrink_to_fit()` if you need the memory back). 
There is also CLN, a reasonably handy C++ layer on top of GMP.
The "Try Online" and "Download" buttons look exactly like the fake download links on banner ads.
Quick-bench version of your benchmarks: - Clang: http://quick-bench.com/25UMMT3tyxbo_2pFLENM6AvZvbE - GCC: http://quick-bench.com/tw-k7md6ONYsZlVkkYDXkzqualk The results are considerably different than the output you got; I use Nonius over Google Benchmark though so I may have got usage of the latter wrong.
There's no way to get infinite precision except with symbolic calculations.
I thought simply globally overloading new/delete would catch it, but it's best effort really :) 
That's on the metashellnpage in case anyone's wondering.
Hey! Just a couple quick points; typically for these sorts of questions its encouraged to post in /r/cpp_questions, or maybe /r/learnprogramming Additionally, you can format your code so that it appears a little more readable by selecting in and clicking the "Code" button in the reddit comment editor. Usually, it also helps to dig in a little more on what "it didn't work" means. Did it read the number but the value was wrong? Did it crash? Did it fail to compile? You also leave out some key information by not showing what "levr" is here. Finally, to answer your question, appending an "l" to the format specificer here is telling scanf to read in a double instead of a float. You can read up more about the format specifiers and what they do here: https://en.cppreference.com/w/cpp/io/c/fscanf (cppreference is a great place for learning!)
As usual with C++, I'd rather have portable behavior than implementation-defined. I.e., given that a growth factor of 2 means that no conjunction of previous allocations is sufficient for a new allocation, I'd rather have my C++ code handle this directly than _hope_ my allocator does for me behind the scenes.
It's worth mentioning that Boost.Multiprecision can use its own backend implementation, or it can wrap GMP or libtommath; I've not used CLN, but I'd never use GMP directly from C++.. ugh.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9368g1/got_code_to_work_but_not_sure_why/e3axqfo/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/936igq/programming_books_or_sites_for_non_native_english/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
MSVC &gt;If a union of two types is declared and one value is stored, but the union is accessed with the other type, the results are unreliable. [https://docs.microsoft.com/en-us/cpp/c-language/improper-access-to-a-union](https://docs.microsoft.com/en-us/cpp/c-language/improper-access-to-a-union)
There is a Windows installer in the releases page. [https://github.com/RangelReale/msgui/releases](https://github.com/RangelReale/msgui/releases)
FYI, you're shadowbanned. You'll need to talk to the reddit admins (subreddit mods can't do anything, except notice shadowbans).
Yes, this is more appropriate for cpp_questions; as this thread has gotten a number of useful replies, I am removing it now.
You probably got better answers than I could provide, but just for completeness: I'm not saying don't use them or that they are generally wrong, l'm saying you should not trust them. Don't trust that results from one particular system apply to a different system/toolchain. Don't trust that your data structure/algorithm show the same behavior on your production code as in your microbenchmarks, don't trust the statistical significance of the test data and don't trust that you actually measured what you wanted to measure. Just as with other pieces of information from unreliable sources, you can use them as a starting point, but you should have a very critical look at how they were obtained and you should try to validate them from other sources. You have to verify all those things before you rely on the results (e.g. by running a macro benchmark, using different toolchains, cross-check if the sizes/types used in the benchmark are actually representative for the ones in your real application. Refactor your benchmark a bit, have a look at the assembly and most importantly: use a profiler).
``` D:\buildrapid&gt;benchmark\rapidstring_benchmark.exe 07/30/18 12:28:55 Running benchmark\rapidstring_benchmark.exe Run on (12 X 2904 MHz CPU s) CPU Caches: L1 Data 32K (x6) L1 Instruction 32K (x6) L2 Unified 262K (x6) L3 Unified 12582K (x1) ------------------------------------------------------------- Benchmark Time CPU Iterations ------------------------------------------------------------- rs_cat 1016 ns 1025 ns 746667 std_concat 1389 ns 1381 ns 497778 rs_reserve_concat 484 ns 476 ns 1445161 std_reserve_concat 562 ns 563 ns 1000000 rs_12_byte_construct 1 ns 1 ns 746666667 std_12_byte_construct 8 ns 8 ns 89600000 rs_24_byte_construct 45 ns 45 ns 14933333 std_24_byte_construct 55 ns 56 ns 11200000 rs_48_byte_construct 51 ns 52 ns 10000000 std_48_byte_construct 58 ns 58 ns 10000000 rs_resize 54 ns 55 ns 10000000 std_resize 79 ns 80 ns 11200000 ``` Not sure why cat and reserve are so different. We do have some extra logic that does rounding in allocate, and extra branches to highly align large (&gt; 4k) buffers that probably are impacted here. I do observe that std::string is attempting to prevent overflow of difference_type so that any iterator subtraction is defined, which rapidstring is not doing. I suspect some of the other differences are because people were calling basic_string's dtor multiple times on the same basic_string, so I wasn't able to remove branches in its destructor for conditions that are likely impossible in conforming code. e.g. the 12 byte construct benchmark that doesn't touch the heap taking 1ns is suspect; I suspect the compiler used the benchmark loop to defeat the benchmark. Resize appears to be different because it looks like rs_resize isn't correctly zeroing out the resized region, it leaves the string filled with garbage. Some form of uninitialized_resize is probably an API that would be nice but isn't a thing basic_string currently allows.
Only for clang &gt;6.0 https://bugs.llvm.org//show_bug.cgi?id=31928
r/cpp_questions
May not be a popular opinion, but if you don't understand pointer semantics, you probably shouldn't be trying to get a C or C++ job.
On the one hand I agree, on the other I'm wondering if those things are representative of the at in Amazon. If they represent a list of x,y pairs as a pointer to pointers that sound whoefully inefficient (unless there where some specific requirements the OP didn't mention).
Are you aware of the Xi editor? https://github.com/google/xi-editor
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/937itk/using_an_int_pointer_to_a_pointer_to_present_an/e3b92ok/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
well i've been in a c++ predominate job for a few years now. Though I don't think i've ever once seen someone represent a list of pairs of ints as a pointer to pointer. looking around now, I forgot that you could just go at it like allLocations\[x\]\[y\].
Sure, but you should still be familiar enough with pointer semantics to be aware that in C and C++, you can index pointers. Heck, you could also do `y[allLocations[x]]`, or `y[x[allLocations]]`. Please don't.
So, can y'all finally implement `__builtin_assume`? `if (!c) __builtin_unreachable();` is _not_ the same thing exactly, and both Clang and MSVC have it.
Company: [Real-Time Innovations](https://www.rti.com/company/careers.html) (RTI) Type: Software Support Engineer - Full time Description: Simply put, RTI connects smarts to distributed systems. We seek to transform entire industries. Our hottest markets are today’s most exciting: autonomous cars, smart medical systems, green energy, unmanned planes. Our software smartly runs the largest power plants on the continent, connects perception to control in vehicles, drives the new generation of medical robotics, controls hyperloop and flying cars, and provides 24x7 medical intelligence to hospital patients and emergency victims. We are making the world greener, safer, faster, and flat-out cooler. Unabashedly, we are the best in the world at what we do. We are the best positioned small company to capitalize on the very real future of intelligent, distributed systems. As a software engineer in the Support team you will be triaging, debugging, and also writing code (bug fixes, customer use case implementations, example code, etc.). Some of the tasks that may be part of your day are: * Investigate, understand and debug customer issues. Work closely with our development and platform teams to find the root cause of these issues. * Find timely creative solutions to customer problems. This includes bug fixing and writing test cases based upon the customer use case. * Create, test and ship engineering builds, and patch releases. * Write best practices and solutions for our knowledge base. * Provide support status to the support manager and overall R&amp;D team. * Ensure our customers succeed with RTI technology. * Provide feedback to the development team to help improve our products. Location: Sunnyvale, CA or Granada, Spain Remote: No Visa Sponsorship: Yes Technologies: C, C++, or Java Contact: Apply [here](https://boards.greenhouse.io/rti/jobs/1247799), then email nicoleho@rti.com
Interesting, did you consider making it a qt creator plugin instead of another ide?
Will there at some point be a good way to describe the *semantics* of a function/class in addition to the implementation, so it could decide to elide allocations/other side effects if they aren't necessary to fulfill the semantic requirement?
I never used Qt Creator, I use the MSVC IDE as I really like its debugger, so no.
Or done only in C++. Heck, there's a plethora of ways to effectively use C++ as an on-the-fly scripting language for C++.
Do you care explaining why you stand by this point and why it is better than the alternative or future alternative?
It's all about RAII for me.
What's the alternative. Damn I admit I am not current. I used to be 10 years ago and I am kind of returning to the language. Perhaps I posted this too soon. I just personally enjoyed exception specifications and I can't imagine coding without them. If I were to go before the board I can make a much more compelling case with examples. I am not prepared to do that now.
Well, there is `noexcept(false)` to explicitly specify a function as throwing. You can check for the "noexceptness" for any expression work the`noexcept(&lt;expr&gt;)` operator. Also, dynamic function specifications were ignored by compilers, so a comment would do the same in your case. Other alternatives are `std::optional` for optional values, the proposed `std::expected` that is either a value or an error type, the finally, the (maybe for C++23) Herb Sutter's proposal to throw values. Dynamic exception specification were a good idea at the time, but so horribly applied. 
The visitor pattern.
&gt; Why exactly is SYCL incompatible with MPI? I’m not familiar with the details, but surely there’s some mechanism for accessing your buffers on the host? A DG solver restricted to one node seems pretty limited! AFAIK there's no direct incompatibility. SYCL has host accessors that allow you to read or modify data on the host. There's nothing which would prevent you from using it within MPI calls. But there's a slight difference between SYCL and OpenCL - the former defines a complete runtime which provides an automatic data movement and relies on using data dependencies for scheduling. SYCL buffers don't have a pre-defined location and there's really no way of telling on which device does your data currently reside. Device accessors determine the order in which kernels can be executed. I agree that the original statement in the paper is not very clear why a hybrid implementation would 'violate the ideas and concepts behind SYCL'. Such program would of course be more complex and error-prone but it wouldn't fundamentally different from an OpenMP+MPI application. I think what they would like to have a global runtime with distributed memory where SYCL buffers and tasks can be transferred natively.
Subroutine pattern. Improves my code by having small units that are easily testable and to understand. Maintainers do not have to reverse engineer single multi-page lengthed functions. Compilers are pretty good at inlining.
that would seem to be a worse experience for most users.
Thanks for the suggestions! Everything you mentioned is enabled already, my CLion hovers around 1700MB just idling. I've done some fiddling with vmoptions, and the following: &gt; -server &gt; &gt; -Xss256k &gt; &gt; -Xms4G &gt; &gt; -Xmx4G &gt; &gt; -XX:NewSize=1G &gt; &gt; -XX:MaxNewSize=1G &gt; &gt; -XX:ReservedCodeCacheSize=512M &gt; &gt; -XX:SoftRefLRUPolicyMSPerMB=50 &gt; &gt; -XX:+UseConcMarkSweepGC &gt; &gt; -XX:+UseParNewGC &gt; &gt; -XX:+UseBiasedLocking &gt; &gt; -XX:+UseCMSInitiatingOccupancyOnly &gt; &gt; -XX:+CMSClassUnloadingEnabled &gt; &gt; -XX:CMSInitiatingOccupancyFraction=70 &gt; &gt; -XX:+ScavengeBeforeFullGC &gt; &gt; -XX:+CMSScavengeBeforeRemark &gt; &gt; -XX:+CMSParallelRemarkEnabled &gt; &gt; -XX:ParallelGCThreads=8 &gt; &gt; -XX:MaxTenuringThreshold=15 &gt; &gt; -XX:SurvivorRatio=12 &gt; &gt; -XX:+AggressiveOpts &gt; &gt; -XX:MaxJavaStackTraceDepth=0 &gt; &gt; -XX:-OmitStackTraceInFastThrow &gt; &gt; -XX:+ExplicitGCInvokesConcurrent &gt; &gt; -XX:+UseStringCache &gt; &gt; -XX:+UseFastAccessorMethods &gt; &gt; -ea &gt; &gt; -Dsun.io.useCanonCaches=true &gt; &gt; -Dsun.io.useCanonPrefixCache=true Is my current setup. It's decent for typing and working in new files, but large refactors tend to make things crawl. clangd seems to constantly be running and taking up cpu cycles though. https://github.com/Dwood15/Tempera/tree/first-rewrite is the repository that I'm working on right now. Default CLion chokes on it and is unresponsive.
I'm sorry if it's sound stupid - you mean splitting big function into several smaller ones? 
I love RAII. I wish every programming language had this. It's like garbage collection at a whole new level.
The correct one for the job, whichever it may be.
Yes.
I have never been exposed to other design patterns ( besides RAII ) before this. The thought never really crossed my mind to research other design patterns. Mixin seems absolutely amazing! RAII is one I always try to go for. It really helps with mental understanding of how my code should function, and generally makes it a lot easier for me to look back on older code and read / understand what is happening.
Thanks! I've recently tried a different approach - using lambdas and partial function application if I have all variables in scope, but don't want to duplicate the logic inside method. 
A lot of languages at least have some form of "guaranteed code on entry and exit of a block", which usually compensates for the lack of RAII. E.g. [`with` in Python](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement), [`using` in C#](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-statement)
That the C way of doing things is often preferable. I've seen a lot of horrendously overcomplicated inheritance structures that had to use casts willy nilly... to avoid using an if statement. That's all virtual does anyway - it saves you an if statement. If inheritance adds more complexity to your code than what you get from eliminating an if statement, then I will look really hard on it to see if inheritance is actually warranted. 
It all makes sense what you say, Chandler Carruth in cppcon15 says about as much. The macro-benchmarking is obviously also important. Yeah, use a profiler. I'm on windows/clang/vc, I don't find the vs profiler that dandy (like the analyzer, there, most of the code flagged is STL-code). It seems there is another tool in the ADK, I'm planning on having a look at that.
Const and constexpr all the things, an you'll see the light. const auto my_var = my_var_t{[&amp;stuff_well_need]{ my_var_t my_var; // ... return my_var; }()}; 80% of the time when you declare a variable or a or method it should be const. If it's non-const, there should be good and obvious reasons for it; otherwise, the intents behind the mutable state should be noted in a comment. When you need to reason what the state of a variable is - you just need to look at the place where it is declared, and ignore the 9000 places where it might-or-might-not-be modified.
Nothing that `if constexpr` can't solve for you (easily).
It would be good if somebody (in this thread, more capable than me) could write all this stuff up into some comprehensive story about micro-benchmarking, or femto-benchmarking ;) (about which, I recently learned about). 
Those are opt-in, which defeats at least half the point.
I read that (link), but I don't understand (or miss) what they are trying to say. &gt; In such a situation, the value would depend on the internal storage of float values. The integer value would not be reliable. What does "internal storage of float values" mean in this context?
Yep! Immediately Invoked Function Expressions (self-execution anonymous functions) and Higher Order Functions (functions that return functions) are pretty powerful. After awhile, you'll start to see duplication in your partial function applications that can be abstracted into general purpose utilities (see [Lift](https://github.com/rollbear/lift/)).
&gt; That would require another wrapper library to make everything RAII, add constructors, move semantics, function overloading and other stuff. Your point being? What I'm saying is, yes you'll need to do that, but it now has become bloody easy.
&gt; trap representation Had to look this up, and stumbled on this [post](https://stackoverflow.com/questions/6725809/trap-representation#6725981), which gives a practical view on this matter.
&gt; plus you have shrink_to_fit() if you need the memory back No you don't. &gt; Requests the removal of unused capacity. &gt; &gt; It is a non-binding request to reduce capacity() to size(). It depends on the implementation whether the request is fulfilled. 
This is a very good point. I'm would also say that sometimes it just saves a switch statement, you should be both very fast and clear anyway. I'm not a big fan of inheritance though. I think it is a poor way of writing generic algorithms.
&gt; ... spelling out full words is ill-formed ... `rs_` is overkill as well in any decent C-code and should be `s_`, the rapidness is implied. 
Strict class invariants is where its at. The amount of simplification it brings is astounding.
Applying the concepts of `sum types` (`std::variant`) and `product types` (`struct`) to tailor invariant-less types and manipulate them using free functions has helped me write better and more maintainable code. Most solutions resulted in simpler code compared to weird class hierarchies where the `is a` relationship is really feeble.
It would be better to benchmark all code against the same string implementation on all systems, like f.e. https://github.com/electronicarts/EASTL/blob/master/include/EASTL/string.h
&gt; ... clang's implementation is a 23 SSO capacity. That includes the 0 (for which they implement a [neat trick](https://getpocket.com/redirect?url=https%3A%2F%2Fgithub.com%2Felliotgoodrich%2FSSO-23&amp;formCheck=00e8dac3daf897c09893c2066c5bc14b). 
&gt; So, std::bad_alloc can occur anytime, because it's a situation we don't have total control over. It's also the only one which is rather useless to handle, I believe I read it's under re-consideration. 
I like to avoid switch-on-type unless my type hierarchy is *extremely* simple, as it tends to be very brittle from a maintenance standpoint. In my experience, dynamic casts are unnecessary in almost all circumstances if you use dynamic dispatch properly.
You're right, although there is no silver bullet, a factor of 2 is provably the worst one to pick. In theory, the golden ratio (1.61) does the optimal job (Fibonacci at work), but since you can never allocate exactly 1.61, this is moot (Didn't Einstein had a good remark on the difference between theory and practice?).
Visitor and Composite. 
Agreed. I'm curious: do you mostly use std::variant + std::visit or double dispatch with the built-in inheritance machinery? I've been looking for a good library to do the latter in C++ (currently rolling my own).
I still struggle with basic RAII techniques. I feel lack it's a lack of knowledge and practice. All tips would be appreciated.
Agreed, but [be careful](https://old.reddit.com/r/cpp/comments/8wbeom/coding_guideline_avoid_const_member_variables/) with const fields. They [don't play nicely](https://www.reddit.com/r/cpp/comments/5yxter/tension_between_const_and_move_semantics/) with move-construction and move-assignment (which is a real shame...).
If you cannot even allocate a small string on your system, you (the OS and you) are knee-deep in the brown stuff, trying to fix something in that situation is in my opinion futile. On systems where this is more likely to happen (if not defensively programmed against) like embedded, implementers will not use std::string, and are probably quite happy with the library the OP presents.
I too like these lambda initialisations but in your case using auto makes it less readable as at a glance it looks like a lamda. Place the type on the left 
Thanks for that, I did remember reading this, and commented that in some above comment, but did not remember where. It looks like the begin of the end of exceptions in C++.
The `eastl::string` does apparently (quite a comment in the header), but than it's obviously not std-conforming.
The pattern is that you declare auto on the left when you have an explicit type on the right.
Yes I understand and usually that's find. But for these lambda initialisations the syntax becomes very similar to a normal lambda definition, making it less readable.
Yep. I used to suck hard from the OO drinking fountain, but after writing games in a dialect of C, I realized that just using an if statement (or switch, as you say) wasn't too bad, and the problems prophecized by the "create a class for every kind of pizza topping" never emerged. To the contrary, it was kind of nice not dealing with all those casts. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/93b5e1/is_there_a_comprehensive_book_of_c_gotchas/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
That's c++ - if you choose the discipline, you reap benefits, but if you inherit your codebase from a psychopath you reap "benefits" accordingly... 
My journey into software engineering started exactly the same way as you, roughly 12 years ago. Now I've been professionally writing Haskell for the last 2 years (rest of the time spent with C++). My advice to you is to look no further than abstract algebra and category theory in order to understand the essence of specifying anything. Category theory is to software architecture what calculus is to mechanical engineering.
How can you get away from switching on type? In situations where you need to enumerate all subclasses of a class or have subclasses interact, or need to identify elements of a superclass container, how do you handle it? Do you use metaprogramming tricks? I'm not arguing with you here, I am genuinely curious. I haven't seen anything better than an if statement or switch. 
Admittedly, that the acronym is horrible doesn't help. Others might be more helpful in grokking what it really is, such as "Constructor Acquires, Destructor Releases" (CADRe) or "Scope-based Resource Management" (SBRM). In my opinion, that more clearly tells us that RAII is about working with the fact that the destructor is called when a variable goes out of scope. So for a concrete first tip, something like "allocate stuff on the stack" is a good starting point. Don't do `Foo *p = new Foo();`, do plain `Foo p;` whenever you can. (For when you can't, well, that's when you read up on the [Rule of Five](https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)))
The basic concept behind RAII is: "Destructors are great". C++ guarentees that destructors will be called for every object when the object goes out of scope. You can use this to, for example, set a variable at the beginning of the function, and guarentee that it's unset at the end of it, whether the function ends because of a return statement, or an exception. You can use this to set a mutex. E.g. void foo() { MutexLocker myLock(myMutex); .... // Do whatever here .... // MutexLocker destructor guarenteed called here } You can use it to make sure a pointer has delete called on it (via std::unique_ptr or similar). You can use it to track how many instances of an object are still alive (similar to std::shared_pointer, but for custom stuff). You can use it to make sure a FILE* is closed when you're done with it. You can use it to make sure an object returns to a memory pool when it's no longer used. You can use it to trigger a log message that times how long the function took to run. It all boils down to "Destructors are great". For more advanced functionality, google Named Return Value Optimization, and how to use std::move() to manage the lifetime of an object. Which lets you have RAII and also even more awesome stuff.
I use either virtual methods or [the visitor pattern](https://en.wikipedia.org/wiki/Visitor_pattern). These have the advantage that forgetting to account for a subtype is a compile-time error.
It's a real shame we have to opt in to constness. I wish it were the other way around. mutable auto my_var sounds much better. Because it really is true. 80% of the time, my variables are const. I very rarely mutate a variable after initializing it.
Please elaborate?
Yeah, it took me a second to figure out that fields shouldn't be `const`, objects should be, especially after making all my Java and C# fields `final` and `readonly` respectively.
It sucks because fields often *should* be const, in principle. It's only the unfortunate interaction with move semantics that makes it not a good idea. I really want destructive move.
I’m in a ~100 peoples project rn and we use RAII extensively in C++11. It’s a pure pleasure working there.
How do you mean? They appear to be talking about runtime polymorphism. Not sure how if constexpr is going to help.
The idea is to restrict as much as possible the states in which a type can be between public method calls. For example: let's say that I have a class with the member `std::unique_ptr&lt;Window&gt; mWindow;` . "mWindow points to a valid window handle" is a stricter invariant than "mWindow either points to a windows or is null". The stricter you make your invariants, the more assumption you can make about the current state of your objects.
Learning to dial it down with the OOP and revert mostly to classless functions instead of methods for doing the heavy lifting of the application's functionality. I find that manual separation of behavior and state gives more flexibility and is easier to reason about versus OOP that forces those to be together. When it makes sense beyond a doubt, then I write a class with methods. I find the beauty of C++ is that it has a diverse set of constructs and abstractions, from basically a C foundation up to abstract shit like lambdas and template metaprogramming and SFINAE. You get to combine them in any way you want to solve the problem in front of you.
Singleton. Come at me bro!
If you are working with mixin layers, I can highly recommended this library for simplifying the layers unit tests: http://steinwurf.github.io/stub/
I can't remember who I saw did it, but you can have a beautiful safe Singleton in C++. You have a namespace with an anonymous nanespace inside. Store your internals in the anonymous namespace and the interface in the named namespace. It's just so gloriously elegant.
v8 v10 v12 v13 v16 v17 They've released quite a lot over the years, but I'd there's little visible changes. For example the code completion is still crappy, many integrated clang tools already but They still lag behind.
There are competitions for this. Scott Meyers' singleton is one of the best. [Ref](http://www.modernescpp.com/index.php/thread-safe-initialization-of-a-singleton) That is if you want heartache later when your assumptions that led you to that decision are proven false.
Modern Qt Creator is quite amazing, and still a much more comprehensible (more compact) code base to develop for, compared to what one assumes VS codebase would be, were it open source. 
You're right.
Decorator pattern.
If you're doing an API that the user cannot recompile, if statements don't work. It's also not accurate to say that virtual only saves you an if statement. It might save you a great number of if statements.
I will second this and third it. It's almost always better to use dynamic dispatch, including if you expect other people to extend an API and they don't have all the code, or don't want to go modify all the if statements.
But isn't this more of a trend than a design pattern?
Thanks for clarifying. I apparently was just having a brain-fart and didn't recognize your terminology.
I feel like constness varies by use case. If you're doing end-user applications, they may well be changing the values of a great many things. Const correctness is also a bit thorny at times. To this point, *mutable* has to exist because of problems (related to algebraic closures) with constness. At production scale (hundreds or thousands of classes) it can be incredibly difficult to predict how to make something const correct, and needs can change over time.
&gt; If you're doing an API that the user cannot recompile, if statements don't work. Eh, all the stuff I work on is free and open source, but I readily admit that library authors have different needs than my own. When writing code for myself, I've moved away from complicated OO class hierarchies to much simpler ones with if statements to switch behavior based on class. &gt;It's also not accurate to say that virtual only saves you an if statement. It might save you a great number of if statements. One if statement per time you need to determine the class, yes. So in some cases it will be certainly less time consuming to use inheritance. Some times it will be easier to not use it.
I started using variant a lot in favor of inheritance-based polymorphism. The pros are value semantics, and less boilerplate, especially when it comes to serialization. The cons is that writing a visitor using lambdas is kind of ugly.
&gt; Although I wouldn't have called filesystem experimental now. The implementation is experimental, not the specification. :-]
Const is good, constexpr is even more amazing! Before I used to hate templates, they are difficult to read an debug, but now you can do the same thing with lambdas with auto parameters, and use if constexpr to check stuff and generate code at compile time! Don't need to call it using &lt; &gt; like templates, and easier error messages too!
What is the C way of doing inheritance? Function pointers an unions?
Wait a second.. you're treading static variables as globals. Is this a standard thought process? To me they are two different things.
&gt;&gt; my advice to you is to look no further than abstract algebra and category theory in order to understand the essence of specifying anything. I can't upvote this enough. Abstract algebra is incredibly useful for solving many design problems. Particularly the axiom of closure, which I have used to solve many design problems. It has also helped me avoid a great many mistakes because I the axioms gave me hard evidence about why a particular design choice was wrong.
MVC. Separation of data from the user interface and from the business logic has made writing C++ applications a lot easier than without it.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/93c50w/a_beginner_in_c_asking_for_advice_thank_you_in/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Funnily enough, while inheritance was overused in the 90s and 2000s, I think there is currently a clear tendency to overuse free functions - probably a side effect of the popularity of functional programming even if one has little to do with the other. Another theory of mine is that it is the fault of c-arrays. As they can't have member functions, we can't write `x.begin()` in generic code and instead have to use `begin(x)`. But would any container author seriously write `begin` as a free function instead of a member function? If foo should be part of the interface of x, what is the advantage of foo(x) over x.foo() ?
If you had to use a lot of casts, you use inheritance (or rather polymorphism) either wrongly or for a problem it wasn't suited for to begin with.
Thanks for the lead. I'll pass this along to my IDE team. thanks!
Perhaps it might help to view this from the other perspective: We don't grant inheritance unless inheritance we are creating some kind of polymorphic structure. We don't grant public access unless public access is necessary. We don't mark functions as virtual unless we intend them to be overridden. It seems that we govern ourselves by a maxim that entities should be granted only those capabilities needed to do their job. Why, then, should membership be any different? If an operation can be performed on an object without that operation being a member of the object, then why should it be a member? The side effect of all of this is that your classes end up containing only those operations that are essential to the class's nature; it ends up maximally coherent. This is a good goal to strive for, IMO. (And, if you really do struggle with the x.y() vs y(x) problem -- which I really doubt -- then you can add extra free functions that forward y(x) to x.y() and use y(x) everywhere. There won't be that many. Job's a good'un.)
Copy-on-write, upon which immutable data structures can be built. 
What I've been doing a lot of lately is writing static free functions and then using a class to glue everything together and expose the functionality. You get the benefit of encapsulation, but when you peer under the hood it's clearer how the data is accessed and modified.
And if it must be heap allocated, manage the lifetime with a smart pointer.
There's a few different ways. You can use delegates as you suggest, but the way I've solved a number of tough problems is with a typeid and then using an if statement. It's more or less what virtual does behind the scenes for you, but it lets you write code like this (let's say it is a shotgun that deals double damage to birds and deer): if (other.takedamage) if (other.typeid == BIRD || other.typeid == DEER) damage(other,20); else damage(other,10); I haven't seen a really satisfactory way of doing this using inheritance that is as compact or easy to read or encapsulated (ironically enough). There's enough wisdom here that I'm hoping someone will suggest a better way, but I haven't seen one yet.
I forgot to write that global variables make source code more difficult to maintain because suddenly every function could potentially depend on something besides its arguments. You can't even trust your unit tests anymore because they could depend on previous tests without you knowing it. Global variables should only be used if you can minimize the potential side effects. Logging, monitoring and debugging tools could use global variables. Everything else probably shouldn't. Another issue of global variables in C and C++ is their unfortunate interaction with DLLs. The same global variable can have multiple instances in the same process on Windows.
Beside RAII (idiom or pattern?), I use the Strategy Pattern extensively, and Template Method a lot, and NVI whenever it makes sense.
Keeping in mind that what I'm about to say is based entirely on my own anecdotal experience, anything involving mixins will just make your life miserable and is probably an indicator of poor design. Likewise, anything involving introspection. I'm on the fence about CRTP, leaning toward probably an indicator of poor design. Singletons, definitely in the anti-pattern column. Like last 10 interviews, if they ask you for an example of a design pattern and you whip out singleton with anything good to say about it, they're not going to be calling you back. You watch, someone's going to reply to this with something along the lines of "Waaah! But... Singletons....!" You can always design around it, your singleton code won't pass design review, you're probably a bad programmer, sorry to be the bearer of bad news. So what's that leave? RAII? Is that even a design pattern? Learn it, live it, love it. Listener, awesome. Factories, model your data as objects and you can write a factory and trivially decouple all your IO from business logic. I can provide examples. Working examples. Of code that does useful things and threads well. Memento, you'll need to know that one if you're to have any chance of understanding the Tensor Flow code. That's just off the top of my head, when I'm up battling insomnia and an apparent invasion of giant fucking spiders. That's not a metaphor. Main thing is understand your problem domain and write small libraries to solve those problems. Keep it simple as possible and solve the problems you have to deal with today, not the ones that could arise tomorrow. All that over-engineering with introspection and all that god damned bullshit is just a symptom of being terrified of throwing any code away ever for any reason, and the whole *point* of software is that it's much easier to change than hardware is. If something comes up that requires you to change your design and rewrite some objects, change your design and rewrite some objects. Ideally try to structure your library code so you don't have to be a domain expert to use it, and you don't have to worry about what object owns what resource at any given time. Ffmpeg is a perfect example of what not to do when designing a library -- you literally have to already know everything about video encoding AND everything about internal ffmpeg code in order to use it. That's right, you actually have to know MORE about the problem domain than if you went and wrote your own code to accomplish any given task. Ask me how I know this!
I would really like a system that won't compile if there's a new subtype introduced! As it is, the default case handles new subtypes at runtime. I'll give you a stripped down example that is similar to code I have in a ~500k LOC game I wrote. Suppose I am making a shotgun that will do 20 damage to birds and deer, but 10 damage to all other actors in the world. Only actors flagged as being able to take damage can be damaged. In my code, I write the following in my fire_shotgun() function: if (other.takedamage) if (other.classname == BIRD || other.classname == DEER) damage(other,20); else damage(other,10); Can the visitor pattern do this as cleanly and compactly? I am sincerely interested in a better approach. Notes: Each weapon might have its own criteria that it uses for doing extra damage like this. other is an actor in the game, which is a class for anything that moves around in the game world. Birds and deer are their own "class" in the system (they have their own AI, movement patterns, health, etc.). They're actually just actors, but behave like subclasses. 
Thanks for the extra information. Unit testing and globals always make me a bit wary Typically within libraries/framework layer I would limit dependencies on Globals unless they are nearly stateless (e.g. logging) and need to think much harder about including them. However within the application layer then I'm a more lenient and will allow some more globals (e.g. thread pools, dispatchers, etc) as often the tests in this layer I'm focusing on system level tests anyway.
Oh sure, it does, at first, but you have to leverage MI for mixins. And eventually you're going to want to inherit two classes together that have the same mixin somewhere up in the tree somewhere. Having gone down that road personally and seen where it ends up, I'm just going to go ahead and say that you'll save yourself a fair bit of trouble if you view them (And probably MI as a whole) as a fundamental flaw in your design somewhere. And sure, someone can probably always point to a .01% of the time case where it at least kind of worked, but you have to be a fantastic designer to get away with that sort of thing, and most people (including me) are not.
Dependency injection and inversion of control in general.
Agreed, but it's so obvious that I even forgot it is called a "Design Pattern" :)
Lambda in a lambda, aka backtrace hell :-)
Here are a few tips that may - or may not - apply to you: - if a destructor is complicated, this usually means the class has too many responsibilities - follow SRP (which fits very well with RAII)
You can totally do it. Write a bunch of static functions that only exist for that file, write a thing_allocator or somesuch that creates an instance of thing and assigns pointers to static functions. It's a lot of manual work and you'll have to call your "destructor" and insert "this" manually, but you can write C that way. You can even do inheritance by replacing some pointers to functions. It's kind of a pain in the ass, though, and I wouldn't recommend doing a particularly complex program that way. Fun as an academic exercise, though.
This is one of the things I like about swift, if you declare a variable and don’t modify it you get a warning. 
It's a weak replacement for RAII like C# generics are a weak replacement for templates. They allow you to superficially do the same thing, but don't actually allow the great abstractions that the former do.
We don't
Don't worry, I also never thought this would require a pattern name. 
Isn’t C++ RAII opt-in as well? The syntax doesn’t force RAII. 
Automatic storage is the default, and objects in automatic storage are automatically destroyed when they go out of scope. To get different behavior you have to opt-out of automatic storage, or write broken types to begin with.
Your not forced to use classes is the point I was making, so strictly speaking you have to “opt-in”... I’m probably only pointing this out cause I’ve seen too much imperative C being called C++. 
Modules. If you are thinking modules - you are thinking OOP. Modules essentially help you to break your complex logic into parts you can understand and make it maintainable. This is a very generic principle, not belonging to C++. Many other principles just help that. Design principles that belong only to C++ are not the deal breakers, tbh, while nice to have.
I got confused with the ones on another tab and now my shipment of 5 boxes of cialis is on the way.
I don't understand how classes relate; either you use `new` or you don't, and if you do then you're opting out of automatic storage. ;-]
True, https://akrzemi1.wordpress.com/2013/07/18/cs-best-feature/
I had some trouble using these compared to RAII in C++. When designing a class in C++, I know that if the constructor failed (i.e. raised an exception) then the members and base classes will be handled correctly and freed. In C#, I have to call `Dispose` manually somehow - Probably by catching the exception and calling it in the `catch` handler. That's extremely error prone. In Python, when writing the `__enter__` function, I also call the same function of the class's members (manually, which is error prone), but what if one of them failed? Do I need to manually call the correct `__exit__` functions? How do I remember which members were initialized? Using the C++ mechanism just works in all of these cases, with minimal boilerplate and burden on the programmer. 
RAII is more than just destructors that destroys something. Look at the full name "resource acquisition is initialization". It is also about constructors - when it successfully finish it's work (without exception), you have initialized object. And that is also great. Destructor is a second part of RAiI :)
"for most users" part is wrong. Only for those who are are used to using weird visual shortcuts ;)
And Linux version? Maybe flatpak?
Just to make sure we are talking about the same thing: Are you suggesting that random access containers should only implement two of `begin/end/size` and the third as a free function as one can be expressed in terms of the other? Should `push_back` be a free function because it can be implemented in terms of `emplace_back` (that can actually be more tricky than it sounds)? `std::unique_ptr::get` can also be imemented as a free function using operator* and std::address of. Imho, all those functions represent core properties and functionalities of their types, even if they might not form a minimal (efficient) basis and I think them being member-functions is exactly the right thing. On the other hand, I'm certainly not suggesting to implement e.g. std::sort as a member function - the at would be plain stupid. &gt; , if you really do struggle with the x.y() vs y(x) I'm not struggling with it. Just because I think a pattern is overused doesn't mean I have a problem with using it. However, the compiler can struggle with it (have you seen the error messages when it doesn't find the appropriatedly overloaded free function of a common name e.g. `operator&lt;&lt;` - not to mention what happens when you are using templates and ADL kicks in). The point I'm trying to make is that `x.y()` conveys information to the compiler as well as to the human that y(x) does not. Namely that there is a very small area in the whole code base where y can come from. It also tells me that calling that particular function was not just an accident, because there happened to be a better matching overload/template than the one the author actually wanted to call (that's why you are qualifying all your free function calls with the full absolute namespace right?). And maybe it is just me, but I find `foo(a).bar(b).baz(c)` much more readable than `baz( bar( foo(a), b) , c)` (admittedly those occur rather rarely) When I write a class, the first and foremost concern is ease of use and readability in the code that uses it (a variation of the "code is more often read than written"). If I have a few more functions that have access to the internals of my class, that is frankly not a big concern to me, because it is still a clearly defined and limited set whereas making my member data public makes it accessible to **everyone**. If you make your functions free functions, just because you have trouble reasoning about the internals of your class (not because it is the more natural choice from a user's perspective anyway or because it's functionality is only loosely related to that particular class), you leak your implementation concerns into your interface and a better approach might be to restructure the internals of your class (e.g. create (free) helper functions or put part of the functionality into a separate class).
Where are you
Globals are bad when they're used as function parameters because the programmer is too lazy to type out the function parameters. The exception to this is when I'm lazy, and do not want to type out all the function parameters. But I'll only do this in a trivial program that I'll probably never use again. For example, I wrote an AI for Connect Four last week in about an hour's time, and it used several globals for tracking state because it shaved a couple minutes off my time and I was coding under severe clock pressure. There's actual legitimate uses for them that you mention in your survey, but as I said, for any serious program I try to avoid them entirely.
I have to usages for global variables: - When you have multiples stacks and you want to communicate between them (like during interruption in micro-controllers, or between 2 binaries (I consider that a file-system is like a global variable)). - When I have a constant configuration (as long as the configuration can't change after the set-up of my application, it's fine). Other than that, never. My first real project when I started programming was ~700 lines when I discovered I had to re-write everything because I used global variables. I was burned really hard, really early!
You're telling me. Some people get angry about it; [https://www.fluentcpp.com/2018/02/13/to-raii-or-not-to-raii/#comment-3755966297](https://www.fluentcpp.com/2018/02/13/to-raii-or-not-to-raii/#comment-3755966297)
(Assume in these examples a type hierarchy with `agent` as the base and `bird`, `deer`, etc. as subtypes.) If your `fire_shotgun()` method is not itself dynamic, then you could just add a virtual method to the base class: class agent { virtual int get_damage() const = 0; }; class deer : public agent { int get_damage() const final { return 20; } }; // Etc. But if not... &gt; Can the visitor pattern do this as cleanly and compactly? With inheritance-based visitors, that particular example might look like this: struct damage_visitor : agent_visitor { int damage = 10; void visit(bird const&amp; other) final { damage = 20; } void visit(deer const&amp; other) final { damage = 20; } void visit(aardvark const&amp; other) final {} // Default other agent subtype visit methods. }; if (other.takedamage) { damage_visitor v; other.accept(v); damage(other, v.damage); } So there's definitely extra boilerplate. But that's generally a price I'm willing to pay in order to be forced to decide explicitly what to do with new subtypes. The [`std::visit` solution](https://en.cppreference.com/w/cpp/utility/variant/visit#Example) can be shorter and cleaner, but I don't really like using `std::variant` when the types have a lot of common functionality.
I am currently writing a template extra-heavy project, and I just use `double d = my&lt;template&lt;instantiation&gt;&gt;::evaluation(complicated&lt;stuff&gt;());` to get a compile error, and read what gcc/clang say about the failed conversion to double (the real type is written in the error message). But I think your IDE can be useful.
I also thought of that syntax (witch is good for local variable), but then you can't have non-const class members with automatic type computation (in a class `mutable` means that the const function may still modify this value, since this value isn't a visible state of this object, eg. a cache). I think that `const myVar = value` should be valid (`const` meaning `const auto`), but I'm not sure it's not ambiguous. 
As for me, my favorite design pattern is Singletone(sarcasm). Frankly speaking, I hate this pattern. I have been working at project, that contains tons of antipatterns and patterns using at wrong places. In this project Loki singletone is used previous developers as arhitecture pattern and I called it Singletone Oriented Programming. To make good design you should know most of patterns: GoF, features of your languane and also programming paradigms. So, good design isn't about concrete patterns, it is rather about balance between flexibility and simplicity. And on each peace of code, library or utility you have to decide what is the most important at this time: Simple code, that may be rewrite, or template code with abstract patterns, that can be used in many places. All of this is result of bussiness requirements.
I am currently writing a pet-project with extra heavy use of template in c++17. It's a breeze, but I'm looking the C++20 addition with desire (like `void foo(auto t);` instead of `template &lt;class T&gt; foo(T t);`, `[]&lt;class T&gt;(T t){ ... };`, class type in non-class template parameters, …)
One that is fairly easy to get into is notepadqq. https://github.com/notepadqq/notepadqq I only did 1 or 2 fixes on there, but the code was easy to understand and get used to.
I also like `struct`s + functions, it also suppresses the urge to write setters. Too bad it looks like unified call syntax won't be a thing, this would be structs + functions on steroids.
You _can_ have a beautiful, safe singleton in C++ ... and just because you can, doesn't mean you should (even when it is elegant). The singleton pattern looks like it improves things when you apply it (and it does) because it centralizes dependencies and places them behind a single access point and an abstract interface. Singletons do not address the problem of inflexible dependencies though. They create code that is easy to use, but difficult to port and reuse (because all your singletons are dependencies that cannot be injected and are not visible on the client side). 
Adhering to good coding practices can be relative to how long you expect the code to live for.
Just because category theory is applied so strongly/directly in Haskel, doesn't mean you should apply it _everywhere_ in C++ (or OOP). ... and DO look further than category theory :) For example, Alexander Stepanov has some youtube lectures where he describes the design principles behind the standard template library. Most of what he says is about designing by contract. 
\`size(container)\` sounds like something useful. Consider: \`namespace std{ template&lt;class Container&gt; auto size(Container&amp;&amp; c) -&gt; traits&lt;Container&gt;::size\_type; }\` Now, you have a uniform way to get the size of a container: a vector, a deque, a string, a statically allocated array... Not bad. Note that the last one cannot be done with x.y() syntax. \`unique\_ptr&lt;T&gt;::get\` can't be implemented in terms of \*/addressof without potentially dereffing a null pointer. \`w.x().y().z()\` breaks the law of demeter. I'm not concerned. But don't get me wrong: not everything should be a member. There should just be a good reason for something to be a member. A question: do you write non-virtual private member functions. If so, why?
&gt;*Postmodernism began in 1951, when David Wheeler (@stroustrup's thesis adviser) invented the subroutine. I hope it catches on. #PostModernCpp --* [Tony Van Eerd, March 2017](https://twitter.com/tvaneerd/status/838974564558340096)
That's a great principle.
But then there's always the fact that any temporary solution inevitably becomes the permananent fix! 
It works in Linux, but the Qt version I require is only available in Ubuntu 18.04, and the latest metashell build doesn't run on it. They are looking for it. The Mac version also works, I am just trying to figure out how to package it.
Thanks! Btw I just noticed that one of the last updates seemed to have re-enabled the "Format on paste" checkbox. But I definitely had this problem too when the checkbox was disabled. One other really annoying thing since the new clang-format integration is that if you type REALLY fast, it swallows your text sometimes and moves around your cursor. This basically only/mainly happens if you type faster than some internal VS update loop, and then the "move-cursor" operation happens after your second keystroke because you were typing faster than it was able to update your cursor after your operation. You can repro this quite easily with open and closing parentheses. If you type anywhere in your code "void test" and then REALLY FAST, and I mean instantly, type "()", then the cursor moves to the middle of the parentheses after you typed the ")" - if you type more slowly, the cursor stays at at the end, after the ")". There are more scenarios where this and similar problems happen, so I do have a feeling that you don't have any ninja lighting speed typers testing this :P
&gt;how long you expect the code to live for. This is where you are often wrong though and it turns out to be very different...
&gt; curiously recurring template patterns (CRTP), pimpl, mixins, mixin layers (for collaborative design), and runtime-concepts (for runtime polymorphism). I would love to see a blog post, book, or talk about how these look with modern C++14 code, when these concepts can be used, how they differ. CRTP, mixings, mixin layers, ... these all seem very similar to me. On top of that many resources regarding these are often old, like CRTP and mixins you mostly find pre-C++11 books/posts online, and I am sure how to implement &amp; use them with C++14 has changed somewhat.
Sorry if this is a stupid question, but where is the C++ code? All I saw was .js files.
What aspect are you struggling with? At its core, the concept is incredibly simple. If a resource needs to be cleaned-up at some point, acquire it in an objects constructor and release it in its destructor. This guarantees not only that every object is in a valid state after its construction, but also that all resources will be released properly. Keep in mind that for objects that are logically allowed to be null or empty, the constructor might not actually acquire a resource. But the destructor will still take care of any resource assigned to them at a later time. Example: { int* a = new int; // Resource acquired : memory ... delete int; // Manual clean-up is error-prone } Should be { auto a = make_unique&lt;int&gt;(); // Ties the acquired memory to a std::unique_ptr&lt;int&gt; ... } // No explicit clean-up, std::unique_ptr will delete the pointer on destruction The existence of an object that *owns* the memory makes handling it so much easier. You can't forget to `delete` it, nor can you double-`delete` it. In fact, you'll never explicitly write `delete` at all. The destructor will be called even if an exception is thrown, meaning that if your program recovers it still won't leak any resource at all. The same technique applies to everything that requires clean-up, such as files, mutexes, connections etc. A good idea to understand how RAII works and what it does for your code is to code a simple RAII class like `unique_ptr` yourself (see [here](https://en.cppreference.com/w/cpp/memory/unique_ptr) for the interface). Then write a small example that uses your smart pointer and use a debugger to watch step by step how the memory is automatically handled.
Why did you declare the type outside the lambda as well, though? Wouldn't the ideal scenario be to declare the type exactly once? That would be in the lambda body because it's unavoidable there.
That's to make it clear from the start that my_var is not the lambda itself, but the result of its evaluation.
It is indeed a neat trick, but not one that Clang uses. Clang simply returns 2 to the power of 63 when `max_size()` is called instead of 2 to the power of 64. Meaning their string's max size is slightly smaller to allow them to store the flag. SSO-23 on the other hand does some black magic bit shifting to save a bit in the capacity based off the size of the string.
The first sentence in that comment is: &gt;This string implementation does not do copy on write (cow).
Can you elaborate on how this is preferable to just using a declaration with the type instead of `auto`? Do you use this syntax for all declarations, including primitive types?
What do you mean by "ignore" constant global variables, exactly? This is the only global variables I use. Does that mean, in relation to your survey, that I "don't" use global variables?
Well, a neat trick.
RAII and pImpl for me
Yeah, shit happens.
I wouldn't say one way is preferable to the other. Some people have an opinion, but I'm still ambivalent on this, but I'm leaning toward the 'auto'-on-the-left for the following reason: const int x = foo(); // might do a narrowing conversion. const auto x = int{ foo() }; // explicit; narrowing conversion disallowed. const auto x = foo(); // implicit, but not read-friendly - might be hard to reason about the type of x unless you're actively helped by an IDE.
In-terms of the survey, that would mean not using global variables. As this is more commonly accepted for people which prefer 'no globals'
I've seen globals plenty of time in production code, mainly in embedded. 
constants aren't variable(s)
supposedly never but deadlines make people do crazy things
Thanks for the detailed answer. It helps me to understand your approach here. With the first approach there is an issue in that the functionality of the shotgun has been moved out of the shotgun's code to every actor in the game. If I want to tweak the damage of the shotgun, it seems counterintuitive to search for the number in two unrelated subclasses (Bird and Deer). It also means the Actor base class has to know about the shotgun (and every other weapon in the game) which isn't something the Actor class should actually care about. So I'm inclined towards your second system, since it puts all damage values for the shotgun in one place, instead of being scattered throughout the class hierarchy. Correct me if I'm wrong, but it seems like we're going to need a quadratic amount of code - one struct for each weapon, and one method for each Actor subtype. With 40 weapons and 30 actor types, that's up to 1200 methods to write and maintain, instead of 40 in the C way. If you're changing how weapons work all the time (which is common when tuning games) that's a lot of places to update and sources for bugs to creep in. The C-style version, IMO, is easier to read and expresses the intent of the author clearly. More importantly, the damage values aren't duplicated across multiple functions. There's a single function describing what it means to fire a shotgun. The downside to the C version is, as you say, if we add a new Actor subtype to the game, then this can (and has!) result in runtime bugs. In the case of the shotgun example it actually works just fine since the else block handles all new types, but I've certainly had bugs when writing new subtypes that aren't handled. Exactly as you said - being forced to handle new subtypes by the compiler is a huge benefit.
Rust APIs are awesome for this. It's pervasive. Like how with mpsc or spmc structures, you have to consume the data structure itself to create a pair of reader/writer objects, the single side (writer for sp, reader for sc) is move-only and the multiple side is copiable.
I can't really remember what is the last time I used global variables. So my answer is no, I don't use them. If I need a singleton, I use static instance variable in a singleton getter function. If I need variables out of classes and functions, I put them in anonymous namespace so they are not really global. But I use global constant a lot. 
Yeah I'm over here internally debating whether or not it counts, but I guess it does.
Also, learn and embrace the rule of 0.
Yeah I'm over here internally debating whether or not it counts, but I guess it does.
The Rule of Five, otherwise known as the Rule of Three, possibly better if it was known as the Rule of Zero.
Abstract factory, builder, adapter. 
However, \`std::unique\_ptr&lt;Window&gt; mWindow\` that always points to a window handle is code smell. First, because your wrapping class cannot implement the rule of zero -- the implicit move ctor of the wrapping class results in an object that violates invariant! So that invariant is only appropriate if the wrapping class cannot be moved. (If you manually write the move, that violates the rule of 0 and makes the move possibly throwing; both are bad). And a wrapping class that cannot be moved means that the type isn't as regular you really want; C++ loves regular value types.
It's certainly a trade-off. If there's a reasonable default behavior for new types and most of your existing types behave the same, a switch is fine. I'm not sure I agree with this point though: &gt; that's a lot of places to update You can define your visitors in the same places you currently have if-else or switch statements, e.g. in the body of `fire_shotgun`. It's technically more functions, but they have the same sort of layout and code locality as the corresponding if-else's.
I use globals frequently, as long as they are constexpr or in a few cases const. The only place where I got mutable global state is a thread local in my logger.
I think that's a fairly good point. VIM (my editor of choice) dates publicly back to the 1987 "STEVIE" code base from which it was forked. By 1987 standards, C++ was decent but compilers were nothing like as widespread or mature compared to the C compilers of the day. I think a lot of editors got started long enough ago that C was a reasonable or arguable better choice due to the constraints. The Stevie editor release was contemporary with the first release of GCC and the first release of G++ didn't stumble out until the end of that year.
The basic rule I like to follow is "a function should fit on the screen". If your function is bigger than your code window, you need to break it down further. It's really about managing scope.
I think you are reading way too much in an off-the-cuff example thrown in to demonstrate the difference between a loose and a strict invariant, and not an actual real-world code sample. But I do agree that move semantics do make having strict invariants hard to implement formally at times.
It's opt-in to encapsulate the resource handling using RAII, but when you are using a type with RAII, it's the default. You don't have to "opt-in call the destructor". It's automatic. However in java/C#, … If you have a type that handle a resource, the user of this type must knows it (and use the appropriate construction like `try_with_ressource`). It's well explain [there](https://akrzemi1.wordpress.com/2013/07/18/cs-best-feature/).
If you needed to use a lot of cast and switch cases for your inheritance tree, it means that it was malformed. See the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). Normally, with a well formed interface/base-class, none of the caller/user of the inheritance tree should have to worry about the exact type of the object it is manipulating. After that, the only place where the switch statement is necessary is for the construction of the correct sub-type, which can be isolated in a factory, and then injected to the users via its constructor. 
Real code generation with templates. At first I thought that it was the same with any generic in other languages, but apparently it's not. I was recently unable to do what I wanted in scala, whereas it would have been a 2 lines template free function in C++.
you never use cout etc?
Curious what the topic of your talks is? I gave a talk on how to do globals correctly at a mechanical level in C++ at cppcon last year, and mentioned a few use cases there: - Logging - Intrusive performance profiling - Factories. In particular, when you have `unique_ptr&lt;Base&gt; make_base(const string&amp; derived_name, ...);` or similar. You'll usually want to have a global `unordered_map&lt;string, std::function&lt;unique_ptr&lt;Base&gt;(...)&gt;&gt;` or similar, which derived classes register into. There aren't many valid use cases for globals, but I'll defend the three above; doing them without globals sucks. The first two aren't supposed to affect behavior, and the third almost isn't really global mutable state, it's a one time initialization of state in order to create a pure function which otherwise can't be written because of language limitations.
There are a bunch of C++ files in src/ui
Who uses cout for anything other than little test programs? 
well constexprs aren't really variables, right?
&gt; If I need a singleton, I use static instance variable in a singleton getter function. A rose by any name...
Thanks for the response. You're right, it probably was malformed, but I haven't seen a great solution to this sort of problem I constantly bump into when writing games: https://www.reddit.com/r/cpp/comments/938ncv/what_is_the_most_useful_software_design_pattern/e3c83pi My solution has been to flatten the class tree significantly and use an enumed member variable to create a form of subtyping. I am not happy with it, but it seems to work better than other approaches I've tried. I'm curious what your solution would be. Additionally, in gaming we often want to do actions like "get all objects of class Deer in the world" or "if the touching object is of class Deer" but this seems hard to implement properly with containers and functions operating on the Actor superclass.
No they really are. If it's a local variable in a function, it will take stack space at runtime, and global constexpr can be ODR used and have an address. They act just like any variable but their value is avalable at compile time.
Good point, I forgot you could declare the visitor inside the function where it is used. That would make it look a lot more clean. There's still the issue with how responsibility cuts across the different subtypes, leading to duplication of code, but that might be the minimum cost needed to get compile time guarantees. 
Why is this downvoted? Category theory understanding will definitely allow you to write better code in C++. Just check http://ericniebler.com/2013/07/16/f-algebras-and-c/
The best pattern when dealing with C++, is the KISS pattern. Use the parts of C++ you need, leave the rest out until you actually need them. "Use All The Things" is not a good design pattern.
I prefer RAII too, but if you're manually calling `__enter__`, `__exit__`, or `Dispose`, you're doing something wrong; they're meant to be called automatically as you enter and exit `with`/`using` blocks
&gt; It's like garbage collection at a whole new level. Or, as Stroustrup has famously said: &gt; C++ is my favorite GC language because it generates so little garbage. C++ expects people to clean up after themselves, rather than hiring an entire janitorial staff to pick the garbage off the floor.
I think this is pretty cool - I will probably use this on my own project. Is it possible to "disown" a child process? I couldn't find a function to do so on the header file.
A ton of programs use `stdin` and `stdout`.
I went from some early 2000's C++ to C++17 and skipped 11 and 14 (as in, I learned 11 and 14 while learning 17), and I am in love with smart pointers. In the past there'd always be _some_ weak moment I'd have or I'd use some person's poorly documented function and it'd `new` something... but since then, I've had zero memory leaks and love every second of it. RAII is my favorite feature.
No, RAII is not opt-in. If YOU use MY class to e.g. open and use a socket, then you are going to get cleanup in the destructor whether you like it or not. Whether you remember to write \`finally\` everywhere or not.
I typically just use it for loggers.
I've looked into it a little bit and both Windows and POSIX seem to support detaching a child process from its parent. It just needs to be added to reproc's API. Can you make an issue on Github? We can discuss further there.
Consider a Server class, which manages a log file. I wish to design a class that is as easy to use as: with Server(port=MY_PORT, log_path=MY_PATH) as server: server.serve() Lets say I already implemented `ListeningSocket` and `LogFile`, each has non-trivial `__enter__` and `__exit__` to make sure their resources are correctly initialized and cleaned (opening a socket and binding it to a port, opening a log file and adding log headers...) Therefore, the constructor of server probably looks like this (maybe with some extra optional parameters): def __init__(self, port=DEFAULT_PORT, log_path=DEFAULT_PATH): self.sock = ListeningSocket(port) self.log = LogFile(log_path) # ... I didn't call either class's `__enter__` function yet, where should I call it? Probably in Server's: def __enter__(self): self.sock.__enter__() self.log.__enter__() # &lt;----- What if this failed? Now, if the second line failed (raised an exception), I need to call `sock.__exit__` somewhere and propagate the exception. If I the method contains more code which can raise an exception, I need to handle that as well. So much work and boilerplate. &amp;nbsp; You said: &gt; if you're manually calling `__enter__ `[...] you're doing something wrong But I don't see any good alternative that maintains the simple interface of this `Server` class. You could suggest receiving both `log` and `sock` as arguments, resulting code like: with ListeningSocket(MY_PORT) as sock: with LogFile(MY_PATH) as log: with Server(sock, log) as server: server.serve() But this code too has boilerplate, and the interface is now too permissive - Do you need to check the `sock` parameter is a `ListeningSocket` in Server's constructor? If not, do you check it supports the interface of `ListeningSocket`? If you use type hints or check the interface, do you make sure that `sock` is actually initialized (`__enter__` was called)? In the end, all options require some boilerplate and using them feels like I do the work a compiler should be doing for me. Fortunately in C++ it is the case.
What was the title of your cppcon talk last year? I'm interested in looking it up on youtube.
As someone who works with the Visual C++ sources, you'd be surprised; the code is actually quite reasonable for such an old product (at least, I was surprised)
https://www.youtube.com/watch?v=xVT1y0xWgww&amp;t=464s
The Swedish migration board website mentions waiting times of about 2 months from the moment the application is received until a decision is taken. This assumes that the migration board will not be asking for additional information once the application has come in (which could prolong the process substantially), and when compared with historical data it seems quite optimistic unfortunately. All that said, we want to hire the right candidate for the job, and so if you have the right profile we're *not* going to throw out your application just because you happen to live outside of the EU. Does that clear things up at all?
Apart from RAII, CRTP(rarely use), i use * decorator and adaptor pattern: talk to external API * simple factory(factory name -&gt; object instance) * Proxy + PIMPL idiom * mix of boost transfer adaptors to print and access stl containers
If we're discussing broad-sweeping changes to the language, like all variables are const-by-default, then the use of the specific keyword "mutable" for one aspect of such a broad sweeping change would potentially imply the need to change things elsewhere to make sure the language is still consistent. In this case, we could do a different keyword for "const functions can mutate this variable". Maybe "cache", or "i-ignore-const", or whatever. Similarly, I'd also love to see member functions of objects be const by default, and require a "mutable" keyword. Further, though less so than the others, I'd love to see normal functions be "pure" by default with some "nonpure" keyword to flag to consumers of that function that the function is going to change some kind of global state. "inline" should really be "allow-ODR-violation". "static" should be something else. Meh, I'll stop now. C++ has a lot of very odd keyword choices.
I use it for subsystems within the software. An application might have subsystems for communication with other applications, storing data that was loaded from a database, performing complex calculations on incoming values, logging, etc. The only problem I occasionally run into is a missed dependency on startup or shutdown; once it is running it's all fine. I use a custom pointer class to construct services on demand which helped a lot with getting rid of such issues. Could I stick them all in a single, stack-based master object and pass that everywhere? Sure I can, but I fail to see how it would be an improvement. 
Wouldn't a qt creator plugin require use of qt creator?
Why would one have to choose one or the other?
I assume you mean the current meaning of the mutable keyword, as applies to const member functions being able to modify member variables. The percentage of variables that are changed after initialization is, of course, going to be project specific. In my particular case, it's a multi-million line codebase that's about 20 years old. My completely-off-the-top-of-my-head estimate is that a good 75%+ of our variables across the whole codebase could be relatively trivially made const-at-initialization, and I think that were the language to somehow change overnight to do const-by-default, we'd be able to shrink our overall codebase by 1-2% just by the difference in characters between "const" and "mutable". Of course, the actually number of characters in a particular codebase is completely meaningless, but i'm just trying to impress the magnitude of the change. But more importantly to where I'm coming from, is that we'd benefit significantly from a change like this in the sense that the number of programming mistakes caused by reusing a variable incorrectly would be reduced dramatically. Professional programmars do this *a lot*. I work with sr. / lead / architect level software engineers that are constantly making mistakes like this. They get caught right away, and these people are brilliant in many other ways, but sometimes the language works against them. Of course, a change like this is never going to happen to C++. Talk about backward compatibility, jeeze. And some readers may be thinking "Use D!" or "Use Rust!", and I don't really have an answer for them beyond the codebase is C++ and switching languages is just not happening *shrug*. If someone were to make a variant of C++ that did use const by default, and it was otherwise 100% compatible with C++. E.g. headerfiles written in C++, impl files in C++++, C++++ sources get detected by a pragma, or file extension or something, that'd be something I could see getting adopted by my group at work. Either way, pipedream, fantasy, nothing to see here.
Ah, that's a really good example; thanks
Unfortunately this is far from clear in the survey, and you'll get inconsistent replies.
Or singletons?
We try to minimize the usage of global variables, of course, but two cases remain a good fit for them: 1) Logging. 2) A registry of static global read-only prototype objects. The first one is quite common, and the second one is related to my domain - game development. It's often useful to have a global registry of prototypes from which game objects can be initialized (for example, car name's localization ID, 3D model ID, top speed, acceleration and the list of available upgrades). This registry never changes after some point (depending on the complexity of the game - in simpler games, it's loaded once during the game start-up, in more complex ones it can be loaded when some level is loaded). It must be accessible from all places where a game object can be constructed, and sometimes from other places, where a list of possible objects of one type is needed, for example (UI, mostly). Instead of passing it around through all layers of calls via context or some other way, we store it a global Singleton, which can be accessed by any piece of code in the game in read-only manner.
I pretty much exclusively use global variables as a hack when I've got a working program that I need to post-hoc add additional functionality to, and I want to do it quickly. And over the years I've done it less and less. I've also gotten into a stronger habit of packing large parameter lists into their own dedicated objects, which *screw bad practice* makes my code so much more readable and easy to work with—and also often reduces the frequency with which I have to make those kinds of hacks, because instead of adding a new global variable to get an important object passed along, I just have to make an edit to the "options struct": image_t perform_render( point2 const&amp; center, float radius, float angle, dim2 const&amp; image_size, int threshold, std::vector&lt;color&gt; const&amp; palette, format_e format) { /*...*/ } //Becomes..... struct render_options { point2 center; float radius; float angle; dim2 image_size; int threshold; std::vector&lt;color&gt; palette; format_e format; render_options() : render_options({0,0}, 2, 0, {1920,1080}, 1000, {colors::black, colors::gray, colors::white}, format_e::float) {} render_options( point2 center, float radius, float angle, dim2 image_size, int threshold, std::vector&lt;color&gt; palette, format_e format ) : center(std::move(center)), radius(radius), angle(angle), image_size(std::move(image_size)), threshold(threshold), palette(std::move(palette)), format(format) {} }; image_t perform_render(render_options const&amp; options) { /*...*/ }
But using a smaller factor is not a silver bullet either; you'll be resizing more often, and sometimes unnecessarily! Which is exactly why I'd rather there was a standardized interface allowing *asking* the allocator what capacity to go for next.
If you have to do singletons, do them with a static getter and make the constructor private. It's been \*extremely\* useful for me in testing things, and especially in the case of making singleton systems - like being able to retrieve the system and then construct/destruct it from static functions used during a swapchain recreation event is sooooo nice. Keeping functions small is also huge. Same with classes. ECS is neat, even if it can be misunderstood and overhyped. Thinking of ECS-like principles can be healthy anyways - and it does tend to lead to more maintainable code, imo.
The pattern where you do something some way because it just makes sense, and later discover it's called "X pattern".
I use them all the time. You often know there will be one and only one of something. If that assumption turns out to be incorrect, refactor. No big deal. Something like a simulation of ships on planet earth, there's going to a single ellipsoid model of earth and a single database of shorelines, and probably a single RNG. I see no reason not to have these as statically initialized, globally accessible things. I'm writing a tool for specific purpose, not some super generic framework. You can still have certain testable functions and methods take the "globals" as arguments and use different inputs in your tests.
&gt; If I need a singleton, I use static instance variable in a singleton getter function. that's global variables, just hidden a bit because else their initialisation would not be thread-safe 
I didn't knot about flatpack, thanks for mentioning it here! I haven't been able to figure out from their doc what compilers one can use. They talk runtimes and SDK environments but don't specify what versions of compiler and libraries are in there. Or maybe I just can't see it.
sometimes, old APIs which take raw function pointers to register callbacks or handlers of some sorts don't take additional pointer to a context so you have to have a global at some point if you want to use some state in the callback.
I think my newest favorite is constexpr Compile time DSLs FTW
To avoid that problem I guess you would need to assume that any code you write inherits its life expectancy from the codebase it is written in. Meaning, there is no such thing as a temporary fix on a non-temporary codebase. I imagine such a rule to be too strict for practice though.
I’d love an example to go with this if you have time. 
I think this article is quite shallow. It should at least show the most common usages of the comma operator in a template metaprogramming context, where it can actually be quite useful... 
It's `flatpak`, not `flatpack` :) And you can use any compiler compatible with Linux ABI. On Linux, we can mix libraries compiled on any version of GCC or even clang :) You have to only be aware of 32 and 64 bit architecture, but that's not a big deal.
&gt; I still struggle with basic RAII techniques Well, the core thing, to me, is that in C++ you don't do: auto x = CX(); x.set_something( y ); // x can be used now, because it knows about 'y' you do: auto x(y); This means that there are less states for x, you don't have an x without the associated y. It also means that you can't change the y. It also means that any cleanup about the y is done in the destructor of X. If, for instance, 'y' needs to be aware of its usage by 'x', you don't do: void CX::set_something( CY *y ) { y_ = y; y_-&gt;in_use(); } and CX::~CX() { y_-&gt;not_in_use(); } because you have many bugs (for instance, if you forget to set_something you will crash, or if you set it twice, you will miss one). Also, doing everything in the constructor means you can use references, and have simpler code: CX::CX( CY &amp;y ) : y_(y) { y_.in_use(); } CX::~CX() { y_.not_in_use(); } with no bugs. You also don't have the tempation of writing: bool CX::set_something( CY *y ) { y_ = y; return y_-&gt;in_use(); } if y can only be used by a single x, because you cannot return anything from constructors: you use exceptions, and your CXs are always correct. You get rid of inventing things like ```x.is_valid()```, or having nullable instance variables if you can avoid it. At the end, for me, it is mostly about making sure everything is done at construction, cleaned at desrtruction, with no half-constructed states. The resulting code is much more robust and completely exception safe. 
Here's an interesting look at a contrary opinion http://number-none.com/blow/john_carmack_on_inlined_code.html
**Company:** [**Quantlab**](http://www.quantlab.com) **Type:** Full time **Description:** Quantlab is a dynamic, technology-driven firm supporting a large-scale quantitative trading operation across a wide range of global financial markets. Founded in 1998, Quantlab is an established presence and one of the pioneers in quantitative investment management with a track record of consistent profitability under varying market conditions. We support a very successful proprietary trading organization (similar to a hedge fund, but no outside investors, so we are much more stable). We invest heavily in the latest technologies, seeking to optimize performance and minimize latency throughout our trading systems. As the member of a software project team, you will be doing work that directly affects our ability to trade every day. You will work with a strong team of developers &amp; analysts that will create, maintain and support the tools and software that make up our mission-critical trading applications. On any given day you may find yourself doing the following: - Writing low-latency, high-throughput C++ routines and libraries - Building applications that leverage internal data to meet various reporting requirements - Analyzing enormous amounts of data - Learning how exchanges work; learning how trading works; learning how Quantlab operates. Our ideal candidates bring many of the following attributes to the table. - You’re up to date on modern C++ standards and have been using C++11/14/17 professionally or in your personal projects - Many years of experience optimizing low latency code for nanosecond latencies - Have worked on the full stack including high speed network design, firmware, kernel modification, compiler modification, and distributed system design - Several years of experience writing code using BDD/TDD processes - Thorough understanding of and experience with Continuous Delivery and Deployment - Are able to teach and elevate the team with existing knowledge - Experience in the automated trading domain **Location:** Amsterdam NL **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++11, C++14, C++17 Linux, Boost experience a plus **Contact:** If interested, [apply here](https://app.jobvite.com/j?cj=oSny6fwD&amp;s=Reddit_-_Who's_Hiring_C++_Devs_-_Q3_2018)
With the conditions you specify, yes you’re correct. And in general, it’s less of an opt-in than C# or Python. 
Extra tricky: int square(int x) { return x*x; } int main() { int x = 5; int y = (x, square(x)); int z = x, square(x); return z; } y is 25, [but z is 5.](http://cpp.sh/93aew) You can hate me, but I've used this to write code like int filter(source, predicate, dest) { int count = 0; for (auto x : source) if (predicate(x)) count += 1, dest.push(x); return count; }
Check out [https://github.com/Apress/design-patterns-in-modern-cpp](https://github.com/Apress/design-patterns-in-modern-cpp) The [http://wiki.c2.com/?DesignPatternsBook](http://wiki.c2.com/?DesignPatternsBook) was all the rage back when it came out. Then people got a bit *too* excited about it (particularly the Java crowd) and people got really tired of seeing "class FlyweightWidgitFactoryMixinProxyFacade" everywhere. This led to design patterns being disparaged for a decade or so. But, the idea is still valid even if Singleton is not an excuse to paper over global mutable state.
Well, I think "a breeze" isn't the right word, library certainly needs a C++ wrapper, because it's interface is non C++ friendly, at least non "modern C++" friendly for sure.
http://rapidjson.org/md_doc_sax.html
This is considered bad practice? I think it's a great idea.
I'm not sure where I heard it's bad practice—I personally use it a lot. But I've been using it under the impression that it's not good design.
whats the advantage writing it like this?
Probably someone who just didn't like the idea of defining "another type?!" I think it's a good idea, especially if it's easy to come up with a name for the type. Of course it's a bit subjective since there's the question of "how many arguments before you put them into a struct?" I feel my threshold is maybe six or so.
One of the very few legitimate cases for mutable globals, in my opinion, is keeping track of the loading/unloading/initialization/cleanup of shared and foreign libraries that need an init/cleanup call. This includes thread local and DLL/so specific init/cleanup as well. You can hook and access the global in the load/unload phase.
terseness
no need for braces after if ()
One thing I wish we had is something like `std::unique_reference&lt;Window&gt; m_window;` Where it's essentially the same as a unique_ptr, except it must be initialized in the constructor with a Window or object which inherits from Window. It's only reducing the cardinality of m_window by 1, but it's an important 1.
**Company:** Disbelief **Type:** Full time **Description:** Disbelief is a game development studio focusing on contracting and consulting services. We’ve worked with both AAA and independent studios to help their projects ship. Notable projects we’ve worked on include Gears of War 4, Borderlands: The Handsome Collection, and Perception. At Disbelief, we’re problem-solvers, first and foremost. We like to dive in to figure out the reasons something isn’t working before fixing it. We take pride in solving problems others can't. We value a sensible work-life balance and work environment. We work with leading edge technologies to make them perform at the top of their capabilities. Currently, we’re looking for a senior programmer. This opportunity is for a full-time position in Cambridge, MA or Chicago, IL. Senior programmers at Disbelief are leaders and developers in their project. You should be comfortable working independently and with a team to develop, test and integrate software into a larger codebase. A key responsibility is mentoring and guiding fellow programmers to improve. *Key Responsibilities* * Clearly communicate your work to others * Mentor fellow programmers in and out of your team * Communicate with clients on team progress and problems as they arise * Debug code with precision * Estimate your and others work * Assess impact of issues on schedule * Diagnose and solve performance issues * Document your code * Study version histories and code documentation to solve present problems * Implement features in innovative ways *Skills and Requirements* * BA/BS or MS Degree in Computer Science, or equivalent experience * Excellent communication skills, both verbal and written * 3-5 years of experience in writing software in C++ * 5+ years in game development, or 10+ in a related industry * Experience working on a large code base * Experience with version control with P4, git, or equivalent * Experience with multi-threaded systems **Location:** Cambridge, MA or Chicago, IL **Remote:** No, but we do enjoy working from home up to two days a week, when project constraints allow. **Visa Sponsorship:** No **Technologies:** Most of our work is C++ of varying standards with a sprinkling of other languages as needed for tooling. We do a lot of graphics programming work, using shader languages and platform graphics APIs. Since we often are debugging the lower levels of systems, being able to read x64 or ARM assembly is useful. Primarily we work with Unreal Engine 4, but we also work with Unity and custom game engines. Our work uses rendering, physics, audio, VR, AR, and other APIs frequently. Our primary platforms are PC, Xbox One, PS4, Switch, and VR/AR devices. **Contact:** jobs@disbelief.com
Job security.
😂
The counter-example is, of course, std::string. It has 200 member functions, and yet many are missing (like split, etc). Should std::string have an unlimited number of member functions - ie everything you might want to do with a string? Obviously not. So you need to draw the line somewhere. A good place is somewhere _near_ "do you need access to members?" and "would it be really hard/awkward/inefficient to do outside". Sure, size() could be external, but a bit awkward, and very inefficient for, say, list. In "normal" code, there is a secondary, and worse, problem. Not only do you add member functions because "this seems related to that", but you then add member variables as well "shouldn't this be part of class Foo?". And then classes grow without end. Free functions help curb the ever growing class. So it is all just variations of the Single Responsibility Principle. And actually, that's probably the most useful software design pattern, if you can call it a pattern.
SRP (Single Responsibility Principle). Is that a "pattern"?
Yes, I hope it catches on.
ah, guess I should up-vote this.
It depends on what your workflow is like and what you’re used to. I haven’t used it yet on any large projects or with any complicated make files but I love it for the stuff I’ve used it on. That also might be because I also very used to IntelliJ.
Since people are naming editors that are written in C++, I think it's fair to mention mine! nedit-ng, it's a modern port of nedit! http://github.com/eteran/nedit-ng 
Use Visual Studio and stop inventing bicycle and so on
What are some real world problems that have been solved with overloading the opeartor, ?
They have a trial some time ago. Give it a try if it's still there.
I use it and I like it a lot. It certainly has been worth it as far as I'm concerned, mostly for how well it integrates with clang-tidy.
Fewer curly braces and one less line if you'd otherwise put the closing curly on its own line.
I understood "making it a Qt Creator plugin" being "a worse experience" to mean that it's harder to make a plugin for Qt Creator than VS. Perhaps I erred there. The user experience in Qt Creator vs. Visual Studio is nowadays comparable in many cases. For a custom language (meta shell), Qt Creator would be a much more compact and easier to manage solution for most *end* users, I'd think.
Visual Studio on OSX is totally different than the Windows one so I'm not sure I'd suggest it if you must use OSX
That's good to know! One less nightmare on the list :)
Comma operator gained another use case with C++17. It allows handily to express generically calling a function template over all objects of a parameter pack using a fold expression: ``` template&lt;class T&gt; void foo(T&amp;); template &lt;auto... ts&gt; constexpr void foo_for_pack() { (foo(ts), ...); // ^ comma operator } ```
Make that int an atomic instead and one day a junior dev is going to make the mistake that the operation to dest is thread safe too because "they're on the same line". I don't know what it is with people who avoid braces. I've been nailed in kernel by countless copy/paste goto out_unlock/free errors or "this code doesn't have extra newlines after this one line if statement" dispose of hours of my time. Not worth it.
I'm not an expert, but I use a global mersenne twister random number generator. I think it's the simplest method to use the new random number distributions that want one. At the beginning of the program you can seed one for each thread and it works flawlessly for multithreading. Passing rngs to methods is annoying if you ask me and doesn't give you a maintenance advantage.
after language server protocols, any text editor can be an IDE grab vs code and cpp extension and you good to go, why using a full IDE when you can do with a generic text editor 
&gt; Qt Creator vs. Visual Studio Why would either of those be a better experience than what was provided? 
I do use it exclusively on a large (relative term) project, professionally. I wish I was allowed to use KDevelop.
Handy tip. Take a ++.
I was under the impression that your example uses the language's built-in comma, not the comma operator.
There is always need for braces after if ().
singletons are just worse globals...
Awesome. Thanks!
What does it bring over virtually any other ide? My colleague is crazy over Visual Assist, a paid plug-in that adds features built-into every ide. It's pretty slow to start (OK, not that important), and cmake support is... Dubious imo. And it's not on Linux but that's another issue altogether 
I too feel uncomfortable omitting braces except when the whole expression is one-liner.
RAII is for tasks that you always do in pairs: do something, and eventually undo something. RAII ensures that the undoing will always happen, automagically. So anytime you see something that requires a "do"+"undo" pair, with guarantee that "undo" happens, you implement it as RAII. The task pairs don't need to have anything to do with managing resources. As a very trivial and not necessarily useful example, suppose that you're using a method that is easier to comprehend when written as if some indices were 1-referenced instead of the usual 0-referenced: void C::my_method() { restorer r1(index1++); restorer r2(index2++); // ... do something here using 1-based indices instead } // you're guaranteed that the indices are back to their previous values here template &lt;typename T, void (*restore_fn)(T&amp;) = nullptr&gt; restorer { T &amp;val; std::optional&lt;T&gt; prev_val = {}; public: explicit restorer(T &amp;val) : val(val) { if (!restore_fn) prev_val = val; } restorer(T &amp;val, T &amp;&amp;new_val) : val(val) { if (!restore_fn) prev_val = std::move(val); val = new_val; } restorer(T &amp;val, const T &amp;new_val) : val(val) { if (!restore_fn) prev_val = val; val = new_val; } restorer &amp;operator=(restorer &amp;&amp;) = delete; restorer &amp;operator=(restorer const &amp;) = delete; restorer(restorer &amp;&amp;) = delete; restorer(restorer const &amp;) = delete; ~restorer() { if (restore_fn) restore_fn(val); else val = std::move(prev_val.value()); } }; If the method were to modify the
That and the article side steps the terminology [sequence point](https://en.wikipedia.org/wiki/Sequence_point), which helps clarify and aid memory retention of the comma operator. The article also neglects to mention that the commas that separate function arguments are not a sequence point. eg `foo(a, b)` is not a sequence point. It also doesn't go on to mention that because the comma that separates function arguments is not a sequence point, the order in which function arguments are called is undefined. eg `foo(a(), b())`, say both function `a` and function `b` modify the same global variable. Because of this, the output is undefined.
My experience is apparently different that other peoples'. I write plenty of dumb bugs and I'm sure that I've had few mistakes due to lack of braces. But, in the decades I've been coding, brace bugs happen so rarely that I can't remember the last time. At this point, braces are irritating, unnecessary noise to me. Especially when I see people filling screens with 1-line if statements spaced out into 5-line attention breakers. if (test(x1)) { doThing(x1); } if (test(x2)) { doThing(x2); } if (test(x3)) { doThing(y3); } if (test(x4)) { whatWasIDoingAgain(x4); } It's one of the many reasons I like Python. I also like [https://marketplace.visualstudio.com/items?itemName=Poptart911.TinyBraces](https://marketplace.visualstudio.com/items?itemName=Poptart911.TinyBraces) so that I can work with teams without angering each other ;)
This article doesn't mention how to defend against overloaded comma in generic code. When the expression's value isn't needed, `++i, (void) ++j` is a visually pleasing defense. (`(void) ++i, ++j` has j's incremented value, but writing it as `static_cast&lt;void&gt;(++i), ++j` is less likely to confuse humans.) This works for three subexpressions: `++i, (void) ++j, ++k`. (You'd need another cast for four, but there are no occurrences of four subexpressions with hijackable commas in our STL.)
https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/
Yes. Yes. It certainly does happen. And, if I ever write something as important as Apple's SSL, I'm going to be using formal verification rather than brace formatting standards to keep hundreds of billions of dollars out of risk. Meanwhile, did you spot my brace-related bug?
Sequence point is an outdated term, it's not being used in C++11 and newer standards. 
You mean the x3/y3 confusion that would be completely identical if the braces weren't there?
That's incorrect (ignoring the C++11 overhaul of "sequence point" terminology into "sequenced before" etc., and [C++17 expression evaluation order](https://wg21.link/p0145r3)). Given `c = foo(a(), b())`, the order of evaluation of `a()` and `b()` was unspecified, not undefined. Unspecified means that the compiler has to do something reasonable, but it doesn't have to do so consistently, or document its choice. There's a guarantee that function calls aren't interleaved, so either `a()` will be called before `b()` or vice versa, and both will finish before `foo()` is called. So, it is perfectly fine for each of `a()`, `b()`, and `foo()` to read/write a global variable (with the unspecified ordering in mind).
Also: if you want reference-counting, replace `in_use()` with `ref()`, and `not_in_use()` with `deref()`, assuming some relevant implementation of `ref()` and `deref()` methods. E.g. `ref()` and `deref()` could forward to `lock()` and `unlock()` on an `std::recursive_mutex` if such was the desired function. Thus the overall pattern is very flexible and easily adapts to different semantics of acquisition (`in_use`) and release (`no_in_use`).
That kind of bug is much easier to spot when presented as if (test(x1)) doThing(x1); if (test(x2)) doThing(x2); if (test(x3)) doThing(y3); if (test(x4)) doThing(x4); You can actually see the break in symmetry when you aren't scrolling through a screen full of whitespace to read a few statements.
I used CLion closer to when it was originally launched and I really liked what it was going for. It worked decently well at the time and my main attraction to it was its use of CMake as its project files. I like Visual Studio, but my biggest issue with it for personal development is how it uses its own "configuration" via its solution and project files (of course this is mitigated when using CMake too). I personally need an IDE when developing C++. The people who don't have their own workflow. I go to encppref on a daily basis, there's no way I can remember all the small details. Having an IDE helps fill in some of those gaps is really fundamental to my workflow. I love VS Code, but its C++ extensions are lacking and I have had only problems with the CMake-Tools plugin. My recommendation is to try it out. As an added bonus it apparently has a good Rust plugin. 
It is just a few lines (yep!) worth of a patch to clang to add a pragma that makes all automatic variables `const`. It is not all that usable since there's no way to "un-const" them then, but adding support for `mutable` as an "anti-const" when the pragma is active is also IIRC a few dozen lines. Probably not all that much more for g++ either. Not nice if you want portable code, but this could be done with a source-to-source transformation that removes the pragma, emits explicit const, and suppresses the new use of `mutable`.
&gt; I love VS Code, but its C++ extensions are lacking What would you like to see?
Not a pipedream at all. A clang source-to-source rewriter implementing this is not a big deal. A few pages of code, literally.
I don't know how this is so low, abstract factories allow for the component based architectures that power almost everything I have ever worked on. They're also the foundation for dependency injection. 
My approach is effectively: leave the campground in better shape than when you found it. If I have to make some edits to an area of my legacy codebase, I make my edits, then try to modernize it a bit. I don't try to do it all at once, because that would probably be suicide.
Qt Creator, just as VS, are shells, i.e. IDE building blocks. Why reinvent the wheel? It's trivial to customize Qt Creator to include exactly the components you want and no more - i.e. it doesn't have to support any other programming languages etc. if deployed as a stand-alone IDE. But the metashell support is still a plugin under the covers, and can be inserted into a full install of Qt Creator to add metashell support :) So - win/win!
I guess it depends. For me, Vim and its plugins(YCM, ctrl-p, Ag, etc) are suffice. I also used VS studio, VS code, eclipse, emacs, etc before but vim is faster. VS studio/VS code are good at debugging though. 
Well, if you're working with this code then it's probably in use somewhere and it works to some degree, no matter what shape it is in. So if you're going to rewrite anything, it would be a good idea to start with adding tests first to avoid making matters worse. This can be time consuming though, so first get some kind of clearance from your whoever you report to.
Wait so when you copy an image into the clipboard, linux and windows convert it to something else? I didn't know that.
I'm in a similar situation with my job (although we use C#). We refactor where we can - if I touched file A and file A is horrible, I do what I can to clean it up. You should do the same thing - although as another commenter said, adding tests to make sure you're not breaking anything is a good first step 1000 line functions can probably be broken up into smaller functions. That's a decent place to start 
I won't claim I read through the entire proposal, and honestly it's evident a great deal of work went into this and it's overall impressive... all I can say is that at a glance, this appears to be a very specialized library for those who want to squeeze out every last bit of performance when doing IO. While that's good... and this is an impressive library that I could see myself wanting to use, I don't see that this is something that belongs in the standard library and I don't think making major changes to object lifetimes in order to accommodate this library is justified. I'm not a member of the standard's committee so honestly my opinion could very well mean nothing, but I think before something like this should even be considered for standardization, there should be an implementation available that provides like 95% of the benefits and functionality for people to use. Just like there's the range-v3 implementation, and boost is available as a pre-standard repository, perhaps it would be best to implement this and see how it's actually used in practice before committing to making the major changes and work needed by the standard committee to actually vet this.
Are you talking about the ugly hack using the comma operator to expand a parameter pack? That isn't necessary any more since C++17 fold expressions. 
Windows uses its bitmaps with premultiplied alpha for RGB values (so we might lost some information in the copy/paste) and programs must be prepared with some special code to handle Alpha channel correctly (Chrome uses [a kind of heuristic for this](https://cs.chromium.org/chromium/src/ui/base/clipboard/clipboard_win.cc?l=652&amp;rcl=c2174d8b05d5e7002579e0dc8ac6f65d1279f222), and we do something similar); and Linux can use any file format (png, tiff, etc.), we use png at the moment (which uses non-premultiplied RGB values, so you don't lost information).
Any idea what the new terminology is?
The Qt Creator IDE is a pretty good, free option too.
If there is branching in those functions based on a global variable the c is unspecified as well. I know different compilers execute every function in order, but because it is unspecified, it is still imo noteworthy and could have been in the article.
I think most people looking at the cpptools repo want to be able to use Visual Studio solutions as well. I'm not the user above, but my personal thing is that I want to be able to debug it while using a different compiler than the Big Three (yes, they existed, and yes, it'd be great to have IntelliSense for them). Possibly them adding ARM support. Another thing the cpptools thing lacks is that it CANNOT be used for intellisense when you have custom defines, so for instance let's say you're making something with a custom compiler for a different platform, you're stuck with the default defines for whatever platform is already there. You can't change them. So let's say the size of a LONG LONG is different on this platform, you can't change that macro. So that's essentially the big issue I personally have. The user above probably meant for his personal thing is better CMake integration for cpptools, seeing as he apparently is complaining about the Cmake-Tools plugin...
I've used CLion for work and personal projects every day since launch. It's my primary C++ IDE, and I wouldn't try to work on too big of a project without it. I use emacs every day; but for me, getting IDE-level features out of a text editor requires too much configuration and maintenance. I want code navigation, inspection, and refactoring features for medium-sized projects. I want the features integrated together. And I don't want to maintain a bunch of different packages and personal settings to do it. In 2014, when I started a professional greenfield C++11 project, CLion was legitimately the only IDE available on Linux that could support most C++11 features without just a zillion red squiggles everywhere (at the time, most *compilers* weren't keeping up even). We wanted "normal" IDE features on cutting edge code, and it was the only game in town. I tried literally every IDE I could find, including Eclipse, NetBeans, QtCreator, Komodo, and a bunch of other ones I can't recall right now. CLion was the only thing that didn't suck. Since then, commercial IDE makers like Microsoft and Qt have put a *lot* of effort into properly supporting modern C++. So I don't think CLion is the only game in town anymore. But as it's matured, I've continued to like CLion quite well and have had little reason to investigate further. It's gained better support for newer C++, and hasn't gotten too slow for me to use. It consistently finds usage and definition even for templated or `auto`'d code. CMake is widely used and sucks considerably less than other widely-used build systems. If you like IDEs and work mostly in C++, I'd say CLion's an excellent choice.
Is it a contrary opinion? He focuses specifically on manually inlining single-use functions that deal with shared mutable data. Why? Because his domain happens to be one where the codebase does a lot of state mutation and needs to be correct/predictable at runtime. He also mentions that he's not encouraging the use of duplicate code to avoid functions. Users should avoid making functions rely on large mutable scope states. Users should look for opportunities to deduplicate work (think semantically, not syntactically). Aim for functions to be pure (no internal state, output is dependent only on inputs) and idempotent (no side-effects when used).
As ironic as it would be, what about giving weapons a friend function to agents that reduces health by the amount? I know some people dislike their use, but it seems like a pretty succinct way to give weapons access to damaging an actor.
I'm a boring person, so PIMPL it is for me. It feels like this is the one that would result in the most pain if it didn't exist.
Perhaps its not I was reading between the lines when you said &gt; Maintainers do not have to reverse engineer single multi-page lengthed functions Certainly a good thing if there is a lot duplicated code but not inherently better if the code is stuff that happens only in that function. Perhaps I should have responded to the comments saying &gt;The basic rule I like to follow is "a function should fit on the screen". Because I don't think you should ever use an arbitrary metric like that to decide when to split code up into multiple functions.
Also, how does it compare to Qt Creator?
&gt; &gt;The basic rule I like to follow is "a function should fit on the screen". &gt; &gt;Because I don't think you should ever use an arbitrary metric like that to decide when to split code up into multiple functions. This was not me.
I know that's what I said. &gt;Perhaps I should have responded to the comments saying
Gradually refactor where appropriate rather than rewriting. Rewriting code is very attractive initially, since it allows you to avoid having to read, comprehend and work with others' code, but it often ends up being a much more expensive endeavor than anticipated. There are likely years of lessons learned and subtle wisdom hidden beneath all the legacy cruft.
How about an anonymous namespace(holding private members/data) inside of a public facing namespace? You now have a singleton that exists for the entire duration of the program.
A wholesale rewrite is a dreadful idea before you are at the point where you understand the existing code very well indeed. Also you'd better have your requirements documentation (and ideally regression tests) in good shape before you start a rewrite, or the rewritten system either won't meet its users' needs or will be buggier than the original.
Sweet sparkly Jesus, that plugin might have changed my life.
Sure, http://eel.is/c++draft/intro.execution#8
This sounds like it's not so much a problem with legacy code as it is with poor software development practices. I've worked with a lot of clean, concise code that just happens to be legacy code. I'd nibble away at small repairs first, but don't touch the architecture without serious consideration. Here's why: you don't know all the things that are happening with the code out in the wild. You almost certainly don't know what data is being pushed through the code, and you don't have detailed information on how people are using the systems. If you do happen to have this information, then you might be able to nibble on some architectural fixes as well. Note that poor software development practices have nothing to do with the C++ version you're using. You can do an equally bad job in any version of the standard.
&gt; this appears to be a very specialized library for those who want to squeeze out every last bit of performance when doing IO It's definitely a different programming style than what has been standard library until now. However: (i) I believe C++ is evolving closer to the metal in any case, so more of this kind of library and those meeting latency preserving design guidelines might be expected in the near future (ii) nobody is expecting that ordinary users will use this stuff directly, rather it's a foundation on top of which to build a Ranges and Reflection based iostreams v2 later on (iii) this is probably the first proposed standard library to have been designed from the beginning with Ranges in mind, so basically Ranges does all the interface and what the user sees, and calls this underneath. For when you need to drop to the metal, this is available to you, but otherwise you can probably ignore it almost all of the time - if we get this right. &gt; How popular is this library in practice? Are people using it? It's niche, definitely. But people report bugs to me. So somebody is using it. I've deployed it in a few consulting gigs, clients were generally astonished at the performance they had no idea was available. The fact we never allocate memory, never copy memory, and never synchronise really lets the hardware's raw power shine through. &gt; What's the consensus among the actual users of this? It's a design meeting the feedback from a 2015 Boost peer review. So it's not just come out of nowhere. The design has had a lot of input since 2012. &gt; I'm asking this because I'm kind of curious to know why everybody isn't already jumping on it and using the library as is? Until now, most storage problems have been solved by throwing complexity at it e.g. DBs, extra cache layers, etc. It's become increasingly evident that doing less is faster. I can throw together a toy transactional key-value store with this in a few hundred lines of code, and it'll do 2.5M lookups/sec/core or 700K inserts/sec/core. That's with no caching, no DB, no in memory store. Just straight to the filing system. Less complexity = less work = faster. https://github.com/ned14/llfio/tree/master/programs/key-value-store But it's definitely a mindset thing. Storage folk are very, very conservative. They won't do a new thing until it's least a decade old. Ask the Intel PMDK folk about how slowly people have been picking up their library! Ultimately though this is a proposed base for further standard library work. It standardises nothing newer than POSIX.2008, which is very widely implemented now. We'll see if WG21 likes it, or not.
 I did fill out the survey, but I am not sure it rightly reflects my use case for globals. I need them in baremetal programming, for `volatile` variables that can change inside an interrupt service routine or even by someone flipping a switch (switch changes voltage levels, that changes a CPU register to which I hold a global pointer). For this you have to have `volatile` globals. If it's a pointer to a read-only register you can have a `const volatile` global pointer, but that's a special case and not something you declare\*. &amp;nbsp; \* Pointers to registers are a part of the standard library for the target architecture, so it's not a programmer's concern if they've been declared `const` or not.
CLion chokes for very large projects, such as what I use at my company, or if you try to code browse the Linux source code. It freezes for a very long time, constantly consumes much CPU, and can't find all the references. I recommend SlickEdit IDE for getting a friendly IDE. It can handle these large projects. It is costly, but very worth it.
It is also a bit of an old article. The real win from the article is to make more pure functions (as you mention). Then the "mutate everything" function can be: { member1 = f(asdf); member2 = g(qwer); member3 = h(etc); } That point gets lost in his other points (and because, I think, he didn't lean as heavily on pure functions when the blog was first written).
As a rule of thumb, rewriting is not the recommended approach for junior engineers. 
I don't know... having basic support for memory-mapped IO would be a good thing even if you aren't looking to squeeze maximum performance.
Thanks for your comment! I found it very helpful.
The fastest way to start building in your case is probably as simple as installing GCC/Clang; maybe adding a MakeFile if things start to get a little bigger! I think beyond this for a small linux project, it might be beneficial to learn CMake. CMake will make it easier to build lots of source files and it will help keep your code able to build cross platform, even being able to generate Visual Studio solution files, Unix MakeFiles, etc. Resources for CMake are a little weird at times but I've found the [Professional CMake](https://crascit.com/professional-cmake/) book to actually be very helpful. (I'm not sponsored in anyway, nor do I get any cut. I bought the book and actually got quite a bit out of it). Of course it might also be a good opprotunity to learn some C++14/17 concepts. There are a lot of great books on that but I personally love Scott Meyer's books.
It is a decent IDE and works very well if you are a CMake user. The sale price is pretty nice but it is still a subscription which is why I won't buy it. Qt Creator is also very nice with the bonus of it being free. On Windows I still prefer Visual Studio Community. 
I really like CLion, how the IDE works, the editing experience, the continous static analysis in the background, how it relies on cmake (not 100% anymore tho) etc... However I don't like the occasional performance issues on big project and the fact it uses a lots of memory. It got significantly better over the last 2 or 3 years I have been actively using clion at work and on personal projects, but be prepared to give the IDE lots of memory and tweak the JVM settings to have a smooth experience. Also, they have an amazing rust plugin, if you fancy that. There is a 30 day trial, free version for open-source devs, so give it a go.
I have been searching for newer resources as well but haven't found any. I implemented some mixins myself and found that some of the problems plaguing early mixins can be solved by using C++11 features, making them a lot easier to use. And they combine well with runtime-concepts, which give them runtime polymorphism without the need to add weird interface wrappers as before.
Visual studio is awesome as long as you work on windows. Some of us don't.
My talk is [I'm falling in love with Globals](https://cppcon2018.sched.com/event/d20ac5d13ff3673289c3e15e73ca222a). I will likely make mention to your talk during mine for information on linking, as I only have 30 minutes (I will be presenting another longer 60 minute one at another conference, however its not announced yet). My primary goal is to share why Globals are used, how they can be useful at times, and then when to absolutely avoid them. I'm not promoting Globals everywhere, instead showing that they can be a useful tool in the toolbox to use, but use them wisely and always think twice and plan them properly.
This is very interesting! Thanks for the comment!
const auto &amp; x[] = { x1, x2, x3, x4 }; for (auto &amp; v : x) { doThing(v); }
We can certainly argue, if all those overloads are actually necessary, but what exactly would have been the benefit of making all those string member functions free functions?
&gt; I wonder if I'm putting myself at a disadvantage by not buying into an IDE for C++? Most good C++ IDEs are free software. Qt Creator is in many areas as good or even better than CLion.
Eh it is often still useful. A small example: template &lt;typename... Ts&gt; auto print(Ts... ts) -&gt; void { ((std::cout &lt;&lt; ts &lt;&lt; '\n'), ...); }
&gt; It's flatpak, not flatpack Oops :-D Cool, awesome that it works with any gcc/clang. Might give it a go! One thing that I perceived a bit negatively is that on Ubuntu you have to add a ppa which very much sounds like a personal repo (`ppa:alexlarsson/flatpak`). This looks quite amateur-like, and with personal ppa's, you'll never know when the day comes when the one maintainer doesn't maintain it anymore. It would make a much better impression to me that if you want to be a professional project, you had a "professionally looking" ppa, like flatpak/flatpak or so, maintained by the project.
&gt; if the touching object is of class Deer With proper inheritance, you should never have to ask yourself this question. The base class should have a function definition for the action you wish to take, and each base class should implement the behavior that apply to them. For example, instead of a fireShotgun() { switch on target type... } You should get fireShotgun(Target&amp; target) { target.shotByShotgun() } And each of your class that inherit from `Target` will implement their own `shotByShotgun()` with their proper response. &gt; get all objects of class Deer in the world There is this other pattern(or anti-pattern because it is often misused), that could help with that. [The Object Pool](get all objects of class Deer in the world). With this pattern you can create a single focus point that could hold all your object of a certain type and subtype (e.g. `TargetPool`). With this class you could then implement function like `getAllTargetInArea(const Area&amp; area)`, and you could template it to get only target of certain type. Disclaimer, I never worked in the video game industry, and thus I don't know if these are proper practice in the trade. Maybe these method have downsides that I don't know about.
&gt; In "normal" code, there is a secondary, and worse, problem. Not only do you add member functions because "this seems related to that", but you then add member variables as well "shouldn't this be part of class Foo?". And then classes grow without end. Citation needed. I just don't see the relation between feature creep and free vs member function.
Yes! Well worth the investment.
Does the premultiplied alpha happen with `CF_TIFF`, or only with `CF_DIB`/`CF_BITMAP` and cousins?
You know, people might actually use better variable names? or arrays? your so-called "break in the symmetry" shouldn't exist in the first place. Are x and y the same type? Is there a reason that `doThing` doesn't just check `x` before it decides to `doThing`? I find this example unconvincing.
I'm going into my 3rd year working on completing a project that has been in flight for over a decade (yes, we're actually going to complete it. It isn't vaporware). Before people say "hey that isn't THAT legacy!", many of the infrastructure pieces and custom libraries are even older than the project (20 years old would be a conservative guess at the mean age on some core components). Total LOC is not as insanely high as some might expect but it's still several million lines last I heard. And today the project has never been in better shape. When I joined I felt a lot like your post sounds. Custom Linked List implementations (among other std container parallels), Undefined Behavior, C++98 style code, premature optimizations, etc abounded. It was a nightmare. The ramp up time for a new hire (regardless of experience level) was something like 6 months. My recommendation is to do what my team did: 1. Relentlessly hunt down dead code pathways. Keep pulling on strings until the whole sweater unravels. 2. Identify code and patterns that uneccesarily raises the skill floor on the project with the intention to either replace it or heavily document it. 3. Pursue toolchain and tool upgrades. Better compilers will at the very least give better diagnostics. Better IDEs will help developers to navigate the code more efficiently. 4. Enable as many warnings as you can stomach and turn on -Werror (or the equivalent for your compiler). Obviously this will require any preexisting warnings to be cleaned up to get compilation going again so it may take a team effort depending on the number of warnings you uncover. 5. Delete anything that isn't code or function headers/short comments. If you open a file and feel suddenly claustrophobic that's a good indicator that there's too much garbage. 6. Ban non-essential macros. 7. Be more vocal in code reviews. Have everyone on the same page that a code review is expected to be highly critical and it's nothing persobal. Every comments deserves a reply from the author. Additionally, use the number of questions on a code review as a high level indicator of the maintainability of the code. If there are tons of questions on a review, there will be tons of questions when it is time to maintain it. Hope this helps. I'll add anything I might think of later.
I use them all the time. My code is code that makes other code.
Isn’t that a fold expression?
Tests as mentioned are a good idea. Otherwise I find your comments a little hard to follow... surely they are not random hex numbers. Are their STL containers or not? What is the history and function of this code? 
They don't require the user to actually have qt creator or VS?
It is - a fold expression folding over the comma operator. 
\&gt; Im just frustrated with the legacy code. I would guess that you're correct and the code and the technical leadership is a mess. Your problem is psychological. You need to accept that you are there for the next year or two to collect a paycheck while figuring our your next move. I would not worry about improving the code much or agitating for change. That is not your place and you will most likely just manage to rock the boat to no good end. Make the assigned fixes and enhancements without too much concern for maintainability (clearly that's not valued) and leave at 5pm on the dot. Make your primary focus an evening masters degree, or whatever. Take a better opportunity when you find it.
I used CLion and I recommend it. However, I found that it used A LOT of RAM. In the end, I just ended up using Sublime Text 3 + Plugins + CMake.
I love CLion. I've tried many different IDEs, and honestly, I don't know how people can stand them. CLion is the one IDE that made C++ programming a joy rather than tedious for me and actually helped. That being said, there are times where CLion is slow, and we're not even talking big projects. I have a 20k LOC project and sometimes CLion grinds to a halt when I'm using boost. Still, I can't recommend it enough. I never thought I would pay for an IDE, given how many are freely available, but I was happy to pay for CLion.
I know you don't prefer it, but Windows' VS2013 (and I'm sure the later ones too) are great for C++. It'll set stuff up for you pretty easily.
I think a reasonable middle-ground would be to have a compiler warning for something that could have been declared const but wasn't.
Yeah, the advice shouldn't be "const all the things", it should be "use `const` wherever possible".
Oh this is cool. I guess in an ideal world, it should be really easy to convince anyone to pick an editor with LSP support as long as we'll have stuff like auto completion anyways. I am slightly worried people will want to use &lt;insert editor that does not support LSP&gt;, though I don't even know if any really exist. CLion seems to have a nice plugin for it. It would be nice if all of this stuff (cquery, IDE support) were generally more widely accepted, but I think this is better than what we're dealing with right now. I suppose the only other concern I have with it is the ability to run multiple at a time. Right now, we have at least two projects that require different compilation environments in different docker containers. Do you know if cquery can support two different instances running on the same machine for different projects?
If there is systemic neglect/laziness among the more seasoned engineers and management I agree. However, sometimes other people also have similar thoughts but aren't leaders. Starting a discussion and gauging interest among the team may reveal that there are in fact people who want to improve the working experience in the codebase but either have no idea how to start or are too timid to speak up and voice what may seem like an unpopular opinion.
The older compilers are not standard conforming, but [the current one is](https://blogs.msdn.microsoft.com/vcblog/2018/05/07/announcing-msvc-conforms-to-the-c-standard/).
I recently moved from clion or qr creator, and don't regret. Qt creator it's free, it's snappier and faster than clion (clion is in Java) , does not freeze nor crash (clion was freezing and crashing for me), and it works smoother with larger projects. 
You can still assign to it through a non-const reference if that is what your returning. I would still count this as a global its just behind a an accessor/getter function, it's also backed by a global as it's using a static instance variable.
BTW, thanks for the heads up on this! Since I'd already bought a license to CLion, I decided to buy licenses for the rest of the JetBrains products, all for only $56.75. Nice!
Oh yeah... it is RAM and CPU intensive. It'll drain my laptop battery in short order.
No IDE is fine, but stuff gets obscured easily with templates. I recommend cquery for vim/emacs, or the MS extension for vs code. I'm also a fan of CMake. It's weird, but it makes things way simpler, especially for cross platform. Check out vcpkg too if you end up working with 3rd party libraries. Building C++ projects is historically a mess. CMake has become somewhat of an informal standard, but lots of (especially older) projects use other build systems, so you pretty much learn whatever your team uses. I'm not familiar with containers, but if you're only using the stdlib, just install clang or g++ and then uninstall it when you're done, although having a C++ compiler is pretty useful even when I'm not actively working in C++.
Yes, they still have a 30 day trial. When I was looking for a C++ IDE, I spent that 30 days trying to love NetBeans, Eclipse, or Qt Creator, because the idea of paying for an IDE felt odd. In the end, I couldn't program happily in C++ without CLion, so I gave in and paid for it. I love it.
CLion's debugging capabilities are, IMO, one of its strongest features.
That would certainly be nice to have!
Most platforms support "delayed rendering" of clipboard formats, where the provider (the app you copy from) just gives the OS a callback to generate a given format, and the OS only invokes the callback when another app asks for data in a specific format. If major benefit of that design is that you can support a ton of different formats really cheaply, because no data is converted until somebody asks for it specifically. Also, every platform has ways to get data in any image format, if the provider supports it. The windows bitmap formats described here are just the ones old enough to have fixed format IDs. If you copy a jpg in a web browser, you can totally get the unmodified bytes of the jpg through the clipboard without any conversions, you just have to ask for the right format. 
Now back on: https://bugs.chromium.org/p/chromium/issues/detail?id=821270#c14
Most of the time you don't want to limit yourself to a single instance of data. A couple decades ago (Let's see, 1998, yep, couple of decades,) I might have tried justifying using a singleton for sound hardware (For example.) That'd have started causing problems for my programs as early as 2005 or so. Now it's common to have 5 or 6 instances of sound hardware on a system. Just because you just have one today, you won't necessarily always want to. And it's mostly ever used as a way to have global variables while trying to hide the fact that you have global variables. Everyone's on to that by now. So really just make a static factory object if you need to get a generic instance of an object and hold it as part of some other object's state for as long as you need to. That always seems to work pretty well.
Do you have documented requirements to the code? Oh right all undocumented. Well then spend at least 3 years understanding every aspect of how it works and the business model it's supporting. If it's still really that bad, write a proposal to rewrite it. Keep in mind that the business will only agree to do it if it's profitable to them in some way. Right now, you're a required expense. Do you want to possibly write yourself out of a job? While you're in the process of understanding it, you should definitely consider modifying it. If they're manipulating records in char arrays, consider making structures with the individual data elements. if it's crashy, bound string and array copies. If it's crashy, run it in a debugger and isolate crashes. If it's crashy, compile it with libefence and look for double frees and stuff. And write unit tests for everything! You're going to need them if you're going to re-implement it, anyway, right?
&gt; You will note that due to their triviality, memory storing trivial types such as std::byte can either be unconstructed, or fully constructed, and no lifetime state exists apart from those two. It is important to understand that currently speaking, using allocated memory in which nothing has been constructed is undefined behaviour, so the common method of reinterpret casting the return from malloc() to a pointer of the type you want is presently undefined behaviour. I can't speak to the whole paper, but I'm familiar with this particular example. This is hardly specialized; if you get some binary data in a buffer from a file or a socket that corresponds to some trivial struct, the current object model would force you to construct a trivial object and memcpy into it. Reinterpret casting is just the standard way to do things in this case. It's not a good sign when the standard way of doing something (to avoid the completely unnecessary copy) is UB and there isn't any good alternative to avoid it.
Formal verification is pretty much only done by NASA. I don't know if x&lt;-&gt;y was a bug or not; if you intend to repeat and want DRY you'd do `( filter(test) | doThing )( x1 )` or somesuch (algebraic over procedural). 
That's similar to the answer the other guy gave, but I submit it breaks OO design. The Actor superclass encapsulates what it means to be an object that can move around in the world. Why should it know what a shotgun is? Why should it's subclasses have to know? All the code for firing the shotgun should be in the fireshotgun() function. Nobody else should know anything about it, IMO. And IT is hard to maintain. Every time I add a new weapon, I have to modify the base Actor class, triggering a full recompile on the dependencies. Every time I change weapon damage, I don't change it in the shotgun code, but across twenty different files where they each have their own getshotgundanage overload. It spreads responsibility from one file to twenty. I absolutely agree it's not good to have a .classname field, but the solutions seem a lot worse than the problem. 
Haha. More like patches patching bugs made by patches elsewhere in the code. At least that's my experience.
No survey is going to be perfect, it would be good to understand what inconsistency you would expect? 
Usually, every single patch like that handles a subtle corner case which is not documented or part of an automated test suite. "Subtle wisdom hidden beneath all the legacy cruft" doesn't mean the developers were wise or that their code is exemplary, it means the results are good enough that we can live with the known issues and that latent bugs are certainly minor enough not to bankrupt the business.
Global variables can be thought of as being member variables of the application. If you're not responsible for the application as an entity, you can't make anything global. Assuming you are responsible for the application as an entity: use globals with care. Any code relying on globals is coupled that specific entity and it will require extra work to be reused, or even tested.
How about coupling? Even if those globals are `constexpr` they still hide dependencies.
Since it hasn't been said, I'll mention iterators. It's a GoF design pattern and is used pervasively in C++. (But my personal favorite is RAII, but that has already been discussed at length.)
In your Windows implementation, I noticed that you have a lot of handling for different types of text formats. Windows actually translates between them automatically, so you only need to check for one of CF\_TEXT/CF\_UNICODETEXT/CF\_OEMTEXT. [More details here](https://docs.microsoft.com/en-us/windows/desktop/dataxchg/clipboard-formats#synthesized-clipboard-formats) If you only handle one of them, then you can just have text_format() return that one, and then you won't need to special case it in so many places. Overall, this is really good work! The one feature that I think it's missing is delayed rendering (I mentioned it in another comment). For the Windows implementation, it'll probably be a lot easier to do that if you switch to the OLE clipboard API, since it's more object-oriented and doesn't require plugging in to the wndproc.
FYI - If you interested in using bazel (a google build system), then CLion (along with other IDEs) have plugin support for it (may not be for the latest 2018.2 yet working, but for 2018.1.x definitely works). 
If you use VIM for editing, do you build on the command line? Just run the docker image interactively with -it in one terminal tab and bind mount your source, vim in the other. When you run 'make,' just do it in the container instead of the host. In general, I think IDE/Editor stuff should just live in the workstation for the user to set up however they like. Then the Dockerfile just needs to provide a build environment. If you use CMake, it's easy to get it to generate project files for whatever kind of IDE the user prefers, or many IDE's like QtCreator can read the CMakelists.txt file directly as a project file. If you really want to be able to do the build from the IDE rather than from the command line, just override the build command from "make" or whatever to "docker exec ..." to run it inside the container. There's no need to do the editor setup in a container because there's no reason to standardise it across developers. If you hire some maniac that prefers emacs to Vim, just lock him in his dark closet and throw him hunks of raw meat at lunch time or whatever emacs users eat, and try not to worry about what he uses to edit the code.
I believe metaclasses can help in this regard! See my lightning talk that touches lightly on this subject : https://www.youtube.com/watch?v=BUaEsoKRCcM
That's a good point, I remember seeing this trick once before and then forgetting about. Do you mind if I steal it for my cppcon talk? Happy to credit you if you like.
Autodetecting alpha like that is kind of janky as BI_RGB with biBitCount=32 is explicitly defined in the BITMAPINFOHEADER docs as having a ignored high byte in each pixel. That's why BITMAPV5HEADER with explicit alpha mask was required to create alpha-blended cursors in Windows XP. It's like putting multiline text with LF endings into the clipboard, which is also wrong but everyone does it including Visual Studio. 
There is never time for refactoring. But it is needed to pay off the technical debt. Talk to the seniors about what changes they would want. Perhaps some of the odd stuff is there for good reason. Then refactor/add comments in small steps every now and then. It is easier to win people over with “I fixed this, isn’t this a lot better?”, than “Can I please spend time on doing this work that doesn’t directly generate profit.” 
Yeap, Ubuntu always Goes theirs own path, they have snappy. I use Linux Mint which is based on Ubuntu and there is flatpak support OOTB. Also most major distributions already adopted it. That only makes me sad that Ubuntu did different.
&gt;It is easier to win people over with “I fixed this, isn’t this a lot better?” Totally disagree. If you show up with big changes as a junior employee to a bunch of old dudes milking the cow of some legacy product or internal cost center support thingy, you increase your odds of getting fired. If you find yourself in the situation of dealing with a legacy product or infrastructure, your job is to do exactly what is asked of you and nothing more, and plan your escape.
https://github.com/notepadqq/notepadqq/tree/master/src/ui Not a stupid question at all :)
You don't just show up. You talk to the "old dudes" first. See what parts they would want fixed but can't find the time for. And it was not a legacy product, but legacy code. Big difference.
CLion is pretty good, but it is missing a lot of what makes intellij great. They have a long way to go, but if they can pull it together, it is gonna be a good one.
I have to say I love it. It is much much faster than Eclipse which is a boon to productivity. My work is all using CMake, and Clion integrates really well and makes it much easier to have a bunch of different builds (Release, Debug, Clang, gcc) set up. Is it better than Visual Studio? Perhaps. But on linux and Mac, it's the best C++ IDE I've been able to find, and I sure have spent a lot of time looking. 
And people that put software on cars, airplanes, train systems, life support devices,...
Depends on which OS you are on. Since I mostly target Apple, Google and Microsoft platforms, I happily use their own IDEs. On GNU/Linux I tend to use Qt Creator.
RAII, yes we this pattern most, along with these below patterns. 1. Singleton pattern for handling configurations 2. CRTP for handling file reading or writing or such repeated tasks 3. KISS for code maintainability 4. Abstract factory pattern
I prefer to have a constexpr global referenced anywhere instead of magic values. Also, one can give a meaningful name to the constant. If it's a constant struct type, you can bundle many pieces of informations together or have some constant operation. Literally, the only (zero overhead) alternative to constexpr globals is magic values copy pasted in the code. 
I was looking exactly for that. Definitely gonna try. I really appreciate Your work, thanks.
Yes I do and would recommend it.
It's pretty good, or any IDE that supports C++ for the most part. CLion shines at finding declarations and definitions, so say you've got a mystery function and your code base is over 100 files large. Instead of manually searching you can hit cmd+b and go right to it. Is it worth the money? That depends. There are free alternatives just about as good. However, if you have the money CLion is quite good.
QtCreator has an option of importing external projects, you configure the source files, defines and includes yourselves. It works pretty good in my experience: there is an automated way to include all files matching some globs (*.cpp,*.h etc.), include directories are detected automagically. The project file format for external projects is very simple: three plaintext files with list of sources, include directories and preprocessor defines, so you can update it via scripts upon checkout or use a GUI for finding the newly added/removed sources.
It's quite easy actually. You can import the sources - "New File Or Project", "Import Project", "Import Existing Project". When it's done you have to go to the "Projects" tab and remove existing build step that invokes make and add the new one that calls scons (something like 'scons -j32'). You can also create custom "Run" configurations for your project. QtCreator will create a file called $project-name.includes which will contain all include paths that are used by the code model. You can add some custom code paths there.
nope, sublime + Terminal is quite enough for me
"a lot of STL containers" is a bad thing?
&gt; I'm wondering if it's something that will help me learn and use C++ more effectively? What do you mean effectively? In my experience, nothing helps learning C++ more in-depth than leaving those all-smart IDEs behind and using just a plain editor like vim and learning how to use the [reference docs](cppreference.com) and the build system. In my opinion shiny IDEs are for people who are experienced and want to type less.
you can mount a directory between docker and host or use sshfs, and you can do whatever you like
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
We have QtCreator and Visual Studio (and VS Code). Why would I buy an expensive IDE when I already have great tools for free?
This is the Q2 post: you want the Q3 post
What you describe is probably most commercial C++ code bases. Certainly reinvention of STL containers and of Boost facilities is extremely common throughout the industry, often obviously just-enough-modified-it-isn't-copyright-violation. As I've often said on boost-dev, the single greatest contribution of Boost is as a source of best practice to go study when doing a hacky local clone of Boost facilities, because it's just far too much effort in most shops to go through Legal to get approval to use a Boost library directly. Faster to do a hack clone instead. Generally speaking, the reason why your codebase hasn't been refactored is that there are good reasons not to refactor it. Those won't be obvious to a junior developer. It's one of those things which make a senior developer is knowing when to leave code alone :) Don't get me wrong, best practice is to continually rewrite perfectly working and debugged code. But only a very few places practice that. Most prefer to not touch debugged code except when unavoidable. Not long term wise, but often such code bases are on sustaining, their owners are basically looking to milk them for maximum revenue and not invest significantly in improving them. Such is commercial programming. It pays the bills, no more. Definitely don't expect to get any job satisfaction or pleasure from work.
Yes.
Care to share details of the JVM setting tweaks you’re using?
81 pages ? Is there a summary of what is actually being proposed with minimal word count (no motivation, no nothing: just API and its semantics) ?
I think rewriting them is when you don't have a good reason. 
You refactor files as part of other work? Are your tickets titled something like "Fix issue in file A, and do anything else you feel like"?
&gt;Definitely don't expect to get any job satisfaction or pleasure from work. Pah, too often this is true. I'm pretty lucky in my current role as we have freedom to do what we want as long as business needs are met beforehand.
&gt;nothing helps learning C++ more in-depth than leaving those all-smart IDEs behind In my opinion, the code improvements suggested by the all-smart IDEs are very educational. It is actually really nice to have modern C++ features unobtrusively presented to you in the context of the very code you are in the act of writing or reviewing. 
For stuff like code completion and YCM, I need the compiler to know project build settings. That's the concern. 
I'm already doing this... The concern is about having access to compile settings using tools like YouCompleteMe. 
Remember that what you think is obvious is not obvious to others, so one inevitably must present a rendition of the present state of things all of which you might consider superfluous, but others will consider mandatory background necessary before one can consider proposed design patterns or a proposed draft TS wording. The first eight pages consists of trends in hardware changes, much of which some people on the committee haven't had time to really consider, then followed by copious examples of use of the proposed API. That second part was by far and away the most requested missing feature in an early R0 draft. Lots, and lots, of people found it useful. I, and anybody familiar with directly calling `mmap()`, will find it tedious and repetitive with no value added. Which is why I didn't have it at all in the first drafts of R0. But as with all niche papers, what is obvious to you and me is not obvious to all. Finally, much of the paper length is draft TS wording in standardese. Those are inevitably a very low signal to noise ratio. One can usually replace ten pages of standardese with "use your common sense, dammit!". I fully expect any final TS to weigh in over 300 pages, much of it repetition and common sense. Such is standards writing. 
QtCreator is free and not *tainted*.
Thanks!
&gt; but I submit it breaks OO design It does not, this is one of the strength and pitfall of OO at the same time. If your abstraction is well formed, you'll end up with multiple sub-classes that hold their respective behavior that only apply to them, if one needs to change or added, then only their respective code has to change. At the same time, as you pointed out, if the base class needs to change, you end up with a ripple effect on all you sub classes and/or their users. That is why a well formed/stable abstraction is very important. &gt; The Actor superclass encapsulates what it means to be an object that can move around in the world. Unlike the other guy, the abstraction that I choose was of type `Target`. As a target, I can be shot by multiple type of weapon, and each of them as a different effect on me. I am not saying that this is the best or only way to reason about thing, but it makes senses. It not more logical to reason about how a shotgun interact with a target, than how a target react to being shot by a shotgun. And then, if you go full OO, you will end up creating new abstractions for almost everything in your program, weapons (area of effect and damage), armor (speed modifier, damage reduction), target (life, armor, weapon), interactible (door, elevator, mines). With OO, that is the way you would design thing, but as with every single design decision, is it the right one? Might not be. In your case, instead of multiple inheritance tree, a simple look up table would be a lot simpler. Imagine a 2 or 3D vector with each axis representing the weapons, the targets, and the armors. Every time the player shoot, you go lookup the right amount of damage in that matrix using the right indices and you get the value you want in constant time, no need for if's or switch case. You could also load that matrix from a file, so that you can change how thing interact without having to recompile. 
I'll skip later today to the technical spec and see if that helps.
I won't claim this is always true, but if there is a piece of text in there which seems utterly obvious and pointless to say, it's usually due to said piece of text being controversial within some parts of the committee. So, the zero copy principle is exactly one of those. There are those on the committee who feel that this principle is a bad idea, potentially a spawn of Satan, and must be stopped at all possible costs. And no, I am not joking. For them, that principle is a *bad design decision* to be kept away from the standard. Rather than weigh in on *that* debate, I simply state it as a general principle behind the design of the specification. It means that when people say "function X has an awful design" I can then reply "function X has a zero copy design, which meets general principle 6.5.2. Can you suggest an alternative design for function X which also meets general principle 6.5.2?" Does this make sense?
Nothing on Metaclass by Herb, and no presentation by Bjarne Stroustroup? Is everything already planned or are some conferences missing? Anyway, it will be extremely interesting like any years.
I have my own GPGPU version that can convert millions of strings at a time quickly.
looks solid
I'd like the syntax highlighting to be based off the AST rather than a TextMate grammar based thing, so it could identify valid locals, types in function signatures, class members, etc. Currently there is no specialization for them (e.g. all function signature elements are deduced as `meta.function.c` and all symbols in the function body are `meta.block.c`.)
Well it's up to the project (flatpak) though how professional they want to look on Ubuntu - nothing keeping them from hosting their packages on a project ppa and not on a personal ppa, is there?
I admit I haven't used an IDE for code editing for the last 4 years and "back then" IDEs weren't suggesting code improvements. What they were doing however was annoying to me. I don't like auto-complete, pop-ups and small icons appearing in the code, it distracts me. Also since I don't use IDEs I go to the docs when I don't know how to use some library object. And this proved to be a very useful habit as, while browsing the docs, I found things I didn't even know existed and that I would never have found with auto-complete. Also I prefer to also learn the why/how of improvements to the way I code, instead of it being presented to me in a ready form. But this is all an opinion, others might feel otherwise.
I did not originate that trick. No need for credit.
It's not a pattern *per se*, but "composition over inheritance" is something I live by.
Metaclasses are just an idea that has yet to be fleshed out in the next 10 years.
Keynotes are always added to the end. Both of them are speaking, but we don't know on what yet 
Yet another talk on Catch(2).
&gt;You can hate me Oh I will
Could you please share your ST3 setup in a quick summary? Thanks!
Thanks I'll check it out!
So, looks like you've got your own local reinvention of upcoming C++ standard libraries? That's nice and everything, but (a) why not use a more popular alternative to upcoming C++ standard libraries like those in Boost or Qt or (b) why not use the reference implementations of the upcoming C++ standard libraries themselves? What's the value add of your local reinvention?
I'm very interested in this; cquery is running inside the container and how is it exposed to the host? I did not see any socket options in the config parameters.
It's also useful for SFINAE since you can effectively test multiple expressions in a single `decltype`.
This will be streamed? I live far away from the event place.
&gt; and preprocessor defines This is the thing that is most worrysome, because our `-D`s differ between compilation units. Can it handle this some way? Is there some way to specify different flags for different files in a way that's easily scriptable by something that parses build output or the compilation database? And what about warning flags? Same story there -- we disable some warnings in some compilation units, so different flies have different flags.
My "problem" with this explanation is it doesn't address what I view as a significant hard thing about C and C++ projects, which are compiler flags. For example, for code completion purposes what define settings will be used when building the completion database?
If you have a shit load of RAM, you can use mine: -Xss2m -Xms2000m -Xmx8000m -XX:NewSize=256m -XX:MaxNewSize=128m -XX:ReservedCodeCacheSize=240m -XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow -XX:MaxJavaStackTraceDepth=-1 -Dawt.useSystemAAFontSettings=lcd -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine
&gt; Shouldn't a design document address their concerns and achieve consensus about the general design principles before writing the spec then ? &gt; (FWIW this is what the Ranges TS did in 2014 with N4128, and this is a large complicated TS that is actually being shipped) Ranges, in many respects, needed to be narrowed down from the huge range of possible designs. So one started with a general principles document narrowing things down, and went from there. That makes sense for a top level library. LLFIO is merely a set of wrappers around POSIX.2008. So the debate here is (i) whether to standardise into C++ which elements of POSIX.2008 and (ii) how thin/inconvenient the wrappers ought to be. So proposing LLFIO is kinda the opposite problem to how Ranges was proposed. There is no debate possible about the feature set, only about scope (which stuff from POSIX gets included vs left out) and presentation (API awkwardness). And of course whether the standard library ought to present such low level stuff publicly at all in the first place. &gt; To which they can answer: "There is no consensus about that design principle actually being good, so the proposal should evaluate alternative designs that do not adhere to it and convince us that this design is the best one". I think the real question is where to draw the line of "below this is low level", and whether library facilities below that ought to be standardised at all. That is of course really a philsophical/Direction argument, and just about everybody has their own opinion on that i.e. consensus is impossible. Some of the Networking TS supporters take issue with how far I take zero copy in LLFIO. But in my opinion, there are solid engineering arguments in favour of why LLFIO is right and Networking needs to be changed to match LLFIO. Winning engineering based arguments is much easier than design arguments, as they are empirically rather than philosophically based. Finally, there is a chunk on the committee who have vowed that mapped memory will never enter the C++ standard so long as they are alive. They have strong objections to it in any form whatsoever. So we'll never reach consensus, just a tyranny of majority opinion at best. &gt; We have seen this happen with graphics, coroutines, ... over and over again. I don't know how old the Coroutines TS is, but its probably at least 4 years old and people have not agreed on even the most fundamental design stuff yet, like on whether coroutines should heap allocate memory implicitly or not, so we might still not get coroutines in C++20. Absolutely agreed. Coroutines really ought to have come in two flavours, low level and high level. Then standardising them would be unproblematic. Gor tried to aim exactly in between both, and it's become a lot harder than it would have been otherwise because it upsets both camps, and leaves everybody feeling that the one flavour is unsuitable for anything. I'm trying to avoid all that by strictly building from the bottom upwards, whilst concurrently Eric and Casey et al build from Ranges downwards. We'll hopefully meet somewhere in between, and thus give birth to iostreams v2. It very totally could go wrong, we could miss each other by miles. But I've known Eric through Boost for a long time. I'm sure we can make it work. Getting something standardised is as much about choosing the right process from the beginning as anything. I have no idea if the process I've chosen is the right one, but I have chosen based on not wanting to repeat what has gone wrong for others. Hopefully this explains the approach of P1031R1 a bit more. tl;dr; it's *politics*! 
"tainted" ?
This probably can be refactored further to be me concise. There is one small mistake (that is easy to make) if you use lambda adapter in this fashion. Note that lambda captures "this" and the lambda capture lives on as a local variable of start() function. The operator() of the lambda will outlive the lambda. To fix this, make the lambda no capture by passing the this pointer explicitly. Something like this: void URLRequestFileJob::Start() /* override */ { [](URLRequestFileJob* me) -&gt; SimpleFuture { auto current_task_runner = GetCurrentTaskRunner(); auto weak_this = weak_ptr_factory_.GetWeakPtr(); auto file_path = me-&gt;file_path_; ... }(this); } 
Qt Creator is under GPL which is generally accepted to be free.
&gt; Tried to open up Tensorflow source and it crashed. did you use the official Qt builds ? the distro ones are generally fairly buggy
Psst, composite pattern :D
That's sort of what I was afraid of, thanks. Though it *might* be possible to just grab (almost) all of the defines across all files and just dump them into one big set, and set that project-wide.
I have no relation to the event, but I assume that videos will be posted to YouTube a little after the conference ends. [Past years' were](https://www.youtube.com/user/CppCon).
Is it just the committee-process that makes changes so slow/difficult to implement? If so, who are the usual committee members striking down changes? I imagine ones representing industries doing embedded or industrial work?
FWIW, I think that "use `-Wmisleading-indentation`" is a much *much* better solution to this problem than a coding convention of "use braces everywhere". The style guide where I work says that one-line bodies should not get braces, though that rule isn't always followed. I didn't like it at first (I've always been a "there should morally be braces" person), but I honestly think I've come to prefer that way. I do very little spare-time coding, but if I did more, I'd probably omit them in those cases.
It's just because C++ is the way it is: a big language that promises not to break anyone and can only get bigger. Adding a big feature is anything but easy, because there is a lot of variables to consider, and that takes time.
Because it's actually C and not C++ library? 
Nice to know the automatic conversion between text formats. I've to give a test if the conversion was introduced since Windows XP, in that case we could use CF\_UNICODETEXT as text\_format() (and the same for CF\_DIB for image\_format() in the Windows port). Anyway as we handle text as UTF-8 strings, we have to add the special case to convert text to back and forth between UTF-8 &lt;–&gt; wide strings. I have to investigate about the OLE clipboard API, actually that should provide a completely different API for the user too (with callbacks to convert the clipboard content on demand). I'm not sure if I want to make the API more complex, but it's a nice idea for the future (I've created [an issue](https://github.com/dacap/clip/issues/17) about this). Finally, the Windows impl doesn't require the HWND handler or the hooking the wndproc. We just do OpenClipboard/SetClipboardData/CloseClipboard and we are done. (Even more, I've seen that OpenClipboard [can receive nullptr](https://github.com/dacap/clip/blob/09e571a7df4610052d449f6dd1364bb194a83387/clip.h#L29) and that's just fine).
I use vim outside of Docker. I checkout my code on the host and mount it as a volume when I run the container. I did a talk about C++ with Docker at C++Now: https://www.youtube.com/watch?v=lmIc0MgWBEI Also check out CppDock: https://github.com/ricejasonf/cppdock
I usually modernize the code and the make my changes, so I can still split it up and the result should be easier to review.
**Company:** [Real-Time Innovations](https://www.rti.com/company/careers.html) (RTI) **Type:** Software Support Engineer - Full time **Description:** Simply put, RTI connects smarts to distributed systems. We seek to transform entire industries. Our hottest markets are today’s most exciting: autonomous cars, smart medical systems, green energy, unmanned planes. Our software smartly runs the largest power plants on the continent, connects perception to control in vehicles, drives the new generation of medical robotics, controls hyperloop and flying cars, and provides 24x7 medical intelligence to hospital patients and emergency victims. We are making the world greener, safer, faster, and flat-out cooler. Unabashedly, we are the best in the world at what we do. We are the best positioned small company to capitalize on the very real future of intelligent, distributed systems. As a software engineer in the Support team you will be triaging, debugging, and also writing code (bug fixes, customer use case implementations, example code, etc.). Some of the tasks that may be part of your day are: * Investigate, understand and debug customer issues. Work closely with our development and platform teams to find the root cause of these issues. * Find timely creative solutions to customer problems. This includes bug fixing and writing test cases based upon the customer use case. * Create, test and ship engineering builds, and patch releases. * Write best practices and solutions for our knowledge base. * Provide support status to the support manager and overall R&amp;D team. * Ensure our customers succeed with RTI technology. * Provide feedback to the development team to help improve our products. **Location:** Northern CA or Granada, Spain **Remote:** Yes **Visa Sponsorship:** Yes **Technologies:** C, C++, or Java **Contact:** Apply [here](https://boards.greenhouse.io/rti/jobs/1247799), then email [nicoleho@rti.com](mailto:nicoleho@rti.com)
I should give a try to the \`CF\_TIFF\` format, anyway if you want to communicate with copied RGBA images from Chrome, you need to do this trick.
Maybe it would help if the committee only didn't discuss things at big official meetings around the world, and decided to use this fancy thing called the internet to discuss things... which would also make it easier for people who don't have a ton of money/time to partake/be involved.
It is recorded but not streamed.
I'm not sure if there is a big number of programs using the CF\_DIBV5 content (e.g. to get a copied image from Chrome, you have to use the same trick they do with a CF\_DIB). Anyway [it's something to give a try](https://github.com/dacap/clip/issues/18).
We haven't announced all the plenaries. Herb and Bjarne will be giving talks of course. I'm not sure why you expect anything on metaclasses. Metaclasses are just an idea. The committee has not decided to go in that direction.
By un-workable you really mean you can't understand it, in which case, you can't rewrite it either. Such codebases never have basic design ideas explained somewhere, nor is the spec there (or is thoroughly false). Gradual refactoring is the way forward.
I use the existence of Python as an argument to people who claim that control flow keywords should be always followed by braces.
/u/Gortara Boost.Operators did very similar thing for older standards to simulate `std::initializer_list` 
AFAIK WinAPI is the API that is the least one satisfying POSIX
ISO C++ can only be defined in terms of other international engineering standards, and that is the portable operating system standard POSIX. Historically, WG21 pretty much completely ignored anything not POSIX up until the Filesystem TS, which make special accommodation for Windows' peculiarities. A controversial part of P1031 is that it is unimplementable on Windows using the Win32 API. It requires implementation using the NT kernel API which doesn't suffer from the problems and lack of facilities in the Win32 API. That means it can interpret filesystem paths as NT kernel paths instead of Win32 paths at (documented) times, and some people don't like that. I've run this up the flag pole with Microsoft, and in principle, they don't currently object, as one Microsoft engineer told me, push comes to shove they either expose the NT kernel APIs in Win32 shims like `GetFileInformationByHandleEx()` is really `NtQueryInformationFile()`, or they just call the NT kernel API directly from their standard library implementation same as the LLFIO reference implementation does, and call it a day. So, in short yes the NT kernel API does provide an equivalent implementation of almost all of POSIX.2008. They in fact had such a rich implementation fifteen years before POSIX got to standardise such advanced features, so they've had to do nothing until very recently. They have, in recent Windows 10 releases, improved the NT kernel's support for POSIX semantics still further, and the LLFIO reference implementation has made good use of that. What few differences remain between the NT kernel semantics and POSIX Microsoft are aware of, and are working on remedying. So tl;dr; yes, it's also a thin syscall wrapper on Windows. Only on less featured POSIX systems would an implementation need to actually do stuff e.g. hard link tracking. And for those, I believe we can bully their kernel authors into fixing their kernels for the most part, and I've got proposed user space template adapters for systems which refuse to fix their kernels. We'll see how things go.
&gt; Added impact on the standard regarding the proposed `[[no_side_effects]]` et al contracts attributes. By no side effects you mean pure functions? The functions which from math point of view are strictly only input =&gt; output mappings?
Don't use CLion on battery power -- or if you do make SURE you turn on the battery saver mode.
Yes, I'm proposing a contracts-modifiable standardisation of the `const` and `pure` GCC attributes in the form of `[[no_side_effects]]` and `[[no_visible_side_effects]]`. Note I've also extended contracts to be applicable to the return value, something they can't do yet.
Is this AST-based highlighting available in other tools? I'd like to check that out.
count++ would be smarter, but wouldn't illustrate the issue I was highlighting.
In very "tl;dr" it's: constructor does `new`, destructor does `delete`. You can't forget to call destructor, so it never leaks.
I'm in a project where we test firmware/BIOS stuff and our abstraction is so layered and RAII'ed that I need to dig 6-8 levels deep to find a pointer. Our tests are not "low-level" but rather "underground", yet I haven't seen it crash anytime. Meanwhile people doing some web/DB/frontend stuff in C# continuously experience `NullReferenceException`.
Don't rewrite. If you are not 100% sure what it does now, how you can prove it still works after? How will you document all those hex values if you don't know what they mean? Of course that doesn't mean you can't tweak a bit here and there. Just make sure the team is ok with that, and (ideally) show them a small(!) example of how much better things can get if you modernize a little bit. They are probably more impressed with a tangible benefit ("look, if you do like this it's only a quarter of the original line count!") then any expressions of software purity ("there may be ten pages of templates, but it saves a whole nanosecond in the wait loop!"). Actually some years ago I had the same problem: I inherited a driver that is full of hex values with no obvious meaning, and a structure that would make you cry. To this day I have no documentation, and no hardware access. The customer has not used the hardware for (at least) 15 years, yet somehow we pretend that driver is still a feature in the software - and multiple proposals to deprecate it have been shot down. My problem was that the driver actually controls three interconnected devices, and the other two are still in daily use - and they needed some significant work to add new capabilities. So, can you guess what I did? ...of course I rewrote it from the ground up ;-) But I'm a lead engineer, so I can do that. The other two devices are now in great shape. The odds of this one working I rate as poor, but the chances of it never being used again as fair, so I'll call it a win. 
[this meme](https://pbs.twimg.com/media/C0shWwKXcAAXVvA.jpg:large) is now going to another level.
I worked on a mesh adaptation code base in my first 8 months, written by lazy mechanical engineering phds who only knew to program in FORTRAN. 1000 lines is a joke. I saw some other 10,000 lines. I definitely improved my ability to follow code and understand intention. I made outlines on paper of the 'subroutines' and what they were doing. I asked around to figure out what the more esoteric 'magic formulas' were about. This is a generic problem, especially when management can't program. They hire others to deliver functionality. If the 'others' deliver it, but write shit code, then it doesn't matter. When you eventually get to working on properly constructed code, you will appreciate the hell out of it.
I'm being immersed by monadic style with variants and visitors #include &lt;variant&gt; #include &lt;vector&gt; #include &lt;iostream&gt; template &lt;typename... Ts&gt; struct overloaded : Ts... { using Ts::operator()...; }; template &lt;typename... Ts&gt; overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;; struct cat {}; struct dog {}; int main() { std::vector&lt;std::variant&lt;cat, dog&gt;&gt; v; v.push_back(cat{}); v.push_back(dog{}); for (const auto&amp; elem : v) std::visit(overloaded { [](cat c) { std::cout &lt;&lt; "meow\n"; }, [](dog d) { std::cout &lt;&lt; "whoof\n"; } }, elem); } It has 2 bige differences from ordinary vector of base class smart pointers: - in typical vtable polymorphism, each class separately implements a virtual function - in visitor approach you implement 1 function for each class together - variant avoids pointer indirection and unnecessary allocation - vector stores object directly within the variants , objects are at most with some compile-time offset I'm not sure about it's performance, but it't probably much faster than vtable approach. Plus visitor gets well inlined.
I really like the idea of meta-classes, but if I think about what I would use them for, it seems like a very complex tool to solve fairly simple problems. There's probably a simpler way to make types that have automatic serialization or smarter enums.
I am really missing an examle of "/content/{contentId}".
So, taking this from the paper: constexpr! void ensure_blessed(buffers_type buffers) { for(auto &amp;buffer : buffers) { bless(buffer.data(), buffer.size()); } } // This function has no side effects visible to the caller except // for the objects it creates in the scatter buffer list. virtual buffers_type io_handle::read(io_request&lt;buffers_type&gt; reqs, deadline d = deadline()) throws(file_io_error) [[no_side_effects]] [[ensures: ensure_blessed(reqs.buffers)]] [[ensures: ensure_blessed(return)]]; Note the `[[ensures: ensure_blessed(return)]]`. We are giving a contract that a postcondition of calling this function is that the side effects of the function `ensure_blessed()` on the return of the function occurs.
I intend to spin out anything which can be separated from P1031 as soon as they are mature enough.
Thank you!
Nice to know.
You can do Microbenchmarks, but you have to be really careful with your test data and make sure the compiler does not optimize stuff away that it would not when given real world data
When I was in the game industry the command pattern was one of those things that just made things click. 
I really would like, but i live in Brazil and i do not have(yet) financial conditions and time to travel. 
"Engineering is programming integrated over time. "A programming task is 'Oh hey, I got my thing to work'... Engineering, on the other hand, is what happens when things need to live for longer." \- [Titus Winters](https://youtu.be/tISy7EJQPzI?t=8m16s)
I feel like these "modern C++" and "modernize your code base" talks keep recurring every year. There so insanely many talks on this topic already...
Read this -&gt; [https://www.amazon.co.uk/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052](https://www.amazon.co.uk/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)
[Design patterns are from hell!](http://realtimecollisiondetection.net/blog/?p=44)
Well, if they want to have wider target, they also can host flatpak as a flatpak package! Oh, wait...
N4762 9.2.3.2 [dcl.ref]/5: "There shall be no references to references, no arrays of references, and no pointers to references."
&gt; "old dudes" will sometimes resist change of any sor Oh. If *that's* how your work place is, run. 
People parrot this "never rewrite" mantra, but to my mind a lot of software ages like a badly maintained building. At some point you're looking at a tear down, not a refurb.
You just had to ruin my fun.
Thinking more about memory area "blessings" -- at least on "POD" data: what would be tolerable, using widely successful existing practice as a reference, would be some kind of compiler memory barrier (that would be upgraded to a stronger barrier on shitty ISA where it is needed). Tracking all mapping addresses in application code is certainly not ok. Maybe it is insufficient for fancy things, but again, permitting fancy things shall not be done by breaking basic working practices and introducing *new* unachievable and dangerous constraints. And to be clear the argument that it is theoretically UB today would be inadmissible (at least in itself): did thread worked before they were normalized? Yep. Would a compiler have been complete crap if they broke it? Yep. Did optim attempt have been reverted when this almost happened? Yep (speculative writes). Same principle here. There is a HUGE difference in *practice* between what is today UB *only* because it is not standardized and basically ignored but merely in a way to let those who care handle it as an implementation detail (but an important one that needs to be handled correctly), and an explicit UB stated maybe in examples, which is taken as an explicit license to "optimize" (well sometimes I understand that even implicit UB are, but obviously I think this is a mistake, not something to encourage) 
&gt; Standardizing shared memory is potentially difficult. IIRC Linux and Windows have slightly different semantics and e.g. Boost use some weird mapping to platform calls to get Posix behavior on Windows (or was it the inverse?). IIRC sysv shared memory segments do not auto-destruct on last "handle" close (and maybe also shm_open - but I'm less sure); Windows Shm do. The proposed library can unlink on first close, via a flag. That causes the resource to be released when the last thing using it stops, with the same semantics on all platforms. Occasionally we can't avoid platform specific behaviour, but a careful boundary has been drawn to avoid exposing it whenever possible by not offering any features which make platform specific differences noticeable. &gt; About concurrent mappings being able to trigger UB if not manually "blessing" them (manually and without any mistake): throwing random UB at the problem in 2018 when platform behavior diverges is a big red flag. Not only I'd like to see an extremely detailed rational explaining why it absolutely can't be done otherwise (modulo things that are capable to make it work today, maybe depending on the platform, like critical sections or leveraging the memory model, at least on cache coherent platforms), but it would also be wise to add some text (scheduled for inclusion in the standard) explaining that it will NOT be ok to degrade current fine behaviors (on HW and OS were they currently are fine) into random compiler generated crap in the future. Where P0593 is taking us is that much of what just happens to work today via UB will stop to work in future language versions. Like when strict aliasing was introduced. That's separate and independent of anything in P1031. That's coming, irrespective. I'm not a compiler expert. The compiler folk are the most of those opposed to memory maps ever being supported in C++, and they have reasons I understand, and those I don't. I've done my best in the proposed changes to address those reasons I understand. I'll probably learn in the next few months what's deficient in my proposal based on the reasons I don't understand. WG21 is fairly on consensus that we want C++ to become formally verifiable in theory, and optimisable based on the availability of formal verification in practice. That means taking the current endemic and unavoidable UB, and more finely slicing it up. As much as there is a large chunk of userbase who feels the way you do - and I get where you're coming from - the current consensus is that you guys can stick with older language versions if you want to keep with the current object model. Future language versions will break some current working code without it being ported to the future language object model, and that's the price of progress. BTW I'd raise your concerns on the std-proposals link rather than here. More WG21 members read std-proposals than /r/cpp.
I'm genuinely curious, is it hard to get a package into the official Ubuntu repos? Sounds like it is nearly impossible? Or what is it?
I haven't been able to build GCC, even with MSYS changes, on MSYS for MSYS. I always get sporadic failures.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/93tilr/best_book_for_intermediate_to_advanced_learning/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ok, so I've come up with this code: void URLRequestFileJob::Start() { [](URLRequestFileJob* me) -&gt; base::SimpleFuture { auto weak_this = me-&gt;weak_ptr_factory_.GetWeakPtr(); FileMetaInfo meta_info = co_await CoroPostTask( me-&gt;file_task_runner_, FROM_HERE, FetchMetaInfo(me-&gt;file_path_)); if (!weak_this) co_return; me-&gt;DidFetchMetaInfo(&amp;meta_info); }(this); } base::PostTaskFuture&lt;FileMetaInfo&gt; URLRequestFileJob::FetchMetaInfo(base::FilePath file_path) { FileMetaInfo meta_info; base::File::Info file_info; meta_info.file_exists = base::GetFileInfo(file_path, &amp;file_info); ... meta_info.absolute_path = base::MakeAbsoluteFilePath(file_path); co_return meta_info; } At least there is no thread switches inside a single function, but this `co_await CoroPostTask(coro_arg, ActualFunction(actual_arg))` doesn't look pretty. And here is the future: namespace base { struct DestroyAwaiter { bool await_ready() { return false; } void await_suspend(std::experimental::coroutine_handle&lt;&gt; h) { h.destroy(); } void await_resume() {} }; struct SimpleFuture { struct promise_type { SimpleFuture get_return_object() { return {}; } std::experimental::suspend_never initial_suspend() { return {}; } DestroyAwaiter final_suspend() { return {}; } void return_void() const {} }; }; inline OnceClosure CoroBind(std::experimental::coroutine_handle&lt;&gt; h) { return BindOnce([](std::experimental::coroutine_handle&lt;&gt; h){ h.resume(); }, h); } template&lt;typename T&gt; struct PostTaskFuture { struct SharedState { T value; Location from_here; std::experimental::coroutine_handle&lt;&gt; this_coro; std::experimental::coroutine_handle&lt;&gt; outer_coro; }; struct promise_type { std::shared_ptr&lt;SharedState&gt; s = std::make_shared&lt;SharedState&gt;(); scoped_refptr&lt;TaskRunner&gt; original_task_runner = base::SequencedTaskRunnerHandle::Get(); PostTaskFuture&lt;T&gt; get_return_object() { s-&gt;this_coro = std::experimental::coroutine_handle&lt;promise_type&gt;::from_promise(*this); return {s}; } std::experimental::suspend_always initial_suspend() { return {}; } DestroyAwaiter final_suspend() { return {}; } void return_value(T value) const { s-&gt;value = std::move(value); original_task_runner-&gt;PostTask(s-&gt;from_here, CoroBind(s-&gt;outer_coro)); } }; std::shared_ptr&lt;SharedState&gt; s; struct Awaiter { TaskRunner* task_runner; std::shared_ptr&lt;SharedState&gt; s; bool await_ready() noexcept { return false; } void await_suspend(std::experimental::coroutine_handle&lt;&gt; h) { s-&gt;outer_coro = h; task_runner-&gt;PostTask(s-&gt;from_here, CoroBind(s-&gt;this_coro)); } T await_resume() { return std::move(s-&gt;value); } }; }; template&lt;typename T&gt; inline typename PostTaskFuture&lt;T&gt;::Awaiter CoroPostTask( scoped_refptr&lt;TaskRunner&gt; task_runner, const Location&amp; from_here, PostTaskFuture&lt;T&gt; future) { future.s-&gt;from_here = from_here; return {task_runner.get(), future.s}; } } // namespace base Well, that's somewhat all right for the library code.
What matters is how many times Make is told it needs to start from scratch when building the DAG. The way make is told about it's dependencies matters. The entire Microsoft Software collection is not large enough to justify a 10 min. wait from Make. Make only deals with strings of text and File date stamps. Did this project contain a large bunch of independent sub-modules?
What was the library you shared previously? I have been looking for game engine libraries recently.
And that's the kind of mindset that allows "legacy code" to be "legacy", instead of just "code".
&gt;leave the campground in better shape than when you found it &gt;don't try to do it all at once This should be known as the "legacy code dev's mantra."
Came here to post this. That book is a must-read for anyone working on a legacy system (which is pretty much everyone). I also found, [*Refactoring to Patterns*](https://industriallogic.com/xp/refactoring/) to be an enjoyable read.
Hey sorry for the confusion. I am just cross posting this but the Library is called mud. [https://github.com/hugoam/mud](https://github.com/hugoam/mud) 
Yes, It's a pure C library.
Oh, I'm sorry, I posted the wrong place. : (
I visited the site just now, checked it out, the code samples, editor and examples too. I have to say this software is way too raw to use for anything at all, even the examples don't work correctly. I like the concept though, an engine like this, if it were much further in development, would be really nice to have around.
 template&lt;class T&gt; void foo(T); template &lt;auto... ts&gt; constexpr void foo_for_pack() { (foo(ts), ...); // ^ comma operator } void bar() { using namespace std::string_literals; foo_for_pack&lt;42, "baz"s&gt;(); } Formatted for you
Well, the most problematic seniors are gone or hold less power now because we ended up just fixing stuff regardless of their objections and attempts to block it. Management didn't end up being too sympathetic to the old guard who complained, and as a bonus our team was given much more independence. I wouldn't recommend this unless you know that some extremely visible and important metrics will improve directly as a result of your change, like we were. Otherwise, you're just as likely to piss people off and get fired.
I feel the article is a very opinionated piece without much concrete evidence backing it up. I took a quick look at the example codes, and while it wouldn't go through a code review at our place, it's not horrible or super hard to understand either.
&gt; there are no standard library implementations that I know of where this doesn't work (feel free to find one if I'm wrong however). This is not relevant, I can write a std complying vector that does not do that f.e. because I want to be able to allocate power of 2 memory blocks only. Yeah svo would mess with that ass well, indeed not allowed, but it does/would in that case respect the rule for `shrink_to_fit()`.
``` const auto &amp; host = "www.google.com"; const auto &amp; port = 80; ``` Hmmm...
&gt; I took a quick look at the example codes Please look at section **8.2.1 Using File Stream Objects ** (p. 317), and tell me is it good to demonstrate the use of fstream in that way? Should the author make a shorter &amp; cleaner sample, without involving the "Sales_data" class? There are a lot of sample codes like that. Also, teaching HOW without WHY is also a big problem. You can view another [negative review from Amazon](https://www.amazon.com/gp/customer-reviews/RU9CX3UFOVAE0/ref=cm_cr_othr_d_rvw_ttl?ie=UTF8&amp;ASIN=0321714113)
This is exactly what the visitor pattern (aka double dispatch) is for. You have a `ShotgunVisitor` with a bunch of versions of `visit()`for each type, and then call `actor.accept(ShotgunVisitor{});` or similar to shoot it. This is slightly more code than a switch statement but IMO easier to maintain and more generalizable.
I don't own the book.
How are they non issues in C? I've seen more than one rant by Linus about aliasing and its relationship to C standardization.
I agree with that. But I react because, especially a for big codebase, people will underestimate the effort to rewrite to the order of magnitude and will fail to produce many of the things that existed (or change them), which creates friction with users.
How does it compare to crow (https://github.com/ipkn/crow), except the fact that crow's development seem to stopped?
&gt; re-writing without a shred of excuse a lot of STL containers and so on Are you sure they had no excuse? STL containers are not the ultimate solution, they are doing a good job in general, but there are countless cases when you can do better. You probably didn't have to deal with problems when the STL classes were the limiting factor. Yet. Ask the seniors, who worked on that code, to explain some of the decisions. Also, if the code is performance critical, you'll see many "ugly" solutions that you might not yet understand.
It's the recommended text at my college. The book is terrible for beginners. 
I referred to [this](https://www.reddit.com/r/cpp/comments/92vyty/rapidstring_maybe_the_fastest_string_library_ever/e39xr1t/) post a bit below.
But there are an immense pool of other problems that you could solve with metaclasses. You may have these two, I have others, some people others.... In the end metaclasses would make everyone happy.
This is a great book with a full introduction to the language, where I believe you are expected to do all the exercises as you go to get the most out of it (learning by doing and experimenting is very powerful). I used this book and learned a lot in a very short amount of time. The book is up to date (more or less) and has a lot of best practices and good C++ examples designed to get you to understand the way to think. Of course you must put in some work yourself to use what you've learned and apply it in your own project, but then that applies to all languages. \[ACCU\]([https://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1848](https://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1848))
Honestly, it was pretty good all things considered and one of the earlier texts that covered C++11 concepts well. Whether C++ as a language is suitable as a first programming language in general is up for debate.
can I use it with asio coroutines?
First one is ok. Second one is wut.
I have the same problem except I'm older. Don't rewrite because you'll introduce new bugs and remove hidden functionality. You're a "junior" programmer but it's the perfect opportunity to become way better than your coworkers: * document everything * refactor (when 100 lines are copied all over the place: create a function...) * automate everything (the build process, ...) * add unit tests wherever you can * switch old files from C to C++ (no bugs and you'll be able to use the STL inside later)
I primarily use CLion for a couple of years now, but recently briefly tried Qt Creator. Qt Creator is much more snappy (generally) and the code checks are more responsive. CLion has a more streamlined workflow regarding previews and popup windows, especially when using git. Some examples: * For a git commit, in CLion you simply click on a file and it previews the changes below. In Qt Creator, you click on the file, then click on "diff selected files" and then a new Git Diff Files view will show up - by default replacing the git commit dialog. * A git blame in CLion is just shown inline in the editor, allowing further context actions for each commit. In Qt Creator a git blame is a new view which will replace the editor - allowing no editing and contextual navigation. * Searching within all files in CLion has a preview while you type These are little things all over the place, a click here, a missing preview there. Some of it may also be personal preference or just a matter of habit. So I will stick with CLion for now. Overall both Qt Creator and CLion have hugely improved in the last few years. If I had either of their current versions 4 years ago, I would have been amazed.
\&gt; "1000+ lines..." Just be happy. Your first "1 000 000+ lines" of legacy code project is somewhere in your future, and that's will be a problem. 1000+ lines is just a nice little puzzle for a few hours to have fun.
Crow is also c++14. But anyway, I will check out your project anyway😊
This looks to me more like a diploma paper where he had to present something to get the grades and move along to a new chapter in his life. Nothing else.
The bold headings on the page explain why along with the chapter title. From page 317 like you mentioned: Chapter 8: The IO Library Why would you want to read/use this? To learn about input output facilities provided by C++. 8.2: File Input and Output Why would you want to read/use this? To learn the ins and outs of file io specifically in C++. 8.2.1: Using an fstream in place of an iostream&amp; Why would you want to use/read this? To learn about what the title specifies, but more thoroughly speaking they are trying to show you how to reuse code for iostream&amp; with fstreams. The idea is that you can reuse a lot of your code for iostreams on fstreams. Got a nice formatting function you wrote earlier in the book for iostreams? This part of the book is trying to explain how you can reuse that for file io. The specific example you're referencing even says effectively (paraphrasing): "Hey, remember those functions for normal io on pg 261 well you can use those for file io too like this" Is it good to use fstreams in that way? They are doing what the title says. Passing fstreams to functions expecting iostream&amp;'s is part of the intended usage of fstreams and iostream&amp;'s which is why they are derived from the iostream class. Fstreams are designed with this kind of usage in mind because it's nice to be able to use functions you already wrote for iostreams like cin or cout on fstreams. Should the author make a shorter and cleaner sample? It's only about 16 lines and the real meat of it is the usage of the read/print function with an fstream rather than an iostream. (which they give you a page number for in the paragraph above the sample) The code is pretty short and pretty clean already and a lot of it you can ignore so long as you don't mind flipping to pg261 to see read/print is defined for iostream&amp;'s but in the sample they are passing it fstreams. Should the author not use sales_data in examples? That's pretty debatable but I'm leaning towards no. It's important to see how classes interact with each other. Part of why you would want to use C++ over C is the ability to design and use your own libraries of classes together with other C++ language facilities to organize and solve problems. What you really need to know about sales_data is pretty minimal since the inner workings of sales_data is not the point. Also if you dig into the source code for it from chapter 7 (I checked the downloads from the books website) it's about 35ish lines of code which is pretty nice and short if you really think about it from the perspective of how gigantic a class can really get. If they make the code samples too short you wind up with code that doesn't describe anything useful at all.
No problem :) Good luck and have fun!
Some senior members of WG21 are between cool and freezing towards the whole idea. Each give different reasons, and there seems to be a lack of consensus as to why not at the present time. The only consistent block of opposition is from the compiler vendors, who feel that supporting mapped memory is highly problematic for their future plans for improving optimisation. I've tried to address what I understand of their concerns in the paper. There is another block of opposition who feel that mapped memory is too specialised, too low level to be in the standard. They want more high level abstractions like metaclasses, not low level stuff which would consume committee time better spent in their opinion on high level abstractions. 
 uint32_t pool_size = boost::thread::hardware_concurrency(); http::base::processor::get().start(pool_size == 0 ? 4 : pool_size &lt;&lt; 1); http::base::processor::get().wait(); It may be just me, but I find this very ugly. If you really really want to use a ternary operator, this would be better: uint32_t pool_size = boost::thread::hardware_concurrency() * 2; http::base::processor::get().start( pool_size &gt; 0 ? pool_size : 4 ); http::base::processor::get().wait(); (ie: we want twice the number of CPUs (probably because of hyperthreading). If we didn't got a good number, we settle for 4 threads).
Not sure what you're saying here.
Hey, I'm the author of the library. Yes, mud is the foundation on which toy is based (and is Zlib license), it contains most of the systems that are general to any application (not specifically games): the rendering lib, the user interface lib, the reflection system, the lua and visual scripting libs, etc... In terms of amount of code, 70% of toy code is in mud.
It does in theory but I don't have a mac dev machine, so I didn't look into it too much. I'm in touch with a github user trying to build on OSX, we will see how it goes.
The engine just reached maturity on the core systems, so development speed will actually speed up from now on, from a usability perspective. Also be aware that some issues in the examples are related to the maturity of the web build itself. I'm happy you see the potential in developing it further :)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/93yck8/good_resources_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's [undefined behavior](https://en.cppreference.com/w/cpp/language/extending_std) to add [a definition in namespace std](https://github.com/hugoam/mud/blob/master/src/math/Clamp.h).
This isn't bad practice, it's actually fairly common. Packing related args into a struct also makes it possible to use the [named parameter idiom](http://www.cs.technion.ac.il/users/yechiel/c++-faq/named-parameter-idiom.html), which I find quite useful. 
**Company:** [TRA Robotics](https://www.linkedin.com/company/tra-robotics) **Type:** Senior C++ Developer (Robotic Simulation) - Full time **Description:** We are engineers, designers and technologists, united by the idea of shaping the future. Our mission is to reimagine the manufacturing process. It will be fully software defined. It will be driven entirely by AI. This will mean new products will get to market much quicker. Now we are working on creating a flexible robotic factory managed by AI. We are developing and integrating a stack of products that will facilitate the whole production process from design to manufacturing. Our goal is complex and deeply rooted in science. We understand that it is only achievable in collaboration across diverse disciplines and knowledge domains. We're looking for Senior C++ Developer to become a part of the Simulator team in our new Berlin office. Simulator is a digital twin of the real factory. It should contain identical workshop, robots and machines, sensors and parts. It allows to execute and debug the control program of an assembly process before it gets to the real production. A technical designer should be able to get from the simulator a prompt feedback on whether a designed product could be assembled at the flexible robotic factory. Simulator does not only repeat physical features of the real world such as obstacles, friction, individual robot specifics, etc., but it should be also as photorealistic as possible. This will help to develop and tune part recognition systems (Computer Vision) and to teach AI systems. *Key tasks:* Development of the factory simulator on the basis of the Unreal Engine 4 (C++). Simulation of sensors (e.g. force control sensor, position sensor, camera etc.). Implementation of simulator interfaces for external systems. **Location:** Berlin, Germany **Remote:** No **Visa Sponsorship:** No **Technologies:** С++ (11/14, 3y+), multi-threading, experience with physics engines (at least one of PhysX, Bullet, ODE, Havok etc.) and physical simulation systems, Python, Linux. It will be benefit if the candidate has experience with Unreal Engine 4 or in robotics. **Contact:** Apply [here](https://www.glassdoor.de/partner/jobListing.htm?pos=102&amp;ao=376008&amp;s=58&amp;guid=00000164f5a0d8df95db675d982991dc&amp;src=GD_JOB_AD&amp;t=SR&amp;extid=1&amp;exst=E&amp;ist=L&amp;ast=EL&amp;vt=w&amp;slr=true&amp;rtp=0&amp;aa=1&amp;ea=1&amp;cs=1_27f8cec0&amp;cb=1533129316866&amp;jobListingId=2864875641), or email us: robot@tra.ai.
I think you can get OSX builds setup on Travis CI. It's not super straightforward, but it's doable. Let me know if you need help, maybe I can dig up the documentation.
Hmm you're right, that's a convenient way to to OSX stuff for someone that doesn't have OSX ! I'll look into it :)
Well, probably good advice, but not a silver bullet. Some scientific stuff with P_r = (P_t * G_t * A_r * sigma * F^4)/((4*pi)^2 * R_t^2 * R_r^2); in every line often ends up as an unreadable legacy. It's harder when this work based on different scientific articles with overlapping naming. Sometimes it's better to write a comment. //Radar Equation. More info https://en.wikipedia.org/wiki/Radar or in some worst cases step by step computation with comments. It can give very important context.
How would you feel about this `radarEquation(P_t, G_t, A_r, R_t, R_r) { return(P_t * G_t * A_r * sigma * F^4)/((4*pi)^2 * R_t^2 * R_r^2); } ` and then: `P_r = radarEquation(...); `
Relevant: r/https://twitter.com/KevlinHenney/status/381021802941906944
(Not OP) I was exactly was I was writing (but close my tab). I also think that the parameters names should be made explicit in the function (`transmitter_power` instead of `p_t`, …). And it should use strong typing with each variable type being an international system of unit. It's really easy to with template, eg: template&lt;int ampere, int kelvin, int second, int metre, int kilogram, int candela, int mole&gt; double SI { double value_; }; class 
Feels good. But my expample more about naming. There is can be situation that only one function can be more 200 lines of code and no possible to separate it to a small ones. And intermediate results just some complex vector3 with no meaning in physical world.
Nice catch :) You were quite thorough to find that one ! Clamp is `c++17`, it was convenient to add it in std so it can be used when compiling with std&lt;17, but I could fix that with a using declaration somewhere instead.
Maybe we should look at naming the variables better, first :)
1. Too many comments destroy the code readability. 2. If a piece of code needs comments to explain, think again and may rewrite it. Code should be self explained. 3. Some kinds of code, such as non-intuitive algorithm, or temporary code, or hacks, may need comments. 
Agreed 100%. Also, even when optimizing your high-priority code, splitting into smaller functions is better than using comments. The reason is - when your code has small functions with good names, it’s so easy to spot actions that can be removed from the main loop, stuff that can be done only once instead of constantly calculating, or just variables that don’t need to exist in that scope. After you’ve done that, it’s way easier to safely micro optimize and remove those function calls when they actually add to your overhead (which is not often).
I mean, both are okay. It's a bit odd but it will work because of lifetime extension rules.
I disagree that they're named poorly. If you're going to understand this code you're going to look at the equation in a math context, which the link helps with though it would be better if it were more specific: https://en.wikipedia.org/wiki/Radar#Radar_equation and if you're reading it both forms it's nice and convenient for the variable names to match up.
&gt; It's not an easy task to derive intermediate types especially when comes up std::vector and std::complex &gt; work becomes more like write DSL for this task, but not sove the task (not all scientists are very good in programming). Not every scientists need to writes those types, only one guys who creates the lib that everyone will use. And if you think it's a lot of work, the NASA lost millions multiples times because one team was using metric units, and the other imperials, … 
I need a very simple hello world that shows the functions (read,write) to implement (with GPGPU stuff). What if I want this in windows?
&gt; Simple &gt; GPGPU Good luck with that
What if GPU part is ready?
The most basic thing is: Describe **what** you are doing (or **why** you're doing it), not **how** you are doing - "Ask, don't tell" kinda works for comments, too. I unironically find "increment the counter" in code sometimes. Or "The descructor." above the destructor. Well duh.
allocating memory puts it in RAM you just need buffers by the sounds of it GPU memory is separate, and requires copying between device and host And depends on which brand of GPU
You can try to use [Dokan](https://dokan-dev.github.io/)
So a quick google for "Windows Open Source Ramdisk" shows me that this isn't close to trivial and isn't really going to be C++ because this is really low level kernel driver work. If you need a ramdisk I'd just compile an existing one for your OS.
Wow Dokan looks really cool, thanks for pointing to it!
Can I use this api directly in any C++ project? Callbacks were what I needed. https://dokan-dev.github.io/dokany-doc/html/struct_d_o_k_a_n___o_p_e_r_a_t_i_o_n_s.html#a92457133b49740e54142183f90efd723
if you are targeting C++14, is there are reason that you are using `boost::function` and `boost::shared_ptr`?
please read the rules in /r/cpp before posting.
Yeah.. rewrite it so you can re-create all the bugs that those thousands of lines of code are testing for. That never turns out good.
[This](https://github.com/prsyahmi/GpuRamDrive)
Crow doesn't require C++14, however, which is very helpful to those of us stuck dealing with Linux distros which barely support C++11. 
This.
The problem with rewriting it is that you would need to understand what it does. I suppose it's not properly tested either.
He's saying that people who only do the ticket and don't clean around it when doing it rarely clean at all. But it's as simple as creating a second ticket to separate the cleaning, really.
A good rule of thumb. Imagine you're a fresh graduate and assigned this piece of code and asked to explain what it does and what the visible side effects should be. Basically, all code should be written like this no matter the language. If the code isn't self documenting, then document, but always prefer self-documenting code.
You can build/debug C++ on Linux from VS on Windows today
Visual studio ? The community edition is free.
What are you looking for in a build tools docker image beyond this? [https://docs.microsoft.com/en-us/visualstudio/install/build-tools-container](https://docs.microsoft.com/en-us/visualstudio/install/build-tools-container) Regarding the tedious manual setup what are you looking for help with there? Is it just automatic mapping of local source directories? The deploy of the container with sources to a remote build system for scale certainly makes sense. Do you see that as complimentary to build services from your source control system, or something it should be providing?
If only it were that simple. Among other things, I've had managers directly tell me not to waste other peoples time making new tickets, and reviews, for minor refactoring, and to just include that in other work. Merging multiple tasks into a single SCR and review is encouraged at a lot of places. Fortunately I currently have a management team that considers code quality, and ongoing adoption of best practices and language improvements to be high priority, so not only does no one question the motivation behind keeping the codebase clean, or including a few unrelated cleanup items in a review, but it's encouraged and expected, to the point that reviewers will point out opportunities for cleanup in a review proactively. It's quite nice. On the other hand: In the past, I've been actively chastised (as in: literally, not figuratively, yelled at) for proactively fixing bugs as I found them, and reverted the fix (I, of course, kept good discipline and separated the commits in SVN just so I could do that if needed). This organization didn't do code reviews, or SCRs. They accidentally had a build that run every night, but it was an accident and no one knew how the nightly build worked as the guy who set it up had already left for greener pastures. The specific bug in question involved a call to malloc (c language codebase) and free in a pattern derived from incoming network traffic. It was, among other things, a missing if statement to check the size of the allocation requested. Yadda yadda yadda, whatever. Long story short, I reverted my fix and later that week a customer ran into the same bug from the previous release build. Crashed their application, lost valuable production data. Manager-yells-a-lot didn't even give half-a-fuck. Just told me to deal with whatever the customer wanted fixed. I doubt he even realized it was the same thing he yelled at me for fixing just a few days before. Obviously I don't work there any longer, and that incident was a big reason for it. But while I agree with you in a perfect world, some organizations are dysfunctional. 
Does it let you visualize it as well?
If by "visualise" you mean watch program flow, see the call stack, and inspect variables' contents, then yes.
One approach a team I worked with took was to add a unit test to the function/class we wanted to refactor, ensure it passed, then refactored the code. So adding unit tests was part of how we modernized a chunk of code.
Visual Studio and CLion (which backs off GDB if I remember right) have pretty decent debuggers. If you can get VS Code to properly detect your environment, it seems to be able to integrate with a few different debugging services. https://code.visualstudio.com/docs/languages/cpp#_debugging
What do you mean regarding ARM support? The ability to use the cpp extension in VS Code on an ARM device like a Raspberry Pi or using an ARM cross compiler?
This would be better over in [/r/cpp_questions/](/r//cpp_questions). When you post over there, tell them your Operating System. I doubt a webform is not gonna be an option in C++. But software solutions are avaiable for [both](http://www.codeblocks.org/) [Windows](https://visualstudio.microsoft.com/de/vs/community/) [and](https://www.vim.org/) [Linux](https://stackoverflow.com/questions/24109/c-ide-for-linux).
I've not really used this, but maybe check out the [Data Display Debugger](https://www.gnu.org/software/ddd/)?
If you're a VIM kinda guy/gal I found this really neat extension called ConqueGDB ([https://github.com/vim-scripts/Conque-GDB](https://github.com/vim-scripts/Conque-GDB)). I used this with MacVim and I was really impressed with following control flow in VIM. You'll still have to be familiar with GDB so its not as "polished" as VS / VSCode, so beware.
Using an ARM cross-compiler, I see that 32-bit is on the roadmap soon though, so that should go through soon at the very least.
I've never come across the terms CADRe or SBRM except in the wikipedia article on RAII. SBRM and RAII are pretty awful names, but CADRe is a little palatable. I dislike RAII because it's not pronounceable, it doesn't mention how to clean up resources, and when I was a newcomer to C++ I knew what a constructor was, but I had no idea what initialization is. RAII also explains the concept backward to how I think about it (IIRA -- Initialization Is Resource Acquisition -- makes a lot more sense in my mind). CADRe addresses all these shortcomings, at the expense of being a nonstandard term. The big problem with CADRe is that it implies symmetry; it implies that if you have a constructor, you should have a destructor. This is the exact _opposite_ of what we're trying to achieve with RAII -- as a general rule, you should _avoid_ writing destructors. I don't know how to encapsulate this concept in an acronym.
The website you linked supports C++ as well...
[cgdb](https://cgdb.github.io/) and [gdb dashboard](https://github.com/cyrus-and/gdb-dashboard) are worth a look.
I hope you know this is not what I meant :)
The implementation isn't as good as for Python. That's why I'm looking for alternatives.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9404j4/what_is_hello_world_of_c_ramdisk/e3hlcln/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Bjarne is giving the Monday opening keynote, and I'm also giving a plenary (I think Tuesday). For my talk, I'm holding off on committing to the exact title and abstract for another ~month, but unofficially-not-committing: I'll likely spend most of my talk on progress updates to the Lifetime and Metaclasses work I presented at CppCon 2015 and 2017 respectively. Both have good progress to report. Both are also multi-year projects simply because they need bake time, especially metaclasses which is larger and involves multiple innovations -- it has been well received in SG7 and will probably be presented to EWG in the next couple of meetings; the gating factor for metaclasses is not committee time, it's design and implementation validation to gradually progress form 'experiment' to 'production ready' to 'standardizable' which takes time for major features (e.g., concepts took over a decade, I am optimistic this will be less :)).
Excellent. I'll give that a try. Thanks!
That's awesome ;)
&gt; The implementation isn't as good as for Python. That's why I'm looking for alternatives. 
No worries. Thanks for posting! That is almost exactly what I have been looking for XD. Saved me lots of internet research! Thank you :)
My favourite comment word is "otherwise"
It’s pretty much gdb with a GUI 
I prefer [cgdb](https://cgdb.github.io/) by far. It's basically gdb with a convenient view of the code (a bit like `ctrl+x a` in gdb, but with color, and much more convenient way to put breakpoints and navigate through the code. And you have the full raw power of gdb, with an interface designed to be used with a keyboard.
Visual Studio is pretty much the best in class, unbeaten today.
I hope you aren't saying `^` to mean exponentation :)
Or marking the inputs as `volatile`.
I used (Nemiver)\[[https://wiki.gnome.org/Apps/Nemiver/Features](https://wiki.gnome.org/Apps/Nemiver/Features)\] for a while before I just went full CLI.
Type `gui` in lldb. It's basic, but works.
IMO, cgdb suffers from the same problem as basically all of these other responses, which is that they're not "visual" in anywhere the same way as what OP seems to be asking. IDEs, GDB, cgdb, emacs, ... none of these visualize things anywhere close to [this](https://i.imgur.com/rG13GsP.png). I almost think almost no one actually gave the link a shot to see what OP was asking... DDD is the closest thing that *I* know of for C or C++ anyway.
Visual Studio supports editorconfig: https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference
how far behind the current C++17 standards is slickedit? And does it support CMake?
GDB actually has a built in text-based GUI. See: https://sourceware.org/gdb/onlinedocs/gdb/TUI.html
Are they ever going to make a linux version? I personally use Windows but I'm curious. 
I'd expect Mac before Linux.
 let factory = new badGuyFactory() let alien = factory.build("alien"); alien.setHealth(100); alien.setArmorStat(50); alien.setAttackStat(50); game.add(alien); &gt; This block of code does several things. The result is that it is difficult for programmers to easily understand what it does. I don't think this is a good example, because the code is simple enough and well-named enough that its intent is obvious. There are problems with this code (an alien can be created without having its health set), but they don't have anything to do with commenting. I'm removing this post because it isn't specific to C++.
On Windows 10 you might want to take a look at https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86
RAII and CRTP
Did you even try to find out for yourself before wasting everyone's time?
Use std::max to guarantee a minimum value. Far more readable
SlickEdit does support CMake, see: https://community.slickedit.com/index.php/topic,15318.0.html As far as current C++17 standards, I know they are constantly improving support. I put this question on the SlickEdit forum at https://community.slickedit.com/index.php?topic=16251.msg62479#msg62479.
A few issues aside from the code :: No license, and no cmake. 
I know but I mean VS community 
They have a Mac version out, or so I thought. 
I only briefly read through the comments but CLion by Jetbrains works well. In my opinion Visual Studio debugger is the standard but as a linux person I find Clion quite pleasant. Free if you have a student email but there is no community version I'm aware of.
Talk to your bosses and tell them what you just wrote here. Say that you think it will save time in the long run to rewrite from scratch. Note that this will be accepting responsibility for any bugs you introduce in the rewrite! And I can guarantee you there will be bugs. It would be a good idea to create a test suite that includes all of your real use cases, before starting on the rewrite. 
That sucks but that's what they get for buying an overpriced Mac. 
While I haven't tried it, [gdbgui](https://gdbgui.com/) looks like a promising candidate for being able to potentially do some of this. While it might not support all the same functionality its probably something that could be added
C Lion is a good IDE with a visual debugger, but it is not free.
You can use—and debug—with other compilers in the Community edition of Visual Studio. 
CLion
Does debugging with mingw-w64+gdb work properly?
Let me bing that for you: https://blogs.msdn.microsoft.com/vcblog/2017/07/19/using-mingw-and-cygwin-with-visual-cpp-and-open-folder/
Cool, I'll give it a crack sometime. Since I'm apparently out of the loop, does VS community have any good GUI builder options? I don't consider MFC to be good. 
:h Termdebug It comes with never versions of vim and even though it is experimental it has worked really well, better than any extension I have tried
https://github.com/facebook/folly/blob/b0eb4087eb0debfbfe3985c5465a703618d3b6d6/folly/Expected.h#L564
As many mentioned before me, complete rewrite is going to lead to disasters, and could make you look bad. Divide and conquer instead. Start breaking down mega-functions into smaller helper functions that are self-documenting.
Good point. I think for that project, though, I was only using the eternally pending boost::disjoint_sets. I suspect it doesn't pull that much in with it, but I could be wrong.
VS code is Microsoft's attempt to compete with Github's Atom prior to acquiring them. 
&gt; Correct me if I'm wrong, but it seems like we're going to need a quadratic amount of code - one struct for each weapon, and one method for each Actor subtype. Not if you just template the default behavior: struct damage_visitor : agent_visitor { int damage = 10; void visit(bird const&amp; other) final { damage = 20; } void visit(deer const&amp; other) final { damage = 20; } template &lt;typename T&gt; void visit(T const&amp; t) final {}
I’m still a little confused on why this needs to be done with a switch statement as opposed to something like an overloaded function? It seems like your problem is: “Do the same thing except specialized behavior for some finite set of types?” In which case the idiomatic answer is to specialize a function for those types (or define a type trait).
Apparently VS has an insane amount of Windows specific hacks to make it work, pretty much rendering it borderline impossible to port without a complete rewrite.
&gt; people like me who have decent proficiency in other language Agree, but stuffs like "Function Pointer" could be new concept for beginners (even if they are familiar with another language - I meant we don't have to ask "WHY" all the time, but for special cases only). &gt; C++ Primer 5e 6th Printing I'm confused, you meant [the one by Stanley Lippman](https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113) or [the one by Stephen Prata](https://www.amazon.com/Primer-Plus-6th-Developers-Library/dp/0321776402)? And would you please give reviews for both books? Thanks so much.
Search on Google for "Undefined Behavior"
This is an article about C++ pointers and Java references and using that insight to tackle the fare evasion problem in French Metro system(a non-CS related problem)
This should not be on this subreddit, and I doubt it would be popular in any other.
I believe in 2015 you can switch b/w a MS compiler or clang
I think they modify the cmake source code, so they need to do some small work for each new version of cmake. Perhaps nobody asked them yet for newer versions. If you request on their forum, they may provide it to you. Or their older cmake may also work for you.
The duo works fine, but you need to keep a tab in browser.
Gdb with tui enabled when in linux. Visual Studio when in windows.
TL;DR: used existing stuffs to solve the problem, right? (sry, I'm not very smart)
Visual Studio Code is free for Mac, Windows and Linux. There are free add ons that enable C++ development and debugging. At this point, I only use Visual Studio on Windows, and only 50% of the time. 
This article is very difficult to read, and has basically nothing to do with C++ that's worth posting about on /r/cpp, nor do I think it provides a meaningful correlation between c++/java and the metro system.
I thought that was actually good practice?
Agreed and removed.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/945j10/question_for_anyone_who_is_familiar_with_zybook/e3iqt9p/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; when all the tried-and-true methods fails you, be not afraid to try opposite, go against conventional wisdom Ahem.. isn't this is what "thinking outside the box" implies?
On Windows windbg is best. It has almost-feature-parity with Visual Studio as far as visualizations are concerned. And on top of it it has a tonload of highly usable extensions. Learning curve is steep though... I miss it a lot having moved to a Linux shop. Gdb feels like a Stone age cartwheel vs a cargo 747.
Yes I agree to a certain extent about the "why" problem but I think you'll find a lot of problems are hard to explain if you have not experienced them first hand. I think it's excessively easy to file something away as not super useful or kinda boring and frustrating until you realize you kinda needed that knowledge now that you have a problem related to it. A lot of features and issues in programming just don't make sense without direct experience. Function pointers seem pointless until you need them, like for mapping a vaguely known procedure across a list in C. I think your code example makes sense but doesn't exactly hit on the feature he's trying to show the reader which is that you can reuse YOUR OWN CODE for iostream&amp;'s with fstreams. Which is extremely useful when writing input output handling functions because once you get everything set up for command line io it's pretty transparent to just pass in a prepped fstream. People already know they can use getline in the way you're showing because the author showed that around pg 87. The feature the author is trying to show now is about why that works due to inheritance and how it's not some magic feature you would never want to care about, how it can help you and how to use it. The amount you need to know to grok the code example about the two functions and the sales_data class is pretty minimal im the first place seeing as you mainly just need the function declarations and to know sales_data exists. The author describes both throughout the book. I'd definitely call this a beginner book, but like an advanced or motivated beginner? I have read about 9 C++ specific books by now. I'd put something like Copliens book, some of Scott Meyers books or maybe the GoF design pattern book in the advanced category. Those books assume you already know the language C++ primer just assumes you know some programming. (Which they say on pg xxiv) You should totally finish C++ Primer it's super worthwhile. Do you know what you want to read next?
Reverse iterator adapter?
 unsigned i = x; while (i--) //do something with a\[i\]. Or you can choose to omit the post decrement, and then decrement as one of the first statements inside the loop. Just use a signed type. \`v.size()\` can only be larger than ssize\_t max if you have an array of bytes half the size of your addressable memory.
Didn't know about that, it's a good one
What everyone else said - start small and leave it better than you found it. A few lines of code repeated here and there? Probably ripe for an 'extract method'. But beware! C++ is a warty language with warty developers and often there is a reason for some of the code that isn't always apparent to experienced developers either. Implicit conversions (accidental or intended), construction and so on. And don't forget concurrent code.
Reverse iteration is bad for CPU cache which I think is another reason that make this type of code not very common in C++.
Cache prefetch doesn’t care about direction. It will work either way. What you allude to is a myth. Maybe it was true on some ancient hardware like Alpha or something that vintage. 
Usually, when I find myself in a legacy environment, it is too coupled together to unit test easily without refactor. But when you can, it's definitely good.
&gt; Do you know what you want to read next? I don't really know. I learn C++ just because I like the language, not because of finding a job or anything. I'll try to finish basic book like C++ Primer or Bjarne's, then work on some projects. I still think I would work as a game developer (Unity &amp; C#; or maybe Unreal &amp; C++) or web developer (javascript), not a C++ developer. 
Stop. Sketch it out, do some napkin visualization, whatever. But please, do whatever it takes to understand that you’re speaking utter nonsense. Iterating either way, the mapping between memory and cache lines, within those cache lines, is identical and it doesn’t matter what direction you go. Imagine that you cover your container’s range with contiguous 64 byte cache lines. Assuming prefetch that can go ineither direction (it does!), utilization of those cache lines has only to do with memory layout of the data you access. So it doesn’t matter whether you’re iterating a vector or a doubly linked list — the direction doesn’t affect how it looks in the cache lines. I have no idea how it’s not Lear to someone who understands what a cache line is and how cache works. 
 auto it = data.end(); while (it != data.begin()) { --it; // whatever }
Noob question: &gt; for (size_t i = data.size() - 1; i &gt;= 0; --i) Why can't we just write this?
Because \`size\_t\` is unsigned, hence \`i\` cannot be smaller than 0. This loop will never end
How about for (size_t i = data.size() - 1; i != 0; --i)
So why not `i &lt; data.size()`? It will stop when it underflows.
It's important to decrement before trying to dereference the iterator. `*(data.end())` is undefined behaviour.
Then you miss the zeroth element.
You don't want int, on a lot of platforms now it's much smaller than size_t. You want [ptrdiff_t](https://en.cppreference.com/w/cpp/types/ptrdiff_t).
Directly use reverse iterators: for (auto it = data.rbegin(); it != data.rend(); ++it) { // whatever }
A sorry, I fixed it. I meant -1.
Which is exactly what is proposed in this thread. Still relies on an underflow which seems bad.
&gt;`v.size()` can only be larger than ssize_t max if you have an array of bytes half the size of your addressable memory. Which is actually impossible on most architectures anyway. On x86 (32-bit) the upper half of the address space is unusable as it's reserved for the system (at least on Windows). On 64-bit, you just can't do it, the CPUs don't actually support the full address space. Running a 32-bit application on 64-bit allows you to use the full 4GB 32-bit address space, but you'd still be unlikely to manage a &gt;= 2GB allocation in more than a toy program due to fragmentation - e.g. having an std::vector grow to that size would require the old 1GB and the new 2GB to both be allocated simultaneously - good luck! Most microcontrollers don't have maxed out memory either - so you wouldn't be able to have an allocation half the size of the address space because there isn't enough ram. The only architecture that could have trouble that I know of is old segmented 16-bit x86 - which has a 16-bit size_t but more ram due to the segments. It's also one of the only architectures where size_t is smaller than intptr_t! Though some compilers support emulating larger data structures with automatic segment fixups, which results in a 32-bit size_t and the inability to use more than half the space again.
It can be 0xFFFFFFFF (for 32 bit) and 0xFFFFFFFFFFFFFFFF (for 64 bit), which is the value of -1 for signed types. 
CLion has a good debugger, comes with GDB and LLDB integration.
I prefer for (size_t i=n; i --\ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\ &gt; 0; ) 
I've caught myself out on that a few times in the past. Facepalm, fix, try to remember not to make the same mistake again.
What about just shifting the index? &gt; `for (size_t i = data.size() ; i &gt; 0; --i) // a[i-1]=...`
 for (auto i = data.rbegin(); i != data.rend(); i++) { std::cout &lt;&lt; *i &lt;&lt; '\n'; } Pretty simple
Reread the code. It's valid and doesn't dereference end.
Yep, but if you need the index reverse_iterator becomes somewhat unintuitive - especially when iter.base() don't reference the same element as iter. With vector::iterator index is easily and intuitively retrieved.
I keep that in mind as soon as I really use indexing on such large containers ;). I knew this argument would come up...
&gt; Still relies on an underflow which seems bad. Why? Underflow on unsigned is well defined and having size() be big enough to cause a problem is basically impossible (and easy to test).
 for (size_t i = data.size(); i--;)
**[2 GB limit](https://en.wikipedia.org/wiki/2_GB_limit)** &gt;The 2 GB limit refers to a physical memory barrier for a process running on a 32-bit operating system, which can only use a maximum of 2 GB of memory. The problem mainly affects 32-bit versions of operating systems like Microsoft Windows and Linux, although some variants of the latter can overcome this barrier. It is also found in servers like FTP servers or embedded systems like Xbox. The use of Physical Address Extension (PAE) can help overcome this barrier. ***** ^[About](https://www.reddit.com/user/ultimatewikibot/comments/90r969/about) ^| ^[Leave](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[me](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) ^[alone](https://reddit.com/message/compose?to=ultimatewikibot&amp;subject=Blacklist&amp;message=Me) 
VS Code can build your code however you tell it too just fine, in addition to the extensions for stuff like CMake or other languages. It also has a built in debugger.
It's not just about GC. I'm currently working on a class that lets me automatically copy an object, modify the copy and then atomically commit the changes automatically when exiting the scope. Templates + RAII is some powerful stuff.
My point was to fix OP's original code, not to show how to write idiomatic C++. 
Just use `std::distance`. The whole point of iterators is that they're general enough to work intuitively. If you have a reverse iterator to a vector, then doing stuff with pairs of reverse iterators is no different from normal iterators.
OP has been updated with even worse code now... Hopefully "be ready to be praised by your colleagues for writing readable code" is /s!
&gt; for (size_t i = data.size() - 1; i &gt;= 0; --i) I'd argue it's better to have a 2G limitation on number of indexable elements than to have an infinite loop.
`std::function` and `std::shared_ptr` would be good choices for C++14
&gt;Several operating systems (including Windows) support addressing more than 2GB in 32-bit mode For all intents and purposes the /3GB switch isn't usable (driver crashes), and is exceptionally niche anyway - you need to have between 2GB and ~3.5GB of ram, run 32-bit Windows for some reason, and need _one program_ to be able to address 3GB of ram! &gt;And running a 32-bit process on a 64-bit process makes no practical difference: anything that needs to be in the address space of the process still needs to be there when you are running in a 64-bit environment. Not true - the system address space isn't mapped into the 32-bit space under Windows x64, so 32-bit applications that are "large address aware" can address the full 4 GB. &gt;Allocating more than 2GB is a simple matter of declaring std::vector&lt;char&gt; v (2'500'000'000);. You might want to do that because you are writing life-critical software and want to do your own memory management. Sure, but that allocation is highly likely to fail in a non-trivial program - even more so if the size isn't hard-coded but can vary. The modern memory model was not designed to have even a fraction of the total addressable space actually used. Fragmentation can mean that even significantly smaller than 2GB allocations can fail, and there's a hard limit somewhere around 3 GB due to the executable, stack, and everything else having to be in the address space somewhere as well. There's not all that much difference to limiting a single alloc to 2GB when you're going to crash at somewhere between 1 GB and 3 GB allocation size anyway!
 for( auto it = data.rbegin(); it != data.rend(); ++it ) { auto i = data.size() - std::distance( it, data.rend() ); ... }
Yes, totally. Create another ticket to do the clean-up you noticed that could have been done as part of your earlier work. Putting work unrelated to the ticket into a pull request is just bad practice. It makes it more difficult to review and the subsequent PRs, which are non-critical, can be reviewed at anyone's leisure. It also helps if at some point anything needs to be backed out.
I am currently reading through that book as I’m learning C++ and I am really glad I decided to buy C++ Primer and not other “shortcut” books I considered (as I already have previous programming experience and I read several mentions of this book as a book for a beginner). The first part deals mainly with things that I had already known before reading it, but there still were many details that would otherwise escape me (such as the order of execution being undefined). It is true though that I would not recommend this book to a person without some general knowledge about programming. As for things like function pointers, if I recall correctly, these are under the “advanced knowledge” flag and therefore need not to be learned at first, but the reader should at least know that something like that exists in case they encounter it on the internet/in other books and resources.
&gt;Which is actually impossible on most architectures anyway. What about the other architectures?
Mind blown, do people actually do this?
Mostly I don't have to deal with vectors anywhere close to INT_MAX, so signed logic is correct and easier to read.
lmao this guy and his pumpkins
SlickEdit IDE has gdb integration. It is not free, but it can handle really huge projects where other IDEs I know (such as CLion and Eclipse) choke on huge projects.
Saving this thread for later. 
And of course Visual Studio Professional/Community does it too.
Have a look at [mana](http://www.includeos.org/blog/2016/middleware-implementation-in-mana.html) which is a C++ web application framework modelled very closely on express.js. Here is their [github](https://github.com/hioa-cs/IncludeOS/tree/master/lib/mana). Here is an example of a named parameter in a route: // GET /users/:id router.on_get("/users/:id(\\d+)", [](auto req, auto res) { auto id = req-&gt;params().get("id"); // Do actions according to "id" if(id == "42") // ... });
std::distance(myvector.begin, iterator);
&gt; The thing is that default parameters allow to hide things. […] How to choose between hiding a value behind a default parameter or forcing its caller to pass it explicitly? Way too much text and overthinking about something solved by an IDE. Does a function have defaulted arguments? IDE shows they're available and what they're defaulted to.
as Linus said once, we don't care what the standard says, we care what the compilers do.
I missed that the answer used std::for_each.
Note, the correct signed type is `ptrdiff_t`.
It is the signature of the function that is used by std::function to determined the return type and arguments by specifying partially specialization of the base template class of std::function. 
gdb -tui works good for me;
Well, right this minute, I have one open code review that's been waiting on other developers (I'm basically waiting for a rubber stamp at this point) for 3 months. Another couple that are two months old. A handful that are 3 weeks old And another dozen that are a week old. A few years ago, I had a review open for 8 months before I gave up and convinced a co-worker who had no knowledge of the codebase to rubber stamp it so I could submit it. This is also on a code base that takes well over 4 days to compile from start to finish, if you're lucky and nothing broke in the interim (e.g. a unit test that fails sometimes but no one's fixed properly), even though it has only a 10th of the code as firefox (according to the SLOCCount tool). So the people I work with have a strong incentive to minimize the amount of reviews they open, as long as they aren't adding an extra several hundred lines of changes to a particular review, it's faster to just include things into a single one. It also reduces the amount of rebuilds that have to happen if you group things into one commit. So the way these opinions developed here comes before my time, but isn't just completely broken. I'm actively working on build times to remove that unintended side effect, but there's little I can do about the culture as an individual *shrug*. But trust me when I say that it's *way the fuck better* here than anywhere else I've ever worked. Try working for a company that doesn't require code reviews to submit to a codebase that gets released to customers whenever they want to pull the latest nightly build (I know, right?) with no unit tests AT ALL (Except for the ones that I wrote, anyway). I'm frankly surprised that place still exists. Guess they got acquired by a competitor, but I would have expected the purchaser to just burn it all to the ground. Oh well *shrug*.
I just came here for this comment lmao
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/94avbq/what_is_stdfunctions_template_parameter/e3josz4/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
For C++ development I use a combination of: * EasyClangComplete * C++11 Syntax Highlighter And that's it. I create a Sublime project so I have all my files handy and organized. I write all my CMake files and when everything is set up it is as easy as going to an external console and executing the good old: mkdir build cd build cmake .. make 
Does any IDE show what they're defaulted to based on the current calling context? I was surprised to read that default parameters can be respecified.
When you're writing it, sure. If you're reading code though, that requires mousing over every function to know it's signature type... Besides a function can have multiple signatures, each with different sets of default parameters. It can be hard to see at a glance.
VTune for Linux is free if you work on an open source project.
I think if you have to rely on specific features of an IDE to unterstand your code, it's probably not very good.
IDE is there to reduce the cognitive load. I've never read production code from a piece of paper.
I bet his underscore key is worn to a mirror sheen
&gt; If you're reading code though, that requires mousing over every function to know it's signature type... WTF? Functions/methods exist to raise the abstraction level. When reading the code I either "skip" the call if I can infer that it does the right thing, otherwise I'm going to have to read the whole function definition anyway. The code should read like a novel: while (!stack.empty()) { auto item = stack.pop(); ProcessItem(item); } It's not given that the stack is an STL container, all of the calls could have been overloaded. But it doesn't matter as long as I have no reason to suspect that the code is incorrect. When I suspect the code is incorrect, I have to dig into the implementation of each individual function anyway.
Great paper.
Speaking as someone who develops C++ without an IDE (just a configured emacs and the unix toolset) it's relatively easy to use tags to just jump to the declaration/creation of the function and find out if it has anything defaulted, then jump back. That's just the non-IDE way to do it though. As for understanding code, unfortunately there's no way to get around checking for defaulted stuff, as there's no way to easily tell intuitively if a function has them, unless you name it something like `getProcessedItemsFromSubArrayOrByDefaultMainArray(array);` Which is silly of course. You could find out if it has something defaulted if you try not giving it anything, but you still can't see what it defaults to.
No, that's a perfect example of why inlining things is helpful. You don't actually know what that code is doing until you start jumping around to look at the functions you're calling. 
At first I liked that idea, but imagine the WTF factor after a bit of time has passed.
Just put a small comment about it around the for.
I shouldn't have to define a variable. Technological advances should make that happen automatically
Have you ever read production code in Git or in a review tool? You can't jump into functions from there.
&gt; C++11 Syntax Highlighter Thanks, I can't find the second one 'C++11 Syntax Highlighter' do you know if it's been renamed?
Depends on the tool.
If you just "inline the code" you want only know even less about what the code is doing from a glance, you won't know what the code is _supposed_ to be doing.
I’m like the worstest: I use underscores and lower case in C, but camelcase in C++. In both I prefer to begin derived type names with upper case, but arithmetic types I always start with lower case, and C struct tags end with `_t`. He probably could use a pedal for the underscore 😜. 
You'll know exactly what the code is doing unless you can't read code, in which case get the fuck out of the source. Not to mention the assumption that you know what ProcessItem is doing by looking at such a generic name.
&gt;C++23: &gt; &gt;Long-overdue, we are finally fixing our mistake of making `size_t` an unsigned type. With this release, `size_t` will now be defined to be a signed type. &gt; &gt;We predict that there will be no regressions or existing practices that will be broken by this change.
I recommend reading Koenig's ["The Case Against int, Part 3: The Advantages and Perils of Unsigned Arithmetic"](http://www.drdobbs.com/cpp/the-case-against-int-part-3-the-advantag/232602212): &gt;If we are moving backward through v, the form is less familiar: vsize_t n = v.size(); while (n != 0) { --n; // Process v[n] } &gt;Writing the loop in this slightly unusual form allows us to stop the loop before n crosses zero (which it will never do, so we had better not try to test for it). It also makes it unnecessary to write a separate calculation to start n at v.size()-1 instead of v.size(). Moreover, the same technique works for iterators: auto iter = v.end(); while (iter != v.begin()) { --iter; // Process *iter } &gt;The similarity between these last two code examples comes from a similarity between unsigned integers and iterators: Because there is an off-the-end value but no off-the-beginning value, both unsigned integers and iterators require special care when a value might run off the beginning of a range (i.e., might underflow). A variation if you prefer a "for" loop: for (size_t i = data.size(); i != 0; /**/) { --i; //Process data[n] } This approach (decrementing the index inside the loop) does not "wraparound" the unsigned integer, which is sometimes triggered by some runtime checks/sanitizers or static analyzers. As mentioned by Koenig, this pattern also also avoids "decrementing" the iterator outside bounds, which is undefined behavior.
How do you explain [this](http://quick-bench.com/79cQgKEh9n5vN-kDGGFFoX_V6Bw), Mr Know-It-All?
Isn't your first example (2.1) potentially creating a vector of a peta-byte size?
For readability purpose, you may consider using single quote in big numbers. For example in 2.7, instead of \`1000000000000UUL\`, you may consider \`1'000'000'000'000\` witch is valid since C++14.
Interesting - I probably spent 60 hours on my [Nurikabe solver](https://github.com/Microsoft/nurikabe) which would seem exceptionally amenable to SAT, as each cell is either white or black. If it works for Minesweeper and Sudoku...
Considering the short amount of time required to try a SAT solver, I'd say it's worth a try. However, Nurikabe seems worse for a solver of propositional logic; there is no "sum" function (as in "the number of mines around this tile has to be 6") but rather you have to explicitly force one of all possible combinations to be true. If I didn't make an error, there are already 48 clauses to be made for each island of size 3. Maybe solvers for another logic are more helpful in this case.
Nurikabe is much harder for a SAT-solver than Sudoku. The single-connected river property in particular is non-trivial to express. The area constraints on the river are easier to enumerate. Most modern SAT solvers will also have more general constraint solvers (SMT/CSP) under the hood (which are typically slower for greater expressiveness). Since you are at Microsoft, you might want to walk down the hall and have a chat with [Z3 SAT-solver](https://github.com/Z3Prover/z3) authors Leonardo de Maura and Nikolaj Bjorner.
Probably because the same general problems have not been solved for several years in a raw, even if they were being working on.
Serendipity (or recency bias or whatever), but the last few days I had been finishing a Z3-Python [repo on GitHub](https://github.com/rhalbersma/zed) some N-queens type problems on a Stratego board (10x10, with two 2x2 impasseble lakes in the center). I agree with you that solvers are incredibly powerful, but they can be tricky to perform robustly (10x speed drop from simple constraint rewrites or even reordering are not uncommon).
Visual Studio does. I use it all the time.
Actually it was just meant to be read as any plug-in which adds improved code highlighting
This is hilarious. I'm imagining an elite programmer with a hatred for camelcase having a double bass style underscore pedal setup coding to some [hard metal](https://www.youtube.com/watch?v=HEz3-RoqG9E).
I was secretly hoping for SoP or FA when I clicked that link...
&gt; some super senior dev couldn't handle their precious code getting touched. This is especially true if the codebase gives them job security as they're the only ones who understand it. As the grumpy senior dev of the group (only 5 years out of college), I would *love* for someone to come along and reduce my bus factor (which is currently just barely above 1). 
&gt;This is also on a code base that takes well over 4 days to compile from start to finish, if you're lucky and nothing broke in the interim (e.g. a unit test that fails sometimes but no one's fixed properly) Jesus fucking Christ. I thought 4-6 hours for our FPGA builds (each, but we can do them all in parallel) was unbearably bad. I wouldn't even *attempt* to work on something that takes **four goddamn days** to compile. 
YES! Haha. It was almost Archspire but I went with FA. 
&gt; As the grumpy senior dev of the group (only 5 years out of college) This is the key - these were guys that had been at the same company 20-30 years. There's nothing wrong with that, but it comes along with the same sort of 'stuck-in-ones-ways' that generally comes with age, and when working on very engineering-driven products it's a huge problem when a dev thinks computers work the same way they did in the 80s and your product is orders of magnitude slower than the competition. The most flexible senior devs, on the other hand, are easily the most knowledgable and valuable people at the company. Mindset makes a massive difference in how valuable your knowledge and experience is.
How does this compare to [cereal](https://uscilab.github.io/cereal/) (or boost::serialization, for that matter)? 
Singletons are just fancy globals, I'd argue they're better. Singletons can be mocked out.
I agree with Linus, and the union aliasing is in there (it works, notwithstanding all the talk about UB in C++). `shrink_to_fit()` concerns the STL though, and has nothing to do with the compiler.
r/doener
I've had plenty of successful coworkers who leave their work at the office and don't do any home projects. Consider that you might be doing dev work for decades. You'd burn out pretty quickly forcing yourself to study the same stuff you're working with, unless you really want to, after spending a day at work.
Joking aside, yes, how does it compare to cereal (also in ease of use)?
&gt; was surprised to read that default parameters can be respecified. An offense worthy of last warning before getting fired :p I can't fathom why the language even allows this.
&gt; Not to mention the assumption that you know what ProcessItem is doing by looking at such a generic name. The name is generic because the algorithm is generic (flood fill / DFS). In any case, there are two "levels" in this code: flood fill and visitation of items (pixels on a bitmap, nodes in a graph, etc.) The algorithm can be verified independently of `ProcessItem` so if the net result is incorrect, the bug is in the externally supplied `ProcessItem`.
Those requirements are very basic. So here's an answer you won't particularly like - from a Vim user. 1. Many choices here. Plain gdb is great, even python scriptable, but not quite"visual". Then there's termdebug plugin bundled with vim, which can provide visual feedback of breakpoints and current line. And finally there's vimspector, that has scope and variable visualisation and actually talks the same protocol the vscode's debuggers do 2. Once again, a ton of choices here. My favourite is YouCompleteMe. 3. Every compiler takes input (plain text) and outputs a compiled executable (unless you request your compiler to stop early). 4. If you learn console, you'd know how to pipe any text to standard input of the compiler and have it process that. With vim that would be `%r !g++ -xc++ $CXXFLAGS -`.
Am I reading this backwards? A casual developer is someone who codes for a living? You've got to balance your life. I love programming and do it for a living, but I also love my girlfriend, my dogs, cooking, exercising, playing video games, reading, traveling to see family, and watching TV/Movies. When I'm working, I give my employer 100%, but when I'm off, I give them 0% - I only code off the clock on my own projects and when I feel like it. I don't think that makes me a casual coder, and I don't think that hurts my career. If you genuinely feel like you're behind your peers or that you're struggling to get your job done, then absolutely work off the clock to learn more - I've done it because I am very grateful of the opportunity to do something I enjoy for a living. However, I don't feel like it's expected of me - coding every waking moment won't necessarily make you better, you've got to have balance. A happy worker is an effective worker. If you all you want to do is code, then you hit the jackpot and I'm sincerely happy for you, I just wouldn't look down on coworkers who have interests outside of work.
Still doesn't matter. Review can help to discover stylistic / design issues, but no review tool can tell me whether the developer observed the code in a debugger before submitting it to review.
Ehhh, I mean it's not like it takes 4 days make a small change and compile a test app. It's 4-5 days to compile whole product. So if you make a change to one of the lower level libraries that's used by everything, it's 4-5 days before you find out if you broke something obscure by mistake. But if you're working on a higher level library, or an executable directly, the turn around time can be as low as 10 minutes or so.
Why would he? That's what unit and component tests are for, added in the same commit. 
Too many macro definitions, which makes use of the library not pleasant. It's strange to see in cpp14.
&gt; Where? I don't recall seeing any public votes on feature implementation being done online. [I don't think you looked very hard at all.](https://isocpp.org/blog/2018/02/new-cpp-foundation-developer-survey-lite-2018-02) &gt; But I do see the committee spending time and resources working on a 2D Graphics API that I don't recall anyone wanting. The committee has made a lot of questionable decisions (and continues to do so), but continues to seem to be insistent that the general userbase is wrong about what they want. [We aren't working on 2D Graphics anymore, thanks to a paper I wrote.](https://wg21.link/P1062) &gt; Suggesting that physical meetings are optimal Face to face meeting are absolutely essential for getting anything done. The meetings are very intensive and efficient - we usually work 12-14 hours a day. &gt; that anything else isn't a great idea just strikes me as elitism and an attempt to exclude the community... Excuse me? - A large amount of our discussions happen online on mailing lists - Meetings are open to anyone. One time a waiter, with no technical background, who happened to be in the room during the discussion voted on something. Everyone was cool with it. - All of this is despite the fact that the C++ standard is an **international treaty** developed by a **large official organization that is an offshoot of the United Nations**. Anyone can participate, in person or online. It sounds like you've never tried to. &gt; elitism The whole tone of your post is downright offensive. I think you owe Bjarne and the rest of the people who slave away to develop this programming language more gratitude than that. I have never met a more down to earth group of people. C++ leadership isn't "elite". &gt; I can't afford to take a week or so off of work and get a ticket for a trip to Switzerland The C++ committee is an international body. We meet all over the world because that's the fair thing to do. &gt; or whatever country the committee decides to have a meeting in. We don't "decide" to have a meeting somewhere. Some very hard working people volunteer their personal time and money to host. We go wherever people volunteer to host. We are a non profit organization with limited resources. We don't have the luxury of choice. &gt; but continues to seem to be insistent that the general userbase is wrong about what they want. Nobody thinks that.
C++23 is an unrealistic timeframe.
&gt; code doing things that some other class should be responsible for. What does that have to do with free vs. member functions? If a different class should be responsible for it, then put it in another class. That doesn't mean putting it in a member function is the wrong thing to do. I certainly wouldn't put a regex engine in a string, but I could imagine a `my_string.replace("foo", "my_foo")` that might internally use some free regex functions. In particular if the alternative would be `foo::str_replace(my_string, "foo", "my_foo")` Regarding the link: I'm not denying the factual arguments behind that advice. I'm weighting them differently and I believe the "use free functions" advice is overused. Overused doesn't mean you shouldn't follow it. It means that people tend to make a religion out of it and it gets in the way of good interface design, usability and discoverability. As I said before. Yes, the fewer member functions you have, the fewer things can - in theory - be impacted by an internal change to the class (keep in mind though, that just because a function is a member function that doesn't mean it uses private data or members). In practice, I have yet to encounter a refactoring where this is a problem. A much more common problem I'm seeing is that a whole block of functionality should be put into a separate utility class (or collection of free functions). In stand by my point: The interface of my class is used way more often than I'll change the internals, so convenient usage is what I'm optimizing for, even if that means putting common/important functionality into member functions that could also be implemented as a non-member.
At a quick glance, it seems doable, if painful. Some of the rules are easy enough (e.g. forbidding pools), but the island size requirements are painful. 
&gt; but they can be tricky to perform robustly (10x speed drop from simple constraint rewrites or even reordering are not uncommon). Yeah, this is definitely going to be one of the posts (along with things like naive and optimized encodings of pseudo-boolean constraints).
You are right. What I meant to say is, a package like Z3 can solve more general problems than pure SAT. However, if your problem reduces to purely Boolean expressions, it can employ the faster SAT solver instead of more general SMT procedures. Getting down to pure SAT is often quite hard and less expressive.
You are right. What I meant to say is, a package like Z3 can solve more general problems than pure SAT. However, if your problem reduces to purely Boolean expressions, it can employ the faster SAT solver instead of more general SMT procedures. Getting down to pure SAT is often quite hard and less expressive.
Why does it matter if it's inside or outside work? The more time you spend working with the language, the better you will get to know it, regardless of where you're sitting. How much time you need to invest to get better, only you know.
For a little more declarative way of solving NP problems, you might want to take a look at [answer set programming](https://en.wikipedia.org/wiki/Answer_set_programming). Modern ASP systems like [clingo](https://potassco.org/) combine the search power of modern SAT solvers with a rich rule-based modeling language.
&gt; [I don't think you looked very hard at all.](https://isocpp.org/blog/2018/02/new-cpp-foundation-developer-survey-lite-2018-02) I'm not quite sure why you feel as though a generalized survey of habits and tendencies amongst C++ programmers as well as what they're doing with it and how they're doing it qualifies as a 'public vote on feature implementation'. It's not specific, nor binding, nor a vote or poll. To me, this just lends an air of non-democratization to the language as a survey like that just seems a façade. &gt; [We aren't working on 2D Graphics anymore, thanks to a paper I wrote.](https://wg21.link/P1062) Yet how many man-hours were wasted working on it in the first place? You yourselves question this in §5.1, but don't seem to touch on the fact that *it was being investigated in-depth in the first place*, nor seem to see that as being a problem in-and-of-itself. &gt; Face to face meeting are absolutely essential for getting anything done. The meetings are very intensive and efficient - we usually work 12-14 hours a day. That's all well and good, but the I feel as though the burden of proof is on you to prove the first part. Other projects, including incredibly large projects, seem to operate just fine without requiring meetings in semi-exotic locations which excludes potential involvement. &gt; A large amount of our discussions happen online on mailing lists And why, exactly, can voting not be done as such? As per your previous statement, face-to-face meetings for 14-hours a day during relatively constrained periods of time is the only time that absolutely essential work gets done. *Why*? If the mailing lists are actually performing meaningful work, I don't see why that's necessary, meaning that mailing lists or other fora aren't being taken seriously or utilized properly. As per the rules of the 'Reflectors', I wouldn't qualify to participate in the mailing lists anyways, as I am neither a member of a national body participating in WG21, not have I attended one of the meetings previously, nor has any SG chair added me (exclusively for study groups). As such, while I would love to meaningfully contribute my own thoughts/opinions/proposals, the language's direction and administrations feels basically *completely* closed off other than what basically appear to be meaningless discussion boards where I don't feel that my opinions would be taken seriously in the first place. &gt; Meetings are open to anyone. One time a waiter, with no technical background, who happened to be in the room during the discussion voted on something. Everyone was cool with it. A phrase comes to mind which I'm sure you've heard in the current political climate: availability is not accessibility. I can access the internet pretty easily. Getting to Albuquerque, Jacksonville, San Diego, Kona, *etc* are far more difficult for me - I would have to take time off of work, pay for it, and so forth. I don't have those resources trivially available to me. The last time there was a meeting in my home city was in 2013. While there are financial assistance programs available, their requirements are rather strict and basically presume I'd already be deeply involved. Even if I went to one of these meetings, it would be as a non-participatory member, as I am not a member of the US NB, and I legitimately cannot find any resources on how one gets involved in the NB. Is the NB for the US ANSI or is it a separate organization? Everything I can find is very unclear, and I can't find much at all to begin with. &gt; All of this is despite the fact that the C++ standard is an international treaty developed by a large official organization that is an offshoot of the United Nations. I'm unsure of what this has to do with anything. Past that, the C++ standard is an ISO specification, and ISO specifications are explicitly voluntary - it isn't an international treaty under any definition of treaty. ISO precedes the United Nations by quite a bit as the ISA. It was never a part of the United Nations, and has always been an NGO. Its association with the UN is and has been extremely loose. &gt; The whole tone of your post is downright offensive. I think you owe Bjarne and the rest of the people who slave away to develop this programming language more gratitude than that. You're more than welcome to be offended if you want to be - it's not going to change my opinion or how things appear to me. Honestly, the fact that you have basically told me, here, that I should be quiet and be grateful for Bjarne *et al* confirms what I'd already said more than anything - that there's a group above me who are evidently immune from criticism and that should be thanked for it. I am well aware that was not your intent, but it's certainly how it comes across to me. Also, surprisingly, I can be grateful *without expressing it at all times*, and can *also* criticize the problems I see with the committee and the system. They are not mutually exclusive things, despite what you seem to be implying. If you're referring only to my tone, well, OK. I'm a very blunt person who is also frustrated, and embittered because whenever I express my frustrations they are effectively dismissed. *I don't want* to move to another community and language like Rust or D. I've been using C++ for too long. However, I don't like it when I feel like the committee is basically *pushing* me there, while at the same time telling me to like it and that I should be grateful that they're pushing me away. &gt; I have never met a more down to earth group of people. C++ leadership isn't "elite". That is neither a definition of 'elite' nor is it the meaning I was using in the first place, and you know that. They *absolutely* match the basic definitions of elitism, in that almost everything is controlled/done by a group of people with very large influence, effectively to the exclusion of others. They are, quite literally, the ruling elite. &gt; The C++ committee is an international body. We meet all over the world because that's the fair thing to do. *Or* we could enter this decade and host meetings online, and stop effectively excluding people based upon geography. &gt; We don't "decide" to have a meeting somewhere. Some very hard working people volunteer their personal time and money to host. We go wherever people volunteer to host. We are a non profit organization with limited resources. We don't have the luxury of choice. You know what I mean. Besides that, you still have to *decide* to go there. I mean, I could offer up my basement for the committee, but something tells me that you wouldn't be willing to accept the offer. "C++ 2018 Face-to-Face /u/Ameisen's Basement" doesn't have a good ring to it. &gt; Nobody thinks that. Evidently, I'm nobody.
I haven't looked at DonerSerializer in too much details but from how it's used in their Readme, I like cereal much more. Much less macro use (or they're abstracted/hidden better), it's easier (and the syntax is better) to serialize your own classes. I would much more like to see some more life come to cereal again, it's gone quite inactive in the last 1-2 years.
I was kiddin' in another post over the Doener references.
From our testing so far, there isn't really a one-size-fits-all approach for PB constraints. However, if you work in C++, [PBlib](https://github.com/master-keying/pblib) makes testing the most common encoding relatively easy.
C++ still doesn't have reflection, so it's not really strange to me.
Government and military code has to be proven and should follow some clear standard. You might not care about this but engineers know that you have to be able to prove that you are doing things correctly, and libraries are unproven garbage for these purposes. For a lot of these issues, a 2d-library offers good diagnostics, but without a standard you cannot run the diagnostics on the same computer as the key software, which adds a lot of issues.
r/cpp_questions
This is a question, should be in the questions sub. But anyway: It looks like you are using heaps of C features, generally there are better ways of doing things in C++. And take my advice with a grain of salt because I may be wrong about some things. Replace your #defines with static const variables. If you want to write C++ using std::string, use std::string. If you want to use char *'s, use char *'s. Don't mix the two up all over the place, unless you actually need your functions to accept char *'s as parameters to link to C code or something. You have methods that return std::string, but they all accept char * as arguments. This is really the most confusing thing about your code to me. If you stop using char * and use std::string instead, then you can just use normal boolean comparators (&lt;, &gt;, == etc.) with std::string's instead of strcmp.
Thanks!
I tried that but some compiler complaint (i don't remember which one or which version). It said the class wasn't declared completely at that point and that it could only get member information after the class was totally defined. How did you handled this? 
The purpose of macros in this project was to give semantics to what you're doing, hiding implementation details the user shouldn't care about. Make everything more user friendly. I know macros are the devil and so on, but there are times where they're more convenient to provide a more understandable and easy-to-use API (and useful to avoid breaking changes in some cases!). Anyway, I see this is a popular complain, so for the next iteration I'll think ways to reduce the macro usage!
As far as I see, Cereal supports more complex types such as std smart pointers. I haven't had the time to experiment with those yet, but we'll see in the future. They also supports other formats such as xml or binary. This is something that can be easily added to DonerSerializer with the implementation of new Resolver classes for handling both cases. There are some improvements that can be done for the next release of DonerSerializer. In the other hand, in terms of usage, DonerSerializer uses it's sister project DonerReflection to define metadata for a specific class. This data can also be re-used in any other way, for example creating a custom form in QT. THis way you have the metadata only defined in one place to be used in many.
Too hot to deep analysis. Some general pointers. If you really really need the handleRequest() to return different values, have a look at Boost.variant , as I suppose that you will want to know *what* is being returned. Your #define are all right for that size of a program, but you can change them for constexpr to have some type safety, For multiple options (your if/else's) there are basically two alternatives. One is yours, that is all right for simple programs like yours seems to be, specially if no new options are foreseeable. The other one is polymorphism. That is more adequate for complex processings or if you plan to add more options and don't want to mess with the base code. Also, every time that you fee like writing a comment like // Get and parse request or similar, consider if you should instead write a function called GetAndParseRequest(), omit the comment and have smaller functions that tend to do one thing only. This have several advantages, one being that the passing of parameters and return values to different functions, give you insight into the data structure of your processing problem, and it helps to define it better. Maintainable code tend to have the responsibilities of changing data very well defined. Then, if you want more, read "Clean Architecture" by Robert C. Martin, and after each chapter, read your code again and see if it complies :-) Good luck. 
Since in CP you won't have to deal with huge projects with thousands of files(it's more like less than 3 usually), you can pick up any IDE/text editor and pair it with a debugger if it doesn't comes with one. On Windows just use Visual Studio since you'd already have it if you're doing serious windows + cpp work. If not, try codeblocks or vscode or any text editor but it's hard to beat down VS integrated debugger and other tools that come with it. I'll still say just stay with VS. On Linux you've plenty of options, either pick professional IDE such as CLion(need to have hefty machine with SSD to use it properly) or more friendly Qtcreator and both of them come with pretty solid debugger support. You can pick vscode(comes with debugger too)/Vim/Emacs/.... &lt;insert your text editor&gt; and pair it with gdbgui(search it on github)/nemiver(standalone debugger) too. There are notable autocompletet plugins for your fav text editors, lookout for clangd/youcompleteme/irony-mode/cquery etc. Then there is - https://gitlab.com/cppit/jucipp
I think it would be possible, in C++11 and beyond, to use a free-function approach instead. Essentially, the macro definitions are about enumerating the properties of a struct and giving them names. For each property, you need: - a way to get the value, - a way to set the value, - a name for the value. That's it. So, essentially, a "property" is a struct with such an interface: template &lt;typename T&gt; struct Property { std::string_view name() const; Get get(T const&amp;) const; void set(T&amp;, Set) const; }; And a list of properties is... a *tuple* of properties, since it's heterogeneous. It's relatively to define a property with a helper, something like: template &lt;typename T, typename M&gt; struct MemberPointerProperty { std::string_view name() const { return name; } M const&amp; get(T const&amp; t) const { return t.*pointer; } void set(T const&amp; t, M&amp;&amp; m) const { t.*pointer = std::move(m); } char const* name = nullptr; M T::* pointer = nullptr; }; template &lt;typename T, typename M&gt; MemberPointerProperty mptr(char const* name, M T::* ptr) { return { name, ptr }; } And the user can write: auto describe(Bar const&amp;) { return std::make_tuple(mptr("foo", &amp;Bar::foo), mptr("other", &amp;Bar::other)); } *Note: I personally prefer to use `template &lt;typename T&gt; struct Id {};` to pass `Id&lt;Bar&gt;` as argument to avoid having an instantiation, but some people don't like it...*
Would you happen to know where I can see an example of basic coroutine usage in MSVC?
&gt;in that it can serialize pointers to derived classes, and then deserialize to the correct derived class again. This makes serializing stuff like a vector of base pointers wonderfully easy. But this also implies that you'll never be able to use JSON Unless I'm missing something cereal can also do that, even when serializing to JSON.
nope
That's a small percentage of the time and that kind of code should be isolated to allow the other 99% of the code to be unit rested effectively.
That’s very unfortunate. Please let me know here or on github about any problem you experience, and I will sort it out.
Awesome! Off topic, but what font is that? It looks really nice!
&gt; 'friend struct SDonerReflectionClassProperties&lt;MyClass&gt;;' I have never had to use anything like that with cereal! :-) But yes definitely agree with you, there's always pros and cons and individual preferences. Anyway great job for the library and I'm sure many people will be happy that you open-sourced it :-)
I mean, I'm looking at my keyboard right now and I think the only three symbols that are going unused at the moment are ``$`` (at s-4) and ``¿`` / ``¡`` (before backspace). Any of them could be used without loss, although I'm not sure how much expressive ``foo= ¿bar`` is for a move. But if we go deep down into it, isn't ``move`` the shortcut version already? 
Not OP but looks like Iosevka or something similar.
Yeah, I have Iosevka installed as well, but that looks a thousand times better than it does on my own Windows installation. I can never quite get it to look right on Windows.
the point still stands, you need to start hopping all over the place to understand what's going on, vs inlining it's all there. there's a tradeoff, and the mistake you're making is refusing to understand that tradeoff.
lets pretend as if these compilers don't ship their own versions of the libraries to try and "right" in an internet argument, shall we? I'm done.
...which is why I always use IDE's diff tool. I can't judge if something is easy to understand without being in the same environment as people that actually use. otherwise, I would be basing my review on useless criteria "code should be easy to read on Gitlab". it's obviously crazy. you can only survive without ide diff tool if you are making sloppy code reviews.
On Windows you use apis like ReadProcessMemory and VirtualQueryEx to read and get information about memory regions. I think on linux there are similar apis (ptrace?), but I’m not familiar with those.
so if there is no api provided, then it something like this is impossible ?
The way CheatEngine works is similar to the way a debugger may work. It attaches to a running process by using a system call , [ptrace](http://man7.org/linux/man-pages/man2/ptrace.2.html) for Linux. &gt;The **ptrace**() system call provides a means by which one process (the "tracer") may observe and control the execution of another process (the "tracee"), and examine and change the tracee's memory and registers. There is already a CheatEngine alternative for Linux it is called scanmem, I believe it exists in Debian, Ubuntu and Arch repos. There is also the source code in [github](https://github.com/scanmem/scanmem). Maybe it can help you
&gt;On Windows you use apis like ReadProcessMemory and VirtualQueryEx to read and get information about memory The API that was mentioned is the one provided by the Linux Kernel
honestly there already are linux "cheat-engines-like" programs. I get no benefit of writing inferior version of those. So why would i bother, if not for myself ? if you know answers to any of my questions i would be glad to hear them :) P.S. i can cheat without coding a single line, so really i don't get why spend time reading books and so on if you can watch YT tutorial by someone in 4 minutes. I really want to know more about memory and cpp
&gt; And why, exactly, can voting not be done as such? You seem to think that voting is real crucial. It's not. Your voice on the committee is much louder than your vote.
&gt; I am learning cpp and i think writing your own "cheat engine" can be a great learning experience. This is a bit of an unusual project that probably wouldn't be a good first project. There's also so much that can go wrong with a program like that apart from C++ that I'm thinking it'll just frustrate you. &gt;Please recommend some books/tutorials/youtube on the topic of memory scanning and ingesting. You probably won't find something so specific, this is not exactly a common task. You're going to have to be self-sufficient and read the docs regarding the API functions you'll need. &gt; And can you explain, please, how something like cheat engine even works ? how is it possible to access other process memory and change it in modern os? A program like CheatEngine will use the debugging API on your platform to read memory, find values and change them at will. You're right in assuming that this should not be possible in a modern OS, it's only through these API calls that the Windows kernel can access another process' memory. Another related thing is a trainer. A trainer is often a DLL loaded by the program. Since this is loaded by the OS into the program's address space, it has access to all memory from that process. I'm sure all this is possible on Linux, but again, you'll need to dig into the documentation and figure it out yourself.
!removehelp
well as i said i don't want to just use someone else's program. i want to write something by myself, eve if it is inferior in the end. It is about journey, not destination this time :) , but thank you for github link. if i find no books/tutorials on topic, i will take a look at finished project
well i am not a newbe. I finished university c and c ++ corses on computer science program, it is that no one toughed us anything similar. I surely implemented by myself all of stl containers and some other STL stuff in our homeworks and semestral projects 
Never heard of Iosevka before, thanks for the pointer! I'd be curious, they say it's "designed to be the ideal font for programming". But I couldn't find a rationale as to why it is supposed to be "the" font for coding. Anyone got any idea or did I miss a page that describes this? For my taste the characters look a bit too narrow, but that's just my first personal impression from browsing their website.
Most of this can be done with Boost.mp11.
Inziu Iosevka SC 12pt. The author of the font has joined Microsoft to participate in the new font design.
&gt;`ec.assign((int)GetLastError(), generic_category());` &gt;`ec.assign((int)GetLastError(), std::system_category());` `system_category` is, in theory, correct for a win32 error on the win32 platform. `generic_category` would never be correct since it's for std::errc/POSIX errnos. Under libstdc++, system errors are also POSIX errors and there is no win32 error support.
This requires GCC upstream to solve. See: https://github.com/gcc-mirror/gcc/commit/2fd48392d0a4ac3d1e217367ccb0ec0333d584d8 
Since you are using C++17, how about having a `vseq` type that takes `auto` values rather than just integers? template &lt;auto... Vs&gt; struct vseq { static constexpr auto size = sizeof...(Vs); // Can't have value_type anymore, though };
I swear I will never understand people who go around to new library releases and just shut it down with, basically, "This can be done in Boost.{X}, what's the point of this library" Not everyone needs the behemoth that is Boost to exponentially increase their compile time and build complexity to do something that can be simply done in a small single header library
I would recommend not rolling your own `make_integer_sequence` with `seq::impl::make`. The three major standard libraries all use compiler intrinsics in their `std::make_integer_sequence` implementations which makes it extremely fast. Instead, I'd use `std::make_integer_sequence` and pattern match to extract the parameter pack, with some math to make it correct. Something like this: template &lt;typename T, std::size_t Size, T Start, std::make_signed_t&lt;T&gt; Step&gt; struct make { template &lt;typename&gt; struct impl; template &lt;T... Is&gt; struct impl&lt;std::integer_sequence&lt;T, Is...&gt;&gt; { using type = seq&lt;T, (Is * Step + Start)...&gt;; }; using type = typename impl&lt; std::make_integer_sequence&lt;T, Size&gt; &gt;::type; };
Probably should have said "rendering engine" instead of just "engine"...
Whoah. That `overload` makes `std::variant` a lot more palatable. I'll have to remember this one. Thanks!
i am one of those casual workers that isn't even allowed to take code back home / out of the office. 
But most boost libs are standalone and only depends on the few base files fro compiler defines. The slow ones are the ones that used to depend on boost.MPL but over time they are refactored with more modern c++.
Don't twist my words, moron. If I want to insult you I will do it without twists and turns. I said it is as good as garbage for the purpose of proving correctness. If it is standardized, you don't have to prove this correctness. This saves money and time. And yes, you run an implementation of a standard. Obviously, you spend the time and money to prove that each update is good and still backwards compatible. This is straightforward for standards because they have a standard way they should respond. If you work in a place that requires less specificity, good for you. I am more interested in the stuff that requires precision. I remember once reading the legal text that defined how a company has to treat old people to get government-funding for elder care. It was an 8-page long description of everything from food standards to sleeping conditions. I was the same week sent the document ESA had for describing just some screws in one of its space-crafts. This was a 20-page document. The difference in details between these descriptions is, I guess, the same as our difference in opinion about what should and should not be standardized.
Boost is maintained and there is a community built around it. It is excellent, heavily tested, platform-independent code. When I use small third-party libraries a lot, the chances are higher that one of them breaks when the maintainer has already moved on and abandoned the project, so that you either have to maintain a fixed copy of the lib or switch it out. Both are expensive options.
Thanks for the suggestion, I will surely consider this.
QtCreator also has an awesome Vim mode, valgrind integration and they just added much better Clang linting
That's fair, but that's a risk you take when using any library. The only way for a library to get better is if people use it, so being quick to dismiss a new one is just unfair. 
What’s new in C++20 that makes this possible?
Using non-built in types (such as std::array) as non-type template parameters.
Wait, so this engine does NOT need a flux capacitor?
it's on the cppreference page about `std::visit` I think `overloaded` was on some CppCon or ACCU.
&gt; "designed to be the ideal font for programming". But I couldn't find a rationale as to why it is supposed to be "the" font for coding. In my experience, if the font is monospace and makes it easier to distinguish o vs. 0 and I/l vs 1, then it's enough to make that claim. Rarely it goes beyond that.
Damn you're right, wish this sub had a spoiler tag... Then we'd have better aerodynamics as well!
Personally I prefer MVVM for larger apps so that any view logic is entirely encapsulated. I've found that maintaining a meaningful separation between the controller and the view can become difficult at times in MVC.
Vim for life!
Ah, that makes sense. Thanks again.
Fantastic project! Really appreciate the upgrade to fmt 5 :)
There's VS Code, which is in my opinion much nicer to use - except that the debugger is a lot less powerful than that of the proper VS.
Visual Studio Code Don't know why this has not been mentioned yet - even though on Windows you'd probably prefer the proper VS, I find it actually more productive
oooo nice new features. I've been experimenting with this library a bit over the past few months, and it's been really nice!
But then why not just use a reference?
Great project. Use it for a couple of months and quite happy with API and performance.
Awesome! Been using the old version for a long time and she's never done me wrong.
Has anyone made a comparison of different "modern" logging libraries? There seems to be quite a number of those and it would be useful to know what are the \[dis]advantages of each one.
Why?
Much easier to handle and track.
I'm actually not sure you even need cppcoro with MSVC though. At the moment I'm mostly interested in coroutines to make making generators easier, but at least for those, MSVC's STL provides `&lt;experimental/generator&gt;` and `std::experimental::generator`: https://godbolt.org/g/FjLMgG
Okay... :-) Thanks for the comment!
Which tool allows that?
Most CVS integrations for any major IDE allow that. There are also several web-services that provide more than just syntax highlight for you code. I.e. https://woboq.com/codebrowser.html
not ultimately, but for big reviews I sometimes start from comments nad later moderate them, to avoid focusing on unnecessary details from the start.
Yeah, I got a little ahead of myself there. If you were to implement delayed rendering with the current APIs (by passing NULL to SetClipboardData), you'd need to handle the WM_RENDERFORMAT window message to actually provide data. The OLE clipboard is more object-oriented, so it lets you provide your own implementation of IDataObject to use as a callback, rather than going through the wndproc. 
A way to set an executor (with the necessary constraints) would have been better than forcing only one implementation to be used. You're basically preventing the user from fixing his thread count to a few and sharing these threads with the logging system.
The library has a Java API so it can be used in Android applications. Java has no concept of destructors, hence the need for manual memory management when dealing with JNI. If you’re only using C++, you could easily wrap that in a smart point.
Actually you don't need to destroy anything, the engine will do the cleanup for you. But we consider it a better practice to manually do it when an object isn't needed anymore.