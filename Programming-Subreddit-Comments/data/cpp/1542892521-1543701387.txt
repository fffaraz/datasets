Bad idea to use `std::any` since `std::any_cast` does type checking every time, since by design you can only have contains objects of type `Base`. So the overhead of your proposal is a function pointer + type checking even if the latter isn't required at all.
u/steveire in a comment above mentioned [https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/](https://steveire.wordpress.com/2017/11/05/embracing-modern-cmake/) which points to this video: [https://youtu.be/JsjI5xr1jxM](https://youtu.be/JsjI5xr1jxM) I've seen him giving the same talk on ACCU and I can recommend it.
You underestimate the issue if you add all requirements. std::any type erasure is trivial because it is binary, b/w two types (source to destination and destination to source). To have full featured polymorphic_value you need to be able to convert-construct from any point in the hierarchy (A&lt;-B&lt;-C) - you must be able to convert-construct from already erased type (poly&lt;A&gt; from poly&lt;B&gt;, where poly&lt;B&gt; is created from poly&lt;C&gt;) and still correctly, upon copy, clone the original object (copy of poly&lt;A&gt; clones C). 
This book is really great, and just got updated to CMake 3.13: https://crascit.com/professional-cmake/
https://crascit.com/professional-cmake/
Because the answer is completely wrong. The sibling comment by /u/notayakk gave the correct answer.
Have you run the code in a debugger ?
We're not provided one on our university network unfortunately.
Do you think we will debug it for you?
&gt; Discussions, articles, and news about the C++ programming language or programming in C++. &gt; &gt;For C++ questions, answers, help, and advice see r/cpp_questions or StackOverflow. 
Being a library author/maintainer sure sounds fun.
I see thanks.
At a quick glance the use of the "meter" variable is suspect. When you say "int meter = ..." In the do while loop you're that's a new local variable not the one you declared up top. Besides that, using vector instead of an array for "people" will simply debugging. By default you should use vector over array anyway. Since I tried to help I want to offer some criticism as well since you said this is a school project. If you're a cs student: beware, your instructors have failed to warn you about some seriously bad practices (arrays, declaring your varibles all up top like that, reusing variable names in nested scopes). If you're not a cs student: you may find a language like python more comfortable for small scrips like this. I hope it was helpful. Also for future reference I think /r/cppquestions may be more suitable for this type of question.
That was my first thought too, but never does it loop beyond 199999.
Is there an issue opened for this bug?
meeter1 and meeter2 are declared just before the first loop starts, above srand. I'll try to convert it to a vector to see if that solves it, thank you very much! Luckily not a CS student, it's an extra module I'm taking, although it's not something I'm likely to ever use.
I have a hard time believing that any standard installation of an OS with a C++ compiler doesn't include any form of debugger... Even if all you can access is a command-line "gdb" then it's definitely worth learning how to use it.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
No problem. Good luck!
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9zelcr/begginer_needs_help_with_map/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I use a mixed type for postfixes, like auto myPrettyColor\_red, myPrettyColor\_blue;
I just found out that C++ shared libraries are just glorified static linking. (From an API point of view anyway...) Thought about making a C API for two days and then just decided to make it a static C++ lib instead.
It would have been nice mentioning a third known use of `inline` namespaces: how they are nested in the standard library to provide fine-grained selection of UDLs through `using namespace`. It is nice that `using namespace std;` and `using namespace std::literals;` import every available UDL from the standard library while using *e.g.* `using namespace std::chrono_literals` only imports UDLs related to `&lt;chrono&gt;` (instead of having to write `using namespace std::literals::chrono_literals` to import them). This is made possible by the `namespace std { inline namespace literals {inline namespace chrono_literals {} } }` structure.
That's a bottom-up approach at teaching. I'm personally not a fan and prefer top-down both in teaching and in learning but anyway. See how even you suggest something else as a first language. In the article I do mention that assembly and C are a better choice that C++. Not a fan of the idea, but at least I understand where it's coming from.
&gt; the languages which I would recommend for good first language are: Ruby and C# smh
Good catch! Haven't thought about it as I never use UDLs precisely because you need `using namespace`.
I wonder if people really think it makes a difference what gets taught at school / university. In my experience time is short and you won't get further than variables, functions, loops and branches and maybe a little object orientation in any language. And at that point the difference between the languages are basically non existent. And if you decide to just stick to what you learn in school and not go out and learn something yourself you'll end up like me and try to program FPGAs in Delphi. I'd say the first programming lessons aren't about specific language futures anyway and the only thing i'd fight for is that teacher should probably take a little time and explain that there's a right tool for anything and depending on what you're doing you might want to look into another programming language. And don't be scared they are not that different and after this course that covers all the general you will be well prepared to start working in any programming language you choose to. 
Thanks, interesting.
No
At uni I hated my top down classes and loved my bottom up classes
The difference between languages that have memory management and languages where you need to understand memory and manage it yourself is pretty drastic. Other than that though, yeah.
You are ProbablY thinkinG of staYabovethelavacase. I'm PrettY sure You should onlY caPitalize GlYPhs that hanG below the baseline; You keeP the GlYPhs sQuished uPPwards to avoid the lavaPool.
The only thing `__declspec(dllexport)` is doing in this case is forcing the compiler to generate all the automatic members that the C++ standard says it should (because the compiler cannot know which members a user of the .dll will use). Without `__declspec(dllexport)`, the compiler only generates the members that are used, as an optimisation. If you add something like `foo f; auto g = f;` to `main`, you'll get the same issue. I'm not sure if this only-generate-what's-used is standard compliant or not, I expect there's a MSVC flag to disable it somewhere...
The naming conventions in that book are total crap, at first I though it was using stroustrup's conventions: **Classes\_are\_written\_like\_this** and **variables\_and\_functions\_like\_this**, but then, he uses **camelCase**.
If it's your first language, and you also want to work in embedded systems or gamedev, C++ and C are your only realistic options. These industries don't care about having pretty modern code, nobody has time for that. What's next, you're expected to learn how to drive in an autonomous car?
For gamedev a lot of games are made using Unity which is C# so saying that C++ and C being the only "realistic" options is unfair.
I teach in a university, and after I found Kate's "Stop teaching C" talk I thought "Finally someone who agrees with me". But I myself are self-taught in the transition from C to C++, so I had to unlearn a bunch of things.
&gt;A key part of learning to program is playing with existing code. Are there codes that are intelligible to a first semester beginning programmer? I doubt it. &gt;C++ does not have a build system. So? In your first semester you will barely reach the stage that separate compilation makes sense. No build system required. Besides, what's wrong with Make? &gt;your friends start showing off with some small games, Impressive. But could they code the event loop that your game framework gives you for free? &gt;C++ is three languages in one. I'm glad the author agrees that, while this is true, you don't teach all three at once. &gt;these complexities are not just hidden They are, if you actually teach programming, rather cobbling together libraries and frameworks and whatnot. Yes, std::vector has a whole bunch of constructors, but if I teach my students just one or two, they never see the complexity and still they can write decent programs. They can discover the complexity later. &gt;competence of the teacher I absolutely agree with this point. There is a lot of dreadful material out there, clearly produced by someone who is clearly not a master of the language. PS my own course materials can be found here: [https://bitbucket.org/VictorEijkhout/textbook-introduction-to-scientific-programming/src](https://bitbucket.org/VictorEijkhout/textbook-introduction-to-scientific-programming/src) please send me comments because I'm sure there things that can be improved. It's a work in progress, but I think it does a decent job of teaching modern C++ from the ground up. &amp;#x200B;
The difference between languages that think memory is the only resource that needs to be managed and those that don't is drastic too. 
IME and IMO under_score loses its advantage when coupled with all the operators and special characters programming languages (especially C++) have. I find `camelCase.PascalCase` or some variant of that much more readable than `under_score.under_score` (e.g. visually the parts in `score.under` seem to be closer together than `under_score`). It's also nice to have a different casing for types and methods.
Ahhh. I see. Its picking the volatile overload because the volatile overload does not take the variable by reference, or reference to pointer but by pointer. Since converting from nonvolatile to volatile is allowed, but still technically a conversion. It is preferred less than the array overload(s). Further the reason why the const char *&amp; is not chosen is because we're dealing with a constant pointer pointing to const char, which can't be automatically converted to a non-condt reference. That makes sense ! Still bloody broken, of course :)
Wait, what? I mean, are you describing the first class in a university course on programming? By the end of a 4 year degree in CS, you should have a chance to write in a dozen languages at least as alien as assembler, C++, LISP, Verilog, Matlab, Java and make. You should have exposure to complexity, understand why Halt is hard and why almost everything is Halt, with a chance to go deeper. You should have completed a few projects; mini-OS's, bignum libraries, a cpu, a compiler for a toy langnuage, hand written a ray tracer, etc. Or do most universities really suck? 
I mean, its a hack, but i think its much less of a hack than using SFINAE for this. The third option might be tag-dispatch, but I haven't tried it yet, and I'm not sure that's any less of a hack than volatile or SFINAE
Boo(st)
i though about schools because i think that is where most people learn their first programming language? At least my school did and that was a good 20 years ago. What i am definitly not talking about when talking about a first programming language is a 4 year CS degree. My guess is not many people start a CS degree without having learned a programming language. But my experience at my university is much different, cs students might have the luxury of learning multiple languages - for me as an engineer it was different. There was one class teaching the very basics about c++ and one elective for matlab and latex. There's no room to learn multiple languages or dive deep into it, it was just expected that we do all the things you mentioned on our own time. But most people are busy enough learning all the math and physics to do that. 
y tho
I think you might be missing the grandparent posters point. Java and c# are cancer precisely because they have massive standard libraries. The lead to lazy students who can't understand what's actually happening under the hood. I learned java first, and almost dropped out of college because it hides such a huge amount of complexity that I was drowning in the unexposed details. It crippled my ability to learn the notion of pointers and arrays. In fact, I didn't truly understand how garbage Java's object lifetime model really was until I spent time working with java native interface. And was forced to figure out c++ with trial by fire. I've since moved past those struggles by a huge amount, but i essentially refuse to touch java and c# for anything serious. They're a gilded cage for the mind. Pretty and comfortable. But still a cage. I refuse to touch python for anything. The whole concept of semantically significant whitespace is just stupid.
&gt; violating Paul's Second Rule of Makefiles
I stumbled over the exactly same issue with 3.12 .
http://make.mad-scientist.net/papers/rules-of-makefiles/ Some people call in "tongue-in-cheek", but I think that's a misrepresentation. Rather, it's how to avoid a set of common mistakes - if you *really* know what you're doing, you can break the rules, but you should be able to justify it. Notably, calling `make` if no files have changed should not rebuild anything. you can create `%.o : obj/%.o`-style rules for forwarding when you explicitly call one, but normally you should have an `all: $(patsubst $(wildcard))` rule so just you *don't* have to specify one. The only tricky part is that you have to actually specify your dependencies correctly - but it looks like each output file only depends on the input file and a few filters.
Ah, I see! Thanks for that. Yeah, I was really just (ab)using `make` for convenience commands. I'm thinking maybe I should use something else ü§î
How? template&lt;typename STRING_T, !std::enable_if&lt;std::is_array&lt;...&gt;&gt;&gt; void foo(const STRING_T &amp; );
Why Boo? 
No, your use case is *perfect* for Make. You're just not spending enough time micro-optimizing.
The linked paper on pattern matching made me weep salty tears of joy. Any idea when/if we can expect this to fall into our laps? Great read btw, awesome work.
One doesn't always have a choice... 
C# is not forcing windows though 
&gt; Java and c# are cancer precisely because they have massive standard libraries. The lead to lazy students who can't understand what's actually happening under the hood. He then immediately says: &gt;I could see an argument for Python first, but I still feel like you're going to make some coders with bad habbits out of it. Yhea... Python is much worse with this than most...
The only-generate-what-is-used is compliant and it enables the OP's code to work (without the `dllexport` part). Disabling this would break templates in a spectacular way.
Yeah, what I meant to say is: same compiler + flags =&gt; will work different compiler or flags =&gt; might not work I‚Äòll reword.
Thanks for this. IMO boost process is way too clever for its own good (looking at you naked arguments)
I have a similar project I use to [format my resume.](https://github.com/FlyingRhenquest/resumetron) I store it in XML and use a [xerces wrapper](https://github.com/FlyingRhenquest/cppxml) I wrote in C++ to read the XML and output LaTeX. My XML parser is from when I was just getting back into C++ again. I really should re-do it one of these days. 
Let me guess: giant legacy code and management refusing to let modernization happen?
Great :) P.S. Thanks for the article, I'll have to investigate what impact it would have on KDE Frameworks if we decided to adopt inline namespaces for ABI control.
Even if you succeed, trying to "emulate" the behavior of atomic, or any lock-free structure/algorithm (successfully, to the point of being correct) won't be possible with Javascript, or more concretely the runtimes javascript naturally works in. Simply because there is no notion of that in it's memory or threading model. Not trying to dissuade you from what you do, but if your goal is to show using (Typescript) how C++ algorithms work, you can take it the other way with wasm/emacsen - still write in C/C++ and get it running under the browser (maybe I'm missing something here). E.g. I don't think STL translates well into a dynamic language like TS/JS - simply because it would seem like an overenginered piece there - we need STL, because C++ is first about not paying for what you don't use, but then something that works almost anywhere else and become a familiar ground with almost every C++ programmer. This is hardly the case for JS, TS, Dart, or other languages targeting Javascript (more directly, than emacsen/wasm). Again, I could be missing an important part of your project here. 
My condolences.
Good luck with that :) - But I'm sure there must be plenty of embedded, game development (especially console), etc. libs that would be geared towards more C++98 (not because modern console compilers do not support modern C++, but simply because of the reactions to new modern C++). Qt must be still C++98 (or available for compilation this way), maybe EASTL (haven't checked recently) - e.g. not sure what you are looking for... And there are still plenty of good "C" libs, or if your case allows libs written in modern C++, yet providing C interface (llvm, zmq, etc.)
Also take a look at this: http://blog.qt.io/blog/2018/11/19/getting-started-qt-webassembly/ - and the comments section about threads.
While I certainly am not advocating you do this, technically you do have a choice still. You could not participate in the project, quitting your relationship with your employer if it comes down to it. There's always a choice. Just a lot of the time the choice is to work on the project.
It's the code base actually incompatible with c++11 or are you just not allowed to use the functionality or do you have top deal with sich outdated tools?
I really really want inspect(or whatever) :). I think I heard it wasn't making 20 but 23. But I don't know where I heard that.
tfw I'm just a pleb that writes a word document...
I never understood the bad reactions. Makes zero sense to me. Even game developers should appreciate move semantics, mandatory copy elision, some of the new containers, ranged for, structured bindings, fold expressions, type safe variadics, etc.
What are the benefits of this over just writing it directly in LaTeX? 
It insures my sections are regular and I can fairly easily have it output to other markup languages as well. In addition to the LaTeX output, I can also currently output to plain text, which is handy for those job sites that always seem to ask for everything on your resume again no matter how you upload your resume. Since it's XML, I should also be able to write a stylesheet to display it prettily in HTML, although so far I haven't had a need to do that. Honestly though it was mostly just an excuse for a fun "learning C++" project!
&gt; If you really need to have a constexpr keyword use the rule: "Any function with the attribute "constexpr" can only be invoked with arguments known at compile time". &gt; What happens when you want to call it with non compile time arguments?
Direct support for tables! `::: tonytable` 
i guess that's a valid use case. I've never written a move ctor where I wasn't sure if it could throw (surely they should never throw..?) but I guess it could happen
I don't think there is. But clang-cl introduced a potentially relevant /Zc:dllexportInlines- flag: http://blog.llvm.org/2018/11/30-faster-windows-builds-with-clang-cl_14.html
And looks like there's a feature request: https://developercommunity.visualstudio.com/idea/374754/implement-zcdllexportinlines-aka-fvisibility-inlin.html
I prefer ninja for this https://github.com/RedBeard0531/better_exception_ptr/blob/master/build.ninja#L13. But at this point I wouldn't touch make if given any other option.
How does this compare to the existing RMQ algorithms? Some are mentioned in https://en.m.wikipedia.org/wiki/Range_minimum_query
thought this would be critics to recent proposals which only target symptoms of the language before clicking the link. Anyway it's a well-written article.
BESM-6 assembler?
Never ever encountered such a beast. It was more like pascal but written in Russian (while loop was written as "–ø–æ–∫–∞", for loop as "–¥–ª—è" and so on). Thinking about your question, now I'm happy that at least it wasn't an assembly of some type :D 
Shows a blank page with only an "Edit" button that does nothing. Any chance for a pastebin?
I posted a new thread where I demonstrate the real ORB part of the IDL system, if you are interested: [https://www.reddit.com/r/cpp/comments/9zl6v5/the\_orb\_sees\_all\_the\_use\_of\_an\_object\_request/](https://www.reddit.com/r/cpp/comments/9zl6v5/the_orb_sees_all_the_use_of_an_object_request/) &amp;#x200B;
Transcript?
Yeah ok but seems a bit radical... I've bills to pay and dont live in a country where I can swap employer like clothes... 
Legacy project with Legacy tools... 
I happen to understand much better and faster the resumable functions model. I do know you put a lot of work in coroutines and that they have been refined in many ways. But I still think that the fundamental design should not be tied to the language as much as possible. In that sense, resumable functions are more lightweight and can get await and others implemented on top of it. What I do not know though, it is if there is any inherent limitation in resumable functions that is not true for coroutines TS/merged proposal. I just see a resumable function and I see a function object with no type erasure saving the address to reenter. I know the memory it could take. I know how to make a custom allocator. And I do not need to learn what a code generator does in the compiler. It also has the advantage that a more library-based approach to await is more easy to experiment with.
I am just wondering, that if I explicitly want to make foo visible I could also declare D a friend of C. In this case using C::foo would work again. And it is really explicit so I (at least I am supposed to) know what I am doing here. Still, the same doesn't work for constructors.
Doing anything else never even occurred to me. Fucking programmers, man.
What do you mean by school ? For a lot of my peers, the first programming language they learned was on their third year of university (with a bit of Maple or MATLAB before)
Haha, I've had almost the exact same school projects. You in Bordeaux by any chance ?
&gt; Every function has this "out" pointer passed as an input argument: `string foo()` actually takes 1 argument at low level - where to place the return value. We can extract it from assembler code but this is `ABI`-specific (`r0-r3` for `arm`, `x0-x7` for `arm64` and so on) - you can check calling conventions for desired arch. Is this true for functions returning trivial types? I thought `int foo();` puts the return value directly in a register. `struct my_struct { int x, y; }; my_struct bar();` might also. &gt; No, with the return value optimization there would be a call to a string constructor directly for return value: `string a("hello");` becomes `out = std::string("hello");`. How are you reinterpreting semantics for this metaphor? I treat `out` as a pointer to uninitialized memory on the caller's stack having suitable size and alignment to hold a `string`. `new (out) string("hello");` is the placement-new expression that constructs a string in that memory. 
Weird, works for me even on mobile. Here is the pastebin: https://pastebin.com/6huUFaec
I know there is mono, but can you create GUI apps with that?
move ctor/assignments and dtors should never throw
Er... afaik Windows Forms is supported on most desktop platforms?
&gt; Every function has this "out" pointer passed as an input argument No, not in general. `void` functions don't, and a function returning a simple value will with most calling conventions just place it in a register, e.g. 32-bit x86 `eax`. 
&gt;This idea to assign the initial value did not come out of nowhere. This is a misunderstood advice, which is otherwise good, that you should assign meaningful values to your objects upon initialization. But this advice is talking about meaningful values. And because of the constraints of the interface of functions fill_1(), fill_2() and fill_3(), we do not have a meaningful value to start with, so using some arbitrary value 0 which we will overwrite anyway does no good to anyone I disagree with this quite a bit, if because of broken code v is uninitialised in a case where the static analyser doesn't catch it, you'll get undefined behaviour instead of well defined but wrong behaviour. The latter is much more likely to be caught during testing, but the former could work silently for months before suddenly breaking
In your example you know the address of the object that the function returns, namely `&amp;a`. If you're going to placement-`new` something there better destroy the current object first. But why isn't assignment good enough?
Its not a good choice. Just a choice. I'm kind of being pedantic here. Not really suggesting you quit.
Let me guess...Spain?
You're on r/cpp. Are you *not* a programmer? 
For "void func(T arg)" arg will be passed as a value in register(s) and the result is returned in the same register(s). And return value placement depends on variable size(if it's known at compile-time and if fits in register): for fundamental "int" eax will be used most likely, for "float" - floating-point register(st0) and so on. If return value is not fit in register/unknown size - caller shall reserve memory and pass this address as an additional argument. (indirect result location register).
As far as I know this was initially proposed to be a full talk. Submit it again somewhere else :)
I realized that halfway through writing ;) I'll post it soon.
May I ask why do you want placement new instead of 'local variable creation' syntax? Since they would exactly the same work (both would create a new instance of std::string in a place provided by the caller and labelled `a`), I don't see the reason to prefer placement new.
Done: https://gitlab.kitware.com/cmake/cmake/issues/18625
Now there is: https://gitlab.kitware.com/cmake/cmake/issues/18625
This is definitively amazing!
A missed opportunity to say "With `&gt; format C:\`".
`+=` is the real winner here.
Hi Sovog, Thanks for your comment! Christoph, the author, here. You observed correctly, that this is indeed one variant of the RMQ algorithms you mentioned. It is obvious, that searching for both min and max in a given sub-range simultaneously does not add extra complexity. When reading through the article, it seems I may sort myself into the case of "Solution using constant time and linear space" especially because of the use of Cartesian Trees which seem to resemble my embedding of the tree into an array quite well. While solving this problem, I have actually looked for such a tree-embedding which I could not find easily. Cartesian Trees would have been the answer I was searching for. Well, now it seems, I have found my own way to implement such a Cartesian tree without knowing about it. I would say, that my approach of embedding is made fit for continuous inserts and a bit closer to C++ vectors. Other than that, (I guess because it exactly resembles the problem) it fits the concept pretty well.
Should submit a resignation from job paper. No, papirus, since paper is too modern.
More of a moment of awe, like the shit we come up with.
Btw Visual Studio Code has a really nice Markdown+LaTeX live preview.
lol I need this for my website, will have to fiddle Markdown support
\^\^ This.
Assuming you are down to C++98 and not like C++-lol-you-have-to-use-VS6, any of the Catch 1.x will work for you.
I have to agree mostly after just porting a big project to pitchfork layout(-ish): Every "module" (library, executable, CMake target,...) should have a `src` and a `include` folder just as you propose (full namespace folders in include, top level namespace(s) folder of the library stripped in src) Especially with CMake everything else is just awkward to do If you have only a single main module in the repo (besides submodules in `external`) then `src` and `include` will be in the root. Otherwise your suggested structure goes into `libs` and `extras`. Otherwise your root folder will get so cluttered with sub folders that you don't find your sources anymore (reason for my refactoring: I had it similar to what you suggest)
This is like a satire of everything I hate about modern programming.
&gt; But writing LaTeX is a real pain. I couldn‚Äôt transfer my thoughts into LaTeX directly Why is that?
I hope a language-based solution comes to C++ as soon as possible.
The reason this was turned down by the committee was something like this: // foo.cpp void foo(int x) {} // foo.h void foo(int y = 1); // bar.cpp #include "foo.h" void foo(int z = 5); void bar() { // foo(x = 3); ? // foo(y = 3); ? // foo(z = 3); ? } Have you even thought about this kind of weird usage? Granted, this isn't good code and clang-tidy has a check for this, but it is valid code none-the-less.
Actually no. C# uses gtk to render apps in mac os and linux. Code using winforms will only compile and work in windows. 
I don't write papers often, but the syntax for some things is such a pain imo. Displaying a table is a pain, doing anything fancier than that requires you to copy paste something from SO, then modify for 20 minutes because some pixel is of. At the end of the day, I've written one actual page of the paper for 2 pages of cryptic, perl-like, single use custom commands 
So, I changed the function pointer to a std::function in the grand-parent comment. Just that one line. And now everything you asked for should work. Well I did need to add constructors with SFINAE, but nothing of substance. I'm puzzled by your mention of `static_cast` to derived. I only static cast for CRTP and to-any-base. My conversion between the stored type and the base type is always an implicit cast. 
The amount of thinking I have done about this topic is nowhere near to a standard-level quality :) &amp;#x200B; The obvious inspiration was Python's \`\`kwargs\`\` machinery, but the library is at the moment nowhere near to being equivalent in term of functionality, and I don't know if it ever can get there. &amp;#x200B; I was vaguely aware of some activity on this topic in the committee, but I'll have to read up the papers in order to understand better what has been done so far.
Indeed. My mistake 
There is also Argo, https://github.com/rmpowell77/LIAW_2017_param, written by Arthur O'Dwyer, Richard Powell, Ga≈°per A≈æman and Odin Holmes. One of the author, Richard Powell, did a cppcon 2018 talk, https://www.youtube.com/watch?v=Grveezn0zhU. 
Why use this over designated initializers? Already accepted for C++20 and already works with every major compiler.
&gt; The obvious inspiration was Python's ``kwargs`` machinery Not surprising, considering you're occasionally active on the pybind11 gitter. Took me a while to recognize the username. Allowing different argument names, including none at all, was probably a not so great decision in retrospect. I also realize you can't do `foo(x = x);` where the first `x` is keyworded argument and the second `x` is a local variable, because you'd be shadowing the `named_argument&lt;T&gt;`. Well, you could, if you were to go through the committee and get this accepted and also make new parsing rules, thus making an enemy out of every compiler developer.
Right, defining a named argument is essentially equivalent to creating a global variable. The way I do it usually is to put the named arguments in a separate namespace, so you don't end up polluting the global namespace with short names such as ``x``, ``text``, ``name`` and so on. If you make the namespace ``inline`` you can then import only the named arguments namespace (a-la user-defined literals).
I am not too familiar with designated initializers, but I thought these were only for ``struct``s/``class``es and not function calls? Or are you suggesting to use them in some sort of meta-programming fashion within a function call?
oof
But this library is not affected by this issue because names(types) are effectively checked in the implementation, not in the argument list. 
Didn't that proposal have the limitation of having the ordering required to be the same as the data members declaration order? That limitation makes it a more verbose version of what we have, and I'm not sure if I ever would use that except in maybe very rare cases.
Yes, I believe you are right about the ordering.
How does that make it more verbose?
You just declare a struct, and have your function take that struct. Nothing fancy at all.
Well, now instead of just writing the arguments, you also write the argument names. It could be smaller for situations where you are constructing a long-named type in the method call, and the auto deductions fail for some reason, but that is pretty rare enough. And the main benefit, to me, with named parameters is the easy of refactoring without having to worry that, for example, swapping implicitly convertible types is going to lead to unexpected results that only show at runtime. The proposal, as it stands, would still force me to go back to all instances of the call and swap those myself manually.
You might have misunderstood. I want to get the *address* where the compiler would have put `a` without having to declare any variable. When I then placement-new an object there, I'm constructing a new object and not overwriting any existing object.
Having the address of the return slot would give me complete control of how and from where I construct the return value, while letting other code call my functions as though they were completely normal. Consider this contrived example: ``` void c_build_string(void(*cb)(char const* s, size_t len, void* user_data), void* user_data) { char const VALUE[] = "Hello world!"; cb(VALUE, sizeof(VALUE) - 1, user_data); } ``` What ways do I have to implement `std::string my_build_string()` that uses `c_build_string`? Right now, I'd have to write this: ``` std::string my_build_string() { std::string ret; // NRVO is applied, but I run the default constructor first. c_build_string( [](char const* s, size_t len, void* ret) { // Assign to an existing string static_cast&lt;std::string*&gt;(ret)-&gt;assign(s, s + len); }, &amp;ret); } ``` But if I had access to the `out` address, I could write this. ``` std::string my_build_string() { c_build_string( [](char const* s, size_t len, void* ret) { // Construct a new string in the return slot new (ret) std::string(s, len); }, out); return; // The return slot already has an object. } ``` This becomes *extremely* useful when my return type is not default constructible or is expensive to move.
Why not use designated initializers ? ```c++ struct Person { string name; int age; }; void print(Person); //... print({ .name ="Anna", .age = 7 }); ``` https://godbolt.org/z/DXn9gw
Oh no, I love designated initializers in languages that support them, I just don't feel they are that useful without the ability to reorder at will. They still have some uses though regardless like you said, but I feel they are much rarer. I understand the readability point, and agree with it, but most method calls should be intuitive, rather than require extra hints about what they require. This can be achieved through consistent API designs, or by wrapping things in a struct for complex/long argument lists. To a degree this proposal removes the need for the struct solution, but I rarely have boolean types in my argument list (because they are confusing, and lead to problems like you say), and long argument lists are a good target for thinking about if 'is this thing doing too much?'. So to me this proposal isn't as good as it could've been. That could be my use case though.
Because it doesn't convey the meaning of the parameters, especially when you have multiple with the same type.
Oh, man, it was 2 years since I dealt with this. Let see. Ok, I believe multiple inheritance will trip you because the base pointers no longer overlap. The problem is not so much preserving (copying) the original object, but correctly casting it after few reassignments b/w object in the same hierarchy - binary cast can safely get you b/w two levels in the hierarchy, if you reassign again to a different base, the original type erased cast is no longer valid. That much I remember. In any case, write a running test. Pretty much these are the cases that need to work as if these are pointers: struct A { virtual ~A() = default; int ia = 12; }; struct B1 : virtual A { int ib1 = 24; }; struct B2 : virtual A { int ib2 = 88; }; struct C : B1, B2 { int ic = 55; }; struct D : C { int id = 155; }; Any combination of assignment of pointers should be valid for poly with correct copy. &amp;#x200B; P.S IIRC the nasty case is B2 from C and then A from B2 because of the pointer shifts, messing up casting.
sure it does: ```c++ struct Lecture { std::string lecture; Person lecturer; std::vector&lt;Person&gt; students; }; void print(Lecture p) {} int main() { print({ .lecture = "CS", .lecturer = { .name = "Peter", .age = 77 }, .students = { {.name = "Anna", .age = 20}, {.name = "Rob", .age = 20}, {.name = "Clara", .age = 20} } }); } ``` https://godbolt.org/z/UoFwGD
But why would you want to go through the trouble of creating an ad-hoc structure for every function in which you might want named arguments? And with this solution I still don't see how you would handle the case in which you want to change the order of your named arguments at the invocation point.
I would say that being able to freely change the order of your named arguments in a function invocation is a key feature, at least as far as I am concerned. One of my main use cases for this library is scientific code where you might a function call with a moderate amount of parameters, all of the same type (say, ``double``). I know what the parameters are and I know what they do, but I cannot memorize the specific order in which I have written them in the function prototype (or in a wrapper struct with designated initializers). Thus, I want to be able to specify them in arbitrary order (and perhaps having default values for most of them). Does this make sense?
I found the classes I took in college to be mostly useful, although I honestly haven't used most of the languages that were taught back then. Somehow I had to go through THREE semesters of COBOL. The data structures and communication stuff was pretty useful. We never really did anything with processes and I don't think I ever heard the word "threads" until after I left. But my nephew graduated recently and I answered some of his questions about a few of his assignments and thought "Wow, they still teach it that way?" It feels like nothing has changed in the teaching scene in a couple of decades. And you can pick up some pretty bad habits there -- if they mention design patterns at all, they always make a bee-line straight for the goddamn singleton pattern, which is the wrong pattern to use in every single instance I've ever seen of singletons being used. Inevitably someone will jump to the singleton's defense, and the vast majority of those people are also using them incorrectly. Which is to say, those people are using them. I'd love to see an experiment where a class of new programmers is handed a bunch of unit tests and told to implement their code so the tests pass. For a beginning class, the very first lesson can be how to build and run the unit tests. And then just keep building on that project for the entire semester with new unit tests as you add requirements. I think that'd be pretty effective.
I want to second the suggestions for using Boost. The older Boost libraries provide much of what C++17 offers. Boost.Assign and Boost.Foreach are also decent substitutes for list initializers and range-based for loops. I would steer clear of libraries attempting to simulate move semantics; The complexity usually isn't worth it. Incidentally, I'm a quite surprised at all the "you should just quit" comments. Someone who would leave a job just because they have to interact with some older toolchains strikes me as bad software engineering material. There are many perfectly legitimate reasons to do so, especially if one is working on lower-level libraries that have gigantic client bases.
Our current target is C++23 for pattern matching.
Apparently I'm missing something. What's the problem with just initializing those variables to zero?
&gt; But why would you want to go through the trouble of creating an ad-hoc structure for every function in which you might want named arguments? Well, your approach seems to require ad-hoc creation of every name and in addition has some more caveats: - the implementer needs to put in extra work to ensure type safety - the implementer needs to put in extra work to make error-messages understandable - you require the usage of a template. In order to use the benefits of translation units we need to split the function in two: implementation and a template for named arguments Those caveats increase the amount of cognitive overhead and could be sources of more bugs. &gt; And with this solution I still don't see how you would handle the case in which you want to change the order of your named arguments at the invocation point. The order is arbitrary with designated initializers. 
Isn't the cause the bad interface (output parameter)?
&gt; The order is arbitrary with designated initializers. Doesn't the designator order need to match declaration order?
Boost, googletest, glog, fmt &lt; 5, gsl-lite and so on.
Well first off that would go against "don't pay for what you don't use". But more importantly, as discussed in the paper, this is really annoying in function templates where you don't know the type. Maybe `T` is not constructible from `0`, for example.
Correct, you can skip some but those that are there must be in the correct order. It's basically the same rules as constructor initializers.
 auto foo = T{}; ? 
Calm you give an example of a trivially conceivable type, that is not initializable by a pair of braces (T{})?
This would construct an object as an rvalue and then move-conatruct it into an lvalue, meaning two objects are being constructed. This would violate "don't pay for what you don't use", sadly. With optimizations, this would be elided out. However, what if `T` has neither a move nor a copy constructor? It would fail to compile because `T`, in that case, is not constructible from `T`.
Wikipedia says, "The primary disadvantage of many message-oriented middleware systems is that they require an extra component in the [architecture](https://en.wikipedia.org/wiki/Software_architecture), the message transfer agent ([message broker](https://en.wikipedia.org/wiki/Message_broker))." I avoid "the ORB" in my approach to distributed programming.
Since C++17 isn't this just a single construction? With the new temporary materialization rules.
Off the top of my head, no. There might be a way to `= default;` the default constructor and then provide a second deleted initializer list constructor to force a compilation failure but most likely he answer to your question is "no". But what stands is "don't pay for what you don't use". You shouldn't unnecessarily initialize an object if your intention is to assign over it later on.
Oh is it? I wasn't aware. Can you provide links? So this would compile even if the move and copy constructors are deleted?
Why that may be true, what's being demonstrated here is NOT distributed, message based communications. It's client/server communications, of which there is always a lot of in any large enterprise style system, and possibly a considerable amount of even in moderate sized systems. It's not for things like e-mail or sales transactions. It's for all those, otherwise very tedious and time consuming, interfaces that handle things like administration, configuration, remote resource management, and so on. Some types of systems may not have any message oriented stuff at all, they may be totally oriented towards that work-a-day stuff that this type of system works VERY well for. Particularly in that it extends the type safety of the language to remote calls, which is a huge benefit over time in a large system. &amp;#x200B;
Well we get designated initializer for C++20; so that's at least something.
Notice the part where it says: "The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually"
IIRC it will work since c++17 , but if not you can just do T foo{};
No, the bug would still be present if the function was reworked to do: if (c1) v = fill_1(); //... return v;
I actually prefer C++98, I find it easier to understand. My coding style might also be antiquated. My advice, instead of dreading it, try to enjoy yourself. It‚Äôs not that horrible!
Right? Haha. At least I'm being given time to work on upgrading to newer stuff :-)
Oh fascinating! I just tried it out https://godbolt.org/z/70sudN In 14 it fails to compile but it works in 17. TIL!
Yup! I was mistaken https://godbolt.org/z/70sudN
What is an 'object request broker' and how is it different from a database? What is an 'object' and how it is different from a flat data structure? Why would you want to hide remote calls and make them look like local function calls? That sounds like a performance disaster waiting to happen. Also why is some sort of alternate language needed for enums? Why not just use a hash table? When I read stuff like this I realize why it takes half a million lines
I guess the real use case I have in mind is a constexpr `absl::InlinedVector`. I'd like to be able to construct and populate an InlinedVector in constexpr while retaining the same semantics. If the number of elements in the vector is small enough to fit in inlined space, we shouldn't be allocating just to allow for constexpr construction. Constexpr deallocations that are not deallocated will take on static storage duration even if they are no longer needed. That's something I'd like to give users the option to avoid. Inlined space relies on the ability to construct uninitialized bytes on the stack. Currently such code would fail to compile without the language change presented in my paper. So I guess a good next step would be to expand the paper to specifically call out this use case. Thanks!
if(c1) `return fill_1()`
That would remove the use of an uninitialized value and replace it with a code path without a return statement. Not a big difference.
Judging by rule #1 then, the standard library conventions are poor, because by making everything lower case they tell you nothing.
Smart IDEs can reduce the need for named function arguments and designated initializers by providing name hints inline in the editor. For example, [this](https://imgur.com/a/eVwj8fk) is what name hints look like in ReSharper C++.
Which tools? 
This is honestly probably good enough.
I get warnings for code paths without a return 
I'd say swapping two member variables (or function arguments) is not something that commonly happens. :) Main purpose I see in inline namespaces is if we wanted to support Qt Quick style versioning in our C++ libraries. BI changes would be in a separate namespace v2, v3 etc. Before recompiling, the binaries would link against v1, and after recompiling it would automatically link against v2 (provided API compatibility remained between v1 and v2) In essence, instead of bumping the .so version and having several .so's on the user's system, we would bump the namespace and all versions would coexist in a single .so. All applications would link against the same .so and just link to symbols in the namespace they were compiled against.
I do understand them. It's not that they are not good, but first they have to be battle tested - for example first uses of anonymous callbacks and their hidden allocation costs were detriment to their acceptance, but later other options were found. STL in general is hard to get acceptance in shipping code (consoles), simply because a sense of lost control is seen. I (work on the toolside) used it heavily, and depend on it - there is penalty for doing so (both memory and cpu), but it eases the process, and instills safe programming - e.g. I'd rather use std::string, even with it's performance downsides over plain old char buf[SOME_MAGIC]; - but then I can clearly see why the latter would be preferred on consoles, or embedded devices. It's just the way it is. And there is still no yet constexpr's std::string literal available! 
I (and the author of the article) also get warnings for code paths that use uninitialized variables.
There's some reasonable explanations there, but why do you need client server middleware? Aren't you still just sending a request for data? Why not use SQL for small stuff and a key value store for binaries? Why not use json or a flat always serialized hash table instead of a complicated enum scheme?
&gt; Inlined space relies on the ability to construct uninitialized bytes on the stack. There is no reason, that those bytes need to be uninnitialized. The bigger question is if you are allowed to do placement new in constexpr expressions in c++20 (I'm not up to date on that front)
Do you want to placement-new one object and then return a different value? If so, you would need to make sure that the `out` address has not already been default-constructed, either by allocating it with `malloc` or `new char[]` for the heap or a static `char[]` for the stack. Eg. bool foo(string* out) { new (out) string{"hello"}; return true; } int main() { char buffer[sizeof(string)]; string&amp; str = *reinterpret_cast&lt;string*&gt;(buffer); bool result = foo(&amp;str); return 0; }
The paper I reference in my paper is the one that adds this. It adds placement new and allocation in constexpr. It passed EWG but still has work to do in CWG for wording (from what I understand). As a result of that paper we will have uninitiated memory in constexpr, but as of right now it will only be allocated bytes. My paper is bringing that same ability to stack variables which is why I'm framing it as a bug fix of the other and not itself a new feature. :)
Oh, we do. Just about every game development studio I've recently contracted with has embraced modern C++, at least to the extent their code base allows them to. There's very little reason not to, as C++ remains backwards compatible even with decades-old code. But we still generally don't use exceptions or RTTI. RTTI in particular goes against the grain of C++ features by imposing a cost even for an unused feature. Exceptions used to be the same way, although with the advent of 64-bit architectures and zero-overhead exceptions, it's mostly about inertia these days, I think. As for not using the STL, this mostly happened at a time when the STL libraries that shipped with the compilers were not nearly at the level of quality they are today. Some development houses lived with it, some used third-party STL libraries, and some wrote their own container libraries. I've worked at various places that have done each of these. These days, there's less reason to avoid using the STL libraries. They're broadly available, more stable, and you can make them perform much better with custom allocators.
thank you
There are more horrors in C++ than are dreamt of in your philosophy, Horatio (https://godbolt.org/z/S4oc6q): struct S { explicit S() = default; }; struct A { int i; S s; }; auto a = A{}; // ill-formed 
You can declare the function extern and provide the direct implementation as an assembly forwarder that calls a C++ function with the hidden address argument exposed as a normal argument. But I can't think of any reason to do that. It's like dynamic patching of vtables. People have done that, for some misguided reasons I couldn't fathom. The result was a big spaghetti with bugs crawling everywhere. 
Does A a{}; work?
At this time, it's proprietary product code. At some point here maybe we might open source the general purpose layer, but that's not the case now. Unless CORBA has changed a lot from long ago when I played around with it (because an employer at that time was considering it), it was seriously ugly in comparison, because of some of the stuff I mentioned above. How can it know how to stream in/out arbitrary classes, and it generated a raft of code for every call. The amount of code ours generates for each remote interface is tiny. Inside the client proxy, the code that handles the two methods of the demo is about 12 to 16 lines of code each, depending on number of parameters. On the server side it's even less. Here is the server side code that got generated: tCIDLib::TVoid TVideoDemoServerBase::Dispatch(const TString&amp; strMethodName, TOrbCmd&amp; orbcToDispatch) { if (strMethodName == L"bQueryVal") { ESomeValues eWhich; orbcToDispatch.strmIn() &gt;&gt; eWhich; tCIDLib::TCard4 c4Value; TString strName; tCIDLib::TBoolean retVal = bQueryVal(eWhich, c4Value, strName); orbcToDispatch.strmOut().Reset(); orbcToDispatch.strmOut() &lt;&lt; retVal; orbcToDispatch.strmOut() &lt;&lt; c4Value; orbcToDispatch.strmOut() &lt;&lt; strName; } else if (strMethodName == L"ResetVal") { ESomeValues eWhich; orbcToDispatch.strmIn() &gt;&gt; eWhich; ResetVal(eWhich); orbcToDispatch.strmOut().Reset(); } else { TParent::Dispatch(strMethodName, orbcToDispatch); } } &amp;#x200B; &amp;#x200B;
I think the words you might be looking for are "template-based static polymorphism," which kind of allows you to approach a problem of "if this object implements a method, call that method with these variables." Here's a [stackoverflow question](https://stackoverflow.com/questions/19062733/what-is-the-motivation-behind-static-polymorphism-in-c) on the subject. I have a little [demo project](https://github.com/FlyingRhenquest/oonits) that might also be of interest, it tries to automatically convert units of one type to another, for units that can be converted. I still have to write the converters in specialized templates so I can specify the unit type I want, but I can convert any unit that's convertible once that's all done. If you look at the populate_vector method in the [unit test](https://github.com/FlyingRhenquest/oonits/blob/master/test/oonits_test.cpp), that gets called by the driver of the test to populate a vector always in meters no matter what kind of unit you put into it. It's kind of a long way to go to get conversions, but it's really nice to just be able to convert anything sensible to the units you want, and it'll give you a compile time error if you try to do something like convert Fahrenheit to meters.
Sadly you can't initialise them in any order, which is something other languages with named parameters can do (e.g. Python). So it's not really a perfect replacement.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9zs1lw/can_i_specialize_a_template_only_by_a_methodname/eabuowm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
My code literally does each cast in order. If you store C in poly B2 then that in A, there is a std function that takes a any with C in it returns a B2 ptr, which is in turn stored in a std function that takes any any containing a C, passes it to the first function, then takes the return value and implitictly casts that return value to an A ptr. If you do more conversions it just nests more std functions. It (the std functions) starts using the heap to store them after the first. So long as implicit downcasts are safe my code is safe. The trick is I do zero unsafe casts; the only static cadts are upcasts, and they could be implicit to. I'm composing two safe primitives to generate the required behaviour. As mentioned, I really need an unsafe any cast for efficiency; but as it mimics my safe cast it shouldn't hurt. (I may have to check for empty manually).
Yes.
&gt; What is an 'object request broker' and how is it different from a database? an ORB is basically when you have a `class foo { void bar(); }` and when you call bar(), the call happens on another machine. That's fairly different from a database and fairly used in distributed computing. https://en.wikipedia.org/wiki/Object_request_broker
Nope :( https://godbolt.org/z/RdXCtb Also, all of this is kind of moot because there's no way to value-initialize elements of a stack allocated array. It requires the use of default initialization. Right now it's impossible to make an array of ints in constexpr.
What do you mean?
I mean that you absolutely can value-initialize array elements, and that "stack" vs. otherwise has nothing to do with it (does this mean automatic vs dynamic storage? why would this matter at all?), so I feel like you must have mistyped...
Ah! I'm sorry I might be using the wrong word. The point in trying to make is you can't have `bool arr[10];` in constexpr. What does it mean to value initialize an array? I'd like to make sure I understand my error.
I think, but don't quote me on this, that there's a difference between uninitialized memory with no object constructed in it (like you get with `operator new` or `malloc`), and a default constructed, but uninitialized object (like `int a;`). If I'm right, then maybe your proposal is not that related to the "more constexpr containers" papers.
Ah! I'm sorry I might be using the wrong word. I was trying to say that there isn't any syntax for doing `bool arr[10](false);`. Ultimately the point I'm trying to make is you can't have `bool arr[10];` in constexpr. You can assign an initializer list but that would perform a copy, which my be deleted on the type. What does it mean to value initialize an array? I'd like to make sure I understand my error.
C++20 | C++23 | Ever ---------|---------|----------- No | Maybe | Yes
Well I spoke in person a couple of times with one of the authors of P0784 about proposing this as a bug fix and he agreed that it made sense presenting in that format. He's on the committee but maybe others will disagree? We'll have to wait and see I guess. Kona isn't supposed to be for discussion of new features so that was part of the motivation for tying it to an existing feature for 2a. But I do think it's related in that it is formalizing the rules around uninitialized memory in constexpr. There is no such thing in 17 so it's entirely new and I would argue that if it's being introduced in the form of allocated bytes, the committee should at least consider it for stack variables as well.
&gt; I was trying to say that there isn't any syntax for doing `bool arr[10](false);`. `bool` value-initializes to `false` (because it zero-initializes), so just list-init or aggregate-init the array and you get that behavior. &gt; You can assign an initializer list but that would perform a copy, which my be deleted on the type. What does "assign an initializer list" mean? Do you mean aggregate-initialization? Or do you literally mean some `std::initializer_list` specialization? If I understand you correctly, this is a non-issue since C++17, as was already pointed out. ;-] &gt; What does it mean to value initialize an array? It value-iniitalizes each element in the array. See [\[dcl.init\]](https://timsong-cpp.github.io/cppwp/dcl.init#8).
FWIW Swift doesn't allow any order, either. 
That sounds like sending a command and getting data back, yet with completely different latency, reliability, bandwidth and errors. I can't imagine anything worse 
All this talk about modules makes me really want to see it in C++20.
In C99 the order doesn't have to match, so that's what most people who have actually been using them are used to.
You have a fundamental misunderstanding of the process. It's reliable, it's convenient, it's not appreciably different in terms of performance from doing it all by hand, but you don't have all the by hand potential errors in conversion of data in and out to different formats. &amp;#x200B;
Swift's argument labels are significantly unlike what people generally expect out of named parameters. Much like with obj-c, they're actually just a part of the *method*'s name which happens to usually be written in between the arguments.
I don't know if I said doing it by hand, but mixing two completely different things is terrible 
What two different things?
 #define await co_await #define yield co_yield #define RETURN co_return 
Thanks for your help: &amp;#x200B; 1. i thought of using "template-based static polymorphism" for this but i think that does not work because my Parts are normaly created elsewhere and i only got the Part\* pointer to work with - but i will recheck 2. any ideas about my question? can i specialize just with the methode-name? (i wil deleted this post now and move the stuff to cpp\_questions later) &amp;#x200B;
A function call and a network command. Also if it is just a warapper function, it doesn't need a nonsense name like 'object request broker'. 
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9zwpil/cool_things_to_learn_for_hft_internship/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
`await` is already used in the standard library. 
But in C++20 you need to preserve order.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9zxa2a/i_need_help_creating_a_efficient_binary_search/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
As well as the ones mentioned there is also: * [Modern CMake Talk by Mathieu Ropiert](https://www.youtube.com/watch?v=eC9-iRN2b04) * [Effective CMake Talk by Daniel Pfeifer](https://www.youtube.com/watch?v=bsXLMQ6WgIk) * [cmake examples tutorial](https://github.com/ttroy50/cmake-examples) - For full disclosure, I wrote this one.
I'd look the Bjarne beginner books, and some Scott Myers effective modern c++ as a great start, I would also suggest YouTube tutorials, they are a great resource and often more up to date with the latest standards.
Thank you for your reply. I'll look at the books you mentioned I know there are loads of resources, specially online. It's just that they seem to code in a different way. For example, we just started classes 2 weeks ago. Also we have been using int main(int argc, char* argv[]), and online almost no body uses it (they use namespace std) 
I understand that you are impatient, but there are things to consider. * Blindly copping other language interface is suboptimal and one of the reason Coroutines got into a trouble. For example it is written around async operations, where the coroutine concept is not related to async. This issue was one of the reasons (arguably the smallest one) to have an entire alternative proposal (Core Coroutines). Another example is the return not being regular `return` \- It turned out, the interface from other languages is not enough - and now we have a weired mix. You say over-complication, but the original "other languages" interface is in a way overcomplication by itself - the yield keyword is just sugar over await - `await promise.yield_value(...)`. In a way *we put a sugar over sugar just to be like the cool languages* \- there is a good reason Core Coroutines got rid of it. * Using an abstract keyword to mark "all things coroutine" is *insanely* enabling. We can have combination that at some point *might* have meaning: `coro break;` `coro export;` `coro throw;` `coro do;` `coro continue;` `coro some-new-contextual(!)-keyword` We can mark objects to create coroutines-related object `const auto c = [a, b, c] coro { return something; };` &amp;#x200B; None of these will be possible if we stick to the "what others do".
I'll message you haha
You can check out the below link for the main function. Cppreference is also great for looking up specific questions about the language. I also found www.learncpp.com quite useful when i first started learning cpp. Pointers were especially dreadful at the very beginning. https://en.cppreference.com/w/cpp/language/main_function 
C++ Primer by Lipmann etc. is excellent. You can also pick another book [from the recommended books list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list). Avoid online tutorials and videos for beginners, as they are all (no there are no exceptions, seriously) bad.
You can zero initialize it (which is a form of value initialization or vice versa - I don't remember). Despite the counter example by Casey, almost everything that can be defined via` T foo` can also be initialized via `T foo{}`. And even when you can't, the question is why can you initialize it later, but not at the point if definition. I'm not opposed to the proposal (I don't have a say in it anyway and as I said not a good overview over what is and what isn't possible in c++2a) I'm just saying that imho you have to work on the motivation part and explore a bit more what is and what isn't possible when you want to present this paper in front of a group of c++ experts (which I am by no means). Imho the best thing to do would be to find a commonly used type or function (preferably from a standard library implementation) that *needs* this functionality in it's implementation (there is a difference between needing it and using it currently though) and showing this as a motivation.
Always thought that pointers are quite easy ‚ò∫ it's like real-world pointer or a road sign. E.g. you can install a pointer to Suomi in Antarctica, so everyone there will how how to reach it. That way you can also install a pointer to your car in the parking. However, you have to maintain that pointer in case if you moved car or destroyed car. You'll also able to move both car or pointer to it. Or set same pointer to another car when you bought a new one.
Dang! I thought it was just user code they were trying to avoid clashing with.
I got introduced to redo by a blog article of the author of this implementation: [https://apenwarr.ca/log/20181113](https://apenwarr.ca/log/20181113) **mtime comparison considered harmful** tl;dr: Rebuilding a target because its mtime is older than the mtimes of its dependencies, like make does, is very error prone. [redo](https://github.com/apenwarr/redo) does it better, and so can you.
&gt; so there is no such thing as a c function that can either take an array by pointer or by reference-to-array with template parameter deduction for the size. fuckin wat
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9zxleo/c_for_scientific_computing/eacvh4r/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I don't understand why pointers are usually only taught as an advanced subject, given that they are such a vital part of the language. I self-taught C and initially didn't understand the concept as it was explained online. However, when I came across Assembly, I instantly saw pointers as an obvious and perfectly logical instrument for the programmer. I think most people didn't learn it from the low-level perspective, though, because of things like putting the asterisk near the identifier in declarations, instead of being part of the type, which (correct me if I'm wrong) suggests people have learnt to associate pointers more closely with the types they point to than with the concept of pointer itself (pointers have same width, can be casted to other pointer types with no actual change in value or representation etc). C* seem very logical to me since they closely follow the actual logic happening under the hood. They're difficult languages to learn because they don't perform any "protective" abstraction, but keep in mind that learning a higher level language is much easier than taking up a lower level one. I'd rather first get used to the heavy mindfuck then proceed to ease my work than the other way.
You may like [Shake](https://shakebuild.com/) then. It is extremely configurable and allows to change the rebuilding criteria in fine-grain manner.
Just a quick look, "Shake can execute ninja files" that's awesome. Will certainly look further into that!! Cheers mate
By the way, there is a recent paper comparing and classifying build systems: [Build Systems √† la Carte](https://github.com/snowleopard/build) ([direct link to a PDF](https://github.com/snowleopard/build/releases/download/icfp-final/build-systems.pdf))
I don't understand the problem this is trying to solve. Why should we not have 3 different keywords ?
About 20 years ago I used LaTeX for uni stuff as well, including my final project. Together with my roomate we started to use Publisher and later switched to PageMaker for the reports that required a bit more graphical embleshiment. Nowadays I just use Word.
`vector` has an allocator, too. ;-]
There are multiple reasons why not. * Out of nowhere snake\_case prefix. No other keyword have such syntax - they just stick the words together - `alignof`, `constexpr`, etc. Arguably even `coawait` is a better option, as it is consistent with the rest of the language. * co\_ is redundant in 2/3 in the cases it is used - only `co_return` technically needs it as it disambiguates new action from an old one. For await and yield it is purely to escape collision (and be "consistent" I guess) as the notion "coroutine await" is redundant - there is no not-coroutine await. * If you have to create new meaning out of an existing one we have tools for that - *modifiers*. We don't have `unsigned_int`. If you want to have a new return - apply a modifier - this is the correct way to do it.. * Keywords scale badly. If we need new coroutine tools we have to invent new keywords as these are extremely specific. A modifier can be combined to create new expression and apply new meaning to old constructs. * Having a crutch syntax like that screams "afterthought" making C++ less attractive. 
The C language doesn't have "references". So there's no such thing as a C function that can take an array by reference. The C language doesn't have templates, so there's no such thing as a C function that takes an array and uses template parameter deduction for the size. Lastly, there is no such thing as a C function that has the same name as another function but takes a different type of argument. So there can't be a C function that accepts a pointer, and another C function with the same name that accepts an array by reference.
What relevance does this have to r/cpp?
This is not the programming subreddit that you're looking for. *hand wave*
Ok thanks, fingers crossed : )
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/a01zvu/hello_i_have_a_homework_problem_please_help_i/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
heresy
OK! 1. You can use "magic statics" to avoid the "is initialized" paradigm; the language will handle that thread-safely for you. 2. The lock should be as short as possible 3. Speaking of locking, don't see the mutex locked anywhere 4. You cannot just create mutex in scope and expect anything to happen; it has to be visible to all threads that lock it Just first things that pop into mind. :) 
Well just ban redeclarations with different names :p
This looks like a pretty neat library! Quick question: on POSIX systems, is there any way to execute code (perhaps a lambda?) between `fork()` and `exec*()`? It's probably a niche use case, but these are some examples of things I do before exec in my projects: * Using `unshare()` to create new mount, pid, net, etc. namespaces * Switching to another user or dropping privileges * `chroot()`ing to a sandboxed directory
It can use a different ABI with different optimizations applyingg. E.g. I'm pretty sure that for a long time msvc wouldn't ever put small structs in registers, e.g. calls to `void foo(int x);` and `void foo(struct { int x; } x);` (typing on a phone but you get it) will have different codegen.
So single lock object across all places in my code that will change var symmaltanously ? I appreciate your suggestions and looking for more 
this should be in /r/cpp_questions
1. I can't see a reason, why you would hand the callback as argument, I think I would call K::callback(..). Enlighten me if there is a reason 2. Who sets stop to true and stops everything?
That's great if you can detect them, but if they are in separate translation units, you can't even do that. LTO gets you half way there, but throw in a shared object or two and you can't even do that. In other words, say hello to ODR violations.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a02956/need_your_comment_about_my_src_code/eae15pv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Nowadays ODR violations are detected, eg ubsan alerts you when it happens.
Off-topic.
Titus, the chair of the tooling study group of the committee, says ubsan also catches only some ODR violations. It's a step in the right direction, but you apparently can get "clever" and fool lto and ubsan.
Currently this isn't supported. One problem I can see with adding this is that there isn't any way to do the same on Windows so we'd have to see what to do with the API (reproc is still a cross platform library unfortunately). 
I am uncertain what you mean.
I'm going to piggyback on this for a related const question. If I declare "const int foo = 3;" in a function, and then I pass &amp;foo to another function that uses a const_cast and modifies the value, is that allowed, or is it undefined behavior?
Let say you have function which has const ref as argument. But compiler cannot assume (for optimization) that value of var doesn't change, because you can use const_cast in body of function. I just wonder, if it's possible to avoid this.
Using `const_cast` to modify an object that was defined as `const` is undefined behaviour. So no, it doesn't prevent optimizations that would apply to a `const` object because they can never be `const` in the first place. `const_cast` is basically a no-op when used to change constness.
Why do you need to change the value of a const variable?
No you cannot. Well if the value is actually const you can.
Modifying a `const` object is UB. `const_cast` is mainly useful for passing `const` objects by pointer into old poorly-typed APIs that won't actually modify them.
That can happen even without `const_cast`. Consider `meow(const int&amp; cr, int&amp; mr, int * mp)`. If `cr` and `mr` refer to the same `int` (something defined as non-`const`), modifying `mr` will change the value observed by `cr`. Same for `cr` and `*mp`. This problem is known as ‚Äúaliasing‚Äù and it‚Äôs one of the reasons why compiler back-end development is difficult, skilled work.
excuse me .. I will try that I am just a beginner 
No it is not
I believe this code is ill-formed: a `const` object of class type must have an initializer except for certain circumstances; having a mutable member is not listed as an exception (C++17 dcl.init/7.4ff) clang seems to accept the code but that looks like a bug (gcc rejects it) 
&gt;Modifying a const object is UB. Although it is not UB to modify a mutable member of a const object (which still counts as modifying the const object).
You probably have 30k lines and 970k lines of 'object request brokers'
Thanks. 2 days ago, so removed this one as duplicate.
If you ever even bothered to read anything I've written instead of just auto-rejecting everything, you'd know that the amount of code generated is very small. 
Using `const_cast` to remove a `const` qualifier is UB only if you then modify an object, and if the original object was declared const. It is **not** UB if you start with a mutable object, construct a `const` qualified pointer or reference to it, then use `const_cast` to remove the `const`. static int a = 1; static int const b = 2; void foo(int const&amp; x, int const&amp; y){ // This is fine, a is now 11 const_cast&lt;int&amp;&gt;(x) += 10; // This is UB. // b might have been in RO program memory. const_cast&lt;int&amp;&gt;(y) += 10; } foo(a, b);
I read everything, even though, imagine this, it was overcomplicated nonsense that missed the point of what it was trying to accomplish. 
Well, so far the most painful bit, by a couple orders of magnitude, has been the UI framework. It has so many enums for window styles and options, position options, input keys, gesture options, and on and on. All of these have to be eventually passed to the underlying OS where they need to be converted to numeric values. And lots of them are bitmapped values that are being combined in various ways, which doesn't work automagically anymore, and that part of it extends out of the UI framework to all window creating code. This all definitely encourages one to create plenty of pre-fab combinations of bitmapped enums, to avoid having to combine them on the fly.
^ bingo
This is technically correct. But usually, when people say "modify an object" in context of C++ and constness, they typically implicitly mean "modify non-mutable state of an object", because saying latter is too verbose, and mutable members are a rare and exceptional (perhaps even obscure) case anyway.
`const_cast` is useful besides that. You can avoid code duplication on the `T&amp; foo()` vs `const T&amp; foo() const` case.
But the whole repo is written in C++... Idk mane, where should I post my C++ projects then?
Absolutely none of those are a concern at all under normal conditions. If you want to use a known-broken tool, don't blame the non-broken parts when it fails. It would be *way* too much effort to make a point-by-point rebuttal. 
It's written entirely in C++.
foo() is defined in Base or Sub?
fooey() needs to be virtual. 
Hi /u/Bombadillo1229! I agree with /u/bunky_bunk. fooey() must be declared virtual in A. Whenever I need to test out or share code snippets like this, I find godbolt.org is invaluable. It can help you write out situations like this and avoid confusion when trying to describe code in plain english. For example, here's (I think) a faithful reproduction of your question: https://godbolt.org/z/zOcJLz Also - judicious use of override saves the day here! While it isn't explicitly required by the language, it can be very helpful in situations like this. For example, if I fail to name A::fooey() virtual, but use override in B::fooey()'s declaration, the compiler will kindly remind me to declare A::fooey() as virtual. Good luck with your project!
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a05hja/question_about_oop_with_c_new_to_oop/eaeshud/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It must prevent optimizations related to const references. For example: void foo(bar const&amp;); void main() { auto bar = make_bar(); if (bar.value == 0) { // stuff } foo(b); // takes a const ref if (bar.value == 0) { // The check for bar.value cannot be // optimized away, since foo can const_cast // legally and mutate value } } The original `bar` local variable is not const. Because of that, any const reference that binds to that object means *nothing* for the optimizer. Unless of course the definition of `foo` is available.
Reddit syntax uses 4-space indented blocks for code formatting IIRC, not ```.
VS doesn't provide a designer for GUI development with WIN32, as far as I know
I think one of the main issues is that you can't determine whether a function is pure via constness of its arguments. You can always modify a global variable every call, so you can't reuse and cache the result to avoid repeated calls. Also, in some situations you may not be able to modify a const qualified instance but someone else does (concurrent or multi thread programs for example).
IIRC const cast is merely there to disambiguate a C style cast when you want to call C interfaces that do not use const, but warrantee that the object is not modified. For example, calling pthread create when your thread function does not modify the contents of the pointer argument.
Usually optimisers rely on undefined behaviours to improve performance. As others said modifying a const reference is UB and the compiler can just delete it altogether, or summon evils that come out of your nose, as someone said once.
Chandler Carruth and "accessible topics" is a bit ... props to you if you do find it accessible, he usually goes deep into some obscure aspect of the compiler's workings. This year was spectre, I had to use the pause button a couple of times. Very interesting tho.
Yes it does, but only in cases, where the optimizer a) can't see the body of the callee anyway, b) can prove that the calle can't possibly have any other mutable reference to the parameter that is passed by const ref and c) doesn't know that the argument itself is an actual const object. As for why const cast is allowed: Because C allows it (at least that's my guess).
Came here to say exactly the same. A compiler could track ‚Äòconst_cast‚Äô alone but there are numerous ways to alias the same memory region, like unions, arrays, pointers to pointers, etc. 
I guess you are referring to the following comment: https://old.reddit.com/r/cpp/comments/9zy0ak/redo_a_recursive_generalpurpose_build_system/eactnx5/ In the link given in that comment, it is explained why the modification time is not a reliable indicator of change in the source files. So now to your question: That depends on the environment in which the build is taking place. If it is your private hobby project which you build on your own computer, you have every control over the build environment. If you are building a web app or service for some cloud company, you still have a relatively large amount of control. If, in contrary, you are releasing an open source library which is build on a multitude of platforms and in a multitude of heterogeneous environments (think boost libraries), it is quite critical that the result is correct no matter what. And then you need certainly account for the fact that mtime resolution is limitied to one second on MacOS, and different machines in a networked environment can have different system times. NFS, for example, has a lot of limitations, but for a collaborative networked environment it is one of few options available. 
But `make_bar()` may have stored a global reference to the object, which can then be modified by `foo()` even if it had no parameters. I don't see what `const_cast` has to do here.
Does the \`restrict\` keyword still(?) allow more optimizations, or is it generally not worth the hassle?
A single \` works as well. `example`.
No it may not. As far as I know, the main don't have a reference. The main has a copy of the return of make_bar();. But anyways that's not the point, let me edit.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/a08b2r/can_anyone_help_me_solve_this_question/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Both very similar, yes. I wonder if the standard will include a similar function in the future. Definitely it looks like fitting well.
If the const version has the same code as the non-const version, you don't need the non-const version of the method 
This is awesome and so super useful in practice. I'd love to see that added to the standard library. It's pretty generic enough.
Which header should this live under? &lt;iterator&gt; is my best first guess since that‚Äôs where begin/end/size live. I have the time to write a paper/proposal, but I would need some feedback and shepherding (I definitely will not make it to WG21 Kona).
NFS: Who ever though that building over NFS was ever a good idea? Simply put who ever thought it would be a good idea to share a build, whatever it is (not only c++), on a shared storage? Whatever the build system, redo included, it is not designed for that, unless there is an equivalent of a distributed lock to ensure transactional updates at the build level (or the target level). Fuse: Building stuff over some fuse fs... Like NFS but I may see a more realistic use case so why not. Anyway, if the fuse-fs does not support mtime correctly, the problem lies in the filesystem itself, not the tool for building. nmap: hum yeah ok why not... I don't why what tools that modifies some source-code using nmap, but in worse case, should not be difficult to `touch` the file to force update. Spurious rebuild, like a file has been modified then restore before a re-build: triggering some incremental re-build outweight by far the full-scan of all single files in the repository. It is fun on small repositories, but does not scale at all on more realistic ones, open-source or at a company scale. Checksum of all the files is really costly, even on modern hardware. And even if you have everything in memory, you can see some big differences. This is without talking about dealing with assets of course. Precision of a second: hum are you really modifying your files that fast even between each build? :) Removing a dependancy: This one is for sure a makefile issue, but other tools like cmake have additional rules which will invalidate the binary and will force a re-link. symlink: this one indeed may screw up the build, we all agree on that. Even if it is not really a problem from my point of view. Regarding `it is quite critical that the result is correct no matter what`, well, that's why many encourage CI/CD process, and if your build is not correct locally, probably blame your own rules which are certainly incomplete. At least, that is what experience teaches us. The advantages of using mtime outweight by far than costly full-scan of each single files. `Redo` does nothing new here, `scons` does that by default for years, and at least, it is optional. I do agree tho that in some very particular use-cases it can be handy, but as an optional mode, and certainly not the default one.
Probably &lt;ranges&gt; Casy wrote an implementation https://wandbox.org/permlink/4jhh70CUy1yEX7RR - although LEWG will probably want to see an enumerate_view type along view::enumerate If you write the paper and I manage to get to kona (not sure yet), I'll present the paper 
[cppitertools](https://github.com/ryanhaining/cppitertools) is also worth a look for anyone interested in python like iterable stuff 
Isn't this already covered by `view::zip` proposed in P1035? Here's an example from the paper: auto in = view::zip(view::iota(0), istream_range&lt;int&gt;{std::cin}); auto weighted_sum = accumulate(begin(in), end(in), [](auto const a, auto const b){ auto const [index, in] = b; return a + (index * in); });
In the redesigned reddit, it also renders code with ```, but unfortunately not in the old reddit.
There is also a pull request adding it to range-v3: https://github.com/ericniebler/range-v3/pull/941 If anyone wants to write a paper, it might be useful as well
Wouldn't struct iterator : TIter have better space performance if TIter is empty? Though, that would only be relevant for the unit container.
"Because it would break code" - we don't only have to be compatible with C, but also previous C++ standards. One thing that has been discussed is having a `template &lt;typename CharType, std::size_t&gt; std::string_literal`, which if used in a parameter list, would be a better match for a string literal than a const pointer.
Nice. A couple of questions: (1) The third line &gt; typename = decltype(std::end(std::declval&lt;T&gt;()))&gt; is an SFINAE way of ensuring that `std::end` can be applied to `iterable`, right? (2) Shouldn't `iterator` have `operator==`, too?
Where did y'all go to learn how to read and write template stuff?
You can always compose things, but a dedicated function would be nicer.
I like how C++ is turning into zero-overhead Python.
Are you from the past? You forgot .net core 
Also no GUI.
Sure there's gui, just not from Microsoft. Unless you count aspnet core, which you should
Thanks for the reply, Mr. Gor. Your proposal has two obvious advantages: more refined in real-world workloads and implementations available to test them. That said, what I would like to see maybe it is something that mixes the easy understanding of function objects with other things. I am not sure whether resumable functions can be done less heavy-weight or if there is any inherent limitation. But, and I say this from the POV of a person familiar with C++ idioms, I understand function objects, shared_ptrs, and many other things and know how they can be optimized. That said, I am not sure how far it could go the performance of resumable functions compared to Coroutines as implemented now, and my understanding is that something close to max performance is essential, so if Coroutines are superior in that sense, that would be a big point for them. As for all the compiler-generated hooks, I think it would be good if part of that in one way or another could be moved to a more library-based solution, since once this is added into the language... you know, there is no easy way back.
Thank you! Is there anything that you would add or change?
Thank you! Is there anything that you would add or change to/about the paper?
Well, frankly, no we don't *have* to be compatible with either C or previous C++ standards. We choose to. I'm not disagreeing that backwards compatibility is desirable, and I'm not saying that breaking backwards compatibility is something to do lightly, but I am perfectly fine with breaking backwards compatibility for something as counter intuitive as functions taking pointer-to-type being preferred over functions taking reference-to-array-of-type. I think it's particularly evil that the pursuit of backwards compatibility could litter the language with work-arounds like the so named std::string_literal type. While there are great arguments for std::string_literal that don't relate to the function overload problem I described in my original post, I think it's bad taste to argue that we should complicate the function resolution rules even more than they already are by giving special status to a newly introduced type. 
&gt; Isn't this already covered by view::zip Yes, at the cost of requiring quite a lot of boiler plate for a very common pattern. Unfortunately the standard library regularly falls short of adding those nice short helpers for common patterns (that it took more than 20 years to add ranged overloads to standard algorithms is a prime exmple for that - another is &lt;random&gt;) 
It doesn't seem to support `initializer_list`, so this fails: for (auto [i, v] : enumerate({1, 2, 3})) You won't be able to deduce `T` from an `initializer_list`, so I think you need an overload: template &lt;typename T&gt; constexpr auto enumerate(std::initializer_list&lt;T&gt; l) { return enumerate&lt;decltype(l), decltype(l.begin())&gt;(std::move(l)); } Apart from that, it's a beautifully written piece of C++ code that makes me kinda warm and fuzzy inside. Kudos.
It does return a reference: `*iter` returns a reference and `std::tie()` returns a `tuple` of `Types&amp;...`.
&gt; I'd suggest getting your terminology right and your facts straight. It's much harder to defend a proposed change to C++17 if you don't know what C++17 does Absolutely! I'm still new to all of this and I agree that the gaps in my knowledge need to be filled to make a stronger argument. &gt; I suggest carefully reading through [dcl.init], several times if you have to. Will do, thanks :) &gt; P-numbers should only appear on papers in their final form; use a D-number when you are circulating a draft for feedback. Yikes! My apologies. I'll fix that &gt; Why do we not fix the (not yet introduced) "new T" inconsistency in C++20 by requiring initialization there too rather than relaxing the existing constraint? This is an excellent question that I'll have to think about and discuss with others. Maybe that's the better approach. &gt; Have you consulted compiler implementers on the implementation costs (and if so which ones?), or is it just your guess? I've spoken in person and over email with Richard Smith (both initial talks but also review of the paper as it is currently written). He and I are in the same group of teams at Google. I also sent it to Chandler Carruth but haven't heard back. &gt; What about indeterminate values that are not UB (i.e., unsigned char)? Also a really good question. I might need to add a section about this. &gt; If you are making performance claims, do you have actual numbers? I'm not currently making any performance claims. It's was more about making generic code easier to write in constexpr. What kind of performance claims might I be able to make? I work primarily in C++11 and I didn't realize that `T t = T();` no longer, even conceptually, calls the move constructor (as evidenced by this thread) so without that I'm not sure if there are performance wins to be had. Thanks for the feedback!
&gt; I'd suggest getting your terminology right and your facts straight. It's much harder to defend a proposed change to C++17 if you don't know what C++17 does Absolutely! I'm still new to all of this and I agree that the gaps in my knowledge need to be filled to make a stronger argument. &gt; I suggest carefully reading through [dcl.init], several times if you have to. Will do, thanks :) &gt; P-numbers should only appear on papers in their final form; use a D-number when you are circulating a draft for feedback. Yikes! My apologies. I'll fix that &gt; Why do we not fix the (not yet introduced) "new T" inconsistency in C++20 by requiring initialization there too rather than relaxing the existing constraint? This is an excellent question that I'll have to think about and discuss with others. Maybe that's the better approach. &gt; Have you consulted compiler implementers on the implementation costs (and if so which ones?), or is it just your guess? I've spoken in person and over email with Richard Smith (both initial talks but also review of the paper as it is currently written). He and I are in the same group of teams at Google and it was based on his feedback that I added the sentence claiming that implementing checks for whether a variable has been initialized is similar to checking for out-of-lifetime variables. I also sent the draft paper to Chandler Carruth but haven't heard back. &gt; What about indeterminate values that are not UB (i.e., unsigned char)? Also a really good question. I might need to add a section about this. &gt; If you are making performance claims, do you have actual numbers? I'm not currently making any performance claims. It's was more about making generic code easier to write in constexpr. What kind of performance claims might I be able to make? I work primarily in C++11 and I didn't realize that `T t = T();` no longer, even conceptually, calls the move constructor (as evidenced by this thread) so without that I'm not sure if there are performance wins to be had. Thanks for the feedback!
1. Yes 2. Outside of a for loop, it could be said that operators outside of the increment don‚Äôt necessarily make sense. Also, this would then also cease to work with containers without random access iterators. 3. This is already taken care of with decltype and auto. 
Don‚Äôt forget that const and ref decorators are preserved in the decltype and auto signature. 
This differs? dafuq?
Reasoning: Struct members must have different addresses. This rule comes from C. So, a zero-size member will occupy at least one byte in the struct. However, base class addresses are not required to be distinct from each other or from member addresses, so any number of zero-size base classes count zero towards the size of the extending struct. You can use this trick to pack the hasher and comparator members for a container which allows custom hashers and comparators, since those are usually stateless (thus, zero-size).
Dagnabbit you guys! Where's the cream filling? I have two recommendations, but alas they teach **game programming**. However, I'm seeing a lot of book suggestions and not a lot of "build a full thing" suggestions. One of these has two sets of playlists(beginner and advanced) that include the whole learning process(videos in order), and it reaches up to C++14(mostly in the advanced playlist). I did not do the beginner playlist but it seemed to cover it all. However the advanced playlist taught me more than ever, including rarities like actually making your own library / game "engine" separated from the game itself. It uses **SDL 2.0** and is OpenGL related in general for graphics. Also, in advanced, very **Object Oriented Programming**. The name of that one is: \--- === \[({ **Making Games With Ben** })\] === --- Link(YouTube): [https://www.youtube.com/user/makinggameswithben](https://www.youtube.com/user/makinggameswithben) &amp;#x200B; The other has an assortment of heavily console-based projects, but my goodness they are outstanding and easy to digest. They are a tad more **code it so it works** and sometimes a bit less object-oriented. The console based first-person shooter was.... it was **easy, and quick to do**. They are mostly **low-tech, console** creations, but **almost always graphical** still. The name of this channel/person is: \--- === \[({ **javidx9** })\] === --- Link(YouTube): [https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA/videos](https://www.youtube.com/channel/UC-yuWVUplUJZvieEligKBkA/videos) 
&gt; I've spoken in person and over email with Richard Smith (both initial talks but also review of the paper as it is currently written). He and I are in the same group of teams at Google and it was based on his feedback that I added the sentence claiming that implementing checks for whether a variable has been initialized is similar to checking for out-of-lifetime variables. I also sent the draft paper to Chandler Carruth but haven't heard back. Name-dropping The Smith is an easy way to assuage implementability concerns for people who don't write compilers. Do it early. Do it often. &gt; What kind of performance claims might I be able to make? I work primarily in C++11 and I didn't realize that `T t = T();` no longer, even conceptually, calls the move constructor (as evidenced by this thread) so without that I'm not sure if there are performance wins to be had. Conceivably, value-initialization just to overwrite later can incur costs if the optimizer can't remove it. We just added several `*_default_init` function templates for smart pointers for this reason. This of course only really matters if the constexpr function is evaluated at run time, but your `InlinedVector` example, at a first glance, seems like it could be a case for it (assuming that I guessed the behavior correctly from the name). Another potential argument could be that the current specification prevents constant initialization when the type is trivial. Take your first example: auto nontrivial_rt = f(NontrivialType{}); auto trivial_rt = f(TrivialType{}); `nontrivial_rt` has constant initialization (and the `_rt` suffix is rather misleading), but `trivial_rt` doesn't, so the latter may conceivably be initialized dynamically, with all the fiasco-y potential. Removing a subtle trap for the unwary can be a good justification for change.
Why not the good old classic ? : auto a = A();
Yeah, I know all of that, my previous comment was not supposed to be a reply to you. I downvoted myself...
&gt; Name-dropping The Smith is an easy way to assuage implementability concerns for people who don't write compilers. Do it early. Do it often. Noted! &gt; This of course only really matters if the constexpr function is evaluated at run time Absolutely. You could write it with two implementations (one for constexpr that initializes the memory and one for runtime which doesn't), but that means you aren't really writing generic code. My personal desire for this change is wanting to simplify library code (since that's my job!), though I understand that isn't usually a good justification in it's own right. &gt; Another potential argument could be that the current specification prevents constant initialization when the type is trivial. Take your first example: &gt; `nontrivial_rt` has constant initialization You're so right! My co-worker **just** did a talk at CppCon that involved this and I completely spaced it. I will definitely add that because allowing such functions/constructors to be evaluated in constexpr would give users constant initialization where they previously would not have had it. Thanks!
How is that implented? How does redo know what paths the compiler is searching?
I don't think I fully understand what's going on here. Please correct me ~~if~~ where I'm wrong! In the case the function is called with an rvalue like so: enumerate(std::vector{1,2,3,4,5}) T &amp;&amp; iterable the parameter means T is deduced as std::vector&lt;int&gt;? This way when put together we get "std::vector&lt;int&gt;" + &amp;&amp;. However now in the function this parameter has become a named rvalue reference - presumably this is just another name for this variable in the function of type std::vector&lt;int&gt;&amp;&amp; here? Then the last line happens: return iterable_wrapper{ std::forward&lt;T&gt;(iterable) }; Here the static_cast&lt;T&amp;&amp;&gt; (std::forward implementation) collapses with the std::vector&lt;int&gt;&amp;&amp; ie. static_cast&lt;std::vector&lt;int&gt;&amp;&amp;&gt;(std::vector&lt;int&gt;&amp;&amp;) // -&gt; std::vector&lt;int&gt;&amp;&amp; &amp;&amp; -&gt; std::vector&lt;int&gt;&amp;&amp; Phew. Or do both the references fall away and we get left with just std::vector&lt;int&gt;? (I feel writing this I've just become more confused...) Regardless of whether the type of the argument passed to iterable_wrapper is an rvalue reference or just an rvalue, I believe it then constructs that container from this, which in the case of an rvalue will result in move construction if available. We then return the iterable_wrapper which will now manage the lifetime of our vector and everything's great. In the case the function is called with an lvalue. This time do we end up making a copy as our forwarding to iterable_wrapper yields the type T&amp; which is then copy constructed on construction of the iterable_wrapper's iterable member. This copy could be unnecessary in the case where we just wanted to read values in a vector, but we copy the vector anyway? On a [previous post about the same thing I commented] (https://old.reddit.com/r/cpp/comments/9qhe02/enumerate_rangebased_for_loop_with_indices/e8dvxk6/) this took the other route I believe and held a reference to the container parameter but then has lifetime issues if passed an rvalue... This seems the other side of the coin to the one above? Is there a way to have our cake and eat it? Have I missed something?
Would not this fall apart in the case of proxy iterators?
Yes it would. This version of `enumerate()` fails for `vector&lt;bool&gt;`.
He said the second `if` can't be removed...
Why do you think it would cease working for non random access containers? Uncalled methods can have unusable code in them.
Must be il const reference due to lifetime rules.
Your SFINAE is wrong. struct bob { int x; friend int* begin( bob&amp; b ){ return &amp;b.x; } friend int* end( bob&amp; b ){ return begin()+1; } }; `bob` is iterable: for(int x:bob); but your enumerate SFINAE rejects it. You have to get fancier. 
True it won‚Äôt work in the sense that things like binary_search won‚Äôt work but I suppose it would compile and do everything else in the more pedantic sense
&gt; My understanding then is that an optimizer *could* remove the second `if` if it could determine that b.value doesn't change. Isn't that addressed by "Unless of course the definition of `foo` is available" though? I don't understand the confusion here. :-S
Hm. Here's me getting bit again by `initializer_list` not being a container. I don't even think making it a const reference would extend the lifetime since I'm passing it around three times. I'll redact it because it's too damn late tonight.
&gt; I don't understand the confusion here Me neither. The code says the second `if` "cannot be optimized away since foo can const\_cast". I'm saying the second `if` can _never_ be optimized away, regardless of `const_cast`. (unless `b.value` can be determined at compile-time, which isn't the point of the example).
Nope.
Isn't the `T iterable` in the iterable_wrapper going to make a copy? 
&gt; It accepts its parameter as an rvalue reference so you can apply it to temporary values (e.g. directly to the return value of a function call) as well as to variables and members. You got the code right but technically it's actually forwarding reference not r-value reference. These two have confusingly similar syntax. Still hoping to get &amp;&amp;&amp; to easily distinguish it sometimes in the future.
How many types with empty iterators do you know?
&gt; It accepts its parameter as an rvalue reference so you can apply it to temporary values That is not a feature but a bug! If you pass in a temporary, that temporary will get destroyed before you reach the loop body leaving you with dangling references. (IIRC there was a plan to extend the lifetime of temporaries defined in the loop header, but I don't know the status of that)
Good article, but a static analyser instead of a language that allows intend to be clearly encoded is also treating the symptom and not the cause. In the particular example in the article, we actually have 3 distinct cases of values b1 and b2, but the language does not easily allow us to encode these cases. However, if C++ had pattern matching, the compiler could easily complain about duplicate clauses. 
Suppose there is a function *f()* in a static library which uses RVO inside and compiled separately. If the assembly of the calling client side code *Obj a=f();* depends on the existence of RVO, how will the compiler know how to compile the calling code? Is there a sign at the compiled static library function that this function uses RVO inside?
Exactly my point. So why worry about that. 
3rd year? My varsity's first c++ module was the first semester of the first year. My Second year was data structures &amp; algos and computer organization and architecture(x86 assembly)
Well for me, years 1 and 2 were mostly exclusively maths and physics with a bit of french and english
&gt; ‚Ç¨9.99 Original Price ‚Ç¨199.99 Discount 95% off I wouldn't trust anything that uses this kind of advertisement practices. 
Yes I know, it's very painful and all Udemy courses does that.
"Arrays and Vectors" - no, it isn't. Arrays are advanced, vector is basic.
"In this video we learn to use C-style strings and the functions in string.h" - yes, and after that tey teach std::string. Crap!
Check this one from Coursera. It is in French, but they have subtitles in English. I didn‚Äôt do this one because I already knew C++, but I did their second one related to OOP with C++ also FREE! This coursera course was way better than my CS class on C++. https://www.coursera.org/learn/initiation-programmation-cpp
You could probably find where the course has been stolen from instead 
It is udemy being shit, not the content itself. There are some great courses. 
I think this is what happens: * If we pass lvalue then T will be deduced to lvalue reference and no copy (of the container) should happen. * If we pass rvalue then T will be deduced to container's type and we should get a move.
`range` and `span` are completely different things, the former is much more versatile, but forces you to use templates. Compile times and binary size matter a lot in some projects.
I think you are missing that in case of rvalue `enumerate()` internally moves container into `iterable_wrapper` which then manages container's lifetime. That is, temporary is deleted, but it has already been moved.
Does anyone know what is the reasoning behind not allowing them to be used in any order?
Absolutely correct - sorry. However, I'm not sure how I feel about that solution. When I pass an l-value container I also iterate over a copy right?
This is a nice little blog post which shows thoughtfulness and effort. The Compiler Explorer sandbox is a nice touch. Although to be honest, I am a pragmatic engineer and I see nothing wrong with `span`.
&gt; Was it a BSc? no, it's french engineering degrees. Two years after high-school in "preparatory classes" (mostly maths and physics as I said), followed by a competitive exam ; your ranking determines in which schools you can go to. Last year, the biggest exam had... around 7000 students competing, for ~1000 available seats in engineering schools ? When you arrive in engineering school in year 3, that's when you can start doing actual computer science, for three years, if that's what you want to do.
&gt; I mean, if it's true, why for example const\_cast isn't only allowed in functions/methods marked with special keyword? I think it might be the case that it is just not worth it. The only place that I know of where const based optimizations apply follow a pattern where the same value is recalculated multiple times, but can not be cached by compiler, e.g.: void foo(size_t); void bar(const std::vector&lt;int&gt;&amp;); void test(std::vector&lt;int&gt;&amp; v) { foo(v.size()); bar(v); foo(v.size()); // v.size() needs to be recalculated } * Programmer can cache the result in a variable himself. * Function to be called in-between must not be inlined or else optimizations apply anyway. * For compiler to cache the result it needs to know that the function is pure. * Recalculation often costs very little, e.g., caching the result of std::string::size() would only make the code bigger and slower. [https://godbolt.org/z/rXJhIF](https://godbolt.org/z/rXJhIF)
:D yeah nice shot. many tutorials are based on a stolen content.
Why? I mean, why are you stuck with C++98? Can't the codebase be slowly ported to C++17 ? Like, first making sure it compiles and run with C++17, then start migrating the codebase, each time you have to implement something new. Unless this is pure maintenance with zero future, it is mandatory for whomever manages that codebase to make it evolve, or it will just die.
&gt; management refusing to let modernization happen? If there is any value in the codebase, management should let the modernization happen, or they won't be able to find anyone of value to work on it in a few years. 
by reading the relevant chapters of "effective modern c++" by scot meyers over and over again ¬Ø\_(„ÉÑ)_/¬Ø
Nice try? Are you selling on Udemy or what? In case you're genuinely uninformed, they're notoriously known for selling content they don't own. This is not some speculation. BTW, I don't think aggregating information into a tutorial is stealing content for there is still work done into patching everything together in an easy and cohesive way. In any case udemy is shady and should be avoided.
&gt; I'm saying the second `if` can *never* be optimized away, regardless of `const_cast`. Okay, I see what you're saying now ‚Äì I just don't agree. ;-] If the definition of `foo` is available, and `foo` indeed does not touch its parameter, then why couldn't it? Indeed, a 30 second test on compiler explorer shows the branch happily disappearing when `foo` is changed from a declaration into an empty definition..
I'm proposing to add `RangeOf` in addition to span not to replace it
&gt;cor3ntin.github.io/posts/... Consider: generator&lt;int&gt; onetwothree() { co_yield 1; co_yield 2; co_yield 3; co_return; } Note how the co_returned value doesn't match the return type. That's because the actual "return" is compiler-generated and the `generator&lt;int&gt;` value it produces provides a way for the caller to control resumption. Could we overload the `return` keyword to mean coroutine termination? Yes (because the actual return is compiler-generated and therefore never appears in the source), but I think it's a bad idea.
That's because `foo()` is inlined, and when it's empty, both `if`s can be merged. If `foo()` is not empty, then the `if`s cannot be optimized away. Something like [this on godbolt](https://godbolt.org/z/YWVWpE). Even if you make `foo()` take no parameters, the second `if` is still there. If _anything_ happens between the two `if`s, then the second test cannot be avoided, how could it?
As a non-library developer I'm astonished every time someone mention ranges as something more intuitive or readable that the alternatives (std::span in this case). Also please factor compile-time cost when advocating a solution against another. 
I only see one `if` here: https://godbolt.org/z/I5-pAe
No
That might be a bad decesion.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/a0lub0/need_some_helpfor_what_level_of_a_c_programmer_is/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It's the small shit like this to try to force people onto the redesign.
&gt; My goal is not to master C++. &gt; All I want is to have a thorough understanding of how my computer, compilers and programming languages work, and of course be efficient enough in C++ (and why not in C?). These are somewhat contradictory goals. 
!removehelp
Likewise Gurtovoy and Abrahams' *C++ Template Metaprogramming*.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a0imcj/is_this_c_course_on_udemy_worth_it/eaimgw1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
[It seems that the compiler assumes that any function that returns an object is RVO](https://godbolt.org/z/ZEc3LO). When calling `f()`, the destination pointer is passed to `f` using `rdi` and nothing is returned, but when calling `g()`, nothing is passed and the returned object is read through `rax`. `call f()` is the last instruction for the RVO call, whereas `call g()` is the first instruction in the non-RVO call.
I guess this implementation works for a simple for-each loop case. But there is an `enumerate` view in the Range library, which I assume is more robust: https://github.com/ericniebler/range-v3/blob/master/include/range/v3/view/enumerate.hpp
If someone sent me a code review changing void f(const std::span&lt;const int&gt; &amp; r); into template &lt;std::ContiguousRange R&gt; requires std::is_same_v&lt;std::ranges::iter_value_t&lt;std::ranges::iterator_t&lt;R&gt;&gt;, int&gt; void f(const R &amp; r); I would murder them.
the title kind of implies replacement.
What about `void f(const std::ContiguousRangeOf&lt;int&gt; &amp;)` ? 
The dream! (Also "Python with static typing")
My understanding is that lifetime extension isn't transitive through arguments and member variables. Having a `const&amp;` as a member variable won't make the `initializer_list` from `enumerate({1, 2, 3})` stay alive past the end of the statement. I'd have to work around it by constructing a `std::vector` from it or something, which is more work than I intended to do in a short comment.
What throws me off a bit about your post is how you always call out that the standard library containers make sure that the destructor gets called. While it is actually true that most implementations of e.g. std::vector have to do special work to call the destructor, this is only because these containers operate in "weird" and uncommon ways with memory for maximum efficiency. The point is: You have to go out of your way to *not* call a destructor, instead of the other way round, which is what makes it so useful. Also, it is wrong that "many standard library collections make sure destructors are called": all of them do, of course. Still, I thought this a nice and easy to read write-up.
`span` is like `string_view` and `function`. You shouldn't be deducing its template arguments. Thus, template &lt;typename T&gt; void f(const std::span&lt;const T&gt; &amp; r); is generally not useful. Additionally, just like the other pair-of-pointers types `string_view` and `initializer_list`, it should generally be passed by value: void f(std::span&lt;const int&gt;); Next, `ContiguousRangeOf&lt;int&gt;` as you defined it is neither `span&lt;const int&gt;` nor `span&lt;int&gt;`. It's effectively `span&lt;const? int&gt;`. If you further check that `iter_reference_t&lt;iterator_t&lt;R&gt;&gt;` is `int&amp;`, then it's perhaps an adequate replacement for `span&lt;int&gt;`, but there's no easy equivalent of `span&lt;const int&gt;`, which can accept a possibly mutable range but generates a diagnostic if the function attempts to modify the range.
Well it lasts until the end of the full expression, which doesn't help the for loop. ;) I'd delete it, then add a variardic one that stores an array s `enumerate(1,2,3)`
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/a0nq8v/book_review_request_concurrency_with_c_rainer/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Wow I'm dumb. I meant to say `async` and that wasn't even one of the options. I completely forgot about the `yield` function, too.
That indeed could work. Sounds even like it could be trsted rather easily in a toy project. The only remaining questions are: i) does this problem really exist in the KDE/Qt world, that this approach tries to solve? And ii) we have to maintain more API this way, so is this desirable?
I agree - this would need to be researched more for KDE
Ah thank you! So in the case where enumerate is passed an lvalue then T is deduced to `T&amp;` so no copy is made. In the case where enumerate is passed an rvalue then the parameter `T &amp;&amp; iterable` is deduced to (for example) std::vector&lt;int&gt;&amp;&amp;, and then T is deduced to `std::vector&lt;int&gt;` and so iterable is move constructed from the temporary?
F# fits that description more directly in terms of syntax, right down to the significant whitespace.
Does this position require knowing French?
Looks interesting! I'm hoping to get a chance to spend some time exploring this. I did want to mention that I believe the OMG has provided a C++11 binding for CORBA that's considerably nicer than the C++98 one. There's also ZeroC Ice, which I've used in production (granted, a long time ago) and had a good experience with. Thanks for sharing this!
Strike 1: template &lt;typename T&gt; void f(const std::span&lt;const T&gt; &amp; r); a `template` function that takes a type-erasure type is questionable. But a `const&amp;` of a `span` is just ridiculous. It is like taking a `const&amp;` of a pointer; almost always code smell. When **your very first use** of the thing you dislike is like this, it isn't a good sign. Strike 2: template &lt;std::ContiguousRange R&gt; requires std::is_same_v&lt;std::ranges::iter_value_t&lt;std::ranges::iterator_t&lt;R&gt;&gt;, int&gt; void f(const R &amp; r); &gt; There we are done. Easy, right? So, every time you have a requires clause without a named requirement, and instead do an ad-hoc requirement, that is code smell. On top of this being *not easy* (only marginally easier than SFINAE), it isn't well done as a requirement. This is acceptable: void f(const std::RangeOf&lt;std::string&gt; auto &amp; r); but, it serves a different purpose than `span`. &gt; shying away from templates and concepts in the hope of slightly faster compile times forces us to deal with types that are easy to misuse and fit poorly in the C++ type system. Span is a non-owning pointer-with-range. Pointers fit in the C++ type system. I've used them in piles of ways that your RangeOf/ContiguousRange wouldn't work with. I've used them in an interface of a type-erased owning data buffer, to whole-hog replace `std::vector&lt;T&gt; const&amp;` with `span&lt;T const&gt;` and code that is strictly better. Like, in 99/100 cases I can do a regular expression replacement of `std::vector&lt;T&gt; const&amp;` parameters and replace with `span&lt;T const&gt;` parameters and get code that is more generic, compiles as fast or faster, and permits new operations (like divide and conquor). Type erasure has its place. And `span` is an awesome unit of type erasure. And yes, range concepts have their place. But calling it a better `span` is saying an orange is a better apple. They are different categories of thing. 
I have to say I'm surprised that there is still so much racism and people who think that non-whites or non-Asians can't be good at programming. I'm going to admit that if I have no other information, I will assume everyone on the Internet is a American male in his 20s, but that's just the most likely thing (though here the age may be higher). But who cares if you don't look like we expected, the inside is what matters. Especially for programming, it should be obvious that the outside is completely irrelevant to the job. I haven't use sol2 (or sol3), but it seems to be pretty good, I'll definitely try it out.
Right direction imo
[*C++ Templates: The Complete Guide*](http://www.tmplbook.com/)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/a0r6xr/help_with_grabbing_user_input/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;so much Selection bias
Perhaps a `coroutine` keyword used to mark a function as a coroutine would have been a better idea. Then `return` would mean `co_return` in such a function. `await` and `yield` could then even be context sensitive keywords, which are only reserved in the body of a coroutine.
You also have a ‚Äòstd::unoredered_map‚Äô and an ‚Äòimplemetations‚Äô hiding in the text...
&gt; I'm surprised that there is still so much racism &gt; I will assume everyone on the Internet is a American male in his 20s
There is a difference between racism and making (wrong) assumptions based on statistics (or most likely personal environment). 
It doesn't imply racism. I expect every soccer ball to be black and white. If one is blue and yellow, I'll say "Oh! That's unusual. Doesn't change anything anyway.", and not "How strange. I'm not sure I will be able to play as good as I'm used to with that ball".
This looks like a great library, very minimal and easy-to-use. I may test it in my key-value database NavDB: ([https://navdb.io](https://navdb.io)) as an alternative to Boost Asio.
Thanks for the kind words. Please be aware that it is still very premature. I do plan to address the issues though.
That's explained here: https://redo.readthedocs.io/en/latest/ Also, there is a redo-ifcreate command which works the same way. If one knows which paths the compile will search, for example by looking at the C++ include path environment variable, checking places where new files would change the build result can be implemented like that, starting from the linked description: redo-ifcreate $(echo ${DEPS#*:} | sed -c 's/usr\/include/user\/local/include/g' ) Better is if the compiler would provide a list of include file names which were absent but would change the result of the build process if that file were created. That would make build in different environments more reliable. I'd be curious to know /u/WalterBright 's opinion on this :) 
What would be the Benefit? A contiguous range of T is the one and only type of range, where you can perform zero cost type erasure (with a pointer and a length or two pointers). There is no reason to expect any performance improvement by turning it into a template.
Yes
`C obj; obj = f();` is not RVO. `obj` is first default constructed, then assigned-to from the returned temporary. `C obj = f();` is not an assignment. It is an initialization.
&gt; Do you want to placement-new one object and then return a different value? No. I really want to return **the** object that I placement-new. Not a copy of it. not by moving from it. That exact object. In C++17 you can return a `std::mutex` by value. `std::mutex` is neither copyable nor movable. This works because there is no copy or move. Not even in principle. The object is simply constructed directly in the location where it will ultimately end up. I want to do the same thing, except instead of returning an object directly `return std::mutex();` or declaring and returning a local `std::mutex ret; return ret;`, I want to construct **the** return object with a placement-new expression `new (return_slot_address) std::mutex();`.
`span` is like `function_ref`, not `function`.
&gt; and making (wrong) assumptions based on statistics (or most likely personal environment). &gt;people who think that non-whites or non-Asians can't be good at programming.
Maybe I‚Äôve skimmed too fast, but my favorite clang tooling wasn‚Äôt mentioned. It‚Äôs scan-build. A static analyzer which runs during the build process. https://clang-analyzer.llvm.org/scan-build.html
I'm glad to see more people than me really prefer chained/member functions. I makes the code so much readable (and writeable)
Are there statistics suggesting that? I feel like you've missed the point.
Just when I noticed that 2018.2.x got slow at executing tests ("Resolve...takes longer" dialog showing), the 2018.3 fixed it. The test round trip feels faster. :-) Remote development and profiling look very promising...
Will browser open pages faster now?
[removed]
Man. That graph is disturbing.
I'm not sure what you skimmed :). Yes, there are many clang tools. This post is not about `scan-build`.
The ownership semantic is clearer imo. And I would not expect a lot of instantiation to exist anyway. Also, if RangeOf should exists, it make sense that std::ContiguousRangeOf would too
&gt; Also, I think the author doesn't pay enough attention to the main use-case for span, which is as a sort of "type-erased" contiguous range. Not everything can (or should) be made a template, and span at its heart is just an abstraction for a pointer to an array that knowns its own length. That's fair, but the opposite is true too: not every body cares about compile time / code size. Then span lose its interest. I think both would have their uses Also missses the bigger point about non-contiguous ranges &gt; (In fact, I would be happier if it was just called std::array_ptr&lt;T, N&gt; and had pointer semantics, including shallow copy, shallow const, and == comparing by identity, but maybe that's just me.) +1
Classic design by committee.
I want to be excited about the remote development, but am not sure what part to be excited about.. is it just so you can develop stuff on your laptop that takes a much bigger computer to run "for real"? My issue is that my laptop is old and slow and that getting a remote computer to do the grunt of the IDE work would be awesome (figuring out completions and syntax highlighting), but I don't think that's what this is.
&gt; The ownership semantic is clearer imo. On the contrary: A span is not owning - full stop. An instance of std::ContiguousRangeOf can be owning or non-owning (e.g. could be a vector or could be a span) &gt; Also, if RangeOf should exists, it make sense that std::ContiguousRangeOf would too Just like it would make sense to have a contiguous iterator tag? 
Thanks for this. I mean that both positively, and negatively.
Main thing I want is for it to stop eating my processors when I use templates. 
?
Check out [jeaiii/itoa](https://github.com/jeaiii/itoa) for ultra fast and correct integer to text conversions with nice code generation.
If you're the author, would it be possible to dual-license the code under MIT and Boost? While MIT is permissive, MSVC's STL is currently using only Boost-licensed source code (Boost.Math and Ryu). The difference is small but currently relevant to us.
I think this is about compiling. E.g. you want to compile on a Raspberry Pi. Or on a big machine because it's faster.
It's likely for people (like me) who are required to use Windows to develop Linux programs. That said, it looks like the CLion java process still runs locally, so it wouldn't help much with what you're talking about (though it would offload the actual build). You may be better off doing what I do now - run an X11 server locally (even as awkward as that may be) and run CLion itself on the server. Can cause hiccups in the UI if your X11 server isn't great :/
That is what RVO does. There isn't any benefit to doing it manually. [Example:](https://godbolt.org/z/F6i122) The functions generate nearly identical code, though the RVO version is more efficient because it calls the constructor directly instead of going through `operator new` first. The manual version is also much harder to use as you will need to handle the allocation and destruction manually.
We've looked at that issue before, but at that time we resolved it as by design in light of CWG issues 86 and 446. We will have to revisit it now under guaranteed copy elision. I don't have a specific timeline, but we'll try to get this into one of the VS 2019 releases.
Well... that's a real trainwreck. I'll start with the flawed premise of the entire article. Concepts are not like classes and refinement is not like inheritance. Concepts aren't "weird" because they're parameterized. They're parameterized because they're predicates (on template arguments). Concepts are \*much\* more like functions than classes. And your diagram does not show "inheritance", it shows provable logical implications, although the arrows are reversed. As in: whenever \`Copyable&lt;T&gt;\` is true, \`Movable&lt;T&gt;\` is true, so \`Copyable\` refines \`Movable\`. It's also worth noting that algorithm for determining those implications is called "subsumption". You might talk about the details of how the subsumption algorithm works, but at this level of discourse, you really want to talk about "refinement". Sometimes, especially when talking about concepts with multiple parameters (e.g., \`Same\`), I prefer "implication". It is entirely worth pointing out that the subsumption algorithm is not a general purpose theorem prover. It has serious limitations, which means that refinements or implications generally need to be opted in to. When you should or should not refine a concept can have some interesting implications. I suspect the reason you haven't found surprising examples is that the feature, and most of the concepts in this post, in particular, have been around in roughly that form since at least 2011, possibly earlier if you look at the 0x concept hierarchy. They're pretty well understood and they're actually useful. So if you reorient yourself (being some kind of old-time cartographer?), your possible gotchas become relatively simple to address. * \`Same&lt;T, int&gt;\` does not imply \`Integral&lt;T&gt;\`. Damn right it doesn't. * \`Same&lt;T, int&gt;\` implies \`Same&lt;int, T&gt;\` and vice versa. Of course it does. * \`DerivedFrom&lt;T, Base&gt;\` does not imply \`Same&lt;T, Base&gt;\`. No shit. * \`SwappableWith&lt;T, T&gt; does not imply \`Swappable&lt;T&gt;\`. Design question: what's the benefit? The 2nd and 4th bullets have associated design questions: do you want those equivalences and why? You might also have taken the time to investigate the \`Invocable\`/\`RegularInvocable\` design and been able to actually explain it. The funny thing is, if you start from scratch, and try to define concepts for facilities in the Standard Library, you'll probably end up with the concepts and the same refinements. In fact, I would strongly to everybody (especially OP) to work through the std &lt;algorithms&gt; header and try to define concepts for those templates. Your understanding of the feature will improve dramatically. And as a final thought. The title is bad,
Would something like this `adl` namespace be useful to have in the standard? Seems like it would make the lives of library writers easier. Then the rule just becomes "If you're writing a library, use `std::adl::begin` instead of just `std::begin` and the same for whatever other functions are affected by this, e.g. `std::swap`.
Yes, this is a strict weak ordering. With `x ‚â∫ y = compare(x, y)`, the rules for a strict weak ordering are as follows: - ‚àÄx ‚àà `Object*`, `x ‚äÄ x` - ‚àÄx, y ‚àà `Object*`, `x ‚â∫ y ‚áí y ‚äÄ x` - ‚àÄx, y, z ‚àà `Object*`, `x ‚â∫ y ‚àß y ‚â∫ z ‚áí x ‚â∫ z` Let's look at the cases. The first is `x ‚â† nullptr, y ‚â† nullptr`; in this case, the above is trivially true, since `operator&lt;` is guaranteed to be a strict ordering already. Then, `x = nullptr, y ‚â† nullptr`. Since `x ‚äÄ y`, and `y ‚äÄ x`, the three properties are trivially true. Same for `x ‚â† nullptr, y = nullptr`. If `x = y = nullptr`, then you have that `x` and `y` are equal, and as such `x ‚äÄ y`. This means that we don't have any properties we care about. Therefore, the comparison you show is, in fact, a strict weak ordering.
Include the more general concept in its conjunciton of requirements: \`\`\` template&lt;typename T&gt; concept BidirectionalIterator = ForwardIterator&lt;T&gt; &amp;&amp; /\* Other stuff \*/; \`\`\`
Clion is too buggy. You need to work on performace related issues. On projects around 100k lines of code, you start seeing performance issues.
How close is Microsoft's implementation to what will (most likely) get standardized in c++20?
Great stuff (and somewhat disappointing results)
Not only performance problems. Even in c++11 code it gets wrong/missing autocompletion. And suggesting that an overriding function is not used is wrong and dangerous
&gt; \`Same&lt;T, int&gt;\` does not imply \`Integral&lt;T&gt;\`. Damn right it doesn't. But if T is int, it's always integral, so why doesn't it imply that?
To make a strict ordering you can do sometimes like this: if (a &amp;&amp; b) return a-&gt;value &lt; b-&gt;value; else if (!a) // nullptr always less return true; else if (!b) // a can't be less than nullptr return false; else // both nullptr return false; Now we can order all values: first nullptr, then all dereferenced values
To be fair, the reason is a bit less obvious to others than I'd thought when I wrote that. (Downside of having worked on this for 6-ish years). It boils down to how subsumption works and some limitations on concepts. First, you're asking syntactically different questions: Same is (usually) defined in terms of is_same, and Integral in terms of is_integral. Because those are different expressions, there's no refinement. Subsumption isn't a very robust theorem proving environment. If you *did* want refinement, you'd have to define Same&lt;T, int&gt; as is_same&lt;T, int&gt;::value &amp;&amp; Integral&lt;T&gt;. Presumably, you'd also want Same&lt;T, float&gt; to refine FloatingPoint&lt;T&gt;, so you'd the do something similar. Sadly, concepts can't be partially specialized, so that's going to be a non-starter. 
Could be interesting if there was a Community Edition.
Alternatively, you can define `Integral&lt;T&gt;` as `Same&lt;T, int&gt; || Same&lt;T, short&gt; || Same&lt;T, long&gt; || ...` etc. etc. (including all the cv-qualified versions. That's a heavy price to pay for something that rarely matters.
From the post (what‚Äôs next): Modules standardization is in progress: Currently, MSVC supports all of the features of the current TS. As the C++ Modules TS evolves, we will continue to update our implementation and feature set to reflect the new proposal. Breaking changes will be documented as per usual via the release notes.
"is more specific than", to eliminate it in overload resolution.
It's the most present demographic on reddit (and I pointed out that this sub might have an older audience as well). I don't care about your gender or your race, it doesn't make what you say more or less valid. Just saying that you'd make more money betting on a random person being a white male in his 20s than a Asian-Indian-American older woman (no prejudice against them, but they are less numerous).
&gt;Could be interesting if there was a Community Edition. unfortunately until then, you will have to pay to develop in slow motion
I agree that a marker on a Coroutine definition would be a plus. However, even so I‚Äôd prefer the ‚Äúreturn‚Äù keyword not to be overloaded. 
The post mentions modules, but they don't say anything about other stuff like concepts. I assume that's what OP is concerned about.
&gt; No. I really want to return the object ~~that I placement-new~~. Not a copy of it. not by moving from it. That exact object. Braced-list-init already does this, and has since C++11, and so works for any aggregate or class with a non-explicit constructor. Why do you need to add placement new into things? This is a ridiculous XY problem IMO.
skwished
Where did you see the result ?
I can't look at these, every time it's another MSVC bloodbath. :-/ 
MSVC gets some things right. And others... they need to work on.
Also, `SwappableWith&lt;T, T&gt;` and `Swappable&lt;T&gt;` aren't even equivalent. The latter is effectively `SwappableWith&lt;T&amp;, T&amp;&gt;`.
Existing results and analysis are at [https://gitlab.com/chriscox/CppPerformanceBenchmarks/wikis/Analysis](https://gitlab.com/chriscox/CppPerformanceBenchmarks/wikis/Analysis) I'm still writing the analysis pages for the new tests (along with writing and refining more tests).
Used QtCreator so far but it's only ok.
I think the remote development bits are the first step in allowing us to use dockerized toolchains.
Excellent trip report.
I read the post. Thank you. The reason I'm asking is that to the best of my knowledge, the driving forces behind modules have agreed on significant updates at the last ISO meeting (or rather in a working meeting before that) like legacy header support and other things from the ATOM proposal. None of those are mentioned in the post and I don't even know if those updates even go through the TS. I know neither the details of the modules TS, nor of the recent development, so it would have been nice to get a short overview, over what features are not yet available and what features will likely get removed.
Is the relationship between the different concepts defined in the standard or an implementation detail?
Is it defined in the standard which concept subsumes which and which not?
Yes (please elaborate)
No
No, I was talking about the difference (if any) between TS modules and c++20 modules. Sorry if my post was confusing. 
I was only referring to the summary in the post 
No. All major compilers (MSVC, Clang, GCC) support it.
No
never had problems with pragma once but oh boy did I have a lot of trouble with people copy pasting files without changing the include guards - or just too common names.
Qt is pretty easy to use and powerful. It has an open source and commercial version - https://www.qt.io/
Thank you, I just gave vscode a try and it's amazing! I had the impression that it was much closer to sublime and vim than an IDE, but it works incredibly well as such. It didn't even need the compile_commands.json for autocompletion for my project. And it's so fast...
Thanks for the suggestion. Maybe I'll give it a try then, but I just tried vscode and I doubt that I'll move anywhere else soon, because everything I need works surprisingly well.
&gt; it's so slooow... Unfortunately that has been my experience with all their products.
Never had a problem.
No.
Thanks. I'll keep trying to do my best. I just hope I can keep bringing quality libraries and software to the private and public sectors to solve big problems for many years to come. Speaking has been really, really fun, but it terrifies me to the core every time...
What exactly dou you mean with atari? Their are different atari consoles and PCs. They all have the problem that they only are 8 or 16 bit systems and have only a few kb RAM. I don't think you can use modern graphic libraries on them 
Nope. 
Fantastic elaboration.
Hello! ‚Äî I'll try the string literals approach, it's up to benchmarking to decide, which one is better. ‚Äî It is highly unlikely to store so many resources that the linear run-time search will become a bottleneck. However, I was thinking about making the addresses `constexpr` to somehow bypass this limitation. The best way is to make several search algorithms with the selection based on the total number of resources. ‚Äî IMHO, templated resources matter for the (de)serialization usage of the `std::embed`, not so much for the kind of applications I had in mind when developing this. But I'll sure give it a thought. I'm really glad you were able to have a look at this, thank you very much! 
My goal is not to force the caller to manually pass in an out-buffer as your example does. It is to let others call my function exactly as they would any normal value-returning function. But inside the function body, I want to construct the return value using placement-new syntax. class C { /* stuff */ }; C normal_function() { return C(stuff); } C my_function() { new (return_slot) C(stuff); return; } void call_function(bool use_my_function) { // Call either function at runtime. They have the same ABI. C (* const fun)() = use_my_function ? &amp;my_function : &amp;normal_function; C value = fun(); use(value); }
Nope, never had a problem, but like the other guy, plenty of problems with the #ifndef guards. 
lol @ "No" getting +20 (no elaboration) and "Yes" (no elaboration) getting -10. Isn't Reddit voting awesome
I don't understand... What problem is this trying to solve exactly? Pretty much all "cFOO" files are very thin wrappers over "FOO.h" anyway. Including both won't gain you anything and could well break things...
&gt; **‚Äù** I don't understand... What problem is this trying to solve exactly? A `&lt;cFOO&gt;` guarantees to place the names in namespace `std`. It *may* place the names also in the global namespace, depending on the C++ implementation. A `&lt;FOO.h&gt;` guarantees to place the names in the global namespace. It *may* place the names also in the `std` namespace, depending on the C++ implementation. If you include only one of these, it's therefore easy to inadvertently write code that compiles with the particular compiler or compilers you use now, but not with some other compiler. --- &gt; **‚Äù** Pretty much all "cFOO" files are very thin wrappers over "FOO.h" anyway. The original C++98 intent was that `&lt;FOO.h&gt;` should be defined in terms of `&lt;cFOO&gt;`. And up through C++03 `&lt;cFOO&gt;` was not permitted to place names in the global namespace. However, as far as I know nobody conformed to that rule: it was too impractical. Until C++17 the standard required that `&lt;cFOO&gt;` and `&lt;FOO.h&gt;` provide the same functionality, except for the namespaces (explained above for C++11 and later). With C++17 `&lt;cmath&gt;` gained some [special math functions](https://en.cppreference.com/w/cpp/numeric/special_math) that are not guaranteed available via the C++ `&lt;math.h&gt;`. --- The copyright and and license commentary is imperfect, yes I know. Thanks anyway!
Given that the exact requirements are pretty unclear (we don't even know anything about the language restrictions, besides the fact that we are currently on /r/cpp), I think it's kinda hard for anyone to give a proper advice. With that being said, I would either recommend taking a look at either a dedicated 2D game engine, such as [L√ñVE](https://love2d.org/) (Lua), [Cocos2d-x](http://www.cocos2d-x.org/) (C++/Python), or basically any of the popular ones on [GitHub](https://github.com/collections/game-engines). [This](https://www.reddit.com/r/gamedev/comments/6lk7pv/choosing_game_engine_or_framework_for_2d_game_use/) reddit question also seems to be related to your problem, you may want to give it a read too. As a developer with a strong focus on real-time 3D rendering, all I can say is that if you have never done any graphics before, you should probably forget about doing it manually using low-level tech, such as OpenGL and the like. While it's true that if you don't mind learning deprecated stuff, then fixed pipeline OpenGL is pretty easy to use, I don't think it's the best idea to waste time and effort on developing bad habits. And the barrier for entry for modern OpenGL is somewhat high, probably stealing the focus from implementing actual gameplay, which I think should be the focus of the course you are currently taking. Then again, if you have still have the plenty of time left to learn, then you should consider a platform abstraction library (such as [GLFW](https://www.glfw.org/), [SDL](https://www.sdl.com/) or [SFML](https://www.sfml-dev.org/)), along with an OpenGL loader (such as [GLEW](http://glew.sourceforge.net/) or [GLAD](https://github.com/Dav1dde/glad)). There are plenty of rather in-depth tutorials on the internet that teach modern OpenGL (such as [this](https://learnopengl.com/), [this](http://ogldev.atspace.co.uk/), [this](http://www.opengl-tutorial.org/beginners-tutorials/) or [this](http://www.mbsoftworks.sk/)), they should be enough to have everything you need covered. It should be much easier to bootstrap a quick project with a dedicated engine though, be it a standalone, integrated environment, or a library-esque solution.
I had some problem when it was used in a precompiled header (no hardlinks involved). It was maybe a compiler bug related to precompiled header handling. Don't ask for detail, I don't remember. However I use everywhere except in precompiled headers, because it has obvious advangates over header guards.
Oh no, someone broke away from our clique... let's downvote him to oblivion.
Team lead said #pragma once cannot be used as it's not standardized. Left the team and living a happy life now.
Definitely a problem, especially when they don't take namespaces into account. A less legitimate problem, but one that irks me, is people taking something like: #ifndef BASE_H #define BASE_H // Base declaration #endif // BASE_H And copy/pasting it, but only partially updating it like: #ifndef DERIVED_H #define DERIVED_H // Derived declaration #endif // BASE_H Triggers my OCD. 
This isn't design by committee. Rather, it's the product of over twenty years of studying algorithms and determining their necessary syntactic and semantic requirements. Concepts have been a part of C++ since 1994, and by studying algorithms such as those in the STL, you'll find that these concepts are all necessary for [generic programming](https://youtu.be/iwJpxWHuZQY).
How long ago was this?
As /u/andrewsutton said in a [different comment](https://www.reddit.com/r/cpp/comments/a0vbet/remember_the_ifstream/ealj7ba), we really shouldn't be thinking about subsumption at this level, but rather refinement. The concept `BidirectionalIterator&lt;I&gt;` *refines* `ForwardIterator&lt;I&gt;` because it has all of the requirements that `ForwardIterator&lt;I&gt;` has, and then adds more on top of them (conversely, `ForwardIterator&lt;I&gt;` is a weakening of `BidirectionalIterator&lt;I&gt;`). Andrew's talk on [concepts at CppCon 2018](https://youtu.be/ZeU6OPaGxwM) addresses this topic IIRC. To answer your question, yes, given the notation Andrew provides above, you can look at any concept in the standard and see that if the concept `BidirectionalIterator&lt;I&gt;` directly refines `ForwardIterator&lt;I&gt;`, then it subsumes `ForwardIterator&lt;I&gt;`. Does `BidirectionalIterator&lt;I&gt;` also subsume `InputIterator&lt;I&gt;`? Yes, because it is a refinement of `ForwardIterator&lt;I&gt;`, which is a direct refinement of `InputIterator&lt;I&gt;`. As for telling if a concept (e.g. `BidirectionalIterator&lt;I&gt;`) doesn't subsume another concept (e.g. `SwappableWith&lt;I, I**&gt;`), look for the latter in the full sequence of refinements. If it doesn't appear, then it's not subsumed.
See this email thread on Qt Developers Mailing list: [https://lists.qt-project.org/pipermail/development/2018-October/033726.html](https://lists.qt-project.org/pipermail/development/2018-October/033726.html) From the Qt Creator's side of things: &gt;Qt Creator uses it since more than two years without problems. &gt; &gt;For a potential conversion [https://github.com/cgmb/guardonce](https://github.com/cgmb/guardonce) may help.
Is there an option in the ide to switch the auto generated headers to use pragma once rather than include guards?
That‚Äôs a good point, some clarity from someone on that team might help. My understanding from prior comments and blog posts was that vs 2017 plans to track the modules TS only. Speculation: maybe if modules misses 20 then the TS would be updated, otherwise we‚Äôre likely going to need to wait for vs 2019 before final modules?
&gt; A &lt;FOO.h&gt; guarantees to place the names in the global namespace. No it doesn't... It's completely non-standard behaviour (unless you can find a clause in the standard that says otherwise?). It only works (most of the time) because the C++ compiler's include path usually includes the C include directory for compatibility with "C as C++" code and the fact that the C includes often live in the same directory as third-party libraries. &gt; If you include only one of these, it's therefore easy to inadvertently write code that compiles with the particular compiler or compilers you use now, but not with some other compiler. You are correct that the C++ standard allows the "cFOO" headers to optionally include names in both the global namespace and `std` and this is the common practice, so programmers may use these names without the appropriate namespace reference and this may break if you ever find a compiler that does not do this. However, including the C headers is not the correct way to address this. Adding the appropriate namespace references is. If a third-party is using your code on an untested compiler and encounters this issue then they can either fix it themselves or submit a bug report for you to fix (it's unlikely to be a huge effort to sprinkle a few `std::`s on lines identified in the compiler's error messages). If you're writing C++, you should stick to the C++ standard and only ever include "cFOO". If you're compiling C as C++ then you're obviously relying on non-standard behaviour which may be compiler-specific. &gt; With C++17 &lt;cmath&gt; gained some special math functions that are not guaranteed available via the C++ &lt;math.h&gt;. They're guaranteed to be available in a C++17 compliant standard library. Before that, they're neither guaranteed to be in "cmath" _or_ "math.h" and are only defined by TRs to C and C++ (ISO/IEC TR 24747 for C and ISO/IEC TR 19768 for C++). The chances are that a system that implements the C TR also implements the C++ TR, but even if it does not, including the C header is non-standard; using the Boost implementation is a better idea. &gt; The original C++98 intent was that &lt;FOO.h&gt; should be defined in terms of &lt;cFOO&gt;. Got a source for that? Every compiler I've ever seen does the opposite; "cFOO" includes "FOO.h", imports the names mentioned by the C++ standard into the `std` namespace and maybe `#undef`-s a few redundant C macros, etc. [See GCC's implementation for examples](https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3/include/c_std). I doubt anyone on the standard committee seriously expected C++ library developers to include a completely independent implementation of the C standard library; such an idea is fraught with issues anyway. On most systems, the C library includes the program startup code, syscall implementations, etc. making developers duplicate all that for C++ would be a ridiculous idea! &gt; No, that's incorrect. &gt; These headers offer different guarantees about what namespaces they provide the names in. As a I said above, the "different guarantees" idea is nonsense. As you can see from the examples I provided, the C++ headers typically make no attempt to provide any special handling for the C header's include guards (and can't possibly do so; the C and C++ standard libraries are often provided by different parties and cannot know each other's internal naming conventions). Thus, including "FOO.h" after "cFOO" will, in most cases, do nothing at all. Even if it does do something, what it does is entirely non-standard. It may cause errors about multiply-defined symbols, may cause name-mangled versions of the C symbols to be referred to by the object file (and thus cause it to fail to link) or any number of things in the realms of "undefined behaviour".
Trying to parse this. Can you provide a simple example please?
In computing, a hard link is a directory entry that associates a name with a file on a file system. All directory-based file systems must have at least one hard link giving the original name for each file. The term ‚Äúhard link‚Äù is usually only used in file systems that allow more than one hard link for the same file.
How much support for modules is in Visual Studio IDE? Looks like it's mostly command line atm?
Never had a problem
Call me lucky (or stupid) but i've never once encountered hard links (that i recognise as such) in my entire life. Thank you for clarifying
&gt; [That &lt;FOO.h&gt; guarantees to place the names in the global namespace is] completely non-standard behaviour (unless you can find a clause in the standard that says otherwise?). C++17 ¬ßD.5 paragraphs 2 through 4 (my emphasis): [quote] 2 The header &lt;complex.h&gt; behaves as if it simply includes the header &lt;ccomplex&gt; . The header &lt;tgmath.h&gt; behaves as if it simply includes the header &lt;ctgmath&gt;. 3 Every other C header, each of which has a name of the form name.h , behaves as if each name placed in the standard library namespace by the corresponding cname header ***is placed within the global namespace scope***, except for the functions described in 29.9.5, the declaration of std::byte (21.2.1), and the functions and function templates described in 21.2.5. It is unspecified whether these names are first declared or defined within namespace scope (6.3.6) of the namespace std and are then injected into the global namespace scope by explicit using-declarations (10.3.3). 4 [Example: The header &lt;cstdlib&gt; assuredly provides its declarations and definitions within the namespace std . It may also provide these names within the global namespace. The header &lt;stdlib.h&gt; assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace std. ‚Äîend example ] [/quote] Except for the C++17-specific details this has been so since the very first standard, C++98. Note however that notes in ISO standards are non-normative, so paragraph 4 doesn't specify anything, it just guides you to understand the normative text better. &gt; It only works (most of the time) because the C++ compiler's include path usually includes the C include directory for compatibility with "C as C++" code and the fact that the C includes often live in the same directory as third-party libraries. I'm sorry, that's incorrect. 
I recommend [OpenFrameworks](https://openframeworks.cc/)
&gt; &gt; A &lt;FOO.h&gt; guarantees to place the names in the global namespace. &gt; &gt; No it doesn't... It's completely non-standard behaviour (unless you can find a clause in the standard that says otherwise?). Well, you could have looked at the section that mentions the headers [depr.c.headers], then you would have noticed the following paragraphs: &gt; 2. The header &lt;complex.h&gt; behaves as if it simply includes the header &lt;ccomplex&gt;. The header &lt;tgmath.h&gt; behaves as if it simply includes the header &lt;ctgmath&gt;. &gt; 3. Every other C header, each of which has a name of the form `name.h`, behaves as if each name placed in the standard library namespace by the corresponding `cname` header is placed within the global namespace scope, [...]
Sneaky doible dipper!
I use classic include guards just because my IDE automatically generates them. When writing manually, `#pragma once`.
No dark mode and compact layout on redesign =&gt; I'm going to stay with old.reddit.com and it's RES support
:) You know, the effort.
I would strongly suggest irrlicht as it gives you significant freedom in programming style and is cross-platform and supports different drivers.
&gt; optimizing on const-ness is less about const-ness and more about potential aliasing; and aliasing is hard. Entire topic tl;dr summarized in 1 statement. /u/ShFil 
I never had a problem with `#pragma once` and I was going to adopt them after having watched [Arthur O'Dwyer saying to use it at CppCon](https://youtu.be/lKG1m2NkANM?t=475). Then I saw [this benchmark](https://tinodidriksen.com/2011/08/cpp-include-speed/) measuring the compilation time when using include guards or `#pragma once` or both and I decided to keep going with the include guards. At the time my main problem was to reduce the build time of our projects. These sources are quite old now, maybe I can give it another chance.
I like effort-intensive C++ memes that try to solve weird problems or just propose funny stuff but unfortunately I find your library neither useful nor funny.
Okay, I missed a deprecated part of the standard. The fact that it's deprecated makes it a _worse_ idea to rely on it, not better, but at least it's not going to fall into the realm of UB for now. &gt; I'm sorry, that's incorrect. It's incorrect that the C++ include path usually includes the C include directory? That's been true on every system I've used...
Okay, I missed a deprecated part of the standard. The fact that it's deprecated makes it a _worse_ idea to rely on it, not better, but at least it's not going to fall into the realm of UB for now.
It's not as bad as you think it is. In the same time, it's far more user-friendly than dealing with the bare linker symbols. But thanks for the suggestion, I'll provide some timings and benchmarks.
I've had less issues with `#pragma once` than I have with the header guards
Everybody has a wildly different definition of long, but what does your "it's not as bad as you think it is" mean? I've experimented with stuff like this a couple times over the last decade (it's common practice to include binary in assemblers using "incbin" or similar, which is why I was used to this), and each time I concluded that the C++ compilers is not built for processing large amounts of binary data. Simply including a 10MB file increases the link time by 30 - 60s, depending on OS and linker.
This is going to get pretty long-winded if you insist on replacing every rebutted assertion with a new set of incorrect or misleading assertions. :( &gt; **‚Äù** Okay, I missed a deprecated part of the standard. No, it's not a deprecated part of the C++ standard. However, the ".h" headers have been formally deprecated since C++98, the first standard. They're not going to disappear, because (1) that would break just about all C++ code in existence, and (2) it would be counter to the main goal of C++ as a language that could easily leverage the libraries of C. The formal deprecation of `&lt;FOO.h&gt;` headers in 1998 must be understood in the context of the formally ideal `&lt;cFOO&gt;` headers of that standard, where they didn't introduce names in the global namespace (the standard finally cought up with reality that nobody honored that rule, in 2011). &gt; **‚Äù** It's incorrect that the C++ include path usually includes the C include directory? Snipping the context and asking for clarification about exactly which claim of yours I pointed out was incorrect, may of course prolong the discussion. I'm not going to check. I seem to recall that you talked about the things you didn't know were guaranteed, that my wrapper headers work by happenchance or something like that; I believe you used the word ‚Äúnonsense‚Äù about the explanations of what the standard guarantees and not. 
Yes but it was moreso related to the IDE than the code itself. In my previous role, I had a 100k LoC project built in Embarcadero C++ Builder XE7. It ships with an older pre-C++11 32bit compiler and a nice 64bit compiler derived from clang. I thought I would replace the include guards with `#pragma once` to help clean up the code a bit. Just a bit of background but C++ Builder ships with VCL and Firemonkey GUI libraries. As such, it also provides a form designer. Probably the one redeeming feature that I would praise the IDE for but it's important to know it's there. It also turns out that it's important to know that the freaking IDE uses include guards to group .h/.cpp/.dfm files together. So once I had replaced them, the IDE could no longer jump between the header, the source or the form designer. If I remember, it even caused issues with compiling due to the disconnect in the IDE. It couldn't automatically update the header with new members for widget pointers or something. So yeah, I've had issues with using `#pragma once` but it wasn't because of the language itself or some of the other horror stories you hear.
I fancy one day writing a c++ papers, and this formatting tool looks fantastic, thank you for sharing.
Can you give an example of an ‚Äúeffort-intensive C++ meme‚Äù? And can you please clarify what ‚Äúweird problems‚Äù you're talking about, and the relevance? Because I fail to understand what you're talking about except that you don't find the little library useful. That's OK in itself. I just offer it up. 
I've included the 10MB (10245KB actually) file and the whole rebuild took 4.55 seconds.
For an atari-style game, anything will do, really. Just pick SDL2, SFML or even Allegro (it's older and doesn't support hardware acceleration, but for this use case it's very simple to use and might even be faster than GPU IO overhead). 
As far as I'm aware the only problem that can arise with pragma once is that you end up processing the same file more than once (as in if the same file is actually in multiple places).
No issues with #pragma once. I feel it's better than include guards. Really helps when class names or filenames are lengthy.
There is some Unix-based software that makes extensive use of hard links, but that sort of software is pretty rare.
Shouldn't it be possible to have a std implementation that _only_ provides guaranteed names as a design goal? Where non-guaranteed names are practically necessary for implementation, use names that are terrible and hard-to-use in client code.
\&gt; I have heard of such case &amp;#x200B; That is actually interesting to me, because so far, when this topic comes up I only hear explanations of how this could be a problem in theory, but I never could find one, for whome this was actually happend. So it seems to me that the avoidance of \`#pragma once\` is more based on FUD than actual facts. Have you heard this from someone to whom this actually happend or is this "a friend was told from a friend that a friend of him heard ..." kind of story?
The problem is that to implement `std::func` in `&lt;cxxx&gt;` that comes from C you just include `&lt;xxx.h&gt;` and call `func` inside it. We would need something like `#exclude` to get rid of unwanted symbols.
I think that user is kidding with you. I know most of us give fuck all about Reddit karma. Here have an upvote due nothing üòä
&gt;Thanks for sharing. Not the kind of problem I expected (actually I didn't expect to hear from someone who actually ran into a problem at all ;)), but a problem nevertheless. C++ Builder XE7 isn't even that old. &amp;#x200B;
Exactly that is the case I'm hearing over and over again. I was wondering if that actually happened to someone.
Didn't think of that possiblity. Thanks for sharing.
Maybe you did and never noticed ;). The world would most definitely be a better place without them...
I plan to cancel my (yearly) subscription and stay on 2017.3 until they fix the performance issues with 2018.x. I evaluated 2018.1 a few months ago, then I tried 2018.2 yesterday and 2018.3 today. All three are slower than molasses compared to 2017.3. Does anyone know what CLion 2018.x thinks it's doing when it pauses for 30+ seconds for no reason while I'm typing? ("This kills the train of thought.")
In slightly different ways, or at least so I've heard. Even if true - their different ways all seem to work just fine for sane codebases.
Yeah, it's only from Sept. 2014. I'm not sure if it's still an issue with the latest versions but it would not surprise me if that were the case.
I guess that has its own issues, because _that_ header could do `#include` with relative paths.
Thats fine. This post (and its sibling) was meant as a poor mans counting system (number of upvotes equals number of people who had a problem), but I should have explained that in the main post from the beginning. Does reddit have a proper mechanism that allows people to do yes/no votes without such dummy posts (and without the result affecting karma)? &amp;#x200B;
Personally I have a frequently shared meta templates header that I need various functionalities in, in a lot of projects. On occasion I've used some of the projects as sub projects to another one that also includes the same header... the compiler errors due to multiple definitions are... fun?
I remember that post. On the one hand I was disappointed too. But what I took away from it in the end was that the time is negligible (for our usecases) in either case.
We ran into what sounds like the same issue in Android builds! Here's the clang bug on it: https://bugs.llvm.org/show_bug.cgi?id=24387 Apparently it was fixed in 2016. 
There is also a still open bug report discussing `#pragma once` performance in GCC: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58770
That is a feature, not a bug. That would only happen when the individual just copy/paste and doesn't give a shit about the code. 
Makes sense and sounds as if that would be more common than the hardlink/network mount case. &amp;#x200B;
That might fall into "if you do this, your code deserves to be broken" :P
To me, it's perfectly reasonable for a developer to assume that Same&lt;T, int&gt; does imply IsIntegral&lt;T&gt;. No developer should have to care about the underlying algorithms in a compiler, and it's not exactly ideal that the language is being standardised on these algorithms; what if a better one comes along?
If you are talking about the file templates (for doing "new file..."), it is pretty easy to make modified versions of the default templates that use #pragma once.
I'm sorry, but at some point along this apparently infinite road of your responding to rebuttals with new assertions, I may not be able to respond to the new assertions within a reasonable amount of time, because I do other things, including sleeping. &gt; **"** Yes [this part of the standard] is [deprecated]. That's what Annex D is for. No, annex D is not deprecated. It describes formally deprecated features. Possibly, but I must just guess about this, possibly you have seen and misinterpreted a ‚Äú[Depr]‚Äù notation in the right margin of the D section heading. That's not a specification or description of the contents. It's a *name*, a way to refer to that section, e.g. ‚Äú¬ßdepr/1‚Äù is the first paragraph in that section. Alternatively you can use the numbers and annex letters, e.g. ‚Äú¬ßD/1‚Äù to denote the same. These generally change between standards, while the names are more resilient to change. However, I generally use the numerical/letter ids because the paragraph numbers often change between standards anyway, and the paragraphs don't have names, so the relevant version of the standard has to be specified anyway (for most all cases). &gt; **‚Äù** You've so-far failed to present any good reason to use the C headers in C++ code. First, a point of terminology: the C++ compiler's `&lt;FOO.h&gt;` header is called a **C header** because it *provide the same things*, plus some, as the C compiler's header of the same name. But the C++ C headers are very much C++ specific code. They have overloads and other stuff incompatible with C. Recall, that until C++17 the contents of a `&lt;FOO.h&gt;` was *defined* as being the same as the contents of the corresponding `&lt;cFOO&gt;`, except for the namespaces (C++17 made `&lt;cmath&gt;` an exception). As far as I know in the C++03 era no compiler implemented the `&lt;cFOO&gt;` **C++ headers** correctly, without polluting the global namespace. All they did was to formally require more verbose code, and make it easier to inadvertently write non-portable code. So until C++11 there was IMO no good practical reason to use them, but I'm in an apparent minority of people who find `std::` qualifications verbose and yielding reduced readability. However, there was the *hope* that some day compilers would maybe catch up to the formal regarding `&lt;cFOO&gt;` headers. Every choice to use those headers would then be vindicated, then producing clean non-polluting C++-ish code. That hope was crushed with C++11, which also in the formal let `&lt;cFOO&gt;` pollute the global namespace. Still, I think even those who find `std::` prefixes to be clarifying, would balk at writing `std::cos` and `std::sin`. So let's say you want to write `x = cos( v ); y = sin( v );`. You can either include `&lt;cmath&gt;` and add two `using` declarations or one `using namespace` directive, or you can just include `&lt;math.h&gt;`. I prefer the simpler, `&lt;math.h&gt;`. But then, I would miss out on the esoteric C11 functions only available in C++17 `&lt;cmath&gt;`, I would not get the Posix `M_PI` etc. without compiler-specific defines and undefines, and I would not get the integer overloads of `abs` (and `div`). When I instead use my little library presented here, I can just include `&lt;c/math.hpp&gt;` and get all that, and no `using` necessary. &gt; **‚Äù** My post is still there, I've not removed anything That may be so, but when the other part in a discussion snips the relevant context and adds an unnatural misleading interpretation of the snipped context in the question following the quote, I'm not going to do the work. 
Yeah, I'm just screwing around. I wrote it before I even saw you also had a 'vote yes' comment. Come to mention, I'm a little surprised reddit doesn't have a survey tool. Seems like everyone would be all over that.
I'll note that "before" is about 15-20 years ago now, unless you were targeting unusual systems of the types that had broken C++ compilers anyway.
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a14s1r/what_graphic_libraries_should_i_use/eanc3ae/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Yes, but many embedded system compiler have minimal support for pragma, so it depends on what you program. Main compilers like microsoft, clang and gcc have been supporting it for many years. But there are some like the cray compiler who still doesn't support it.
&gt; There are two ways of setting values with this feature; brace initialisers or equal initialisers: S{.a{30}, .b=9}. The brace version is a bit more relaxed as it allows narrowing conversions. Wait, so it works in an opposite way to the variable initialization? int i = 1.2; // compiles int i{1.2}; // error - narrowing conversion Why was it designed that way?
I can't really read the grey-on-slightly-darker grey color scheme. It's a shame you can't initialize in any order, e.g. like python, but this is still really nice, and I'll probably start using it ASAP.
&gt; but that sort of software is pretty rare. Or more to the point, it doesn't come up in context with that. For example, you could make an argument that Git "makes extensive use of hard links", and it's not exactly rare. (It will by default use hard links for the read-only blobs under `~/.git` if you do a clone to the same filesystem.)
Assuming you ever used a Unix shell and typed `cd ..` then you used a hardlink :) Hard links are used for example by rsync and rsnapshot to do some deduplication between backups. But manually creating hardlinks in a source code sounds like a really nasty idea! 
You are correct. The compiler implementation reflects the TS not the merged paper between the Atom proposal and the TS. Again, once that paper is merged, the compiler implementation update will follow.
&gt; we have to be very careful to not use functions that take const char* This is not an argument against putting binary data in a string, the function you call just doesn't support inline null bytes. It won't work no matter what container you use to store your data. Also, I don't think anyone expects std::string to be human readable, there can be an expectation that they're printable though. This would ideally be solved by string typedefs, if they existed.
I once ran into problems because we had the same header installed to multiple locations and included in different ways, which resulted in both of them being included. It was a giant pain to track down what was going wrong. Then it turned out that they were actually *different versions* of the same header because obviously there's no guarantee that the project-local copy of a dependency and a system-wide copy are actually interchangable and we would have had issues even with include guards.
only if the files are different. you can declare things many times and inline/constexpr as long as they are the same
I am not sure what the point of this article really is. It doesn't come up with a valid reason to use a string for this in the first place, so why would we need to be told not to?
The fundamental problem seems to me to be that using preprocessor directives to import code is just an inherently error-prone way of doing it \#ifdef and #pragma once are both trying to patch over that issue but can't solve the real problem, which is that the compiler treats header files like raw text, rather than like code.
Database-driven compilation when
&gt; No, annex D is not deprecated. It describes formally deprecated features. Now you're being silly. Obviously the description of deprecated features is not itself deprecated. That would be nonsense. Calling a feature described in under the "heading" of "These are deprecated features..." a "deprecated part of the standard" is, while possibly sloppy language, quite easy to understand (if you're a non-native English speaker, I apologise for any confusion I may have caused). &gt; As far as I know in the C++03 era no compiler implemented the &lt;cFOO&gt; C++ headers correctly, without polluting the global namespace. As far as I can tell, the C++03 standard does not require this. In fact it allows for the "pollution", albeit not as explicitly as later versions of the standard ([lib.extern.names]/4): &gt; _Each name from the Standard C library declared with external linkage is reserved to the implementation for use as a name with extern "C" linkage, both in namespace std and in the global namespace._ At worst you can say that the presence of C names in the global namespace is a common vendor-defined addition that is acknowledged by the standard. &gt; All they did was to formally require more verbose code, and make it easier to inadvertently write non-portable code. Do you mean "non-portable" as in "no longer a C and C++ polygot"? Because, sure, using the C++ namespace will stop the code compiling as plain C (in the absence of awful macro trickery at least). If you mean "you could use the global name and a theoretical future compiler might only define the names in `std`" then sure, but then a compiler removing the global names is just as likely as dropping the old "FOO.h" include names. Currently, the former is an optional standard feature while the latter is a deprecated standard feature. Neither should really be relied upon (at least not for new code). I can see your point about `std::` being a bit verbose for short function names. Still, `using std::foo;` is something you only have to type once (per file) and doesn't rely on any optional or deprecated standard features. If you're only using a standard name once-or-twice in a file, it's no big deal to prefix it with `std::`. &gt; But then, I would miss out on the esoteric C11 functions only available in C++17 &lt;cmath&gt;, I would not get the Posix M_PI etc. without compiler-specific defines and undefines, and I would not get the integer overloads of abs (and div). If you read the standard carefully, you'll notice that including "FOO.h" from a C++ program is not guaranteed to include any functionality that doesn't exist in "cFOO"... &gt; _Every C header, each of which has a name of the form name.h, behaves as if each name placed in the standard library namespace by the corresponding cname header is placed within the global namespace scope._ So whether you get any of those POSIX/C11/C19 features that aren't in the C++ standard by including "FOO.h" is very much a non-portable vendor extension. &gt; When I instead use my little library presented here, I can just include &lt;c/math.hpp&gt; and get all that, and no using necessary. Of course, you could update your library to just include "cFOO" and have a bunch of `using std::bar;` lines to ensure the names are in the global namespace and not be relying on any not-to-be-relied-upon parts of the standard...
I suspect this is an error in the article.
Here is the [link](https://www.youtube.com/watch?v=SDJImePyftY) (I watched it too yesterday).
Does anyone know what is the reasoning behind having to use them in the order they are declared?
I will do exact that.
I don't think so, cppreference says &gt; Narrowing conversions are prohibited when the form using the equals sign is used.
To quote [my comment](https://www.reddit.com/r/cpp/comments/9zg5tc/_/eagenm5) on the reddit post for that lightning talk: &gt; `std::basic_string&lt;T&gt;` seems to only be well defined if `T` is a trivial standard layout type ( http://eel.is/c++draft/strings#general-1 ). Unfortunately, this makes `std::basic_string` rather hard to use as a container. For instance, the example of `std::basic_string&lt;some_struct&gt;` where `some_struct` has a `std::string` member is invalid because `some_struct` is not trivial because `std::string` is not trivial
I am. Yes, I will dual-license the code under Boost for publicly available STL implementations like MSVC's.
Though a good point in general, for this application it should be fine. `unsigned char` is a fundamental type, and `std::byte` should be trivial. 
Yes commits are cheap
Yes. Jason Turner noted that also in his recent C++ Weekly video. Yes. It's a serious confusion issue. Just when we start to fall in line with C++11 "initialisation issues"; C++20 comes with another twist. I hope they fix this before IS draft
As a C++ dev for 3 plus years now, I have never had a problem with #pragma once. It has always been problems with traditional header guards.
On the contrary, std::string is little but a container of null-terminated raw data. If it is text, you have no way of knowing its encoding
This is ridiculous. Is there any paper that tries to fix this?
Now, C++ and JS will be same language: foo({ .bar = 10, .baz = 20}) In JS, that is used almost everywhere. 
This can go wrong with include guards as well. For example, copy a directory to the 2nd project, then make changes in the 1st one and forget to copy the changes. BOOM, 2 actually different files using the same include guard.
That would be broken with include guards too.
It was a real story, but a rather old one. Ten years ago, perhaps? In those days, #pragma once was supposedly faster than include-guards. I doubt there is any performance difference today.
Saw some build performance degredation from using precompiled headers with pragma once rather than include guards with MSVC. Don't recall the specifics but I believe it was somewhere around a 2x speed difference.
This seems like an instance where rather than fixing the problem you should be asking yourself why you do something so intensely fucked up.
Finally catching up to C99.
I've had to struggle with this. Often it will feel like I don't need to make a commit for such a small change, but the other option is to lump those changes with larger unrelated changes. The problem with that is other developers (or yourself) down the line that are inevitably trying to track down the origin of those seemingly minor changes end up getting a completely random and useless commit message attached to it. I've bitten myself in the ass before doing that.
I would be happy even if they got rid of implicit narrowing conversions in designated initializers.
Yes, commonly used in backup schemes. 
Agreed
It's common practice for people to set up a simple poll here www.strawpoll.me and ask for elaborations in the comments.
Worse: "human readable" text can contain null bytes, depending on encoding, leading one to wonder what std::string \*is\* good for if storing raw data isn't it.
[I guess one of these two would be the closest.](https://godbolt.org/z/plZblU) They're nowhere near as efficient as pure RVO, though `f()` does avoid using the copy constructor. If you really need that much control over this, it's probably better to just write the function in assembly. C++ doesn't give any good way to not initialize a static object, which is why `f()` constructs the object and then destructs it before using placement-new on it. Also, the "return slot" is not an address in memory, but the `rax` register. It is only 8 bytes (or 4 for `eax` in 32-bit code) and is not used to store objects, only plain numbers and pointers. The compiler automatically rewrites any function that returns an object by value to instead take a destination pointer to place the "returned" object in.
They're handy if you do batch processing in a directory. Download in one directory then when your download is done, hardlink to the batch processing directory and remove the one in the download directory. It's an atomic operation that doesn't push bytes around. It only works on the same filesystem, though. Minor but important detail. The C API is pretty easy to use -- man 2 link and man 2 unlink for details. And knowing that, if you ever see anyone use system("rm ...") in the future, you can punch them in the dick for me.
Why in the hell would you, out of all the containers in the world, pick `basic_string&lt;std::byte&gt;`? What is wrong with people?
Probably the usual way, someone copies/pasts a header file to solve some problem or other. They'll start to drift apart over time and 5 years after that guy leaves someone else will have to debug some esoteric problem because of it. Either someone updated the wrong header, various executables use one header or the other and someone only updated one of them, that sort of thing. It's not too uncommon to see this sort of problem in 90's-era C projects. You don't see as many 90's era C projects post-about-2002 or so, as many of those "developers" didn't survive the tech market crash and went on to open liquor stores.
Plenty of good reasons. Like OP said, you get all the string semantics that vector and other containers lack, perhaps the most obvious being the small string optimization.
It's weird, I generally have no problems either way unless I think there won't be any problems, and then shit just gets weird.
it's only because of the name, rather than the functionality behind it. strings could have been a normal class; instead it was chosen to be built upon more generalised container with certain functionality. It is a specialisation of this general container, and they needed a name thus `basic_string`. However, this generalised container could have a different name; `simple_vector` for example. The interface of `std::basic_string` is pretty useful. Just take trying to extend one container with another; `std::basic_string` defines `operator+` to do it remarkably cleanly compared to `vector`. We also get "small object optimisation" thus potential speed increases and memory reduction. i personally have not found a need to use it; but now i know it can.
...except for all the interesting use cases: struct A { int x, y; }; struct B { struct A a; }; struct A a = {.y = 1, .x = 2}; // valid C, invalid C++ (out of order) int arr[3] = {[1] = 5}; // valid C, invalid C++ (array) struct B b = {.a.x = 0}; // valid C, invalid C++ (nested) struct A a = {.x = 1, 2}; // valid C, invalid C++ (mixed)
&gt; Do you mean "non-portable" as in "no longer a C and C++ polygot"? Because, sure, using the C++ namespace will stop the code compiling as plain C (in the absence of awful macro trickery at least). &gt; &gt; If you mean "you could use the global name and a theoretical future compiler might only define the names in std" then sure, but then a compiler removing the global names is just as likely as dropping the old "FOO.h" include names. Currently, the former is an optional standard feature while the latter is a deprecated standard feature. Neither should really be relied upon (at least not for new code). The problem it's attempting to prevent (I make no statement as to what I think about the solution) *is* an actual problem, which is that you develop software for five years using just Compiler A on Platform 1, and then you decide to compile with Compiler B on Platform 2. And there's some name that A and/or 1 puts into the global namespace that B and/or 2 does not. Neither compiler or platform is *changing*, it's *you* that's changing. And it's not *hard* to fix, but it is yet one more task on the hours upon hours (if not days upon days) of porting effort you'll likely have to put in because of implementation differences (included names, warnings, places where you accidentally use a compiler extension, places where you are depending on a compiler being more permissive than it needs to be, etc.). Admittedly, I don't recall ever running into this with C library names, but this sort of thing *does* definitely arise when you have some system header `&lt;a&gt;` including system header `&lt;b&gt;`, you use names from `&lt;b&gt;` without realizing it, and on some other platform that inclusion path isn't there. That's something that does actually change -- MSVC 2010 if I remember right for example removed a lot of `&lt;iterator&gt;` includes from standard headers, so adding `#include &lt;iterator&gt;` was a pretty common thing you'd have to do.
That's too bad
I wrote guardonce to make it easy to convert in either direction, so I could switch to `#pragma once` to try it out and switch back to include guards easily if I eventually discovered some problem. But, I never did discover any problems. FWIW, I agree with the Qt Project's decision. Applications have a bit more room to try things. You can just try switching and you'll find out if there are any problems. That strategy works less well when used on a library, because you try switching and your users find out if there are any problems.
I find `std::byte` very inconvenient to use. It's defined as `enum class byte : unsigned char`, so there is no conversion from or to integer types. You have to use `std::byte{int_val}` to create a byte value from an integer type and `std::to_integer&lt;T&gt;(byte_val)` to convert back to an integer type (and you have to specify `T` type explicitly). In contrast, `std::uint8_t` doesn't have any of these limitations.
But it's functionality is exactly what you want for the concept of a byte, and is pretty much as close as you can get to a collection of raw bits, and only has bitwise operators. Now if you want to assign some meaning to bytes then they no longer are just raw bits, the type add semantic meaning, and thus operations on the data carry semantic meaning. At that point you then have to convert the raw representation into a representation with semantic meaning. That's the problem with `unsigned char` it has other operations defined for it which have nothing to do with the concept of a byte. Worst of all are the implicit casts. It has symantic meaning that extends the concept of a byte. 
Yeah, it's not necessarily nul-terminated either.
`std::basic_string` is null-terminated. It was clearly made for string manipulation. If you want SSO and other stuff, use a container that was made for the purpose.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a1abpu/do_not_output_duplicate_output_code_in_c/eao1w0g/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You can compare `std::string` objects for equality with `==`. (This is case-sensitive.)
Isn't the `int arr[3] = {[1] = 5};` actually a gcc extension?
The title is non sense largely due to raw data often coming from a device sending ASCII strings that are still raw. Raw in that you have to process the string to get anything useful from it. Now if the heading had said binary dats there might have been a real purpose here. Other wise there is a huge assumption here that all raw data isn‚Äôt suitable for storage and processing in strings. Often you get data from the field that is ‚Äúraw‚Äù that is very suitable for placement in a string. 
It's technically correct, the best kind of correct. Fixed.
No.
It can (and does) happen to us all on occasion. After being bitten by subtle problems due to unintentional duplication of include guards, or duplicate names in different project's headers causing conflicts, I started to use `#pragma`. You can care all you like, but a moment's distraction can result in a problem you'll waste a lot of time to figure out, since duplicate include guards are rarely the first thing at the front of your mind when things go wrong!
Fair point! Anything (person, build script) that's maintaining distinct include guards could just as easily make the content distinct with a comment.
`++inputArray[i]` is just incrementing the value by at index `i` by one, it is the equivalent of `inputArray[i] += 1`. What you want is `inputArray[i] += i`. 
depends what you mean by null-terminated. each "entry" is not terminated by `'\0'`, then it isn't it's actually potentially `T{}` (though, all it needs is `char_traits&lt;T&gt;::length` to point one past the end; so you likely never even need it) if that's what you mean, then it is.
Good call
!removehelp
This reminds me of [Louis Brandy's talk from CppCon 2017](https://youtu.be/lkgszkPnV8g?t=1209). And it works for practically everything in the standard library. Just start typing it in google, and the first suggestion will be "is X thread safe". 
This. This would happen all over the codebase I work with if we used #pragma once instead of proper include guards.
For me this is one of those videos I recommend people watching.
I still wouldn't use `#pragma once` in an *installed* header (you just *know* some dumbass is going to install 2 copies or something), but it shouldn't be any different than an application for internal headers.
Hard links are obsolete with CoW filesystems anyway, you should just use reflinks when you want to save space for large files.
I don't like the color red, yet other people use it?! 
I was simply running some of the code in a separate thread rather than the main thread (and I was planning to have the other thread post a message to the main thread when it's done). Seemed like it shouldn't be a multi-threaded nightmare to debug, as it's not actually doing file I/O simultaneously, just in another thread so that the GUI doesn't freeze.
It improved massively in the last 4 years or so, to be fair.
&gt; perhaps the most obvious being the small string optimization. the correct solution for this would be to have a small_size allocator but I'm not sure it's actually possible to implement one correctly for use with std:: containers
I haven't encountered anything at all, it just works. I still don't think it's in the standard, but literally every compiler I've used supports it. It also solves a problem. People will often just do an include guard with a simple symbol like VECTOR\_H, but with such a short and common name it's possible you have a compilation unit that includes two vector.h files that both use the same include guard.
I like the GSG as a starting point of "if you're going against this rule, just think about why." You're going to work with a lot of different qualities of coders, a guide serves as a minimum bar to help inform. That said, the article points out some valid issues with the GSG, but also has a bit of misinformation: &gt; Inline Functions The inline keyword at the language level only means it can circumvent the ODR. Member functions also have this ability as their definitions are "inline." Some compilers use this as a hint for inlining, but it is by no means a directive or guarantee. Not having the keyword will not prevent inlining, and having the keyword will not force it. &gt; Multiple Inheritance Inheritance is already a nightmare for optimization, but multiple inheritance really messes things up. All your call sites end up with pointer adjustments and forget about ever inlining anything. Not standing with GSG on this one though, since its unlikely that its the slow-step of your program (unless you just go rampant with multiple inheritance...) &gt; Reference Arguments I agree with GSG 100% on this one, mostly after having used Rust a bit. Your call site should absolutely inform you of what could get modified. &gt; Exceptions Exceptions are always going to be a battle in C++. My issue has always been that exceptions are not truly zero-cost. [This paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r0.pdf) highlights a lot of the issues clearly and proposes some things that would help a lot, I feel.
It's just an oversimplification. What prevents expanding a function invocation inline is defining the function in a separate translation unit from where the function is invoked (except, as the quote points out, LTO may be able to lift this restriction). What inline declaration technically does, is relax the one-definition-rule such that a function can be defined in multiple translation units which is otherwise ill-formed according to ODR (and replaces the restriction with a new one, that the function *must* be defined in all TU's which invoke it). In effect, this allows a function to be expanded inline *in more than one translation unit*. The emphasized qualification being the part that the quote left out for simplicity.
&gt; every feature that went into the language was vetted for being useful It was vetted for being useful *at the time when it was introduced*. Many parts of C++ are very old and what was considered useful at the time might be a bad idea nowadays, either because better alternatives exist, or because it turned out that the feature has flaws.
The inline keyword relaxes the ODR and serves as a hint to most compilers. The article seems to imply that the keyword WILL inline the function and the absence of it would somehow stop it. Both of which are outright false.
I did not like this article. I clicked on the linked sections of the GSG guide, and I feel like the author did not pay enough attention to the details. For example, the C++11 part in the GSG, says to use all the features "when appropriate" except for the `std::ratio&lt;&gt;` and `&lt;cfenv&gt;` header (which I've never seen before actually). Which is fine. The `std::ratio&lt;&gt;` has been useful for me to do time (or duration) conversions, but other than that I've never felt the urge to use it. That being said, I also do not like "all of" GSG either. But I am a bit biased, as I love header-only libraries and TMP.
&gt; Putting large functions in headers is poor practice Can you define large functions? Is the metric lines of code?
Let‚Äôs now look at some of the grievances which particularly trouble me. Include guards: why choose a non-standard solution when there is an established standardised, compiler-optimised solution? Forward declarations: the style guide isn't talking about circular definitions. It's talking about declaring external types and functions. Which you should avoid for exactly the reasons the style guide states. To prevent mismatches. It's why headers where invented: so you don't have to manually declare external types and functions. Inline functions: If you mark many functions inline, it means you have to include the definitions in headers. This means the compiler has to compile and possibly optimise them in every single translation unit that includes them. Namespaces: Nowadays, many projects are built as libraries with the executable as only a thin wrapper around the library. I think we can agree that libraries should use namespaces, so most code is in a namespace. If an executable is built directly from all source files, in a big project, you'll still want namespaces to seperate your logical parts. Unnamed Namespaces and Static Variables: Why would you put these in header files? That means the same constant variable is included in every translation unit that includes the header. As you say in your last point: it's 2018. Use inline constant variables. Static and Global Variables: I'll give you this one, this rule does seem a bit strongly worded. Implicit Conversions: "Implicit conversions can sometimes be necessary and appropriate for types that are designed to transparently wrap other types." Like std::string wrapping a C style string. Although even here, if std::string_view had existed at the time, this constructor should probably have been made explicit. Implicit allocation when calling a function is often unnecessary overhead. Copyable and Movable Types: I agree with the first part. Follow the rule of 0 or 5. An example of unclear copying behaviour would be the old auto_ptr. Please don't do that. Same thing for making shallow copies when a class is not clearly a handle or a smart pointer. Copying a vector of course incurs the cost of copying all elements, that's expensive, but not unexpected. It would be unexpected if you copied a handle to a 5 GB memory mapped file and it started copying all 5 GB of memory. Inheritance: I don't get your example. Why not declare a private array as a member and pass that to StrWriter's constructor? It's trivially destructible and an implementation detail, so no need to use std::array here. I haven't done any benchmarks, so I can't speak to the speed of multiple inheritance. Operator Overloading: it is a bit unclear what the GSG means by built-in. It allows overloading &lt;&lt; for streams, so it might seem logical that they'd allow emulating std::string's operator+() for string-like types. I agree that in DSL you should be able to overload operators in domain specific ways. Reference Arguments: you actually give the answer yourself. This rule ensures that it's clear at a call site which parameters may be changed by the called function. If you apply this rigorously, which I assume you do if you use this style guide, that makes it immediately obvious which arguments may be changed and which won't be. Exceptions: like you said, flame war inducing subject. But the Guide does mention two alternatives in the decision: error codes and assertions. You're right in that it doesn't specify a single way to return those error codes and it probably should. Lambda expressions: a programmer may and should be expected to see that a 200-line lambda in a call to std::transform should be factored out. You're right in that the guide could and should be clearer about this. Template metaprogramming (TMP): many programmers have a lot of trouble with understanding TMP, so I can see where the guide is coming from. There's still some use for TMP, but with the constant extension of constexpr, it's needed way less than it used to be. Boost: I agree with you on this one. Boost has some issues with readability sometimes, but I've only seen that where there's no other way to do it. C++11: It's 2018, but sadly lot of companies aren't using the latest compiler versions. Most of what can be done in C++14/17 can be done in C++11 as well. Maybe a bit less easily, but it can usually be done. Sorry for the horrible formatting, typing this on mobile while lying awake in bed. 
&gt;Perhaps the guide should just include a reading list for developers to hone their language skills. The style guide isn't there to teach you the language. It's a set of rules for a large production codebase that needs to be relatively uniform across an organization composed of tens of thousands of engineers. It's also there to prevent easily avoidable bugs that have caused problems in that large production codebase. The rest of the article is mostly contrived examples. There were legitimate grievances against it several years ago but the vast majority have been fixed. The remaining controversial points are passing out parameters by pointer instead of non-const reference and the banning of exceptions, the latter of which will never be lifted anytime soon partly for historical reasons. It's not an academic text, it's a rule/guidebook for engineers to do their jobs at one particular company.
No kidding. Removing #pragma once is not a solution, it's denial.
At my previous job our senior dev was a dick about this whole thing, so he would refuse my PRs because of #pragma once. I remember that I spent almost half a day to come up with a Bash function-alias combo that would automatically audit all of my #pragmas and replace them with #ifndef/#define guards. I was like 2 months into the job.
&gt;... and serves as a hint to most compilers. I've read other programmers claim that, but I'm not convinced. Can you provide me with a minimal example where the compiler *takes the hint* i.e. expands a function inline only when the function is declared inline even when the function is defined in the same TU regardless. If all compilers ignore the hint, then it's not much of a hint. &gt;The article seems to imply that the keyword WILL inline the function ... The article seems to imply the opposite: That the compiler gets to decide whether whether expand inline or not. &gt;The article seems to imply that ... the absence of \[inline\] would somehow stop it. That the article does imply and it is indeed false, unless, as I pointed out, the statement is qualified: *The absence of inline would stop inline expansion into more than one translation unit*. Perhaps the article should have been more specific.
My main problem with #ifndef is that it's ugly as fuck to write.
Same at my previous job. Now at this new job, I am making a point out of using #pragma.
https://blog.tartanllama.xyz/inline-hints/
Better heuristics are: Functions that are slow to compile, and functions that are modified often are bad fit for headers. But those heuristics are much more difficult to measure than lines of code, and LOC does indirectly correlates with the better heuristics, so it is *good enough* way to make an initial choice before you can afford to spend hours to prove that one choice is better than another.
Jason Turner did a [video specifically about this](https://www.youtube.com/watch?v=GldFtXZkgYo). At least for LLVM, `inline` is a slight encouragement to inline.
Also a [C++ Weekly](https://www.youtube.com/watch?v=GldFtXZkgYo) on this.
Thanks, nice article. TL;DR: The author did find pieces of code in both GCC and Clang that take inline declaration as a hint.
Agree completely. And if you allow some of these easy-to-make-confusing-code features the hordes will on average make tons of bad code. &amp;#x200B; C++ is a complex language with many features that have subtle interactions with other features and dusty corners. When used by people of wildly varying backgrounds and skill levels it is a recipe for code that very few can debug. Less is more.
Well, no, not really. #pragma is not standardized, include guards are even if not in name. Our code works fine as it is. Maybe #pragma once should address it's deficiencies? 
I can think of very few features that are completely obsoleted now. In many contexts a different feature or idiom could be better used (e.g. return optional&lt;foo&gt; instead of foo\*). Probably every C++ feature has flaws. 
Soon? [http://lists.llvm.org/pipermail/llvm-dev/2018-November/127899.html](http://lists.llvm.org/pipermail/llvm-dev/2018-November/127899.html)
Google Style Guide is great for Google (like most tools Google creates). For normal size teams or individual developers, maybe not so great (except for the people on those teams who plan to apply for a job at Google).
UGH I wish I saw that blog post 2 years ago...
Google hiring committees don't care how well you know the style guide.
It's not a warning, writing them out of order is ill formed. So many people are assuming it's like member initializers in constructors but that is not the case. Call your member of Congress--err, committee member--and let your voice be heard if you, like me, think this is very obviously the wrong decision.
Having two versions of the same header is a very bad idea, especially if only one gets included in the end. Which one is it? Could change if you changed something completely unrelated then bring doom on your project.
Aside from Microsoft trying to shove Windows 10 down everyone's throats, is there any actual reason the 'step back' feature requires Windows 10 (1605 update)? This seems like a completely unneeded requirement.
Thanks for the reply. 
Forbidden by the standard because of iterator invalidation requirements.
Pointing out exceptions to each little thing does not mean that it's not overall a benefit. All you've done is nit pick and completely misunderstand the entire point of the document.
References and addresses to uninitialized data are perfectly valid for so long as you don't use them before they're actually initialized
I've encountered a slew of #pragma once in .cpp files. When I took some time to dive in and right these wrongs, I learned that some (but not all) were necessary - because other libraries were #include-ing the .h and .cpp file instead of linking. To be fair the same problem would have happened with include guards, but maybe the original developers would have thought twice if they were surrounding their .cpp files with include guards. It's hard to say.
out of order and nested being invalid seems so stupid to me
Sorry, you're correct. I mixed it up with the regular clang driver bridge. 
That's true, it's just that you don't know if the constructor of one of your members will dereference the uninitialized sibling member or not. If the compiler can check that, then hell yeah brother.
I was just messing with this today and it seems like it already works with both clang and gcc with --std=c++11. Am I crazy?
...unless of course you want to return an optional reference to an item in `container&lt;foo&gt;`...
MSVC is what people/companies are actually using to build real world products on Windows - like it or not. (sadly that includes your ATM machines, airport kiosks, self checkout systems, etc.) Yes, I checked with other developers on this (and did a little debugger/file snooping) in addition to my own major product development experience. The next most used compiler on Windows is Intel's (usually used for libraries or performance critical subsystems). Yes, MSVC is very widely used and should be tested so that developers (and especially the compiler developers) know how it stacks up.
[removed]
I recall from the video that it requires OS support to duplicate the process‚Äôs memory (copy on write) in a lightweight manner, so the Win10 requirement is unsurprising to me. However, I don‚Äôt work on that feature.
Thanks for the answer. I kind of slide under the rug on all of the points though, as I do not inline any assembly, I do not need new windows features (game devs honestly do not really have to integrate into an OS provided you have some form of platform abstraction. Lucky us!) and I don't do dev work on Windows so I don't need profiling tools there. I have debugged in it before, but I find that gcc works just fine under Cygwin. So that clears that up: I'm probably just in the intended userbase of Mingw, whereas a Windows dev really isn't. &gt;it felt like an intentionally alien compiler for the platform Yeah, that's probably why I like it. I haven't really developed on windows (only _for_ windows) but I had heard of Chrome and Firefox wanting to/switching to Clang for all platforms, which is apparently better for windows than gcc. 
I haven‚Äôt really dabbled much with `optional`, but wouldn‚Äôt `optional&lt;reference_wrapper&lt;foo&gt;&gt;` work?
I can understand the nested one if you can just write struct B b = {.a = { .x = 0 } }; (I have no idea if you can, though.) Wish they had stolen syntax from JSON so we could write struct B b = { a: { x: 0 } }; though. Ditto vectors/arrays with `[]` instead of `{}`, and key/value pairs in maps with `:` instead of more `{,}`, but I'll live.
Better to return an `optional&lt;KeyType&gt;` so your reference doesn't get stale if the container has to reallocate its memory
If only we could declare types in function parameter lists, then we could write void foo(struct { int bar; int baz; } args); I think it's valid C though. Is there a decent trick to do it some other way in C++, or do I have to name the type? Maybe 
The backport might be an extension. Does it still compile with -pedantic?
Sweet mother of God, tell me that this *significantly* predates Qt or Boost? Having had to maintain such a platform abstraction layer written entirely in C in the style of "I'm a Windows Kernel developer, and how do I cross-platform?" (the answer is "Make Linux learn to Windows!"), and port/integrate an equally large framework from a vendor, I know full-well what a monumental work-effort something like this is. Based on the types I could see as you were scrolling by/the diagrams of the abstraction layers, I see very little that isn't done in Qt or by Boost + a little extra work. Do you get substantial value from maintaining this, or is more of a "well, everything is already built on it, and it doesn't make much to keep running" sort of situation? 
#pragma once is indeed widely supported: I don‚Äôt think I found a compiler/kernel combo bootable in VBox that didn‚Äôt support it! https://github.com/mcandre/tonixxx/blob/master/examples/palindrome/tonixxx.yaml To be fair, I have not tested tcc, Intel‚Äôs compiler, or other exotic compilers. But I‚Äôll be danged, the thing seems to work on the strangest environments!
no real world problems on projects both small and large. include guards make me irrationally mad, like why can't we get past this stupid incantation from the days of tape drives and fucking magnetic core memory!!!!
Thanks. Will use that next time
If you don't have an IDE/ other tool that does it for you.
Wouldn't that require that you still open and read each header file again everytime it gets included (although not their transitive includes) nor sure what the result in terms of performance would be. 
Not sure how you organise your work but it certainly doesn't take longer than a few minutes for me to make a simple change like that and push to to Gerrit for code review. And the review only takes a minute and can be done whenever someone has time over
Private inheritance is useful for crtp, if you don't need to inherit an interface (I guess you could make all the methods on the base protected as well?)
What does this have to do with sound?
Sounds close to that 'poison' feature gcc has, although I don't think it respects namespaces
It's possible to have one global's initialization depend on another global, and they might be initialized in the opposite order you hope. (You might hope no one would do such a thing, but then there's the law of big codebases.)
&gt;&gt; With C++17 &lt;cmath&gt; gained some special math functions that are not guaranteed available via the C++ &lt;math.h&gt;. &gt; &gt; They're guaranteed to be available in a C++17 compliant standard library. Before that, they're neither guaranteed to be in "cmath" or "math.h" and are only defined by TRs to C and C++ (ISO/IEC TR 24747 for C and ISO/IEC TR 19768 for C++). Right, you're saying the same as I informed you, but with an emphasis that indicates to the reader that some point is proved. These functions appared in `&lt;cmath&gt;` with C++17. &gt; The chances are that a system that implements the C TR also implements the C++ TR, but even if it does not, including the C header is &lt;del&gt;non-standard&lt;/del&gt; not guaranteed to give you anything that the C++ header does not; Again this appears to be an argument *against* something. But you don't indicate what you're arguing against. What exactly? &gt; using the Boost implementation is a better idea [than using `&lt;math.h&gt;`. That could be, if there is a Boost implementation, because formally the C++ `&lt;math.h&gt;` doesn't provide these functions. You're arguing strongly against using `&lt;math.h&gt;` for that, in response to me informing you that `&lt;math.h&gt;` does not provide the functions. Why are you doing that? 
In this context it's okay to read "sound" as "correct." (To elaborate: As in the "Notions of semantic preservation: refinement" part of, say, https://materials.dagstuhl.de/files/18/18201/18201.XavierLeroy.Slides1.pdf: "If the compiler produces code C from source S, without reporting a compile-time error, then every observable behavior of C is a possible behavior of S."; in a C++-specific context this is also commonly described as compiler obeying the https://en.cppreference.com/w/cpp/language/as_if rule.) For more, see: - http://www.pl-enthusiast.net/2017/10/23/what-is-soundness-in-static-analysis/ - https://stackoverflow.com/questions/21437015/soundness-and-completeness-of-systems - http://liamoc.net/posts/2015-08-23-verified-compiler.html 
&gt;&gt; As far as I know in the C++03 era no compiler implemented the &lt;cFOO&gt; C++ headers correctly, without polluting the global namespace. &gt; &gt; As far as I can tell, the C++03 standard does not require this. C++03 ¬ß17.4.1.2/4: [quote] *Except as noted in clauses 18 through 27, the contents of each header cname shall be the same as that of the corresponding header name.h, as specified in ISO/IEC 9899:1990 Programming Languages C (Clause 7), or ISO/IEC:1990 Programming Languages‚ÄîC AMENDMENT 1: C Integrity, (Clause 7), as appropriate, as if by inclusion. In the C + + Standard Library, however,* ***the declarations and definitions (except for names which are defined as macros in C) are within namespace scope (3.3.5) of the namespace std.*** * [/quote] Regarding the vigorous argumentation against dragging &gt; POSIX/C11/C19 features that aren't in the C++ standard by including "FOO.h" well again you're arguing against something that only exists in your mind, but that your argument projects also into readers' minds. You could very easily have checked the source code to see how various features are provided, just as with your first posting (and later) you could easily have checked the C++ standard for your claims about that. And so on. 
Ok, so do I then assume that every other video that doesn't state that it's not doing sound things isn't? That was more my point.
And it's coming from SNSystems, so basically from Sony, which as a game dev should mean a lot. They are still experimenting though, so don't expect too much from it for now ;) 
It's just a common word in computer science. Unsoundness exists.
&gt; unless otherwise specified as a "learn from our mistakes" kind of thing or something. I believe it's in the reference to the previously taken approach; from the talk description: &gt; The first proposed model for handling devirtualization for C++ in LLVM, that was enabled by -fstrict-vtable-pointers flag, had an issue that could potentially cause miscompilation. We took a step back and built the model in more structured way, thinking about semantics of the dynamic pointers, not what kind of barriers we need to use and what kind of transformations we can do on them to make it work. Our new model fixes this issue and enables more optimizations. In this talk we are going to explain how it works and what are the next steps to turn it on by default.
Yes, it says the names should be in namespace std. It _does not say_ that they shouldn't be in the global namespace, but it does later say that the names are "reserved" in both the global namespace and std. **As I said**: "At worst you can say that the presence of C names in the global namespace is a common vendor-defined addition that is acknowledged by the standard." &gt; Well again you're arguing against something that only exists in your mind What on planet Earth? You _specifically_ said this: &gt; I would miss out on the esoteric C11 functions only available in C++17 &lt;cmath&gt;, I would not get the Posix M_PI etc. without compiler-specific defines and undefines, and I would not get the integer overloads of abs (and div). As an argument for using (presumably) "math.h" from a C++ program. Are you actually trolling me now? &gt; You could very easily have checked the source code Implementation != standard, obviously. The standard says that "FOO.h" should act the same as "cFOO" except for the namespace. The fact that it may include extra C features is non-standard (and, in theory, those extra C features may not even work in C++). I don't know how to make that any more obvious...
Yes, `#pragma once` has several problems. The main problem I've encountered overt he years, is the inclusion of the same header twice. Imagine you build a large-ish project, which has a couple dependencies. You depend on three libraries libA, libB and libC. Everything is fine. You decide to add libD, which internally, depends on libA, and includes it's public header in their public headers. This will give you a nasty compiler error, due to the same symbol defined multiple times, since libA uses `#pragma once`, and no include guards. Since the same header exists twice, `#pragma once` is unable to distinguish that those are the same header. Include guards would've correctly determined the identity of the header and prevented double inclusion. Using your filesystem to uniquely identify a header file doesn't work, and will never work.
I agree with you. The compiler should initialize in declaration order like it does with member initializers. Te elaborate on your example, this: struct nontrivial { nontrivial(const char* label) { printf("ctor: %s\n", label); } nontrivial() { printf("default ctor for member c\n"); } }; struct s { nontrivial a; nontrivial c; nontrivial b; }; s s1 {.a{"s1.a"}, .b{"s1.b"}}; s s2 {.b{"s2.b"}, .a{"s2.a"}}; Should print this: ctor: s1.a default ctor for member c ctor: s1.b ctor: s2.a default ctor for member c ctor: s2.b
&gt; **‚Äù** What on planet Earth? You specifically said this: &gt; &gt;&gt; I would miss out on the esoteric C11 functions only available in C++17 &lt;cmath&gt;, I would not get the Posix M_PI etc. without compiler-specific defines and undefines, and I would not get the integer overloads of abs (and div) &gt; &gt; As an argument for using (presumably) "math.h" from a C++ program (on a pre C++17 compiler). You're directly claiming that using the C include gives you extra POSIX/C11 features. Reality distortion is strong in you. And the ability to snip context is well honed. With a bit more of the context, what I wrote earlier: [quote&gt; * I prefer the simpler, `&lt;math.h&gt;`.* *But then, I would miss out on the esoteric C11 functions only available in C++17 &lt;cmath&gt;, I would not get the Posix M_PI etc. without compiler-specific defines and undefines, and I would not get the integer overloads of abs (and div).* [/quote] &gt; **‚Äù** Are you actually trolling me now? I'm being very, very nice. 
&gt; Reality distortion is strong in you. I'm not in your mind. I cannot tell what the intended meaning of your words is, only what they appear to say. Posting half-complete arguments and expecting me to divine what you didn't say by clairvoyance is not a good debate tactic.
Furthermore, if one ever finds a situation where it isn't supported, it is trivial to write a script that replaces the pragma with macros. 
https://youtu.be/Am2is2QCvxY Watch two parts of this cppcon talk and I promise you will be able to write and understand code with SFINAE in 2 hours. That guy is a wizard of a word.
&gt; **‚Äù** In all (standardised; obviously what you get pre-C++98 is entirely vendor-defined) versions of C++, according to the standard, both "cmath" and "math.h" should contain the same definitions. If you get different results (with the exception of namespacing) by including one over the other then you should complain to your compiler vendor. No, that's incorrect now. As already explained a number of times, in C++17 `&lt;cmath&gt;` gives you a set of special functions that are not provided by the C++ `&lt;math.h&gt;`. I have already quoted the standard on that baffling assymetry, namely C++17 ¬ßD5/3, re-quoted below, but maybe you didn't notice because it refers to ‚Äúthe functions described in 29.9.5‚Äù. If so, mea culpa for not pointing it out. Sorry. [quote] *Every other C header, each of which has a name of the form name.h , behaves as if each name placed in the standard library namespace by the corresponding cname header is placed within the global namespace scope, except for the functions described in 29.9.5, the declaration of std::byte (21.2.1), and the functions and function templates described in 21.2.5* [/quote] Section 21.2.5 is titled ‚ÄúMathematical special functions‚Äù. I believe I have earlier provided a link to [the listing of these functions at cppreference](https://en.cppreference.com/w/cpp/numeric/special_math). &gt; **‚Äù** Posting half-complete arguments and expecting me to divine what you didn't say by clairvoyance is not a good debate tactic. Do feel free to ask about anything that's unclear. I know I ain't prefect. 
Sure, that's a well-known issue with globals. But it's not a _threading_ issue.
Main problem with #pragma once or include guards is why they're needed at all. Why doesn't the compiler just *not* include files more than once?
`M_PI` (one of the things you specifically referenced) is not in Section 29.9.5, nor are any other POSIX/C11 features...
`std::byte` isn't intended to be used in places that need an "8 bit unsigned integer". It's not even guaranteed to be 8 bits! What it is, is a fundamental unit of memory. It's intended use cases are allocating space for later constructing an object into (`std::byte[sizeof(T)]`), and for accessing the raw memory of an already-constructed object for operations such as memcpy.
Can you elaborate a bit what you mean? I am a bit confused here. Thanks.
&gt; and let the compiler glue them together for VC++ (I forget the actual limit, but there's a link to somebody's frustration with it IIRC it's less than 2^15 characters. I remember that I couldn't embed the whole text of the GPL directly.
it's a compiler extension, it's not standard
In this discussion I was just pointing them out as a C++17 exception to the general rules; I don't use them. But for the library I think it's essential to provide all that the standard headers do provide, except that tracking the standard's evolution may not necessarily be feasible. C++17 introduced one other exception to the general rule about header pairs, namely the `std::byte` type and associated functions, defined in `&lt;cstddef&gt;` but not in `&lt;stddef.h&gt;`. 
Imho the problem here is that libD shipped headers from libA that it doesn't own and hence has no business distributing. There is a non-zero chance that you now have two different versions of libA headers in your program, which leads to a different set of problems. But thanks anyway for the datapoints.
The pointer for in/out parameters is unreasonable rule in C++ that helps show where the data is being modified in the same way that using non const reference but with additional pitfall. If I see a parameter as pointer, the first thing it come to my mind is that parameter is optional (I can pass nullptr). I agree that out parameters are questionable anyway. But OTOH, if exceptions are forbidden,out parameters are a way to return the result of a function call or a possible error code.
What iteraror invalidation requirements block this? Iterators can be invalidated by increasing the size to greater than the current capacity already.
This _might_ be quite useful if `std::basic_string&lt;T&gt;` did not require a valid `std::char_traits&lt;T&gt;`....
You can reimplement the sleep function. [Get the current time](https://en.cppreference.com/w/cpp/chrono/steady_clock/now) and loop until needed. But it also depends on what you really need. Do you want efficient code? Don't busy-wait. Do you need high precision timing? You might need better OS time management support.
You don't need to sleep, you can always busy-wait. Although this all seems a bit arbitrary to me and would help if you exlpain why you need this.
I want the computer to solve a mathmatical function but I don't want CPU power to be a factor in solving it. I want a user with a junk laptop or a super computer to solve it at the same rate. However I would rather not use sleep to slow down the ideration of the loop that is used to solve it 
This is not a matter of language, it's a matter of run-time environment. If you are completely isolated on a die (there are instructions that can invalidate the entire L3 cache...) and you know that the hardware cannot vary it's execution speed (so no Intel Turbo mode, etc), and you keep temperatures constant, and .... then there is a lower bound to the absolute stability you can achieve in terms of run-time. Trivially, sample the CPU real-time clock every iteration through a tight loop until your event time has passed. Depending on OS that could give you stability to within say 20 nanoseconds. Of course your system is doing absolutely nothing in the meanwhile, which probably isn't what you want. Add in noise from a software system actually doing anything, and you're probably looking at a lower bound in the tens of microseconds, maybe hundreds of microseconds (as far as absolute stability goes) depending on OS. If you want sub-10 microsecond stability, you'll have to look at hardware / hardware-like solutions such as FPGA, custom silicon, etc.
Even with sleep function it will only be approximately the same, and sometimes even arbitrarily longer, for example if the system is suspended.
That isn't really a C++ question I would say. Is it possible in any language? I'd say no, even including a sleep function, because there is always a few extra instructions that will take a variable amount of time depending on the machine executing them. I believe that the time would vary even on machines with identical specifications, unless they're very carefully calibrated and maintained.
I checked the requirement on cppref and I think they speaking of "swap" that should not invalidate them, but a small vector has to invalidate them (I think).
Would it maybe be possible to add a difficulty component that is calculated based on the run time of a pre detirmined function that scales the difficulty of the mathmatical function? How accurate do you think I could get that?
So, you don't want to slow down't the iteration of the fast machine, but it should take the same time of the slow machine, did I understand correctly? Can this mathematical probel be solved with different precision? In this case the fast machine iterate multiple time and can find a more refined solution.
Yes it can be. So could the precision be based on the time to sovle a different function as a benchmark? How close do you think I could get? 
"Cryptocurrency without the crypto!"
Even though it is tangential to your question, you'd probably be interested in [constant-time functions](https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html), mostly used in cryptography. These don't run in exactly the same time everywhere, but given an environment the execution time should be the same every time.
That looks interesting, thanks. I'll look I to that.
Hmm I wasn't aware that existed, good spot. I checked string and iterators can be invalidated in string.swap. That's a particularly nasty one!
It sort of is, though, because it implies that the "pointer" is expected to sometimes be "null" and sometimes not. With regular pointer variable or parameter you might be left wondering if null is a valid value for it at all. 
https://github.com/cgmb/guardonce like someone already did
You can approximate this behaviour for certain problems, such as an iterative matrix solver, by iterating until a fixed time limit is reached. Then the precision of your answer would depend on how fast the machine is. But for a sufficiently crap pc you'd not get a useful answer out (you might not even finish one iteration). It should also be noted that on any regular OS even with timers you can only get the function to run *approximately* as long each time in the best case.
But like, your code wouldn't link if you omitted 'inline' (or 'static', I guess). In 2018, when there's very little justification for not compiling your release build with LTO, where translation unit boundaries don't matter for inlining. I really don't get why LTO gets sometimes talked about like some esoteric, experimental option rather than the normal, expected mode of compilation. 'inline' since C++11 has meant relaxing ODR like you describe. It's the reuse of an essentially redundant keyword which sort of makes sense because it sort of can relate to inlining in the traditional compilation model. However, it does not directly relate to inlining (other than sometimes being a hint for back compat reasons) and should not really be discussed as if it does.
Nope, but you can rely on latencies. The time to touch RAM should be pretty consistent across all systems.
&gt;constructing an object into (e.g. std::byte\[sizeof(T)\]), and for accessing the raw memory of an already-constructed object for operations such as memcpy For this case though, you really want std::aligned\_storage.
Been using it for a year professionally and I'm really happy with it so ymmv I guess.
Too true! But sometimes you need a runtime size for that kind of thing, and aligned_storage doesn't support that.
I think you have missed communicating some simplifying assumptions. As stated you need natural language processing, and non-directed learning along with a level of comprehension beyond most commercial products today. 
&gt; But like, your code wouldn't link if you omitted 'inline' (or 'static', I guess). You have two options: Either you declare the function inline and define it in all translation units that invoke it, or you define the function in exactly one TU. If you do define a function in multiple TU's, then you must first change that before you can omit inline. Once you conform to one of the options listed in previous paragraph (assuming it conforms to the standard in other respects as well), the code should link successfully. In case of template functions with unbounded template arguments, they *must* be inline, you don't have a choice. If you want to provide a "header only library", then inline is the only choice as well. In other cases, *you* can make the choice: Inline (and define in all TU where the function is invoked), or non-inline (and define exactly once). As far as I can tell, the only reason to choose inline is to allow inline expansion into more than one TU (sans LTO) - and also apparently to hint the optimiser as discussed in another branch of this thread. &gt; In 2018, when there's very little justification for not compiling your release build with LTO Perhaps. But if you distribute source rather than binary, you often cannot assume that your clients can use LTO. Furthermore, are you certain that LTO is able to perform all optimisations (across TU's) that regular optimiser does (within a TU's)? &gt; 'inline' **since C++11** has meant relaxing ODR ... No. The meaning of inline did not change in C++11. The meaning of inline function has been the same since standardisation at least. I don't know much about pre-standard C++, the meaning may have been different in some of the old dialects. 
I mean, this is cool and all, but it's not C++.
Time critical operations usually require a real time OS or environment. 
Why?
We need an easy and working standard way of generating crash dumps! On top with an easy way to integrate a crash reporting ervice like [sentry](get.sentry.io) 
Really? What if the computer is made out of clockwork?
Taking your question literally, it is not physically possible in our universe. Taking "same amount" to imply an "approximately"... remember you can't even reliably tell what time it is or how much time has elapsed if you're not in control of the machine your software runs on. For an extreme example, consider pausing a VM.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a1j823/tools_need_rollbackability_in_enterprise/eaq8mfl/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;As far as I can tell, the only reason to choose inline is to allow inline expansion into more than one TU I mean, you just stated the other reason in your previous paragraph - header only libraries. &gt;apparently to hint the optimiser as discussed in another branch of this thread. Yeah, I think the 3 major compilers do use it as a hint under some circumstances, but then again, they use lots of things as hints/heuristics. If you listen to e.g. Chandler Carruth talking about it, this is mostly kept for back compat reasons - i.e. if this were removed, it might end up not inlining something in some big codebase which could regress performance, and then the inliner would need to be tuned to get those cases etc. Inlining decisions are tricky. &gt;Furthermore, are you certain that LTO is able to perform all optimisations (across TU's) that regular optimiser does (within a TU)? Yeah, I mean, the difference between LTO and non-LTO is that the optimizer sees all functions at once, not just all the functions in a single TU at a time, so intuitively this should be the case (along with many other whole program optimizations). I'll concede that sometimes libraries are distributed as compiled static or dynamic libraries and headers, and in those cases, inline functions in the headers for the purpose of enabling inlining can sometimes be desirable. &gt;No. As far as I can tell, the meaning of inline did not change in C++11. The meaning of inline function has been the same since standardisation at least. I don't know much about pre-standard C++, the meaning may have been different in some of the old dialects. Yeah, I wrote that paragraph too fast. I do think something to do with 'inline' changed or was formalized in C++11, but I'm not sure. What I meant to say is that these days it just doesn't directly relate to inlining.
Not just swap as noted by /u/minirop, but also (much more ubiquitous) moves. This applies to all standard containers: &gt; After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in ¬ß23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via LWG 2321. https://en.cppreference.com/w/cpp/container/vector/vector
It does predate those but that ultimately misses the point really. Our system is about exactly the opposite of the usual thing, which is sort of duct taping together a bunch of third party code. We use only a tiny amount of third party code. That means that we have an incredibly clean, incredibly consistent system, that is totally under our control in terms of quality and super-tightly integrated. There is no redundancy, no differences in styles, no 'impedance mismatches' between subsystems. Everything is completely of a piece. I imagine it would take a LOT of third party libraries to provide all the functionality we do. And, don't forget, there's another 500K lines of automation system code built on top of this stuff. Utlimately the only third party code we currently use is some of the guts of the standard JPEG libraries inside the JPEG library, and we use a wrapped copy of Scintilla as a code editor, which is only used for CML editing currently, and that's not actual code that's generally called just a UI component that is used within a wrapper. So it's about quality and control and consistency. Ultimately, trying to string together 50 third party libraries and keep them stable and working over decades and many versions, and dealing with customers accidentally changing versions and all that, would be worse by far, IMO. Instead, I can put that effort towards creating my own world, that I control. I've done a lot of cross platform coding in the past, so I know the issues well. I worked at Taligent, which a lot of youngsters here probably won't remember, and at the IBM version of that that came afterwards, all of which was about creating portable class libraries. And I've done other similar things since, some on a smaller scale such as writing the Xerces XML parser in the Apache project, which runs cleanly on a lot of systems (some far further off the beaten path than Unix like the AS/400.) And I've worked on the large scale for a long time, so these types of things just don't intimidate me. 
See below. The short answer is because I can, and the benefits are massive, if you have the chops to do it.
My team uses AWS a lot, we have been quite happy with this news. 
How do you inject the alternate header?
excitingdevelopment++ I was waiting for Java 11 support for aot and better cold start time, but prob this is going to be the answers.
Definitely: void function() { } With optimisations enabled, this particular function should take the very same amount of time everywhere, even in presence of time dilation.
Off-topic.
Yeah but you're introducing "yet another standard". If it works for you and you can get paid for it, that's great keep up the good work. What if you want to use a library though that does not use your interface?
But so did every other existing library that was created. That didn't stop them. There's more than one way to skin a cat, as they say. There's nothing wrong with options. As I pointed out, we don't really use other libraries. That's not the point of this code base. The point of it is to create a totally consistent, totally integrated system. And to support the automation platform that is built on top of it. In the automation world, robustness and very quality is absolutely important. And it's more than a library of course. It's everything from the ground up. It's build tools, it's loadable resource management, it's translatable text support, it's UI resource design and loading, all of that. It's a fully integrated system, not just a library. There's a big difference.
Just C++11?
The example specifies GCC 5.x or later so possibly also C++14 or 17?
Maintainer here - You can use C++11 or later. Plain C, C++98 and C++03 can work but require you to write a shim. Will add examples on how to do that if there's enough interest. &amp;#x200B;
BTW, if you're not familiar with his work on AFIO (now LLFIO) it's really good stuff! I haven't been able to get file ops anywhere near as fast as LLFIO in my own code. His talk on the project was really informative.
Hi, I couldn't find any comparisons in startup time, how does the C++ version compare to, say, Node?
Uhhm, you could always use C++ on AWS Lambda. It's nice to have a C++ runtime available, makes things easier, but nothing prevented you running native code on Lambda.
As far as I understand, there're no such guarantees for shared libraries, so those stay may be attempted to initialize from multiple threads. At least that's what we observed (and had to fix) in our product.
I‚Äôm not in your class 
That actually made me laugh
I think, as a general rule, any experienced developer (and probably lots of inexperienced ones) consider anyone else's style choices as something at best to be pitied and at worst a statement on the quality of their ancestry. I guess it's sort of the nature of the beast amongst any crowd of intellectual beta/sigma male geeks like us. Obviously anyone who doesn't agree that the wood grain patterns in Gandalf's staff help focus his Maian powers despite the Valar having removed themselves from Middle Earth is an idiot.
Run your code through a debugger and check what's wrong
Ok, as long as C++17 is supported. I just got concerned when the example is on an old version
The problem is that it always says me 0 aka the number i put in isnt in the array
Did you want a cookie?
A better place to ask this question is /r/cpp_questions.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a1l5gg/class_exercise/eaqp2a8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
In `tres::cargar()` you are not actually indexing into `tabla` (nor are you in tres::encontrar, but I think those loops are debug loops).
IIRC shared libraries are outside the scope of the C++ standard entirely - so you're on your own there. But if you're loading a shared lib from multiple threads or calling into it from other threads before the call to load it has returned... that's your own fault.
Oh, BTW, I should have mentioned that, if you really need to use some specialized third party library, you can always encapsulate it in the same way as demonstrated here. There are some cases where you might encapsulate it in an external process and control that process. We use that in a couple places up in the automation platform layer. It has a very powerful touch screen UI design and deployment system, and amongst other things it allows you to display web cameras and embedded web browser windows. These are both notoriously flaky things (in the web cam case probably mostly because of media codecs, modern digital audio is clearly too complex for its own good.) So, instead of taking the risk of destabilizing our touch screen client, it just spawns off external processes that wrap that code, and the UI client just sends them commands (via our ORB interface) to tell them what to do, such as keeping them correctly placed within the client's window so that they appear to be part of it instead of separate processes, or telling them to load a new camera URL. The web cam process wraps the VLC video engine. That's not something we ship with our code, but the user/installer can install it and we can make use of it for web camera display. There's also the option to wrap something in a background service and use the ORB interface to access it. That's been done by some customers in some cases I think.
None of the types in `std::char_traits&lt;std::byte&gt;` are program defined so you may not specialize that. You can provide a custom char_traits to basic_string, but that would be spelled `basic_string&lt;X, yourchartraits&gt;`, not `basic_string&lt;X&gt;`.
Is the supported way of making a .zip file basically just shipping a static binary? Is it guaranteed that lambdas will run on x86-64, or should I be thinking about building lambdas that can be run on the new ARM CPU's that also got announced? What's the eventual plan for when the container needs to change to some new kernel version or whatever, will I be able to specify that certain lambdas should stay on consistent container versions or do I have to expect that they may just start running inside a new OS environment without warning? Looks like a neat API. Congrats on the launch, and thanks for popping up here!
From my understanding of the notes in cppref, `char_traits&lt;T&gt;` is only explicitly defined for the built in character types. And the suggestion is to open the standard namespace to specialise. Just as is common for `swap` and `hash`. Thus you should be able to then use `basic_string&lt;X&gt;` Now I've explicitly stated its not something I've do ne, or found a need to use; but pointed to a lightning talk which explored the concept, which others have linked. 
I just finished a project that involved me deploying a few compiled binaries of C++ source to a lambda. I read the title and for a second I thought I‚Äôd done something super sneaky and not allowed...
Node has a pretty good startup time. However, you should see a significant difference with the C++ runtime if you have a compute intensive workload.
Assuming `header_foo.h` has #ifndef __header_foo_h guard, add `-D__header_foo_h` to compile-definitions on command line so the original turns into a no-op, and use GCC/Clang `-include` to inject alternate header in, or if there is some project top-level porting headers that are customizable, such as `project_port.h`pull in stub headers from there. 
Really cool. I think this uses much of the same techniques. [https://github.com/apolukhin/magic\_get](https://github.com/apolukhin/magic_get) Seeing your boilerplate makes me sad that we do not have variadic structured binding :( Hopefully maybe in C++23 :)
I'm not sure if you noticed that I mentioned [P1061](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1061r0.html) but I would really like to see that feature accepted. Parameter packs are awesome and that proposal would be so convenient for this kind of stuff.
Here's my [as_tuple](https://github.com/mpark/patterns/blob/master/include/mpark/patterns/detail/as_tuple.hpp) implementation :) It's slightly different than yours in that the resulting `tuple` is a view into the given `struct` rather than a converted copy, but basically the same technique!
&gt; And it's more than a library of course. It's everything from the ground up. It's build tools, it's loadable resource management, it's translatable text support, it's UI resource stuff, and UI framework, it's the object request broker stuff from one of the previous videos, all of that. You have (single-handedly, based on other comments?) built your own subset of Qt. Honestly, it's impressive. But based on your comments in here, it also sounds like you're unfamiliar with just how much Qt brings to the table. It has every (or nearly, there's some abbreviations I'm not sure about) box in your diagram that isn't ORB-related or part of the application layer. It also has a *whole* lot more. I'm not quite the Qt evangel I used to be, but I still stand by it being one of (if not the most) fully-featured, well-developed, and well-documented frameworks in any language. A platform layer like this costs real money. Time time spent maintaining existing code, adding new code, training new employees, and more is all time not spent making the product itself better. If it's taking anything resembling substantial time and effort to maintain/add to the platform abstraction layer, I would be taking a really honest look at whether the bottom 500K lines of code are adding significant value, compared to that top 500K. You might be surprised.
I would never even consider it. You can't understand it unless you've lived it. The best off the shelf house is never as good as the one that is built completely to your specifications. You can't understand what it's like to work in a system like this where you know every line of code, where you seldom have to stop to look anything up, where you always know what's the best approach and how to best plan for the future (because you define the future.) It has more benefits than it does costs, believe me. If you knew the complexity and power of the automation system that lives on top of it, and consider what it would have taken for a single person just to have written that. I'd never have done it without the general purpose layer that completely integrates into everything else, that never changes behind my back with a whole new list of bugs, that I never have to wait for to get something fixed.
Questions like this are really useless. #pragma anything, by definition, is non-portable. It is a portable means of putting non portable constructs into code. The fact that anyone (several examples noted here) has had problems with it should be reason enough to never use it. I have seen you rationalize reasons why you feel you can still use it. So why ask? You're not going to listen. Problems come up in large codebases in large organizations. I have seen the biggest problems come up with mergers and acquisitions of codebases. Now you have 2 projects using the same library and you have a lot of rework because 10 years ago someone said "that will never happen to me." Include guards are much safer and you don't have to be a special case. It doesn't matter how many people have not had problems. If they haven't, it just means their shop hasn't ever faced really tough issues. I have been using C++ since cfront. I was on X3J11 when we added #pragma. Using it is lazy and does cause problems. The individual experiences that say it hasn't happened is of no value. I know people who have played Russian roulette and lived to tell about it.
Sure, find the time to execute another, fast to execute, function, bar(), then in function foo() execute bar() N times; where N is the time desired by the time to excecute bar().
I took a look at Qt. Ultimately, it's larger than my stuff, but not by that much. Part of the reason it looks like it might be is that they are exposing a lot of stuff as libraries that in my case are part of my higher level automation product, and hence not exposed or discussed here. Not that it couldn't be available also, but since that stuff is part of the CQC code base, I don't want to be showing it around at this time.
... how? That's really impressive.
Yes, and to be fair it worked pretty well for our workflow, didn't really cause problems to have mapped drives (except when they disappear because of a windows update as you mentionned :). The #pragma once's spiced things up when the tool i'm talking about invoked the compiler which then (I don't remember the exact why) encountered inconsistencies in the paths used to refer to the same file, thus causing surprising compilation errors.
Actually Qt has something like ORB: https://doc.qt.io/qt-5.11/qtremoteobjects-index.html
Yes, they're not covered explicitly, but, I suspect, the behavior is mostly covered by [Dynamic initialization of non-local variables](http://eel.is/c++draft/basic.start.dynamic). Where most things are "implementation-defined", lol. It's not that exotic as it sounds. Just have a multithreaded server code calling functions a DLL, and there's a fat chance for the same function to be invoked concurrently, given enough load. And if that function accesses static object ‚Äî well, the only guarantee here is that the object is going to be initialized before first use. So, in our project, moving a bunch of code with static variables to a DLL led to sporadic crashes, both in production and perf tests, when compiled with VC++ (for Windows) or Clang (for Linux). Thankfully, it was quite easy to fix, once we knew that, but it was an interesting lesson to learn. Since then, I prefer to write code in a way that doesn't break depending on whether static or dynamic linking is used =)
Oh, God, of course it does, now. One thing I've always had to impress on teammates (even those who have used Qt for years) is that they *really* need to peruse the index of the Qt classes. Way too often, in my more Qt-ful days, I would catch someone writing something and have to just go "why are you not using `QNotInventedHere`? The answer was always "oh, I didn't even know it existed."
That while useful is as tie.
Do you mean my `as_tuple` impl? But it takes an aggregate and returns a `tuple` of the members. That's not what `std::tie` does. `std::tie` also only takes / returns (`tuple` of) lvalue refs, whereas given an rvalue `aggregate` my `as_tuple` will forward it through as rvalue references. Am I missing something?
Unfortunately, it looks like it would have to be C++23 at the earliest.
target\_link\_directories 5 years later \[slow clap\]
Sure, should have replied to your parent as that's more likely the issue they were running into to.
\*\*Company:\*\* Uplynk, which is part of Verizon Digital Media Services, which is part of Oath \*\*Type:\*\* Full Time \*\*Description:\*\* We are looking for a small number of C/C++ developers, with some video experience, linux is a plus, ffmpeg api stuff is a plus, h.264 is a plus, HLS / DASH is a plus. \*\*Location:\*\* Sandy, Utah, USA \*\*Remote:\*\* We have remote employees, many of us work remotely, even those that are close to the office, most of the discussions and meetings are remote, on slack and in hangouts... Local to Northern Utah would be a preference. \*\*Visa Sponsorship:\*\* I don't believe so \*\*Technologies:\*\* C++98/03, C, ffmpeg, Python. \*\*Contact:\*\* DM me and I will reveal myself as the real UplynkHuman
I'd further add that with raw pointers, it's not semantically clear when pointer arithmetic is or isn't allowed. A pointer can be null, or reference a value, or be an iterator in a range (including being an end iterator which can't be dereferenced but also isn't null). That's not even touching the muddy ownership semantics that pointers are saddled with from C and pre-C++11 code.
Just create a variable Bob called b and enumerate that instead.
Honestly: kudos to you for being willing to take a look; most people wouldn't even bother, when they're where you're at skill/functionality/comfort-wise. As somebody pointed out to me in a reply, they even have [something akin to your ORB functionality](https://doc.qt.io/qt-5.11/qtremoteobjects-index.html), as of Qt 5.11. Those folk never stop adding neat new stuff. I was looking at some of your videos showing the UI designer for your software. It honestly took me a second to realize that it *wasn't* the [Qt Designer](http://doc.qt.io/qt-5/qtdesigner-manual.html) with a different skin. Having used it extensively, there may be some good ideas you could lift from them for your stuff. CQC looks pretty awesome, by the way. You've obviously put in a ton of high-quality work.
Hmm, seems like the existence of the destructor prevents them from being optimized out. I guess assembly will be the only way.
Thanks on the CQC thing... Believe it or not, I have something approaching 50 man years in this stuff. Probably says all that needs to be said about my social life.
Thanks for your reply! My current use for lambdas is very much not compute-heavy, it's functioning more as a validation/formatting gate between API Gateway and DynamoDB/S3, so the benefits probably do not outweigh rewriting our (admittedly tiny) AWS codebase in C++. I'll take a look at Lambda proxies though, I don't think I've seen those mentioned anywhere yet :)
&gt; my social life What's that? :) Having burned my whole adult life up in stuff just like this, I honestly think it's only fair to recognize what you've accomplished. That said: I actually deleted an earlier reply to this comment: &gt; You can't understand it unless you've lived it. I have. I'm one of the guys who gets brought in when talented engineers like you--capable of developing/maintaining these platform abstractions as well as the products that rely on them--stop scaling; whether that's because the company is moving too fast, you're working on newer/more fun projects, or you're moving on to greener pastures, it's always the same story: I'm good at grokking other peoples' ways of thinking/how they abstract the problems they're solving. I can pick up your work and contribute without drama, because I can write code how you'd write it. But, the same thing always happens: it scales beyond me, too. At some point the company's needs dictate that we hire people who *can't* pick up a 1MM LOC codebase and contribute to it in within the first week/month. Worse, eventually, you and I are gone. Then, the company is left with a lot of code that nobody really understands well, and you can't just hire someone to maintain. The end result is always a lot of changes with bugs, or, worse, a ground-up rewrite with *even more* bugs. So I guess this is all really just a word of...warning? I'm not sure, at this point (it's late). You've obviously got the experience to make the right choices. For me it boils down to this: if you think the company is going to outlast your tenure there, and you care about what they do and your legacy in the product, be cognizant of the fact that it's going to be hard for them to hire people to keep up the awesome work you've done. It's a lot easier to tap into e.g. the huge pool of Qt developers than to train the average person up on an otherwise unique framework. Whatever the case, keep up the good work!
Wouldn't Go be better suited for the type of applications that you'd use lambda for?
I think the rough ballpark estimate is factor two slower than C but don't quote me on that. Would still be plenty fast then.
Is the c++ standard library part of the runtime? If so, which one (libstdc++/libc++) and how regularly are you going to upgrade the standard library? More generally, how up to date are the c++ toolchains on amazon linux (which seems to be the recommended dev platform)? If I'm not mistaken, this becomes Especially relevant, if I want to harden my applications against spectre.
Correct me if I'm wrong but as far as I remeber yoy had to wrap your C++ as node module and run your function as node
I've read some stuff recently that says that this is less wrong than some people think. 
&gt; It's a set of rules for a large production codebase that needs to be relatively uniform across an organization composed of tens of thousands of engineers. No, I don't think that's the case at all. People way overvalue this. 
In short, problems appear when you do tricks such as mounting the same folder into different locations, or using hardlinks. [That's where good old include guards work, but pragma once fails](https://lists.qt-project.org/pipermail/development/2018-October/033733.html).
Yes, you need to invoke your native executable through either of the supported runtimes. I've chosen Go, since the startup time I measured for Go was the shortest, due to being native executables. .NET Core is dangerously close, though. 
In those few seconds how did it feel to be Hacker Man?
It'd be really nice if you'd tell us how to load our own xen virtual machines, so that we could use [ling](http://erlangonxen.org/)
For those not currently using AWS, can you go into more detail about Lambda proxy, and the idea in general of a \`super low-latency web application\`
QtCreator, KDevelop, Eclipse CDT or Netbeans/Oracle Studio.
&gt;`span` is like `basic\_string\_view` and `function`. You generally shouldn't be deducing its template arguments. May I ask why that's the case? (Didn't hear of that before) :-)
I'd suggest .NET Core. It's got a great standard library, and is faster than Go.
Do I correctly see that it does heap allocation within a execute loop?
Why is it self-documenting?
Thanks for your feedback! I haven't run any specific benchmarks to compare it to other libraries. However, from what I could gather when trying out other alternatives, this has better support for runtime extensibility through plugins and scripts. The focus is placed on extensibility and ease-of-use rather than sheer performance, so I wouldn't be surprised if it was slightly slower than the main "competitors" :) &amp;#x200B; As far as integrating with the build system, it is as simple as adding a CMake subdirectory. There is no specific toolchain to run.
&gt; Imagine going to the grocery store and seeing a box of cereal that says it's cyanide free. Now you're wondering if all the other boxes of cereal are going to poison you. https://xkcd.com/641/
You need a 50 line shim, to dispatch the correct functions, that's all. You can write this on day 1, and immediately forget about it. I don't see the problem with this. 
I'm not sure what you are referring to. \`SystemManager::execute\` uses an \`\_afterSystem\` vector of functions that will be called after the current system, so using that will indeed perform some heap allocations. However, as in C++ tradition, you don't pay for what you don't use, so it is entirely possible to have no heap allocation whatsoever during execution.
[If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.](https://en.cppreference.com/w/cpp/language/union) So yes, arbitrary aliasing is not allowed, but there are exceptions where aliasing is well defined.
Why is the C++ runtime not following the Go runtime protocol? Constantly sending HTTP requests to poll for new tasks is not actually great. https://github.com/awslabs/aws-lambda-cpp/blob/d987b450cd1f8d21b24f386c408fc98e8f0ed2c5/src/runtime.cpp#L407-L439
It actually seems different than what I was thinking about. I was thinking of having actual code in a database. That just seems to be using a database for compilation/linking. Doesn't seem like it changes much other than speed up compilation.
That's a very good remark. In the context of optimizer example must be valid C++
Not only that, if you add/remove components you'll also do dynamic reallocation. No idea what your intended use for this code is, but ECS in game development usually aims at data-driven and cache coherent designs - when you optimize at this level, dynamic allocation basically defeats the whole purpose - what you gain with cache friendliness, you lose in allocation/deallocation performance.
https://www.reddit.com/r/cpp/comments/a14o5q/real_world_problems_with_pragma_once/eamzb6p links to https://tinodidriksen.com/2011/08/cpp-include-speed/ which shows that for GCC include guards are *much* more optimised than `#pragma once` (and a reply points to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58770 for details).
Adding/removing components only results in dynamic reallocation if the pool overflows, in which case it will double its size to prevent too many allocations. This is somewhat of a necessity when the total number of entities cannot be predicted. In the end, these allocations will usually happen when creating many entities, i.e. during initialization.
Why does this have a CppCon tag?
while an interresting article, someone should seriously proof read it before posting :O makes reading way harder than it should in the current form
And yet, the premise of p0476 is that it's not well-defined. I think there was a CppCon talk last year that explored the options and concluded unions weren't allowed. I think what cppreference is trying to say is that all compilers define the behavior in spite of the standard, not because of it.
I think the standard still treats this case as UB. It‚Äôs just that the common compilers all implement what you expect to happen in this case. So it‚Äôs like an implementation specific feature.
That's why you tend to set a hard limit on the number of entities you have.
Yes, and I understand the reasoning behind that. However, this being a rather abstract engine and aiming to be rather versatile, I chose the flexible option. If a statically allocated pool of entities is really a requirement for a project, forking the engine and modifying it should be simple enough. Of course, I also keep working on the engine in my free time and might change this part of the architecture if it really does end up being a bottleneck.
Cool! Im guessing it has not been fixed for more recent versions of GCC?
This is specifically there to allow accessing things like common struct headings which may identify the actual union member, which is a situation that comes up in things like event or package handling systems. the `union_cast` represented here is UB for nearly all interesting cases.
It's number 10 in the article's references
[removed]
Your comment has been automatically removed because it appears to contain disrespectful profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9fq4o1/how_to_remove_elements_from_a_sequence_container/easnnli/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ahh ... you're saying it's referring to something like this: struct A { int i; double d; }; struct B { int j; long long k; }; union U { A a; B b; }; U u; u.a.i = 42; u.a.d = 3.141; std::cout &lt;&lt; u.b.j &lt;&lt; '\n'; // Well-defined behavior, as both members have a common first member std::cout &lt;&lt; u.b.k &lt;&lt; '\n'; // Undefined behavior I'd have to think about this more and dig into the standard, but you might be right.
Interesting. Perhaps Feedback Directed Optimization (AKA profiling guided compiling) should be commented? 
no, no. i'm no native speaker myself, there were just many passages with sentences that changed halfway through (visible by double use of "even" for example), that are really well visible on a proofread. its also more meant as suggestion for improvement than critique. it makes for a better overall image :)
[See \[class.mem\] 25](http://eel.is/c++draft/class.mem#25)
But those less experienced people wouldn't be dealing with this stuff. They'd be working on applications based on this stuff, which is a far, far smaller bite to chew. A couple good people could maintain and extend the general purpose code over time, because it's already there and very mature. It's not like it's some 'gotta do this in 18 months' type thing. And I also see it as actually a big positive, because at some point before long we may open source it and build our own development community around it. Unlike a lot of other OS projects it would continue to be oriented towards our own implementations of technologies, and the building of a comprehensive monolithic code base. And then of course the next guy who comes along and does something will have people telling him he is wasting his time because CIDLib is already there and already does all of that.
How exactly commented? It's compiler-specific feature, and it's hard to cover it generally.
I fully agree.
You are completely and totally wrong about reference arguments. Examples: 1. void f(const type* arg); ... f(&amp;val); // you think val will be changed, but it can't 2. void f(type* arg); void g((type* arg) { ... f(arg); // you think arg won't be changed, but it will be ... I can't believe this tripe persist to this day. That ampersand means diddly squat.
The C++ standard library is automatically packaged along with your binary and library dependencies in the output zip file (assuming you're using CMake and you call `aws_lambda_package_target()`) You don't _have_ to use the toolchains on amazon linux. They're only recommended because that's what Lambda runs on which makes it it easier to debug with less uncertainty of other factors being at play. In fact, it's one of the design goals to let you use any toolchain and build on any Linux platform. For example, you can build your Lambda function on Ubuntu 18.04 with the latest Clang or GCC or any C++ compiler really. I've personally built many Lambda functions using Alpine Linux and musl libc. There are some gotchas in the packaging that you should be aware of which I documented in the README. So, make sure you read those, and ask questions if something is not clear (create a GitHub issue). That being said, Spectre-type vulnerabilities are not an issue with Lambda (at least according to Amazon security experts, I'm not one of them). The reason being, each Lambda invocation runs in its own VM. Never shared with other Lambdas. That means, you never share Kernel memory space with anyone.
so what are you implementing yourself that Qt abstracts over with libraries for instance ? 
I don't have numbers. But I'm looking forward to seeing your findings ;)
Because C++ is using the Custom Runtime API. When Go and all the other languages were added, that API did not exist.
The bug's still open, so I doubt anything changed.
Thanks for the feedback. Glad you liked the post.
thanks, buddy, but in reality it's much more complicated than this. &gt; You need a 50 line shim, to dispatch the correct functions, that's all. that's a lot more than you make it sound like. many people switched from node to go as their wrapper to reduce startup time, because for lambda hits that's both make-or-break and occasionally the economic underpinning. c++ derives no value from go, so putting it out front is silly, no matter how small that number is. this is a new attack surface. every time a defect is found in go, your c++ programmers have to know about it and mitigate it. this is a new opportunity for subtle translation bugs between the two languages, like being out of step on unicode versions. . &gt; If you really wanted to avoid it, you could do this before the C++ runtime was a thing. Thanks, I know. I stood ning up on aws eight years ago. Don't talk down to strangers. It's meaningfully different to have first class support from the vendor. Then they're expected to provide examples, documentation, to quickly patch serious bugs, etc. "If you really wanted to" is never an acceptable strategy at work. . &gt; Lambda "function calls" are simply HTTP requests. lambda function calls are actually invokations of a xen virtual machine, tied to the internal AWS event system. They have no concept of an HTTP request - those are handled by an entirely different system called API gateway - and can be and often are tied to things that have nothing to do with HTTP, like s3 events or database triggers. This was entirely wrong. 100%. . &gt; Simply looking at the Go runtime source code would've told you how to react to them in C++. Actually, no. The go approach is a very poor approach in c++. The go approach is essentially the c approach, which c++ has extremely different preferences for. This was never about knowing it was possible, or trying to figure out how. . &gt; Edit: Sorry, the Go runtime uses a TCP protocol, which is even better Oh look, you've already corrected your first wrong anti-teaching. (Your second one is wrong too, by the way. That just connects to the event consumer.) . &gt; While the C++ runtime actually constantly does HTTP requests. WTF? Am I reading this right? No, you're not. That also just connects to the event consumer. They're both optional, they're both selected for convenience, and they'll both be replaced in a high throughput system when written by people with experience in this system. Source dives are a terrible way to understand corporate code. Corporate code varies wildly in author capacity, and is usually at the lower depths of the pool. You should be in their API documentation, then making your own decisions. Both of these piles of source - and I choose the word "pile" carefully - are terrible.
What another one?
yes, ling, the thing i linked, is the erlang runtime we'd all like to use there are hacky ways to do it, mostly on ec2, but we'd all really like to have this natively on lambda just like c++ devs didn't want to host using node as a wrapper, erlang devs don't either please let us know if there's a reasonable mechanism. it appears to fit perfectly into your existing stack
In lieu of having an actual proofreader, what I‚Äôve found is a very effective tactic is to come back to your writing a day later and read it out loud. You can catch many more errors that way!
Yes. The C++ runtime makes HTTP requests to a **local** web server on the same machine/vm. In our testing those calls took sub-millisecond to complete while running on the smallest Lambda (128MB). Please file an issue if you're seeing performance problems in that regard. With the shim, you still have to pay for marshalling data back and forth between managed and native code. You also have to pay for whatever memory and GC penalty that managed language imposes on you. Finally, correctly packaging your C++ binary dependencies is non-trivial and manifests in strange crashes at run-time. With all that being said, yes it can be done. And it has been done. We're just trying to make the lives of our customers easier. 
Thanks for the tip, I will try it tomorrow. This particular article is especially challenging for me, as I have started to work on it back in 2015, I rewrote it several times since.
Well, of course I don't know for an absolute fact that they are wrapping or implementing anything. But a lot of it is pretty obvious, because what it's wrapping is in the class names, like OpenGL. But, on my side, I have my own implementations of PNG, bitmaps, ZLib, XML parser and associated bits, HTTP, SMTP, Websockets, JSON, Web Server, object database, various cryptographic schemes (though not SSL, which is included in Windows), I do a good bit of UPnP myself to get around some issues in Windows' implementation, regular expressions, text transcoding, image handling framework, a comprehensive ORB/IDL system as mentioned elsewhere, my own UI framework (which wraps some standard controls and implements others, but either way it's a LOT of work), my own build tools, loadable text and resources system, my own very nice embeddable OO macro language with VM and IDE, a lot of speech recognition stuff which is wrapping an OS feature at the core but a lot of stuff on top of that. And that leaves aside all of the more automation related stuff, which is huge, and a lot of which is very useful outside of automation. That includes a very powerful media management system, hundreds of interfaces to devices and external systems for control, voice control capabilities, a very powerful touch screen UI creating system, centralized data storage system, an extensive configuration and customization UI, and various other bits that would hard to appreciate if you aren't an automation guy. As I mentioned elsewhere, other than OS services, which we wrap at the lowest level that we can, in the general purpose code we use two third party bits. One is some of the core code of the standard JPEG library, and the other is the Scintilla code editor control, which we use as the code editor for our macro language IDE. That's it. There are some other bits in progress, but not done yet, such as RTP/RTCP, which is a prerequisite for doing SIP/SDP next. Some behavior tree stuff which is pretty well implemented but hasn't yet been put to use. And of course I have my own complete standard runtime library, I'm not using the C++ standard runtime libraries, though it looks like maybe they do the same from poking through some code examples. And they may or may not have their own versions of various amounts of the stuff I mentioned above, it's hard to tell in a lot of cases whether they are just wrapping some third party code or doing something of their own. They have a LOT of stuff related to 3D, it might be almost a third of the classes ultimately, from a quick scan. &amp;#x200B; Anyhoo, I don't want to turn this into a whose is bigger argument. I'm sure that they out-resource me considerably, and of course they charge money to license the code which helps on that front a lot. For us, we could afford to open source our general purpose code because it's not the product itself.
Apparently, all of my post went straight over your head.
"weak_equality considered harmful" wasn't rejected. It was actually well received. But it is now moot because `==` will no longer be generated from `&lt;=&gt;`. Next step is get rid of "weak_equality" and "strong_equality" because they are now not used.
Isn't Clang implementation different from the Microsoft one? I read somewhere the MS one is the one which will be picked for standardization.
I don't know which IDE supports them, but I know the [build2](https://build2.org) build system is really good at compiling modular code.
Thanks! Is build2 a relatively new thing? I had never heard of it. I tried Rust, and while I personally prefer the C syntax, I TOTALLY LOVED Cargo.
After fixing the remaining crashing bugs (still investigating performance), I do have a thought: after checking up on what, exactly, `remove_if` does, what I actually wanted in `colony` was `erase_if`. I've slapped together a version of it into `plf::colony`, which just does a simple linear search for contiguous blocks to erase, but I'm sure there's more performance to be squeezed out of it. Other thoughts: * Polymorphic value containers are *hard*. Where I absolutely needed it, I wound up with a `plf::colony&lt;actor*&gt;` in a wrapper class that returns `actor&amp;`s from its iterators. * The wrong `#include` order and the `max` definition in `windows.h` blows `plf::colony` to smithereens during compilation. This isn't `plf::colony`'s problem, but perhaps a word to define `NOMINMAX` somewhere wouldn't go amiss. * Ran into some bizarre compilation errors with `erase_if` that ended up with the members taking function pointers instead of `std::function`s. Either the templates were getting confused, VS was getting confused, or I was getting confused. It's probably the last one, but I felt it important to mention.
What a pity. I grew up with those damn header files. I really hate them.
xmake has been around a while. If someone links to a new release of SCons or tup would you make the same comment?
Really neat.
Based on [ASMVisualizer.js] (https://github.com/piotte13/SIMD-Visualiser/blob/master/src/components/ASMVisualizer.js) it looks like this only supports two instructions. I'd say that falls a smidge short of "ultimate". 
Cool, if you see how cargo works, then you will understand that build2 have a way to create a new project, with a hello world function (\`bdep new\`, with \`bdep\` being the "cargo-like" tool). Recently I made modularized versions of these hello world projects generated by build2, you can find them there: \- Here is an example of a Hello World program generated by build2's bdep new -t exe command (first commit) then patched (second commit) to compile with modules and that works with MSVC 15.9: [https://github.com/Klaim/build2-helloworld-exe-modularized/](https://github.com/Klaim/build2-helloworld-exe-modularized/) \- And here the same with bdep new -t lib which generates a hello world library with tests: [https://github.com/Klaim/build2-libhelloworld-exe-modularized/](https://github.com/Klaim/build2-libhelloworld-exe-modularized/) &amp;#x200B; If you want to experiment with modules (using build2), these projects can be good starting points. I used VS 15.9 to compile and test them, I didn't check them with gcc or clang but I think the only difference should be the syntax (see below). Basically, the second (and following) commits in each repository shows you what you need to setup to make a build2 project work with modules. You should also read the manual for modules which explains all that: [https://build2.org/build2/doc/build2-build-system-manual.xhtml#module-cxx](https://build2.org/build2/doc/build2-build-system-manual.xhtml#module-cxx) &amp;#x200B; Last note: currently no compiler implements the current state of Modules as it is still in flux. Most of them implement (more or less) the Modules TS (which is kind of like an alpha or beta version if you will), which is more restrictive than the current consensus. So expect changes in syntax and semantics in future versions of your compiler. &amp;#x200B;
This is better suited to r/cpp_questions, but... Why are you having a problem getting GLEW or FreeGLUT? They're both easily available from their respective sites, even if they aren't in whatever kind of package manager you're using: [GLEW](http://glew.sourceforge.net/) [FreeGLUT](http://freeglut.sourceforge.net/index.php#download) &gt; I need someway to model in CPP You don't model "in CPP". You either model in another program and use a library that can read its output format, output to something simple like `.obj` and write a parser (or, again, use someone else's library for it), or in the case of something simple like a Rubik's cube, you could encode the geometry data directly into the program (since all you really need is a single cube as your model).
Keep in mind that I am not the author of this project. Perhaps you should open an issue on the GitHub project.
Mob programming needs to be renamed ‚Äútuple programming‚Äù :-)
The problem is we have too many damn build systems and package managers for C++. Every new one I learn about just makes me more pissed off and I didn't know about xmake before.
What's the difference between the remove_if it gave you and erase_if you needed? Looking forward to perf analysis.
I'm disappointed to not see abbreviated lambdas https://wg21.link/p0573r2 being proposed.
I was confused about this, too, but it turns out `std::remove_if` actually doesn't remove anything on its own. Instead, it shoves everything that meets the predicate to the end of the container and then returns an iterator to the beginning of the block of predicate-matched things (which you then shove into an `erase` method). Weird name and I don't know why it was designed that way, but that's what it does. `remove_if` doesn't make any sense at all for an unordered collection like a `colony`, and so `plf::colony` actually doesn't support it. Thanks to the magic of open source, I was able to add an `erase_if` member. I'm currently in the process of building a better benchmark, but eyeballing it doesn't reveal a difference, which might suggest I was not memory-bound. I did spot another place where I could swap a `vector` for a `colony`, so that's next up on the list. 
remove_if was designed that way to be exception safe, and since you need to do both a rearrange and destroy any way, you can batch them and it performs better.
Note that the whole AI and rubiks cube logic is completely independent from drawing the thing. If you want to get that part working you can start that and _then_ figure out how to draw it. You should also not have an issue downloading these things as long as you have access to the internet...
Thanks for the correction! I was in SG13 during this discussion and so I was trying to reconstruct the outcome from the minutes, which showed no polls taken. &amp;#x200B; I updated my post to clarify.
I talk a bit about why we're at an impasse on this subject, in my [Albuquerque report](https://botondballo.wordpress.com/2017/11/20/trip-report-c-standards-meeting-in-albuquerque-november-2017/) (see the summaries of the "Abbreviated lambdas for fun and profit" and "Lifting overload sets into objects" proposals).
I must have missed that one somehow. Thanks for the write-ups. These are the most comprehensive and useful write-ups about C++ meetings I've ever had the pleasure of reading.
Made me think of: https://xkcd.com/927/
I'm using `tie` to mean "tuple of references". I'm assuming your `as_tuple` doesn't `forward_as_tuple`, which could be wrong.
Possibly; that would be a library "solution". Another approach would be to have a language solution. Suppose we added the keyword "adl" (not realistic but follow along). You could imagine having std::adl::foo and myns::adl::foo to do an adl-lookup of `foo` while including `myns` or `std` in the lookup. Now, this syntax limits you to one namespace. So imagine: namespace{std,my_ns,bob,default}::foo and `default` would enable ADL lookup, and `foo` would be overloaded using ADL, `std`, `my_ns` and `bob` namespaces. That is probably going too far. So how about: default{::std}::foo where `default{ XXX }:: token` does an ADL-enhanced lookup of `token` using `XXX` as the "default" namespace if no ADL is found. Such an approach prevents `std` from being "blessed" with this feature. 
Thanks much! 
Interesting but not that clear, to be honest.
He who provides sources **really** should also provide the build sources. I am not building e.g. OpenSSL by making my own makefile for it. I do change it for... reasons, but if LTO was in, it stayed in.
Clang currently has its own flavor of modules (commonly referred to as "Clang Modules") as well as bits and pieces from Modules TS. MSVC currently implements Modules TS. GCC currently is the one closest to what we will likely get in C++20, which is the Merged Modules proposal (it is a merge between TS and the Atom proposal, with the latter based in Clang Modules).
Glfw + glbinding is usually a good mix. If you need a drop in replacement for glew, massive glad would do but I never tried it.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a1xr0l/i_want_to_make_a_model_of_a_rubiks_cube_and_an_ai/eauavn3/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
nice, but to be honest i would say that this is a rather complicated way of visualizing the parallel addition of 4 numbers. 
FWIW, https://www.reddit.com/r/cpp/comments/a1tmni/trip_report_c_standards_meeting_in_san_diego/
I'd be curious, what are some larger real-world example where one would use a library like that? Like if I have a library that needs to run several things parallel within one algorithm, and these (sub)tasks need to signal each other? Or a larger GUI application? When would I choose transwarp, when would I choose e.g. a signalling/slots approach?
Really depressing 
I have actually been interested in making a vscode extension for build2 for a while, but I have some other things to sort out before I can look into it more closely. No promises though!
I'd say that signal/slot is somewhat orthogonal to task concurrency. The only similarity I see is that you can model dependent operations with both, although one quickly loses overview of the dependencies with signal/slot. Essentially, task-based concurrency is useful whenever you can model distinct operations in a graph of tasks. This graph can then be executed asynchronously. Examples are digital signal processing (audio graph), machine learning (e.g. feature processing), asynchronous I/O, GPU computing, etc. I find that task concurrency takes a little bit to get your head around but then it can make your asynchronous life a lot easier and code more readable. 
You might also want to have a look the transwarp examples: [https://github.com/bloomen/transwarp/tree/master/examples](https://github.com/bloomen/transwarp/tree/master/examples)
Reposting this across multiple specific language subreddits comes off as kind of rude. Maybe a single one in /r/programming, but it still looks more like a survey than a discussion, so I don't think it would end too well.
Off-topic here, sorry.
[Here](https://github.com/tacticalmelonfarmer/cxl/blob/master/include/cxl/aggregate.hpp) is a similar thing I recently implemented, which is inspired by [this blog post](https://playfulprogramming.blogspot.com/2016/12/serializing-structs-with-c17-structured.html).
it seems like your senior wanted you to write standard c++ and not just something that compiles on your computer.
I actually did already, and they're very nice examples, but they're exactly that: Nice small examples. They don't really help understand the "big picture" where to place transwarp and when it can be useful in larger applications or libraries.
Okay cool, thanks a lot! That's a very useful explanation :-)
I've used a library fairly similar to transwarp in some respects (Intel TBB) for the software I work on (ossia score : https://ossia.io). The software is a multimedia sequencer, so the operations are fairly well expressed as a task graph : play this sound, then apply an effect to the sound, then mix it with another sound, meanwhile send MIDI or OSC messages, etc... Of course the dependency graph is constructed at runtime since it's the user of the software who actually connects the cable ; if this was done with signal-slots in a naive way without "hacks", (I use Qt for the ui) i'd have at some point to handle the possibility for every kind of object to be connected to any other. while here I just say "this task must run before this one" and I know that the following tasks can safely go read the memory of the previous task's output since there won't be any more writes on it.
I can definitely understand the desire to avoid external dependencies when possible. I actually have my own personal game engine + game development toolset (about 150 KLOC). It's built almost entirely from scratch, and it was a pretty significant effort to get it finished. And I can justify it because it does things most game engines don't do well, but mostly, it's because I want to write games using an engine that works just like I want it to work. I even wrote my own scripting language because I wasn't happy with Lua. It's really fantastic to have a complete framework that's written to your own exacting standards. Granted, I didn't go so far as writing my own version of libpng or zlib. I think a lot of people miss the point of how beneficial it can be to control nearly aspect of your framework from top to bottom. When you adopt a third-party solution, you get a huge, immediate boost to productivity, but if you want it to work any differently than how the maintainers envision it? Ehhh... that gets a lot trickier. It's rarely practical to fork it for modification purposes, because then it's no longer as easy to take advantage of upgrades and maintenance, one of the major benefits of using a third-party library in the first place. Obviously, this approach doesn't necessarily pay off for every type of project, but it seems like some developers are overly-intimidated by the thought of not using a lot of pre-packaged libraries or frameworks. You just have to understand the costs and benefits of a do-it-yourself approach.
It‚Äôs really nice to see a simple libary which would normally just have some crude api, have such an well thought through and powerful api, while simple at the same time. I love when libraries spend the time to pay attention to the details, it just makes them a delight to use.
I know that if after all the hype modules is not in I will commit suicide.
Not even just computer science, it's common English. A ship's hull is sound. A design is sound. It just means "good and solid".
Well, if modules got it, you will probably be underwhelmed. Modules are, in practice, hardly usable 
For some reason at my school i cant access the webpage. Realizing it works at home 
&gt; Java IS suitable for writing huge systems in a way which C++ just isn‚Äôt. If you try to write the kind of mega-application that Java is used for in C++ it‚Äôs going to be horrible. Juggling that much memory allocation by hand is intractable. Have you really done C++?
I mean, if anything, writing huge systems in Java is more complicated due to the unclear memory management and the garbage collection. In C++ will have the best memory management if you have good architecture and good coding principles in the team. 
And total lack of generic programming.
Well, they are hardly implemented yet?
And lack of value types and const-correctness.
You shouldn't be using templating for this at all: template&lt;int rolls, int sides&gt; static auto cast(int modifier=0) { creates one copy of that function for each choice of `rolls` and `sides`, but worse, it means that in client code, you can't use this function unless you know the values you want to roll _at compile time_. That's miserable for you as the API user because you can't do really simple things: int sides = getSides(); int rolls = getRolls(); auto cast = die::cast&lt;rolls, sides&gt;(0); // won't even compile! Also, why is this an iterator? You should end up with, essentially, a button you can press that generates a random number - there's nothing iterative about that! Also, you'd like to be able to combine two dice of different sizes - it's going to be impossible to do that because they have different types.
I disagree. This is close to the _worst_ possible API, because you have to know most of the information you need to make it operate at compile time - so you can't for example get information from the user and use that to roll dice. [More info here.](https://www.reddit.com/r/cpp/comments/a201o4/chain_em_iterate_em_copy_em_die_cast_header_in_c11/eauxyyv/)
No offense to the author but I don't think he did. From the "about" page: &gt; a web developer and graphic designer living in Amherst, Nova Scotia, Canada. I spend my days with my hands in many different areas of web development from back end programming (PHP, Django/Python, Ruby on Rails) to front end engineering (HTML, CSS, and jQuery/Javascript) &amp;#x200B;
I'll also tag on that there is no standard library in existence today that optimizes `std::optional&lt;std::reference_wrapper&lt;blah&gt;&gt;` to be the size of a pointer today, which means it's also terrible-crap with its space savings too.
&gt; One minor snafu discovered at this meeting is that prior to the PDTS ballot, the Reflection TS, which depends on Concepts, has been rebased onto C++20, to take advantage of C++20 Concepts (previously, it was based on the Concepts TS). **Unfortunately, ISO rules don‚Äôt allow publishing a TS before its base document is published, which means that to publish the Reflection TS as-is, we‚Äôd have to wait to do it concurrently with the C++20 publication in late 2020.** We very much don‚Äôt want to wait that long, since the purpose of the Reflection TS is to gather feedback from users in preparation for revised Reflection features in C++23, and the earlier we start getting that feedback, the better. **So, we‚Äôll have to un-rebase the Reflection TS onto {C++17 + Concepts TS} to be able to publish it in early 2019 as planned.** Processes above people. Shouldn't the purpose of ISO be to help, not hinder progress?
I think that blog is satirical. The poster submits the articles to r/programmingcirclejerk 
Who art thou, so wise in the ways of science? I agree. You can't make a third party library use your exception system, your logging framework, your statistics gathering system, your persistence system, and on and on. Some of them maybe may provide hooks for some of that, but it's not the same. And, in my case, some people act like not using the standard C++ libraries is crazy, but you can't get underneath and inside those libraries to do all of these things, and that means that you cannot implement many things consistently that you otherwise could. You can only implement it above the standard libraries, not below it, so a big part of the system cannot partake of the Borg. I can understand issues of intimidation and arguments of practical time to market and developer pool skill set and all that of course. But all of use have worked in the 'buncha libraries' mode, but very few have worked within their own comprehensive world. So most are going to see it from the former perspective and not necessarily appreciate the offsetting benefits of the latter. &amp;#x200B;
One would hope. If not, there's always drugs. Javascript is the Basic of the modern world; but, unlike Basic, it has orders of magnitude more complexity to go with its utter lack of type safety and inability to do threading in any straightforward manner. &amp;#x200B;
but why?
That's a pretty limited way to achieve performance. Allocations aren't something to forbid. They're just something to minimize and optimize intelligently. Professional grade ECS architectures (e.g. in shipping AAA games and engines, not just the toy engines on GitHub) most definitely allocate. The trick is to do so only _when necessary_, and often via a slab approach (no moving or _re_ allocating required).
I am going to add that since the underlying type (int32, float32, etc) is communicated with the instrinsic suffix (epi32, ps, etc), it would be great if the boxes would split based on that.
``` for(int i = 0; i &lt; rolls; i++) { std::random_device rand_dev; std::mt19937 generator(rand_dev()); std::uniform_int_distribution&lt;int&gt; distr(1, sides); list.push_back(die_cast_info({distr(generator)+modifier, sides, i+1, modifier})); } ``` This is poorly done. For each value the random device is opened, a mersenne twister instance is initialized with 32 bits of entropy, and then a uniform value is generated. The entire library is a case of taking something simple and making it complex. The entire thing can more efficiently be written like this: ``` int RollNDice(int sides, int rolls, int modifier = 0) { std::random_device rand_dev; std::mt19937 generator(rand_dev()); std::uniform_int_distribution&lt;int&gt; distr(1, sides); result = 0; for(int i = 0; i &lt; rolls; i++) { result += distr(generator) + modifier; } return result; } ``` 
Yep, that's a very good point about sometimes third-party libraries not providing proper hooks. I had to make some small modifications in the Ogg Vorbis library to use a custom allocator, which was necessary because it performed so many small, frequent allocations at runtime. That can be a performance killer if you don't use an allocator able to effectively deal with that. When I wrote and released my own scripting library, I made sure it had callbacks to replace allocators and logging, as well as APIs for memory and performance monitoring. I cut my teeth in an era where the standard libraries were much less robust than they are today, and as such many companies tended to write their own collections, etc. So a few years ago, I was contracting at a company who had their own low-level list class for instance. Because they wrote it themselves, they were able to implement it as an intrusive model, which performs much better at the cost of some versatility and ease-of-use. These days, I'm much more bullish about using the standard library in my own projects, as they've helped me reduce the amount of platform code to maintain - an important consideration in a one-man show with limited funding. It's now much easier to use custom allocators in std containers, and things like the thread library was more fully featured than my own, so I replaced all that with standard library code. I'd probably like to use filesystem if it was more widely available, and hopefully the networking lib can replace some of my socket libraries (or at least simplify them). When something makes it in the standard library, I feel like it's at a point where I can rely on it for the long-term, across just about any platform I'm likely to port my games to. But like I said, I certainly understand the appeal of having control over as much code as possible - especially when it's long since written and debugged, and you're now reaping the benefits. 
on mac --&gt; xcode and commandline tools. installs everything you need. gcc 'works', that is, it is symlinked to llvm in the terminal. c++ can be used for native development on the mac, alongside c, objective c and swift. start with : #include &lt;stdio&gt; int main(){ std::cout &lt;&lt; "Hello World!\n" &lt;&lt; std::endl; return 0; }
Try downloading Code::Blocks, it's a free, open source IDE and is great for beginners :) You can find more info on their website, and get relevant info as to what to download to suit your needs.... &amp;#x200B; Happy coding :)
Try downloading Code::Blocks, it's a free, open source IDE and is great for beginners :) You can find more info on their website, and get relevant info as to what to download to suit your needs.... &amp;#x200B; Happy coding :)
You need: 1. A compiler - gcc/g++ 2. A text editor - VS Code or your fav one. That's it. 
I've used SCons before, and my current gig uses WAF. And at a former employer, we actually used Lua as a custom build system, so I'd probably feel quite at home with xmake. Even so, I'm biting the bullet and learning CMake, because I was tired of maintaining separate projects by hand - and new projects were a pain to set up properly. I kind of hit a "last straw" moment when I made a slight change, and my Xcode project lost track of where all the source files actually lived. Using a "standard" has tremendous benefits, because you benefit from the network effect of using a popular tool or library. I realized this after I had chosen Mercurial over Git for my own projects, and later regretted it, not because Git is superior in any sense, but that *everyone else is using it*. That mean Visual Studio had integrated Git support, not Mercurial. It mean that there are many great Git-related tools. Far less for Mercurial. Now I use Git. Honestly, I've love to see a more sanely-designed system besides CMake move to the forefront of the C++ community, but until that happens, many people are better off using a flawed but more standardized system. And yes, unfortunately that tends to be self-defeating in terms of getting new, improved systems in place.
Just use Xcode
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/a25mkh/c_for_mac/eavc2w8/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
statistics and tabletop RPG simulations
\&gt;Still, it will be interesting to hear from people with little to no experience I've learned about C++ Coroutines just recently and tried to implement toy async file IO api. Initially I've read TS, stared at some code examples and then read /u/lewissbaker posts. It all started to make sense only after making the standard extension points to be simple forwarding wrappers around more intuitively named functions. Like this post, especially \`coroutine\_context\`, and hope it'll get traction.
not sure what you mean about different die size. `auto result = die::cast&lt;1, 4&gt;().cast&lt;1, 8&gt;();` returns two sets of die rolls joined. One for the 4-sided die and another for the 8-sided die. Iterator syntax added so you can user a foreach loop on the result as seen in the README. Noted about compile-time limitations.
you can't chain them this way. Noted about the device initialization.
Thank you for noticing! that's my goal. C++ _can_ have beautiful syntax when properly planned.
Minor change to the api will fix this.
what about modules would make you want to pick up c++ as a hobby? It doesn't do nearly anything for making hobby programming better.
What do you think modules changes about "those damn header files"?
I had a feeling that the network TS was going to be shot down. Although ASIO is good, it abstracts a whole lot unfortunately. 
If you are serious about this, I'd like to encourage you to get help. Talk to your doctor. If you are in the USA, consider calling the National Suicide Prevention Hotline ( 1-800-273-8255 ). There are [similar crisis lines](https://en.wikipedia.org/wiki/List_of_suicide_crisis_lines) for most countries. Suicide is no joke. I wish you the best of luck in your recovery!
std::string is particularly nasty on old gcc versions (up to 4.9.x). You would think that the libstdc++ is C++11 compliant, but it is not! In these version std::string is COW. Meaning that trying to mutate the buffer of a std::string could end up mutating other instances...
I love this post as well. The current coroutine api is basically impossible for me to understand without going onto the slack channel and having these questions explained.
Wtf is a Microsoft Cloud background check?