!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/71s9ya/is_it_just_me_or_writing_a_full_working_windows/dndgww1/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/71gr2y/i_want_to_create_an_app_in_c_but_it_seems_that/dndh0jy/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Steer clear of r/educationalgifs, then.
I'd be interested to see how just using two #pragma omp parallel for in the standard c++ version would compare to using CUDA
Pdfs support transitions: https://tex.stackexchange.com/questions/22412/beamer-transition-effect
watching those make me irrationally angry. text people, text. It's so much more efficient.
Clang, GCC and MSVC all implement unique_ptr differently and depend on different mechanisms. For example GCC implements unique_ptr in terms of std::tuple to represent both the object and deleter and depends on a compiler optimization (specifically the EBO) to erase the deleter. The EBO optimization that GCC uses doesn't work in versions of MSVC before MSVC 2015 Update 2, and even with Update 2 you need to explicitly opt-in to trigger the optimization. This means shared libraries built using mingw and MSVC will not be binary compatible with each other if you use std::unique_ptr to acheive pimpl. However, if you use the ComPtr provided by Microsoft, it will be binary compatible since ComPtr is explicitly designed to preserve binary compatibility. In general you need to be very careful about how you expose classes in shared libraries that make use of the STL. Different implementations use subtly different mechanisms to accomplish the same things and there's no guarantee that the compiler will treat them identically, even if the end result is the same.
That's great. Thanks. It's a great coincidence that I was designing a variant class today in work. I'll instead try to use one of these solutions. Great summary.
IMO, the default nowadays should be std::unique_ptr or std::shared_ptr, depending on the use of a pointer. If you need to dynamically allocate an array in memory, use std::vector. Using **new** doesn't seem to be recommended anymore unless you explicitly want to be doing those things that could potentially be unsafe. Part of your issue is that you are taking what you were taught a long time ago (the old way) and not looking at how modern C++ is taught.
Comment voting are not pure function. :P (people hate on my hate for ISO incompetence in some other comments, although I think I am not being a hater, just pointing out when they really do a shitty job and/or spin it as a feature)
I don't think you get my meaning. I do understand the modern way, syntax matters, unique_ptr being default over new is ugly.
Maybe this would help: #define var auto #define ptr std::unique_ptr Your problem is that typing std::unique_ptr sucks? Personally, I would think std::shared_ptr would be a better default, but sometimes you don't want the extra overhead. This is c++ after all, so no matter what you're going to have to have a way to differentiate between shared_ptr and unique_ptr (and weak_ptr). They tried auto_ptr in the past which might have an argument to replace new, but it turns out that it wasn't such a good idea.
Lol, thanks :-)
Thanks for your feedback.
This doesn't solve one of the main problems that PIMPL is trying to solve. You still need to recompile all the translation units that have assumed the original class layout before you modified the class.
There are two different names, `a` and `b`. **Named** Return Value Optimization chooses one of the named variables in the function, so it can only work if all the returns are the same name.
This again is based on the shortcomings of C++'s header system and its impact on the build system. The need to recompile translation units because an irrelevant implementation detail in a module changed - as well as even the _cost_ of such recompilation - is not present in some other languages (and, hopefully, won't be present in C++ toolchains in the future). A unit should only even need recompilation if something affecting the compilation actually changes. The current C++ ecosystem often results in a change to a comment in a header recompiling code, which is just silly. With many intelligent hash-based build system, the recompilation is avoided in the comment-changed case (though costs like the preprocessor and such are still involved). With module-aware build system - and an implementation based on module units like Microsoft's .ifc files - units only now need be recompiled when a module is meaningfully changed; that won't itself avoid your complaint or use for PIMPL, of course. However, the structural module approach enables the proper solution: only recompile a unit if its dependencies change. Which means, only if the public attributes of its dependent modules change. As a unit can statically cache its dependencies and their state (e.g. a hash), a build system is more than capable of splitting a types attributes between public items and implementation details and then only recompiling units when they really truly actually need it. That is all implemented to various degrees in at least some other languages, particularly functional languages. Rust has something like that in experimental state (["incremental compilation"](https://github.com/rust-lang/rust-roadmap/issues/4) as they call it; see [issue 37333](https://github.com/rust-lang/rust/issues/37333) for something as close as possible in Rust-land to the C++ PIMPL problem you're noting) as an example of C++-like machine-oriented systems language that is pursuing this approach.
In C++, an object doesn't exist until its constructor terminates (or, more specifically, the constructor of the most derived object terminates). This means that in `Foo { .b = bar(), .a = doit() }` if `doit()` throws an exception there has never been an instance of `Foo`, and therefore there is no `Foo` object to destroy. Instead, the already constructed members will simply be destroyed one at a time. Therefore, the logic goes like this: // Don't do this at home! struct Raw&lt;typename T&gt; { std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type mStorage; T* operator-&gt;() { return reinterpret_cast&lt;T*&gt;(&amp;mStorage); } }; Raw&lt;Foo&gt; raw; B* raw_b = nullptr; A* raw_a = nullptr; Foo* foo = nullptr; try { new (&amp;raw-&gt;b) B{bar()}; raw_b = &amp;raw-&gt;b; new (&amp;raw-&gt;a) A{doit()}; raw_a = &amp;raw-&gt;a; foo = &amp;raw-&gt;(); } catch(...) { if (raw_a) { raw_a-&gt;~A(); } if (raw_b) { raw_b-&gt;~B(); } throw; } foo-&gt;~Foo(); // Destructs B then A. It does mean the order of destruction between the initialization phase and the destructor differ, but I argue it doesn't matter. 
.odp
OK, but question is then why there isnt there an Unnamed :) Return Value Optimization. In other words if both branches need space for 1 string where is the big difference... I mean `if(rand()%2) { string a("haha); return a; } else { string b("anana"); return b; }` can be equivalent to `string ret; if(rand()%2) { string a("haha); ret = a; return ret; } else { string b("anana"); ret = b; return ret; }` 
I have a love/hate relationship with Eclipse. It does work pretty well. But it always feels like bloatware.
Those are _not_ equivalent.
I mean, you really only needed the last line of this post. The reasoning of the comittee has nothing to do in particular with a member's constructor throwing. It's just that members always have to be constructed in the same order, so that there is a single order for destruction that destroys in the correct order. In your example, that doesn't happen correctly, because b is destroyed first even though it was constructed first. You're entitled to think this doesn't matter, but this is a very strong guarantee of the language, and it's very very useful at times. Even if you don't make use of it personally, it would never make sense to introduce an exception to this just to save people re-ordering their initializer list. And, frankly, it's a key property of correct RAII. I know some newer languages like Jai and Rust ignore this, and I think it's a pretty terrible mistake. Even e.g. python's with statement gets this correct (when you use with on multiple things, it indeed closes the context managers in reverse order of opening).
Qt Creator is a great C and C++ IDE. There is a common misconception that it's useful only for writing projects that use Qt, and that's not true. While it does provide nice features for projects that do use the Qt library, it's also a great general C and C++ IDE. It has good refactoring capabilities, fast syntax highliting, good shortcuts (ctrl+click on a type or function to instantly go to its definition and F4 to switch between foo.cpp and foo.h are probably ones most used by me), you can split the code editor vertically/horizonrally many times, cmake server integration, clang code model, in-line code warnings before you even compile the code, great debugger ui, valgrind and callgrind ui integration, nice things like TODO plugin that adds a panel listing all TODO, FIXME and such comments the project has, a feature to sort highlited region of text (nice for sorting headers alphabetically), vim mode, git integration, gerrit integration, etc. It's also highly customizable: you can ask it to automatically insert license header in all .h and .cpp files you create, change default file extension of files from .h to .hpp or from .cpp to .cxx or whatever you want, change code highliting scheme, change code style/identation, etc. It's also cross-platform, so you can use it on Windows, Linux, macOS and maybe others, which is a big plus if you switch between different OSes for development.
For traditional RVO the return statement needs to be an rvalue. `a` and `b` are lvalues. (That's why if you want RVO on a named variable it has to be NRVO)
I know that's how things end up, but my point is: * when working on a piece of code in a large project, one modifies but a small piece thereof; it is not normal to even look at the rest; you build/debug/test that piece anyhow, don't you? * it's really a consequence of a shoddy work. So you say circular dependencies in projects: what do you mean? That can't even build at all. You maybe mean between headers only? But anyhow, that's not normal, some refactoring is in order; in other languages, this situation indeed ends up in a circular project ref and you can't build, period. So you say art artifacts: but when working on your part, you only need a small part thereof, and even then- do you need to update that and have the most recent version? So you say "headers included everywhere" - well, just don't do that. tl;dr shoddy work, but only tooling is the problem. Eh... it's a combo of the tool and the work.
What do you think that "GL" in "GLFW" stands for?
Incidentally that doesn't mean you can't create their windows and use them for input. It just eases GL development. I've seen it used for Vulkan, and they don't have a VK in their name. 
Who is still writing their own C++ compilers in 2017 ? 
Iirc it was based on a GCC 4.6 or something
I've had very good luck with [HTML slides authored with RStudio](http://rmarkdown.rstudio.com/lesson-11.html). Besides being highly portable and only requiring a browser to view, they also have the advantage of [LaTeX](https://www.latex-project.org/) support and direct embedding of figures from R, both of which are outstanding for scientific presentations. The downside of this approach is that you really need to understand HTML and CSS, which, I'm guessing isn't much of a problem for people in this subreddit. Also, because these presentations are authored with [RMarkdown](http://rmarkdown.rstudio.com/lesson-1.html), the process of presentation creation is substantially different than with PowerPoint. Compared to PowerPoint, the biggest feature I miss with HTML slides is not being able to move slides around in the slide-sorter view. Also, if I'm in a hurry, PowerPoint is quicker. On the flip-side, HTML slides take longer to set up initially, but the format gives you much greater control over how the presentation renders. If you decide to make a formatting change with HTML slides, you can re-render the entire presentation very quickly. Doing so with PowerPoint is possible, but doing it in a consistent, easy-to-maintain manner is not.
By the way, I also meant to say that I really enjoyed your presentation, and it even inspired me to post a question on /r/cpp_questions.
Well, auto is defined that way ... to be consistent with template argument deduction for functions. I actually like it this way. I prefer references to be explicit. The reference types are very different from object types. GetBar returns a reference but the expression is an lvalue of type Bar. The types of expressions are always adjusted like this. The name of an lvalue reference to type T is an lvalue expression of type T, not of type T&amp; as if references are immediately implicitly dereferenced. The type of an expression is different from the *declared* type if references are involved. That's just how it is.
&gt; why auto can't deduce the reference from method return type? As your title states, `auto` follows the rules for template type deduction. It's not that it _can't_. It's that it _won't_, intentionally. If you need reference deduction, use `decltype(auto)`. There are several reasons why this behavior was chosen. Consider this: if `auto` deduced to a reference then how would you bind a reference to a value using `auto`? That is, consider this code: foo&amp; get_ref(); auto x = get_ref(); // decltype(x) == foo auto&amp; y = get_ref(); // decltype(y) == foo&amp; If `auto` deduced references then how would I rewrite the code so that `decltype(x) == foo`? Certainly a syntax could be invented, but the decision was to add only `auto` at the time and follow the template deduction rules for consistency and grammar simplicity (`decltype(auto)` came slightly later and exists mostly for perfect-forwarding use cases, though it is an example of how new syntax can be added to address deduction defaults). It's very debatable whether the common desired use case is to capture by reference or to capture by value (I'd say reference, but a lot of very smart people disagree) so it's hard to even argue along principle-of-least-surprise lines. Whether the design was the right choice or not is somewhat moot since we're stuck with it now forevermore due to back-compat concerns.
That's just how the rules for type deduction work. If you want to use auto as a "take the exact type of the signature", auto&amp;&amp; works. I recommend reading Effective Modern C++ (where the first chapter is all about type deduction) if you want to fully understand auto
We are in a programming sub. Just open it with a zip reader, extract the xml and parse out the plain text. Should be doable in one or two hours. 
I don't think compiler/standard library writers are incompetent as you're stating.
Hi r/cpp I'm an experienced Web Developer who tries to get a grasp on C++. I have already learned the syntax and the characteristics of this beauty, however it feels hard to move on from this point. In particular, I'm looking for some kind of course or tutorials, which walk you through creating a few 'real' applications instead of just explaining the general concepts (which is what most C++ courses, e.g. on Udemy, do). In order to understand how to really use a language 'in the real world', project-based learning has always been the way to speed up things for me. Seeing what you can accomplish and how one would approach it makes it so much more intuitive to use. Do you have any suggestions for me? Thanks in advance!!
I second this request, I also think that project-based learning works the best. However, I have a comment or a warning, rather. Every time I tried looking up full projects (e. g. on GitHub) to try to understand their approach, I noticed that they were really advanced. The easy ones, on the other hand, were not much dissimilar to the exercises you find in a good textbook. I know that your request is actually for *an instructional* on a project and that would really be ideal. But until you find that, it could be a good idea to think about your needs or problems and give yourself a project. It could be a simple tool to ease a task or a rather advanced one. This way, you‚Äôll feel motivated and really connected to the task, knowing its use and what *you* and *your workflow* will get from it. Then research step by step.
thanks for your reply!! I find it hard too, to go through advanced C++ GH projects without proper guidance, though I do this frequently for projects in other languages I'm familiar with. I have a hard time coming up with a starter C++ project myself - mainly as I would solve most problems I come up with with either Python (for hardware projects, e.g. on RPi) or build an Android- or WebApp for itüòÅ I've tried playing around with Arduinos, but that's not quite the same as building a standalone application, a little syntax knowledge and you're in üòâ Any suggestions for a viable learning project?
This is why in chromium you are required to write auto&amp; for references and auto* for pointers... because people make wrong assumptions about deduction...
I mean, it probably is a good idea to do some reading and understand the basics of how auto works before you use it, instead of just trying to use intuition. If most of your colleagues had the same issue, you have a training problem. 
Personally, I‚Äôm currently learning C, rather than C++. In my case, for example, replicating the usual Unix programs (ls, cat, cd, cp and so forth) is a common exercise. But yes, I do have personal ideas too. I‚Äôm an academic and I have tens of thousands of study materials for various subjects. I‚Äôm trying to figure out a way to make a program to help me both browse and organise the files (e. g. based on metadata, preferably embedded in the file, if the format allows it). I do have plans for C++ as well. Two examples: remaking the program above, but using classes where I would use `struct`. The second one would be using the SymbolicCpp library. I‚Äôm a mathematician and since I don‚Äôt like Python, I reckon I can replicate some SymPy with SymbolicCpp. :) As you can see, the examples are quite custom to my use. But maybe you can find something useful. Or better still, get an answer to your original question, with an instructional that is project-based. I‚Äôd love that as well.
You think `std::shared_ptr` should be the result of allocating dynamic memory *by default*? 
Depends on exactly what you want to animate. If it's individual figures on the slides, then you can use SVG with animations.
I don't say that auto should create references by default, but in the very specific case that I've mentioned, when a method returns a reference, it is easily detected at compile time. 
If that's the behavior you want, use `decltype(auto)`. The functionality is there, it just has a different name than you want. (N.b. changing `auto`'s behavior now would be silly and break _everything_.)
That's a good styleguide, but there is a problem: if you don't specify auto*, you still can get a pointer. If you don't specify auto&amp;, you won't get a reference
`decltype(auto)` would get a pointer and lvalue-reference respectively. The rule is not complicated: `auto` decays, `decltype(auto)` doesn't.
The problem is C++ can be used to create almost any type of application so what exactly do you mean by "real" application? Unlike, say, learning Django framework with Python which can be used only for creating websites, C++ can be used for anything. Tutorials that teach you how to create application with GUI usually focus on the GUI framework rather that language. 
Not the way I like most, but still a solution, thanks!
Scott Meyers and Herb Sutters books really helped me to step up my C++ game. Those guys are awesome and introduce many nice and elegant solutions to real world C++ problems. I understand that you might want to get a little bit more hands-on experience before reading those kind of books though. I can't tell you what real world application you can implement but here is a list of C++ topics or concepts which are IMHO really important to learn to get a grasp of modern C++ programming. Try to make use of these when you implement your application: * Smart pointers - why do we need them? how do they work? which one would you use to implement a cache? * Rule of 5 (formerly known as "Rule of 3") * Templates and the STL - of course this is a huge topic but just remember: before implementing anything yourself, take a look into the STL. It might be there already * RAII * function pointers and lambdas * Multithreading and locking This list is far from complete but I think it's a good start. Also: If you finally find an application to implement, post your results somewhere and get it reviewed by others. EDIT: Do yourself a favor and forget about all those tutorials and books that teach the OLD way of C++ progamming. There is an exception for everything but if you wan't to learn a language that is as complex as C++, try to keep it simple. Use strings over char*. Use smart pointers instead of raw pointers to manage lifetime. Don't use malloc/new. Don't use makros. 
&gt; Tutorials that teach you how to create application with GUI usually focus on the GUI framework rather that language. that's not my focus eitherüòâ I would really like to get a good overall knowledge of the various standard libraries in C++ and what they can be used for.
Just for those who are curious, I've found one tutorial building a keylogger in C++ (not my main interest, but a start), free on udemy currently with the promocode from here: https://www.reddit.com/r/udemyfreebies/comments/71gs3b
Guys at Lynda have some good stuff as I remember and they give you exercises :) also "Programming: Principles and Practice Using C++" is a very good book which always gives you some exercises at the end. Give it a try :)
No, just update your fucking software on a regular basis, like every sunday, no need to watch out for CVEs. What you just said is a non-argument. And we are on a programming subreddit, we are not "the vast majority of users".
Something that might help is that some (maybe all, not sure) Arduino compatible devices support C++. I personally learned a bunch building my own pool automation using the Particle Photon. I still have a lot to learn but it gave me something to do. The photon supports C++11, uses gcc and most STL (they have their own built-in classes/functions for the things not supported), has a cloud compiler or you can compile locally. Build something cool and learn at the same time. Great community support, tons of libraries for sensors/displays/etc and plenty of tutorials. 
Suggested reading, section 2 of http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf It talks about the rationale behind the choice of auto's semantics. 
[removed]
One big advantage of static libs is that it makes unit testing your code very simple. Your Catch executable just needs to link to the static lib of your production code and immediately has access to all symbols you need for your testing. That's without having to export things you don't need on production dynamic lib interfaces or compiling the same code multiple times for production vs testing, which can be very slow indeed. Plus you aren't actually testing the same code that you ship. Even when we actually ship a DLL, we generally first create a static lib with all the code, and use that for unit testing. Then we link that into a DLL and that's what we ship. 
I skimmed over the long article so will comment on the main points at the end: &gt; Static libraries are really just object file archives, with a bit of additional symbol indexing. One important difference is that an object file is only "picked" from a static library if it is actually needed (that is, it satisfies a previously unresolved symbol) unless you link the library in the whole-archive mode. Over the years I've seen many cases of people that don't understand this being bitten by this important difference. Also, the order of linking static libraries (unlike object files) is significant. &gt; Bundling object files into static libraries doesn't affect code linkage, which is why it's really easy to decompose a project into 'internal' static libraries. I believe the commonly-used term for these is *utility libraries*. One important difference compared to vanilla static libraries is that you want to use the same object file type as the "final product". For example, if the utility library is for a shared library on Linux, then you would want to use object files built with `-fPIC`. &gt; The actual information hiding from the static library build step is minimal (just a list of object files), and, unless your code is already well structured, your project is unlikely to benefit from this information hiding anyway. As the other commenter already noted, a major benefit of utility libraries is for building unit tests. If your "final product" is not a library (executable), then without a utility library your only option for linking unit tests is to list the needed object files manually. In fact, this could even be handy for shared libraries for testing internal functionality (e.g., non-DLL-exported functions). 
&gt; One big advantage of static libs is that it makes unit testing your code very simple. wait until you have 200 test executables to link against 
I'm not sure how static libs make very large projects any worse? Can you elaborate? Is it that the same static lib needs to be linked into 200 executables vs once into a dynamic library?
&gt; Is it that the same static lib needs to be linked into 200 executables vs once into a dynamic library? Yep. When it takes 3 second to link you're good for two minutes of waiting every time you change the lib and recompile.
Maybe the right thing to do is to create a static lib of the code in question so that it can be easily unit tested. Then link that into a dynamic library, which can in turn be loaded by the 200 projects? 
&gt; Then link that into a dynamic library, which can in turn be loaded by the 200 projects? and then, what's the difference with this and just dynamic linking directly ? 
Depends on the API that's exposed on the dynamic library I guess. If it exports everything you might ever need to test it then there's no need. If on the other hand it exposes an interface that hides a lot of the details that you need for unit testing that code (eg, for inserting seams, injecting, mocking etc) then you can't simply use the dynamic library as is.
You talking this http://shop.oreilly.com/product/0636920033707.do book? Do you have any online video series covering these points you'd recommend?
Seeing stuff like this makes me like reddit more than Facebook. 
Yes, there are several things wrong in this short comment. 1. It is not the compiler that is at fault here, but the library implementation. 2. Implementation is actually super fast. There should be no sarcasm here. The standard was finally approved only couple of weeks ago, and we already have two almost-complete implementations. It took much longer with previous standards. 
You continue to mistakenly refer to ISO where WG21 (aka "C++ standards committee") would be appropriate. 
Actually, there is a deleter that needs to be stored somehow. Most of implementations rely on EBO in case the deleter is empty, but it is not specified how exactly this is done (and EBO was not supported by MSVC until recently).
PGI has a free community edition of their compiler (works on Windows/Mac OS/Linux), although it seems to not be the most recent version (if I understand correctly). Sadly, it looks like PathScale has gone out of business. [An article](https://www.hpcwire.com/2017/03/23/hpc-compiler-company-pathscale-seeks-life-raft/) on HPCwire from earlier this year says they were looking for buyers. Their website (pathscale.com) times out for me. The HPCwire quotes PathScale's CTO and owner Christopher Bergstr√∂m: &gt;‚ÄúUnfortunately in recent years, we bet big on ARMv8 and the partner ecosystem and the hardware has been extremely disappointing,‚Äù said Bergstr√∂m. ‚ÄúOnce partners saw how low their hardware performed on HPC workloads they decided to pull back on their investment in HPC software.‚Äù
I have been creating my presentations using Markdown and versioning them with Github for a little over a year now. I was not aware of [gitpitch.com](https://gitpitch.com). Thanks for the suggestion.
There are a number of wrong or misleading and unhelpful descriptions in this post. To start with, the terms are lvalue and rvalue. They are not hyphenated. The terms are not l-value nor r-value and certainly not "left value" or "left reference." Use the correct terms. This definition: &gt; A r-value is one that should be on the right side of an equals sign. is neither correct nor particularly useful. You can have lvalues on the right side of an assignment, you can have rvalues on the left side of an assignment. You have even have lvalues and rvalues without any assignment involved! It's also worth pointing out that the `print()` example is quite wrong. `print(std::string const&amp;)` does not detect rvalues, it would also bind to const lvalues. And the call `print("rvalue")` does not actually call `print` with an rvalue, `"rvalue"` is an lvalue. When `std::move()` is presented, it's described as being used "when we know a variable is in fact a r-value". Well, no. Typically, the value category of the expression you want to move is an lvalue. The purpose of `move` is to *cast* it to an rvalue, to enable its resources to be reused. This is pretty important. &gt; So what `std::move` does exactly behind scene. I do not know myself when I am writing this paragraph, so let‚Äôs find out together. You could simply look it up on [cppreference](http://en.cppreference.com/w/cpp/utility/move) and see that it's just: template &lt;class T&gt; constexpr std::remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept { return static_cast&lt;std::remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t); } It's just a cast to rvalue reference. The use of `ResourceOwner` as an example is also quite odd since the member there is `std::string*`. `std::string` already manages its own resources, why use a pointer to it? Either use a `std::string` or use a `char*`. But where this gets questionable is the entire several paragraphs explaining what: ResourceOwner &amp;&amp; rvalue = std::move(res); does. The correct answer is nothing. It does nothing. It's a reference binding. I have no idea what the post is trying to demonstrate here. It could have shown the difference between move-constructing a `ResourceOwner` and copy-constructing one, but it instead it somehow gets to the conclusion that &gt; The test shows that the move semantics is pure syntax candy and a machine does not care at all. Um. No. 
i would say just read a modern book like "effective modern c++" and write code! thats just the best way, the more you practice the more you learn about it. write stuff, coding challenges, personal projects, game clones, whatever. just use it. you will have doubts about stuff, that will force you to google about them, you will learn about best practices, language features, STL, etc about modern c++ theres no quick way.. just practice its my advice.
You should ask this at r/cpp_questions. Try making something (clone a simple app, create a useful tool for you, ...), during the process of coding it, you'll probably find places where the question "Could this be implemented in a different way?" appears. Research how you could do it differently and what are the trade-offs.
Doesn't hurt to start at the very beginning in many cases, since that's the foundation for your future skills. Personally I'd take a look at [this list over C++ books](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list), and go from there. I read the basics several times, and it really does help further learning. Apart from that I would say, just start making programs, and keep making them, no matter how silly, just do it. Since reading alone won't get you very far.
Pro tip by the time you ‚Äúmaster‚Äù c++ you‚Äôll realize how much you haven‚Äôt mastered c++. Strive for realistic mastery! Things changes frequently in the tech world. So there‚Äôs always something new and more to learn. 
&gt; If your "final product" is not a library (executable), then without a utility library your only option for linking unit tests is to list the needed object files manually. Build system can take care of this, right?
According to their own documentation (https://msdn.microsoft.com/en-us/library/ee410601(v=vs.100).aspx), the deleter doesn't need any space if it is stateless since Visual studio 2010. I don't know how they did it back then, but one solution could e.g. be partial specialization, or just the equivalent of a std::conditional.
What I really like to do, is go to something like en.cppreference.com and just stroll a bit around on the site. Have a look at everything marked as C++11/14/17 that pikes your interest. Or [this list](https://github.com/AnthonyCalandra/modern-cpp-features). The target is not to know these list by heart, but just get a rough overview of the features. And then start code. Anything. And at some point you'll likely think, hey that one thing from that one list may be helpful, what was it again. And then you google that feature and read it again, more in detail.
At work for [driving simulators](http://ac-m.pl/en/products/simulators/mobile-drive-simulator) (training and improving of the driving skills for truck and bus drivers), at home for gamedev, lately for my pet project for [logic simulator](https://github.com/aljen/spaghetti)
I won't be attending CppCon but I'm interested in the powershell scripts for working with vcxproj, is there a link available or would it be a spoiler?
Soon... stay tuned :) PowerShell scripts and Visual Studio extension will be available next week, after the session. I'll post links here.
Except that they've written a compile plugging that enforces it at compile time: ../../house/bridgewise/bridgewise_tools_main.cc:135:5: error: [chromium-style] auto variable type must not deduce to a raw pointer type. auto command_line = base::CommandLine::ForCurrentProcess(); ^~~~ auto* It is great and I use it daily. (And yes, this is a production project that has nothing to do with chromium)
Yes, the Effective C++ series are really good. You can find quite a few talks on youtube. Check out Bjarne, **S**tephan **T**. **L**avavej an **STL** developer :-) and Herb Sutter to start with.
Won't be at the conference, but looking forward to watching the recording and checking out your open sourced scripts.
I meant more in context of the discussion of having garbage collection by default in C++. If I had to make a choice between unique or shared as the default smart pointer, it would be the shared pointer because it has a copy constructor.
This is still a bigger problem than it should be -- we're still paying for 70's compilation worldview. When modules are standardized I think you'll find C++ equivalents to `npm` and `pip` come flying out of the woodwork.
Well, no. If you were starting from scratch, the default would be a unique_ptr equivalent, because by far the most common use case is unique ownership. Presence or otherwise of a copy constructor is utterly irrelevant to the argument. 
Write code. Write bugs. De-bugs. Profit...
If you are a node.js developer, or interested in leveraging your web developer skills as part of a real world project, you might consider learning to write node.js extensions. Node itself is written in a combination of js and cpp, and extensions can be written in cpp: https://nodejs.org/api/addons.html#addons_c_addons https://nodejs.org/api/addons.html#addons_n_api 
I'll just re-create ssh for the Windows console. See you in 5 years.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/72050c/best_way_to_master_c_in_2017/dnfennx/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
emacs, bash, gdb. gnu make. sometimes cmake. if i'm trying to debug something *really*, *really* hairy, valgrind. valgrind doesn't find the bug but if there's something deeply wrong in the force valgrind will find *something*, and chasing down that often points at the real problem. qt's great, as others have said. i'm a fan. most of the time I don't write GUIs though. perf to profile, though i'm not as strong at it as I should be. looking for ways to get better.
you speak truth
Off topic but thanks for reminding me CppCon is starting today :D
Welcome to r/cpp where objective facts get downvoted.
Yours is a very specialized definition of a monoid (I.e a monoid in the category of sets, with Cartesian product as the tensor). Learn about monoidal categories to see the concept in it's full generality. It turns out that all models of computation are just monoids in some monoidal category.
yes, this subreddit is also involved with ISO9001 quality management standards so I see how confusing I am...
This is great, i made some scripts on my own, but no visual studio integration yet, i am curious how they managed to get all compile arguments from within visual studio. The only way i know to do it correctly is parsing compiler log files, but that is quite hackish. Without that you need quite some magic to parse property sheets, the visual studio extension api is hard there.
I've been using this: https://www.sourcetrail.com/blog/export_clang_compilation_database_from_visual_studio_solution/ Had to delete an extra comma from the end of the file to get it to parse with run-clang-tidy.py, but it works. 
Thanks, you refreshed my memory why i didn't use the visual studio extension api. We apparently put the propertysheet information in our vcxproj in a non-standard format which causes the visual studio extension api not to pick them up, but visual studio itself does recognize them.. Seems to be time to change all projects to a standard style.
Right, in PathEngine we have a custom build system that takes care of figuring out exactly which object files need to be included in the link for any given project, which is particularly nice for unit testing.
&gt; One important difference is that an object file is only "picked" from a static library if it is actually needed (that is, it satisfies a previously unresolved symbol) unless you link the library in the whole-archive mode. You're right, and I should update the article with a note about this detail. I see this behaviour as something that *can* make it tricky to bundle object files together, in some situations, but not as useful information hiding, and I don't think it really changes the point of the article.
Looking forward to this. Sadly will have to wait for the video, or (hint) early access to the slides :) Thanks for sharing your experiences
I was hit by almost the same thing yesterday, trying to write a loop to iterate over a vector and mutate the data in it, doing `for (auto i : some_vector)` and wondering why the data didn't seem to chance, until the obvious hit me in the face. Now, I don't blame C++ for this really, the explicitness is there for a reason as many other commenters have already pointed out, and being explicit is one of the reasons why I love C++. That said, does anyone actually ever iterate over copies, especially if the code changes the data, since that seems kind of moot? I can't imagine iterating over copies being more performant than references if the data is considerably larger than a common POD type, and even then the performance difference shouldn't be very noticeable...? The only thing I can really come up with is testing some operation on the data, as in "a preview" to see if it would produce sensible output without altering the data. Would having a compiler issue a warning if you edit a copy of data in a container through a for-loop make sense or would it trigger annoying false positives?
I don't use it awfully often, but it sure beats trying to figure out how to correctly write out your foo-type iterator for your bar-type container containing qux-type elements. Generally when anything template-y or container-y is involved typenames get ugly quick while the underlying interface for all of them is mostly the same. I don't give a crap what iterator it is as long as it iterates.
I **really** prefer references to be explicit because of lifetime handling. Lifetime is a **huge** point in C++.
I love this book, he rambles for good reasion.. 
It's not the compiler, but clang-tidy has a check for precisely this issue: https://clang.llvm.org/extra/clang-tidy/checks/performance-for-range-copy.html
Interesting, can you elaborate on how this is done? To me it sounds this would require replicate the linker's functionality by checking which symbols are undefined then checking which object files can satisfy them.
~~Well, not precisely that issues, as:~~ &gt; Finds C++11 for ranges where the loop variable is copied in each iteration but **it would suffice to obtain it by const reference**. ~~The problem is, in my use case using a const reference is not an option, since the data is going to be edited, and thus can't be const. Specifically, I'd want some sort of warning about edits on copied data instead of the originals, since that can easily create obscure bugs, as it looks like you're editing the data but in reality all your edits are discarded with the copies. Still, thanks for the recommendation.~~ No, actually, the &gt; WarnOnAllAutoCopies &gt;When non-zero, warns on any use of auto as the type of the range-based for loop variable. Default is 0. setting would catch that. Thanks!
Gotcha. It is worth looking into how to add checks to clang-tidy, as it might not be too difficult to achieve what you need with the check I linked to as a starting point. Actually adding a new check into the build is straightforward. I think that sounds like something that would be really useful in general.
I made a tool to scan all CU's with Clang-tidy, Clang static analyzer, cppcheck and lizard based on clang cdb output and separate batch file to scan the same codebase with coverity. Jenkins Jobs to provide daily feedback and cli tool with unified output for OS X and windows. Took about two weeks (coverity few weeks more due to old release with bugs). Not a single warning or bug fixed in 6 months unless I raised a jira issue. Quite a few logic issues, some minor leaks and shitton of constness &amp; missing copy/move operators. Also, every time new patch was made and Jenkins builds failed, it was always "ups, I forgot to update the tests" /bitter 
&gt; My auto point was var is less typing So... Instead of just using `#define var auto` in your own code, you propose adding a keyword to the language, breaking tons of legacy code. The amount of sense it makes hurts my head a little at the moment.
Just add var as the standard. I didn't say auto has to be removed nor should it be obviously.
This sounds incredibly interesting to me. We have basically the same stats for our codebase (up to ~15 years old, over 2m loc, actively developed with regular releases) and also rely on the win api in quite a few places. We are about to switch to vs2017 (finally). This sounds like a dream, so I seriously can't wait for the video to be up (as I sadly can't attend directly), and the materials of course. Thanks so much for the heads up and for giving the actual talk!
I gotta say, the emails from Codacy on each commit definitely gets our devs‚Äô attention. Nobody wants to be the one that made the graph go up
MSVC don't implement two phase name lookup yet.
I know, but hard to put disclaimer in title :) And IIRC they made some progress, so hopefully soon it will be available in VS. 
Yeah! Looking back at the state of MSVC in 2013, I would never believe that one day they would come close to finish SFINAE and two phase name lookup. Kudos to the msvc team for that! Even if they are close to supporting those features, it's still a pain supporting library with msvc support. I have a library that rely heavily on template, and there's always *that* part where you need to test on msvc before releasing, and error messages are still not that clear. Things are doing much better in MSVC 2017 however! But I still have to support older versions :(
0. This seems a bit off topic 1. Initialize your variables
No init for `vArraySizes`. (Also inefficient multiple retrievals of `polys[i]-&gt;Triangles.size()`, as a separate issue.)
Your error is not using modern c++. auto vArraySizes = 0; 
And not using the updated for loop.
It does now, [at least partially](https://www.reddit.com/r/cpp/comments/6zjub9/msvc_now_has_partial_twophase_name_lookup/). With `/permissive-` on, this code fails to compile with current MSVC (v19.12.25719). (The error spew is too long to paste here.) EDIT: MSVC errors [here](https://gist.github.com/anonymous/46cff7c5fe68ee329b1c5dffe49b3514)
I had a bunch of static asserts in my code that never fired and then they started firing when I tried to use clang/gcc
3\. Possible value truncation and comparison between signed and unsigned types. Better hope `polys.size() &lt;= INT_MAX`...
We also don‚Äôt know what polys *is*.
Any sufficiently modern compiler will only do one access.
Right; but chances are good that `size()` doesn't return `int`. :-]
I disagree on this point. Size should never be negative so it doesn‚Äôt make sense that literal deduction should make it an int. 
It's quite likely you'd overflow in `vArraySizes` before having to worry about `i`, since assuming no less than one triangle per poly, that summation eats up at least 3 or 4 more bits.
Linkage requirements for each object file are derived from include relationships between source files. So for example, if foo.cpp includes bar.h, the build system considers that anything linking to foo.obj will also require bar.obj included in the link. (And then the same rule is applied recursively, if bar.h or bar.cpp include other headers.) The code has to be well behaved with respect to this system, and not do any funny business, but that is a good thing anyway, I think. 
Using unsigned integers to represent size/indices turned out to be a bad idea. Most of the time you're doing arithmetic operations with size and indices. It easily becomes a mess of implicit casts from unsigned to signed (compilers help by providing warning flags). Every time I do arithmetic, I cast these unsigned types to signed, then proceed with the operations (code now contains visual noise). So why have them be unsigned when you could just go with signed integers? Size never being negative isn't that of a strong argument when doing arithmetic is almost always the case.
So use `0u` instead.
Sorry. Maybe I‚Äôm biased from working on simulation code with over 2^31-1 elements in data arrays. Signed long (64-bit) is usually what we use. But we NEVER use int.
As long as `size()` is const and has no side-effects, and there's no `operator-&gt;()` or `operator()` doing anything crazy, etc..
Efficiency aside, it's still repetition of logic, which is reason enough to pull it into a variable, because this more closely expresses your intent. It makes it explicit that the duplication isn't just a copy/paste error. 
Oh, I agree with repetition of logic, but labeling it as inefficient for the primary reason doesn't make sense.
A std::vector of pointers to polygons as defined by the .obj file I previously read in. There's usually one per material in the model, so it's reasonable to assume they're never going to reach INT_MAX.
Performance isn't really important at this point in the code, and if that changes, this is unlikely to be the point where it could be improved. Those lines are unlikely to ever run more than a few dozen times.
Using an iterator? I didn't bother this time so that I wouldn't have to use (**it). Unless there's some easier syntax for accessing a member of an object that needs to be dereferenced twice first
What advantage does auto give you here?
&gt;Efficiency aside
 int vArraySizes = 0; int uvArraySize = 0; for (const auto&amp; poly : polys) { auto triangleCount = poly-&gt;Triangles.size(); vArraySizes += triangleCount * 9; uvArraySize += triangleCount * 6; } More readable and even generates *slightly* better assembly. What's not to like? 
 for (const auto&amp; poly : polys) I've never seen this before. That's useful to know, thanks
It makes it impossible to leave a variable uninitialised, because to do so would be to not write an expression from which 'auto' can deduce a type. This is one of the biggest advantages of the "almost always auto" style - this entire class of bugs disappears. 
Oh, OK, that makes sense. Doesn't it also create some cases where it's harder to infer the intended type just from reading the code though?
i.e. `auto x;` is ill formed. 
Certainly, and it becomes a matter of taste and degree in some cases, but for simple variables like this there's really not much argument,except that the auto form is slightly more verbose. But I think the added safety is well worth it. I would also add that it is a common coding standard rule to disallow multiple variable declarations on one line, not just because of the potential for bugs like this, but just because it is needlessly difficult to read compared to the alternative.
The bad idea is a lack of separation of concerns in the integer types with respect to their arithmetic and domain: - `int` (arithmetic: ub on overflow, domain: ~~natural~~ integers) - `unsiged` (arithmetic: modulo, domain: positive natural numbers and zero). Many other languages that do this in a saner way (e.g. by making the domain and arithmetic orthogonal to each other) do not have any issues with `unsigned` integers. 
Just use an iterator. edit: I misunderstood the argument, sorry.
Natural numbers (N) are positive by definition. You probably meant integer numbers (Z). 
Indeed. I guess is time to sleep.
What do you mean, just use an iterator? 
Docker is extremely useful for this type of stuff. When you're stuck running code on server using RHEL or CentOS, Docker can be the key piece of the puzzle that lets you sandbox newer versions of the compiler or 3rd party libraries.
**Company:** [Cadence Design Systems](https://www.cadence.com/) **Type:** Full time **Description:** Join the Virtuoso R&amp;D team and build the tools that circuit designers will use to build the next generation of smartphones, self-driving cars and IoT devices. **Location:** Livingston, Scotland, UK **Remote:** No **Visa Sponsorship:** Yes **Technologies:** required: C++, C; optional: Qt, Lisp **Contact:** PM or [apply on careers page](https://www.cadence.com/content/cadence-www/global/en_US/home/company/careers.html)
By using an iterator, you don't repeat `poly[i]`, nor do you explicitly declare a third variable to reference each element (which is noisy). Or are you talking about the value returned by `size()`? If that's the case, then sorry, I misinterpreted your argument.
Oh, yes, I meant the entire repeated fragment: `polys[i]-&gt;Triangles.size()`
I'm not saying there's not a place for a fixed-size string type -- there certainly is a place for that. In particular the ability for the user to ask for a particular fixed size they need can be really useful. And not needing to store capacity can save a pointer worth of space. But I do have a few nitpicks with this blog post... &gt; Faster string operations: string construction and destruction are much faster since no memory allocation takes place. I'm interested in data backing up this statement. If you enter the "no memory allocation takes place" path of string's SSO, it should be similar. &gt; Cache-friendly: it stays close to your other class members, your cache likes it. That's also true for the normal SSO. And in normal program use you're likely to need to leave more space than you actually need in these strings, which means your cache does not like it. &gt; Other operations are also slightly faster: as its buffer does not grow, inplace_string benefits from a simpler code with less branches. There are 2 improvements that can be made here: * a fixed_string can always stay in "small" mode so no branches need be taken to decide between small and large representations * a fixed_string need not store the capacity. The cost of the "should I grow now" branch is insignificant; it is one branch per mutating operation call, and that 1 branch is still needed in a fixed_string to properly detect / explode on overflow. Geometric growth means that the branch is predicted correctly not taken most of the time for basic_string. &gt; You can find the benchmark on my github. I searched for MetadataTree and didn't find anything. I'm curious as to the actual benchmark code because 3ns per iteration looks like the compiler optimizer defeated the benchmark. To be clear, these things are mostly nitpicks. There are certainly applications where a fixed_string type would make sense; indeed supporting such types is a big part of why string_view is now standard.
Actually every compiler will fail on this one. The only way you will see a single load of poly[i] is if the member function .size() is fully visible (any doesn't do anything weird itself) in the same translation unit as this code.
Why would someone use MSVC if they can use clang instead? MSVC has giant optimization bugs where turning on any optimizations can cause crashing. No, this isn't the difference between a debug build using the debug heap and the release build (release w/ optimizations vs release w/ no optimizations is what breaks). It is a known issue with certain versions of Eigen. 
Or how about that you have to decide on "reference type" or "value type" when you're writing the class/struct. In C++ a class can be either, depending on how you use it. 
Are you using 'new' for every polygon? 
`-&gt;` is already used for lambdas - for specifying a non-void return type. 
That was the whole idea: share our experience with this process and also share the tools we built to help us, so that others who want to follow the same path don't need to start from scratch.
I hope I won't disappoint :)
 const auto sum = std::accumulate(polys.begin(), polys.end(), 0, [](int sum, const auto&amp; poly) { return sum + poly-&gt;Triangles.size(); }); const auto vArraySizes = sum * 9; const auto uvArraySize = sum * 6; 
Cool. The idea was that we wanted a lightweight method of working directly with our *.vcxproj files, without the need to generate a clang compilation database, or roundtrip configs.
&gt; That was the whole idea: share our experience with this process and also share the tools we built to help us, so that others who want to follow the same path don't need to start from scratch. 
1. Create class with overloaded operator+, operator= and make it so the operator+ returns something other than 110. 2. Same deal, but make operator+ return your class and create global operator== taking your class and int, returning false.
Here's one way: struct evil { evil(int) {} evil(const evil &amp;) = default; evil &amp; operator=(const evil &amp;) = default; operator int() const { return 42; } }; If you pass two `evil &amp;`, or the same `evil &amp;` it will compile but clearly not do the arithmetic. In your code snippet, if `x` were `30` instead of `10`, then you could also break it by passing it two variables of type `signed char`, because it would cause overflow. But if the sum is only `110` it would be fine. Another way might be to use a bitfield or something? Because then you can cause overflow using smaller numbers. You might be able to use a `bool` for this also, but I'm not sure if it would compile. If it did compile I think it would be like, `bool x = 10` becomes `true`, `bool y = 100` becomes `true`, `x+y` becomes `1+1` because of `bool-&gt;int` conversion, and the sum is `2` not `110`. I guess the other obvious way to do this is to pass two references to the same `int`, that will clearly break everything.
Alright I actually got one answer just now: int main(int argc, char **argv) { int val[1] = { 0 }; std::cout &lt;&lt; std::boolalpha; int *ptr = (int*)val; int b = 100; int&amp; ref = (int&amp;)(val, b); bool ret = foo&lt;int&gt;(ref, b); std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; ret &lt;&lt; "\n"; } Should print false.
 int main() { bool a = false, b = false; std::cout &lt;&lt; foo&lt;bool&gt;(a, b); int z = 0; std::cout &lt;&lt; foo&lt;int&gt;(z, z); return 0; } edit: just realized you're also going to have to throw a `std::boolalpha` in there.
Love it! Can't wait to see :) 
 int a; foo(a,a); Is simpler. And what's the point (hah!) of ptr? And that mess with the comma operator?
hahaha idk man I am drunk and just thought of this 24+ month old interview question again tonight. 
Yeah
&gt; STL compliant, can be used as a full replacement of C++17's `std::string`. This is a very useful type in its own right, but I don't think you can claim a *full replacement* of `std::string`. They solve different problems - `std::string` needs to hold an arbitrarily long sequence of `chars`, `inplace_string&lt;N&gt;` can only hold `N` of them. That's not really the same thing. When I read that, I thought that `inplace_string&lt;N&gt;` was basically `std::string` with a user-specified SSO buffer size. Had to look through the implementation to verify that it's indeed not. So, somewhat misleading claim. 
Well the obvious way is: int i; assert(foo(i, i) == false); Aliasing for the ~~win~~ loss! 
That is insanely slow for many reasons, but mostly because heap allocation a freeing takes time. Build your data structures to mimick the structure of the .obj format so you can use arrays of floats. 
I convert it to a more useful format once the file is parsed
That doesn't really make any sense with necessitating heap allocation for every polygon, but you can do whatever you want with that information. 
Visual Studio is the best C++ IDE on the planet, by far IMAO. Many codebases are stuck on VS for plenty of reasons.
I'm pretty sure that if it's declared as `const` it will remove the second call.
Possibly an issue on your end? Nothing seems unusual about the speed of the new site.
Any decent compiler will give you a warning for initialized variables though. Especially in such a trivial case like this.
This was about compilers, not IDEs, and the msvc 2017 compiler has serious bugs in it. As for the IDE, that may have been true before VS 2017. Now it is a train wreck of nodejs servers and sql services. It slows to a crawl even with small projects on big computers. 
*No*. That's a common misconception in C++ though. `const` can be cast away, so a compiler can never assume that `const` means _it won't change_.
&gt; EDIT: MSVC errors here u/AndrewPardoe will make sure VSNext has clang like error quality... ;) But joking aside I guess it would be too hard for VS to get the clang level errors since due to my limited understanding of compilers clang has to do some advanced voodoo of "looking ahead" or maybe update the errors as it moves through source... Could be wrong though, IDK a lot about compilers.
I tried what I thought was the obvious way, using two floats or doubles, and that they would lose enough precision for (x + y == 110) to be false, but that wasn't the case.
But you shouldn't cast it away, and casting it away will usually result in undefined behaviour, meaning your compiler can do whatever it wants. I'm assuming in this case, both the size function and the array itself are `const`.
Are the property files that hard to read? As long as you're not trying to use regex, you should be fine.
Speaking of misconceptions -- regardless of casting, it's important that you understand the meaning of **const**. **const** does *not* mean "this won't change" **const** means "*you*^1 can't change it" (of course, when you cast away **const** -- which is certainly almost never the right thing to do -- it's no longer **const**) Most people coming from an embedded background have encountered "**const volatile**" values (e.g. peripheral status registers). This is perplexing if you don't understand what **const** means. [1] "you" = "your code that is seeing this object as const"
&gt; and that 1 branch is still needed in a fixed_string to properly detect / explode on overflow. I mean, maybe you want that branch in debug build for safety, but I don't see why it is necessarily in release build. It depends on your project I guess. If the whole point is that you assume the user doesn't need more than the capacity, then why not just make it UB if you exceed the capacity, and skip that branch, in release. --------- Also, even if the string doesn't decide to grow, you still have an extra branch, even on non-mutating operations, right? Since you have to check, am I in small mode or big mode first, so that I can find where the character is. Maybe there are some really clever tricks to avoid that branch when making an SSO `std::string`, but if so I don't know them. Right, since an SSO string in small mode doesn't actually contain a pointer to it's own memory, it wants to use the space of all of the pointers to store characters. So I think `operator[](int idx) const` should look differently for big mode and small mode: 1. In big mode: "interpret (bytes of) a particular region of the `std::string` object as a `char *`, add `idx` and dereference it" 2. In small mode "Interpret `this` as a `char *`, add `magic_number`, add `idx` and dereference it (for some correct offset value `magic_number`) I don't see how you can avoid branching for these two cases -- you think they can be reconciled into one routine somehow without `if` or ternary operator? That branch is definitely avoided for the in-place string. Idk, I never actually read the source of the libc++ or any other major SSO `std::string` implementation. ---- Edit: Looking in libc++ implementation: In libc++ `std::string`, the `operator[](int) const` calls member function `data()`, https://github.com/llvm-mirror/libcxx/blob/master/include/string#L2949 which calls private member `__get_pointer()`. https://github.com/llvm-mirror/libcxx/blob/master/include/string#L1129 And `__get_pointer()` contains a branch based on whether we are short or long: https://github.com/llvm-mirror/libcxx/blob/master/include/string#L1311 I think that branch gets avoided when we can assume we always short. (Maybe the MSVC string somehow doesn't contain a similar branch, due to some trickery, idk.) ---- Edit: Looking in libstdc++ implemenation: In libstdc++ `std::string` it looks like `operator[](int) const` doesn't have this branch -- it always stores a full pointer `char *` to the string, even when it's in small mode. Consequently it has a smaller SSO buffer, afaict: https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.h#L1030 https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.h#L3295 https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.h#L155 So, that's interesting, I didn't realize libc++ and libstdc++ differed in this way.
&gt; &gt; Cache-friendly: it stays close to your other class members, your cache likes it. &gt; That's also true for the normal SSO. It's half the size per-object vs. the normal SSO; if we're talking about cache-friendliness, compactness is surely a virtue.
`static_any` looks nice and may save me from having to write my own equivalent class! I have a problem with your implementation though. You are using a `std::array&lt;char, N&gt;` as storage for the `N`-sized object. But `std::array` may not have the same alignment as an object that you're storing. In general, calling placement-new on an incorrectly-aligned address [is undefined behavior](https://stackoverflow.com/questions/11781724/do-i-really-have-to-worry-about-alignment-when-using-placement-new-operator). (Intel CPUs can do unaligned access with a performance penalty, and in practice the function pointer that precedes the storage in the `static_any` struct may turn out to correctly align the array anyway.) You can fix this by using [std::aligned_storage](http://en.cppreference.com/w/cpp/types/aligned_storage) as your backing storage, which accomplishes most of the boilerplate work of finding the appropriate offset. It defaults to the most-stringent alignment, which is what you need for an `any` class. I'd be happy to open a ticket on GitHub if you want; I'll probably be making this change for my own use and I'd be perfectly happy (prefer, even) to help implement it upstream.
&gt; As for the IDE, that may have been true before VS 2017. Now it is a train wreck of nodejs servers and sql services. It slows to a crawl even with small projects on big computers. If you tell me how to switch to Clang for Win development without loosing intelisense, and debuging capabilities of VS I will switch... For slowness of VS I can not confirm, but compiler is buggy, I hit one anoying bug that is hard to reproduce: incremental build does not see modified file so after build my source is out of date and it is quite irritating(stop debugging-&gt; clean build -&gt;start debugging)
Or: int size=0; for(auto&amp;&amp;poly:polys) size+=poly-&gt;Triangles.size(); int vArraySizes=size*9; int uvArraySize=size*6;
const doesn't mean that a side effect of a const call isn't a mutation of the underlying data. It is perfectly valid to access a global (non const) pointer to the same object and mutate it during a const call (since the only thing const means is you won't modify any value that's not marked as mutable via the const pointer). It's a dirty and silly thing to do but since the standard allows for it compilers can't assume you don't do it (unless they can see all the code [aka it's all in the same compilation unit]).
To be fair, it is a noop in hardware but not on the abstract machine. And if the type has a "make from raw memory" ctor which does nothing but ... make from raw memory, we can implement a similar function (that optimizes to noop and allows inplace construction) without the type being pod. Just replace the copy-back and new with "new from raw memory". Possibly we should have a concept in the standard that reflects such a type and allows easy extension by user types willing to make that guarantee. 
I see what you mean now, that's so evil I hadn't though of it. Do you think there's a way to fix the standard to have `const` mean "no side effects that will ever affect something outside the class"?
I doubt the meaning of const will every since it would break a ton of old code. People have talked about adding 'pure' as a keyword to the language represent a function that has no side effects but I don't know it's current status. If you are interested in it here is one of the papers for the standard committee. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0078r0.pdf
&gt; you have to check, am I in small mode or big mode first Yes, that's the "* a fixed_string can always stay in "small" mode so no branches need be taken to decide between small and large representations" part of my comment. &gt; So, that's interesting, I didn't realize libc++ and libstdc++ differed in this way. Our implementation is yet a third different way, something like: struct { union { char * ptr; // selected if capacity != BUF_SIZE char buff[BUF_SIZE]; // selected if capacity == BUF_SIZE }; size_t size; size_t capacity; }; So we have a smaller SSO capacity and a branch to get at ptr, no branches for size or capacity, move is just a memcpy + memset (not true for libstdc++ since they have container-internal pointers). We're considering moving to a libc++-like representation in the medium term. 
It's the exact same size per-object vs. libc++'s SSO.
`std::array&lt;char, 4&gt;` has an alignment of 1. If you use it to store an int with an alignment of 4 you're going to have a bad time.
Ah, I misread the whole situation, thinking of arrays of `T`. You're right.
windows only -_-
Cool, thanks!
float can represent exact integers up to 2^24, that's 16777216. For double it's 2^53, thats 9007199254740992.
That's assuming it actually is irrelevant. Changing private members is not irrelevant; even aside from size that everyone mentions, if you for instance have member functions that are getting inlined, those functions need to know exactly at which offsets to find private data members. The best you can say is that re-parsing could be avoided, but codegen, particularly with any level of optimization at all, will certain requirely recompilation even for private member changes and there's just no way a truly fast statically compiled language can get around that.
 #define return return false&amp;&amp;
I know this is generally of less interest than the data members aspect, but one thing worth knowing is that if you want to avoid recompilation for changing private functions, you can get this without pimpl. The idea is simple: you just declare a friend class in your class. // .h class Foo { friend struct Bar; int m_x = 5; public: void blub(); }; Then, in the .cpp, you simply implement what would normally be any private methods of Foo, as instead public static methods of Bar, that take a Foo&amp; as their first argument. You can then call these from public methods of Foo: // .cpp struct Bar { static void blub_impl(Foo&amp; f) { std::cerr &lt;&lt; f.m_x; } }; void Foo::blub() { Bar::blub_impl(*this); } Probably most people know that you could just write free functions in the .cpp file, but such functions of course don't have access to private members of Foo, so you have to unpack any data as it were before you access them. This gives you the same access as private member functions or friends, and you don't have to commit to anything in the .h.
For any reader that is wondering, the LLVM code base contains `small_vector` and `small_string`, which are containers with user-specified static buffer size, but that can switch to dynamic memory if needed.
Why do you store capacity in small mode? The size_t and the char * are the same size (on your platform), but in small mode the capacity is implicit anyway. The char * gets used a lot (much more than capacity, I imagine) so having to calculate that each time is hardly ideal. The capacity in large mode could easily be stored with the allocated buffer, and retrieved from there when needed, which should only happen when growing the buffer - also a frequent operation, but not nearly as frequent as accessing the string contents. 
Shouldn't that have generated a warning? `-Wall` appears to produce a few messages for me locally on that fragment on both gcc and clang.
Hey, you're totally right, this is an important point - I had that in my TODO list for a long time! I planned to do some cleanup in static_any anyway, so I will do this change at the same time. It should be fixed in a few days :) 
As the correctness of our compiler improves, the quality of our error messages improves as well. That part comes for free. We've also been working on improving diagnostics overall--above and beyond what a better parser can give us. One problem is that it's hard to compare diagnostics across compilers. But we know we have work to do, and we're doing it.
It's true that it would break some things, so a new keyword might be better. It's on a whole different level than `auto` after all. Now we have `constexpr`, so maybe we could extend it (I'm pretty certain `constexpr` cannot have side effects in any way).
Did you even look at what this tool does? Parsing executables + debug info, runtime instrumentation and injecting yourself into a running process are all things that are not easy to port to other operating systems
I look forward to build systems of the future. So far the far reaching dispicible binaries like Visual Studio's versions of eld are shrinkwrapped VMs most of the time. It's horrible.
&gt; A portable and fast approach is to instrument your executables while assembling them. That's not an option on Windows, hence the utility of a tool like this.
 Interesting-- it appears to have some features beyond what the VS profiler has, such as showing live frame performance. Going to try it out.
The tool looks quite interesting. However, I wasn't able to selected the functions from the list - the select options simply wasn't available, only "hook/unhook/visualize", none of which did the same thing as the video demoing the profiler.
AFAIK the useful sanitizers don't work on Windows for either GCC or Clang; and MSVC has only basic stack guards.
For Linux a nice analyzer tool is UFtrace https://github.com/namhyung/uftrace &gt;The uftrace tool is to trace and analyze execution of a program written in C/C++. It was heavily inspired by the ftrace framework of the Linux kernel (especially function graph tracer) and supports userspace programs. It supports various kind of commands and filters to help analysis of the program execution and performance.
ASan/MSan are nice, but there is still a place for things like Valgrind, so the central premise of your post is completely flawed. Also ASan is rather OS specific (because it needs runtime hooks) and don't get me started on MSan (I sure hope you are willing to instrument the standard library, runtime and all libraries you are using, are enjoy having FPs). I will readily admit that I am not sure if XRay is OS-specific, but it likely is. 
 Then I'm forced to recompile my entire program just to run a profile session. No thanks.
Good point, the phrasing is bad - I meant that the interface is the same. Thanks for pointing that out!
Neato frito. The code is very neat, clean, and super professional. Very easy to read. I'm curious to give this a try. I like the fact that it has a GUI. Thanks for the contribution!
To be fair, I was looking for the semi-colon at the end of the line with the for statement, but you meant the other oldest bug. ;)
Note that I am describing what our implementation currently does; this layout was designed at least a decade ago; we probably wouldn't go with this layout today. &gt; Why do you store capacity in small mode? Capacity is used as the marker for whether or not the string is in small mode. We use capacity == small buffer size. libstdc++ uses data == &amp;buffer[0]. libc++ (and FBstring) use "bit twiddling hacks" (the good kind of hacks, not the bubblegum and duct tape kind). &gt; The size_t and the char * are the same size (on your platform), but in small mode the capacity is implicit anyway. The char * gets used a lot (much more than capacity, I imagine) so having to calculate that each time is hardly ideal. Yes, I expect that is why libstdc++ stores the buffer and capacity in the same space instead of the buffer and large data pointer in the same space. The downside of that is that you need a branch for moves, since there's a container-internal pointer to fix up in small mode. That's also why we're considering replacing our layout with one much like libc++ in the medium term -- we're already paying for the branch to get to the data pointer, we might as well get a bigger SSO out of the deal. &gt; The capacity in large mode could easily be stored with the allocated buffer Well, not with this implementation, since we need the capacity to decide whether or not we can dereference the pointer. If you want a decent SSO, doing that isn't a win anyway (for any representation), since you probably want the string to be at least 3 pointers for SSO space.
My exact reaction each ime I see a new awesome tool that only runs on linux (hopefully only temporarily) :)
(It should also be noted that this representation thing is the least of the perf we were leaving on the floor until recently: https://twitter.com/MalwareMinigun/status/814196564507799552 )
Functions marked constexpr can have side effects when they are executed during runtime.
every variable goes into its own line
It depends what you prefer to do, wait for a compiler warning and act on it, or adopt a style which means you never waste time having to do so, and have security that a class of bugs is never going to appear in your codebase. If everyone understands and adopts the latter, and not just this example, effort is saved across the board in reading and reviewing code. 
Whether or not `size()` is const is irrelevant as const in this case doesn't have any guaranties useful to the compiler and can be removed by `const_cast`.
at this moment, both clang and gcc compilation fails. I am working on this.
nop...
I think that giving an error if only some values are initialized should be in the standard, because there a so few cases where it's actually a conscious choice (and you might as well make 2 clearly separate declarations then) that it's 99% of the time a big ugly bug. I do think that using auto as much as possible is good, not really because of this, but because your code is less likely to break when you change the system (like going from 32 to 64 bits, a int used to store some stuff might do shit). I only use explicit sizes when I'm reading from a binary file or handle images and the like.
Do you have an example for this? You can't use non constexpr functions or static variables. Or did they change the standard again?
If it makes sense for the project you could theoretically separate it into a few libraries so the penalty of rebuilding would only affect the logical units where code was changed. But that's probably more work than it's worth, I'm guessing.
&gt; If you tell me how to switch to Clang for Win development without loosing intelisense, and debuging capabilities of VS I will switch.. I hear you loud and clear. I'm in the same boat and trying to figure out that exact problem. The debugging in visual studio is no doubt very good, better than Qt Creator (though Creator was impressive last time I tried, just use cmake and not qmake!). Intellisense is also indispensable in my opinion, even as perpetually broken and detached from the actual compiler as it seems to be in VS.
&gt; Intellisense is also indispensable in my opinion, even as perpetually broken and detached from the actual compiler as it seems to be in VS. I think they have different compilers for backend and intellisense unfortunately... If you really care somebody here from MSFT can confirm. Also not to promote them too much but I used to use Visual Assist and last time I used it (4y ago :) ) it was even better than builtin Intellisense. 
&gt; If you really care somebody here from MSFT can confirm They do, I understand the reason, it just seems to get progressively worse and not better. I've heard good things about visual assist. I think when I used it before it was a little slow, though now in comparison it may be fast. 
&gt; The need to recompile translation units because an irrelevant implementation detail in a module changed But that's not an irrelevant implementation detail. If you have struct Foo { public: int foobigate(); private: int x; int y; }; in a module and you do this in another module: int main() { Foo f; return f.foobigate(); } the compiler *has* to allocate the size of two ints on the stack; there's no way this `main()` function can skip recompilation if you add another `int z;` at the end of `Foo` since three ints now have to be allocated. There's no going around this. Many other languages bypass this because they are doing the equivalent of `Foo* f = new Foo` instead; but modules in C++ will never "solve" this.
The [Chobo library](https://github.com/Chobolabs/chobo-shl/tree/master/include/chobo) also have useful containers in the same vein
C+=2! Made me laugh out loud! 
I haven't seen this mentioned yet, but our software compiles and links much faster on Linux than on Windows. We use gcc on both Linux and Windows, so maybe we would see different results on Windows if we use VS. However, with my personal projects, I've compiled using both VS and gcc using the same build system (cmake + ninja), and gcc was noticeably faster.
Awesome!
That tool is useless, you have to provide formating rules to it, which defeats the whole purpose of time saving. Especially when it will break.
The same can be achieved more elegantly with [Nix](https://nixos.org/nix/). Give it a try, it's great tech, but still rather obscure. nix-shell -p gcc7 --command make
The project contains hardcoded paths (eg. linker), but I could not reach that point as the compile stage has include path problems. (using VS 2015.3 and Qt 5.8, 64 bit release project) However, I quickly tried the binary, that looks promising :)
I wish some of this stuff was directly integrated into VS, particularly from the "capture" tab and the graphical, detailed view. MS, please listen! ;-) I know VS has a very rudimentary live-performance analysis too but it doesn't even come close to that (yet).
&gt; If you tell me how to switch to Clang for Win development without loosing intelisense, and debuging capabilities of VS I will switch... I spent the last month or so migrating out of VS into VSCode, wherein I can switch between MSVC, Clang, and MinGW painlessly. I use clangd for autocompletion in VSCode , and either MSVC or LLDB for integrated debugging (though I usually use Windbg regardless of IDE/compiler, not an integrated debugger). I haven't used this setup for long, but so far the combination of clangd's autocompletion + VSCode's editor has been extremely rewarding. EDIT: [Screenshot](https://i.imgur.com/vxgkqST.png) (libnonius code)
Sure: https://godbolt.org/g/RNx5Yp
Relevant: https://www.youtube.com/watch?v=wTmAJAk7WV4
I was thinking about writing the `std::accumulate` version and when we finally get ranges I might actually start using it for everything, but as it is right now it's way too verbose for *simple* tasks. Let's compare the C++ version with Rust: C++: const auto sum = std::accumulate( polys.begin(), polys.end(), 0, [](int sum, const auto&amp; poly) { return sum + poly-&gt;Triangles.size(); }); Rust 1: let sum: usize = polys.iter() .map(|poly| poly.triangles.len()) .sum(); Rust 2: let sum2 = polys.iter() .fold(0, |sum, poly| sum + poly.triangles.len()); I find the Rust versions *much* more readable (especially the first one where I don't have to parse that the fold is actually doing a sum). As I said, my opinion will probably change if we get abbreviated lambdas and/or ranges but right now `std::accumulate` is a bit too noisy for me compared to: int sum = 0; for (const auto&amp; poly : polys) { sum += poly-&gt;triangles.size(); }
FWIW, C++ with ranges-v3: const auto sum = ranges::accumulate( polys, 0, ranges::plus{}, [](const auto&amp; poly) -&gt; int { return poly-&gt;Triangles.size(); } ); // or auto poly_tri_count = [](const auto&amp; poly) -&gt; int { return poly-&gt;Triangles.size(); }; const auto sum = ranges::accumulate(polys, 0, ranges::plus{}, poly_tri_count); Format to taste; not too terrible, IMO. Personally, like Boost, I expect ranges-v3 to be available for pretty much any non-legacy codebase I'm working on.
Louis Dionne has created a [special library](https://github.com/ldionne/libawful) of several "awful" types - types that have some awkward properties, like not being copyable, or trapping on construction from non-expected things, etc. Also see how this library tests that some files should error on compilation using CMake: [here](https://github.com/ldionne/libawful/blob/659333af04f41af793d861d947411d3d336fea3a/CMakeLists.txt#L27) and [here](https://github.com/ldionne/libawful/blob/659333af04f41af793d861d947411d3d336fea3a/cmake/compile_fail.cmake)
If anyone is having trouble compiling, here's what I did: I needed to make a $(QTDIR) user macro, pointing to my "Qt\5.8\msvc2015_64" directory, in a new propsheet to get the the Qt stuff to resolve properly. The top level directory needs to be named "Orbit" based on how things are pathed. If you cloned this repo from github, it will be named "orbitprofiler", so you need to rename it. And then the hard coded linker includes to external libs need to be fixed. I just did a search/replace in OrbitQt.vcxproj to change "D:\git\Orbit" to my own Orbit src directory. Then I needed to build Orbit\external\glew-1.13.0\build\vc12\glew.sln in Release|x64 (opened solution, upgraded projects from VS2013 to VS2015). Then I needed to build Orbit\external\capstone\msvc\capstone.sln in Release|x64. Then it all compiled.
Yeah cross platform has gotten alot better, you can almost replace all of the windows.h stuff with the stdlibs and boost
By the way, is there anyone who already has a perforce precommit hook script to verify if no changes occur after formatting with clang-format? So far i could only find git scripts to do it.
MSVC debug CRT helps a great deal. But fair enough, debug only.
I like that last one.
 float x, y; foo(x, y); Perhaps?
I've done two internships using C++ (3 months + 6 months), but I only had a total of 4-6h in my whole scholarly on C++. I've learned it by my own. My current job is my first one. I was graduated last year in France. Since I've been hired, I've been working about 6 month on C++, and 6 months on scala (witch was new totally new for me). During the interview, the recruiter asked me some technical questions, and I said (it's real) that I love this langrage, and I'm able to give detailed example of stuff that I love (the most important feature of C++ is RAII for me). To be honest if you are a good programmer, learning a whole new language is something totally doable, and recruiters should know that. So even if you don't have past experience, you should show your motivation and will of learning witch is much more valuable than a 1 year experience.
&gt; most jobs I can apply to here in London go through recruiters who start ignoring me as soon as I mention that I don't have previous commercial experience in c++ I had no previous commercial experience in C++ either, but my current employer (Bloomberg) was very interested in my [open-source projects and libraries](https://github.com/SuperV1234) and my [conference talks](https://www.youtube.com/playlist?list=PLTEcWGdSiQelEQw64Z7EL2vk6LsKW_Ouj). I love C++ as an hobby and before getting a full-time job I spent many years just developing games, tools, and libraries for fun. Showing passion and expertise was enough to proceed to the interview phase, even without previous commercial experience. tl;dr: do C++ stuff 
Please, indent those code snippets.
The bootcamp involved javascript and some top principles, not c++. I have a M.Sc. in mathematics but no contribution to open source software in c++.
That certainly makes sense, but I was hoping to not have to wait to build a portfolio for years. But thanks for sharing your experience. 
Is this any good over Linux perf? What about cache misses? That's the thing I like to have numbers about.
If you're still interested in math, try software jobs that use those skills. There are way more C++ programmers than people with the level of mathematics skill you probably have. Use that to your advantage. My first gig was with a kind of research contractor. I didn't have any C++ experience going in, but I got the job based more on the content of the work, if that makes some sense.
What's the abstract?
Get tons and tons of background experience on personal projects: not only does this give you bragging points, but it works really well for sharpening your skills. The more diverse, the better, as this helps you explore C++'s *massive* featureset. Get experience using git, both with a GUI and without. Use CMakeLists and learn how to set it up for more complicated projects. Sharpen your skills when it comes to using Modern C++ stylings, but don't rely on it entirely: be able to justify why you should use this over older idioms. Try using the WSL or a separate ubuntu/linux install to get used to developing on that platform: you'll probably find it pleasant and easier than you expected. And as mentioned by /u/robin-m, it helps to talk about why you like the language. Don't be afraid to admit what you don't know: this is an important thing to do, and can help you become better if you're willing to reach out for help or find further resources. I say this all as someone who effectively dropped out of college (I was in for aero engineering) after being at an internship-turned-part time job for a year, at which point I was offered a full-time position (without a degree, gasp). My situation is mostly due to luck and the goodwill of others, but all the above helped me (I believe) inb4 coworker spots me here edit: background in mathematics can, as mentioned by /u/whatwasmyoldhandle, opened other opportunities. Maybe look into R&amp;D firms looking for programmers, or for scientific programming positions. They might not be C++ exclusive (might be more focused on python, but you can pick that up quickly), but that will help you by: 1. Giving you a job to sustain yourself with, so you can afford to do the whole "adulting" thing and 2. You can use your free time to develop your skills on personal projects. This is kinda what happened for me: I had more free time and less C++-focused programming at first at my internship, so I'd go home and just code until I had to sleep.
Hmm, how about clang with thin-lto and libc++? Is it possible?
But do you have _any_ experience in C++? If the answer is no, what attracts you to the language?
Nobody wants to run a slow, instrumented executable when they're not doing profiling.
At least on linux there is perf. Tools like that are lacking in Windows, which probably creates a market for Windows-only performance tools.
Definitely going to be looking at this. New task at work involves updating a 17 year old codebase that last worked for Mac OSX 6 to compile and run on all three major platforms, while adding some new features. The code is well written, but its all very C-style (as old C++ was) and really needs what clang-tidy offers to save me time and sanity. Being able to still use VS would help loads, since that has its own suite of useful tools.
The point is that it's easier to identify an uninitialized variable if they're all declared on their own respective lines. Someone may mistake the "= 0" as applying to both variables (if they're both declared on the same line), which is obviously incorrect, which is why OP ran into this bug in the first place.
Search for and apply to junior C++ jobs directly, not through recruiters. A maths background and C++ is an attractive combination, you just need to find the right position that will take a chance on an inexperienced dev. Recruiters aren't into taking chances, they want to send top candidates to interviews so they look good, and get their commission quickly and can work on the next position to fill. 
One way is to create a class with static constexpr variables of type bool that hold the value of the expression to be tested. Assume you have `static_assert(expr,"...")`. Create a class struct NeedsGoodName { static constexpr bool my_test = expr; }; // define NeedsGoodName::my_test somewhere Now yout static assert becomes `static_assert(NeedsGoodName::my_test, "...")` If `expr` depends on template parameters `NeedsGoodName` becomes a template and you can view `NeedsGoodName&lt;T1,...,T2&gt;::my_test` as the result of a function. This allows you to test also cases where `my_test` should be false in a normal unit test. This allows also a nicer way to compose more complicated tests because you can do several smaller computations in separate variables and the combine them with Boolean operations to the final result. It becomes nicer with C++1z because static constexpr variables are automatically inline variables and you do not have to put an extra definition in.
What is your area of mathematical expertise (are you a geometer, an applied mathematician, a pure mathematician, a statistician)? Many of the C++ jobs I see, moreso than general web dev positions, at least, come with domain specific knowledge requirements (GIS, database engine experience, 3D graphics and geometry, etc). Targeting one of those areas, if it is a good fit, might be a way to get your foot in the door.
!!!!!!! Very nice work
I think this is the most beautiful GUI I've ever seen‚Ä¶
Great stuff to see you have self-propelled your career in this way (the evolution is also very visible on StackOverflow).
This is sort of how I got my current job. I found a job whose product line was similar to what I was into, specifically cpp for linux on embedded devices, and made sure that I crushed as many GOOD C++ books as I could before the interview (Effective C++ was and is still awesome, depending on your toolset) I had been putting Linux on all kinds of little devices at home for years, and I loved it, so then that experience, with enough C++ knowledge at the interview landed me the entry level position. My first few years of code reviews were brutal and fantastic. Lots of continuing self-education, and now I'm a senior dev.
&gt; functions that are getting inlined Functions that can be inlined are part of the public interface. "public" interfaces essentially include anything that can impact ABI.
What worked for me is to pick companies you like and ask for the official channels of recruitment. Some of them have webpages where they put all the job offers. In my case, with 0 experience, I asked if they had any intership offers which required C++. I don't know if I was lucky, but most companies I applied for pay interns pretty well and they had something to offer me. I spent 6 months at one company and 6 months at another, and at this last one they hired me as a full time employee. Maybe this strategy will work for you, I recommend it but again, maybe I was lucky... Just keep in mind these companies normally require disponibility to move to some part of the world, that is one big condition you need to be aware of if you want to do this.
Yes, it is very easy, but `auto` doesn't care how easy it is; rules are rules, and the rules are that `auto` _never_ deduces to a reference because of the reasons I already outlined and others.
&gt; if you add another int z; at the end of Foo since three ints now have to be allocated If you've changed the size of the type, you've changed its public interface, since `sizeof(type)` does not require private access.
&gt; &gt; &gt; If you've changed the size of the type, you've changed its public interface, since sizeof(type) does not require private access. And that's why you need PIMPL most of the time. To hide the size from the type information, so that you can add for instance a cache or reorganize members without breaking the ABI.
I said **read**, not **write**. perl is a wonderful language to write in. It is just unreadable a week later.
Wow. I searched for this and never found anything like that. Thank you! Now, I only need to find a way to test if the right static_assert has been fired.
that would be lovely. I just have no idea where to even look for a job like that in London. Literally, what am I looking for in practice? Software simulation?
Fair enough. I would argue most of those cases _realistically_ get coupled with changes to the rest of the public interface anyway, but certainly not all the cases.
I was expecting a hacky solution, but pleasantly surprised at how beautifully simple it was.
I am reading a book by a gottschling guy who introduces c++ for engineers or scientists. I think I like the focus on performance and efficiency if it makes sense, because I have the impression it would make for more interesting problem solving. I guess what I would really love is a job in software development that uses as much math as possible. 
pure, sadly. Analysis.
&gt; I guess what I would really love is a job in software development that uses as much math as possible. Sounds like you might enjoy [ML](https://en.wikipedia.org/wiki/Machine_learning). I worked on image and video classifiers for a few years, and the guys designing (and sometimes implementing) the rankers all had to deal with math that was quite over my head. I was a QoI specialist, though, so I didn't need to understand the math so much as to simply translate their Python/C# code to efficient C++.
I know. Still easier to read than python. Easier to write too.
Anything scientific. Try searching for different scientific fields that interest you. 
any hint on how to do that? Like a portal that doesn't use recruiters?
I think I would enjoy ML, but guess what. Same situation as c++ for a pure math M.Sc. :)
The really dismal thing is that all I get is job entries in websites like indeed, that 99% of the time are from recruiters, who then proceed to trash my cv immediately. I would really need to find employers directly. Just can't think of how. 
I know you're being humorous, but defines aren't really modern C++ either... The second one could have been a typedef. 
 include_directories("${PROJECT_BINARY_DIR}") It's 2017. If your CMake files aren't using target-based commands instead of the old legacy ones, then you're doing it wrong. In this case you should use [`target_include_directories`](https://cmake.org/cmake/help/v3.9/command/target_include_directories.html) instead. Also, [`using namespace std;` is a bad practice](https://stackoverflow.com/q/1452721/2176813). Don't use it!
Thanks for the input, tambry.
IRC
what do you mean?
`using namespace std;` is absolutely fine in many cases, regardless of the number of upvotes that SO answer has. Just think about the scope of what's being impacted. The risk of conflicts, particularly insidious ones, is over-egged by a few people to have been bitten by particularly nasty cases that probably could have been prevented in other ways. https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only
I actually meant to redefine std::make_unique, so it's still a typo. But yes, typedefs would improve upon the example of why that part of his rant is silly. Something has a long name? Shorten it yourself.
I can't think of any examples in the standard where similar cases ("all or no local variables of non-class type must be initialised" or something equally non-local in scope) make a program ill-formed. This falls into the realm of static analysis, some of which may be performed by the compiler.
after more than a year of looking for a job (PHP or C++) after graduation, and did interviews with BBC, Trivago, Citrix, Booking, etc. nothing. Then an IT consulting company asked me if I was interested to do a 3-months J2EE training course then they would hire me. Said yes, and the client I worked for, after 2 months of doing nothing (because they was no things to do) on the J2EE project I was on, put me on a VC++6/MFC project. Lasted one year before the project was stopped (new version done by another company). Now I'm in another company doing C++/Qt in the industry (they hired my because I have Qt certifications).
You might try sending blank applications to research companies in the fields that interest you. Interested in Medicine, Chemistry or Biology? Try e.g. Bayer. Economics? Banks are your way to go. Physics or Engineering? Siemens, ESA, Boeing, any car manufacturer. 
1. `T=bool` 2. aliasing e.g. `foo(x,x)` 3. writing a class that overloads `operator+` to do non-conventional addition.
I can verify that `T=bool` [will return false](https://ideone.com/ggPGMR).
Look into actuarial software companies, full of mathematical routines
This. The example from StackOverflow is silly, since the only thing it takes to fix it is adding `using bar::Quux;` as well.
* Unindented code * Variable width font * Bold and italic * Huge line height Also, this appears to be the only website on the internet still not using HTTPS
Here's how I went about it. From my post in /math (https://www.reddit.com/r/math/comments/6l9rnf/how_has_your_math_career_been_different_than_you/). tldr: get any programming job that's SORT of math related, and learn C++ on the side. Each job change get a little closer. Caveat that Im in the US so YMMV. To the title question of your post, I got a non-c++ job at a company that had lots of c++ jobs, was learning c++ on my own, and through networking found a team that was willing to take me on because of my math skills alone. (and they felt they'd rather be teaching c++ than teaching math). &gt; Longer version: I enrolled as a nuclear engineering major, quickly changed to physics 1st semester then by end of 3rd semester switched to applied math. Never tried to find internships, or jobs. knew jack all programming. went straight to grad school. tried to find MS level teaching positions towards end of grad school. 0 replies. barely learned some programming in grad school (matlab, sas, python). got a job doing some IT consulting and learned SQL on job for a year, learning more python, C++, and cs concepts on the side. Did some big enterprise IT for manufacturing/engineering company with a worthless job for a year so had lots of time to learn c++ &amp; cs concepts at work bc so bored. Eventually switched to r&amp;d at same company through networking/social skills and did c++ for image processing algorithms for factory automation. Did that for a while then joined a data science group, same company. focused on predictive maintenance for machines/vehicles from sensor data using some cool distributed stuff (apache spark, hadoop etc). been in that role little over a year. Now leaving company to go to small medical r&amp;d company doing more pure prototyping of advanced math features (matlab and c++ heavy). Much more advanced linear algebra... will likely learn some controls/robotics on the job too.
I was quite lucky in my path, I did QA at an anti-virus company, so all the malware imitating tools I wrote were in c++, after a couple of years i got accepted to the dev department (they develop in c++), not the most standard path.
Do you use github ? Start by put on it your projects. 
https://www.co-hire.com/, although it seems to only have js/python now. stack overflow also has job postings from companies. the big companies usually manage their own recruitment. last, you might be interested in an internship at a solid company; it's probably better paid/you'd learn more than a shitty random job anyway.
Entry level, new college graduates jobs do not require extensive experience in C++. I got mine after mentionning i knew C++ on my resume and not borking my interview (too much).
Generally, I wouldn't trust the float comparison to work out either, but it turns out for sufficiently small integers the float representation is exact. https://stackoverflow.com/questions/3793838/which-is-the-first-integer-that-an-ieee-754-float-is-incapable-of-representing-e
What may be the point of using one compiler for development and another for production ? Would that not risk hiding potential problems ?
Im similarly searching for c++ in sf bay area right now with math background, no software engineering experience. Having a github portfolio with modern c++ really helps even if its all tiny. This has been a major door opener for me even with like just a few hundred lines libraries. U dont need a year to make a portfolio that can impress employers. You need to be able to explain what it is and why to use it clearly and thoughtfully, and talk to other engineers intelligently abt c++ design issues. Heres mine : https://github.com/cbeck88 I literally just got off the phone with managers, this kind of thing is as attractive to them as my whole damn phd... lol Its true that i did contribute to some open source stuff a few years ago but i barely knew any c++ at that time. I think the most technical things in my list were like maybe a months worth of work each. Theres a lot of aspects tho, testing, CI, cross-platform... its not like u wont learn anything even from smallish projects ------ Edit: Some tools people recommended to me, but I didn't end up using, so I can't speak to them. They might be kind of like the "portal" you mentioned you wanted: triplebyte: https://triplebyte.com/ angel list: https://angel.co/
If you have good math skills and some c++ projects that demonstrate some of your coding you could consider game development. They tend to require pretty solid grasp of linear algebra, geometry and calculus. I‚Äôve been asked questions during interviews like: ‚ÄúGiven a ship in 2D space and a rocket flying at it, how do you determine which hemisphere of the ships shields to activate.‚Äù Stuff like that.
I am a master SE student who just got employed in cpp after 11 months of C#/JS. I did not have any commerial experience with C++, but I've done many of my labs in it and knew it good enough to pass the interview and impress the interviewers. Just remember that while there are employers who would turn you down because you do not correspond to formal requirements, there are also those willing to give a chance to people who actually know C++ stuff :)
Thanks for your feedback, much appreciated! &gt; I'm curious as to the actual benchmark code because 3ns per iteration looks like the compiler optimizer defeated the benchmark. Good one, you are right: the code is entirely optimized with clang 5 (not gcc 6 though!). I will edit the post on my blog, meanwhile I will share the details here are as I believe it is interesting. Here is the code (you can find the entire code [here](https://github.com/david-grs/inplace_examples/blob/master/inplace_examples.cpp)): using MetadataTree = boost::container::static_vector&lt;std::pair&lt;inplace_string&lt;15&gt;, static_any&lt;16&gt;&gt;&gt;; template &lt;typename TreeT&gt; TreeT GetTree(int i, double d, bool b) { TreeT tree; tree.emplace_back("metadata1", i); tree.emplace_back("metadata2", d) tree.emplace_back("metadata3", b); return tree; } int BenchmarkGetInPlaceTree() { int elements = 0; for (int i = 0; i &lt; 1000000; ++i) { auto tree = GetTree&lt;MetadataTree&gt;(elements, 2.0, true); elements += tree._metadata.size() + tree._metadata[0].second.empty(); } return elements; } Which generates with clang-3.8: 0x00000000004021a0 &lt;+0&gt;: mov eax,0x2dc6c0 0x00000000004021a5 &lt;+5&gt;: ret Quite amazing that clang is able to bypass the entire boost.static_vector::emplace_back with inplace_any and static_any. But I guess that's another good point for inplace containers, right ;)... After having fixed the benchmark, I get the following results: Test Time (ns) INS CYC --------------------------------------------------------------- MetadaTree 543 2,205 1,013 in-place MetadaTree 28 117 53 &gt; I'm interested in data backing up this statement. If you enter the "no memory allocation takes place" path of string's SSO, it should be similar. If you enter the case of SSO, `std::string` will be as fast as `inplace_string`, indeed - but that's the whole goal of this class: to guarantee that this will *always* be the case, regardless implementation details. &gt; &gt; Cache-friendly: it stays close to your other class members, your cache likes it. &gt; That's also true for the normal SSO. And in normal program use you're likely to need to leave more space than you actually need in these strings, which means your cache does not like it. This really depends on the application - I am not sure what you mean by "in normal program use". In my application, I am using a lot `inplace_string&lt;4&gt;`, and the cache likes it: is using *less* memory than any possible `std::string` implementation. Although my main motivation to write this class was that my application is also using many strings around 23 characters, which doesn't fit into any SSO implementations. 
http://en.cppreference.com/w/cpp/language/operator_other "In a comma expression E1, E2, the expression E1 is evaluated, its result is discarded (although if it has class type, it won't be destroyed until the end of the containing full expression), and its side effects are completed before evaluation of the expression E2 begins (note that a user-defined operator, cannot guarantee sequencing) (until C++17). "
This is off-topic for this forum, and should be directed to /r/cpp_questions or [Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b). Any expression of the form `(a, b)`, which doesn't correspond to a function call, instead becomes an invocation of the *[comma operator](http://en.cppreference.com/w/cpp/language/operator_other)*, whose effect is to evaluate `a`, discard the result (if it returns a result), and then evaluate and use `b`. So the resulting outcome of your code above was equivalent to `(y2-y1)/(x1)`.
&gt; The risk of conflicts, particularly insidious ones, is over-egged by a few people to have been bitten by particularly nasty cases that probably could have been prevented in other ways. ugh, thanks for reminding why the CppCoreGuidelines are utter shite. Seriously. &gt; Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring std:: everywhere could be distracting. yeah, right, "obviously", up until the day someone sets up precompiled headers or unity builds and suddenly nothing compiles anymore. Likewise [this kind of shit always end up in libraries' header files and then everyone is sad](https://github.com/search?utf8=%E2%9C%93&amp;q=%22using+namespace+std%22+extension%3Ah+extension%3Ahpp&amp;type=Code&amp;ref=advsearch&amp;l=&amp;l=)
It's such "utter shite" that it tells you not to do the thing you just complained about everyone doing that makes you sad. Perhaps if those authors had followed those guidelines their code would be better, even if you don't agree with everything about them. &gt;SF.7: Don't write using namespace in a header file
&gt; crash compiler &gt; kill the compiler It is expected that compilation errors will not crash or kill the compiler. 
&gt; SF.7: Don't write using namespace in a header file No, even in source files (at global scope) it's not kosher. Else it breaks unity builds. That people do it in headers only adds insult to the injury. 
Then take that into account if you intend to use unity builds. Anyone doing so will need total control of the code base which is being built, anyway, because of the need to not repeat variable names in different cpp files' anonymous namespaces. The guidelines could mention unity builds but I doubt that would be sensible because it's a relatively niche area, and those using it are generally aware of the issues it can cause. You want to do unity builds with random libraries you find online? Good luck and be prepared to massage the code. 
Using it in headers is bad, using it in cpp files is fine. Not everyone uses Unity, and even if it breaks Unity, then that's kind of on them.
Even without using any other libraries, it's already a pain to get coworkers to not do it in a relatively small project's codebase.
(since you're adding a cap to unity, I'm not sure that we are talking of the same thing. "Unity" builds are when you #include all your .cpp files in a single "big" .cpp file that is compiled in one go. In my experience it brings down compile times by a good 80% on template-heavy projects. That's a [relatively common optimization](https://en.wikipedia.org/wiki/Single_Compilation_Unit): for instance with CMake it's a single command if you use the cotire library.)
And what's the solution to that problem? It's not to take issue with perfectly sound advice which applies to the vast majority of cases. It's to enforce project specific coding standards through code review, source control tools, static analysis (clang-tidy plus custom checks is awesome for this), and so on. 
&gt; It's not to take issue with perfectly sound advice which applies to the vast majority of cases. There's no amount of code review that can go against people half-reading bad blogposts and treating them like the holy bible. This wouldn't be necessary if every other online example would shamelessly put `using namespace std;` everywhere. 
&gt; `cmake .` Ugh.... in-source builds are the worst. I never, _never_ use in-source builds. Sure, you can configure your source control to ignore all the generated stuff, but it's a giant pain. Additionally, you can't create multiple builds concurrently for different tasks / targets. Personally, I always create a `build` folder in the main project folder and then from there call `cmake ..`. This allows me to add a single rule to my source control (in my case git) to ignore `build*`. Then I can create `build-android` or `build-clang` or `build-debug` for various sub-projects I'm working on. 
Unity isn't the game engine in this case, but a method of building that basically takes many source files and globs them together into much larger files before building, greatly reducing the build time consumed by initialization/teardown of the compiler, file I/O, etc. My last job was at a game company and we used unity builds and Incredibuild (distributed builds) and the build speed improvement was impressive. I'm not sure how widely adopted this strategy is, however.
Well, yes there is, because any code review will see that somebody wrote that line of code, and question it. It takes technical leadership and mentoring to prevent a "wild west" of developers writing code to whatever best practices they think they understood from a stack overflow post that week, one tool in the toolbox is code review, I've mentioned others. This isn't a hopeless situation. 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/72fgwc/using_ab_in_a_formula_did_not_crash_compiler/dni6lpt/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Ah, I misunderstood. However at that point, you're just using cpp files as header files. The underlying point is that you should not have `using namespace` in code unless you actually have control of exactly what code follows the using statement. Both headers and cpp files used in a unity build violate that constraint. Personally I don't use `using namespace std;` at all because I think typing `std::` actually ends up reducing typing in environments with code completion. On the other hand I'm not above doing things like `using Lock = std::unique_lock&lt;std::mutex&gt;;`
Don't forget boost.org :-&lt;
Also, people will non-maliciously commit these things, and then your build is wonk forevermore.
/u/spongo2 is at CppCon this week, but I'm sure he'll be interested to see your request.
Slightly off topic, but why are you using the static keyword in front of the constants? This is redundant for namespace scope constants.
Not sure if he should change the title just because everyone's shit is emotional right now. 
I thought some compilers wont check if the function is valid to mark constexpr unless it is forced to be evaluated as such? e.g. returning a value and having that value assignment be constexpr. yeah: https://godbolt.org/g/ZGbx99
This is a very specific feature of CMake to choose as a basic introduction. Most projects will probably never even use the file configuration feature (as neat as it is when you do need it). 
Use the company website.
Sorry to be blunt, but overall I find this is a rather poor example of how to use cmake (most reasons have been named in other comments already). I'm not sure if you are doing the community a favor with this. Although this is one of the few blogs that addresses template files, so there is some value in it.
I've found this C++Now talk [Effective CMake by Daniel Pfeifer](https://www.youtube.com/watch?v=bsXLMQ6WgIk) quite good. A bit too fast at some points, so you will need to check the docs, but covers a lot. It made me discover `target_xxx` commands, and specially useful for me, the "easy" generation of `foo-config.cmake` for other to use your project. Also in [pdf](https://github.com/boostcon/cppnow_presentations_2017/blob/master/05-19-2017_friday/effective_cmake__daniel_pfeifer__cppnow_05-19-2017.pdf) 
So much simpler than cmake
I created an ASSERT_COMPILE_FAILS(expression); for use where I work. Essentially how it works is it is a macro that compiles to a function call with line number information throwing the expression away (as it is expected to not compile) The function call writes out the test cpp file the same except for removing the macro around the expression. Then it tries to compile it using the same compile flags. It then runs an ASSERT based on the return code of the compiler. Example: std::unique_ptr&lt;int&gt; a, b; ASSERT_COMPILE_FAILS(a = b); You can also do multi line by opening scope with { expressions }
As I said, in some cases it will be fine, but that's still poor style. Having a way to signal that you explicitly left something uninitialized would be best.
A constexpr with no return screams evil. I definitely see why we need a true pure keyword.
What's even better, stylistically, is not to have variables defined before they have meaningful values. There's almost no excuse for doing so in modern C++ now that C++17 has multiple return values. Going back to the OP's code, zero is a meaningful value because it's the initial value of an accumulation - just to be clear that I'm not trying to point out an issue with that particular example. 
Listening! 
I think portfolio is optional. What's required is that you actually know how to do the job they would hire you for. 
It's honestly somewhat a wonder and a disappointment that cmake even supports them. Or doesn't at least automatically put all generated files under a sub-dir of the target source dir, e.g. `./cmake-build`.
I think the case where you use an uninitialized value is when you have a if/else structure where both assign a value to something that you want to use later. However, you have ways to avoid this with ternaries, lambdas or complete functions. I tend to use ternaries as much as possible in these cases because that's usually the shortest.
If it's already slow af for a middle sized project, how can it be the best c++ IDE? Sometimes, even ctrl-c to copy one line will take a long time. Not to mention the horrible, sluggish, outdated and buggy intellisense. Without a commercial extension like visual assist, vs for c++ is simply unusable for any serious c++ project.
I didn't have any diploma, I made a RTS that I showed in interviews, and more importantly: I was cheap. Don't do like me.
That is likely a manager at Bloomberg. Bloomberg is just another big enterprise that hires young people in batches and abuses them until they quit.
[removed]
[removed]
Manufacturing and industrial companies have lower standards because software is not their main product.
Please don't post the same reply three times to different people; I've removed the two other copies.
Hi jherico, that's a really good point. I updated the article.
Hey kalmoc, thanks for your feedback. There are good points mentioned in the comments. Especially the in-source build. I updated the article and hope it is at least a little more helpful.
I found that there are cases where clang-format** (or at least the version I'm currently using) can produce invalid C++ as output and that made me very hesitant to put it onto a p4 trigger. We run it as part of our pre-commit test suite behind a small python script that handles backup of the original file and diffing. ** We're actually pairing clang-format and astyle as I couldn't get clang-format to do what I wanted, so it might have been related to the combination of the two.
Bad habit I guess. Thanks for pointing this out.
Actually, in projects I never use "using namespace ...". I sometimes do it when writing small test programs to type less. For the hello-world example in the article that does not make sense of course. I changed it to avoid spreading bad coding habits.
You need to write some code. I learned C++ back in 1990. First, the very first, thing I wrote in C++ was a parser for a subset of COBOL. You may laugh, but it's super easy to parse, and it taught me something about designing a non-trivial object oriented parser. Mistakes were made - and not repeated - because it taught me a lot. Go forth and write some real code, on your own, in C++. Reading a book isn't all you need to do. It's been 27 years since I first learned it, and I am still learning new things about C++ every day. It's my job, and I love C++. If you write code and love C++, you will find your way into a job. I promise. But, the code comes first, always. Write it. 
&gt; Anyways, people post here all the time about their own C++ projects. If this is where you want to set the bar, all those "raytracers, window process managers, ..." posts here have a chance. None of them helps me as a C++ programmer either, and the only reason they are here is that they are written in C++. They're C++ libraries, so they C++ programmers (not all of them, obviously). On the other hand, this only really serves Rust users.
no no... the _best_ is when you do `cmake ..` and you get back _FATAL: Project FOO does not support out of source builds_ or something similar. Seriously, fuck developers that do that. 
I second different articles and books by Herb Sutter. http://www.gotw.ca/ is his old website but still useful. In addition to that, there are very informative cop talks on YouTube by Chandler Carruth, Scott Myers, Bjarne. And Channels like meeting cpp, cppcon, cppcast etc.
If I may digress, vscode works great in macOs. God it feels lighter when working on vscode vs Xcode. 
Thanks a lot for the read and the detailed review. I have fixed the annoying terminology issues. Some of the points are too subjective, e.g., "is neither correct nor particularly useful", some are just rephrasing existing content in the story, e.g., "The purpose of move is to cast it to an rvalue, to enable its resources to be reused." so there is no way for me to improve the article and benefit the readers. The code block referred from cppreference is not an interesting one, as it obfuscates the concept even more, so I will not use it. "...member there is ... already manages its own resources..." This is off the point as the concept should be agnostic to exact type of the resource. "The correct answer is nothing. It does nothing. It's a reference binding" Repeating is too strong to highlight this point. Plus, "It's a reference binding" is telling nothing but "I know the secret". So I think the existing way is better for the end purpose. Thankd again for assisting making it a better story. 
&gt; A constexpr with no return screams evil. Why? Sometimes you need complex initialization logic in order to produce a constexpr value; mutating the object as part of its initialization by calling its member functions seems completely natural to me, not evil...
A window's process manager written in C++ is not a C++ library, same for a ray tracer, same for other programs written in C++ here, and same for a compiler for language X written in C++. The main difference though is that those are typically 1kLOC toy projects and this is a 100kLOC single man weekend project, and also, that nobody writes compilers in C++ for fun except this guy. Just for the fact that he chose C++ is actually pretty significant. Most of those using C++ tools to write compilers, like LLVM, do so through the C bindings via a high-level API like the Python bindings. I really don't recall the last time somebody wrote a compiler in C++ for fun. Most just use Ocaml, Haskell, or some other more suitable language for that. Anyhow, discussing about this is pointless, if this is were the bar is set for posts here, I think that's fine, sorry for the submissing, I did not know.
WTF. Is this an entry to obfuscated C++ code competition?
Computer Graphics involves tons of math. Machine learning is piles of linear algebra if you peek just below the surface. "Quants" in the financial industry do a ton of math. Even network programming benefits from a math background if you can calculate optimal ways to move data around between nodes - a LAN can quickly look like Graph Theory is you have the right perspective. Math is a remarkably general purpose tool. /r/cscareerquestions/ may be useful for general How Does Jobhunting Work kinds of questions.
If speed is important, I'd do something like this: int numTriangles=0; for (const auto&amp; poly : polys) { numTriangles += poly-&gt;Triangles.size(); } int vArraySizes = numTriangles*9; int uvArraySizes = numTriangles*6;
&gt; Here is the code (you can find the entire code here) Thanks! &gt; 28ns That sounds more like it! &gt; I am using a lot `inplace_string&lt;4&gt;` I'm used to a lot of.... let's say, "users" who want to randomly set that to like 512 chars. :) If your common use case is 4 then yes this'll be a big win.
Well deserved üëè
Well, there are of course more realistic examples, but this was the shortest one I could think of. There are a lot of misconceptions about what constexpr is (e.g., even the core guidelines claimed for a long time that constexpr functions couldn't throw exceptions). But all constexpr guarantees is that for at least one set of inputs the compiler can execute the function at compile time. For all other combinations it can almost act just like a normal function (**you can even call malloc**). I think that was a mistake just as not guaranteeing that a function is evaluated at compile time when it's inputs are compile time constants, but that's what we have. But even when we only look at compile time evaluation, pure and constexpr can be viewed as two independent requirements that happen to have a large intersection e.g. you can think of various pure functions that can't be constexpr, starting with functions that are not defined inline, using compiler intrinsics/assembler or maybe even throw and catch exceptions internally (depending on how you define pure). 
What I understood was you could evaluate it at compile time for *any* input arguments. I don't really see the point of only guaranteeing for some arguments, that really limits the optimizations.And it doesn't help that C+11 was effectively that as well, so you end up finding conflicting information.
So basically, when testing your template library, you use these types to see if you managed to design not only for stupid, but for Machiavelli as well?
I use [terminator](https://gnometerminator.blogspot.co.at/p/introduction.html) with 3 windows as my build machine. For development I different editors: * kate for most of my stuff. * Visual Studio Code because it's nice, but unfortunately a bit slow for large projects. * geany as a quick editor I use the fantastic [ripgrep](https://github.com/BurntSushi/ripgrep) to quickly grep through a huge software infrastructure.
Ah, I see. That makes for some tough interviewing. You'd typically get questions like "Can you tell me about an earlier C++ project you worked on?" "What did/didn't you like about it, what difficulties did you run into, and how did you solve them?" I would have trouble recommending anyone who doesn't have good answers to those. red_nuts is right: you need to write code, show at least some kind of basic aptitude (and in the process figure out for yourself if you really enjoy it or not), before recruiters would consider you. The way to do it... maybe through an internship; a good mentor would be a great help in quickly getting up to speed. Alternatively, maybe by doing some work on an open source project, but it would have to be a recognizable chunk of work, rather than just a patch here or there. I should add a word of warning: writing software has virtually nothing to do with math. If you enjoy math, maybe you should find a job where you can actually do math - and while I'm sure there are a few software jobs out there that use math beyond highschool level, the vast majority struggle to even reach that level. If anything, software is about organisational skills; it's about keeping your mess in carefully defined boxes that don't leak too badly into other parts of the project. It's about making simple, powerful, interfaces that are hard to use wrong. It's about obsessive attention to detail, understanding process flows, and coming up with an answer to every "what if" years before they happen. But math? Not so much... 
Congratulations, mr. Stroustrup!
I maintain the codebase for a legacy application that controls lab instruments. With drivers and tools that's probably around 2-3M LOC, mostly in C++98. 
Thanks for the advice
Vittorio isn't a manager. Do your research before throwing stones.
I was involved with the Boost community, on IRC, and asked someone for a job.
When did this become legal C++? For i=2 to n 
I'm not a manager, I'm [Vittorio Romeo](https://vittorioromeo.info/). I've been a Bloomberg employee for slightly more than a year. While it's not perfect, I'm having a good time here... and I'm being treated well. Sad to hear that your experience was different.
&gt; I just have no idea where to even look for a job like that in London. Quantitative finance is all mathematics and programming, and it's all based in London. There is a very steep learning curve if you haven't been exposed to the basics of stochastic calculus. But as you would imagine the pay off is rather lucrative. G Research would probably be interested in your profile (although they are mostly a C# shop, they do a bit of C++ work as well). Bloomberg is just a giant C++ factory. Other major investment banks have C++ and always like people with a mathematical background.
Recruiters are poison but unfortunately every small company relies on recruiters; they don't have the resources to read through unfiltered CVs. You really do have to send out 100 CVs and keep trying until something comes back.
I think callgrind can show you cachemisses
First of all, the compiler error is not about whether constexpr is valid or not, but about the missing return statement (in a non-constexpr context this would just be UB, in a constexpr context the compiler is required to diagnose it). Second, as I said, constexpr functions can have side effects when they are executed during runtime (as in my example). You are trying to execute the function during compile time (e.g. using it as a constant expression) that is of course not possible for the given input of `false`. If you add a return statement and switch the input to `true`, this will compile just fine, although the function can still modify state if called somwhere else during runtime: https://godbolt.org/g/UXk8Gm. This bahavior is afaik not compiler specific behavior but the way constexpr is specified (However, I'm not a language lawyer, so if you want to be sure, you should probably open a question on stack overflow)
I might be wrong - look at the standard or ask on SO to get a more reliable answer, but from cppreference.com ( http://en.cppreference.com/w/cpp/language/constexpr ): &gt; there exists **at least one** set of argument values such that an invocation of the function could be an evaluated subexpression of a core constant expression (for constructors, use in a constant initializer is sufficient) (since C++14). 
Have you considered doing a PhD in industry? The [Industrial Doctorate] (https://www.epsrc.ac.uk/skills/students/centres/pre2013/idd/) programme places you in a research project with a company for 4 years. It includes an integrated Masters course so there will be plenty of opportunities to take additional programming classes at the partner university. That said, practice your C++ until you can pass a programming test and then apply directly to companies or job adverts. There is a huge shortage of people with maths and programming skills at the moment. The search term you want to use is ["scientific programming"](https://www.indeed.co.uk/jobs?q=scientific+programming+graduate&amp;l=london). Good luck!
Bloomberg are in London and hiring lots of C++ developers. They have a good training scheme (3months) for new juniors or grads, and the pay is good. Highly recommend you apply there directly. As long as you can code well enough to pass interviews you don't need prior c++ experience afaik.
Does NVIDIA really have worldwide remote/from-home engineering jobs?
Thanks a lot for the suggestion. However it seems that the next batch of graduate jobs at Bloomberg will be in an unspecified month in 2018. I can't afford to wait that long. Btw, when you applied at Bloomberg you already had your side projects and so on, right? 
Is the instrumenting profiler still supported ? I gave it a try not so long ago but didn't get it to work. Also, profiling is broken with fastlink ! I think DIA is missing a little bit of love with this one.
I don't want to be mean, but I know that you will find many, many more people who are expecting and eager to answer your question over at r/cpp_questions
The signature of the time function takes a pointer - 0 implicitly converts to a pointer, NULL works and means the same (sort of), nullptr is actually guaranteed to be a null pointer (there's some weird stuff that can happen) so always use that instead But beyond the straight question, srand + rand are both considered to be fairly bad and are likely being straight up removed at some point in the future from C++, so i would recommend against both of them Use the C++ random number generation facilities instead. Its slightly more verbose, but its a big improvement. EG you are able to swap out the implementation to a different rng if you need it std::random_device rd; //Will be used to obtain a seed for the random number engine std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_real_distribution&lt;&gt; dis(1, 2); for (int n = 0; n &lt; 10; ++n) { //Use dis to transform the random unsigned int generated by gen into a double in [1, 2) std::cout &lt;&lt; dis(gen) &lt;&lt; ' '; //Each call to dis(gen) generates a new random double } std::cout &lt;&lt; '\n';``` This example taken from the wiki, although mersenne twister is pretty bad and I'd recommend using literally anything else like minstd_rand over it
Your tutorials are seriously outdated. ```srand``` and their colleagues are fossils from C that don't deliver good, let alone true, randomness. It's fine if you are working on a simple game, but no serious company uses it any more for getting random numbers. You should learn how to use the new random generators from C++11. A good place to start is here: http://en.cppreference.com/w/cpp/numeric/random 
Yes I am simply using it for a simple game.
For Games you often want fairness more than true randomness, in which case it is sometimes better to shuffel a predetermined set of values than generating true rangom values. That aside, even for a simple game I'd recommend to use the c++11 functionality - for many cases, just using `std::random_device` + whatever distribution you want (e.g. `std::uniform_int_distribution&lt;int&gt;(0,100)` is actually good and fast enough. 
Why is mersenne twister bad? I know that it is slower than some modern prngs and a bit tricky to seed, but for most cases it should be ok 
Here is to the most influential person on earth. Cheers!
&gt; Some of the points are too subjective, e.g., "is neither correct nor particularly useful" This isn't subjective. It's objectively not the correct definition of rvalue, but it's also objectively not useful since it doesn't actually tell you what an rvalue *is* - it just tells you something historically about what the term used to imply. Here, for instance, is an rvalue on the left side of an equals with an lvalue on the right side: struct S { } s; S{} = s; A more useful definition of rvalue is an expression that denotes resources that can safely be moved from. &gt; some are just rephrasing existing content in the story, e.g., "The purpose of move is to cast it to an rvalue, to enable its resources to be reused I do not see where in this story that you describe the purpose of `move()` as such. The statement you have is that `move()` is used "when 1) we know a variable is in fact a rvalue" - but this makes no sense for two reasons. First, because value categories (like rvalue) are categories of *expressions*, not categories of *objects*. A *variable* cannot be an lvalue or rvalue, those terms simply do not apply to variables. Second, because there's no reason to `move()` an expression that is an already an rvalue - that additional `move()` wouldn't do anything extra for us. The only time `move()` changes program semantics is when you `move()` an lvalue. &gt; Repeating is too strong to highlight this point. Plus, "It's a reference binding" is telling nothing but "I know the secret". So I think the existing way is better for the end purpose. This is an important point that you're missing, so I think repeating it might be again worth it. It's not a *secret*. `std::move()` casts its argument to an rvalue reference type - that is its entire point of existence. As a result, `ResourceOwner&amp;&amp; r = std::move(res)` is just a reference binding in the same way that `ResourceOwner&amp; r = res` is. And reference bindings (to the same type) don't *do* anything. There is no constructor invoked here. You're not moving or copying resources. You're using the fact that a direct reference binding generates no code to conclude that move semantics, as a whole, doesn't do anything. That conclusion is very wrong. 
The current "rudimentary" live-performance analysis is already awesome, keep up the great work! Thank you :-) Looking forward to great things in the future, I know they'll be coming\^\^
&gt; when you applied at Bloomberg you already had your side projects and so on, right? Yes, most of them.
Wish i could pronounce his surname
&gt; Is there a non C++ compiler that can recompile any of the major C++ compilers? I found this interesting. Until several years ago, GCC was in C, so could in theory be compiled by simpler C compiler like TCC, LCC, or 8CC. 
Might be a bit of a stretch there.
I'm on the same boat!
okay thanks alot i will take note. 
Congrats /u/bstroustrup !
http://www.stroustrup.com/pronounciation.wav
From the same page : "For people who can't receive sound, here is a suggestion: Both of my names are pronounced with two syllables: Bjar-ne Strou-strup. Neither the B nor the J in my first name are stressed and the NE is rather weak so maybe Be-ar-neh or By-ar-ne would give an idea. The first U in my second name really should have been a V making the first syllable end far down the throat: Strov-strup. The second U is a bit like the OO in OOP, but still short; maybe Strov-stroop will give an idea."
Transitivity is powerful.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; minstd_rand `minstd_rand` is terrible. Although seeding a `mt19937` with a single 32-bit variable is also terrible. So yea, why do you think MT is bad?
&gt; let alone true Nothing computer delivers true randomness.
&gt; If it's already slow af for a middle sized project, how can it be the best c++ IDE? Sometimes, even ctrl-c to copy one line will take a long time. Not to mention the horrible, sluggish, outdated and buggy intellisense. Without a commercial extension like visual assist, vs for c++ is simply unusable for any serious c++ project. All those are relative to what? VS like IDE that is fast and also nonexistant? I do not know of any IDE better than VS. If you do please do tell, but disclose if you work/contribute to Eclipse CDT/CLion. 
That's *Doctor* Stroustrup to you ;)
C++ is heavily used in AAA games. I don't know if that interests you, but math can play a big role in rendering. I think there are a number of game companies in London.
&gt; I know that it is slower than some modern prngs and a bit tricky to seed, but for most cases it should be ok Basically this, plus MT has huge internal state, is expensive to seed, and is commonly implemented badly
As one of the worlds most unknown, prolific inventor, he is to me, as this was a subjective comment I made., though I respect your comment. 
&gt;maybe Be-ar-neh or By-ar-ne would give an idea Barney?
&gt; This, in turn, makes i18n of the &lt;&lt;-based code a nightmare (while it is fairly straightforward for printf()- and {fmt}-based stuff ‚Äì we just need to replace the format string, that‚Äôs it). I hadn't really considered it before but this point makes a printf()/{fmt}-like I/O API not just a matter of preference but a veritable _requirement_. 
It took me a long time to understand *why* this can happen, and I'm still infuriated that it can happen at all. I'd love to get a proposal into C++20 that would * make it a standard warning to have any variable left uninitialized, * add a modifier/annotation/whatever (`uninit`?) which suppresses that warning, * make the warning become an error in C++23/whenever I'll even write it myself if anyone can point me in the direction of any good resources on how a novice would go about learning how to write a good stdC++ proposal.
&gt; To win the challenge, your code must have as many features of C++17 as possible. This seems to conflict with the goal of writing "expressive" (which I take to mean "concise yet readable") code -- using, say, class template deduction guides or `std::byte` just to tick them off doesn't necessarily lead to the best quality code. 
So happy this is steadily transitioning in `std`. One of the best formatting (and i/o) libs out where overall. Even without the localization argument I've always found iostreams to be less convenient. You have to type so much just if you want to output a number followed by a newline. Also, there are some possible performance drawback to be considered. But with `printf` it's really easy to make some subtle mistakes, since it's not type-aware and compiler diagnostics can only do so much. Also, I find printf-like format syntax ugly and there is no reason for most of it when you are dealing with type-aware language.
I completely agree. Well, I am already using {fmt} all over my projects but having it in the std would be great.
&gt;failing to actually return something That's what I get for having to redo after I fail to save things correctly oh well. But basically yes; constexprs functions can 'modify' global state so long as they are not evaluated in a constexpr case, when they are evaluated at compile time they must have no non function local side effects... e.g. they are allowed to mutate only things that are created during the functions life time.
What we need is a C++ fork which intentionally breaks things in order to modernise the whole ecosystem. Those of us who only care about x86-64 could then use it and those who want their code to run on everything legacy would use normal C++.
There are no uninitialized variables in the linked code snippet. 
I think that's a.... comment? But I'm a newbie. 
They probably intended to mean the NEW features, but they didn't exactly specify did they. C++17 features include C++14, 11, 03, 98...even pre-standard. So basically they're asking us to use as many C++ features as we can think of. So this is really just a rehash of the obfuscated code contest...if you really think about it.
You'd have to either (1) define what invoking a null function pointer means or (2) explicitly list allowed or disallowed optimizations? Not sure how else you'd fix this.
What is the context of this? Guy seems to frame _Barney_ as some disconnected PL theoretic without any real arguments?
Titus Winters announced this at his CppCon keynote: https://twitter.com/CppCon/status/912742896905863168
So if my solution starts with namespace [[sphere]] { namespace A::B { constexpr auto inline x{[]{ return 1;}()}; template &lt;auto V&gt; struct X { static constexpr auto value{V}; }; static_assert(X&lt;x&gt;::value); } } Is that good for using a bunch of of C++17 features or bad for being completely pointless? (Edit: added more)
Okay, now I'm *really* confused. Apparently static/global variables, if left uninitialized, will get default-initialized to 0? If so, then I literally have no idea how this is a valid optimization.
I see how this can look contradictory. I don't think it is though: the point is to explore the features brought by C++17 and use them to improve the clarity of code. If a template deduction guide helps you remove noise related to redundant info in template args, then it's cool. If there is no use for std::byte in your solution then too bad for std::byte, no need to force it. If this is not what the rules seem to mean, then we should add this precision. The point is write the cleanest code possible by focusing on C++17 features. This approach seems interesting to us, because it gives an opportunity to look up all the new features of C++17 (we provide resources for that) and think about how they can help us write cleaner code. I think this will be valuable knowledge when we actually have C++17 at work, in order to make the most of it without too much delay. Don't you think so?
Yep, that would be the new features, as in the ones specific to C++17.
Well, the goal isn't to write pointless code. It's rather to focus on C++17 new features to perform the task described in the challenge. If a feature has no use for this specific task, then no need to force it in. To illustrate in your example, the nested namespace would make sense if there are two real concepts embedded in one another, that you want to express with a nested namespace. In this case, C++17 makes the code lighter with the form A::B. That's good. But no need to make a real_namespace::dummy just for exposing the feature. Basically, the point of the challenge isn't to make a catalogue code. There are better resources for feature lists! :) Rather, it is to research what features C++17 brings and how they can help us write cleaner code for a given task. Hope that makes sense?
It is explained in the article: &gt; Do is static and its address is not taken, so the compiler can trivially see all writes to it and determines that Do must have either the value 0 or the value EraseAll (as NeverCalled may have been called from, for example, a global constructor in another file before main is run). The compiler can remove 0 from the set of possible values when processing the call to Do as it would invoke undefined behavior, so the only possible value is EraseAll
Definitely look at Bloomberg, I had a crazy offer from them for c++ entry level with no programming experience except having read cracking the coding interview. Am also a maths grad. One does not simply walk into g research. 
So if I make the cleanest code of all with no c++17 features I win? :P
I got an offer from them with literally no coding experience or projects. Just learn to do interview algorithms and talk your maths up. 
Good article. I always had difficulties imagining how coroutines can work without using a stack, but this does a good job of explaining the mechanism which makes coroutines work. 
Thanks!
Type safe, yes, but at run time only, not at compile time. What this language needs is a dependently-typed user_defined literals feature, such that `"{d}"_fmt` is a `format&lt;int&gt;` and `"123 {s} 456 {f}"_fmt` is a `format&lt;string, float&gt;`. Unfortunately the standard committee has killed it. \&lt;/rant\&gt;
Oh, and what about the other direction? Will we have a completely independent, subtly incompatible replacement for `scanf/&gt;&gt;`?
Took a brief look. Nothing very convincing to introduce as a dependency. 
Could someone explain what does it offer over boost?
Nice logo, too!!
But how did you get to the interview stage? Did you get a first class from Cambridge or something like that?
They seem to have slightly different styles (Boost is more metaprogramming focused, while Abseil's types aim at being C++17-compatible under C++11), but that's all I can really tell...
I have never seen why you would want to write the type that you want to print. If you look at non-legacy-languages there is a reason why almost none of them offer it and why it is **EXTREMELY** rare that it is actually used in those that do have it. If I want to print something, I want to print it no matter what it's type is, requiring me to spell it out is exactly the wrong way. With regards to formatting: I think a viable solution there would be to offer a way to change it on the argument side, not on the formatstring-side: writef("{}, {}, {}", 3, fmt(5, 10_width, "0"_fill), fmt(3.5, 4_prec, "0"_fill)); // "3, 0000000005, 3.5000"
I would not recommend to use `absl::InlinedVector` for anything. Do you guys know why `std::move_if_noexcept` is important? [Here is the code](http://codepad.org/YbVsjMy5) to demonstrate the problem. The code will output: +++ std::vector ok +++ absl::InlinedVector poison Meaning that std::vector is good, but you may lose your data held by `absl::InlinedVector`. 
Congratulations! I hope the rest of the goodies from //base, //file, //net //util and so on will be released soon. There are bits and pieces of those scattered through repos such as chromium, or-tools, protobuf, grpc
I'm not sure, but the same person in [another video](https://www.youtube.com/watch?v=_xLgr6Ng4qQ) says that private is useless and you shouldn't ever write a getter or setter, so I'd definitely take what they say with a grain of salt.
Meh.
Am I missing your point or are you simply referring to the point that it only offers weak exception safety guarantee?
Google code doesn't support exceptions... having said that, they have been adding noexcept to their move constructors in chrome to help with the optmiser.
If by "weak" you mean basic guarantee, then no. Because invariant is not preserved and you have no way of knowing (in general) that you dealing with moved-from object.
Not convinced. No reference documentation, I hate the style (which is a stupid thing to hate but I find uppercase method names so confusing), and it offers nothing over boost or even Qt. I guess I'm just disappointed because I'm sure there are much more exciting stuffs to extract from google's code base (for example, I've found google chrome source code to be an invaluable mine of information when it comes to desktop &amp; displays apis)
You don't want to write the type, you want to write the format (`{d}` is decimal, `{x}` is hex etc). The problem is when you specify `d` and the actual argument type is a string. You cannot detect that without compiler magic until run time. `"{:x8}", arg` is so much more readable than `"{}", fmt(arg, hex, 8_width)` it's not even funny. Edit:format
Can you explain in more detail why `absl::InlinedVector` returns `poison` in your test? I agree that it is surprising that a moved-from object ends up in the vector.
This is great but I would rather include //base from chromium, which offers much more than this library. I can see their point though... they are trying to do it much more friendly to be seen used as a library...
//util?
"The medal will be gold and shall be accompanied by a prize of ¬£1000 and a certificate." Life well spent. :P 
The Status and StatusOr types used by various packages like grpc, protobuf etc are in the ::util or &lt;package&gt;::util namespace. For example, see https://github.com/google/or-tools/blob/master/ortools/base/status.h. Unfortunately, they don't play well together, so you cannot automatically cast the Status returned by say leveldb to the Status type from grpc. If you want to write code that handles Statuses from both those packages and returns a single Status, you have to write some (trivlal but still) conversion code.
[removed]
This is basically a distilled portable modern version of //base. There is a lot of cruft in //base that is not easy to be aware of.
That's really cool; thanks for the article. Why is not having run-time type information a plus though?
You're welcome, and thanks for reading. :) Some people disable it, so that it won't generate type info for all classes and this reduces the size of the program. Might be not that great win, though. I have nothing against RTTI, just thought that not using it is a thing to be proud of, because it shows that most things about types are known at compile time.
In my test one of the elements becomes moved-from because when `absl::InlinedVector`grows it allocates new chunk of memory and moves elements from old location to this new chunk one by one. If one of the elements will refuse to move (by throwing an exception), we end up in a situation when half of objects already moved to a new location and another half still sits in old location. And we can't recover from this because moving those moved objects back to their original location can potentially lead to another exception. `std::vector` handles this by calling `std::move_if_noexcept` that degrades to copy-construction if move-constructor can throw. 
When you have getters and setters for everything, private _is_ useless. I'm sure for people from Java-land, it's easy to blame the accessibility modifier(s) rather than the real problem.
So, the inlined vecctor will be noexcept movable, if the contained type is no except movable. That's a reasonable choice for a generic class. You should always write your own classes to be noexcept move whenever possible. It's true that vector goes beyond this and is always noexcept movable; that's the benefit for having a layer of indirection. I find your blanket statement to be pretty over the top. The inlined vector is anyway most useful for quite small types like int, double, unique_ptr, etc, which are more likely in general to be noexcept movable.
//base is quite portable as well... so, I would still stay with it.
I see, it makes sense. Yeah, it's not really appropriate to use this in a project where data-loss in the face of exceptions is a problem. But also, it's not invalid to access the moved-from object, the moved-from object has to be left in an "unspecified but valid" state. So, it's not impossible that the program can proceed normally after this happens. But it does mean there is potentially data loss in the face of exceptions, similar to the problems with `std::variant`.
you should be proud of... this is important. In my work, we don't use any code that depends on RTTI, and it won't even compile dependencies since we turn it off for the entire build. As far as I'm aware of, RTTI is a no go in many projects out there, and it is mostly on its way out...
Oh I see, thanks for the reply...
I would be shocked and amazed if Chromium didn't gradually migrate themselves to absl, so you may not have much of a choice.
... I have youtube also... but really, he says many things that people on here never agree with, oddly it's what C++ ACTUALLY IS and why he kept all the old code like a ship at sea collecting barnacles. He's a great writer, his book complements C++ Primer really well. And I think that he's never going to give up on "fixing" C++, he's a true programmer/computer scientist/realist. 
Haha really? I haven't encountered that one before. I got a "... does not support in-source builds" before, when I accidentally tried to build something in source (pressed the wrong button or something).
Congratulations Mr. Stroustrup! Very well deserved. I feel almost bad mentioning this in the same message as congratulating Mr. Stroustrup but ... &gt; Previous recipients include Donald Knuth (2011), Roger Needham (1998), Sir Maurice Wilkes (1981), J A Ratcliffe (1966), Sir Edward Victor Appleton (1946), and Sir Ernest Rutherford (1930). Columbia could really have done a better job here and list some women as well.
G Research has nothing to do with Google, does it? I've never heard of it. Some kind of shop that only hires geniuses?
He was already a C++ wizard and had more side projects on GitHub than 99% of C++ people. So not really a reference point, unless you want to spend 5+ years on hobby/side projects first ;)
Math (and physics) graduates are usually amongst the best and brightest computer science people, particularly if they can code too (in any language, not a specific one). Find out what field would be interesting to you, Google for companies in that field, just apply. Show enthusiasm. A GitHub account with at least _something_ on it will probably help, depending on where you apply. Btw while there's lots of ML jobs in C++ too, it's evolving into more of a Python thing (e.g. TensorFlow).
&gt; An `absl::InlinedVector` is designed to be a drop-in &gt; replacement for`std::vector` for use cases where the vector's size &gt; is sufficiently small that it can be inlined. Am I correct in assuming that InlinedVector essentially implement SBO (small buffer optimisation)? IIRC the reason why `std::vector` doesn't have SBO is because standard requires that move does not invalidate any iterators. Having a small buffer on stack, obviously, invalidates the iterators on move. If that is the case, `absl::InlinedVector` is not a drop-in replacement for `std::vector`. PS: I will still use this because I think that requirement by standard for vector is not very useful.
selling absl::StrCat(), absl::StrJoin(), and absl::StrSplit() is kind of a sad statement for any library and c++ as a whole. Like who on the planet hasn't got those in their toolbox?
this is super interesting to me at an article level. i'm excited to try this out, thank you :)
There's some pretty cool string stuff... StrSplit, StrJoin, and StrCat for example. StrCat in particular is a modern replacement for sprintf. Here's some benchmarks they just announced at the 4:45 talk at cppcon: // snprintf into a buffer. Takes 326ns: char buf[80]; snprintf(buf, 80, "Bob has %d %ses costing %g", 23, kApple, 23 * 0.07); // Someone's C++-ified printf, which returns a std::string so not surprising that it looks // about the same and takes a little longer - 327ns s = StringPrintf("Bob has %d %ses costing %g", 23, kApple, 23 * 0.07); // One modern C++11 way to do it, using std::to_string. Takes 529ns: using std::to_string; s = "Bob has " + to_string(23) + " " + kApple + " costing " + to_string(23 * 0.07); // Another modern way, using ostringstream: at 855ns, the slowest of all: std::ostringstream oss; oss &lt;&lt; "Bob has " &lt;&lt; 23 &lt;&lt; " " &lt;&lt; kApple &lt;&lt; " costing " &lt;&lt; (23 * 0.07); s = oss.str(); // Abseil: only 105ns s = StrCat("Bob has ", 23, " ", kApple, " costing ", 23 * 0.07); ps Why doesn't my 4-space indent stuff format as code?!?
Did you put a new line after "4:45 talk at cppcon"?
On the topic of split, having something may not always be the "best" option: https://github.com/tobbez/string-splitting 
Does anyone know of an online compiler where this library is in the include path?
Show don't tell. When I get a resume, I want to see someone's github on there. I'll glance over the rest of the resume, but the github is the first thing I deep dive into. If I can see that you know what you're doing, that interests me more than saying you used C++ at your last job.
&gt; It took me a long time to understand *why* this can happen ... It's **undefined behavior**. There are no restrictions on what it can (or cannot) do. That's the point of UB.
For anyone interested in the education side of C++, there was a talk at CppCon 2015 which discussed teaching "Modern" C++ to developers. [Stop teaching C](https://youtu.be/YnWhqhNdYyk). The general idea is that the current model of "teach people C, then teach them C++ as an extension" is flawed. The talk presents an alternative approach which sounds pretty reasonable.
This is the ONLY good talk about how to write modern CMake. Too many tutorials teach old hacky ways that might work" but their solutions are either very fragile or will only work under very special circumstances. 
Recently worked in my first optimized code base with GPU programming on cuda and c++. Since then i've been nearly binging a lot of c++ sites to learn a lot of the modern standards, together with a lot of the cppcon videos. I really enjoy bjarnes talks and this one was really interesting to me, as i am usually someone who learns faster by teaching others. In regards to the talk and c++ a few questions, if this is allowed in this thread(?): - beginner packages: Would the Qt framework with QT Creator and CMake make a good starting combo? - when will the rest of the cppcon videos be uploaded? - are there any graphics/gpu devs that can recommend a more intermediate/expert book on software development/graphics/visual stuff with c++?
I agree on the sentiment, especially the last part. With his book you meant the Tour one? And do you recommend c++ primer as a good read?
Viewing the source of your post suggests that your code comments aren't also indented by four spaces.
I wish it didn't bother me, but I really really don't like mixing styles like this :( There is an ISO standard for naming used by the standard library, can't we stick to it like all other languages seem to be able to? Maybe the ship has sailed, but to me this is as bad as doing #define BEGIN {
When they've done something of as much importance they'll get listed, not everything needs a participation trophy.
Backslash as path separator in include.... argh... almost expected to find #include &lt;conio.h&gt; In the implementation...
Qt creator itself is a great ide and you don't have to use Qt. You can use it just for editing c++. It comes with a clang static analyzer built in so you get nice error squiggles and autocompletion. You don't even need to use its cake integration (although it can be handy). For graphics books, there is physically based rendering 3rd edition, and a lot of the opengl books are quite good. 
Oh and the cppcon videos will go up steadily over the next few days/weeks. 
It's important to note that with the PascalStyleNames this library finally closes the loop for C++. Now I've seen EVERYTHING!
I love that Kate Gregory video. She's completely right
Great talk. I want to get involved with making the basic system happen.
Thank you! :)
Define CSV. Do you want a full RFC 4180 implementation?
I don't think so... Everything in there is a watered down version of //base. Check //base/strings for instance. It has so much more, and I'm talking about really useful things, rather than bloat.
The [Michael Faraday Medal](http://conferences.theiet.org/achievement/awards/medals/faraday.cfm) is awarded by the Institute of Engineering and Technology, not by Columbia University.
A lot of what's in Chromium's //base has been split into more fine grained structure than that. Look at absl/strings, for example.
I did look, and that's why I mentioned //base/string. I work with Chromium codebase in a daily basis and I also submit code changes for them every week. I'm telling you: this is a watered down version of their actual code. I'm not saying it is not useful though. I'm just saying that it is not as useful as most of the code they depend upon. // base is really reach, not bloated. And it offers a lot of cross-platform support for your code. For instance, currying through callbacks, task scheduler, message loops, value structures a la {} in python, profiling, histograms, file system, timers, unit testing support, threading, synchronisation, operating system specialisation... I work in a massive codebase that depends on their code, and their code is solid and rich. My take on this repository is that they are putting out there a more digestible version of it, but I doubt they would adopt it as the standard, replacing //base in chromium, as someone else suggested above. I'm saying this because we wouldn't replace //base with absl, since it is not even close to what anything //base offers, even the areas they overlap. On a side note, we also have strong use of //net, //crypto (a sane openssl), and //sql, and all this code is weaved by //base.
Language gives enough tools to make compile-time checked format strings at library level. There are several implementations out there, for example [MPark.Format](https://github.com/mpark/format) (this is the first that come up, there are others, but I don't recall then from the top of the head).There is no need for such a specific language feature. 
The synchronization stuff is there. I am on the Abseil team (speaking unofficially my own thoughts on your comments). There is a lot more which we will be adding in the future to Abseil, but this is, with a couple exceptions, the most depended upon code in Google's C++ code base. Of course it won't have everything that Chromium needs, because that's not its goal -- the goal is to release the most important code externally so that the things which *are* copied by Tensorflow, Chromium, protobuf, etc, can all be disposed of for one central dependency. So Abseil isn't a watered down version of Chromium code, because it doesn't come from Chromium at all -- it comes from internal Google code, of which much of Chromium's //base is a fork. When Titus Winter's keynote from Tuesday at cppCon is released, I'd suggest watching it for more history on why Abseil exists and what it is exactly.
I'm not disagreeing with you... That's exactly what I said in my first comment. I said this was an initiative to provide google's code in a more library-friendly way. However, I'm only saying that it is not as mature as //base yet. I do disagree with the other comment that said that //base is full of cruft though. I know that the owners of base do keep it very clean. There are things like this in base that were not included yet, and it is not cruft: https://cs.chromium.org/chromium/src/base/strings/string_tokenizer.h.
&gt; beginner packages: Would the Qt framework with QT Creator and CMake make a good starting combo? Yup, I doubt there's a software that you couldn't build with this. If you're interested in GPU dev you way also want to take a look at APITrace, very useful for debugging: https://apitrace.github.io/. More generally nowadays GPU dev is more and more removed from "CPU-based" programming languages: you'd try to do most things in shaders. Thus, the orange book ("The OpenGL Shading Language, 3rd edition").
I think Bjarne always had a clear view of what c++ is and should be. I highly recommend reading "The design and evolution of c++" auto, simple template declaration syntax, etc were already in his mind in the early 90s, but the world wasn't ready. It's always nice to remember than RAII is in the language since the very beginning and it's a bit odd that people have been rediscovering that in the past decade. "Fixing" may however not be the appropriate term, features won't be removed, compatibility is one of Bjarne strong commitment. And arguably, the most fundamental reason to c++ success. However, he is trying to add way to simplify how people write code and teaching is a big part of that. Students will use the subset of the language they are familiar with, is our (the c++ community) responsibility to define that subset for them. 
although it says c++11 compliant, google's c++ style is really medieval.
But that's not really the point. While the compiler can in principle do anything, it certainly doesn't act at random. What's interesting is that calling a never called function seems like random, unreasonable behaviour, but there are actually a small number of logical steps that lead to this outcome.
Sorry, you misunderstood. The **news article** is on the Columbia website. They **listed** (not awarded) a number of recipients, and all are male. I said they could've done a better job at **listing** these previous recipients and include at least a female one as well. I was not talking about awarding the medal at all. [Having checked now](https://en.wikipedia.org/wiki/Faraday_Medal), it seems though there are not many if **any** female recipients of the medal - Am I missing something here? We have loads of really famous female people in Engineering and Computer Science.
"I have definitely had people, every year on the course, freshmen coming out of Texas high schools, who are absolutely convinced that they are smarter than I am on the topic of programming. In this particular case, I am reasonably sure that they are wrong." :D
&gt; "expressive" (which I take to mean "concise yet readable") I don't think this is what expressive means; expressiveness in programming is being able to carry the most semantic information in the least characters possible. eg `2+3` (or `+ 2 3`) achieves maximal expressiveness for the task of representing an addition. Likewise, doing asynchronous operations with coroutines is more expressive than manually sending function calls in another thread through a message queue, and lambdas are more expressive than manually-written functors. 
Sorry, I meant practice and principles(PAP) using C++, using these two together really fills any gaps you may have in wanting to lean, it's like the books belonged together in a odd way. I use the C++ primer for clarification or a reference, and the PAP book for all the exercises, drills, and, the "try this" and theory that primer does not have, to focus your skills. This is all relative to how I'm learning, but both books use C++11 and both books are really well written to show how any number of ideas can work together (C++ primer explains rvalues and lvalues better but PAP shows segments in a more in depth view and realistic view with theory and code together in one book. They just complement each other. Idk how else to say it. 
The doForAllMembers lambda argument being a template just blew my mind. I will need some time to digest that. Excellent article !
See also: boost::container:small_vector
[removed]
Thank you! Yes, I was quite shocked when I got it working. :D
This looks great! Thanks for sharing and licensing under a permissive license (MIT)
My first language to learn was C++ (besides a game-specific scripting language for modding) - never had to learn C first. I can agree completely.
Same people not liking my comments, use my ideas. This world is so silly. Seeing all those negatives makes me so much more happy then seeing a positive growth in my comments. It means I hit a sweet spot in human nature. 
The fact that MPark.Format needs to use a macro shows that vanilla C++ (sans preprocessor) doesn't currently give you enough tools to do this. Ironically, with the compiler extensions in GCC and Clang, C `printf()` actually offers better compile-time type safety than fmtlib can manage. What is needed is proper support for compile-time strings, as proposed by Louis Dionne recently. I'm not sure of the status of it though -- can anybody give an update? 
I'm not sure what the "subtly incompatible" dig is about -- fmt's default formatter is compatible with Python's formatting language, but it offers a `printf()`-compatible formatter as well. As to a `scanf()` replacement, yes, it would be nice to have this as well eventually.
I think it was Scott Meyers who explained in one of his books that C++ is best viewed as a collection of several languages (C, Templates, STL, OO-parts) and so on (or like you said, one could call them "subsets"). And looking at it like that really helped clearing up the oddities and "inconsistencies" for me.
How if it's community based? How could he have known what C++ should be? He's a scientist not a time traveler. He's said himself, it's evolved with the user base in mind, and if the user base changed over time, so did the language, so he could not have known. He might have had an idea of what He wanted, but not the language. The language changed dynamically not statically. over time not even the inventor could pridict what it would turn into... as he says in all his videos and talks, and articles, no one will ever know everything about programming, so how could he himself. And you completely missed what I sad about "fixing" C++ in context. It's understandable, but its like what you were saying but different. Keeping compatibility but "fixing" parts to make it easier to learn. Is what I meant. 
Excellent thing you did not ask me for advise, I would have told you not to waste your time !
Well, a language is more than a set of features. There are a bunch of underlying goals, constraints and design philosophy. Features are derived from that. C++ evolves to better express these core ideas better. And, as a matter of fact, type inference with auto was implemented in 84 in CFront by Bjarne. That explain was the auto keyword was reserved already - It's 98-03 meaning of 'automatic storage duration' wasn't useful at all. People at the time thought that was black magic sorcery and too confusing to be used in a proper language, the feature was therefore removed. In the same way, Bjarne has long argued that the current template syntaxe was needlessly complicated and that the compiler didn't need all that verbosity. the committee is still unsure about that. I don't think people agree on the usefulness and viability of the short form of function-using-concept declarations... ( not sure what the latest paper/development about that is)
We are saying the same thing in different ways.... this is way to common in C++, for people to agree, and not realize it. It's our weakness as coders. Keeping compatibility but making it easier to learn is what I meant by "fix" it's what he has said himself many times, for the fucking idiots who don't agree. Did anyone watch the video? Like actually watch it?
So much this. She speaks so simple, yet so right things! When I first watched the video, I was a bit ashamed that I always considered a bad idea to teach C++ prior to C...
Glad you find it interesting. I'm happy to share my ideas without restricting people.
Haha, yeah, I wondered if I wasted my time working on this or not. Even if I didn't get the results I did, it'd be still worth it, as I've learned a lot about complex templates.
Previous discussion of this code snippet: https://www.reddit.com/r/cpp/comments/6xeqr3/compiler_undefined_behavior_calls_nevercalled/
[removed]
That's a very narcissistic perspective... All the downvotes really mean are that your comments are off-topic and do not contribute to the conversation. I would downvote you even if I agreed with you.
[removed]
This is exactly what I want to do too! :-) Thanks for taking the time to share your info.
[removed]
And dangit, that's about my favorite part of the language. Everyone can have their own 10% and they can all interoperate (to some extent..) without using clumsy FFI.
r/cpp is not for that.
Yeah, it's easier to add `/build` to `.gitignore`.
Sadly, yes. Here is a very prominent example: https://github.com/WebAssembly/binaryen/#building
Thanks a lot for the info! The missing libs have been submitted. (https://github.com/pierricgimmig/orbitprofiler/commit/3bcc3ddf05e57784939daba838d82ef5573d3aa1). The hard coded paths in OrbitQt are next on the list. The goal is to make the compilation as easy as possible. The remaining issues should be fixed in the coming days. Thanks!
[removed]
Irrelevant and off-topic. Go away. 
[Image](https://imgs.xkcd.com/comics/free_speech.png) [Mobile](https://m.xkcd.com/1357/) **Title:** Free Speech **Title-text:** I can't remember where I heard this, but someone once said that defending a position by citing free speech is sort of the ultimate concession; you're saying that the most compelling thing you can say for your position is that it's not literally illegal to express\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1357#Explanation) **Stats:** This comic has been referenced 5167 times, representing 3.0545% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dnkulit)
[removed]
If you are going to label an entire state as uneducated and fundamentally stupid, at least learn how to write properly before showing off your superior intellect. &gt; As an example, wanting to Suscceed from the USA It is NOT Suscceed, it is secede. &gt; Prove me wrong. You are not Texan... I'm fairly sure this in itself makes their average IQ line higher.
This whole thread is you having a complete breakdown because some people disagreed with you, and the resulting word salad to try and justify your anger. I mean, it's actually quite entertaining, but for your own sake I feel the need to point out what's happening. 
This is really, really amazing. I've wanted something like this for simplifying a jni bridge. How does this handle inheritance? Just define all meta for all derived classes? I don't expect classes with inheritance to be used for models like this - just wondering. 
If that's what you think, I'm OK with that, but your comment is only somewhat true, the breakdown is because I quoted him without quoting him from his videos just to see, and people still disagreed. So I just decided fuck it, it really does not matter what was said, thank you though for a normal reply. 
Wow! _speechless_ :\
So ya you are somewhat correct. I'm typing on a tiny screen and going back a few letters is not easy, so word salad is a good descriptor. But I did start off giving real comments, but it turned out not to matter. 
And I am actually bored though. And did decide to troll as intended.
OK You are right I'm an idiot. And I've done nothing with my life, I've saved no lives or improved them, In any way, you are absolutely right, the world would be better without people like me as I'm sure you never used anything I designed. 
[removed]
I went to both of Titus's talks. I think that to a large extent, Abseil is supposed to be a departure from that.
[removed]
Your comment has been automatically removed because it appears to contain profanity or racial slurs. Please be respectful of your fellow redditors. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Vulgar%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/72o44u/cppcon_2017_bjarne_stroustrup_learning_and/dnkwzak/?context=3.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Great! Your right again! Keep it up. Oops edited this one also! This is also an edit. This is also an edit. This is also an edit. Your right takes up so much time when your bored. That was an edit, so is this all I have is time. This is also an edit.
Doesn't Microsoft use that style?
This is also an edit.
[removed]
Not having to maintain separate copies of things is a pretty powerful motivator.
You can be Mr Torlvads his Excellence himself... I don't care.
[This](https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528) is the classic text on computer graphics. It's been at least 10 years since I touched it though, so I'm not sure how up to date the latest edition is.
Unfortunately, such a design would be incompatible with run-time localisation, which is obviously required in quite a few string formatting use cases. This stuff is all very interesting, but personally `QString::arg()` is the only string formatter I'm likely to be able to use for a long time.
I still try to avoid using it, tbh, but it does have uses when shortcutting away something like `std::experimental::filesystem`, and so long as you keep it in function bodies you're pretty safe Something about `using namespace std;` still upsets me though, mostly by making me a bit anxious
I just mean that a scanf replacement, unless it is developed together with a printf replacement and comes in the same package, has a chance to be incompatible with said printf replacement. 
I could definitely use code reviews: I'm one of two C++-focused devs here, and the other one is mostly busy setting up automated build and test systems and improving our embedded work with C++ in key locations. Ultimately, I'm the only one doing application dev and have a worrying lack of oversight: plus, code reviews are a great place to learn. Also agree on Effective Modern C++ being great, things like `std::async` and `std::unique_ptr` along with move semantics have been blowing the minds of our EEs and embedded devs as they move to C++. How long did it take you to get to senior dev, in terms of how you felt? I'm only 21 so I've still got loads of time and loads of learning to do, but I'm trying to figure out how to evaluate and describe my abilities.
A tool should scan the codebase and extract format strings to be given to translators. Then a tool can verify that translations are compatible with the original.
&gt; Ban me Ask and ye shall receive.
An external tool can verify, but I'm not trusting enough to let one bad translation crash my program, so run-time checking would still be necessary. (Also, any formatting system without support for positional arguments isn't going to work for internationalisation anyway.)
I'm not sure, my first job was not at NVIDIA.
I was already a huge fan of your ImGui tutorials, for helping get me up and running with that library (plus, it was graphics API-agnostic, which isn't always the case): this is even cooler though! No RTTI, doesn't need modifying source code (super nice for my use case w/ legacy code), and no macros like some serialization solutions. Cheers for releasing it with a permissive license, too!
See also the note on Abseil exception support here: https://abseil.io/docs/cpp/guides/base
&gt;`j=j-1;` Welcome to /r/c=c+1
Stop teaching C *if you mean to teach C++*. C is still legit.
&gt; Also, the order of linking static libraries (unlike object files) is significant. What's the consequence of changing the order?
Great talk. I have taught C++ to small groups (bootcamp of less than 25 people) a few times, and I still do, Some of the first things I do for my students are: * Download the latest available Compiler. (The last set of students I took earlier this year was with GCC 6.3 and Clang 3.9). * I show them how - (but to ensure compliance, also go through each person's computer) to **setup a default** compiler flag for their IDE's. The flags are: `-std=c++14 -pedantic-errors -Wall -Wextra` * Every code of theirs **must** compile without warnings. * After teaching them about abstractions, libraries, and Code testing... I make them `clone` and install [Catch framework](https://github.com/philsquared/Catch) to unit start testing their code. * Assignments are hence graded by passing **all** my secret Catch unit tests... * While I teach them Object lifetimes, RAII and Storage Durations, and using `std::vector` right off the start, I teach program control flow using debuggers... My favorite is teach basic basic algorithms like Bubble sort, merge sort - this teaches them how to use C++ debuggers from the very early beginning... Rather than making me vote to close their "why isn't this code working..." Stackoverflow questions... * With respect to getting help, I teach them on how to use cppreference and Stackoverflow.. Also, For the sake of non-obvious compiler errors, I teach them *"How to copy relevant compiler errors into Google and Bing search engines"*... :-)... and use relevant answers... I like to give such "Fix this code" assignments, such as order of class *member data* with respect to initializing them in *member-initializer-lists* ... by - First compiling the code, - Either use your experience, or Search the internet for the errors and warnings generated by the compiler, as taught in class of *"How to copy relevant compiler errors into Google and Bing search engines"*... Most times I like to give different assignments that generates new warnings... - in my experience, anything involving `class-templates` or `function-templates` is a source of many many different kinds of errors... There's a systematic way I teach them on getting help with respect to these kinds of errors - using the stack of compiler errors generated. Maybe I should blog about this?? ---------------- After watching this, I plan to introduce 2D graphics, next time I am opportune to teach (especially if there are newbie programmers)... [SFML](https://www.sfml-dev.org/index.php)??. - I also plan to introduce static analyzers and using sanitizers along with my class...
&gt; In general we will try to support exceptions in reasonable APIs and designs. We are, however, opinionated about where exception-flexibility is trumped by performance. We will try to be clear about where exceptions are a bad design choice and mark things noexcept when possible. Do not confuse conceptual support for exceptions with endorsement of exceptions in all places - if your hash functor throws, you‚Äôre on your own. Basically what I said.
Why would I micro benchmark something instead of benchmarking it? That sounds like recipe for disaster and myopic focus.
How are you defining the distinction? A micro benchmark IS a benchmark, so there's no either-or relationship. 
If they are the same thing, why specify micro? I think most people understand instead of being pedantic. Why intentionally benchmark something that is very small, runs very fast, or both?
If you don't already, then you should definitely come along to [C++::London](https://www.meetup.com/CppLondon/) (and if you do, then we may well have met in person :)). Unfortunately the next meeting isn't till the end of October, but I can highly recommend it. The talks are usually very interesting, and afterwards you can go out for a beer with awesome folks like /u/SuperV1234, /u/jackie_kay and /u/olipro. Well, awesome folks like Vittorio and Jackie, anyway... ;)
Well you may as well have said "why write a unit test instead of a test", so no, I didn't understand what you meant. They aren't the same thing - one is a type of the other. The reason for writing a micro benchmark is to gain insight into the characteristics of a (usually) small piece of code which is considered critical to performance in a wider context. That is, by focusing attention into that small area, benefits will be seen more widely. Yes, it is definitely a difficult area with pitfalls and generally quite poorly understood, but it is not to be dismissed on that basis. It's a critical tool for anyone interested in performance.
fmt is useful to format strings, it does not replace output stream operator because it does just one part of what stream operator is used for, e.g. reading a stream data in specific format can be done with an algorithm, a stream iterator and a container to read to because stream iterators are based on stream operators when reading data, not sure how fmt would handle such operations. I think when committee talks about good streams replacement it is meant to have same STL oriented design meaning that it can be combined with iterators, algorithms and containers easily. Right now fmt is just a string formatter and I don't think is need to ask it to do more than it is designed to do.
Wouldn't that imply that a micro benchmark is more accurate than a macro benchmark? 
Additionally, if you're writing a library, your only option may be to write microbenchmarks because you don't have a larger more integrated example of your code's use to use when measuring performance. A suite of small, quick microbenchmarks allows you to run them as part of continuous integration, and spot when you cause a performance regression which will negatively impact your users. 
No. One of the subtleties of measuring performance is that the characteristics of a piece of code can change when placed in different contexts. This is one issue with microbenchmarks. There are cases where a change to a function can cause no change in a microbenchmark, but screw up your application performance, for example by making the function larger and affecting decisions made by the compiler regarding inlining. This is why a multi pronged approach is needed if you're really serious. But as with any kind of testing, it's a matter of degree and availability of effort. 
Needs more jpeg
or `llvm::small_vector`
Thank you! And thank you for the question. I haven't thought about inheritance previously, but seems like there's an easy way to get it working! [Here's how you can do it](https://gist.github.com/eliasdaler/45bf3f583cd4a41019b9802c198e6f41). I'll think if there's any clearer way to do this, but I'm pretty satisfied with what I managed to find out. There's additional challenge in automatically picking up all base classes in serialization/deserialization procedure, but I'm not sure that it's possible or if it'll be the behaviour people will expect. In my example you'll have to register things explicitly, but that's a good thing in a way! :) 
Or `folly::small_vector`. I smell something that needs to be standardised.
Ugh, needs list initialization: ,`vector&lt;int&gt; a { 1, 2, 3 };`
Bad for non-fundamental types. It's better to move the objects: a.insert(a.end(), std::make_move_iterator(b.begin()), std::make_move_iterator(b.end()));
Thank you! I'm glad that my tutorials help you so much. Please tell me if you have success using my library for something. It's obviously not complete and there are lots of things to add, so any real world usage will help the library improve quickly. :)
Doing something and doing it well are very different things. The Abseil string routines are very good.
I dislike libraries which boast about performance without providing any evidence. I'm not just going to trust you, and I don't have time to test every alternative. Apparently the keynote may have had some numbers - these (and associated automated benchmarks) need to be included in the repository. 
If you want fairness, you should aim for the *equality* of the *quality of life*... You'll find out that someone in the developing/poor country actually needs more cash in order to have the same quality of life (if possible at all) as another one living e.g. in Switzerland...
Abseil team member speaking unofficially here. We want to have Status in Abseil, but this will take some time and care due to the difficulties you outlined.
or: for(auto&amp; i: b) a.push_back(move(i));
Here are the promised materials: GitHub project: https://github.com/Caphyon/clang-power-tools PowerShell scripts: https://github.com/Caphyon/clang-power-tools/blob/master/ClangPowerTools/ClangPowerTools/clang-build.ps1 https://github.com/Caphyon/clang-power-tools/blob/master/ClangPowerTools/ClangPowerTools/sample-clang-build.ps1 Visual Studio Marketplace - "Clang Power Tools" https://marketplace.visualstudio.com/items?itemName=vs-publisher-690586.ClangPowerTools 
I posted the materials, check this thread.
Qt, EASTL....
The math background is a great thing for C++, for sure. However, it's not worth the time and resources to train you how to code. I think most places view a github account as a portfolio of your work, so try putting some stuff up there. If you ever took a course, mention that. I didn't need some huge extensive background, I just didn't need hand-holding.
I work on the strings part of absl, so I'm really curious what you miss so much about //base/string. We thought we got the parts that are actually important... and there's a lot of duplication that we tried to leave behind when making absl.
I'm working on a project where I can only use gcc-4.8 for cross compilation, but I compile unit tests locally using gcc-5.4. DAK if its _possible_ to set target compiler flags for all unit tests with cmake such that I can use std=c++14 for test code, but std=c++11 for production code? It would be awesome to be able to use c++14 libraries in test code without needing to upgrade my tool chain. 
If you're not going to trust absl anyway, why would it matter if it included benchmarks? (But see my post elsewhere on this discussion for some rough numbers.)
I never said I wouldn't trust it on any basis. The only other major aspect would be on correctness. It's much easier to trust correctness because it's much easier to spot incorrectness, test suites are included in the Abseil codebase, people report issues, and so on. Performance is a continuum, so isn't subject to the same kinds of checks. 
No, this is worse. With random access iterators, `vector::insert()` can see how many values it will be getting and only needs to do a single resize (and then a single `memcpy()` if the value type is trivially copy/moveable). With a loop, each value must be copied/moved individually, and the destination vector will potentially need to resize itself many times as it doesn't know the final size in advance.
String tokeniser: https://cs.chromium.org/chromium/src/base/strings/string_tokenizer.h string pattern: https://cs.chromium.org/chromium/src/base/strings/pattern.h stringprintf, which I cannot do without: https://cs.chromium.org/chromium/src/base/strings/safe_sprintf.h These are the ones I can think of the top of my head. All the UTF8, UTF16 support.... case insensitive comparisons, trimming... I hope you don't take this as actual criticism. I'm just saying absl is not there yet for me, as a replacement of //base.
Ah yeah, that aligns with what I expected. Maybe hide the fact that it's a tuple a bit behind a members_concat or a constructor taking a tuple of members and a variadic list of members to concat to it.
This is my library with read/write symmetry. https://www.codeproject.com/Articles/811387/Cplusplus-New-Text-Streams Pseudo code below // Writing ostm &lt;&lt; name &lt;&lt; age; ostm.match("Name:{0}, Age:{1}"); ostm.write_line(); // Reading istm.read_line(); istm.match("Name:{0}, Age:{1}"); istm &gt;&gt; name &gt;&gt; age;
I use Stroustrup Mixed_case whenever anybody lets me. Very disappointed that Google decided that wasn't good enough here.
&gt; If they are the same thing X is a Y doesn't imply X == Y. Microbenchmarking is for after you find out where the problem is in your full application, so you can focus on improving the section of code that was identified. It's faster and easier to understand the performance implications of the changes in isolation before you go back and plug it back in to your main code. Microbenchmarking is the process of getting an isolated benchmark into a situation where it can be timed in such a way that the results are meaningful to the full application without running the full application. Say, for example, that the full application requires a graphics library and accelerated GPU support, but the part of your code that profiling identified was problematic is pure CPU code. This allows you to do benchmarks offline, perhaps as part of a regression suite, without having to worry about making sure you can create a graphics context - which is likely not available on a build server.
If I've watched Chandler's talk on microbenchmarking about 5 times over, do you think I'll learn a significant amount by attending this talk? I'm volunteering that morning, so I could be the guy holding your time cards for you :)
The C++ and English in this blog is quite... well... below standard.
For what it's worth, we have benchmark code, but its release is blocked on compatibility with all the platforms we support.
1: Just curious: do you actually have a move operator that sometimes throws? 2: I've filed a bug. Thanks for the report.
You would think that at least here on proggit people would not be badly failing logic. I say "badly" because you persist after being explained where you went wrong.
not everybody on this planet is fully fluent in English.
&gt; I teach them "How to copy relevant compiler errors into Google and Bing search engines" that's honestly the n¬∞1 thing people should learn.
Assuming that is the semantics you want and your types are cheap to move (fundamental types aren't the only ones that don't profit from it). You also might want to clean up your vector afterwards, as it is now full of moved from objects. Honestly: Yes it is an optimization, but it also turns a concise, readable and correct piece of code into a construct you imho have to spread out over multiple lines for it to stay easily readable. Hence I tend to use those move iterators only if I really need them or hidden behind a function - not by default (and I'm a bit ashamed to admit that).
&gt; it also turns a concise, readable and correct piece of code into a construct you imho have to spread out over multiple lines for it to stay easily readable. Hence I tend to use those move iterators only if I really need them or hidden behind a function If you care that much about line length then you should be using ranges, with which this becomes a complete non-issue: ranges::insert(a, a.end(), ranges::view::move(b));
On the other hand, UB can also prevent you from calling a dangerous function, so it evens out on balance. https://godbolt.org/g/MRpskr 
Many Microsoft's containers may throw on move construction, see /u/HowardHinnant 's summary [here](http://howardhinnant.github.io/container_summary.html)
I'm far from a CMake expert, but I think it should be possible to use per-target properties for this, i.e. something like target_set_properties(main_exe PROPERTIES CMAKE_CXX_STANDARD 11) target_set_properties(test_exe PROPERTIES CMAKE_CXX_STANDARD 14) although I haven't tried it so take this with a pinch of salt.
Detecting bugs and errors through testing and generally is crucial to each working programming. There are also programs that might help doing that, such as checkamrx. It is, anyway, important to test your program. Good luck.
I would definitely consider Qt Creator also because it is very easy to set up. But even though I have and still use Qt a lot I would not use it as a beginner package even if it makes graphical code super easy. Qt has a small collection of quirks and language extensions which might color new students a bit much early on. As a package to move beginners to intermediate status I think it is great because it would allow you to give a student the fun experience of taking their code and making it do fun things on screen. If you want to go visual first with C++ code it is however a good bet for an easy start, if something like imgui or something is not for them.
The whole subject is vague and theoretical, not to mention I was only asking questions. I think 'failing logic' might be a bit of an over reaction. If something takes up the majority of program time, a sampling profiler is going to sample that part most of the time anyway. Not only that, but the complexity of CPUs means that the smaller something is, the more likely it is to run differently in the full context of a program due to cache and other CPU features. Given all this, along with no one actually linking benchmarks, examples, or real data of any kind, I think asking a question or two isn't so unreasonable. Try not to get carried away.
Use [target_compile_features](https://cmake.org/cmake/help/latest/command/target_compile_features.html) to set a target's standard: target_compile_features(test_target PUBLIC cxx_std_14) target_compile_features(app_target PUBLIC cxx_std_11) 
You don't need to write throwing move operation for this problem to happen. TL;DR move does not move. If in generic code you have `a = std::move(b);`, it does not mean it moves anything. It very well can make a copy if types do not have move operations at all. Another (but still the same) example - you write your new shiny class today and you want your move operations to be noexcept: class new_class { cpp03_class m1;//prehistoric class from pre-C++11 era(or you are at Windows as encyclopedist explains) cpp11_class m2; new_class(new_class &amp;&amp; other) : m1(std::move(other.m1)), // copy construction called, can throw m2(std::move(other.m2)) // move construction, can't throw, but who cares? {} }; 
Hard coded paths have been removed: https://github.com/pierricgimmig/orbitprofiler/commit/305685bb83277aa36a92e928a048594c5f59ff85
The cxx_std_14 / cxx_std_11 feature flags were only introduced in CMake 3.8. If using an earlier version you have to set specific features which you know will activate that C++ version.
Catch is easy to use but doesn't have a lot of features
For doForMember you can do better. Take two callable objects; a filter, and a function. If and only if the filter's decltype is truthy, call the function. Then write a type filter helper. template&lt;class T&gt; struct type_filter_t { template&lt;class X&gt; constexpr std::false_type operator()(X const volatile&amp;)const{ return {}; } constexpr std::true_type operator()(T const volatile&amp;)const{ return {}; } constexpr type_filter_t() {} }; template&lt;class T&gt; constexpr type_filter_t&lt;T&gt; type_filter{}; Then we write `run_if`: auto run_if( std::false_type ) { return [](auto&amp;&amp;..)-&gt;void {}; } auto run_if( std::true_type ) { return [](auto&amp;&amp; f, auto&amp;&amp;...args)-&gt;decltype(auto) { return decltype(f)(f)( decltype(args)(args)... ); }; } Now we can do: meta::doForAllMembers&lt;Person&gt;( [&amp;person](const auto&amp; member) { auto should_run = type_filter&lt;std::string&gt;( member.get(person) ); run_if(should_run)( [&amp;](const auto&amp; member) { if (member.getName() == "name") { std::cout &lt;&lt; "Name starts with " &lt;&lt; member.get(person)[0] &lt;&lt; '\n'; } }, member ) } }); or even meta::doForSomeMembers&lt;Person&gt;( type_filter&lt;std::string&gt;, // lambda that only gets called when the member is type std::string ); Embrace value-style metaprogramming. 
I think by "test runner" he surely means the thing which calls your test executables for you? In which case ctest is fine. Tricky to get working with remote devices e.g. run tests on a phone. But otherwise fine, it "just works"
&gt; and it is mostly on its way out... could you elaborate on this?
gnu make and a directory of test executable works fine.
In [`build2`](https://build2.org) we have the `testscript` language. The main advantages would be concise syntax, parallel execution of test cases (note: *individual* test cases, not entire tests -- this is a big deal), support for regex-based output analysis, and portability (works on all major platforms). If you've seen the testing frameworks in GCC and Clang, `testscript` is like that just general-purpose. The [Introduction](https://build2.org/build2/doc/build2-testscript-manual.xhtml#intro) would be a good place to get a quick feel of what `testscript` is about. If you want to see some real/non-trivial examples, check the [`bpkg` (package manager) tests](https://git.build2.org/cgit/bpkg/tree/tests).
I like how LLVM guys do it. They use both lit[1] and FileCheck[2] in combination, which allows for regression tests. You have a test/ directory, in which you put subdirectories with test files for FileCheck to consume, and a configuration file (written in python), then you run tests with lit. Although these tools are kinda ad-hoc for their infrastructure (they test parser and codegen output), it may be used for programs that generate parse-able output just as well. [1] https://llvm.org/docs/CommandGuide/lit.html [2] https://llvm.org/docs/CommandGuide/FileCheck.html
I was trying to put together these tools and I was surprised by the fact that it won't work if you don't have stdafx.h/stdafx.cpp in your project. Is this intentional? Unfortunately I am not present at CppCon so I had to make sense from the materials posted of Github and the slides. So far I could not make it go through my files due to our project lacking PCH, although it's the powershell scripts are a good blueprint of how to potentially adapt it. 
&gt; IIRC the reason why std::vector doesn't have SBO is because standard requires that move does not invalidate any iterators. This can't be true because `std::vector` supports allocators with and without POCMA. --- EDIT: It is true, but check it out: http://en.cppreference.com/w/cpp/container/vector/operator%3D &gt; If `std::allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value` is `true`, the target allocator is replaced by a copy of the source allocator. If it is `false` and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must move-assign each element individually, allocating additional memory using its own allocator as needed. That is, if POCMA is `false`, on vector move assignment the vector elements are moved into the allocator of the target, so... if you have iterators to the old elements, they are not invalidated... but... they point to values that have been moved from (that is, they are not the same elements) and are in a valid but unspecified state. This can lead to a lot of FUN (as in, undefined behavior) if you then call some methods on those elements that have preconditions. TL;DR: the iterators are not invalidated, but they point to different elements, and these elements are in a dangerous state. C++ never disappoints.
Does build2 support clang on Windows already?
Last time Titus went on stage at CppCon, he mentioned the uper duper code explorer &amp; indexer google had internally and google would open source that. They did, I think, publish bit and pieces, but I don't think it's usable yet ? In the same fashion clang-format and clang-tidy are cool, but I don't feel they are the whole story. I mean, are these tools able to work on large project effortlessly today ? I'm not really confident to use clang-tidy "at scale" because it works on pre-processed files. Dig google solved that ? Or does google has much better tools internally that they are unwilling to publish ? These talks are always along the lines of "Here at google, we refactor 250 millions lines of codes on a daily basis with confidence. Here is how you can rename a local variable". Where is the missing piece ?
CTest because it comes with CMake and I don't have to install anything else.
Never understood complains about readability of iostream: in other languages people like string interpolation.
Better late than never! Here is the link to the post about the talk and you should be able to access the video there too: https://www.think-cell.com/en/career/events/2017-08-22/
You should throw in a structured binding, a string_view and some template deduction. Then you're all set.
I love [doctest](https://github.com/onqtam/doctest/). It‚Äôs fast, it‚Äôs single-header, you can put your tests adjacent to your code if you want, and you can set a compiler tag to leave out all test code. Test names are also arbitrary strings, rather than having to conform to naming rules.
And there will be [**a talk on CppCon 2017**](https://cppcon2017.sched.com/event/ba8f3acbdd972c2c49e9579c2d2cf122) about it in a few hours :)
In your first post you're making a mistake of implying that micro benchmark is not a benchmark. When the other dude points it out, you persist. Come on...
I am pretty sure it does (and if there are issues, report them and we will fix'em). In `build2` there aren't any hard-coded compiler/platform assumptions and we query the compiler for things like target architecture, search paths, etc. Though the target might have to be adjusted for Windows (not sure what Clang reports as a Windows target triplet).
I hear this thrown around a lot, but I've done some real world tests and found it to be pretty much meaningless. The MT only reseeds rarely, so it's extremely fast almost all the time. I've found the speed with other PRNGs to be nearly the same (with MT being faster in many cases) while also having much higher quality. `minstd_rand` for example has terrible quality, and is really only slightly faster than MT.
`fct.h` (also works with C) and running with CTest.
Been using Emacs Cmake C++11 on Arch. Recently started moving to sublime text
&gt; When Titus Winter's keynote from Tuesday at cppCon is released, I'd suggest watching it for more history on why Abseil exists and what it is exactly. The talk has been brought online: https://www.youtube.com/watch?v=tISy7EJQPzI 
This is an exciting initiative. I must say I find the API interesting. A deeper dive might find niggles later on but it is good to see a C++ UI library that does not use Qt style (and I partially make a living writing Qt code right now). A very multiplatform boost / template metaprogramming UI library in C++ would be something to behold. And yes I am sure I could find more examples if I went looking but many of them have APIs from before C++11/14/17. 
"Tools don't have impact" -- I stronly disagree. A super-awesome language without an IDE will never see the same levels of adoption as a language that comes with usable tools for debugging, refactoring, and all those other myriad wonderful things.
On FreeBSD I can install many GCC and Clang versions in parallel on the same system, as well as other compilers, without there being any conflicts. Likewise on various Linux distributions which provide multiple versions. As much as virtualisation can be wonderful, I think it's a bit of a bandwagon where everyone is using it whether or not it's actually necessary. You don't need virtualisation to test a compiler. Just install it into a prefix of your choosing. 
I don‚Äôt want to engage in an argument about something so boring... if you don‚Äôt agree with my point, that's alright.
&gt; any formatting system without support for positional arguments isn't going to work for internationalisation anyway While it is not _that_ bad in practice - yes, positional arguments are very-nice-to-have for i18n, and {fmt} does support them too :-) (as "{0}" etc.)
See ui/example/cpp11 folder for C++11/14/17 examples. Code ui/example/*.cpp is a demo of integration with other Boost libraries.
Oh I noticed them :) I am reading through a few of them right now. I think my main take away right now is that there should be some way to interact with the event loop to include non-UI objects or rather events from other threads that the UI should react to into the event queue. If that exists then cool :)
That already exists and called boost::ui::call_async() function. Also there is a usage example in ui/example/thread.cpp :)
&gt; to type less. Ah the age old tale of optimizing for the wrong thing.
If we're hand wringing about unity builds and `using namespace ...` shouldn't we also be hand wringing about unity builds and things with internal linkage in general?
That is useful. Ah very interesting library, great effort.
Thanks :). It is pleasant to hear this.
Thanks for the heads up :)
Thanks, that's good to know, and I appreciate this is a project with long term commitment, so take this as encouragement to get those benchmarks portable and published. I think it would be beneficial. 
Thanks for the feedback. Sorry about that. This is a limitation of the current PS script. It tries to optimize build speed by always trying to make a PCH. Will definitely fix this issue ASAP, by making PCH optional (depending on your VS project settings). A fix is comming... stay tuned. (watch the GitHub repo).
It depends on what dialect you choose. The default is ECMAScript which has features that can't be implemented with a DFA/NFA, so it can't possibly be linear. (If you can come up with an algorithm that matches regexes with backreferences in polynomial time, congratulations, claim your million dollar prize, as it's NP-complete.) But if you use a different dialect that doesn't have features that require a backtracking implementation (like backreferences or look-around assertions), then potentially you can get a different implementation strategy. 
Are you not confident in using clang-tidy as a static analysis tool in general, or being used to provide easy upgrades? As for the former, its pretty solid. But it requires no trust, you just run it along side whatever static analysis tools you have and see if it reports anything interesting. As for the later, I don't see how it actually solves the easy-update problem. It identifies interesting patterns... but how much work is there, and is it even tractable, to then be able to automatically alter the code?
Agreed.., the talk and his answers on questions sound quite arrogant, but to me his words are not backed up by actual tools. I am curious what the abseil library will bring, a quick scan didn't show anything that i would use in my day to day coding, but that could change later on.
I also noted that thing. It could be that I am not a native english speaker, but the talk as well as answers had a tinge of smugness associated with it. Not reading too much into it though :) 
I don't think I ever said a micro benchmark wasn't a benchmark. The real question is why you are so upset, yet when I point it out, you persist.
So from what I gather this is an abstraction layer over wxWidgets 3.0? A few screenshots would be nice too. Defining the layout is done interestingly though it is a bit verbose like needing to call .layout() on everything.
Src code on github has scripts for bazel file system. Does anyone know how to use it with your own build system?
Could you give hints where to find more?
Yes, only the property you need to set is [`CXX_STANDARD`](https://cmake.org/cmake/help/v3.9/prop_tgt/CXX_STANDARD.html) (without `CMAKE_` prefix)
Why not using boost.asio's event loop ([io_service](http://www.boost.org/doc/libs/1_65_1/doc/html/boost_asio/reference/io_service.html)) directly ? it already has everything needed and more (and hopefully will be in standard C++20! https://github.com/chriskohlhoff/networking-ts-impl).
Yes, Boost-like API on top of wxWidgets. It's odd that wxWidget is not mentioned in the post.
Just use range-v3.... zip iterators cannot work properly with the STL... range-v3 has first-class support for proxy iterators and the whole library works with them.
I'm not familiar with boost.asio yet, sorry. I'm thinking on better integration with this library.
Boost.UI in comparison with wxWidgets has better API, it is more compatible with C++11 and it was integrated with other Boost libraries.
Careful reading of the standard reveals them. For a recent one, search C++17 for the words "cats" and "dogs"
wxWidgets API not exposed into Boost.UI library interface and I would like to omit stereotypes about wxWidgets.
&gt; sound quite arrogant He is not arrogant, he is just talking on a level that most of us are not used to be part of. The guy is heavily involved with the biggest C++ codebase in the world. This library alone is touching in a quarter of a billion lines of code. What do you all expect? Do you want him to tone down? I thought he was quite modest. Modesty means recognising your own limits, not pretending to be limited just to show false humility.
I consider the iterators to be invalidated in this case, and that's what my implementation does. Recall that vector mid-insertion invalidates iterators, even when the memory remains allocated and the elements are merely reassigned.
Two questions: Any chance of getting something like llvm::expected? Is GN support something reasonable to expect down the line?
Spotted the grammar Nazi. 
I like the new versions of Boost.Test. Fixtures and data driven fixtures and operator overloaded assertions make writing and maintaining tests-as-code easy, even with thousands upon thousands of test cases. There are a lot of ways to run tests and output control is sufficient. It's not fancy, but it works well. 
Am I seriously missing something, or is Google Groups bugged and showing Niall's name for some of your messages? https://i.imgur.com/JNOamIR.png Clearly, this is your message, as it has your signature at the bottom (replying to Stefan's earlier message). Why tf does it say Niall? The only real Niall message I saw was at the bottom, where he suggested taking inspiration from AFIO to handle the fact that C++ programmers are 100% going to want control over the event loop.
It's not, "code" on this website is at best half C++ half pseudocode
It looks like a bug in Google Groups web interface. Emails sent without these errors.
Great talk, but compared to other talks he gave in the past it sounded a bit over-rehearsed. 
I'm not sure it is actually the biggest codebase, but it is the biggest monolithic codebase
I'm confused on how you can't make an arbitrary iterator type that the stl doesn't support? The different iterators I reimplemented support all the underlying iterators, aka a zip of just random access iterators is random access supported. testing with std::sort() which boost fails to compile with; mine compiles fine and gives the expected results aka multiple containers that are now sorted. So apparently range-v3 does do zip iterators; couldn't find that before. Well; mines a bit less wordy/new magic looking and functions closer to a standard iterator.
Potentially when using another dialect it could be faster, it just isn't using my compiler. I just don't get why there isn't an option to force using a theoretically fast algorithm.
It's still a bit strange to write "uses native system-provided widgets " instead of "uses wxwidget"
[removed]
That was not my intention. We use RTTI in our projects. If RTTI is on the way out, as you have put it, I'd like to learn about the details and see how this will impact the project in the future.
`boost::geometry::strategy::transform::map_transformer&lt;value_type, 2, 2, true, true&gt; transformer(m_box, m_canvas.width(), m_canvas.height());` 
Titus said they write *plugins* for clang-tidy. It's not stock clang-tidy he was talking about.
There is already a [pull-request](https://github.com/abseil/abseil-cpp/pull/8) with CMake support. 
C++ had a problem: it wanted to have a library for smart searching of strings. "I know" someone said, "we can use regular expressions!" C++ now has two problems. 
There's a requirement on forward iterators that for dereferenceable forward iterators `a` and `b`, `a == b` if and only if `*a` and `*b` are bound to the same object ([\[forward.iterators\]/6](http://eel.is/c++draft/forward.iterators#6)). IIUC this means proxy iterators cannot be forward iterators.
so if I'm understanding that right a == b implies you are checking the same block of memory (aka pointing to the same location in memory)? I mean it supports it currently(?) std::vector&lt;int&gt; arr_1{ 1,2,3,4 }; std::vector&lt;int&gt; arr_2{ 1,2,3,4,5 }; std::vector&lt;int&gt; arr_3{ 1,2,3,4 }; std::vector&lt;int&gt; arr_4{ 1,2,3,4,5 }; auto zip_itr = zip::random&lt;zip::fuzzy_equality_tag&gt;(arr_1.begin(), arr_2.begin()); bool compare = (zip_itr+2) == zip::random&lt;zip::fuzzy_equality_tag&gt;(arr_3.begin() + 2, arr_4.begin() + 2); std::cout &lt;&lt; compare &lt;&lt; "\n"; outputs 0 due to memory locations being different. Granted that's in release mode, with the level 2 debug checks off else it throws an error on vs for comparing invalid iterators. Although ignoring the fact the iterators can't be compared equally they'd point to the same data just not the same memory(that's not useful though). Time to go back and dig up more of the iterator requirements and see what I'm either failing on to match or am getting for free.
Why are you using `at` (which makes you pay for a bounds check) instead of simply indexing into the string? (Same for the vector)
I see, thank. So it is better to directly work with the string. It does not change the string length when I index it?
If it makes you feel any better msvc++'s implementation of std::regex is *also* not great. Luckily there's boost::regex :)
[too short.](https://i.imgur.com/eaOtBc7.png)
To be fair to the OP, a good engine would detect when you have no backreferences or similar, and switch to an NFA/DFA or similar. But none of the standard libraries come with good engines right now.
Why would it? You're just looking into the string, not adding to it. There's a few other issues with the code (some that may affect performance, some not): - What's the purpose of `flag`? It's never set to anything - I'm not sure what the whole manipulation of mask it doing at the end of that function. But since you haven't spelled out the actual requirements/constraints on the input or what the program actually does, I couldn't say whether that could be improved or not. (As an example, is "({[}])" legal input?)
[removed]
But as I see, the simple looking algorithm should change the string. If it finds balanced parentheses it should remove it. I'm doing examples from the leetcode and hackerrank. The problem formulation can be found here https://www.hackerrank.com/challenges/ctci-balanced-brackets/problem
This is eerily similar to the project I've been working on for the past ~6 weeks; down to the choice of json dependency and example editor widget using imgui! ;) I wasn't aware of MetaStuff when I started, otherwise I would(/should) probably have used it instead. After getting accustomed to auto-generating [UI for ECS entities](https://twitter.com/junkdogAP/status/686027733114163201) in java-land, I _don't want_ there to be any going back, so I set out to do something similar for c++ projects. My implementation borrows heavily from the gamedev.net article: [Pupping - a method for serializing data](https://www.gamedev.net/articles/programming/general-and-gameplay-programming/pupping-a-method-for-serializing-data-r4485/). I'll have to take a closer look at MetaStuff; it has some neat ideas and solutions I never considered. 
yes, I don't need the flag, it is a rudiment from the previous version.
Ah. OK. I can think of other ways to solve the problem, but I'm not sure that's really what you're looking for. Has changing the `at`s to indexing bought you the time you were looking for? (another hint that fits into your algorithm.... during the stage of your algorithm where you're changing the content of `mask`, if you've just removed a matched pair, do you really need to go all the way back to the beginning of the vector?)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/734hpy/learning_c_have_a_question_on_the_standard_valid/dnnnl2p/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
This is not acceptable.
wxWidgets *is* native. No skinning stuff like Qt, only a direct wrapper over the system ui toolkit
It's conforming to the [Google C++ style guide](https://google.github.io/styleguide/cppguide.html). Consistency always wins over random style picks.
The syntax is now applicable with normal functions: int main() =&gt; 42; Also new domain name for the compiler : [http://www.gcc-abbreviated-lambdas-proposal.tk/](http://www.gcc-abbreviated-lambdas-proposal.tk/)
Not on Plasma desktop it's not. Here Qt is the native toolkit while wxWidgets uses GTK. IIRC Mac users also have complaints about the nativeness of wx.
The question in second post clearly implies that. Several people picked up on this. So yes, you did. Read what you write, but with a critical mind?
That's not unit tests though, is it? I mean, you can make it so, but people have come to expect more...
Most uses of string tokenizer can be replaced by using StrSplit, at https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_split.h having said that... didn't this come from Plan9? MatchPattern... is interesting; apparently originated within Chrome... Wouldn't you rather have full regex support though? SafeSPrintf... we're working on something even better. I'm curious which of its differences from snprintf are important to you?
Nice effort. Things I didn't like/questions: * function ui_entry. Please remove that and use an object ala Qt::Application. * remove the create functions. An object's constructor should create the object, a separate function shall not be used. * enable(false) does not make sense. Use set_enabled instead. The same for show(bool) and other functions. * are the event functions on_&lt;event&gt; really signals? or just a single function only can be attached to them? if only one function can be attached to them, you can avoid having the functions, just make the relevant member objects protected or even public. * I didn't see a widget function that dispatches events. This is crucial for extending widgets with custom events. * no support for drag-n-drop and types. * no focus out or validation events. How to validate input on data change? * why is there a passwordbox, and not have a property in text box to show text as password? If I want to provide a button which shows the password, I would have to replace the passwordbox widget with another widget on the fly. * why 'passwordbox' and not 'password_box'? same for textbox etc. Visual Basic-derived terminologies are used to be expressed in camel case, i. TextBox, which makes sense, but in c++ that would be 'text_box', not 'textbox'. * why is there a separate log class? or is that a wrapper over boost logging? * can I override button painting to provide custom look and feel to button without changing behaviour? I know this is a difficult task, especially on Windows since in Win32 gui the button is to be drawn by its owner dialog, but nevertheless this is a needed functionality. Qt cracked this by mimicking native widgets instead of using them. * personally I'd prefer layouts to be widgets themselves. Mentally, it helps me construct a single UI tree, whereas with layouts, one has to have two UI trees in mind, one for the widgets themselves, and one for the layouts. I've done this in the past, by providing 'virtual' widgets that don't have an actual UI output and it worked perfectly, and it also allowed me to optimize the display tremendously and also do a client-server architecture where the display server only instantiated the widgets that were needed, whereas the client side had many times more widgets, but most of them where virtual (they were layout widgets). * the whole library offers the very basics for UIs only. For example, I can't extend 'combobox' to show icons near the strings. * is there a plan for a tree view? I haven't seen a UI without a tree. * with what backend engine is html rendering done? * if a full html engine is provided with it (as a wrapper to the native one), why would we need a full UI library? why not provide a c++ interface ro the html engine instead. * what's the difference between 'choice' and 'combobox' widgets? * there are no classes for nested menu items, checkbox menu items, radio menu items, separators, etc. * why another UI string class? can't you just provide something standard and do the conversions internally, when needed? I am not saying it's even doable, that's why I am asking. * no scroll bar widget? Despite all these questions, I have to congratulate you on taking on this effort alone. This is a topic (c++ standard UI) that has been avoided by whole groups of developers (the standard committee, boost, etc), if you make it alone you'll be a hero ;-). 
The c++ standard library does not allow zip iterators. If you implement one, it won't be standard conforming. It might work with some algorithms on some implementation, but that will be just pure luck and non portable. Range-v3 has different iterators concepts and reimplements all of the standard library to support zip iterators (and many other things like ranges, projections, views, coroutines...).
This is awesome - thanks for the extension! Out of curiosity, is there anything in it that relies on VS2017-only functionality? Asking since we still use the former a fair bit at work and it could be interesting to convert it to work with both.
hrm; move semantics are the problem along with copying the reference tuples.. that's what I get for failing to test all cases oh well. time to go dive back into things and see how much I can break everything.
A zip iterators cannot even model InputIterator. When I say "it cannot be fixed" I mean it. The way the requirements are stated in the standard it is impossible to write a confirming zip iterator. One needs a different standard library with different iterator concepts.
But wxWidgets also has Qt port - wxQt.
And most distros only ship wxgtk 
As we pushed for a quick initial release, we didn't have enough time to test it on VS2015, so version 1.0 is limited to VS2017. The next release (coming very soon), will fix several bugs and also add support for VS2015.
Shows "token_revoked" error
It was a very interesting talk, and while yes I will admit that I am put off by the CamelCase of the library it looks like it is another interesting C++ base library. In essence Abseil is doing what Boost hasn't done with its 5 year rule of not getting stuck on old workarounds. I find one thing odd and that is the pride in their Mutex class. Because it seems to be having both an exclusive lock and a read/write lock ability in the same object is a violation of SOLID design principles and the reasoning that it would be hard to fix a lot of code that uses the lock around their code is even weirder because unless I have missed a fundamental way of doing things I thought it was common practice to wrap contested resources in an object that contained the locking mechanism to ensure no one has to deal with concerns that are not essential to their application work. That object might (and I would be concerned if it was common) be passed around but never the mutex itself. Of course if you want to take several resources at once you have to use a different pattern, but this is a rare situation in my line of work.
My biggest concern is the license of wxWidgets, is it even compatible with the very permissive boost license?
What you are missing is that the award is about notable achievements, not leftist propaganda.
Why no standard library implementation copied boost::regex? Licensing issues? NIH? Amount of work to make it conforming? Amount of work to get rid of boost dependencies?
wxWidgets is licenced under LGPL with exception that allows to destribute executables on the user's own terms. It is very useful in static library linking.
Which is very restrictive compared to the boost license though, which is a huge deal breaker for me.
&gt; function ui_entry. Please remove that and use an object ala Qt::Application. Why? Single function looks easier then whole class at least for beginners. Also without top level GUI function in call stack it will be impossible to catch exceptions and handle it before exit. &gt; remove the create functions. An object's constructor should create the object, a separate function shall not be used. Delayed initialization is very useful for 'virtual' widgets. &gt; enable(false) does not make sense. Use set_enabled instead. The same for show(bool) and other functions. set_enabled() supposes changing a flag, but enabling is a process. enable(false) syntax is required to simplify this function usage. &gt; are the event functions on_&lt;event&gt; really signals? or just a single function only can be attached to them? if only one function can be attached to them, you can avoid having the functions, just make the relevant member objects protected or even public. Multiple functions can be connected to one event handler. &gt; I didn't see a widget function that dispatches events. This is crucial for extending widgets with custom events. Custom events are not supported and they supposes native API usage. Use Boost.Signals2 for custom events. &gt; no support for drag-n-drop and types. &gt; no focus out or validation events. How to validate input on data change? &gt; no scroll bar widget? Not implemented yet. &gt; why is there a passwordbox, and not have a property in text box to show text as password? If I want to provide a button which shows the password, I would have to replace the passwordbox widget with another widget on the fly. Some underlying toolkits not supports this or I don't know how to add this support. https://developer.apple.com/documentation/appkit/nssecuretextfield &gt; why 'passwordbox' and not 'password_box'? same for textbox etc. Visual Basic-derived terminologies are used to be expressed in camel case, i. TextBox, which makes sense, but in c++ that would be 'text_box', not 'textbox'. I'm thinking on this renaming. &gt; why is there a separate log class? or is that a wrapper over boost logging? boost::ui::log is a sink that displays list of log entries in dialog in idle time. Boost.Log should be able to write into this class but this is not implemented yet. &gt; can I override button painting to provide custom look and feel to button without changing behaviour? I know this is a difficult task, especially on Windows since in Win32 gui the button is to be drawn by its owner dialog, &gt; but nevertheless this is a needed functionality. Qt cracked this by mimicking native widgets instead of using them. &gt; the whole library offers the very basics for UIs only. For example, I can't extend 'combobox' to show icons near the strings. It isn't implemented. It is possible to try to implement, but I'm not sure that all native widget toolkits supports it. &gt; personally I'd prefer layouts to be widgets themselves. Mentally, it helps me construct a single UI tree, whereas with layouts, one has to have two UI trees in mind, one for the widgets themselves, and one for the layouts. You can use boost::ui::panel with connected layout in this case. &gt; I've done this in the past, by providing 'virtual' widgets that don't have an actual UI output and it worked perfectly, and it also allowed me to optimize the display tremendously and also do a client-server architecture where the display server only instantiated the widgets that were needed, whereas the client side had many times more widgets, but most of them where virtual (they were layout widgets). It isn't implemented. You can use create() function, but it isn't what you need. &gt; is there a plan for a tree view? I haven't seen a UI without a tree. Yes, but not now. &gt; with what backend engine is html rendering done? IE is used under Windows, and WebKit under other platforms. &gt; if a full html engine is provided with it (as a wrapper to the native one), why would we need a full UI library? why not provide a c++ interface ro the html engine instead. Yes, it should be possible to write application with single boost::ui::webview widget, but it supports only data output yet. Data input and event generation isn't supported yet. &gt; what's the difference between 'choice' and 'combobox' widgets? combobox can edit choosen text item, choice don't. &gt; there are no classes for nested menu items, checkbox menu items, radio menu items, separators, etc. menus are not implemented yet, work in progress. &gt; why another UI string class? can't you just provide something standard and do the conversions internally, when needed? I am not saying it's even doable, that's why I am asking. C++ Standard and Boost libraries have no string classes with lazy conversion support, this class isn't even a part of GUI. But there is std::filesystem::path class that works like uistring: converts strings from/to internal format. Thank you for great feedback! 
&gt; Why? Single function looks easier then whole class at least for beginners An application object is a more flexible solution, it allows to be subclassed if needed, and it's not easier for beginners unless beginners know about function objects. &gt; Also without top level GUI function in call stack it will be impossible to catch exceptions and handle it before exit. You shouldn't do that. &gt; Delayed initialization is very useful for 'virtual' widgets. Yes but it is better to be hidden. &gt; set_enabled() supposes changing a flag, but enabling is a process. enable(false) syntax is required to simplify this function usage. No, set_enabled() doesn't only change a flag, it can be a process too. &gt; Some underlying toolkits not supports this or I don't know how to add this support. On Qt, there is a property for setting the password character displayed, and that protects the widget. &gt; It isn't implemented. It is possible to try to implement, but I'm not sure that all native widget toolkits supports it. At least on win32, they are supported. Thanks for the reply. 
I read this a couple of times and still have no clue what you actually want to do. *spits out files* which ones are you talking about? object files? pdb files? the executable? the libraries? *run it in an online IDE* run, as in *debug in the debugger of that IDE*? or just *run but without any IDE intervention*? *it just doesn't work* that is quite a poor problem description
It's also very easy to integrate with any CI system out there; CMake is the only dependency, and it's only a CMake target.
Any chance that this will be available on Youtube?
Is `reference` a reference type and does unary `*` return it? If not, your iterator is not even a ForwardIterator. Basically, ForwardIterator on up requires a backing container, barring insane implementations, because they didn't think of zip iterators back in the 90s. You can pull off `InputIterator` in my experience, but anything beyond it you have to cheat and violate standard requirements on the iterator category. 
Why can a zip iterator not model InputIterator? If we can read tuples from a file, we can read them from 2 vectors. Or do you mean this zip iterator fails? If so how exactly? 
same for me
&gt; Which is very restrictive compared to the boost license To be fair, how does boost copes with for instance Windows API usage ? It's not under a free license either AFAIK. 
Don‚Äôt you mean -1 problems?
Yearp, can confirm
I would recommend the book to you. Do make sure to do all the exercises.
Give that man a medal, a raise, and full control over the committee. I'm okay with a benevolent dictator. This proposal is honestly the most exciting thing happening in the C++ community since modules ( if we get them ). As someone working with Qt a lot, I'm sick of hearing people complain about moc, and I'm confident that this is the solution right here. Maybe some concern over what may happen to the syntax. Is the single-dollar-sign-used-as-placeholder-by build-systems a big enough concern that we should use some __ugly keyword instead ? ( I used the dollar sign for myself a lot for this, but usually I go for `${...}` or `$$$` to be on the safe side) I hope the committee will see the benefits in keeping the syntax and overall design simple. I wonder how much of the current c++ standard can be retrofitted on top of this proposal and implemented in terms of compiler scripts, for lack of a better word. How much would that impact compiler design ? Compilation performance is also a bit of a concern, but I guess it can be solved if baked deep enough the compiler ?
&gt; &gt; remove the create functions. An object's constructor should create the object, a separate function shall not be used. &gt; &gt; Delayed initialization is very useful for 'virtual' widgets. MFC tried that and it's always been a mess. At the end of constructor execution, you should have an object, not a half-initialized object (what is that?). 
The standard requires *it to return a value_type&amp;. Proxy iterators (zip iterators, vector bool iterators, ...) cannot do that. This is fixed in range-v3 and the STL2, but the STL1 cannot fix this without breaking backwards compatibility. 
&gt; As someone working with Qt a lot, I'm sick of hearing people complain about moc, and I'm confident that this is the solution right here. While I understand some of the criticism towards Qt I do believe that moc should be understood as a language deficit. The only people that are allowed to complain about moc are those that have tried to advance C++ to the point where moc is not needed.
I want this as an inpirational poster or t-shirt. [Code don't lie Code compiles Code unit tests We love code.](https://youtu.be/4AfRAVcThyA?t=1h14m15s)
&gt;While I understand some of the criticism towards Qt I do believe that moc should be understood as a language deficit. It's the same with C++/CX. But some people out there prefer to believe they exits for the lulz.
&gt; To be fair, how does boost copes with for instance Windows API usage ? It's not under a free license either AFAIK. You can use boost licensed code in any way you see fit, the only thing you have to do is include the original copyright and well the license text. TLDR Legal of the Boost Software License https://tldrlegal.com/license/boost-software-license-1.0-explained TLDR Legal of the LGPL in comparison https://tldrlegal.com/license/gnu-lesser-general-public-license-v3-(lgpl-3) My biggest gripe is how complicated that license is, afair it allows you to dynamically link against it w/o disclosing your source but try explaining dynamic vs static linking in a court.
OOP is a term that has little meaning (in my opinion), you have to explain more plainly what exactly you wish to learn. Do you want to understand how basic C++ object lifetime and ownership is handled (construction, destruction, copying and moving) ? Do you want to learn design techniques based on combining classes via the use of template ? Do you want to learn about how to use C++'s "older" OOP features (inheritance, virtual... etc) ? And python (a dynamically typed, GC language) is a complete different story, since you loss the concept of lifetime and stack + the features at your disposal are much more minimalistic. In essence, OOP just means: You have a "thing" (object) which represents a bunch of data (data members) and some functions (methods or member functions) which are made to act specifically upon said data or using said data and the other member functions (which is passed to them implicitly, via a handle to the object). Anything you write that uses that kind of semantic is OOP.
Compile time strings with format specifiers solves one problem; but it breaks safe dynamic runtime localization.
Haha thank you for redefining my question. I guess that reflects a better understanding and more in-depth experience. Considering that do you mind giving ideas or suggestions on how I could come about familiarising myself with that style of coding? An example close to my experience and background would be creating a library for a specific sensor or actuator. Being that those topics are slightly more complicated I‚Äôd appreciate it if you had simpler suggestions on how I could start getting comfortable with oop.
Moc wasn't needed already in 2002, when Gtk-- as Gtkmm was called back then, was making use of libsig++. The only problem that moc solves is template metaprogrammig allergy.
Not really, as Kenney Kerr has proven, and is now leading the C++/CX replacement effort at MS.
The LGPL does not contain the word "dynamic" or "static"; it's just a common ([and false!](https://www.gnu.org/licenses/gpl-faq.en.html#LGPLStaticVsDynamic)) simplification that people do. It doesn't even make sense: there are plenty of languages without any concept of linking at all and yet you can use the LGPL there, too. And at least in europe there is a legal precedent for LGPL validation in court: http://www.h-online.com/open/news/item/German-court-case-confirms-validity-of-the-LGPL-1822882.html
Check [this list](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list).
Does anybody use std::regex?
Well, in that case I would recommend using C++ to do it, if you can compile using a recent~ish version of clang or gcc for your environment and using the standard library (aka the std or the stl) as much as possible, it's a very OO library so by using it you will understand how OO can be helpful and you can look at it's design to understand how to write things similar to it. If you want books I would recommend Scott Mayer's Effective Modern C++ (if you are familiar with C and/or older C++) or Brine Startrooper's A Tour of C++ if you are not that familiar with programming in general. Alternatively, if you want a book about OOP design patterns, there are tow classics that come to mind: *Gang of four (http://wiki.c2.com/?DesignPatternsBook) *Modern C++ Design(https://www.amazon.co.uk/Modern-Design-Generic-Programming-Patterns/dp/0201704315) For more up to date stuff, watch talks, look at code or look for less popular "up and coming" books. Keep in mind that your goal shouldn't be to use OOP because you want to use OOP but to use OOP because it helps you reason about things. OOP can easily result in slow code (similar sized data will not be localized, resulting in inefficient access), horrible design patterns (most beginners will make the mistake of writing large objects that have two many responsabilites) and hard to read code and change code (due to, sometimes useless, coupling between data an algorithms). If you want to see some interesting takes on OOP check out Scala and Akka's actor library, actors are a thought provoking distributed design pattern that is fun to write and Scala is arguably "the purest OO" language that is widely used today. Overall write code that works and is easy to modify, use a lot of language and libraries to familiarize yourself with as many aspects of technology as possible. And remember "objects are burritos", they are simply an abstraction that is used by a wide array of programmer and as such they mean different things from different people.
&gt; (1) If you statically link against an LGPL'd library, you must also provide your application in an object (not necessarily source) format, so that a user has the opportunity to modify the library and relink the application. Didn't know that they specifically aren't using the terms, but this part is what I'm referring to, unsure if I like this. &gt; ...but it stipulates that developers must give prominent notice to where the licensed code was used,... Eh, I don't know specifically how they used the code but this is exactly why I try to avoid using LGPL libraries, it's scary. Not saying that I hate the license or anything, it certainly has its use cases, but I think it's clearly incompatible with the boost license.
No. Check the paper Sutter wrote about metaclasses. The approach Kerr is following also has the problem Qt has with moc: it requires a side compiler. On top of that C++/WinRT requires you to use a a side language (IDL) to be able to develop WinRT types. C++/CX decided to follow a different path to not require a side compiler and a side language by extending the C++ language to allow both consumption and development of WinRT types. Both paths have different trade-offs but by the end of the day they are there because of limitations in the language and the proposal tries to address them.
You have no idea what moc does I guess. Moc offers reflection capabilities ( refer to a class/method by its name, get enum as strings, create signal/slot connection at runtime, have a complete property system, etc. Those things enable interfaces such as qml/qt quick. Of course you can have a signal/slot system without moc and in fact, in Qt 5 you can connect a signal to a non-slot function.
**Company:** [Carmenta](http://www.carmenta.com) - 2D/3D geospatial data visualization and analysis. **Type:** Full time. **Description:** Carmenta provides geospatial technology embedded in high demanding Command and Control systems such as Air Mission Support Systems, Battle Management Systems and Emergency Response Centers and we are also expanding our business to backend systems for autonomous vehicles. Carmenta has offices in Gothenburg (HQ) and Stockholm, Sweden, and subsidiaries in Germany, France and Spain. We are looking for an experienced C++ developer to join the [Carmenta Engine](http://www.carmenta.com/en/products/carmenta-engine/) team in Gothenburg, Sweden. Carmenta Engine is an SDK for Windows, Linux and Android implemented in C++ that provides advanced GIS functionality and visualization. **Location:** Gothenburg, Sweden. **Remote:** No **Visa Sponsorship:** No **Technologies:** Required: C++14/17 on Windows or Linux. Additional technologies: DirectX or OpenGL. **Contact:** For this and other available positions [visit our careers page.](http://www.carmenta.com/en/about/career/)
&gt; Brine Startrooper Now *that* is some seriously great autocorrect.
It should be in a few weeks :)
&gt; Moc wasn't needed already in 2002, okay, so please tell me how given types such as : class foo { public: int blah(); void setBlah(int); std::string doh(); void setDoh(std::string); }; I can have the following for all my types without writing a single line of code: void magic_set_function(foo&amp;, std::string, std::any); std::any magic_get_function(foo&amp;, std::string); and do : fooo f; magic_set_function(f, "doh", "some string"s); auto res = magic_get_function(f, "blah"); because *this* is the main problem that moc solves, which in turns open a lot of possibilities (for instance calling C++ methods directly from javascript without writing binding code manually). 
What is log reallocs of total linear size between friends?
&gt; Moc wasn't needed already in 2002, when Gtk-- as Gtkmm was called back then, was making use of libsig++. Not really. Gtkmm is built on top of GObject, which uses C macros to do (more-or-less) the same stuff that Moc does, like type registration, runtime property introspection and so on. Just because this stuff isn't visible in Gtkmm doesn't mean it's not there, it's just buried in the C layer.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Can you clarify something for me please? Does Boost.UI *depend* on wxWidgets? If so, as others have mentioned, how can you claim it is licensed under the Boost license if it depends on code with a more restrictive license? Do other Boost libraries depend on non-Boost-licensed code?
&gt; Give that man a medal, a raise, and full control over the committee. I'm okay with a benevolent dictator. Are you talking about Alexandrescu? :P Anyway since you work with QT I get your excitement, but honestly I wish ISO would just do something useful and just add interface keyword to the language without requiring users to learn another sublanguage of C++ but ISO is so incompetent they can not do that so this MC is next best thing...
Yeah that seems like a *glaring* omission.
That depends on the widget. I believe the list view is custom-drawn on Windows for example. And I think the tab interface is custom on all platforms.
But this library is dependent on wxWidgets is it not? If so that needs to be mentioned up front. It seems misleading otherwise.
This is Gold! I owe you one!
ISO is necessarily slow to act because they need to make sure that anything they add will be forward and backward compatible, clear, consistent, and meaningful, while also testing that it will be reasonable for compilers to implement. They could spend their time doing that on interface, or they could spend their time doing it for things which can be applied in many more different areas.
As a Qt programmer, I NEED this.
Can I get an amen?!
&gt; I wish ISO would just do something useful and just add interface keyword to the language Given this proposal I'd rather have ISO deprecate the `{class, struct, union, enum}` keywords and let people implement them themselves
they should also deprecate ++/-- operators and let people implement the semantics of that also... Imagine the possibility to now have power operator ( ** ) in the "portable standard C++"
False, IMAO. I know this is generic answer that in the mind of ISO fans can shut up any critic but IMAO truth is that most of eng work is compromise, and ISO fails here as they give too much value to backw compat when deciding how to compromise. In this specific example we could have had interface keyword for like 10 years already, and it would actually be really helpful to make code easier to read and write, especially for OOP programmers migrating from Java/C#. But no! In only 6 years we will get the ability to implement parts of compiler by ourselves... What a joy. Maybe in 12 years we get ability to implement a bit of codegen also. Imagine all the fun and expressive power we will get when x-64/ARM instruction sets are in the language . :P I hope Herb is not reading this, I have a joke that I can not even joke about C++ because ISO ends up doing it, so... :P 
&gt; super duper code explorer &amp; indexer that google had internally I‚Äôm assuming you‚Äôre referring to [Kythe](https://kythe.io). Kythe is the (new) backend to a bunch of code-related tooling at Google and is indeed open-source. In terms of work like globally renaming an identifier, I typically use a small command-line tool that‚Äôs effectively grep but backed by the index, programmatically do the rewrite often even just using sed or by whipping up a small python script, then shard up the patch and send it for review. Kythe includes [documentation and examples](http://kythe.io/docs/kythes-command-line-tool.html) of how to use its command-line tooling to do this sort of thing. The other missing bit is a tool to programmatically shard up a patch, run tests and if they pass, identify reviewers, then submit once approved. Such a tool is going to be pretty specific to how your repo identifies code owners, what version control system it‚Äôs backed by, and how presubmit checks and tests are run, so Google‚Äôs tools likely wouldn‚Äôt help much here. In terms of formatting, most teams I‚Äôm aware of use the usual suspects in code formatting (clang-format, gofmt, dartfmt, etc.) on their changes before landing. Some teams (or language infra maintainers) also configure a presubmit check that runs clang-format and refuses the commit if it produces any diffs. 
&gt; Also, people will non-maliciously commit these things, and then your build is wonk forevermore. How'd that get through code review?
But `cppreference` says nothing about `operator=` invalidating any iterators :/ I hope the standard does.
By making use of [libsigc++](http://libsigc.sourceforge.net/). On the phone now, maybe I can give you an example over the weekend.
[libsigc++](http://libsigc.sourceforge.net/) doesn't use any C macros.
[libsigc++](http://libsigc.sourceforge.net/) does support signal/slot connection at runtime, have a complete property system. As for reflection and enums as strings, no.
The UI designer person just hits "stage all" every time and the person who reviews him doesn't know any better either.
Are you implying that someone should get a license to use the APIs of the OS... they bought? Sound really strange. IANAL though .
Eh... `set_enabled(val)' isn't much better either. Surely `enable()/disable()` is the simplest possible thing?! (Or show()/hide()).
Fixed. Should be working now.
Fixed. Should be working now.
... but libsigc++ does not do reflection at all. it's entirely unrelated. Can libsigc++ give you a list of the member functions of your class ? 
Fixed.
Thanks! Let's get this thread to the top! 
what makes you think that I have a Windows / macOS / VxWorks / whatever license ? Yet there is some boost code on my machine that calls their respective APIs
Great, looking forward to seeing your talk!
&gt; In this specific example we could have had interface keyword ['Interface' Considered Harmful](http://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html) ['Interface' Considered Harmful](http://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html) ['Interface' Considered Harmful](http://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html) Besides, imagine C++ had gotten interfaces ... say in 2001. Now we're in 2017 and what does java do ? Add the ability to have implementations in interfaces! In a few years they will allow state, too, and the entire futility of interfaces will have been demonstrated. 
I love the idea of metaclasses as much as the next guy, but I can't shake the feeling that something's missing. It seems too good to be true. The only drawback I've been able to think of is that it could hurt compilation times, but I imagine it shouldn't any more than existing techniques already do. Can anyone think of some real pitfalls to metaclasses? 
Enums as strings is only an issue if you want to do it automatically. Putting together the internal translation isn't all that hard to do yourself. I don't consider that one a big deal. Reflection though? That's huge. That alone makes moc worth it. If we could get that into the language in some way that you can turn off for performance... or even better is constexpr so you don't have the runtime hit... yea that'd be worth it. Building a query/response system for runtime reflection is a royal pain and I never want to have to do that again.
I know that. It also only does a small part of what GObject and Qt need. Libsigc++ is purely a compile-time dispatch mechanism. It offers zero in the way of run-time reflection. I can't look up a widget's signals at runtime, or ask the runtime what the signal's argument types are, for example. With "real" GObject signals and with Qt I can do that, and it's essential to how interface designers like Glade and QtDesigner work (not to mention bindings for dynamic languages like Python and JavaScript). Of course, libsigc++ could add this functionality, but it would require a lot more work on the part of class authors to call the correct registration functions at the correct time. This boilerplate is generally hidden behind macros (as most C++ runtime reflection libraries do), or generated by a preprocessor tool -- or, potentially, by the compiler using metaclasses. 
No idea, before my time. But those are all good reasons.
Herb mentions that "enums bifurcate type system". Could someone explain what he means by that?
the StatusOr which /u/insanityzwolf mentioned is more or less llvm::expected IIUC, so the same answer applies there. I couldn't tell you about GN, because I have never used it. We already have a pull request in motion from external users adding CMake support to Abseil. Without knowing anything about GN, I don't see a priori why GN build files couldn't be there -- but the Bazel build is the source of truth in that respect.
You bought your Windows, didn't you? That's what gave you license :-).
Metaclass greatness may be the pitfall really. It's a big, world changing feature and the committee can be a bit afraid of that. Same thing with concepts, big proposal so it took decades to get in with lot of compromises and stupid syntax. You will notice that Herb didn't give any sorte of timeline. It won't be 2020 but it may not be 2023 either. To be the devil advocate, your question is worth asking and you probably need a lot of use too see where the pitfall are. It tooks year before someone realize TMP was turing complete. I'm not sure that's a good thing. And people may argue that it's too powerful or whatnot. I have a feeling that Herb gives this talk in part so that the feature gain momentum and to put pressure on the committee. It feels a bit like "Write to your representative to let them know you want that feature" I'd love to know what /u/bstroustrup think about the feature btw.
Version 1.0.1 fixes the PCH issue. You can now use the VS extension or PS script for projects without PCH. 
Enums are a specific thing in the standard that is neither a native type ( like int ) - nor a class ( or a struct, same thing ), and instantiation of an enum are weird things too, you have to convert them to a native type to interact with them most of the time. Basically, enums are bad(tm). That's why implementing flags, or simply converting an enum to/from its underlying type is clunky and not really safe. 
I (personally) only use Linux. Got a macOS license at work.
There you are right, there is no reflection support.
Giving out iPads as prizes? Does Apple still push Objective C?
Ah, your boost code is just text, it can't really call those APIs? Meh, in that case, it's the same as having copy-pasted some Win code from the internet into some text file. I don't know if there legislation to address this üòÅ
If Boost.UI is a wrapper around (and depends on) wxWidgets, it should say so on the main page. It would be very helpful to show how it is different from wxWidgets for example with 2 implementations of the same app.
I love the idea, I use perf+flamegraph all the time. You should definitely add some `hacktoberfest` issues, I'm in the process of trying to get a t-shirt and would be glad to help out :)
I don't necessarily agree with your assertion - "enums are bad", but I get how enums didn't belong to the traditional type system classification.
Uncle Wrong is wrong. Interface is better than an equivalent for the same reason why std::for_each is better than for loop. It tells you what it is, not how it is implemented. Also interfaces help us when we think of software in the same way that functions help us although we could write software by implementing everything in main(). 
I use them a lot, but they are quirky, and a hack. And it shows. That is what he was talking about. It's a non-native, not class, non callable thing. 
Looks awesome! So far used perf and the flamegraph scripts when profiling some java apps, but having a GUI to quickly select/exclude threads and time slices helps a lot.
Right, but that's for ForwardIterator, not InputIterator.
Interfaces as a concept are useful. This is the argument you've just made. I agree. You've not made the argument that the keyword `interface` is the best language feature ISO could be working on.
This is 2 things: one is the my esthetic feeling that says that using =0; to indicate pure virtual function is an abomination. You could say it is beautiful :) second is ISO priorities: IDK, my point is that if it is so hard to add interface keyword that it was not done I guess the ISO process is sh*t. So it is quite possible that it was a right thing not to waste a lot of time on adding interface keyword, but then the problem becomes how do you expect language to evolve if adding a simple keyword(compared to example await) is such a huge pain. It is like if your developers have productivity of 4 LOC/day they are either incompetent or your dev process is a disaster... there is no way to claim that 4 LOC/day is good(unless you work on kernel/low level primitives, etc). 
Sounds like a process/human capital issue: Why are people that clueless about code and version control doing code reviews? 
Exactly. The requirement that the iterator reference existing data starts at `ForwardIterator`; at `InputIterator` it makes no sense for there to be such a restriction, because it is supposed to be reading data from a file or out of scope. Both in my understanding of standardese, **and** in the fact that InputIterators must be able to read data from a file (or otherwise out of current address space) tells me that an `InputIterator` zip iterator that *copies* its data must be legal. 
Is that a question or a statement?
Well, that's why people don't wait for the standard to change to make changes to the compilers. That's why, for example, when Andrew Sutton and Matt Godbolt saw the Metaclasses proposal, they implemented a portion of them to see what it would take. There's a lot of value in non-standard compilers, and that's where a lot of the innovation in C++ can come from. The standards committee's job is to make sure that the standard can advance in a universally strong manner, as best as they can. That mission necessitates extreme conservatism, so it'll be slow. You're right that in a box, it'll cause stagnation, which is why we have std::experimental and non-standard compilers. So if you think that an interface keyword is a good thing to add to the language, you can make a branch of gcc or CLang that includes it as a first-class feature of the language. If you find it does good things, you can write a paper about it, and try to convince people that it should expand out.
I'm really glad to hear you keep resources spent on winXP to a minimum.
&gt; So if you think that an interface keyword is a good thing to add to the language, you can make a branch of gcc or CLang that includes it as a first-class feature of the language. If you find it does good things, you can write a paper about it, and try to convince people that it should expand out. If you do not like Trump you can run against him in 2020. (assuming you are US citizen).
I don't think that's a fair analogy. ISO doesn't state "All compilers must behave this exact way, and any that doesn't it terrible and wrong." It states "Compilers which implement to this specification will be guaranteed always to compile code which is written to this specification." If you don't want to write code that's to spec, you need a compiler that will compile your non-spec code. There are drawbacks to doing this, but you can do it, and no one is going to stop you.
The conversion von Tuple&lt;&amp;T&gt; to tuple&lt;T&gt;&amp; only works if T is copyable, which is required by InputIterator, does not work for unique_ptrs, so yes, a zip range of unique pointers cannot model InputIterator. /u/dodheim When I say they cannot model InputIterator I mean exactly that.
I bet five dollars that the mentioned "stable" releases will have semantic version numbers.
Thank you! That looks really good, I'll try to improve my lib with this approach. :)
It's because it's not code they're concerned about. They are not modifying code. They are artists and designers who don't deal with it. Their `.png`s, `.psd`s still needs to be tracked somehow so into git/perforce/svn it goes. They don't touch code, but may still end up doing a build locally. I've seen people commit the temp and cache folders on a couple of projects. It wouldn't surprise me if debug symbols or `.o` ends up in the source because of a mistake of someone who really doesn't know better and my god it's miracle enough that they're using it and not making local copies instead.
Hey, you need one of `{class, struct}` so you can define the others in terms of it! (I know you're not serious, by the way...) 
So again: How'd it get through code review? Why are people who aren't concerned with code doing code reviews? This is a process issue (which isn't to say in source builds are good, because they're not). 
Easier C++11 `tee` signature: template &lt;typename T&gt; T&amp;&amp; tee(T&amp;&amp; ); Also note that this breaks up lifetime extension for prvalues: auto&amp;&amp; val = func(); // lifetime extended auto&amp;&amp; val = tee(func()); //dangling reference Which may be an argument for `tee` returning `T` instead (which has a nice ring to it as well).
&gt;How'd it get through code review? Why are people who aren't concerned with code doing code reviews? Because they're not working with code. There is no code review. They still commit to source. Not all source is code or text. An artist code review is "looks sick dude" and then it is checked in. &gt;This is a process issue Yes it is. So you add in the .DS_STORE and other garbage into the .gitignore (rather than expecting people to have their global settings correct) so that this doesn't happen, which was my original point.
I'll read up on this more. What I am curious about is whether this can be used to make a 'finally' in the code (something that will be called even if an exception is thrown). Note that I probably wouldn't but curious if it could!
&gt; There is no code review. They still commit to source. ...which is a process issue.
The closest thing to this sort of adhoc cleanup is `SCOPE_EXIT`.
With C++ 17 and class template type deduction you can make something like this quite easily: https://gist.github.com/Rseding91/a79ce2a47b1339cfb735f1e1af52d2d1 With the usage (in C++17) being: ScopedCallback guard([&amp;] { /* my code */ }); It's not perfect but it handles a lot of use-cases.
If you're doing this a lot, it *may* actually justify using `std::list`--you can (usually) `splice` two lists in constant time, instead of the linear time that any/every method of adding to a vector is going to take. That said, to justify using `std::list`, you really do need to be doing this a *lot* (and other things like actually traversing the list a whole lot less), at least with most modern, high-performance processors (i.e., just about anything that depends on a cache for its performance).
Screenshots plz :)
You keep saying "what I say is what I mean" but unfortunately, I'm not 100% clear on what you mean. Regardless of if they conform to an iterator model, you can successfully `std::sort` on them and that's good enough for me.
Can you zip two (or three) vectors of unique pointers and std sort them? With which std library ? 
I have to implement on thing before I can push the new standardese on Monday or so. It still lacks the template mode and has probably regressions but should work otherwise.
Cool, I'll be an eager beta tester for you!
In the meantime you can run the [cppast](https://github.com/foonathan/cppast) tool over your code and report any errors.
On childcare this weekend, but will do early this week
&gt; A very multiplatform boost / template metaprogramming UI library in C++ would be something to behold. I'd like to behold that from a safe distance.
what is a natural use case for this?
The worst thing is she described almost exactly how my C++ courses went. We used `cin` and `cout`, but other than that I spent two semesters learning C, but calling it C++. This was in 2007, but even then &lt;vector&gt; existed. Actually, I think I had to learn &lt;vector&gt; on my own. The only part of the STL we ever touched was &lt;string&gt;. I've written doubly linked lists by hand, learned the pitfalls of new, and everything else. Heck, going to the microcontroller class where we were coding using C, the only difference was we had to use `printf` instead of `cout`.
In one sentence: transwarp may work for you if you want to model dependent operations in a task graph, possibly run those operations asynchronously, and schedule them multiple times. 
sorry, I meant to send: https://cs.chromium.org/chromium/src/base/strings/stringprintf.h rather than the safe version.
Maybe it is just me, but how does this work together with a UI? Does it support getting task progress, e.g. for UI progress feedback, pause/resume and cancellation?
Since transwarp supports executors, you can create a custom executor that runs functions on the UI thread. There is no support for progress or pausing because transwarp does not know anything about the operations that are scheduled apart from input/output types and dependencies. There is support for cancellation in the sense that a task can be canceled which means it won't get scheduled when it is its turn. However, this will not affect any currently running tasks. 
I do. It let me drop my boost dependency. 
What sort of task granularity works best? It is possible to have millions of tiny tasks, or is it better to stick with a handful of big ones? 
I think any number of tasks should be ok as long as the majority of tasks does some actual work. If the majority of tasks is too tiny and may be just adding two numbers then the (small) overhead of creating a task and visiting each task in the graph may not be justified. There are two benchmarks in the 'examples' folder which compare task graph with regular function calls. For those benchmarks there is no significant difference between the two. 
As non Qt programmer, I really need this too ! 
Hmm, you're actually probably the first non-helpful C++ coder I've met. Regardless, I did try on Compiler Explorer and I was attempting using Boost. Their tuples aren't comparable and standard tuples can't be used to make their zip iterators. I'm not sure why 100% but it seemed Boost couldn't give it an iterator tag. Edit: Actually, then I found this: https://stackoverflow.com/questions/9343846/boost-zip-iterator-and-stdsort So, that's weird to me. I think I've learned it before but I forgot. Either way, I sort zip iterator ranges using the CUDA Thrust library. You get hella memory efficiency in your GPU sorting. [This](https://github.com/LeonineKing1199/cuda-stuff/blob/7bca517de5b0fc68a02092674728fa617c4fb68e/src/nominate.cu#L131-L134) is some code that compiles for me. I'm not sure what the discrepancies are between Boost and Thrust.
I see some problems with your fluent interfaces: 1) https://ocramius.github.io/blog/fluent-interfaces-are-evil/ 2) methods like `on_key_press` should return something like `boost::signals2::connection`.
Nice write-up. You should definitely put a note somewhere that the code sample requires c++17 support to compile. I'm still digesting the concepts so I don't want to make technical comments yet :) edit: I'm not sure why you use `5'000'000` for integer literals and how that even compiles
It just does :) I'll add a note on c++17. Thx!
That's [n3781](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.pdf), single quote as digit separator.
As soon as I saw the title I thought "you know it would be great to have a strong typedef that has a customizable feature set" and it seems to do just that. Haven't looked at the code, but I think I'll try to implement something like this myself for fun.
Ok now I digested the concepts a bit better. This is super nice. The real trick isn't using CRTP, but reversing information flow so that an entity doesn't know its components, but components know their entities via unique ids. This is what allows you to store components out of their entities and in per-type static vectors, this is what gives you cache-friendliness. CRTP is just a way to not rewrite the interface methods for all component types, it just saves you typing and code duplication. With the stuff in your blog post you provide: * actions on a component type for all entities via static methods: `Component_t::update()` * actions on a component type for one entity via random access: `entity.get&lt;Component_t&gt;()-&gt;update()` What you are missing to cover the whole matrix is to provide: * actions on all component types for all entities * actions on all component types for one entity You can really just add this on top with variadic template methods and type lists, e.g. template&lt;typename...Ts&gt; struct type_list {}; using all_components = type_list&lt;Comp1, Comp2, Comp3&gt;; // helper function to call update on all component types update&lt;all_components&gt;(); // just does `(Ts::update()...)` expanding the type list with `...` // call a method on all component types for this entity (there might be better ways) auto call_render = []&lt;class T&gt;(T &amp;c) { c.render(); }; entity.apply_to&lt;all_components&gt;(render); I find the approach elegant, although it has inherent complexity that might be an overkill for small-sized projects. You say you want to explore multi-threading now but it seems to me that is a completely orthogonal topic? I would use your pattern in multi-thread code, I wouldn't make your pattern inherently multi-thread if you know what I mean. Separate concerns.
ah thank you, it's actually mentioned in the "integer literal" page on cppreference but I failed to ctrl-f the right keyword "separator" :)
How about 'incrementable' and 'decrementable' instead of up_ and down_counters? 
`gsl::final_act` is a modern replacement. You can even write `auto cleanup = gsl::finally([](){ do_something(); });` https://github.com/Microsoft/GSL/blob/master/include/gsl/gsl_util
I've always preferred the macros to the library solutions if I'm honest. No (visible) extra variable, consistent naming for success/failure scenarios (e.g., `SCOPE_FAIL`), and 0 boilerplate. It's simply a small scope to do cleanup and nothing more. The macro isn't hiding anything important, just the necessary code in order to make it work in C++. 
Ugh, the ratio of code to English is frustrating. Almost every slide is pure code, which makes following along very frustrating. I'd be nice to see some plain English explaining the motivation and advantages.
I don't follow your arguments other than of brevity, which I agree on. Otherwise, any macro solution has the option of being implemented in terms of gsl::final_act or Boost.ScopeExit style uniquely named classes, or anything else, so any differences aren't specific to the macro itself. So, back to the question asked by /u/ajorians. Could the metaclass proposal enable implementation of something like this? `finally { do_something(); }{}; Not in its current form, because this isn't a named class. It would require a mechanism to generate a unique class name, similarly to how a lambda's type name is generated by the compiler, and how Boost.ScopeExit uses the preprocessor to create a unique class name. Secondly, what we would want to do is to take everything in the 'class' body and put it into the generated class destructor, and I'm not sure whether the proposed reflection support can do that. Still, this would be an interesting idea to look into further. 
But why would I need this if I all I want to do is write a GUI application?
Note that we already had https://github.com/foonathan/type_safe
`enable()/disable()` or `show()/hide()` requires `if`s if you control them by some boolean e.g from checkbox. `set_enabled(val)` is easier to use in signal/slot environment.
that's actually quite useful. A common use case is to generate UIs that map to data structures automatically; eg if you have an int you create a spinbox, if you have a string you create a lineedit, etc. and you can show the name of the member. For instance in unity3d if you have a class : class NewBehaviourScript : MonoBehaviour { public int bananas; public string simpleMethod; private int myImplDetail; } the following UI is automatically generated: https://i.imgur.com/UZUgubj.png
I never noticed the strong typedef portion, thanks! On an unrelated note, why can the control blocks that take booleans use `explicit bool` operator while `switch` cannot use `explicit integer` where integer is an integer type?
1) Thank you for link. Many problems are just because function returns something except *this. Fluent interfaces has disadvantages, but I think that advantages is much more bigger. BTW C++ iostreams uses fluid interfaces. 2) Why? Boost.UI not uses Boost.Signals2 and it allows to subscribe multiple times to the same event. Also it is possible to implement Boost.Signals2 support in user code. Also your proposal isn't compatible with fluent interfaces.
What if I'd like to base my type on two metaclasses (assuming they are orthogonal)?
Awesome response, let me go a bit deeper. You are right that there is much more going on than just CRTP, but without it things cannot be data-oriented (not in a user-friendly way at least). I guess I forgot about all the other cool things since I've been working on entity-component systems for so long :) &gt;What you are missing to cover the whole matrix is to provide: &gt;actions on all component types for all entities &gt;actions on all component types for one entity Actions on "all component types" are provided by other engine infrastructure in my project. Mostly I use callbacks, which I really like. The demo is just a tiny sample of my engine. I didn't want to over-complicate things. Actions on all component types for 1 entity are quite rare in games. I can't really think of a scenario off the top of my head. Have an example? Note that applying something to all components for 1 entity breaks the contiguous benefits though. Anyhow, I'm happy this has inspired you so much. Be sure to share if you evolve this idea. On multi-threading: They are not orthogonal if you want to format your architecture to minimize locks. You can transform the core to be multi-thread friendly. Since this affects everything else in the engine, I want to get it done early on. Cheers edit : I'll make a write-up if the multi-threading works BTW. It will be more clear with examples and real data :)
I am actually trying to be helpful. If you need zip iterators, really, use range-v3, it is designed for that. The reason thrust doesn't have ranges is because it needs to be rewritten anyways to make zip iterators robust. It works because thrust controls the algorithms but if you pass a thrust zip iterator to a non thrust algorithms things break in subtle ways. You might think this is me demotivating you in trying to find a solution, but this problem is 20 years old, there are many solutions to it, and the only one that works 100% of the time is the range-v3 one. If you want to do it yourself, that's fine: just study and fully understand how range-v3 does it first. It takes too many years of trying and 10.000 LOC to get it right.
Anyone fancy writing up some.of the key points as I can't watch the video anytime soon? Thanks!
Is there a good documentation on how to probably install the latest boost on windows 10 The instructions in the latest release is giving me lots of errors, and it may be related to this.
Ah. Yes, that form of stringprintf is widely used at Google. It has one really super-annoying problem: the format specifier for "long", "long long", "ssize_t", and "ptrdiff_t" are all different: "%ld", "%lld", "%zd", and "%td", respectively. This is true even though in most 64-bit environments, they all refer to the same thing: a signed 64-bit type. That means that if you call a routine that used to incorrectly return an "int", and now returns a ptrdiff_t, you'd better not have immediately fed it to printf, because if you did, you're going to have a compile error. This is maddening. I think you'll find that most uses of StringPrintf in your code can be replaced by calls to absl::StrCat or absl::Substitute, because the formatting is simply made up of %s or one of the 16 forms of %d. For the rest, stay tuned.
&gt; It has one really super-annoying problem: the format specifier for "long", "long long", "ssize_t", and "ptrdiff_t" are all different: "%ld", "%lld", "%zd", and "%td", respectively. You are making it sound as a problem, when it is not, since unsigned types have their own specifics on the printf convention, so breaking the build for anyone trying to convert a unsigned to signed is the proper behaviour. This is the contract of that function. Besides, There is a support file for handling this kind of problem, with a portable way to flag unsigned values and other similar types: https://cs.chromium.org/chromium/src/base/format_macros.h?q=prius&amp;sq=package:chromium&amp;dr=CSs&amp;l=21 About using absl::StrCat or absl::Substitute, I must say, you are not listening. I do have code that does things like: ``` base::StringPrintf("%s_????????.log", log_prefix_.c_str()); ``` or ``` std::string out_str = base::StringPrintf( "[%02i.%02i.%i/%02i.%02i.%02i] %s\r\n", now.day_of_month, now.month, now.year, now.hour, now.minute, now.second, msg.c_str()) ``` I'm on your side... I'm giving you honest feedback. Please take it. There's no way I'm gonna remove `//base` from my code for a leaner version of the same code that is less resourceful. The absence of StringPrintf is a deal breaker.
Yes of course keep the pattern thread-friendly! I guess the challenge is keeping the critical section related to adding and removing components from entities as small as possible? I never did game programming, so I understand the code but I don't have a full grasp of the application
So far First 20 minutes is all history. (Somehow I find it interesting thou) - KDE was inspired by Qt - Nokia funded Qt in the beginning, which helped for the further development of Qt Creator(Symbion OS apps where build using Qt btw(At least the company ones)). - Later there were issues b/w Nokia and Qt, After switching to Windows phones, Qt didn't had much to do in Nokia. ;( - After, a company called Digia acquired Qt assets from Nokia. - He admits that the Qt developers learned a lot about good design and abstractions from Nokia(Or working for Nokia). - Qt left Digia in 2016 I watched first 30 mins, I might watch the rest later.
1) Imho fluent interface should rather be available by some adapter like `fluent(widget).someWidgetFunc1().someWidgetFunc2()`. However with this solution you must remember to add method to fluent adapter after every new method in widget class. 2) Because my proposal isn't compatible with fluent interfaces I don't like fluent interfaces :P I am not saying that you should use boost.signals2 but you should allow some mechanism to disconnection.
no, you still need basically interface generator promised by the end of this year
Conditionals are considered an explicit conversion to bool for convenience's sake, since none of the dangerous things around implicit conversions can really happen there. AFAIK there's no reason why an explicit conversion to int in a switch statement couldn't be handled similarly other than that no one's proposed it and it's relevant far less often.
Yes definitely. Also, separating mutable from read-only data. Here is the paper I'm using for inspiration http://ics.upjs.sk/~krajci/skola/ine/SVK/pdf/Majerech.pdf It will be very different as I don't use a traditional ECS. But the idea remains, compartmentalize what is readonly/mutable to help the concurrency. Hopefully it all works out!
Pretty uninteresting talk if you're familiar with the libraries already. If you're a Qt programmer, start at 1:06:30 for the very short future direction stuff and the Q&amp;A. There were a few things that people will find frustrating about this talk; 1. Lars is expressing a lot of reluctance to change APIs to bridge the gap between the standard library and Qt libraries - near the start of the talk, he mentions that he wants the library to be as simple as possible to use for new programmers and those transitioning from languages like Java. This kind of ignores the fact that C++ programmers still need to be familiar with 2 very different APIs 2. Lars mentions that he wants to make it easier to avoid templates - a lot of people WANT to be able to start using generics in Qt code. 3. MOC is here to stay for the foreseeable future, and there won't be any major changes in the way people structure Qt code. That said he did mention that the introduction of reflection into the standard could mean big changes in the way Qt is used including looking at removing moc, but it was more of a "oh yeah, that could happen" than a "yeah, we're working on it" 
1) This will produce a lot of code duplication. But you can write an adapter that don't use fluid interfaces. (: 2) Disconnection wasn't implemented yet because it is an early stage of development and I'm not sure what name use for disconnection: off_key_press()? unbind_key_press()? disconnect_key_press()?
Can it be used to schedule jobs that physically run on other machines? 
You can create a transwarp task with a functor that schedules the server job. Child tasks could then wait for this task's completion. The same could be done for GPU jobs. All that transwarp cares about are input/output types and dependencies. It is not concerned with what each task's functor actually does. 
Nokia apps where only written in Qt after the Trolltech acquisition and development of PIPS. Until then it was plain Symbian C++ with the Eclipse based Carbide, after rebooting the first attempt to use Eclipse, the route taken after moving away from Metrowerks based tooling.
It's very unfortunate that Qt seems so reluctant when it comes to language and API evolution. The Javaism shows through almost in all of the Qt types, and not in a good way. I understand they want to keep the SDK accessible to new programmers and whatnot, but it's getting really outdated with all the C++ progress that has happened over the recent years. Nowadays, I isolate all of my Qt code to bare minimum, to parts dealing with UI specifically. 
Any runners that will isolate tests into own process to prevent crashes to take down the whole suite? In the past, I've used testrunner-lite but that requires a bit of instrumentation to create suitable xml file to run the tests..
What reason would I have for doing so? Much of the C++ discussion I participate in would not be improved by using a proprietary messaging service.
Well, why should Qt be more flexible than the standard library? I think the fossilizing of old APIs is a general C++ problem - not just that of Qt. 
Last time I seriously used qt was a long time back. Where exactly is the gap between the Qt-API and the standard library? Is this just about QString vs std::string?
I find that to be a weird hangup, considering reddit is proprietary as well, as are a number of different blogging technologies out there. Google groups are proprietary as well, as is Twitter. There are at least 3.2k people on the Slack team now, so, proprietary messaging service aside, there are quite a few great discussions that can be had. The more people, the better.
Regarding the removal of moc by using reflection: Be realistic: It will be at least 2020 until reflection comes into the standard and then it will probably take another 3 Years or more until c++20 is sufficiently wide spread for qt to be able to rely on it. I find it not surprising that he didn't want to make any announcements about things that would happen 6-7 Years in the future and heavily depend on events that are outside their control.
The committee is considering a `std2` namespace to allow breaking changes to the APIs. So when Qt has it's next major release, they could also use it to break old APIs in a similar fashion. Unfortunately, if I understood Lars correctly, they won't break the APIs too much because of the large user base. If it were my decision, I'd to the complete opposite and change the APIs massively to make Qt easier to maintain and to use, in particular since you only get the change to do so approx. every 5 years. In my opinion, Qt should get rid of all it's containers¬π, essentially all of the threading stuff (e.g. QThread, QMutex, QFuture) as well as the Qt smart pointers; they simply provide no benefit over their std counterparts (even the futures don't have `.then` yet). Introduce a Qt namespace so binary compatibility can be guaranteed in the future by using `inline` namespaces, then you can even add new virtual methods to classes if necessary to improve their API without having to wait for a new major release. Yes, these changes break a lot of existing code, but it should be rather straight forward to also implement a clang-tidy based tool to update client code automatically. ¬πapart from maybe `QString`, but that is debatable - sadly Lars didn't really answer Odin's question why they don't just use free functions operating on `std::string` or `std::wstring` for the unicode specific stuff instead of member functions on their custom string.
Looks really good. Bit unfortunate that it has so many dependencies... Both KDE and Qt is a bit too much. 
&gt; If it were my decision, I'd to the complete opposite and change the APIs massively to make Qt easier to maintain and to use, in particular since you only get the change to do so approx. every 5 years. That's what's happening to Gtk+. See how they're losing their users.
I like that new voice from Rob xD
The committee is **considering** std2 exactly because they don't want to break backwards compatibility and afaik, there is not a single class or function proposed for std2 so far, so I won't hold my breath until I see it. Also, std::thread has nowhere near the functionality of what QThread has to offer. In particular considering the integration with the signal/slot and event-loop mechanism. Regarding the containers (including QString): Yes, they could probably be replaced, but somehow I'd expect that to go down similarly as the python 2-&gt;python 3 transition (and qt's api has been around much longer than python2). I think the best QT can realistically do is making their api accept standard library types wherever possible (in addition to the Qt types), but of course that imposes additional implementation burden. I don't want to overly defend qt, because I rarely use it and don't really care what way it develops (actually I would appreciate more standard library compatibility), but I think just as backwards compatibility is important for c++ as a language, it is also very important for Qt in particular.
&gt; If it were my decision, I'd to the complete opposite and change the APIs massively to make Qt easier to maintain and to use, in particular since you only get the change to do so approx. every 5 years. I think that big changes like this should also change the project name. Keep in mind that Qt is used in industries where specific versions of softwares &amp; libraries sometimes stays fixed for 30+ years. For instance, the API had [mostly small changes between Qt4 and Qt5](https://wiki.qt.io/Transition_from_Qt_4.x_to_Qt5) (to the point that many big projects were buildable under both Qt4 and Qt5 for a long time - eg QtCreator, Clementine, etc) and it already drove people out of it and led to endless complaining on forums &amp; blog posts. 
Use the AppImage, then you don't need to care about what dependencies are used internally.
&gt; I think that big changes like this should also change the project name. All the things I proposed aren't fundamentally changing the way Qt works or how it is used, it is mostly about getting rid of old workarounds. The Qt containers exist because when Qt first was developed, most compilers didn't ship with complete STL implementations. Since that has changed, Qt might as well get rid of them. &gt; Keep in mind that Qt is used in industries where specific versions of softwares &amp; libraries sometimes stays fixed for 30+ years. Even better then. If they aren't going to update to Qt6 there is no problem in breaking APIs. &gt; [...] it already drove people out of it and led to endless complaining on forums &amp; blog posts. That's why I suggest to provide a clang-tidy based tool to automatically port the user code to the `std` types and the new namespace. If they can't be bothered to use that (and fix potential cases where to tool didn't work correctly) then they still have the option to stay on Qt5. If the last Qt5 release is a LTS release, they even have 3 years to port to Qt6 without having to worry about security and bug patches.
&gt; All the things I proposed aren't fundamentally changing the way Qt works or how it is used, it is mostly about getting rid of old workarounds. there would be quite big changes to implement though: Qt containers are COW (which allows to copy them without loosing too much performances when passing them between threads through the signal-slot system) while the std containers are not ; a *lot* of Qt code relies on this and just passes everything by value so someone would have to implement a generic COW-wrapper, and wrap the qt containers passed by value with it in order to keep the same behaviour. 
2) a bare minimum is to return a handle that can be used to disconnect... otherwise you can‚Äôt disconnect anonymous functions (lambda)
&gt; Also, std::thread has nowhere near the functionality of what QThread has to offer. In particular considering the integration with the signal/slot and event-loop mechanism. The fact that `QThread` automatically has it's own `QEventLoop` is nice, but does it really warrant the overhead of having to maintain your own platform-specific implementations of a thread class? Maybe it does, but that is not my decision. I just think it makes sense to go through all existing Qt classes now and to decide which are worth keeping. For those that only provide minimal additional functionality compared to their `std` equivalent and thus will not be kept around, necessary additional APIs that use `std` types can be already introduced and the old APIs can be marked as deprecated. If a clang-tidy based refactoring tool is provided at the same time, hopefully most code will already be ported by the time Qt6 is released. &gt; Regarding the containers (including QString): Yes, they could probably be replaced, but somehow I'd expect that to go down similarly as the python 2-&gt;python 3 transition (and qt's api has been around much longer than python2). C++ has a significant advantage over Python, though: It is compiled and statically typed, thus we have the option to use clang-tidy based tools for automatic refactorings.
I'm not familiar enough with Gtk+ to have an opinion on why they're losing users. It might also be the case that the alternatives are better. The latter is also what I fear for Qt. The current state is that Qt is arguably the best framework to write GUI applications in, partially due to QML. But you actively have to fight the framework to use it in a modern C++ fashion. And you also have a lot of friction when using it with other 3rd party libraries. Currently, if there were a GUI library that is just as convenient to use to write GUIs (i.e. with something similar to QML), the main advantage Qt had over such a library is that is a full framework and thus also provides the facilities to e.g. communicate over the network or a serial port. Essentially, Qt provides everything I need to write a full application, so I only need to care about a single dependency. As soon as C++ gets a de-facto standard package manager (conan seems to be on a good path) and thus allows much easier integration and therefore adoption of 3rd party libraries, this advantage is basically nullified and the already existing friction with other libraries is going to increase as the interfacing area is increased. At that point, if a new GUI library just focuses on providing modern APIs for the core task of creating GUIs and is just as convenient as Qt, suddently this library becomes a viable option as all other features of Qt are also available in other 3rd party libraries. So in the long run Qt will have to modernize, and it is probably better to do it early before even more code gets written.
Do you actually know of successfull, large scale, non-trivial refactorings based on clang-tidy outside of Google? Not to mention, that I wouldn't be surprised if a significant part of qt users code base can't be compiled with clang. As far as QThread goes: As long as the standard library doesn't have support for message passing between threads I'd say yes (and afaik, there is nothing preventing QThread from using std::thread internally). Regarding fighting the frame work: As I said, I haven't used Qt in a long time - where do you have to fight the framework to use it with modern c++?