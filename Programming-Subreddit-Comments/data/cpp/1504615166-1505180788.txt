A bunch of compiler errors! Bad include statement, uneven quotes, and a WTF operator &lt;== which likely would compile, but wouldnt do what you think. But why ask what the output would be when you could put it in a compiler and see this anyway? Maybe this is for /r/homework as your cpp is bad.
And I missed a closing }
Have you tried running it?
Try run it: http://cpp.sh/6awwj Post is after the output has been carried out. So std::cout &lt;&lt; A; A= A+1; 
It doesn't look like he wrote it, looks like codes from a book and asking him what it would output. Whichever book it is, throw it out.
I'd find another website. Every time I look at that few lines of code I see something else wrong. Learn from good code, learning from bad code won't help. You often need to scan thousands of lines of code looking for issues, learning from code that looks like wouldnt be learning.
I'm pretty sure that the operator would not compile. It would either be parsed as &lt;= and = or as &lt; and ==, none of these are unary so they cannot follow each other like that. 
So many wrongs in so few lines of code!
[removed]
Interesting. It appears that LLVM is expanding the base of developers who are contributing to open source compilers. I suspect that most of these additional developers represent corporate contributors that don't mind working on LLVM's permissive license, and would otherwise not support GCC's strong copyleft license. Personally, I think its important to have strongly copylefted software out there, especially programs as high-quality as GCC. Richard Stallman may be the proverbial lunatic wearing a hair shirt out in the wilderness, but there's no doubt that his unique ethical perspective has changed the programming landscape for the better.
Hey, I actually just tested using _Generics in VS 2017 with the latest update, and it worked, so thanks :) I primarily develop on a Mac, and just assumed VS would support it then I was like "wait, shit..." Glad it worked out.
VLAs are basically pointless when you can just use a pointer anyway.
Glad it worked for you. I'm assuming /u/STL or one of his compatriots deserves the credit there. We've been telling developers to just use our stack--your code will probably work with the latest compiler and the `/permissive-` conformance switch. Of course that's an easy statement to prove wrong: we make no secret of the features our compiler still lacks. But we've rarely had a big customer come back and say they needed feature X or Y implemented right now to continue with MSVC. 
There would be no output since the code failed to compile. If you start talking about increment operators in your exam you should get 0 points for overlooking the serious problems starting from the first line.
Maybe my eyes are just eager to see a pattern, but it looks like LLVM almost always has a little spike of activity during the dips in GCC activity. I wonder how many people are contributing to both and how they allocate their time.
I can't really use Hana because of compiler compatability issues, but thanks for your comments here, I will definitely consider bringing in `is_valid` standalone. Thanks! Edit: For anyone who's reading this, and not using Hana but does want to use `is_valid`, it's a bit awkward in the above implementation to use with typical template parameter sfinae: // Nice! auto has_toString = is_valid([](auto&amp;&amp; obj) -&gt; decltype(obj.toString()) { }); // Not nice template &lt;class T, std::enable_if_t&lt;decltype(has_toString(std::declval&lt;T&gt;()))::value, int&gt; = 0&gt; void foo(const T&amp; t) { ... } You can do return type sfinae which cleans this up a bit, but not completely, and in general return type sfinae isn't always a solution and I usually don't prefer it. So consider using the following helper: template &lt;typename ... T, typename F&gt; constexpr bool is_valid_2(F&amp;&amp; f) { return decltype(is_valid(std::forward&lt;F&gt;(f))(std::declval&lt;T&gt;()...))::value; } template &lt;class T&gt; constexpr auto has_toString2 = is_valid_2&lt;T&gt;([](auto&amp;&amp; obj) -&gt; decltype(obj.toString()) { }); // Much much nicer template &lt;class T, std::enable_if_t&lt;has_toString2&lt;T&gt;, int&gt; = 0&gt; void foo(const T&amp; t) { ... }
Sounds awesome! Qt Creator version 4.4 contains bug fixes and new features. The most important changes are listed in this document. For a complete list of changes, see the Git log for the Qt Creator sources that you can check out from the public Git repository. For example: git clone git://code.qt.io/qt-creator/qt-creator.git git log --cherry-pick --pretty=oneline origin/4.3..v4.4.0 General * Added highlighting of search term in Locator results * Added larger icons to `New` dialog * Added locator input to extra editor and help windows (QTCREATORBUG-9696) * Fixed theming of Debugger Console and TODO pane (QTCREATORBUG-17532) Help * QtWebEngine backend * Fixed that wait cursor was sometimes never restored (QTCREATORBUG-17758) Editing * Added optional inline annotations for Clang code model errors and warnings, and bookmarks * Added optional smooth scrolling when navigating within the same file (for example with Locator or `Follow Symbol Under Cursor`) * Added overridable `DeleteStartOfLine` and `DeleteEndOfLine` actions (QTCREATORBUG-18095) * Added support for relative path to active project to `Advanced Find` &gt; `Files in File System` (QTCREATORBUG-18139) * Added colors to default text editor scheme (the previous default is available as `Default Classic`) * FakeVim * Fixed `gt`/`gT`/`:tabnext`/`:tabprevious` All Projects * Improved detection of cross-compilers CMake Projects * Added option to filter for CMake variables in build configuration (QTCREATORBUG-17973) * Added warning when detecting `CMakeCache.txt` in source directory even though build is configured for out-of-source build (QTCREATORBUG-18381) * Fixed `CMake configuration has changed on disk` dialog (QTCREATORBUG-18292) * CMake &gt;= 3.7 * Improved handling of `CMAKE_RUNTIME_OUTPUT_DIRECTORY` (QTCREATORBUG-18158) * Removed `&lt;Source Directory&gt;` node from project tree * Fixed that headers from top level directory were not shown in project tree (QTCREATORBUG-17760) * Fixed progress information (QTCREATORBUG-18624) Qbs Projects * Re-added `Qbs install` deploy step (QTCREATORBUG-17958) * Added `rebuild` and `clean` actions to products and subprojects (QTCREATORBUG-15919) C++ Support * Added option to rename files when renaming symbol using same name (QTCREATORBUG-14696) * Added auto-insertion of matching curly brace (QTCREATORBUG-15073) * Fixed that C++ and Qt keywords were considered keywords in C files (QTCREATORBUG-2818, QTCREATORBUG-18004) * Fixed highlighting of raw string literals (QTCREATORBUG-17720) * Fixed `Add #include` refactoring action for static functions * Fixed crash when parsing invalid C++ code (QTCREATORBUG-18499) * Clang Code Model * Added highlighting of identifier under cursor, which was still delegated to built-in code model * Improved order of items in completion list (QTCREATORBUG-18319, QTCREATORBUG-15445) * Fixed function signature hint when completing constructors and functors (QTCREATORBUG-14882) * Fixed that completing function pointer was adding parentheses (QTCREATORBUG-17578) * Fixed completion inside function template (QTCREATORBUG-17222) * Fixed wrong column number with non-ASCII characters (QTCREATORBUG-16775) * Fixed highlighting of primitive types and operators (QTCREATORBUG-17867) * Fixed highlighting of partial template specializations * Fixed highlighting of functions in `using` declarations * Fixed that keywords were highlighted in preprocessor directives (QTCREATORBUG-15516) * Built-in Code Model * Fixed completion of STL containers (QTCREATORBUG-1892) QML Support * Updated QML parser to newer QML version (QTCREATORBUG-17842) * Fixed crash in QML `Outline` pane * Fixed that auto-completion could overwrite text (QTCREATORBUG-18449) Debugging * Added `Alt+V` + letter shortcuts to open views * Added pretty printing for `qfloat16`, `std::{optional,byte}`, `gsl::{span,byte}` and `boost::variant` * Improved display of enum bitfields * Fixed support for `long double` (QTCREATORBUG-18023) * Fixed editing of strings (QTCREATORBUG-18681) * LLDB * Fixed disassembly view for code that contains quotes (QTCREATORBUG-18721) * CDB * Added support for extra debugging helpers and debugging helper customization * Added warning if run configuration uses unsupported shell command QML Profiler * Fixed that timeline could stay empty after analyzing small range (QTCREATORBUG-18354) Qt Quick Designer * Fixed context menu items that did not work on macOS (QTCREATORBUG-18662) Version Control Systems * Fixed format of visual whitespace in blame, log and git rebase editors (QTCREATORBUG-17735) * Git * Improved branch listing in `Show` (QTCREATORBUG-16949) * Made `git grep` for file system search recurse into submodules * Gerrit * Added validation of server certificate when using REST API * Fixed that non-Gerrit remotes were shown in `Push to Gerrit` dialog (QTCREATORBUG-16367) * ClearCase * Disabled by default Diff Viewer * Improved performance * Fixed state of actions in `Edit` menu * Fixed that context information for chunks was not shown in side-by-side view (QTCREATORBUG-18289) * Fixed that UI blocked when showing very large diffs Test Integration * Added view with complete, unprocessed test output * Made it possible to enable and disable all tests using a specific test framework * Fixed wrong location of results for tests with same name (QTCREATORBUG-18502) * QTest * Added option to run verbose and with logging of signals and slots (`-vb` and `-vs`) Beautifier * Added option for using a different AStyle configuration file * Added option for fallback style for `clang-format` Model Editor * Fixed crash with invalid files (QTCREATORBUG-18526) * Fixed crash when dropping package into itself (QTCREATORBUG-18262) Platform Specific Windows * Removed support for Windows CE macOS * Fixed that some context menu items in Qt Quick Designer did nothing (QTCREATORBUG-18662) Android * Added support for API levels 25 and 26 (QTCREATORBUG-18690) * Added support for `android-clang` (QTBUG-60455) * Added option to run commands before app starts and after app stopped * Fixed state of actions in `Edit` menu in text based manifest editor iOS * Added UI for managing simulator devices (QTCREATORBUG-17602) Remote Linux * Added support for `ssh-agent` (QTCREATORBUG-16245) Universal Windows Platform * Fixed deployment to Windows 10 Mobile devices (QTCREATORBUG-18728) Credits for these changes go to: Alessandro Portale Alexander Drozdov Andre Hartmann André Pönitz Christian Kandeler Christian Stenger Daniel Teske David Schulz Eike Ziller Felix Kälberer Florian Apolloner Friedemann Kleint Ivan Donchevskii Jake Petroules Jaroslaw Kobus Jesus Fernandez Jochen Becher Jörg Bornemann Kai Köhne Leandro T. C. Melo Leena Miettinen Lorenz Haas Marco Benelli Marco Bubke Mitch Curtis Montel Laurent Nikita Baryshnikov Nikolai Kosjar Orgad Shaneh Przemyslaw Gorszkowski Robert Löhning Serhii Moroz Tasuku Suzuki Thiago Macieira Thomas Hartmann Tim Jenssen Tobias Hunger Tomasz Olszak Tor Arne Vestbø Ulf Hermann Vikas Pachdha
Thanks for taking over Chris's series, renovating the subject, with an end :)
Any idea what part of GCC's license makes companies wary of contributing?
It isn't necessarily the license prevents contributing in my company's case. The issue is that GCC's license doesn't permit us to have our own version of the compiler, whereas LLVM's does. Thus, my company contributes to BOTH, however the GCC contributions are simply to enable new processors. Since we have an LLVM spin that we actively maintain, a large amount of our customizations actually get contributed back to the community. 
Arithmetic operations are the first ones that come off the top of my head right now.
&gt; mean that referencing null does something Exactly, now every pointer dereferencing has to have some behavior, even though it could be just crashing or accessing a valid address, it doesn't matter, it's more work on the compiler's part, and subsequently worse code generation.
&gt; The issue is that GCC's license doesn't permit us to have our own version of the compiler It doesn't permit you to have your own _closed-source_ version of the compiler. You can have your own GCC with your own customizations, but if you distribute that outside your company then you have to release the source code for those customizations.
Love the cleanup to the project view of CMake projects. The old pannel was littered with targets that shouldn't be shown in an IDE's view of the sources.
"Shouldn't". If a compiler "shouldn't" do something, you have the means to disable such thing. Linus didn't ask the compiler writers to remove strict aliasing from compilers, he rather disabled strict aliasing for Linux builds.
Thanks! Any thing else I can improve for you in that area?
Haven't pitched it because most of my committee time is spent working on compile-time programming for reflection. So lack of time, basically.
What if you make custom modifications to GCC and don't distribute the binary outside the company?
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Hey man! Where did `(iostream.h&gt;` go....
I'd be all for "-fno-undefined-behavior" or similar switch as long as it was reasonably standard between compilers. As it is, 1) I have to hunt for the right combination of switches to do that for a particular compiler and 2) exploiting undefined behaviour _by default_ is just insane. Compilers have had the ability to exploit floating point calculation reordering for a long time (-ffast-math), yet I'm not aware of any major compiler that does that by default, even though it would break an order of magnitude fewer programs,
Of course you're allowed to do that. The GPL says you can't distribute closed source forks, but if you don't distribute it you can do however you please.
How is "Don't explicitly optimize seemingly unrelated code away based on additional analysis" extra work? The problem with exploiting that kind of behaviour is that 1) the compiler assumes your code is perfect (demonstrably untrue in any non-trivial project), 2) said behaviour is extremely difficult for human to reason about (just see the top post), 3) it often results in removing and altering unrelated code since the compiler propagates completely unreasonable assumptions, 4) it multiplies the effect and severity of otherwise benign bugs or even code that would otherwise be valid, which has resulted in documented security flaws. Making a compiler do all that by default (instead of some "-fexploit-undefined" switch) is just insane.
I have been watching chernos videos since he did his game development in Java and Eclipse series. I was not aware he is doing a cpp series. Now that I currently have a job doing cpp, I will have to give this series a go. His videos were always very informative and fun to do and listen to.
So technically this sentence is wrong - "It doesn't permit you to have your own closed-source version of the compiler."
I keep hearing this, but as I said, I have yet to see a real world case (as opposed to a theoretical example or tiny artificial benchmark) where it would make any actual difference (say more than 1-2% difference). If you know any, please link to them.
More Qt related than Creator but please can we get 64-bit MinGW support out of the box? Pretty please :) 
Yes. Very wrong.
I'm a little surprised of the downvotes above, I was sharing the reason that my employer contributes extensively to LLVM (2nd most commits on a per-company basis?), but significantly less so to GCC. You're right, it prevents us from having a closed-source version that we can distribute. We have compilers for un-released architectures/processors that we give to some customers. Giving out the source for these would unnecessarily reveal secret information, giving our competitors an advantage. Instead, we do these patches on LLVM/Clang, and when we can release them, we share that with the community.
Can you please provide a link, which says that?
Clang provides a sanitizer for UB: `-fsanitize=undefined`. https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html
Insane is to expect your program to work when it trigger undefined behavior. But I see your point. You prefer safer than optimizing. But do recall why C++ is still used in mission critical software: it's not because it's safe, for sure. But because it allows for a lot of optimizations, the ones you're complaining about. If you need support to write safer software in C++, you have a handful of options. Primarily Clang, which provides a bunch of sanitizers and compiler flags. And again, you keep saying the compiler did unreasonable optimizations. No, the compiler isn't driven by illogical reasoning. The only valid code path for that program to be correct is by calling NeverCalled before main's entry. All other paths not calling NeverCalled are invalid and outside of the input ranges the compiler accepts. edit: &gt; How is "Don't explicitly optimize seemingly unrelated code away based on additional analysis" extra work? It is extra work to generate optimizing code. Needs more proofs to optimize checks away (assuming the compiler generates a check whenever a pointer is dereferenced, which would be the case if it wasn't able to trigger undefined behavior).
+1. It's a definite improvement, both usability and aesthetics / information overload.
What is people's experience with the clang code model? I tried it just now and it looks like the code competion doesn't work well inside template classes. For example, pressing CTRL+Space after `this-&gt;` doesn't show anything.
Of course there is a difference. A nullptr is just one special case of an invalid pointer but hardly the only one (e.g. consider pointer to destroyed objects). Contrary to many other kinds of invalid pointers it would be trivial on most systems to guarantee a certain behavior (e.g. program termination) on nullptr dereferencing.
Yes, they exist and I mentioned them in my original reply, but contrary to what I was subsequently suggesting, sanitizers introduce a significant overhead.
The simplest solution is to replace all occurrences of arrays with `std::array`, they work like normal types and can be passed to functions normally.
A single add instruction vs that and a branching instruction. Considering that branching is slow, making that decision in every arithmetic operation inherently makes the program slower. It's no doubt that languages with bound checks for arrays have it slower than the ones that don't bound check. I don't have any links to real world cases, but I'll save your comment and PM you if I find anything.
But if you are debugging, does it matter whether your program is slower? You aren't supposed to ship your binaries with sanitizers anyway.
argument 3 is `double**` but the function that works has `double***`..? In any case you probably want to either alias the type or put it as data member in a wrapper class (that any compiler would optimize away) or use `std::array` as already suggested. Anything, as long as you don't really have to keep track of how many stars you type.
You should consider using a proper matrix/tensor lib that encapsulates better the operations of your field as well as being efficient. It will solve this and much more. If you go the `std::array` route, you will also encounter other kind of issues, because they are not natively multidimensional friendly and you can end up creating unnecessary array copies, can't be unsized, etc.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6y9k3k/arrays_as_function_arguments/dmlo9hs/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
From the rest of the comment it's clear the author refers to distributing your own closed source version, which you can't and is the whole point of the GPL
For me, it's just far too slow to be usable.
What if I manually cast the problem variable (a vector in this case) as a double** when I use it as an argument? 
It would be awesome if we can get an option to group all CMake targets under one "tree-node". I liked the simplestic view of the project sources the old versions had, so if I get an option to group all targets I think it will improve usability.
you know you can't just cast stuff to stuff and expect it to work right..?
I still want to push into the direction where CMakeLists.txt files become UI-accessible. Basically I want users to be able to add new targets/files via the UI. This requires work on the cmake side (Creator will *never* be able to parse CMakeLists.txt files!), so this is not a short-term goal... But with server-mode in cmake that is an option we can aim for. For that to work, the project tree needs to be pretty details wrt. which target belongs into which CMakeLists.txt file, etc. So I would like to keep those details in the tree.
[removed]
That is a known problem with clang completions. Don't know if it's gonna be fixed upstream though.
If it needs a C++ compiler is C++.
I think there still needs to be a version of the detection idiom, as it lets you pass in arbitrary types that won't work with hana::is_valid - e.g. Function signatures,void, local aliases, etc. (I've tinkered a little with explicit template lambdas but don't think it solves this problem- it being 3 years from standardisation doesn't make it suitable for production code anyway) The version I posted above is far simpler than the partial specialisation version submitted for standardisation but retains the same syntax and therefore functionality. I'd be interested to see if louis has a more elegant solution to my issue however. Specifically, I use it for exact member function signature detection. 
Leverages is_valid, but uses a couple of basic macros and a slightly different approach to basically eliminate decltype and declval in user code: https://godbolt.org/g/n7rYW8.
Check out the "GPL Faq" page on the GNU website: https://www.gnu.org/licenses/gpl-faq.html#GPLRequireSourcePostedPublic
noob here, can i update Qt Creator with the maintenance tool? I tried so and I'm missing the configuration of the repositories.
It worked fine for me.
I will check it again. What OS are you running?
Sorry, I don't see why you can't use say function signature with hana::is_valid? Or local aliases? Can you give an example? The thing about exact matches is that its arguably breaking the contract of implicit conversions to even do so in the first place. Usually I don't care if a function returns a string, but whether it returns something a string can be constructed from. For this sort of thing, is_valid is much more natural. You should still be able to handle exact detection however with is_valid so that you are no worse off, and still able to do it more concisely (at the user site). Something like: // ugly but library code, equivalent to the implementation of `is_detected` template &lt;class R, class ... Args, class T, class R2, class ... Args2&gt; auto exact_mem_fn(R2 (T::*t)(Args2...)) -&gt; std::enable_if_t&lt;std::is_same&lt;R, R2&gt;::value &amp;&amp; sizeof...(Args) == sizeof...(Args2) &amp;&amp; all_same&lt;type_list&lt;Args...&gt;, type_list&lt;Args2...&gt;&gt;::value, int&gt;; And then you can use it as ... -&gt;decltype(exact_mem_fn&lt;std::string&gt;(&amp;decltype(obj)::toString));
I checked it on Windows 10 and Ubuntu 16.04. Your best bet might be reinstalling (your IDE preferences are stored outside the Qt Installation folder and should be kept).
&gt; Basically I want users to be able to add new targets/files via the UI. How would adding sources work if for instance in my CMakeLists.txt I have : set(SRCS foo1.cpp blah/foo2.cpp) set(HEADERS foo1.hpp blah/foo2.hpp goo.hpp) add_executable(foo ${SRCS} ${HEADERS}) if(HAS_SAUCE) target_sources(foo special_sauce.cpp) endif() ?
&gt; What is people's experience with the clang code model? Every new QtCreator version I try it, and I enjoy the added information and better "quality", but it is wayyyyyyyyyyyyy too slow. I'm happy if auto completion takes less than five seconds to show up (and I'm on a beast of a machine). Whereas the default code model is always instantaneous, but sometimes fails to parse modern C++ constructs.
&gt; You must be hiring directly. No third-party recruiters.
The AutoModerator removed this comment due to a word used in the equal opportunity paragraph; I have manually approved the comment. (I usually refrain from moderating anything MS-related but this listing is clearly on-topic and not an employer-duplicate). You should add a Technologies section, as specified by the template.
For all languages, do what the language (and its library) does. Do not look at example of style in books for they have physical constraints that your monitor doesn't. C++? Use snake_case. Case closed.
Look up [hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation) if you are programming for Windows. Popularised my Microsoft in the early nineties and makes the code very readable and easy to maintain. Some examples A simple class defintion: class CFoo { const char* m_lpszName; HWND m_phwndMainWindow; } By prefixing 
I agree and that is what everyone does for other languages, but seemingly very few do for C++.
I seriously hope this is sarcasm.
For the love of God do not use Hungarian Notation. One day you will need to change the type of a variable and you won't have time to fix its name in the 200 places it is used. I can see into your heart, I know it's true.
To make it compile you have to make a whole bunch of changes. Which means you are talking about different code than was posted. Maybe the "real code" didn't have any increment operators and those were also typoes. How do you know? 
I've not had to do this personally, but is it not generally a simple find and replace? Hungarian notation names are pretty unique
I personally would love the option to see files that aren't part of a CMakeLists.txt. it's a bit annoying to make a cmake mistake and suddenly all subdirectories disappear. Also, an "add file at this directory" option would be great. Thanks for all your hard work so far!
You've already wasted more time than this was worth.
wow, dude. Such dry humor. Careful, someone might think you were serious.
Good luck inheriting from void_t
What part of what void_t does do you think isn't described? It's an alias for void.
To be fair `void` and `bool` are about as different as `void_t` and `true_type. 
well, it's not really about checking whether something can be 'called', so implicit conversion is actually a detriment there - it's more checking that it 'exists' in an exact format. My use case is to implement final / pure virtual in policies and CRTP without breaking constexpr guarantees. I think it might be better if I supplied an example of what I'm currently doing: https://godbolt.org/g/hEPcC7 The implementation you've demonstrated, as far as I can tell, is very similar to how I'm using std::mem_fn to check for the existence of a specific function with a given signature. My issue is that with hana::is_valid, I have no way to re-use the check with different signatures (the way I'm re-using has_func with void() and void() const). It's that I take issue with - being unable to pass arbitrary template parameters into the lambda. All that being said however - hana does fix the 'bug' I'm seeing with clang... so maybe it's worth the compromise. edit: took a quick look at whether or not is_valid can be enhanced (or maybe... overcomplicated) via the use of explicit lambda templates - I managed to get what I wanted... I'm not sure I would say it's the prettiest code ever however: https://godbolt.org/g/sv8xQ7 edit2: realised I was significantly overcomplicating things - can just use is_valid, C++2a's explicit lambda templates, and a simple type/non-type template parameter list type to pass/extract what I need. https://godbolt.org/g/FBBahX
Well, if there were something called "int_t"...
I suspect you're joking, but I'm still curious how you'd prefix `std::unordered_map&lt;std::string, std::vector&lt;uint32_t&gt;&gt;::const_reverse_iterator`? Anyway, I find adding a prefix for scope is useful, at least in so far as to keep local variables and function arguments separate from member variables. Adding 'm_' on members is not a bad thing. Everything else about Hungarian notation is, though... 
I think true-false-int types are just subclasses of integral_type.
Writing languages to target LLVM doesn't generally require any changes to LLVM itself. Of course any usage can lead to contributors; find a bug in LLVM while writing your language compiler or whatever and so you end up contributing a fix. Some of the factors I'd guess are behind the large number of contributions are (in no particular order): - The permissive license is very attractive to corporate contributors. However, because the code base moves fast having private forks presents challenges and risks one getting left behind, so there's a lot of incentive to make public whatever can be. - The project started out in academia and has a large mind-share there. A lot of research on compilers and optimization gets done using LLVM. Compilers courses these days often use LLVM, which can lead to new contributors. - The codebase is well organized and inviting, and the surrounding community is quite easy to get involved with.
Speaking for MSVC++ we are not allowed to look at GPL'd things but we can look at MIT / Boost / etc. things (by company policy). /u/STL has commits against Clang and all the standard library maintainers (e.g. /u/CaseyCarter, Steve Wishnousky, and myself) have commits against libc++.
I worked with a guy who used it, he was a little anal. The one and only time I just trusted the Hungarian notation instead of checking the declaration it was wrong. So sure, it's a simple find and replace, and checking out all the files that use it merging, who knows. But why spread this info all over the place instead of having the type info in one place?
I agree with you, but at the same time its actually useful when dealing with the winapi IMO. I think for 99% of codebases its probably not helpful, but for something with extreme enforced stability (ie winapi) perhaps its useful in that context
The second line is an alias. The third line is a newline.
In general I think you should work in the style of the environment you are in, so yeah, maybe. Haven't really programmed windows in like 20 years so that's not a concern.
Still, I would not be surprised if, say, there are many people interested in making Rust faster, who end up contributing patches to LLVM primarily. Would be interesting to see a survey of all the new LLVM developers.
Does that mean [cppreference](http://en.cppreference.com/w/cpp/utility/variant) is wrong? It says &gt; As with unions, the default-initialized variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case default constructor won't compile: the helper class std::monostate can be used to make such variants default-constructible)
To have a *default-constructible* variant, the first alternative must be default constructible. If I don't need a default-constructible variant, the first alternative can be whatever I want. And `std::monostate` certainly doesn't hold a monopoly on "type that can be used as a filler/blank/empty alternative".
IfYouLikeReadingStuffLikeThisThenUseCamelCase. if_you_like_reading_stuff_like_this_then_use_snake_case. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Hn is cancer!
it conflicts terribly with the AAA
The fact that it's an alias for `void` is almost irrelevant to what it's used for, which is triggering a substitution failure in a partial specialization of a base template. Like the OP suggests, something like `std::is_valid` would already be an improvement, although you know my opinion about the detection idiom as a whole.
For Winapi it's seriously problematic, and has been for years. Just for example, in 16-bit Windows, `wParam` as a (16-bit) word-sized item, and `lParam` was a (32-bit) long-sized item. They're now really the same type, but the names `wParam` and `lParam` were/are too entrenched to get rid of them, so we can't fix them, even though they've been wrong for decades, and there's virtually no chance the prefixes will ever be meaningful again.
Currently you can not add files to cmake projects via the UI with Creator. So that does not work. The cmake developers are occasionally talking about adding that functionality to cmake itself. In fact that and syntax highlighting are the reasons to have a interactive way to query a running cmake instead of e.g. dumping a JSON file into the build directory with all the necessary information. If the cmake developers add that functionality, then I will use that in Creator. I hope they know the cmake features and peculiarities well enough to support your use case. I do not, so I can not parse the CMakeLists.txt files in Creator well enough to figure out where the new file names need to go.
I disagree. It is never a waste of time to make sure your code is consistent and easy to read. I personally use the standard library naming convention because I hate having my code littered with the same concepts (types, functions) named differently (why is it `std::string` but `StringRef`). On the other hand, if you are using something like Qt for your "standard library" (e.g., you use `QString` instead of `std::string`, etc), then it may make sense to use its naming convention.
&gt; It is never a waste of time to make sure your code is consistent and easy to read. It's always good to make sure you're not going around shooting people in the face. That doesn't mean that any time spent making sure you don't do it is the best way to spend your time.
Adding files to CMakeLists from UI would definitely be nice. What I miss more though is listing .qml files from my .qrc file in the project side panel.
Thanks but I explicitly asked for the lines of code, I know what a blank line is.
Not even in your free time? What if I kidnap you, tie you up and read out the GCC code?
Works on Linux. Be sure to choose "Update Components".
So, if you want to help people understand what this is and how it works, you might want to compare to https://github.com/apolukhin/magic_get which does something similar. (He also gave a talk at cppcon here: https://www.youtube.com/watch?v=abdeAew3gmQ) If I understood right, the starting point is similar -- you are going to try to detect the structure type by passing it some kind of artificial "detector" type in aggregate initialization. The detector has a template conversion operator, so no matter what type the member has, the detector can legally bind to it. The goal is to from there, somehow get back the type information. In `magic_get`, he has to create an explicit numeric code for every possible type. The detector type stores this code. At the end he reads the codes from the detectors. That's why he can't handle structs that have user-defined types, he basically only handles primitive types. He ends up getting a sequence of numeric codes that identifies the struct members in order. In yours, it seems you are not trying to convert the member type info to a numeric code. Instead, the only "output" you get from the conversion is that the "tag" type instantiates some other template, which in turn declares an overload of a global function "loophole" by means of a friend declaration. (I'll admit, I had no idea that friend declarations in a template could also be definitions in this way, and so inject dependent names into the global namespace. That is indeed a crazy loophole you discovered :) ) You later can detect each of these loophole overloads that were created by passing them each of the appropriate tag types, thus you can find exactly which `operator U` was requested in aggregate initialization. You might want to make a better write up of what is going on here, I think your intro at http://alexpolt.github.io/type-loophole.html is very hard to follow. You shouldn't just throw template code at people and say "isn't that so surprising? My jaw dropped" You should explain what problem you are attempting to solve first. Also the template code in question doesn't obviously have anything to do with struct reading, so either explain your example first and then explain struct reading, or start with struct reading and work back to your question. Also you should know that it has already been known for a long time how to store a "type" in a "variable" using tags. See "compile time type registration", here it is on stack overflow, I think it was earlier on boost mailing list. https://stackoverflow.com/questions/4790721/c-type-registration-at-compile-time-trick (Edit: It probably originated with Matt Calabrese, he describes here in a talk https://www.youtube.com/watch?v=gcsOsV5XSjk&amp;feature=youtu.be) But I never saw before that this "storing" can occur merely as the byproduct of a template instantiation, because of friend functions. That to me is the new part here.
It wasn't actually me who posted the link. :) Thank you for your detailed and insightful write-up. I guess you're right. After your words it seems that my post is really cryptic. I was just directing it to C++ developers. There are source code comments if one follows to the linked GitHub repo. I'd really love to link your helpful comment. Should I just link it here or should I link a blog post of yours:)?
Whatever you like man :) I don't have a blog right now, maybe I should make one but probly not for a while.
The Project view is a visualization of the build system. So I am reluctant to add files that are not part of the project to that view. I did add headers (which are typically not known to cmake), so that is not a hard rule, but I do not want tthe projects view to turn into a generic navigation widget. IMHO if you navigate via the project view, then you are probably not using the locator (Ctrl-K) enough:-) 
Good catch, I'll fix that:-) Actually the QRC files are listed with their contents in the project tree *below their targets*. But CMake also lists the .qrc files as input to the build system and that way creator adds another node for the .qrc file to the tree. Now it depends on the project tree layout (== on the project) which one of these is picked first when you open a .qrc-file :-/ Looks like I was lucky with my test project.
Thanks!:)
You implied that C and C++ compilers are different things and used this to justify your position. In practice they are not, so your justification fails.
For those interested, [this post](http://b.atch.se/posts/non-constant-constant-expressions/) explains how the friend injection works to provide stateful metaprogramming by referencing the relevant standards passages. The "Great Type Loophole" uses this in addition to deferring the deduction of `loophole`s return type until `loophole_t` is instantiated, which injects `T` as the return type.
This is retained search. We are technically hiring directly and are heavily involved in the process.
Hello. Right, if I replace `T&amp;&amp;` with `T` it works as intended. The code that causes a segfault with clang is [here](https://wandbox.org/permlink/5K11KOSWp1Vz44i7). The same code with `T&amp;&amp;` -&gt; `T` being transformed works just fine with both MSVC and clang, so I imagine the `T&amp;&amp;` is causing issues. I wanted to build clang trunk and debug the executable with gdb but I couldn't manage to build it so sorry for not looking into it more.
Then he has to find a new job, duh. :-D
they both look so good! I guess I'll use both :-)
You might want to listen to Sean Parent's talk: https://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil
Typing on phone so please forgive any typos. You say 'the variable r is an rvalue reference' but is that actually correct? I can understand maybe that whatever is assigned to r must be an rvalue but you've given it an identity; 'r'
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6yee6o/what_about_if_i_will_learn_cpp_without/dmmqz6i/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
If you ever get to do it you may want to ask Walter Brown how he feels about it. He may be a bit biased since void_t is his invention, but he seems to know a thing or two about TMP. If Walter sits in every ISO meeting/teleconference with you sorry for spam, I do not follow ISO that closely to know how ISO operates.
I swear the majority of the time I see the friend keyword its for doing some kind of incredibly shady C++ magic This kind of header would be 9000% useful to me at the moment, as I'm in full serialisation mode at the moment and it'd let me skip some code duplication &gt;I'll admit, I had no idea that friend declarations in a template could also be definitions in this way, and so inject dependent names into the global namespace. That is indeed a crazy loophole you discovered :) This seems like complete nonsense that this is possible, its great
Cannot decide if this is beautiful or horrible. Probably both.
I'd recommend against using something like this in production, as the committee want to [make it ill-formed](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2118) and you need to be very careful not to break the one definition rule.
That's a shame, it seems too useful for them to make it ill formed, although I also suspect itll actually go out of the window when we get proper reflection
They follow different specs, even if those specs are implemented by the same executable.
I don't understand the rationale for making it ill-formed and thus not allowing it. Yes, it's arcane, but so what? It's powerful and useful.
&gt; I'm in full serialisation mode at the moment and it'd let me skip some code duplication I would also love to use it for serialization, but I wonder if it would cause a big compile time and binary size bloat in a large code base.
I hit the same problem. Try pressing "settings" then go to "repositories" and add this as a new user defined repository: "http://download.qt.io/online/qtsdkrepository/linux_x64/desktop/tools_qtcreator/".
At least for me personally on a small project (31k), it'd be worth it purely for correctness as I know that I haven't missed anything. I may actually just use this as a test to validate the existing implementation to make sure I haven't missed anything
I found a small bug: given an empty struct `as_type_list` returns a single type of the struct itself, instead of an empty list. https://goo.gl/4ivePx It also does the same for primitive types, which could be thought of as a feature, but can easily cause infinite recursion if you're trying to visit a type recursively.
I use an external script to check if I haven't missed anything. Let's say I have: struct A { int SERIAL(member1); string SERIAL(member2); SERIALIZE(member1, member2) } The SERIAL macro is empty, and SERIALIZE defines the `serialize` template method. (I use the cereal library) The script returns an error if the contents of all SERIAL and SERIALIZE macros are not equal.
It's correct as written. You're confusing the types with the value categories.
just don't use m_ for members, it's a stupid idea ;)
I prefer Pascal_snake for types to ensure I never give the same name to a variable and a type. 
It is like C++, both awful and awe-ful.
Because they want the type system to be stateless. If we need or want state, using a hack like this makes the code more arcane. It is a poor way to add stare to metaprogramming. Add state in the front door, not the back. 
If you think, that the only alternative to UB on integer overflow is introducing bounds checks everywhere you are grossly mistaken. Point in case, gcc has - for years - guaranteed wrap around behavior and it's not like performance suddenly skyrocketed once they dropped that guarantee.
Not necessary faster, but I try to somewhat follow Rust's dev (just out if curiosity) and I see a lot of patches from their side to LLVM since they frequently uncover some bug or regression in it. And wasn't the entire AVR backend contributed to LLVM mainly to [bring support of Rust to this platform](http://dylanmckay.io/blog/rust/avr/llvm/2017/02/09/safer-microcontrollers-almost-here.html)? So I'm pretty sure that the new languages that chose llvm as their platform are one of the main factors in LLVM's exponential growth.
This is why we need reflection/metaclasses. To not having to entertain the idea of making use of crazy hacks like this in the first place.
`m_I_Will_Kill_You_if_You_Name_YourVariables_likdis`
That makes sense. Having a sensible, “obvious” (as in: it's clear what this thing is doing) replacement, it does make sense to make the unintended side-effect invalid.
Good point 
Snake case is objectively more readable[1]. It also uses up more space. Your code will also look like it belongs in the standard ;) [1] http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf
Stroustrup uses Capitalized_with_underscores for class names, which I like.
Use lower_snake_case for all but template arguments. Its how the standard works. Do as you see. Let's stick to it and all be happy.
I think the key point is how easily and subtly you could violate ODR with this, and how terrible and cryptic the consequences would be.
Here is a simple example using this loophole to detect the inner member of a struct: https://godbolt.org/g/L4ZC2R Really neat! 
Well, that depends.. I tend to not use **get** as prefix for getters, in which case your suggestion is a problem. For example, this won't work: class Foo { public: int value() const; private: int value; }; It might be a good idea to use some prefix for member variables then.
I mean, just use boost fusion, declare your data as a boost fusion struct, and then you can reflect over it in a tuple, with zero limitations, and write your serialization code with zero duplication. Or if you object to this for some reason, you can use boost PP to write a macro that you use to declare your variables with and achieve a similar effect. I've been thinking about writing a blog post that implements this and talks about how, it's not very hard (maybe like 100-200 lines of code tops).
&gt; In C at least people use lower_snake_case for types, why not so in C++? I don't think this is a very good reason for snake case. C++ focuses a lot more on types than C does, and that's just one of the many, many ways that the languages are fundamentally different in how they're used. But this speaks to the core problem. A lot of C++ programmers originally came from a C background where snake case would be more common. On the other hand, a lot of modern OOP languages went with camel case, and some C++ programmer went that direction instead. Personal opinion: it's a mess, so get used to it. You can pick one style, but then a library will use a completely different style. And a third library that differs from either one in subtle ways. I'm partial to camel case, and I'm experimenting with a particular variant: the first letter capitalized for things like types, global variables, free functions, static members, and a few other things, while a lower case first letter is used for local variables, member functions, and the like. So far the experiment is going well ... but I'm sure lots of people in this thread would hate it.
How do these courses work? I am a college freshman learning C++ at the moment and I'd love to try this out but is it structured like an actual class where I will be asked to complete work or do I sort of do my own thing? I just want something to learn on the side not more stressful coursework. 
Sadly I was unable to get it to work. See: https://developercommunity.visualstudio.com/content/problem/108486/unable-to-load-libcmake.html
I had the same problem. What turned out to be easiest for me was to create a CMake file to build the IDE files. One can verify that the IDE built is equivalent between the two build systems. Of course this is a pain in the short run. But it pays off pretty quickly as it's much easier to keep CMake files up to date and just regenerate the IDE files. It's meant that I can avoid having to learn where everything is in Xcode in and an VS. In both places it's very hard to find where to set stuff. Also my project is large - 250 tests so making a change in either one is a huge pain.
As somebody who made the switch I would just suggest learning all the shortcuts, text navigation and selection with ctrl/alt etc but most importantly advise try not to adapt Xcode to a vs workflow. They are quite different and are both best used without trying to make them something they're not. The biggest difference for me is how tabs and assistant editors work. Now I'm proficient with Xcode I find it to be very smooth to work with. VS always feels awkward, big and bloated. Make sure you check out open quickly too...
It's an ad for a [Udemy Course(no referral)](https://www.udemy.com/unrealcourse/) 
Although they've changed a bunch of the shortcuts in Xcode 9, so look forward to that.
Personally I've fallen out of love with Xcode. I used to really like it, but since Xcode 8 I just don't really like it as much anymore. I tend to use Sublime for everything now. I kinda hate Visual Studio too. I can't really explain *why* me and Xcode aren't getting along anymore, we just aren't.
There's also a bunch of new C++ refactoring support (finally) so that should make up for it
I write both Verilog, C++ and Assembly. I use Emacs extensively. I've tried on many occasions to move to a 'proper' IDE (specifically, CLion) but the keybindings are a deal breaker for me. I just cannot get use to them; I am at one with the Stallman.
Good point. fuzzy testing is probably the only situation where debug performance is really important - maybe also for games and the like. I guess the other question is how confident you are that there will be no case of nullptr dereferencing in the shipped binary. 100% Test overage on non-trival software is imho a rare thing. 
**Company:** [Moz](https://moz.com/) **Type:** Full time **Description:** We're looking for someone to help us build novel approaches to big data. Our team creates infrastructure and systems that process petabytes of data and indexes tens of trillions of records daily. We're a small team that believes in punching above our weight. You'd be the team's third engineer. Technologies used include C++, AWS, and Linux. We're part of a startup that is profitable, well capitalized, and positioned to effectively use your efforts to grow rapidly. Above market compensation. Our work includes: building infrastructure that distributes and coordinates data processing across computers; designing abstractions for data processing; and using it all to index the web. If you think this type of work is interesting and can write performant &amp; maintainable code, we'd love to work with you. **Location:** Seattle, WA **Remote:** No **Visa Sponsorship:** Yes **Technologies:** C++17 draft, Linux, AWS, latest Clang **Contact:** recruiting@moz.com . 
Do you *have* to use Xcode? Personally I find Qt Creator and/or Clion to be much better for C++ than Xcode. If you are forced to use it though I feel your pain. If you find a good guide please share it!!
wow, c++ is becoming amazing! and soon there will only be 9 people smart enough to use it!
&gt; [...] how confident you are that there will be no case of nullptr dereferencing in the shipped binary [...] Could just as well use the `not_null` wrapper from GSL.
Thanks for the reply, I didn't find that link yesterday, I'm updating Creator rn.
They also stopped supporting plugins. What is an IDE without plugins?!
Who forces you to use XCode? I mean you can use the same compiler, but a different editor
But the a_ and m_ notation is still wildly popular (at least in the game industry). 
&gt; The rule for C++ is that any C library of the form `xxx.h` is also available in `namespace std` using the header `cxxx`. To clarify what you said (since it could be understood at least two ways): Other than macros using the form `cxxx` exposes the same symbols but is only guaranteed to do so in `namespace std`: The following code is not guaranteed to be valid under the C++ standard: #include &lt;cstdio&gt; int main() { printf("Hello world!\n"); } While the following is guaranteed to be valid: #include &lt;cstdio&gt; int main() { std::printf("Hello world!\n"); } &gt;In the C++ standard library, however, the declarations (except for names which are defined as macros in C) are within namespace scope of the namespace `std`. §17.6.1.2 [headers]
&gt; It is never a waste of time to make sure your code is consistent and easy to read. When both options meet that goal just fine, why spend time bikeshedding?
I used a previous version of it on a project a while back, and it could handle fairly wicked c++. It understood auto keyword, and weird boost crap really well. My project was small enough it wasn't even insanely slow like other people complain about. My biggest complaint at the moment is just that it's a pain to use on Windows.
I use Clion daily, however I must say that XCode 9 is *finally* getting better at C++, thanks to better navigation, refactorings, etc.
I use PascalCase for App/Domain-specific classes, and snake_case for std-like generic things. Not sure it is a good idea, but it helps separate things in my head. "Is this a library?" Of course, sometimes things turn into libraries, but I actually tend to know whether that is going to happen or not.
I had to make this transition about 9 months ago and it was very hard at first, especially since the Mac I'm working on is too slow for code hinting to be useful. What I found that made it easier to work with was changing the key bindings to be more Windows like as that was what I was used to, as well as changing double clicking a file to open it in a new tab. Due to the lack of hinting I basically had to navigate to the file with the declaration of what I wanted to call to see the names/signature. Using Cmd+Shift+o to do this made it much faster as you can search file names, types, method names etc. And quickly navigate to it. This is similar to VS' Ctrl+, hotkey. Not sure if this is the kind of advice you're looking for but hopefully it can be of some use!
You can compile your own libclang plugin profiled for your source code. You should get a [speedup](https://cristianadam.eu/20160104/speeding-up-libclang-on-windows/) around 20-30%.
I really liked this youtube comment on antony's talk: &gt; 27182818284590452354e-19: &gt; &gt; Witchery! Most vile! &gt; &gt; But seriously, compilers deserve this abuse for not giving us proper reflection. Speaking as an American, the USA should be happy that compiler abuse is not an olympic event, because the Russians would probably take every medal :P
Does Xcode 9 finally support C++ refactoring? 8 was not bad, except no refactoring support.
Yeah: &gt; Xcode 9 supports a number of different refactoring actions for C++ projects, including things like "Extract Function", "Generate Missing Function Definitions", "Add Missing Switch Cases" and others. In general the list of "supported languages" includes C/Objective-C/C++/Objective-C++ and Swift of course. ([source](https://stackoverflow.com/a/44532474/378298)) Also, see Apple's [changelog](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/xcode_9/xcode_9.html)
So what about sticking to the standard naming convention? That would be the most consistent one.
That seem very popular for modern C++. But I can't understand why, other languages don't seem to need this separation of styles at all. Is C++ more complex and need this crutch?
**Company:** [Datawire](https://www.datawire.io) **Type:** Full time **Description:** Datawire is a company focused on building open source tools for organizations adopting Kubernetes and microservices. We're looking for a C++/Go hacker who can work on Telepresence (www.telepresence.io), our open source tool for fast, local dev of services on Kubernetes and Ambassador (www.getambassador.io), our open source API Gateway built on Lyft's Envoy L7 proxy. We're working on figuring out the best ways to make state-of-the-art tech (Kubernetes, microservices, Envoy, Docker) accessible to developers. Big bonus points if you like to write about technical things, know Kubernetes and/or have prior experience in a microservices architecture, and also know Python / Kotlin / JavaScript (we're a polyglot shop). **Location:** Boston **Remote:** Yes **Visa Sponsorship:** No **Technologies:** C++11 Optional: Python, Kotlin, JavaScript **Contact:** Email careers@datawire.io or [see job posting](https://angel.co/datawire-io/jobs/265354-principal-software-engineer-envoy-oss)
you could try doing something like making a thread pool / task queue using c++14/17 standards. It'll be a useful crash-course in getting you up to speed on modern c++. If the last version of C++ you've used is C++03 you'll be pretty out of date at this point.
Well, there's no "standard naming convention" is there? There's the one used by the C++ standard, of course. But I'd say more code out there uses camel case, which makes that the defacto standard. You're going to get a mix no matter what you do.
I don't think it's good design at all to just send a struct/object over network, or save them in some external buffer. That's what serialization (e.g. protobuf) is for. Otherwise you could run into some nasty issues, like different struct padding etc (when the server runs on a different architecture for example). Better play it safe.
Seems about 50/50 camelCase vs snake_case in my experience. But snake_case is the ISO standard. CppCoreGuidelines says snake_case is the original style. I can understand wanting to keep consistent with existing code. But when you're starting a new project don't you want to be consistent with the standard library?
&gt; But when you're starting a new project don't you want to be consistent with the standard library? If the only library you use is the standard library, that might make sense. But it won't be -- the C++ standard library is very thin. You create a GUI using Qt and everything becomes a mess. When inheriting from a Qt class, should you follow the Qt naming conventions, or should you use the standard library's? Honestly, both options suck, and there's no good answer. So I say to just pick whatever style you like best and stick to it. Be consistent within your own code, and it won't matter in the long run. C++ programmers need to be able to read multiple naming styles and indentation styles fluently, it's just the way things are. If there were one single style like other languages have, then sure, that should be the one to choose. But that ship has sailed, and it's not coming back.
Nevertheless, systems that dump binary data like this are common and there needs to be some way to interface with them.
I did, but moved to vim+ycm because of very bad c++17 support. Eclipse has the fastest indexer for our project of ~50-100k lines of code. YCM and KDevelop' s indexers take a lot of time after every change. I haven't tested Clion, but it's also not up to date with the standard. I'm interested if there's any IDE that is as fast as Eclipse CDT and supports c++17, or at least doesn't refuse from indexing whole file with c++17 syntax. E.g. YCM doesn't like template constructor template deduction, but understands other symbols in the file. CDT refuses to parse anything if there's `namespace a::b` or other new syntax in the code.
Hackerrank practice challenges https://www.hackerrank.com/domains/cpp/cpp-introduction
If you don't give a reason you are stupid. 
`apt install libhardcorerefresher++-dev` Edit: *It was a joke!*
Don't do it. Almost every IDE you can find (XCode, QtCreator, vim, Visual Studio) is better than Eclipse to do C++. I personally used Eclipse to do C++ for a little while and then switched to Visual Studio because you can just feel that Eclipse wasn't meant for something like C++ and it is just tacked on.
i chuckled. why the downvotes? bunch of salty mofos in the cpp subreddit huh
Maybe downvotes because no sudo?
Is it likely that any of the reflection and metaprogramming stuff will make it into C++20?
 make sudo Problem solved.
sudo upvote me
Clang requires you to have a pre-registered account to file bugs. I'm hoping someone can just file this simple repro as a bug. Cheers
&gt; AddressSanitizer’s job is to detect this issue and to report it to the user. Currently there is no real equivalent on Windows platforms I really admire these guys trying to achieve the extraordinary. I built chromium with ASan just two weeks ago and I felt I was going the extra ten miles for my company...
sudo: upvote: command not found
Not a bug. Go ahead and change to other compilers, the behaviour is the same.
`vcpkg` is too great at what it does to be besmirched like this! Heresy, I seethe, heresy.
No, Eclipse works "perfect" only with Java, with C++ the experience is far worst Try CLion, for me it is the best IDE for C++ avaliable
Neither Eclipse or CLion has nothing to do with C++17, in both you has to install a proper compiler, if you install old versions it will not support C++17 at all or if you dont care with compiler the ide will use and pick whatever it shows you maybe wouldnt get the lastest
Unfortunately it's not a bug. You need to either enable C++11 (add -std=c++11 to the compiler options), or insert a space in the centre of "&gt;&gt;". It's a quirk of parsing that prior to C++11 a "&gt;&gt;" is unconditionally interpreted as a shift operator.
clang defaults to C++03 and thus this isn't valid. You need to add "-std=c++11"
https://i.imgur.com/82148su.png
 sudo make sudo or no?
Unlikely, the major goals for C++20 are concepts (already partially in), modules, ranges and co-routines. Maybe the networking TS. And that's a lot! I've briefly participated in the inception of the initial static reflection proposal and have been following how it progresses since then, It's going quite well and I hope there's a chance for it to make into C++20, but since it's not even a TS yet and I won't hold my breath. Metaclasses are probably a C++23 thing to be build on top of reflection.
6 years from now? That's depressing :(
To me it is simply amazing how much progress C++ has made since C++03. To be able to evolve a language that is so complex so much in mere 15 years. It is really a great achievement.
You don't always log in as root?
Particularly given its stagnation before then 
Also, a question. In your blog post you labelled this c++14 but i dont see a reason right now why it cannot be c++11. If it can be c++11 that is another innovation. the numeric codes calculation in magic_get seems to require extended constexpr, but i think this template friend stuff should be okay in c++11
Indeed... But that's also our fault as a community for not putting some effort ourselves to make those things go faster: - just a handful of C++ developers participate in the implementation of new language features on clang/gcc or library features. - when features are available on those compilers (or even in MSVC++ recently) only few of us try them and provide a feedback. - when some big features become a TS and are made available we dismiss them completely just because it goes to std::experimental namespace or because only one compiler supports them or because it may change a little, losing what could be an opportunity for real-world experimentation. Let's not forget that the C++ standard is a collective and *voluntary* endeavor and that the committee is eager for input on new features to reduce any uncertainty around them. It would be nice if we could to turn some of this dissatisfaction into positive action. BTW, isocpp.org should have a section for "how to make your favorite proposal move faster" :)
I totally understand, writing proposals and defending it against the committee is really hard and a bit intimidating haha. I can still wish it was faster, even if I don't blame anyone :P.
return type deduction is C++14.... but if you don't need the type info then may be it could work
I use Eclipse CDT daily. If you're experienced with it in Java you just need to configure it a bit. It's far from having all the features you get for Java but the basics works better then Vim, Emacs and stuff like that, particularly if you have an "weird" environment (like myself compiling on remote machines through NFS shares and say). I suggest you take a look at Mozilla's guide for working with Firefox in Eclipse CDT. **However all the above is for Linux workstation.** Obviously if your main workstation is Windows you can't get anything better then Visual Studio.
Only on Windows and Macs. On Linux, it's mostly Eclipse, QtCreator and CLion.
Jesus christ I just don't know where to begin after starting from roughly C++95 (I think? I was super young when I first looked and learned) to get up to date in any capacity.
Is it a crutch?, or is C++ a multi-paradigm language, where everything - even naming - comes down to "it depends". Most languages have one way to do things "do it with OOP the java way", "just use a hash map", "follow this pattern", "put everything on the heap"... C++ lets/makes you decide each trade-off.
And I am wishing someone with time to help will read this and get motivated. :) Sorry, I didn't mean to imply you're blaming anyone.
98 was the first standardized version. (Though the language was usable long before then.)
Is return type deduction necessary? ~~I understood that the function needs to be declared in the global namespace before `friend` in order to be visible globally later.~~ (Hmm... it also works sometimes in examples that don't do this.) But when the friend declaration occurs, we are making a new overload anyways, are we not? So could not the initial declaration just be `void` or something? It also occurs to me that maybe instead of putting the stored value in the return type, it could maybe be in a second parameter or something, and then later extracted via a trait or something... I guess I need to play around with it. Edit: Ok, I'm giving up for now. It seems pretty hard to do this in C++11, a least I'm out of ideas for now.
Can you provide links to how people could help?
&gt; I'd recommend against using something like this in production, as the committee want to make it ill-formed and you need to be very careful not to break the one definition rule. I think it would be a good idea to correct this only *after* static reflection is added. Until then, this is genuinely useful. 
I'm using Eclipse CDT on daily basis for a big project on Windows. You need to know a few things about it: * It requires a lot of memory (for a big project that is). And to give it a lot of memory you need to edit eclipse.ini. For my project, I gave it 8Gb. Like so: -Xmx8000m * You might want to increase cache size of the C++ indexer in settings. * Debugger is quite bad. But at least on Windows, it is very much possible to debug with Visual Studio. You can start it like this: devenv /debugexe youproject.exe Or right click on a running process in task manager and select "Debug". Or use "attach to process" from running instance of the Visual Studio. * It requires precise project configuration for a good indexing and completion. It needs all the include directories and all the defines. Otherwise, you'll miss a lot of potential Eclipse CDT have. * Having said above things about configuration I have to admit that project setup in Eclipse CDT itself is not trivial. The best bet about project management would be a project generated with CMake. * Eclipse CDT indexer chokes in STL from Microsoft Visual Studio. At least I was never able to make it work properly with it. It sounds strange, but for editing, I'm generating Eclipse CDT+MinGW Makefile project and then replacing build command with Ninja+MSVC (Which is MUCH faster than msbuild). I tried QtCreator and CLion with my project. As well as Visual Studio. Speed and quality of indexing, code completion and navigation in Eclipse CDT is absolutely the best (given that you have enough memory and have properly configured project). Yes, it's far from perfect overall, but it is definitely usable. 
On the other hand, using snake case for both forces you to think of a good(?) name for your variable, rather than just naming it after its type.
Writing high-quality portable tests for libc++ would accelerate libc++ and MSVC STL development (I wrote shared_ptr for arrays slower than I otherwise would have, because I had to write tests too - libc++ hadn't implemented or gained tests for that feature yet). I have a laundry list of improvements to the existing tests that could be made, too.
This surprised me a little, I started C++ a few years before C++11 became standard (probably 08/09), and when it did it took a long time for compiler vendors to get up to scratch I've been using C++17 for a few weeks now, so internally I think I'd assumed that it'd been standardised absolutely ages ago Its nice to see that the compilers are way more on point when it comes to implementing stuff these days. It doesn't seem to just be standard revisions, but generally there seems to be a much greater focus on 'make compiler good', I guess a lot of this is likely down to LLVM existing and giving the competition a good kick up the bum (thanks LLVM!)
This subreddit is a good place for catching news and hanging out, but the really technical discussions and big decisions tend to take place on mailing lists. Subscribe to a Boost/LLVM/GCC mailing list if you are interested in pushing the language forward from the library or compiler side of things. There are surely other lists too, but these are the first which come to mind. Once you feel comfortable with the group dynamics and some subsection of code or topic, start posting :D It can feel difficult at first to get people's attention on a mailing list, especially a high-volume one, so be persistent. If you are polite, eager to contribute, and can learn independently, then you will find someone who can point you in the right direction. The key is to go with the flow of things, working toward the same goals as the project. The flow of things can be very fast, so it takes effort and commitment to stay up-to-date with a project. Keeping up with the list developments is kind of the baseline level of involvement. If you can do that, then you can contribute code and technical comments, which really puts you at the front of the pack. It takes a huge effort to do this and still perform at a demanding job, so my level of involvement tends to come in spurts. The weight your posts carry on a C++ mailing list is determined by the following factors, roughly in order IMO: 1. demonstrated commitment to the project 2. quality/relevance of technical comments 3. prior contributions Hope this helps. I am far less involved than many others on this subreddit (and not really involved at all wrt the ISO standard... yet) so my advice shouldn't be taken as gospel.
But, it's hard...
One man / woman's "real world" is very different from another, but let's suppose we can agree that multiplying large matrices together is important for scientific applications, for machine learning, and potentially lots of other things. I would expect that doing bounds checking when multiplying two 20 MB square matrices together in the naive way, instead of skipping the bounds checks when scanning across the matrices, saves a factor of 2 to 5 in performance. If it's less than a 50% gain on modern hardware I would be shocked. On modern hardware the branching caused by the bounds checks is probably more expensive than the actual arithmetic. The optimizers / pipelining are still pretty good and it may be able to eliminate many of the bounds checks if it is smart enough. I don't know off the top of my head of anyone who ran such a benchmark recently but it shouldn't be hard to find. If you don't think that's real world, then we just have to agree to disagree.
Wow, how did you set your colors like that? The white background of reddit kills me. And the threading mode? :D
It's SFINAE. [This SO answer](https://stackoverflow.com/a/34706276/2397809) walks through a few SFINAE approaches, and finally arrives at the style shown above. 
I decided to mostly copy C# conventions. `PascalCase` for anything file-scope, also for methods and public data members. Lowercased `pascalCase` for arguments and local variables, `_member` for private and protected members. As for template parameters, `PascalCaseWithAppendedT`. I find `snake_case` ergonomically difficult to type.
Exposure to GCC source presents some legal questions for a closed-source compiler vendor. The FSF and Microsoft don't exactly get along, either: 1. https://www.fsf.org/news/microsoft_response 2. https://en.wikipedia.org/wiki/Free_Software_Foundation_anti-Windows_campaigns 3. http://www.fsf.org/blogs/community/dear-microsoft-fsf.org-is-not-a-gambling-site
That looks like night mode in [RES](https://redditenhancementsuite.com/).
A library for this would be very useful. I also think that the commitee should consider closing this "hole" after adding at least static reflection. The feature is too useful to ignore it.
Uh, thanks, installed, it looks quite neat :D
Lets Hope Full implementation finishes soon also. I want dem parallel algorithms.
Qt Creator with the clang backend enabled absolutely destroys Eclipse.
That's not true, those IDE parse c++ on their own a lot.
To be fair the compilers are also very conservative : clang still ships in -std=c++98 or 03 by default for instance, for fear of not breaking. But this allows hacks to accumulate and bad code to persist. Also, a lot of people use debians or ubuntus and have to wait for years before being able to use new compiler features because the c/c++ toolchain is paft of the core OS and not separate like in other systems or languages, which makes libstdc++ not easily updateable at the risk of breaking everythin if there is an abi update or something..
C++ as a user facing language has a reputation for being a fairly obtuse language, that is somewhat deserved and somewhat overblown C++ as a library implementation language has a reputation for being obtuse and complex that is completely justified. You get to your first template&lt;typename T, typename = std::enable_if_t&lt;!std::is_base_of_v&lt;serialisable, T&gt; &amp;&amp; std::is_standard_layout_v&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;&gt; And realise you have no idea what's going on anymore. This is really simple stuff for someone who has a real good knowledge of C++, and it barely scratches the surface of implementing library features Writing new specification submissions for C++ requires a proper understanding of how on earth C++ works, as well as a deep understanding of how to write library code. It feels like you need to be capable of fully implementing std::vector&lt;&gt; to the specification before you submit anything The suggestions as I can see them are: 1. Submit reviews for TS's/experimental std library features 2. Implement compiler code 3. Pitch ideas for the spec The base of users who have the ability to do this is... pretty small, even within C++ which seems to have a fairly high skill userbase. A lot of these tend to be solo efforts, and we're fundamentally saying why don't *you* write up a spec for C++ This IMO is entirely the wrong approach - the core problem is that these things are A: Difficult, and B: Obtuse to get in to I think we can fix both of these at the same time. Various C++ folks have different skills, I myself have some knowledge of C++, and would consider myself more knowledgeable than a lot of folks about undefined behaviour, but it is not complete enough to write a standards proposal. Other folks have different knowledge What we need to do is build a community driven approach towards solving these problems - where instead of one or few people working on a spec proposal/compiler implementation/review, lots and lots of people can contribute a small part of their knowledge The key to building a community driven approach is attracting people, presenting a 0 friction entry point, and creating a focus around a particular problem that people agree they want to try and solve **Concrete shell of an idea:** Build a website dedicated to the above. Every month or so, a new focus/idea for a piece of work (spec/review/implementation) goes up Say the focus is "we're trying to flesh out an idea for X and turn it into a draft spec proposal" The website would direct you to an area where everyone is trying to figure out what we're doing. You'd need lists like "this is what needs to be done overall", "these are concrete actionable items that need to be solved", which could be managed by volunteers (I'm thinking a stackoverflow style system, as that leads to the most boring but dedicated individuals being in charge heh) So for a spec item you'd have the overall things that need to happen for a spec proposal, but more importantly specific items like "section 32 needs the wording to be more compatible with the standards definition of rvalues". This is a distinct actionable item that somebody with the appropriate knowledge of rvalues can do The key here is breaking it down into an easily accessible set of actionable items managed by the community that somebody with the right knowledge can do. With implementation, I can write a function and submit a PR for it, but the problem is I have no idea what is helpful and integrating into a project is hard. There are a million projects, and a million issues, but if there were a "This is what we're doing at the moment to help with C++" site which was setup to be as easy and direct as humanly possible, it would be much easier for me to get involved With this kind of system, I think it'd massively lower the barrier to entry for people helping in C++ and we could get things really moving This is just an example of an idea, but I think it gets the point across
I tried compiling this with ubsan. Not only does it provoke no error, but the compiled program tries to run "rm -rf /". $ clang++-3.8 -fsanitize=undefined -Os -std=c++11 -Wall ubsan.cpp -o ubsan &amp;&amp; ./ubsan rm: it is dangerous to operate recursively on '/' rm: use --no-preserve-root to override this failsafe Anyone know why?
Fortunately we have these things called "libraries" ;)
My first thought was that it's impossible to write code like this and then http://cpp.sh/4tkqs
great, the only problem your code is only GCC, let me make it universal https://godbolt.org/g/bxcKZY :)
It's actually quite useful if you need compile-time strings. And with the help of a macro you can generate those easily, in one of our libraries we have: ``` TAOCPP_PEGTL_STRING( "foo" ) // yields a type tao::pegtl::string&lt; 'f', 'o', 'o' &gt; ``` (From [here](https://github.com/taocpp/PEGTL/blob/ee9d99d873728a2c88aad733fcfe64d1708649a6/doc/Rule-Reference.md#taocpp_pegtl_istring--)) Obviously, you'd **not** use it for normal strings... :) EDIT: And I don't think the slide reflects their actual code, as storing a string in just one `static const char` is not too useful, although with a CRC8 they might even use it to optimize if-else-cascades into a switch-statement :)
Thats essentially C, not C++ … Don't do it, its the opposite to a good preparation.
Thank you for your valuable input. The reason is mainly that you should not care that something is a member, what you should care about is what it is in the first place. That's why IMHO the best approach is to either not mark members at all or use Google's trailing underscore (member_).
ITT: people who think that "familiar (to me)" means "good" etc. and that "unfamiliar to me" means "annoying" etc.
And then everyone will start to argue about the color of the bikeshed, or the like.
&gt; argc is always at least 1 Not according to the (public draft of the) standard... (§ 3.6.1) &gt; The value of argc shall be non-negative.
so assuming the bmw code would compile... Function just returns the first character, which is statically known based on the type, hence the variable is called S?
I agree that this kind of thing could happen, but it'd be such a massive step up from what we have now (very little) I think it'd be worth doing I'd set up a prototype if I had any web ability whatsoever... but C++ dev yunno :)
No, as I already said `Function` might be a `constexpr` CRC8-implementation to calculate some value on the string at compile time. And `S` then probably stands for `SuperSecretHashValue` ;)
Just curious, if more people implemented ideas as experimental compiler extension, would it speed up adoption by the c++ group ?
oh, thanks) i'll fix it
well, after another look, i actually mention that in the header type-loophole.h at github: you can pass it a type with a constructor (not aggregate type) and will detect it, but you can easily get in trouble:) https://github.com/alexpolt/luple/blob/master/type-loophole.h
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [alexpolt/luple/.../**type-loophole.h** (master → 3080d68)](https://github.com/alexpolt/luple/blob/3080d68a2fcb6db1403e89de81981987a2a7ff16/type-loophole.h) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmof054.)^.
Yeah, the competition between GCC and LLVM is great. I love those compilers. There are others though and their C++ standard support is not great. For instance, Visual Studio still doesn't support C++11. If you try to write cross-platform code this causes no end of headaches since windows users invariably expect to compile with Visual Studio. :(
Yes it compiles in VC++ 2017 https://godbolt.org/g/nxAG5z and most likely it was a bug.
Can I download it without a developer account?
The inline compiler errors are great, but I get some bogus errors, and they are very distracting. The project compiles fine with a makefile, and I set the same compiler flags in C++/Code Model settings. Is this a configuration issue? Any idea how approach it? Here are the errors: https://imgur.com/a/o9aOy
Where did you get Qt Creator from? Which clang version is it using (if it is not ours)? The code model is very picky about the clang version being used and is currently stuck at version 3.9 of clang. Our version of clang also is shipped with some patches that are not applied to upstream clang yet (the patches are stuck in review:-/), and those patches might also make a difference here. Even if clang is working great, the data Creator feeds to it might be wrong. Do the include paths in look correct for the different parts of your project? Please check in Tools&gt;C++&gt;Inspect code model.
There is truth to this. I would note that GCC has been moving more aggressively to default to newer versions of C++, which helps adoption in the open source community. The Visual C++ compiler defaults to C++14, with a switch to opt into C++17 (at least for the part that is publicly resealed), and the team has adopted a fast release cadence not seen before. They have a strident focus on catching up with standard conformance while also delivering on 3 key Technical Specifications (ok, Concepts just got merged in C++20 but the team wants to deliver on the TS). That demands lot of resources :-)
It might help. Even more so if those implementations ship in officially released compilers -- see what GCC did with Concepts, or Visual C++ with coroutines and modules. One issue is fragmentation of the implementations. See Bjarne Stroustrup's CppCon2016 keynote, and his example about using concepts, modules, coroutines in the same program.
&gt; Where did you get Qt Creator from? Which clang version is it using (if it is not ours)? I got it from the Qt Downloads page. Before that I used various versions, including beta and one that I compiled myself, so maybe there is some misconfiguration? How can I check which clang version it's using? The include paths look good, but now I'm thinking that the flags that I set in Options/C++/Code Model are not being used, for example I added -Wunused-function and didn't get any warnings about unused functions in my code. It's there that I added -std=c++14, and if it's being ignored then maybe the errors come from clang trying to parse the project as c++11?
&gt; I got it from the Qt Downloads page. Good, that one comes with a fully patched clang 3.9. &gt; Before that I used various versions, including beta and one that I compiled myself, so maybe there is some misconfiguration? That will use whichever clang you have installed on your system. &gt; How can I check which clang version it's using? "clang --version" should provide a hint:-) &gt; The include paths look good, but now I'm thinking that the flags that I set in Options/C++/Code Model are not being used [...] The code model is not really my area of expertise, sorry. Please consider to file a bug over at https://bugreports.qt.io/ !
Even vs has had a massive leg up, they actually seem to care now which rocks. The compiler dev team is very active around these parts too. It's bad, but way less bad
&gt; "clang --version" should provide a hint:-) I know which clang I have installed on my system (which is 4.0), I was asking about the version that Qt Creator 4.4.0 uses to make sure it's not the system clang. In fact, it would ideal if I could get the entire command line that the code model plugin passes to libclang (?) to parse the files then I could perhaps figure out the error on my own. Otherwise it's like black box debugging. I will file a bug if I can't solve the problem. Thank you for your help :)
It's possible to return first character, but it's worthless #include &lt;iostream&gt; template&lt;typename First, typename... Other&gt; First getFirst(First f, Other... o) { return f; } template&lt;char... C&gt; struct String { static char Function() { return getFirst(C...); } }; int main() { static const char S = String&lt;'S','H','A','R','E', 'Y','O','U','R', 'P','A','S','S','I','O','N'&gt;::Function(); std::cout &lt;&lt; "First char: " &lt;&lt; S &lt;&lt; std::endl; } http://cpp.sh/36vfe
Have you tried hypnosis? In some cases it can help you recall supressed or faded memories.
How can I join this effort?
&gt; I would note that GCC has been moving more aggressively to default to newer versions of C++, which helps adoption in the open source community. yep, this was a very good move. Likewise for msvc++. But I think that what we are missing is a good, free, cross-platform toolchain that comes with compilers, debuggers, valgrind, IDE, etc. a bit like Xcode.app on mac. I wanted to work on it for Linux (https://github.com/AppImage/AppImageKit/issues/298) but never came around having enough time to do it...
True. It's still years behind gcc and clang in standards support though. I mean come on, not complete c++11 support yet? It's been 7 years. At that rate they will not have c++17 support until like 2024. 
&gt; For instance, Visual Studio still doesn't support C++11. If you try to write cross-platform code this causes no end of headaches since windows users invariably expect to compile with Visual Studio. The current state of C++11 support in VS 2017 is: ^1 * Two-phase name lookup - Partial * Expression SFINAE - Partial * C99 preprocessor - Partial * Everything else - Done as of VS 2015 While I will be glad when their "Partial"s become "Done"s, C++11's largely been usable since VS 2015. What do you have problems with? On top of that, their C++14 support is complete as of VS 2017, and was only missing a couple of features in the 2015 release - most notably extended constexpr. ^1 https://blogs.msdn.microsoft.com/vcblog/2017/08/11/c17-features-and-stl-fixes-in-vs-2017-15-3/ "Compiler Feature Status" table
How likely is it that we actually get concepts in C++20? I've been hearing of concepts being included in the next standard since C++11. 
That was roughly the way I came up with this hack. Except for the "giving up part" :). No, I don't think it's possible on C++11. Thanks for checking.
Well shit, I thought the code in OP's image was just nonsense.
The problem is that the things that are missing are heavily used in "advanced" libraries like ranges-v3 and some boost libraries. As a result those libraries are either not available or have to implement workarounds. Also, if rumors are to be believed, Kenny kerr is finding non-conforming bugs on a weekly basis with his winrt library. However, I'd say that c++11 and c++14 standards support of msvc is good enough by now that the average programmer isn't affected anymore. Last predictions I heard was that the msvc compiler will be fully c++17 compliant somewhere early 2018. That will be a day worthy of celebration.
So... no job at BMW for you then ;-P
I maintain the dlib open source library: github.com/davisking/dlib. Visual Studio 2017 will hang if you try to compile all the example programs. So I am very regularly reminded by confused visual studio users about the lack of complete C++11 support.
Clang + Visual Studio + Linux support. I can dream can't I?
Better to have people argue about the color of the bikeshed for 2 years than to have one guy building it by himself for 8.
I prefer the latter, because in the latter case a bikeshed will actually be built.
https://github.com/AnthonyCalandra/modern-cpp-features Effective Modern C++ is an excellent book
I restarted work on a 10 year old codebase a while ago and it's such an incredible pleasure to see how much boost stuff can be thrown out or replaced by better, standardized equivalents. I'd never believed I'd see the day where you could use threads (or spinlocks!) in a platform independent manner in real C++. I'm really considering moving it up to C++14 and Almost Always Auto etc. The code won't resemble the original at all, yet it's still C++.
As someone who is half way through Programming : Principles and practices using c++, should I wait for the next edition with c++17 or does it really matter?
VS Code? Qt Creator? Not sure what you're asking for.
Neither come with a compiler, a standard library, a build toolchain (ld, as, ar or LINK.exe), a debugger (well, QtCreator does on windows with mingw). And it's a pain if today you want to have two different versions of GCC or clang on the same system (assuming linux), while with a bundled toolchain you have everything self-contained and not interfering with your system. What I want is being able to download a single file from a website, double-click on it, and be able to write, compile, and run cross-platform GUI software with the latest C++ features.
Oh, just get RES for reddit and set it to night mode :P I couldn't browse reddit without night mode, it's killing my eyes :D
I don't... :( I'm also a forced windows user, so there's that
And nobody will use it because no-one is cycling to work, and when they cycle, they don't want to use that weird bikeshed. You could name it &lt;regex&gt;.
Haha, same here. I maintain a library that heavily uses templates and SFINAE everywhere. It works pretty fine with g++ and clang++, but Visual Studio 2017 gave me an ICE when I tried to compile the testsuite. That said, I almost managed to port another smallish C++14 library of mine so that it worked with Visual Studio 2017. I had to deactivate a semi-arcane feature, but it otherwise worked great. That's already pretty impressive by itself considering that one or two years ago porting the library to Visual Studio would have been borderline impossible.
Imho c++17 doesn't really change anything substantial and who knows how long it takes until a revised version of the book comes out, so I'd definitely say no.
A bikeshed is still better than no bikeshed, even though it is late and the bikeshed is weird.
Hi Gor. There is still an issue with optimized Release x86 build and coroutines. I finally managed to reduce a large project to barely a single coroutine to illustrate the bug. It even has a single line (it is unreachable and never executes, by the way), uncommenting which makes compiler to create a buggy code and commenting "fixes" it. What would be the best way to share this little project with you or with other VC devs so this issue could be addressed? Thanks!
Well, they are already in the working draft, so I'd say the probability is very high.
This is clearly false. I mean, everyone knows it is impossible to actually implement `std::vector` under the standard due to issues with placement construction, arrays, and pointer arithmetic requirements. 
&gt; Effective Modern C++ Not exactly for a beginner though
Ah, I think it was `is_pod` because `is_trivial` failed (due to lack of trivial constructor I believe), not destructible. It appears clang marks them as trivial to copy and destroy. 
Lets be real, the C++ community is one of the most mature, self motivated, and adult (not like that, i don't want to see bjarne naked) communities around If there's a group of people who can make this work its the C++ folks
Does anybody know what the most recent draft is? A while ago I was told that was n4660, but there's been lots of corrections and tweaks since then if you look at the standard's Github project.
I find the snake case impractical when we arrive to some names with more than 2 words.
In which case we are back at additional runtime overhead.
It's Microsoft, sadly they never update their structures/functions (muh backward compatibility), they create new ones.
I think the convention of Microsoft is to only take top level type (+ pointer if there is). In this case it would most likely be *map* or *umap* prefix with the rest being what it corresponds to. I'm personally fine with m_ and g_ , I never got to use a_ however.
Haa .. Naming conventions, that's a hard topic. I find the snakecase very hard to use in projects. In some areas, like games, it is impossible to hold to the convention. You always end up with very long names, and being already complex code, it's better if you can save up space to make it more readable. I do like snakecase when the code is 'low level' or can be used to wrap things. Boost is a good example. But when it comes to your actual project, I always end up using C# alike notation (Pascal for classes and functions, camelCase for args and vars, TXXX for templates), and the little addition of Hungarian "m_" for members.
There isn't really much in C++ that is beginner friendly :-/ Are there any modern C++ courses that teach from the ground up?
In all fairness, I don't think a hanging compilation has anything to do with c++11 support. But I feel your pain. At least I get hardly any ICEs these days anymore.
Only happens with complex c++11 code that uses expression SFINAE. So yeah. C++11
The creator from qt.io is hard coded to the clang it ships with. LibClang is a library that is linked to the binary. So unfortunately there is no binary to play with.
I'm not 100% a beginner. That should do nicely for the most part. It's more about catching up the last 7-8 years.
That's a great reference. I'll have a look.
if you didn't use template a lot, just learn c++ all over again.
isn't there a mac version VS?
That is disappointing
LibClang accepts regular clang flags when initialized though. If I could compile my project with those flags then I could maybe find the errors. I'm certain now that the command line passed in Options/C++/Code Model has no effect on the code model (at least for the annotations), neither for warnings nor c++11/c++14 flags. Not sure if that's a bug or I'm missing something.
Not really yet, no. A friend of mine has been badgering me about writing one because I complain about there not being one so often.
It's all relative. There is basically a very small number of features that are required for full c++11 compliance which take a lot of time since they a very fundamental but at the same time they are not required for 99% of actual code out there. It's not even unique to VC++. If I'm not mistaken there is only one compiler that fully supports C++03 out where. Afaik they plan to fully support Two-phase lookup, sfinae and even C99 preprocessor with one of the VS2017 releases. So after that, they'll almost instantly become fully C++14 compliant. And this is on compiler side, which is hard to change. On STL side VS is on-par with all major compilers sometimes even taking a lead.
See https://libcxx.llvm.org/ . Their docs are kind of disorganized and could use improvement (I have a certain set of incantations for wiring up git to their svn, which are based on slightly outdated incantations on their site, but I can never remember where that is).
 8. Don't use shared_ptr&lt;&gt; as a back-door garbage collection mechanism. Satan steps on a puppy when you do that.
It's http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4687.pdf , also accessible as https://wg21.link/n4687 . The way to find the latest one is to search for [wg21] which will take you to http://www.open-std.org/jtc1/sc22/wg21/ , click on papers, click on the current year, then search on the page for the last occurrence of Working Draft that refers to the actual Standard (not various TSes) and isn't an Editor's Report (although those are highly informative too). The precise phrase is Working Draft, Standard for Programming Language C++, but I can never remember the exact phrasing. https://wg21.link/standard is supposed to take you to the latest WP, but it has to be manually updated, and isn't current right now.
Everyone complains that C++ is too complicated, then they rush to add their own complexity. Do you think that this is really common enough and error-prone enough to justify a new Core Language feature? (Sometimes the answer is yes, as it was for range-for. Often the answer is no.)
VS 2015 is an ancient bug farm. Please stop using it. VS 2017 is binary-compatible with it, making it easy to upgrade.
We don't need a new language feature for this. You just need something like `enumerate()`. With structured bindings, looks great too: for (auto&amp;&amp; [i, elem] : enumerate(foo)) { ... } As far as range adapters go, `enumerate` is pretty straightforward to write too. 
Untested with RangesTS: for (auto &amp;&amp; [idx, elem] in zip(ints(), foo)){...}
Was thinking the same thing but of course I was stuck with old language features so my direction of design was more complicated. Still, nothing in the world stopping you from making an iterator adapter that pairs values with indexes/counts. Also, when I see code like the OP's I first assume that `i` is going to be used later (generally if you're counting it will be) and thus there's likely an algorithm I should be using instead...like `accumulate` perhaps. Edit: Actually, `accumulate` might be the answer regardless: auto x = accumulate(begin(foo), end(foo), 0, [](auto i, auto elem) { ...; return i+1; });
To be fair, it's common enough to have language support in [Python](https://docs.python.org/2.3/whatsnew/section-enumerate.html) and standard library support in [Rust](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate). Like others point out it's easy to write an iterator to do it yourself, but still it's not far-fetched to be included as part of the standard library.
Technically yes, but officially/legally, that is a no.
Count me as a weirdo but I like Xcode better than VS. VS has better debugging support, but Xcode is far better with profiling and build time issues imo. Things that took me a while to discover Cmd-Shift-O (Open Quickly), and then Assistant Editor (choose Counterparts to automatically have it open the corresponding header file when you are looking at cpp file and vice versa) Xcode 9 finally treats C++ as a first class citizen.
There's Visual Studio Code but I find it garbage.
Everyone's favorite language to hate, php also gives you the option to have your cake and eat it too: &lt;? $list = array(2, 3, 5, 7); foreach($list as $item) printf("%d\n", $item); foreach($list as $i =&gt; $item) printf("%d: %d\n", $i, $item); ?&gt; 
TBH you are probably using bad libraries. In C++ you should only have to deal with std::string and c strings. If some library you are thinking about using has implemented its own strings that is a fairly strong indication that it is a poor quality library or old and likely unmaintained. When you run into one of these you move on to a different library. This is not to say that all libraries with their own strings are bad. Some like QT had valid reasons for why they did it to begin with, but mostly C++ has moved in a different direction and if you want your code to be future proof you would be better off avoiding even the fairly good quality old libraries like QT, Poco...
&gt; https://wg21.link/standard is supposed to take you to the latest WP, but it has to be manually updated, and isn't current right now. Fixed!
As in when people define what a function argument is supposed to accept, they can detail any number of different string types right `char`, `const char`, `std::string`, `c_str`, just to name a couple. I dont have anything concrete in front of me, this is all from memory of about 5 years ago, so please excuse me on this one 
There is presently no way to write a GUI in C++ without being stuck in a soup of string formats.
- [LLVM 5.0 release notes.](http://releases.llvm.org/5.0.0/docs/ReleaseNotes.html) - [lld 5.0 release notes.](http://releases.llvm.org/5.0.0/tools/lld/docs/ReleaseNotes.html)
Release notes: [Clang 5.0.0](http://releases.llvm.org/5.0.0/tools/clang/docs/ReleaseNotes.html), [LLVM 5.0.0](http://releases.llvm.org/5.0.0/docs/ReleaseNotes.html).
Removing - I submitted a duplicate 2 minutes later than someone else :-/
Under '5. Take Advantage of Compile-time Programming', that would have been a perfect opportunity to make `Vector`'s constructor and `operator[]` constexpr...
&gt; In C++ you should only have to deal with std::string and c strings See, I completely agree with this statement. And I'll be the first to admit that the libraries I tend to use fall into the battle tested (and mostly C based) and not bleeding edge C++ stuff, but the libraries I've used include the following: - LUA - QT - GTK - SDL - SDL2 - SFML - cURL - AngelScript - SquirrelCode - Boost (in small ways)
The world definitely needs more up to date C++ books. I have several developers that I am supposed to update to newer C++ standards and material wise they have to learn from crappy material made locally, through coding trial and error, from stackoverflow, a few Con videos on youtube and from each other. There are a dearth of books/materials for modern C++ that can carry people forward from old C++98/03 style to C++11/14/17. The professional courses exist but the books have not followed along. Most of what has come out are on advanced subjects or tips and tricks. I'd like a few books I could just point people too for beginners, intermediate and advanced programmers coming into C++.
This is currently being proposed, for symmetry with the similar feature C++17 added for `if` and `switch`: http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0614r0.html It was discussed a little two meetings ago and primarily at our last meeting in July, and both times received strong polls in favor of continuing with this proposal and will be going into wording (standardese specification) review at our upcoming November meeting. Example: for (int i = 0; auto elem: foo) { // ... ++i; } And note the end of the paper explicitly notes the natural extension: for (int i = 0; auto elem: foo; ++i) { // ... } which is exactly your requested syntax modulo the `,` and `;` punctuation... so, part or all of what you're asking for might be in C++20.
I'll wait then.
&gt; . Do you think that this is really common enough and error-prone enough to justify a new Core Language feature? How would you define common ? I'd say I have to do this kind of loop more than once per week.
Tour of C++ is for beginners.
Nice! &gt;`-Wcast-qual` was implemented for C++. C-style casts are now properly diagnosed. &gt;`-Wunused-lambda-capture` warns when a variable explicitly captured by a lambda is not used in the body of the lambda. &gt;We expect this to be the last Clang release that defaults to `-std=gnu++98` when using the GCC-compatible clang++ driver. From Clang 6 onwards we expect to use `-std=gnu++14` or a later standard by default, to match the behavior of recent GCC releases. Users are encouraged to change their build files to explicitly specify their desired C++ standard. &gt;Support for the C++17 standard has been completed. This mode can be enabled using `-std=c++17` (the old flag `-std=c++1z` is still supported for compatibility).
Uh sounds good, how is it quality-wise?
Ok, to the best of my knowledge, lua, gtk, SDL, SDL2 and curl dont have custom string types, they just use `const char *`. I cant speak to the others. I dont know of boost libs that require custom string types, but i havent used every boost lib. The only time ive seen ppl forced to use custom string types is using qt. There are some libs like cegui that allow u to customize the string type they use internally. The reason is to automatically handle some encoding issues on windows. You can make the lib use std::string if you dont care about that or dont want the automatic support. The modern convention is to always use std::string for utf8 strings. Utf8 is backwards compatible in that old parsers written for ascii work with utf8 no problem. That is why utf8 is now king. If u need a different encoding in order to talk to windows or some dusty old lib, u make a temporary on the spot and convert it as appropriate. Idk why you would be remembering lots of string types tbh. Maybe in the past it was not as widely understood how to deal with this but i think today it is a solved problem; except that many windows calls are utf16 annoyingly. But thats an ms specific problem.
Of course ":" instead of "in"
I completely understand what your saying, and to clear the air I'm not really talking about "custom string" types, those are mostly evil and should be avoided at most costs, im just talking about the incompatibility between these types and having to constantly convert between most of them, to satisfy whatever the next function you need to execute wants take in a curl payload that comes in as a c string, convert it to std::string to use the string builder and sane concatting methods to use the data returned by curl for display or logging, then pump the data back out as const char because lib #3 wants a const char and not your std::string or char, but lib 3 maybe takes in that const char but returns something else blah blah so on and so fourth 
Excellent news! Btw, the syntax I posted maintains the classic structure of the for loop. It's still: for (init-expression ; cond-expression ; loop-expression) So you could write something like: for (int i = 0, auto elem: foo; elem != nullptr &amp;&amp; i &lt; max; ++i) But I'll take it :-)
Why not defaults at least C++11?
Well, it turns out we're getting it anyway. See hpsutter's post. Which is a good idea, in my opinion. It's not really a new feature but a backwards-compatible adaptation of an existing one.
Why default to C++11? Both C++11 and C++14 are implemented, and the latter is a very minor change compared to the former. They should either keep 98 or jump right to 14 or later. And that is exactly what they propose to do.
Huh. That's a pretty slick idea. I took a [stab at implementation](https://godbolt.org/g/5pZB4s), and it really was pretty straightforward. I'm sure there's probably better ways of implementing a range adapter, I've never done that before. I did try to account for various oddities (different types for `begin()` and `end()` iterators, and it works with arrays), but of course there's some cases I missed. I also only implemented the operators necessary for a ranged for loop, others might be nice but everything gets much more complex at that point. Edits welcome. As an aside, why wasn't the compiler able to deduce the template arguments when constructing `iterator_type`? I'm new to that feature in C++17, but that should have been possible, right?
Yeah, but not 'til next major version. Why not do that with this release?
In scala, `var` is for (non-const) variables and `val` is for (const) values. I guess OP meant to say `val`.
Ok, so yes, this kinds of conversions may often be necessary. But this really should not be very much work at all. - The data is either already a `std::string`, or it is a `const char *` and so it can be passed where `std::string` is expected, because `std::string` is constructible from `const char *`. No extra typing here. - When the data needs to be a `const char *` for some lib... you don't need to think about it too much. If you pass `std::string` where `const char *` is needed, your code won't compile and the compiler will tell you where the problem is. So you just write `.c_str()`. Problem solved. In the rare cases where you have to have non-UTF8 strings then more thought is required. But I can't see how this adds up to this: &gt; I remember spending 95% of my time debugging and writing conversion code to deal with feeding things their preferred string types. If you were a beginner, just learning about different encoding types, you didn't want to use a library for some reason and were writing your own encoding functions... then I can see how it might consume 95% of your time. But that is a newbie mistake. You shouldn't write those conversions by hand, you should use a library. Even if your program consisted mostly of windows system calls and you were wrestling the API, sure I can understand that it might be a big pain to debug it. Maybe the string encoding stuff caused 95% of your pain and anxiety -- and through some quirk of the human mind, that's the part you now remember. But if 95% of the time was actually the string issues, it must have been like a tiny project or something. Idk, to me it just doesn't add up.
What's the state of libc++? Is it ready to replace the gcc libstdc++? What's the compatibility like. On a separate compatibility point. If using libstdc++ can I use clang++ with the switch turning off the new ABI so that I can continue to mix older libs built with gcc 4.8.4 with newer gcc and newer clang. I was just waiting for centos devtoolset7 package that finally included llvm and clang 4.0.1 as well as gcc7.1. Then I can conveniently test lib interoperability.
Careful, though. You're implementation breaks if the value passed to `enumerate()` is a temporary. You can fix this by changing the type stored by the `enumerate` class based on if it is constructed with an l-value or an r-value. [All you really need are a few deduction guides.](https://godbolt.org/g/YTAcFL) Mine may be hideously broken in an obscure way. First time I've written deduction guides.
IME I'll often find libc++ works better with modern C++ features than libstdc++, but the libc++ in most Linux repositories is quite out-of-date.
`auto elem: foo` is not a declaration expression.
libc++ support windows when use clang bootstarp
Please elaborate... I'd like to try libc++ on Windows, where do I find information on how to do this? (I've checked libc++'s docs/wiki and they strike me as being rather dated, but I don't know that for sure.)
You'll say the same thing about VS2017 when VSNext is out... ;-]
My tools clangbuilder select Engine NinjaBootstrap or NinjaIterate can build it https://github.com/fstudio/clangbuilder docs http://libcxx.llvm.org/docs/BuildingLibcxx.html#experimental-support-for-windows
when you build success ，you should copy c++.dll to you install dir
I know.
Of course. WCFB02 is so much better, you'll see.
Some comments: * Your array deduction guide is redundant with your lvalue-reference deduction guide. Similarly, your array constructor is redundant with your forwarding-reference constructor. * Your rvalue reference deduction guide doesn't need SFINAE. If the type was an lvalue reference, the lvalue reference deduction guide is more specialized. * Once we reduce to that, you can reduce both deduction guides to just the one: `template &lt;typename C&gt; enumerate(C&amp;&amp; ) -&gt; enumerate&lt;C&gt;` * `operator*()` returns a `pair&lt;int, T&gt;` where it should return a `pair&lt;int, T&amp;&gt;`. More minor: * `operator!=` does not need to be a template. * `end()` does not need to initialize with `size()`, you could just initialize with 0. 
Sounds like a plan. That's what I use at home; I haven't requested an upgrade yet at work. I'll do that tomorrow. But still, as an outsider, I never viewed VS2015 as a bug farm. I really like it. Never once had it crash except for when VAX made it crash a few times loading up LLVM... Anyhow, I was more or less curious if this was allowed or undefined behavior. I guess the consensus is that it's legitimate? 
Hm :/ still no parallel algorithms.
Excuse me, both of you - you linked to Godbolt snippets, but have you even looked at the outrageous amount of code that this generates?
They gave warning this release so that people have time to opt out of the default by next release. Changing it at all in this release would defeat the purpose of that warning.
I fail to see why it makes sense to put it where a declarator is expected, rather than following the pattern and making it `for (init; decl : expr)`.
When you take into account how much it has to do - which is print four different containers to `std::cout` - it doesn't strike me as outrageous. Here's a stripped version to just call some function: https://godbolt.org/g/SV98DR Edit: added comparison to manual implementation of `enumerate()`. Looks... the same. 
Oh, I'm looking forward to it; being rid of `__declspec(empty_bases)` at the very least will be a relief. :-]
&gt; Anyhow, I was more or less curious if this was allowed or undefined behavior. I guess the consensus is that it's legitimate? An alias template is just a declaration; and having multiple (non-conflicting) declarations is of course perfectly acceptable. :-]
I took a look, and it seems that none of the generated machine code originates from the `enumerate()` abstraction. Almost all of it is dealing with `std::vector`, `std::map`, and `&lt;iostream&gt;` functionality. If you remove the IO and usages of `vector`/`map`, and just use the plain array, the code neatly vanishes.
&gt; Your array deduction guide is redundant... Odd. I poked that code for quite a while, and couldn't get it to compile without doing that. Just went back and checked. Seems you're right: It can all be done with just two deduction guides and one constructor.
Python's `enumerate()` is also just a function in the standard library, like in Rust.
Will they provide pre-built binaries for Ubuntu 16.04? Last month I installed llvm 4.0.0 with the provided bins, now i can't find how to get 5.0.0 without compiling from source.
There are PPAs here: https://apt.llvm.org
It is excellent
That’s part of libc++, not clang
Still trying to get my Gentoo (LLVM/clang/libc++)-pure on 4.0.1. I'd love to tell you...
Thanks for the link, just checked it and seems to be only for nightlies, do you know if there's a ppa for stables? I can wait for the pre-built bins aswell.
It says nightlies, but if you scroll down you'll see the PPAs for 5.0.
Since I'm the original author, I'll respond to the minor nitpicks. I believe `operator!=` does need to be templated since the iterators for `begin()` and `end()` might be different types. That's why C++17 slightly modified the ranged for loop. Yeah, the initialization in `end()` with `size()` is unnecessary, and I debated not doing it. It's unnecessary with this use case, but if this utility were to ever be used outside of a ranged for loop, that's what you would expect the value to be (so `operator--` does the right thing, etc.)
VS for Mac is Xamarin Studio with MS' branding, which among other things means it's for .NET languages only. It's not VS — _100_% separate — just a gross rebranding, presumably for the sake of quick marketshare. There's also VS Code, which is again totally separate from VS-proper. This is primarily an editor, but also supports some debugging, source-control interaction, etc. This does support C++, indirectly via _various_ plugins of which MS' is only one.
Gonna throw in a Kotlin example because why not: val foo = listOf(2, 3, 5, 7) foo.forEachIndexed { i, elem -&gt; println("Item #${i+1} is $elem") }
Does it compile with clang on Windows?
Experimenting with already available implementations of a TS, or individual/language features on one or many compilers can also be a way to help. My experience is that the authors of proposals are always welcome to receive feedback. Of course, the feedback needs to be as technical as the proposal sometimes. However, valid questions/doubts may also be a form of feedback. :) Not sure if the std proposals mail list is the right channel for some questions, specially when it relates to quality of implementation. GCC/Clang groups as others have mentioned may be a better place.
Here's a challenge then... building the latest clang from source is a fun experience by itself on Linux, on top of all the goodies you get once it's done. If the goal is experimenting you don't need to mess the default OS support. Production is a different story though :)
Thanks for the patient help, got it installed now :).
I did too, very pleased with results!
Well a lot of Linux distributions don't even offer clang 4.0 in their repositories
Is it a google query? What answer are you expecting? It will be a number of replies, like vim, emacs, Visual Studio, +1, +1000, who uses that crap, etc, etc "Most popular" doesn't mean it will fit your usage patter. People using a number of different tools on various platforms.
When you see C# code it usually reads very nicely since the naming conventions are so consistent. They never mix styles. Why can't we do the same in C++?
Better ask that over at r/cpp_questions. 
It at least states: Fix compilation error with clang-cl ticket 11821 Don't know how many clang-cl issues there are though
The Support for the execution policies and subsequently of the parallel algs? Does the compieler not have to have that?
The execution policies that are standardized can be implemented using libiomp. Intel implemented their version of parallel stl using TBB. No new compiler features are necessary.
The next version of clang will ship with gnu++14 by default :)
&gt;Stacktrace: Update build testing file to detail with a MinGW issue. Ah hopefully this fixes the fact that MinGW support didn't seem to work at all for me Edit: No I think it just disables support for mingw :[
&gt; The next version of clang will ship with gnu++14 by default :) why not 17 ? clang 5 is c++17-complete so there will be 6 months of people testing it before the next release.
Don't forget wchar, const wchar, std::wstring, and wc_str. and all the other, incompatible, variants
std::wstring.
Here's the thing I don't get -- don't you want to use some kind of CI also, like travis? If your project requires an IDE and projectfiles to build then that means the builds I do locally during development aren't going to match whatever is happening in the headless command-line environment. To me there is a huge value in having the builds I make and the builds in CI be configured exactly the same way every time, on all the platforms to the extent possible. So I'd much rather use something like `cmake`. And for any prospective IDE, I'm like, hey, get the hell out of my build system, or else figure out how to read my cmake file without chages. In fact I generally don't use an IDE at all. I don't get any of the intellisense nonsense or the refactoring tools... I hear refactoring tools are nice. And I end up using grep and sed to modify source code sometimes, which makes me feel like I'm 55 (I'm 29). Idk I really don't want to be seduced by IDEs to some extent. Every once in a while I try one, but often I get really turned off quickly by the bloatedness, extremely slow source indexing process... or minor stupid quirks of the default configuration that surely could be fixed but I dont know how and don't want to spen time learning. I have a great fear of being forced to spend lots of time fixing broken project files. What do people who rely on IDEs do for CI? I assume you must use CI still somehow. Is there a way to make msvc and these oher IDEs work within a CI image like travis from command-line? Does it require commiting solution files or something to your repo? Do you actually trust it to perform the build in the same way there as it does locally, or do you notice weird janky differences?
&gt; I wonder why we don't have that in C++? Very often, I do need a counter when iterating over a range There are third-party libraries that help with this. [CPPItertools](https://github.com/ryanhaining/cppitertools) with structured bindings. for (auto&amp;&amp; [i, elem] : enumerate(foo)) { // ... }
Good choice
&gt; If your project requires an IDE and projectfiles to build then that means the builds I do locally during development aren't going to match whatever is happening in the headless command-line environment how so ? just install the software you use for building your software on your CI. Here's what I use for instance for Travis : https://github.com/OSSIA/i-score/blob/master/tools/travis/deps.sh &gt; So I'd much rather use something like cmake. And for any prospective IDE, I'm like, hey, get the hell out of my build system, or else figure out how to read my cmake file without chages. ... yes ? Most "big" IDEs are able to do this nowadays (QtCreator, KDevelop, VS, CLion, Xcode). I use QtCreator with CMake almost exclusively. Besides, even if you use "IDE project files", they are no magic. For instance you can build visual studio project files on the command lines with `msbuild`, and Xcode project files with `xcodebuild`. &gt; I don't get any of the intellisense nonsense or the refactoring tools... I hear refactoring tools are nice. And I end up using grep and sed to modify source code sometimes, which makes me feel like I'm 55 (I'm 29). For C++ I'd never resort to grep and sed unless I'm renaming a very specific concept of my codebase that does not exist elsewhere. try renaming foo::blah() in foo::bluh(); with sed: int blah() { return 0; } struct foo { int blah() { return 1; } void guh() { blah() + blah(); } } ; int main() { blah(); } IDE refactors are able to do this without problems because they have a semantic model of the code.
so ```( : )``` range based for ```( ; ;)``` classic for ```( ; : ; )``` extended range based for ? I'm usually all for syntax sugar but I have to admit this is a bit cryptic and weird.. although it does make logical sense, and I probably would use it. I've certainly felt the need. I do miss some of what you can do in classic for loops, and this gives the best of both
Not a big fan of this new rapid version scheme thing.
a lot of the complexity *in using it* comes from places where the features kind of do half of what you need, so you need to stretch it in unusual ways to get things done. This is why people want to extend it all the time, IMO.once you get the right features in the core language, it simplifies use.
Is there any appetite to extend the for loops with the 'else' clause e.g as you can do in python [https://stackoverflow.com/questions/9979970/why-does-python-use-else-after-for-and-while-loops]. ```for(){...break..} else { .. if no break not taken...}``` In Rust they have proposed something similar which would complete their 'expression based syntax' (the break and else could both give return values). I suppose we could hack that with a lambda, auto result=[]{ for (..){.... if .. return..} return &lt;default..&gt;;}() it's very messy though; the extra nesting level bugs me more than it should (i think it's a 'muscle-memory'-esque issue, you learn to respond strongly to curly brace grouping) .. I also find this problem with Rust macros
&gt; "Most popular" doesn't mean it will fit your usage patter to be fair if you have to ask this question there's a good chance you don't even have an usage pattern
Things gone so bad in US nowadays that even Microsoft can't sponsor visas?
Not run this through a compiler but a coroutine enumerator should look like this: auto enumerate(Rng &amp;range) -&gt; generator&lt;std::pair&lt;std::size_t, std::decltype(*range.begin())&gt;&gt; { std::size_t count{}; for ( auto &amp;&amp;e : range ) co_yield std::make_pair(count++, e); } 
&gt; Vienna, Austria. So salaries are up to EUR 45K? Please put some range so it's clear...
&gt; I'd say I have to do this kind of loop more than once per week. Sounds like a design or culture problem (if you have to do this kind of thing so often). If you need to group things in different sequences of elements by position, then you should extract them into common code and do away with the need for an index altogether. (I have no basis to know what your code is like, so I'm just running my mouth over here). 
Documentation seems to say otherwise.
/r/NoStupidQuestions 
Exactly, my question was about polymorphism, not ownership.
Thanks a lot for the explanation :) (and sorry, didn't saw your post earlier.
Some examples from my code: template &lt;class Container&gt; QJSValue make_array(const Container&amp; arr) const { auto array = engine.newArray(arr.size()); int i = 0; for (const auto&amp; child : arr) { array.setProperty(i++, make_value(child)); } return array; } void print_states(const ossia::scenario&amp; s) { int i = 0; for(const auto&amp; sync : s.get_time_syncs()) { std::cout &lt;&lt; "Sync " &lt;&lt; i &lt;&lt; "(" &lt;&lt; sync-&gt;is_evaluating() &lt;&lt; ")"; int j = 0; for(const auto&amp; ev : sync-&gt;get_time_events()) { std::cout &lt;&lt; ": Event: " &lt;&lt; j &lt;&lt; " =&gt; " &lt;&lt; ev-&gt;get_status() &lt;&lt; "\n"; j++; } i++; } } auto init_keys() { std::array&lt;QString, brigand::size&lt;value_type_list&gt;::value&gt; arr; int i = 0; brigand::for_each&lt;value_type_list&gt;([&amp;] (auto t) { using type = typename decltype(t)::type; arr[i] = Metadata&lt;Json_k, type&gt;::get(); i++; }); return arr; } std::vector&lt;PointView*&gt; points; ... int i = 0; for (auto point : m_model.points()) { points[i]-&gt;setModel(point); i++; } maybe there are better ways but it's often very different structures or places in the code so I don't see how to abstract this kind of stuff even more without spending more time than needed.
Stacktrace libraries are a half measure anyway, you get small parts of the stacktrace, often full of `??:??`, and sometimes, when the stack was corrupted by the bug you get nothing. The best method by far is to execute gdb externally to attach to your process and print the stacktrace. `thread apply all bt` will even try to print parameter values where they weren't optimized away, and there are even options to print the contents of stack variables. https://github.com/miki151/keeperrl/blob/master/stack_printer.cpp#L51 (the file has all the logic to print the stacktrace from within the program, but defaults to running gdb.exe if it can) https://github.com/miki151/keeperrl/blob/master/rungdb.bat https://github.com/miki151/keeperrl/blob/master/gdb_input.txt EDIT: Of course you need to ship gdb with your program, but it's not a big deal. I'll also note that I've had problems with making the 32-bit gdb from mingw attach to the process and printing a stacktrace, there is possibly a bug there. 64-bit version works wonderfully though.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [miki151/keeperrl/.../**stack_printer.cpp#L51** (master → 479c5f2)](https://github.com/miki151/keeperrl/blob/479c5f25a2b40c006a7451e0672dae5d3bd21659/stack_printer.cpp#L51) * [miki151/keeperrl/.../**gdb_input.txt** (master → 479c5f2)](https://github.com/miki151/keeperrl/blob/479c5f25a2b40c006a7451e0672dae5d3bd21659/gdb_input.txt) * [miki151/keeperrl/.../**rungdb.bat** (master → 479c5f2)](https://github.com/miki151/keeperrl/blob/479c5f25a2b40c006a7451e0672dae5d3bd21659/rungdb.bat) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dmq3mjg.)^.
Have you tried contacting vs dev team regarding your issue? IRC, they were collecting good examples of such TMP-heavy libs for testing purposes.
There is no universal "most popular IDE", it depends on the platform. On Windows you might prefer to use [Visual Studio](https://www.visualstudio.com/vs/community/), if you are more into cross-platform code you might want to try [CLion](https://www.jetbrains.com/clion/) (which uses CMake underneath). If you're a beginner I would definitely recommend VS, since Makefiles and CMake are not very beginner-friendly (but that's just my opinion, your question is subjective).
I'm using RapidJSON recently. It looks interesting, I'll give it a try.
I didn't try to contact them since I wasn't actively trying to get the library to work with MSVC, just checking. If collecting such libraries is ok with them, I'm ok with sending mine. Do you know where/how to contact them for this specific purpose? :)
* Visual Studio (2017) * Visual Studio Code * CLion 
Not so much Babbage as Babble.
When I see these "What's the best &lt;xyz&gt;" questions I feel a mixture of bemusement and downright irritability... WHY do you need to know? Are you just bored? Give people a clue what you need/want and then you may get something useful as a reply. Because of this, I have chosen to give you a very unhelpful reply to your question but perhaps it will prompt you to actually THINK first. As it stands even bothering to give a reply is also meaningless since you will most likely not know the detailed context of the persons answer e.g. Their experience, their types of activities, their education (assuming you are trying to emulate a particular type of person, of course, but as I say in my first point, I have no idea.)
I tested it and this works fine: std::vector&lt;std::string&gt; v = { "foo", "bar", "baz" }; for (auto &amp;&amp; [x, i] : zip(v, ints(0))) { std::cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; x &lt;&lt; "\n"; } More expressions, less statements please...
 &gt;Utf8 is backwards compatible in that old parsers written for ascii work with utf8 no problem. That is why utf8 is now king. They work so long as you only have single byte characters. If you have multibyte characters, they no longer work. With Qt, you should be able to use `std::string` now, though you might want to use `QString` anyway because it's "batteries included".
Well, you can use [connect](https://connect.microsoft.com/VisualStudio) or their [newer website](https://developercommunity.visualstudio.com/spaces/8/index.html) to submit a bug (or just submit the feedback from inside the studio). It's usually gets look at quite fast. But ICEs are usually pretty serious, maybe there is better way to go about this. If I'm not mistaken, I've seen /u/AndrewPardoe asking for some good modern cpp libs to test the compiler on. Of If I'm wrong, I hope he'll redirect it to the proper place.
Good point. The intent was that the actual length of the array argv is at least 1 since argv[argc] is valid and == nullptr. &gt; The value of argc shall be non-negative. The value of argv[argc] shall be 0.
Windows' lack of low level UTF-8 support is one of the biggest hurdles to simplifying string types at our company. If a Greek user wants to open a file with a Chinese name, that just can't be done using `std::string` alone on Windows. You've got to invoke `wchar_t` and non-standard extensions to make that happen. In an old, large code base, `std::string` and `char *` are an absolute minefield because one rarely can be sure whether the contents are UTF-8 text, local 8-bit text or just bytes. I support the idea of adding `u8char` and `std::u8string` which are fundamentally identical to `unsigned char` and `std::string` but are distinct types with a well known encoding.
Is this in a repo somewhere? Are there clear instructions to build the library and maybe even tests? If so, please send me that info: &lt;firstname.lastname@microsoft.com&gt; If it's going to be difficult for us to build your repo (there are a number of great libraries that were frankly just never intended to build with Windows tools) then I'd prefer to get smaller repros for the ICEs. Info on collecting repros is at https://aka.ms/CompilerCrash. Feel free to contact me either way: we want to make your code work with MSVC. 
This is quite an interesting solution, thanks for this. As far as I can tell stacktracing on windows under mingw64 (on msys2) is completely broken, _Unwind_GetIP simply always returns 0, and the number of frames that _Unwind_Backtrace gets seems to be also broken I was hoping with boost::stacktrace it'd be a nice simple quick trip to the park for some basic debugging information, but sadly its been nothing but pain and failure all the way through libbacktrace and eventually the manual unwinding functions I'm on 64bit so I should be fine, thanks again this is super useful
I love that he has expanded the web site to handle more compiled languages.
The majority of projects I know in enterprise context, people just build from their IDEs, there is hardly a CI in place.
If you can't get the gdb method to work then this stack printer has worked fine for me in mingw, with the drawbacks mentioned above. https://gist.github.com/jvranish/4441299
Then those are not good Linux distros. Providing old packages is always a bad thing
Why? I think semantic versioning matters and LLVM + Clang break compatibility every release, why not bump major version?
This is insignificant but I don't like your header font, bree-1.
&gt; Support for the C++17 standard has been completed. Yey! Arch Linux bumped GCC libstdc++ to 7.1.1 which wouldn't compile with Clang because it didn't have support for class template deduction. Hopefully it works again!
Great post. Begs the question (to me, anyway) of whether we should think about widening the meaning of covariance for C++. After all, the following is both simple and perfectly safe in all respects (save for, you know, being ill-formed): struct Interface1 { virtual unique_ptr&lt;Interface1&gt; clone() const = 0; }; struct Interface2 { virtual unique_ptr&lt;Interface2&gt; clone() const = 0; }; class Implementation : public Interface1, public Interface2 { public: unique_ptr&lt;Implementation&gt; clone() const override { return make_unique&lt;Implementation&gt;(*this); } };
Thanks, I've sent a mail. Hope it might help in some way :)
SFINAE and two phase lookup are huge features. You can't compare them to the not implemented feature of C++03 you are alluding to, export templates, which were universally recognized as a bad idea and not implemented and subsequently deprecated in the standard. No one cared about export templates. But lots of real world C++ code doesn't compile in visual studio because of missing support for central C++11 language features like SFINAE and two phase lookup.
We've been using libc++ in production for a year and a half. Haven't had any problems.
&gt; decision to move to git was made I'm guessing this had similar blowback which is hilarious.
The collective "us" is part of the reason your code is worthwhile - we appreciate you putting time and effort into making such a valuable library. You must appreciate the time effort we took into using your library. Don't be so full of yourself. -Random Boost User
Except x-&gt;clone().reset(new Y()). You need runtime checks for covariance, don't you?
Got it, thank you!
Bit silly to claim that all non-rolling release distros are bad. Even Arch sometimes lags behind on Clang. Are all distros bad?
Oh, I see, as long as the caller is the only one who can access the contents, it's fine. And there are other cases, like immutable data. It's constrained to a set of types the compiler can't distinguish from other types.
It is impossible for us to give a salary range, as we are hiring from all over the world. If you’re interested in our hiring approach you could look at https://pspdfkit.com/blog/2016/hiring-a-distributed-team/ - it also shows you that one of the first things we ask is a expected salary range just to make sure we’re all on the same page. 
Aye! That's what I'm talking about :D 🍻
&gt; If a Greek user wants to open a file with a Chinese name, that just can't be done using std::string alone on Windows. as suggested [here](http://utf8everywhere.org/) just treat entire Windows API as UCS-2-only. I.e. before calling *any* WinAPI function convert your utf-8 std::string to UCS-2 string (and convert any string result back to utf-8 on return). Unfortunately on Windows fopen/iostream stuff will need special treatment. But, tbh, it is Bill Gates' fault -- this stuff works just fine on Linux.
Responding to the very first and last bit there, it's true, the question should very much imply that when it comes to the c++ I am still level beginner. I can write it by virtue of using C-like or C-inspired languages for most of my professional life, but when it comes to its unique fun quirks and ecosystem, I spend a huge amount of my time figuring out what the problem is, why the problem is occurring, trial and error fixing, all else fails stackoverflow, trial and error implementing suggestions, and all else fails a complete refactoring. I also get hung up on compiler settings, for some reason none of it makes any sense to me. I have this similar issue with Java and it's fun ecosystem. So while all of my c++ usage have been relegated to weekend project status, and definitely outside of a professional setting (obviously), 95% of my time and effort goes to fucking around with basic asinine bullshit instead of actually writing the damn program for its intended purposes. I've had success, I'm not stuck on anything, but it's a set of experiences that prevent me from even wanting to fire up a new project with it, for whatever reason that may be 
Yes. All distros are bad, in one way or another. The struggle of the Linux user is not to find the *best* distro, but to find the distro that is *least bad* for their purposes. This applies to all software. ^^^^^software ^^^^^sucks...
For example, developers wont remember it. Most people will know if they use clang 3.x or 4.x. But no one remembers if they are on version 56 or 65 of Chrome. And for webbrowsers this may be a desired behavior. You dont want people to thzink about browser version numbers, because they have to be forced to upgrade anyways. This is not hte case for compilers.
I don't see it. If `x` is a pointer to `Interface1` or whatever other type, the reset is checked based on that type. Because when you call `Interface1::clone()` you get a `unique_ptr&lt;Interface1&gt;`. The point is that the compiler is perfectly capable of noticing that the return type of an override of a virtual function doesn't match. It can then check "is there a conversion?", and if so write *two* `clone` implementations (or one per base signature). The base signature implementation calls the derived signature implementation, and converts the return value. When you call `clone` on a pointer with static type pointing to the *derived* object, you get the "derived return value". On the base, the "base return value". Now, this implies a pointer to the derived `&amp;Implementation::clone` method is *different* than the pointer to the `&amp;Interface1::clone` or `&amp;Interface2::clone` pointer. So some complexity can fall out here. Even more strangely: unique_ptr&lt;Base&gt; (Derived::* ptr0)() const; unique_ptr&lt;Derived&gt; (Derived::* ptr1)() const; you could imagine both of the above method pointers pointing at different `clone` signatures! In any case, if/when we get metaclasses, we'll probably be able to write this ourselves. 
If the stack is corrupted, I wouldn't expect to get anything at all, just a crash. How would that possibly work?!
But still. The full c++17 standard would include the execution policies. 
I would guess that gdb is much better at recovering the stacktrace than the stack printing libraries in case of bad corruption, plus the fact that it's run externally to the process supposedly helps a lot. I've had similar experience with Visual Studio, if you write a mini-dump file from within the program in many cases you get garbage, while an external debugger will give you a clean stacktrace.
I personally like XCode, I just love the way you can easily open or switch between cpp and .h files and how you can have a splitt in the middle of your main windows for cpp and h with simple shortcuts. For me it's much simpler to use than visual studio (even though I hate apple products) https://www.git-tower.com/blog/xcode-cheat-sheet/ might help aswell.
Did you write this? I'm new to C++ myself, but I think you should update the first tip, as I think its incorrect. C++ pros, correct me if I'm wrong. Using the "new" keyword should not be avoided. Pointers are very powerful and their use is absolutely crucial. Rather than say avoid them, explain how "new" is different in C++ than Java. Avoiding "new" and pointers in general would be a huge mistake. 
Uh, isn't this SO answer a much better solution, that preserves covariance. https://stackoverflow.com/questions/6924754/return-type-covariance-with-smart-pointers
A fully compliant C++17 standard library would include the execution policies. A fully compliant C++17 compiler would have no such knowledge of execution policies because it's a function of the **standard library**, not the **compiler**.
Clang is a C++ compiler. It does not provide a standard library. Clang 5.0.0 claiming C++17 compliance as a **compiler** is an accurate statement. Trying to shoehorn that Clang, a compiler, should also be forced to include a standard library implementation does not make sense. Libc++ exists for a reason as a separate project. Vendor compilers like Intel, IBM, and PGI usually rely on libstd++, GNU's C++ standard library implementation. That doesn't make them more or less C++ standards compliant
There really is no generic way to prep for a C++ interview. You need to know something about your target and what style they use. What part of the language, if any, do they insist you not use? Are they coding in C++ or C-with-classes? How old is their compiler and what is their upgrade path...if any? Unfortunately, at least for me, jobs that use C++ in what I'd call a rational way are far and few between. Be ready for fear of templates and exceptions...STILL...type-embedded hungarian notation (in other words not even getting the shittiest naming convention in the world right)... Terror of anything C++11 or higher... The problem with C++ is that there's too many experts. And if you've read "Thinking Fast and Slow" you might remind yourself that the *illusion of skill* is real and that confidence is actually higher when you know less. It's hard to give real advice that will encompass any C++ interview. Your current knowledge may be totally adequate and exactly what you need. On the other hand, C++ has changed a LOT even for those of us trying to keep up...so you could be asked all kinds of questions that your existing experience couldn't possibly help you with. Learn too much modern C++ and you'll do terrible on some interviews.
Tell this to all the CI/CD services out there, running on Ubuntu 14.04 (3 years old!)
It has nothing to do with being non-rolling. Ubuntu is non-rolling, Fedora is non-rolling, latest versions still offer the latest Clang. I haven't been on Arch for too long, but I didn't see any lags with 3.9, 4.0 (5.0 is few days old and is in Staging at the moment), so I don't know what you're talking about, maybe it was before I switched to Arch, but, again, I don't possess any knowledge about it then.
I'm in my mid-30s and have only passing familiarity with how mailing lists work and what the expected etiquette is. I feel like the use of mailing lists in-and-of-itself is a barrier to entry (perhaps that's the point). I mention my age because to me that seems like an outdated and inefficient way to communicate. Any tips on how to better engage in those discussions?
Scott Meyers Books and Bjarne´s
Oh, I see. So you're the kind of company that pays people based on their location rather than their contribution... One of the main benefits and reasons of remote work is to escape the local market, so you're passing on candidates who made it (escaped the local market).
&gt; Using the "new" keyword should not be avoided. Pointers are very powerful and their use is absolutely crucial. You are conflating two things here. operator new should be avoided in modern C++. You don't often need it. Pointers don't always mean using new. Pointers can be used to read from any place in memory. Using operator new means you own that memory and need to make sure you know where to use operator delete to free it from the heap.
Give me your clothes and motorcycle.
The search bar exists, mate. And this question is also well answered on StackOverflow. C++ Primer, latest edition, is an excellent intro text. Especially if you do the practice exercises (though, I have a hunch you may not)
I don't see what that has to do with what I said. Ubuntu 14.04 isn't a "good" distro. It was the least bad for their purposes at the time. We use RHEL for our CI/CD servers. Same reason.
&gt; Using the "new" keyword should not be avoided. Pointers are very powerful and their use is absolutely crucial. Care to show an example ? 
&gt; Tell this to all the CI/CD services out there, running on Ubuntu 14.04 (3 years old!) most of them allows to use docker images now so you can use whatever base system you want
http://en.cppreference.com/w/cpp/language/statements
`return` is a keyword. `"\n"` is a string literal. `return "\n";` is a statement. I would suggest asking your questions at /r/cpp_questions instead, it's a much better place for this than /r/cpp.
http://en.cppreference.com/w/cpp/language and http://eel.is/c++draft are your friends. http://en.cppreference.com/w/cpp/language/statements#Jump_statements or http://eel.is/c++draft/stmt.return show that `return &lt;expression&gt;` is a statement. http://en.cppreference.com/w/cpp/language/string_literal or http://eel.is/c++draft/expr.prim.literal → http://eel.is/c++draft/lex.literal#lex.string show that `"…"` is an expression though.
Oh so \n would not qualify as a statement then ? 
Ok sorry I was just trying to write a program with the least number of statements used that would print out 1,2,3,4,5 all on different lines. I used \n after each except for 5 rather than jus writing endl . 
One statement is all you need: std::cout &lt;&lt; "1\n2\n3\n4\n5\n"; This is also one statement: std::cout &lt;&lt; '1' &lt;&lt; '\n' &lt;&lt; '2' &lt;&lt; '\n' &lt;&lt; '3' &lt;&lt; '\n' &lt;&lt; '4' &lt;&lt; '\n' &lt;&lt; '5' &lt;&lt; '\n'; But this is five statements: std::cout &lt;&lt; '1' &lt;&lt; '\n'; std::cout &lt;&lt; '2' &lt;&lt; '\n'; std::cout &lt;&lt; '3' &lt;&lt; '\n'; std::cout &lt;&lt; '4' &lt;&lt; '\n'; std::cout &lt;&lt; '5' &lt;&lt; '\n'; (Note: `std::endl` is probably unnecessary. You don't need to flush the buffer.) One thing that will help in your case: `main` does not need a `return` statement.
Crap ok sorry kinda taking this all in so \n is not a statement right ? But endl is a statement and we do not need to use it . Now for return 0 I was sure it was a statement from another post I saw here but you don't need it here ? I thought every program requires a return 0 statement at the end 
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6ywq6y/question_regarding_statements/dmquqyh/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Here's a vastly oversimplified definition of a statement: a line of code that ends with a semicolon. So `"\n"` by itself is not a statement. Nor is `std::endl`. These are both *expressions*, but not statements. Nor are `return` or `0` statements by themselves. But string a few of them together and end it with a semicolon: return 0; And now we have a statement. My second example only has one semicolon in it, even though it's split into five lines. It's still just one statement, albeit with a long expression inside. But break it apart like my third line with multiple semicolons, and it's five statements. (Note: this is /r/cpp so there's a significant chance of a pedant coming along and correcting the details here. Yes, I'm leaving a LOT out of this, but it'll give you a very basic start to understanding.) Regarding `return`: any function that returns a value (`int foo();` for example) must have a `return` statement. *With one exception*: C++ lets you omit this with `main`, were it assumes `return 0;` is what you wanted.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/6ywa60/give_me_your_best_resources_on_c_learning/dmqusps/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I'm not going to engage in this, sorry. If you don't want the job, that's fine :)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/6yxf4r/can_someone_please_help_im_new_to_this/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
 coroutines, Cool!
Looking at the standard, I'm guessing `span` didn't make the cut?
Mind calling it v.1.0?
What format is more efficient than mailing lists for this? A web forum? Or do u want like some kind of live chat? I really cant see what would be a better, workable alternative. Im 29.
I always wondered if there's a real reason to implement more than one interface? Isn't it a direct violation of a single responsibility principle? Can't you just create a wrapper to implement second interface when needed (or just use a `std::function` or similar polymorphic wrapper)? Do you know some interesting examples when it's justified? 
Like almost all guidelines the single responsibility principle has exceptions. Sometimes it is harder to read/understand/debug/maintain 3 separate wrappers than it is with a single concrete class that implements 3 interfaces.
Yes, and that's why they say support has been completed, not that they've implemented the standard. Which just was accepted yesterday or so. But there is a lot of library work to be done on all the major std implementations. Filesystem, parallelism, pmr, math functions, ... 17 adds a lot of capability to the SL. 
From my recollection reading the mailing list, no one thought of it in time to give the warning last release. And it will break people's builds. 98 to 11 is ABI breaking, so you really want to give people a chance to rebuild the world. 14 and 17 are easier to integrate, although I've heard occasional issues. I don't think there was a by design ABI break, like with std::string. 
SRP doesn't come into play. Interfaces are *capabilities* (similar to C++ contracts) and there's nothing that says that a class shouldn't have several capabilities. Take strings: they are equality comparable, lexicographically sortable, subsettable (yielding characters or substrings), etc. Each of these capabilities can be formalised in a public interface contract that a string class implements (and indeed that's how some languages/libraries handle this).
For threads we need a better story around thread pools, but executors seem to be moving in the right direction. The std::async launch a thread for everything model isn't awesome. But we are getting there. 
The compiler is probably complete against the standard that might be published by year end (but the text is final!). There isn't a complete standard library yet, so lots of conforming programs would fail to compile. So making it the default seems a bit hasty. 
Merging concepts into the working paper (minus a few bits) is a stake in the ground. We're more likely to have C++21 or 22 than not having Concepts. After a year just backing out the changes would be a ton of work. https://github.com/cplusplus/draft
std::regex
I was mocking up examples but I couldn't recreate a problem I once had, in which I developed this point of view. I guess I've been using pointers when I shouldn't have been. I believed that, when declaring a variable or object in a function, once that function ends, the variable is always destroyed. But if its a pointer, that variable pointed to by the pointer persists till delete is called on the pointer. But I've been trying to create a scenario where the object I create is destroyed when its scoped function ends. It seems that as long as I'm returning the created object, or setting a pointer reference to the created object's address, the object isn't destroyed. Is that how it works? As long as some variable is referencing it, it persists, regardless of whether or not the scope it was created in has ended? EDIT: The second answer here is what had me believing this: https://stackoverflow.com/questions/6403055/object-destruction-in-c
Looks pretty neat. I'm not familiar with Boost so that's a new pattern for me, I'll need to look it up. I'm stuck on VS2013 and RapidJson 1.0.2 so I think I'm out of the running on this one. Still though, looks really good.
Not sure if it's just bitbucket rendering it strangely, but if not, the coding style used is abysmal, which is a shame because it seems like a cool little library.
A biannual release for a major version is very different than a release every 8 weeks (6+ releases per year). GCC does one major release per year. By the way, clang 3.0 was wildly different than clang 3.9. Remembering 3.6, 3.8, etc. is no different than remembering 4.0 or 7.0
There like 4 major compiler releases per year at most. At this rate well get to Chrome numbers in 10-15 years. But that's at the extreme pace. Usually it's no more than 2 releases, so the time doubles to 20-30 years. Hopefully libclang/llvm would mostly stabilize it's API at that point.
Just keep going with the current book. Then revise later for c++17. The differences you need to learn are minor compared to the core basics. 
You can also use virtual inheritance to factor out the implementation of the virtual `clone` function. template&lt;typename T&gt; struct Clonable { public: virtual T* clone() const = 0; }; template &lt;typename T, typename I&gt; class ClonableImpl : public virtual Clonable&lt;I&gt; { public: virtual T* clone() const { return new T(*this); } }; class Interface : public virtual Clonable&lt;Interface&gt; { // more virtual methods here }; class InterfaceImpl : public Interface, public ClonableImpl&lt;InterfaceImpl, Interface&gt; { // implements Interface's virtual methods (except clone) } InterfaceImpl i; i.clone(); So any class that needs to implement the clone method can just inherit from ClonableImpl&lt;T&gt;
You won't need any particular math aside from very basic algebra in order to code. Calculus is overkill and you won't ever need it unless in special circumstances such as scientific computing.
I think OP plans on game programming... He needs some pretty high level math if I'm not mistaken and he'll probably need some physics knowledge.
He seems to be aiming at simple "roguelike" stuff ATM. A GUI-less text based approach might be what fits OP best currently.
I've found that refactoring is a constant. So what I do is I try to design with the intention to make future refactorings easier. If you are coding something and you feel like it will be a pain to change or it's tightly coupled with some other object, then that's a good sign the design needs work. Also, don't set out to create 'perfect code'. It will never be perfect. You will always be learning so any old code you've written will probably seem really bad. That's a good thing though because it means you are getting better. Also mistakes get a bad rep. Make mistakes. Make all of the mistakes. Don't try to avoid them. They are they only way to learn anything. You will need to write a lot of bad code before you write good code. I say that you work on your project and finish it without stressing to much about how 'good' it is. Try to design it and code it as best you can, but don't let the 'this isn't good enough' thought stop you from finishing it. After all, a working app is cooler and more rewarding than a non-working one no matter how it's designed. EDIT: If you are working on code it's never going to be a waste. If you didn't have that initial problem who knows when you would've learned about binary search. That problem led you to new knowledge. Now you you know about binary search and you can utilize it. The more problems you encounter and solve, no matter how long it takes or how it was solved, will lead you to more knowledge and a stronger skill set. Just keep coding and doing what you are doing.
&gt; currently. In order to get really into game dev, he will need advanced math for sure.
Can you provide an example of code which code style "is abysmal"?
v.1.0 means that API stability and compatibility will be a top priority for us in further development. Now we don't know how many breaking changes we could introduce on the way to v.1.0.
Peter Gottschling's book discovering modern c++ is a great overview of the language from a modern point of view It quickly goes over the basics with c++11/14 and mentions lots of idioms and tidbits along the way.
If you're coding a 3D game engine, sure. If you're making a game in Unity? Probably not. If you're just making a presumably text-based or 2D roguelike? Almost certainly not. How likely are you to do physics simulations in a turn-based game (unless you're the guy who makes Dwarf Fortress, of course)? 
https://i.imgur.com/LIN8FBm.png This function is probably the worst offender. To my eyes, information is spread out all over the place, and it's difficult to discern scopes, and which are locals vs arguments. The return type on its own annoys me too but only as a matter of personal preference, it doesn't hinder readability for me. This isn't a judgment on the quality of the code, which i'm sure is really good, i just can't stand to read it enough to find out. 
&gt; I believed that, when declaring a variable or object in a function, once that function ends, the variable is always destroyed. It certainly is, unlike you return it lke you said (and even then, until C++17, the object could still have been copied and destroyed) &gt; It seems that as long as I'm returning the created object, or setting a pointer reference to the created object's address, the object isn't destroyed. no, it is, you just happen to read invalid memory. This would certainly crash in one way or another after some time or with more optimizations enabled. &gt; Is that how it works? As long as some variable is referencing it, it persists, regardless of whether or not the scope it was created in has ended? No. Hence one of the most important concept when you want objects to keep living in C++: ownership. http://ericlavesson.blogspot.fr/2013/03/c-ownership-semantics.html ; sure, a way is to do `new myObject` and delete it later, but it is error-prone and unsafe in many cases.
I am 25. It seemed old-fashioned at first, but I got used to it. I suggest you subscribe to get your toes wet, and then draw your own conclusions. Boost makes it pretty easy to get involved. The Fit library formal review begins this week, which is sure to generate some great discussion. Seriously, you should submit a review! The Boost formal review is an incredibly enriching process to participate in. Fit did not pass the first review, but i know Paul has been working hard on this awesome library. I expect it will succeed this time, but not without much discussion and analysis. Now is as good a time as ever to [subscribe](https://lists.boost.org/mailman/listinfo.cgi/boost)!
Creating a basic roguelike shouldn't require any difficult math. The two algorithms that you will probably want to implement are line of sight and pathfinding, and there are tons of tutorials on them. You should check out the roguelike development resources at /r/roguelikedev and roguebasin, for example the C++ tutorial (there are others for other languages): http://www.roguebasin.com/index.php?title=Complete_roguelike_tutorial_using_C%2B%2B_and_libtcod_-_part_1:_setting_up
I'm afraid there can be an argument about personal preferences. We using such code style for the very long time (probably 15 years or more) and haven't any difficulties with it. So I read this code snippet without any problem. Specification of result type on separate line has its advantages when name of type is rather long, something like that: template&lt;typename Some_Meaningful_Name&gt; typename Some_Meaningful_Name::Some_Nested_Long_Type_Name some_function(...) {...} This declaration style simplifies reading of complex code bases for us.
builds are up at llvm's download page.
Just get on with it and start. There's no way you can avoid most mistakes by studying theoretical subjects up front. Programming is for sure aided by theoretical knowledge but at the end of the day it is a craft that takes loads and loads of practice and there is simply no shortcut around that. Will you write ugly code? For sure. Will you have to redo stuff? Absolutely. This is programming. :)
How is this different from cereal? https://github.com/USCiLab/cereal 
!removehelp
I agree. I gave up trying to read this too, it's highly idiosyncratic. The way new lines are used in template parameter lists and function argument lists isn't something I've seen before and I found it hard to follow. Similarly for the initialiser list in one code snippet, with every comma lined up with... And you know what, I had to stare at the code for a minute to try and put into words *what* it is lined up with and I'm still not sure? It's really odd. Return types on their own lines can sometimes be necessary, if they're long types, but in my experience this is a one in a thousand thing. Doing it for every function looks odd to me. You can argue all day long whether the "&amp;" should be associated with the type or the variable, with a huge majority coming out on the side of the type. But it is never right to put it in the middle - that just looks like a binary operator&amp;. On top of that, this library actually overloads precisely that operator, which is maddening! I had to stop reading. Sorry. 
The original covariance works because the compiler *knows* that the method in the derived class returns a pointer to a derived type, so it can safely upcast the returned pointer. - Allow explicit conversion constructors/operators alongside non-explicit ones (where the implicit one is preferred if eligible), allowing pointer classes to more closely model the behavior of raw pointers by providing an explicit conversion constructor if a static cast of the raw pointers is well-formed (alongside the current implicit one that is only exposed if the raw pointers are implicitly convertible). Or even better: Allow explicit conversion constructors/operators to explicitly (no pun intended) specify the conversion type they apply to (e.g. by appending `for static_cast` / `for dynamic_cast`, etc, this way it wouldn't require new keywords) at the end of the signature. That would also allow normalizing `std::static_pointer_cast` et al into regular casts. - Provide a way to mark `static_casts` as "contextually safe" during compile time. A static cast from `U&amp;` to `V&amp;` shall be contextually safe (implicitly, without any annotation) if `std::is_base_of&lt;U, V&gt;::value` and `std::has_virtual_destructor&lt;U&gt;::value` and the dynamic type of `U` is known to the compiler to be `V`, e.g. in the case of a covariant method override. The pointer class can then use this to confer the same conditions for contextual safety to its own conversion operators, and more complex classes that wrap unique_ptrs can do the same. For example, template&lt;typename U&gt; class my_ptr { public: // ... template&lt; typename V, typename = std::enable_if_t&lt;std::is_convertible&lt;V*, U*&gt;::value&gt; &gt; my_ptr( my_ptr&lt;V&gt; &amp;&amp; ) { // ... } template&lt; typename V, typename = decltype( static_cast&lt;U*&gt;(std::declval&lt;V*&gt;()) ) &gt; explicit( my_ptr&lt;V&gt; &amp;&amp; ) for static_cast contextually_safe_if( is_contextually_safe_cast&lt;U&amp;, V&amp;&gt; ) { // ... } }; 
Thanks for clearing that up! For the stuff I've been writing, its been important that objects keep living past the lifespan of the code block they were created in. But as you and others have pointed out, doing so with "new" is bad. Perhaps, then, the article needs to allude to safer approaches to persisting objects past initialization scope, rather than just say its a bad practice to use "new" and leave it at that. For my personal benefit, what is the standard - safe - method of persisting objects past their initialization scope? Smart pointers? 
What problems are caused by forgetting which compiler version you're using? How difficult is it to find out, if you forget? 
&gt; without even addressing my arguments. Belated reply but anyway... I can't address arguments I haven't read. If there's anything of worth in there I'm sure someone else with some basic human decency will also raise them and I'll pay attention then. Consider that a life lesson perhaps, most people couldn't give a fuck if you're right or wrong when you have a toxic personality. They'll just ignore you. And nothing of worth will be lost because it's unlikely that your insights are so unique and special that no one else will also voice them, but in a professional manner. 
It's hard question. First of all I see cereal as a full fledged serialization tool. It supports different archive formats and so on. But it is required to use cereal in the project from the very beginning. Out json_dto library is just a wrapper around of RapidJSON. It means that json_dto can be used in projects where RapidJSON is already in use. You can write new code with help of json_dto, but the old code in your project can use RapidJSON as usual. And I don't know it is possible to specify different field names in cereal. With RapidJSON and json_dto it is easy to have one field name in JSON and different name in your C++ structure. Something like: struct my_type { timepoint birth_date_; ... template&lt;typename IO&gt; void json_io(IO &amp; io) { io &amp; json_dto::mandatory("dateOfBirth", birth_date_) &amp; ...; } }; 
Sorry, but I don't understand such complains. Library's code style doesn't require that all users of the library will use the same code style. You can format *your* code as you wish. If you take a look inside some of STL implementation (like on in VC++) you can see very strange and hard to read code style. But there are many reasons to write STL implementations such way. It doesn't make STL valueless. There is no "one true" code style for C++. For example I don't like code style of RapidJSON. But it doesn't matter because I use RapidJSON because of it features, but not code formatting rules. And last but not least: your complains doesn't tell anything useful to us as library writers. If our code style makes reading code examples harder for you then it's a pity. But if we change our code style to fulfill your desires then there can be anyone else who can complain about any other code style.
STL implementations are not written as examples to be followed, primarily. While there is no one true style, it is possible to assess a style in terms of how readable it is. By virtue of having unreadable example code, your library has a higher barrier to entry than is necessary. This is a shame, because I'm sure the point of its existence is to make it easier to use RapidJSON, a library I discounted from using in my own project due to the awful mess of code it requires you to write without such a wrapper. Any style may draw criticism, but this does not make all styles equal. This one is *bad*, no matter how used to it you are, and I feel comfortable that I can defend that as an objective property not simply as a matter of opinion. 
When you declare a local variable you use what is called automatic allocation (sometimes called stack). These variables only exist for the duration of the scope in which they are declared and are destroyed when the stack frame is popped. To have the duration extend the scope you need to use static storage (via static keyword or having a global) or dynamic memory via the new operator. This is how containers such as vector and smart pointer work "under-the-hood". If you return a variable by value, the object is copied to the callers automatic storage. Thus you can just return the object from the function by value to extend the lifetime beyond the end of the function. Return value optimization can "elide" this copy, which means that you do not really pay the cost of the copy, but it is easier to reason about what is happening if you think of it as a copy. As of C++17 this elision is mandatory. If you want to use dynamic memory for your object, the you should use a std::unique_ptr to allocate the memory. You can return this smart pointer from your function which indicates you are giving the caller ownership of the object that is pointed to. When the smart pointer is destroyed, the memory it points to will be freed by the principle of RAII.
&gt; it is possible to assess a style in terms of how readable it is. This code style is most readable for us. It helps us to write the correct code. &gt; This one is bad, no matter how used to it you are, and I feel comfortable that I can defend that as an objective property not simply as a matter of opinion. It just your point of view. No more. And yet another time: your opinion about our code style doesn't allow us to make the library more powerful or to add new features to it.
&gt;It is just your point of view. No more. Sure, that always sounds reasonable. In reality, it's trivial to come up with a coding style which is clearly inferior in readability to others, however contrived. It follows that there is an objectivity to such criticism, with opinion coming into it when two or more alternatives are similarly as good as one another in their objective properties. Can I point you here, for some very reasonable, not too proscriptive, or controversial guidelines: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-naming In particular, 4, 9 and 15.
&gt; 4. Maintain a consistent indentation style We are trying to maintain consistent indentation style. But it is our style and we maintain consistency with our taste and common sense. &gt; 9: Use ALL_CAPS for macro names only We started to use ALL_CAPS for template parameter names may be ten years before C++ Core Guidelines was published for the first time. So we still using it to keep consistency with our old code. &gt; 15: Use spaces sparingly We have found that in large code bases additional spaces like: void f( first_type first_arg, second_type second_arg, third_type third_arg ) { call_another_function( first_arg + third_arg, second_arg / third_arg + first_arg / third_arg ); } much more readable than: void f(first_type first_arg, second_type second_arg, third_type third_arg) { call_another_function(first_arg+third_arg, second_arg/third_arg + first_arg/third_arg); } So we can keep arguing about code styles but I have to say: our code style is not arbitrary one. May be there was about 10 years of experience with different code styles before we started to use our current code style almost 15 or 16 years ago. You can dislike our code style, but it just doesn't matter.
You have two people immediately giving you feedback that they gave up on trying to understand your library because they find your example code unreadable. Although I'm biased because I'm one of them, I have no reason to think that either of these people are idiots. I will leave it to you to decide whether or not this matters. 
Thanks for the advice! Part of my problem is that I do often run into the scenario of thinking "this is going to be hard to change later" while I'm programming, but I don't know enough to change it for the better. I don't intend to produce perfect code, I just want to produce maintainable code. I was hoping there might be some standard set of best practices to draw upon, but if experience is the only way to achieve that, then I suppose I better get to work!
That looks like a great tutorial, thanks for that!
Ah, ok. Thats rather unfortunate, I guess I had always assumed that the information gained via a CS curriculum allowed people to bypass the novice stage of being a developer. At least there is is clear path to getting better, by just doing it.
Yes, I'd like to be a 3D game dev. I'm not exactly sure what I'll need, but my limited experience with 3D games has shown that I'll definitely need something beyond basic algebra.
This subreddit is r/cpp
I'm interested in your reasons for finding VS Code garbage. It's rather popular, but we know it could improve. 
Hi Barfus: Send me a zipped project. You can find my e-mail in the list of authors of p0057 paper
It's a good text editor, but an *awful* c++ IDE, even with plugins. Last time I tried to set that up as an IDE, you'd have to manually edit a bunch of config files for each and every new project you wanted to set up. :(
This was since your comment, but he's saying he will do smart pointers soon, so he's going to at least start hitting more modern topics it appears.
&gt; And nothing of worth will be lost because it's unlikely that your insights are so unique and special that no one else will also voice them, but in a professional manner. Well if you read them you would know they are(assuming you are capable of deciding what is unique and special, not so sure about that).
Cereal supports pretty much identical syntax, which is why I asked ar &amp; cereal::make_nvp("name", value);
It's interesting, I didn't know that. Does cereal support optional fields and/or validators for deserialized values?
I think this approach has so much subtlety wrong that it does much more harm than good. For starters an example of get() not working right because you don't know the order of operations is probably the least of someone's worries there. Disregarding the fact that there are much better ways to do this than using a mutex, both references could refer to the same object which would create a deadlock, not the order of operations. Then, returning some sort of locked data object implies that it won't get unlocked until it goes out of scope which is bound to cause problems somewhere. This is just the tip of ice berg. There are likely many strategies that would work better, but my first thought is a double buffer. Have a read buffer that can always be read from and write to a different buffer, then switch the buffers with an atomic. You can switch while one is being read, but you can't write while another thread is writing. You also can't switch, switch back, then start writing without making sure no threads are still reading from the first buffer.
This... doesn't compile? Even fixing the missing `new`, `InterfaceImpl` is still an abstract type. 
&gt; Disregarding the fact that there are much better ways to do this than using a mutex, both references could refer to the same object which would create a deadlock, not the order of operations. The approach has broader usage than using a simple mutex. The article uses a mutex as an explanation of the generic approach. The synchronization aspects and possible solutions are out of scope. &gt; Then, returning some sort of locked data object implies that it won't get unlocked until it goes out of scope which is bound to cause problems somewhere. The described approach doesn't return any locked data object. All locks are taken inside the function invocation. &gt; There are likely many strategies that would work better, but my first thought is a double buffer. I don't think that double buffer is suitable for atomic changes of the object in the multithreaded environment. Nevertheless, I would like to emphasize that the approach has broader usage than concrete synchronization implementation based on a mutex.
What I do when I am coding a bad design but don't know how to immiedatly fix it is just to put a comment pretty much just saying that. // This design is not good. If I update anything this code // will break because of x, y, z. Need to figure out a better way // to design this. From there I just keep working. Sometimes I do go back to fix it, sometimes I don't. And chances are the longevity of your program won' t be long enough so that it ever really becomes a problem. But if your programs lifespan is that long, I guarantee you that by the time that section of code does become a app breaking problem that you will be better equipped to deal with that problem. In short, acknowledge the problem exists and you don't quite know how to fix it, but move on. Don't let it stop you. There are some standards to follow. Design patterns are some standards of design but you can definitely write good, maintainable code without using any of them. For me it's about 90% experience 10% learning the academic side. I read programming books often, but those books don't directly effect my code. More often what happens is I'll write some crap code and then think of this concept which I read in some book and be like 'Aha, *now* I understand why that's a good idea'. I would never got those 'Aha' moments if I didn't experience first hand why my code was crap and why that particular concept is good.
no, but I think both of these are trivial to add by making a custom wrapper around make_nvp
But there will be too much wrappers I think: custom wrapper around cereal and cereal as a wrapper around RapidJSON (for JSON archives). If we need to make custom wrappers around cereal what benefits we can take from usage of cereal? 
I believe Openframeworks comes pretty close. Not sure if there vector implementations but you could always use something like Box2d for that. Daniel Shiffman has some good stuff on box2d for processing which should translate to cpp pretty well. 
So cool linking articles from 2015 that link articles from 2014 in which code does not even compile. https://godbolt.org/g/igX2tz
Yep - openFrameworks are Cinder are the closest matches in this space. Also, Polycode - though I've never used it myself. Cinder ships with a Box2D "block" (addon) that has a few examples, I believe. Processing (p5) and p5js are very similar because a lot of the same people have worked on / spearheaded the two projects. Btw, OP you can also check out GLM for working with 2/3/4D vectors. OF and Cinder both use it internally for mathematics. 
&gt; Its nice to see that the compilers are way more on point when it comes to implementing stuff these days. Well since C++17 did not actually ship anything big it was not that hard. If compilers implemented all the Technical Specifications that would be unreal accomplishment. So C++11 was much harder to implement. C++11 was constexpr, threading, variadic templates, move semantics in STL and compiler... 
&gt; 2D vectors and methods for adding vectors, calculating magnitude, adding force, etc.? you don't need neither p5 nor openframeworks if that's the only thing you want to do; there are much simpler libraries for this (Box2d as was mentioned or Bullet physics). But yea, openFrameworks is almost the same API as processing (`ofCircle` instead of `circle`, `ofColor` instead of `color`, etc).
It's cool to easily fix the compilation by adding: using Mutex = std::mutex; The original article from 2013: https://habrahabr.ru/post/184436/ The article introduces Mutex type.
And how many are staying silent because they don't see a problem and the code author is doing a fine job of defending their decisions? Or because, as the OP says, 'it just doesn't matter.' Who knows..? Well count me, for one. ;-]
There is always an option to contribute these features to cereal instead of writing yet another library from scratch ;-)
Cool project, but to me solouno sounds better.
What about solomonosingleunoone?
Probably you need to make additional protection (ifdef guard) against each merged header as you could get two inline function bodies in one unit, so it won't compile.
as mentioned, openFrameworks has a similar api, but i think that's to its detriment if you're an experienced c++ programmer. Cinder is much better for those more used to the language. Also, not that it matters, but processing is more like p5js's father; it was around for a long time before the scourge of using-javascript-for-everything came about. 
Slick badges!
didn't know godbolt had the windows compiler.. very cool.
This is exactly the kind of problem you needn't solve with a memory and concurrency safety obsessed language like Rust :)
Does it handle missing keys in JSON? For example, if `"Two"` was missing, it would be left default-constructed in the struct. Even better, is it possible to annotate fields as mandatory or optional? Alternatively, would it work and understand `optional&lt;T&gt;` fields in the struct?
I believe you do not understand English sentences, or how logic works, or presumably both. You DON'T NEED the things Rust was built for in order to solve a one-shot file concatenation problem like this. İf you find the sentence hard to understand try reading it louder in front of a mirror. See, other people can be rude too
I think this option exist for those who use or aware about cereal. This is not our case :) If speak more seriously then we used RapidJSON and have no problems when there was small amount of types which need to be represented in JSON. But when that amount started to grow we decided to find a way to avoid writing a lot of boilerplate code. We also want to keep some JSON-features like absence of some fields in JSON-documents and nullable fields (like {"field":null}). We didn't see switching to any full fledged serialization library (like cereal or Boost.Serialization or something else) as an option. Because adoption of big library for our needs via contribution of some JSON-specific code is a hard, risky and slow process. At least as I see that. 
Yeah, there is a JT::Optional type which is sizeof T and there is a JT::OptionalChecked which is sizeof T + sizeof bool, i.e. You can check if it has been assigned. You can also get a list of what fields in the Json didn't map to a struct, and a list of what fields that didn't get assigned. 
So... In what ways "concatenating files in a single thread" actually benefits from rust' strong safety semantics ? What the parent meant was, I think, "this could have been much shorter and easier to do in $highlevellanguage like Python or maybe even unix tools like sed / awk ". This is not critical code, it's a one-off script that you run, not a server exposed to the web. Such things really have to be optimized for development time above anything else.
It can for sure shorten the novice stage, but yeah, not bypass it. Yep!
I misread the "needn't" for "need", my bad, completely agree with the original poster :p
From the README: &gt; This is my first Rust project, mainly created to start getting used to the language. My intention is to improve `unosolo` as I get better with Rust and the final goal is being able to successfully use it on popular libraries.
You need an Apple account, but you don't need to be a paid developer.
(Better) Support for VS2017.3 /std:c++17 mode?
Thanks for sharing it, really appreciated!
But then, how's it related to r/cpp? Doing something trivial in a random language that's not built for it.
1. I personally feel like I'm more productive in statically typed languages than scripting languages. Would take C++/Rust over Python every day (I've created small Python projects before and the lack of a type system is really painful). 2. Rust can be used to create anything, you can argue that it's not the best tool for the job but saying that "it wasn't built for it" is nonsensical. Language preference is subjective. 3. This tool was created for C++ developers, so I don't think it's out of place here.
The features you listed are in vs too
But we can't discuss the development of a tool written in Rust on r/cpp.
I think it has to do with old codebases, and C/C++ projects tend to linger around more than usual. All code I write in C++ is tested...
I would not be surprised if people avoided tests because of the soul crushing compile times too. Boost tests just take forever to compile...
This is why we need modules. :)
I don't know global percentages, but on our team of 8, 4 use it fanatically and the other 4 do it less obsessively.
Are you referring to "having tests", like early comments are discussing? Or genuine TDD, where all development work begins with a test that fails until the work is done? In my professional experience, TDD is usually not used. There's a valid argument for either side. TDD is like insurance. There's a regular, recurring cost and in return you're better protected against unforeseen catastrophes. In TDD shops, you get very good at predicting how much you're going to get done in a week.
I really like [Catch](https://github.com/philsquared/Catch) but I'm not sure of the compile time. 
I've been trying to get better at writing tests along with my code, but I'm not sure I would go full blown TDD...
I like using visual studio. Kinda heavy on the install though. If I don't have access to my desktop, I'll use sublime. As for spaces, I do everything on one line so I don't have to worry about tabs or spaces
CLion tab = 4 spaces
I'm using Qt Creator. I usually program on Linux and only sometimes on Windows, so Visual Studio isn't a candidate.
Everything in one line? Seriously?! 😂
I use, and contribute to, the lightweight IDE [juCi++](https://github.com/cppit/jucipp), and use Clang-Format's default LLVM style (2 spaces).
QtCreator, 2 spaces
QtCreator, and a custom clang format style that indents 2 spaces and makes sure that if I need to wrap parameters they all go on separate lines under the first one.
I am a free lance C++ software developer. I've worked a many companies over the years - maybe 20? In every case I've been the only one who ever wrote a test. I've done it make the job actually doable. After I'm done - the tests are deleted. The stated reason for not using tests is that "it takes too much time". The real reason is that tests find and highlight bugs and fix responsibility for them.
How come you do everything on one line? Just curious! It obviously works for you :) 
The indentation style that I recommend is *consistent*. Many IDEs have an option to show faint indicators for tabs and spaces, so you can see if your code is going to look like a sawblade mess to someone else. 
Lol, I don't. Dude I would die
I use Visual Studio IDE, Sublime Text and Notepad++. Visual Studio: for regular coding, it has knowledge of the projects in the solutions and of symbols and their definitions. Sublime Text mainly because I like its file locating capabilities (Goto). Finding and opening a file seems magical to those who haven't seen Sublime's Goto in action. Visual Studio's "CTRL + ," doesn't come close and sometimes crashes. Notepad++: mainly to analyze log files and to perform search and replace and create macros for repetitive tasks. I like its columnar editing capabilities and that's very useful for large-selection editing. I have all three open most of the time and their functions overlap, so I use whichever IDE/editor my file is open in. Edit: Indent style - 3 spaces - dictated by coding rules.
HAHAHAHA Oh god I am so gullible 😂
Thanks for explaining what you use each one for! Really useful :) 
&gt; After I'm done - the tests are deleted. Why's that so?
C++ guys prefer to not use TDD and then hire offshore coders to write unit tests for finished code when it turns out they can't sell it because having tests is industry standard now. Fun. Lot's of it...
Vim. 2 space tabs.
There's no necessity to use new here unless the object is getting stored in a pointer to the base type. And InterfaceImpl shouldn't be abstract because ClonableImpl implements the clone function. That's what the virtual inheritance is for. But I haven't tried compiling it, myself, so there may be a small error or two. The general idea works, however.
I use googletest, and once I have all tests compiled, it doesn't take more than 5 secs to compile and link changes in a translation unit. So, I cannot claim that compile time has been a problem for me, during development.
Visual Studio 2017 nearly exclusively. (Game Dev) My default/personal style would be most similar to Stroustrup's. But style doesn't matter at all, I use a http://editorconfig.org/ file per project to keep the style consistent. We do Allman style at work.
QtCreator: I don't work with Qt but I find it to have the perfect balance of functionality/speed/'weight'. I use Sublime for other languages (scala/rust) For the indentation, I use whatever the project uses and for my personal stuff it's OTBS/Java with tabs (I know...). 
I use XCode and VS2017, but ident style doesn't matter because we run clang-format before committing...
I think that this is more of a "package management" issue than module-related. One of the reasons I'm really attracted to Rust is `cargo` and how easy it is to use other people's libraries/tools. To use `unosolo` you literally only have to clone the repository and write `cargo run`. Hopefully the C++ community will decide to adopt a powerful package manager soon.
Yes, but be fair: sometimes it's the management that won't see the necessity until it's too late. "We'll do the tests later, first we satisfy the customer with fast deliveries." Sure, customers are probably happy to be the alpha testers... 
&gt; The approach has broader usage than using a simple mutex. The article uses a mutex as an explanation of the generic approach. The synchronization aspects and possible solutions are out of scope. But what you showed was a mutex and would be an extremely problematic technique. You can't handwave away the fact that this tutorial instructs people to do something that will likely come back to haunt them and ultimately be unworkable. &gt; The described approach doesn't return any locked data object. All locks are taken inside the function invocation. These don't seem like a contradiction to me. The problem is when they are unlocked. &gt; I don't think that double buffer is suitable for atomic changes of the object in the multithreaded environment. I wasn't talking about atomic changes to the data. If you can make a change atomically, just use an atomic directly. I was talking about data bigger than what could be atomic.
Vim, Tmux, Bash, and the GNU Toolchain. Indent by one tab in a new block.
I'm convinced style consistency is a valid code quality metric.
If you want consistence, use `.editorconfig`
Visual Studio and K&amp;R
People seem to use terms TDD, unit testing and testing in general interchangeable, we need to fix this first...
If you consider software engineering, and I stress the work 'engineering' where user requirements are elicited and design is driven by requirements, then no, why would you create a design driven by a set of tests - if you said you created tests based upon requirements and then designed to that then you are still doing requirements driven design, which in my 33 years as a real-time safety critical software engineer is the correct way to do things. Fag packet designs are another matter and so the domain is critical when asking and answering this question - like so many others.
Curious, have you tried VS 2017? It's lighterweight in that you can install just what you want. And it finally uninstalls cleanly.
Unfortunately the current algorithm only works properly for header-only libraries. It would fail in the case where two source files define a `static` function with the same name, as an example.
And VS Code 2017 is even MORE lightweight 
clion, allman, 4 spaces. plus ack / grep 
I'm just a hobbyist, but I usually practice TDD when implementing something nontrivial.
Run clang-format over the code and the metric is gone.
&gt; But what you showed was a mutex and would be an extremely problematic technique. I've shown synchronized object technique along with other use cases. std::mutex is a standard tool to use in multithreaded environment and I don't see any reason not to consider such approach as an introduction and baseline. Do you want to say that std::mutex should be excluded from standard due to deadlock possibility and "extremely problematic technique"? &gt; These don't seem like a contradiction to me. The problem is when they are unlocked. You said the following before: "Then, returning some sort of locked data object implies that it won't get unlocked until it goes out of scope which is bound to cause problems somewhere." Could you clarify what do you mean? Maybe some code snippet could be helpful. &gt; I wasn't talking about atomic changes to the data. If you can make a change atomically, just use an atomic directly. I was talking about data bigger than what could be atomic. You treat atomic concept as std::atomic only. I mean atomic as A from ACID.
I'm not a big fan of actual TDD. That might just be lack of experience with/knowledge about it, but I had the impression that it requires much more refactoring compared to an approach, where you write down an initial set of tests/use cases, think about a design and then and then write down an initial implementation of your function / class in one go. I AM a big fan of writing unit tests however and the two main pain points when I compare it to other languages are bad tooling support (for testing and refactoring) and long compile times. The inner cycle of modify/compile/run_tests is just much longer in c++ than in almost any other language (especially considering, that in many languages you can get the unit test results almost in real-time while typing).
&gt; Do you want to say that std::mutex should be excluded from standard due to deadlock possibility and "extremely problematic technique"? Why are you conflating your use of a mutex with any use of a mutex? I don't think this technique all together is bad or that it can't work, but you at least realize that if you take two references they could refer to the same object and crash or deadlock right? &gt; You treat atomic concept as std::atomic only. I mean atomic as A from ACID. I think you misunderstood. I was originally talking about an arbitrary buffer of data. If there are multiple buffers, any buffer that isn't being written to can be read from without any locking. An atomic boolean or integer can be used to switch which buffer a thread should read from. Another can be used on each buffer to keep track of the number of readers. 
Anything other than a K&amp;R derived style is anti-social behaviour. This is C++, not Java or C#. Please do like Stroustrup and the ISO standard. 
Agree, these are wildly different
I have some boost tests running over night on our build server. The main issue is that the codebase itself is not easy to test.
One of the biggest flaws of C++ is that it doesn't have a codified style. Python, as a counter-example, demands that you indent 4 spaces per scope. 
I don't use TDD because it doesn't make sense to me. TDD tries to decompose the software engineering process into all these sub-units, very few of which make sense in isolation from each other. In my work, I use a combination of debug asserts, code to generate test data, and code to run the tests. In my experience, I've found that the biggest problem with testing is being able to cover all the permutations. So my approach works well for the problems I deal with. We create test data automatically, we sometimes generate the testing code automatically, and we run the tests automatically. tl;dr TDD is overly granular, and in my experience, the test patterns don't really match the way the code/systems are actually used.
I have used a formal TDD based process a few times for a few specific careful small changes to large systems - and have done so, on occasion, since the mid 80s. I use TDD in the sense of "write test code that fails, write the code change that makes it pass, improve the code change while keeping the test passing" without dragging any other baggage along that some may associate with TDD. But it's a rarely used tool in my toolkit -- think of some of the widgets in the back of your household toolbox, not the hammer or the screwdriver (or the scissors!) but that oddly shaped angle wrench, which came in so handy a year ago when you were fixing that bookshelf. In general, if I'm adding a big chunk of code -- for example, a new module implementing new functionality to a system, or the rare case where I'm building a new system completely -- I tend to start by roughing out the design, knocking together some prototypes, killing them off and doing a better design, and by the time my interfaces are locked down to where I can start thinking about writing formal tests (that produce clear PASS/FAIL indicators that can be automatically collected and monitored), I have some pretty solid code already written. So those bits ... nobody would ever say that TDD was used to build them ;) And I'm the "automated build and test" fanatic in our group. 
Yes I hate that people just make up their own dialects, please stick to the standard please and use underscores. And Stroustrup is pretty clear that a K&amp;R-derived style is the original C++ style.
As long as it's consistent and braces aren't on the same line of code, I'll use whatever my employer mandates.
Emacs, and whichever indent style the rest of the project uses.
Does it support paths like `"foo.bar.test"` ?
Vim, 4 space tabs, 1TBS. Though I haven't used C++ in a while, mostly a Python and Erlang girl right now :P
VS, Allman style with real tabs.
What do you mean?
Agree, clang-format has been a game changer for me. Finally a code formatter I can trust enough to automatically run on all my code.
&gt; There's no necessity to use new here The function returns a `T*`, so there kind of is. &gt; And InterfaceImpl shouldn't be abstract because ClonableImpl implements the clone function. But I haven't tried compiling it, myself. The key is *which* `Cloneable`. `InterfaceImpl` inherits from both `Clonable&lt;Interface&gt;` and `Clonable&lt;InterfaceImpl&gt;`. The latter's `clone()` is implemented, but not the former's. 
VS Code is very slow though when you load a large directory. Especially when you compile within that directory, because it monitors all file changes
https://github.com/torvalds/linux/pull/437/commits
In that case you might want to check out [**doctest**](https://github.com/onqtam/doctest) - see the [**benchmarks**](https://github.com/onqtam/doctest/blob/master/doc/markdown/benchmarks.md)
I'm a big believer of human beings having as little control as possible on formatting rules. Instead, use clang-format and let your editor or IDE apply the formatting to the buffer every time it writes to disk. This is one thing the Go team did extremely well with their tool gofmt. (Even though I hate Go as a language ... but that's a separate discussion).
VS Code because it works best with both CUDA and CMake. 2 spaces, K&amp;R style for the most part.
And how many lines/files does your project have then? Unless you're talking about millions of lines then your "only takes 5 seconds" is a bit beside the point.
&gt; on one line so I don't have to worry about tabs or spaces I have a healthy distaste for line feeds and carriage returns myself, but if I'm feeling whimsical I'll sprinkle some whitespace around my braces and parens. Sometimes form feeds, sometimes vertical tabs, I find it's a good way to adjust the timbre of the code.
VS Code is getting better with each release, which happens monthly. It's not as heavy on the system as Visual Studio but since it's all javascript and HTML in a Chrome browser it can be resource intensive. 
Python demands indentation, but only requires consistency. Try tabs or two spaces, it works.
You're correct. The point I was trying to was that *correct* Python code has 4 *spaces*/*tab*. C++ code could be written as a single line, without linebreaks. 
**Company:** [JFrog](https://jfrog.com) **Type:** Full time **Description:** JFrog, the creators of Artifactory Universal Repository and Bintray. We are hiring 2 software engineers for the [Conan](https://conan.io) team, both of them with experience in C++ multiplatform building. Both are technical roles that will develop and support Conan C/C++ package manager, but one of them will be more focused on the product and the other will take a role of "Developer Advocate". **Location:** Israel, Madrid (Spain), SFO-SunnyVale (USA), Toulouse (France) **Remote:** Yes **Visa Sponsorship:** No **Technologies:** Compilers (gcc, cl, clang, apple-clang) and build systems (CMake, Makefile, Visual Studio (C++), autotools), Python, Jenkins, in multi-platform (Linux, OSX, Windows) **Contact:** More information in this [blog post](http://blog.conan.io/2017/08/28/Be-a-Barbarian-Join-Conan-Team.html), contact at info@conan.io (please use [BeBarbarian] in the subject) 
Done. I've also submitted a bug using "Report a Problem" feature in Visual Studio: https://developercommunity.visualstudio.com/content/problem/109875/bad-code-generation-for-coroutines-in-release-x86.html
In large projects (at least Chromium) linking tests takes up abysmal time, about 20 minutes on a decent machine.
Cool project! I just tried and imported a small meson project and it worked immediately, very nice. I'll keep an eye on it.
How do you do this ? I tried to get clang format to do this dozens of time but could never manage it
Under linux, I'm using CLion (for lack of a better choice), and my brace and paren styles [depend on context](https://gist.github.com/jrandom/c47d326b172bc2601aa03fc484b865b8).
Obviously, he likes wasting time on manual tests afterwards. Or he delegates testing to end users.
If you do a full link of Chromium, yes... but not if you are dealing with a a test for a specific target and you have already a full build. Chromium's tests are built for specific targets, so you cannot compare the link time for Chromium itself and its unit tests. Finally, I have linked chromium just recently, and I think it didn't take anywhere close to 20min on my computer (at least, I think I would have noticed that). Having said that, my comment was about the project I manage in my workplace, rather than Chromium.
Setting the 'bin pack' options to false ensures that arguments are either all on one line or all on separate lines.
Yes, I'm talking about slightly above a million lines of code. If your tests are all bundled in a single target unit test output that has to compile a million lines of code at once, you need to rethink the way you write your dependencies and test your code.
I have BinPackArguments: true BinPackParameters: true but it does not do what I want, eg : void some_function( std::vector&lt;int&gt;&amp; whatever, double x, double y); 
Small percentage, but that does not mean anything. Most of developers in language X are bad so you should not think that Y is a useless practice just because most of people do not do it. I personally do not do TDD, but I write tests for all my code that is not just bench marking/playing around. If you want a nice motivational/introduction videos about TDD in C++ watch this: https://www.youtube.com/watch?v=NVrZjT5lW5o Note that due to pathetic language support testing in C++ is harder to do than in some other languages, hopefully we will get some language support soon so macros will not be needed anymore.
You have it backwards, you want false here. I find this setting annoying. :P
int65_t in README.md
&gt; I don't use TDD because it doesn't make sense to me. Well this is not an argument. Quantum physics does not make sense to me, that does not mean that classical physics is better. If you actually did TDD for 6 months and decided your approach is better that would be valuable information, but just not liking TDD and not doing is not an argument against TDD. 
I don't know why my comment got duplicated. I've removed the duplicates since they don't contribute to discussion. There's nothing wrong with what you wrote; I only wanted to point out that constexpr is more like static than const in where it is allowed to be placed: const int * x = 0; // valid int const * x = 0; // valid int * const x = 0; // valid static int * x = 0; // valid int static * x = 0; // valid int * static x = 0; // invalid constexpr int * x = 0; // valid int constexpr * x = 0; // valid int * constexpr = 0; // invalid
Emacs, projectile, clang-format, and etags. I'd use VS code if I weren't so used to all the basic emacs editing features.
&gt; Why are you conflating your use of a mutex with any use of a mutex? Because my approach shares the same drawbacks with the mutex but prevents race conditions completely. &gt; I don't think this technique all together is bad or that it can't work, Before that, you said: "I think this approach has so much subtlety wrong that it does much more harm than good." It's strange to see the contradictions in the discussion. &gt; but you at least realize that if you take two references they could refer to the same object and crash or deadlock right? Wrong. Deadlock is possible but not in this case.
First was a typo, thanks. Second issue was something I overlooked. Thanks for pointing that out.
"If your tests are all bundled in a single target unit test output that has to compile a million lines of code at once, you need to rethink the way you write your dependencies and test your code." Who said anything about this?
You did, with the following sentence: &gt; Unless you're talking about millions of lines then your "only takes 5 seconds" is a bit beside the point. You introduced project size to the question. I'm only pointing out how it is not as relevant as you may think it is, when it comes to dedicated targets for unit testing.
I know. It's what is in the link on the former comment I've made, which you asked over.
Have you tried Visual Assist in VS? Alt + shift + O = goto file
Man, what kinda dreamy studio is already on 2017? We just moved up to 2015. You're a lucky bunch
For the record, I have tried TDD on a limited basis with a small system, and I do have a significant amount of experience with regular unit testing. Nothing against TDD in general, but for what I'm working on nowadays, I just prefer to use a different approach. To this point, I like to keep testing and implementation code totally separate from each other, as in not in the same file, not related at all, etc. While I really love and believe in data/code-driven testing methodologies, I just don't want to use an approach that radically changes the way our software development process works. As noted in my original remarks, I feel like TDD is TOO granular and that the isolated test results don't closely match the way the code is used in production.
Funnily enough I've never found an IDE I like as much as Emacs. Emacs doesn't force a specific directory layout on my project, doesn't crap a bunch of files into my working directory that may or may not need to go into version control and is plenty configurable for what I need to get done. Also, the default indent style for Emacs works fine for me, for C++ and Java.
Tried it a couple times on smaller projects, don't really care for it. But I do write lots of unit tests, usually right after getting a first pass on a class written, and do find that to be a huge time saver. And it's pretty nice on a tight deadline to be see all the unit tests pass and be almost completely certain that deploying the project will go off without a hitch.
I'd like to hear your opinion on Go
Where do you see the word 'better' in that short, simple sentence you quoted?
If you want C++ it's still 2-3 GB. Plus another 2 GB if you want the Windows 10 SDK.
The algorithm used here works okay for toy C++ header only libraries, but anything non-trivial e.g. including the same file more than once, or requiring a certain order of includes will break. If you need to generate single include files for real world C++ libraries including ones which do preprocessor metaprogramming, consider https://pypi.python.org/pypi/pcpp which I specifically wrote for that role. Oh, and generating something which doxygen's poor parser doesn't blow up on.
Count me as a "no" on TDD, at least in the formal sense where tests are written first. Testing in C++ can be tricky, as compared to say, python. Where I work, we get the job done, but C++ tests are usually less ideal than their python counterparts, mainly due to the disparity in difficulty with faking and mocking in C++ vs. python.
Somewhat in-between languages. I like TDD when you are writing functions that handle intricate input and the input is pretty clearly defined. It actually can make it easier and save time. The example input and inputs that can or has given you problems end up being used to make the test. Otherwise, I don't bother since I don't see too many advantages to it. 
You have done a lot with C++, especially advances metaprogramming. I would be interested in hearing your first impressions of Rust. Have you run into issues where stuff like lack of non-type template parameters or lack of variadics has made you wish for C++?
I personally use [Chromium's C++ style](https://chromium.googlesource.com/chromium/src/+/master/styleguide/c++/c++.md) and Qt Creator.
~~visual studio code runs on Linux, Windows, and Mac. I use on Linux and it works very well.~~ vs code bad. fake ide.
We still build with v140, I just started here last week and was able to get 2017 \o/. Doesn't Xb1 require v141 at this point?
Yes, the C++ toolset is about a GB. We've got compilers for four different target architectures and a couple different hosts. We've separated out ATL/MFC to save some space. On my install, I'm showing 2 GB for the Windows SDK, and 1 GB for the C++ tools. The VS installation directory is 1.5 GB in total, though I know that some other stuff is installed elsewhere (such as MSBuild, which I think is just ~1 MB.) I *think* the 2-3 GB estimate you give is more than a barebones C++ install requires, but not by much. And it could easily hit that if you include CMake or any other optional feature. I haven't done careful measurements--uninstalling and reinstalling--but I think you could do C++ for as little as 1.5 GB, or 3.5 GB with the Windows SDK. 
Qt Creator is a full IDE though, versus VSC being a text editor with plugins (a la vim). Certainly not a bad choice, but there is a difference between VS and VSC.
There's text wrapping, so you don't waste space and your screen can be 99% code. That's how you are the most efficient. Haven't you seen the movies?
A web forum or something similar that makes it easier to see thread history and separate topics. I subscribed to the mailing list myself but it seems to take too much attention to follow a conversation. Maybe I just need a better mail client?
&gt; columnar editing capabilities Thanks for teaching me that, I never knew it was a feature. I had been using excel for that all this time (to be fair, Excel allows some nice stuff if you need a sequence or the like, when for some reason a loop wouldn't be convenient).
I have subscribed but found it too time-consuming to parse things at a glance. Perhaps I should try participating and see. Can you recommend a mail client that's perhaps better suited than Gmail for browsing the various topics?
Indeed. It took one of the teams I was on a long time to fully grok unit testing and TDD is something we only managed to do on a few occasions.
I can relate to some of what you're saying. I've done both unit testing and TDD for embedded control systems and displays and the TDD was most useful for testing interaction between small components or for state machines. It was much less useful when testing things like algorithms where the output is a calculation rather than a mutation of some other component's state. I've yet to find a method for testing computations that I'm satisfied with.
Why do you need macros for testing? At least with Visual Studio, you just type test functions that call your code and put plenty of asserts to make sure you got the right results. It even tells you which assert failed so you can know what went wrong. The tests are pretty fast as well, and it can run them all in a row automatically after each compilation if you want that. Fair enough their assert class uses macros but at least you're not using them directly and they use templates to enforce type checking.
I would consider what I do to be software engineering and I've found it useful to break down customer requirements into sub-requirements that are implementation-specific and write unit tests based on those. Even better, I've done automated Acceptance Testing using Gherkin syntax that tests the customer requirements directly. It's enlightening and quite comforting to capture requirements as executable tests and know that with every change you've automatically verified that your code still meets the requirements. Further, your specification is now executable and intimately coupled with the code, which helps reduce bugs that occur due to the spec. and the code being out of sync. I feel this is especially useful in safety-critical code where even small changes can introduce risk. This method of testing allowed us to make rapid changes and increase the feature set without fear that something would break.
In my opinion, what you described: writing a set of tests, creating a design, and implementing it, *is* TDD. I don't think there's a rule that says you must write a single test and make it pass before writing the next test. I've followed your approach and as I implement the design I run the tests after I think another one will pass. It hasn't led to unnecessary refactoring in my experience.
I have no data for you but I can tell you I have personally done TDD in C++11. I've also dabbled with it in C#. I think it's definitely more complicated in C++. The standard unit testing design tools like dependency injection are not nearly as automated in C++. For example, Google Mock requires a lot of manual setup to function and actually injecting dependencies is something I've only done manually. Compare to C# where you have automatic IoC containers and things like Moq that can leverage inflection and TDD in C++ starts to look a bit tedious. I think it's also a coincidence due to a lot of C++ code bases predating the popularity of TDD. Still, I try practice it when I can and unit-test at least when I can't. The tooling is only getting better (Catch and hopefully some kind of reflection support in C++20) so I think it will slowly gain in popularity. That being said, I believe you have to think very carefully about your architecture and design to make TDD easier for yourself (e.g. leverage dependency injection).
VS2015 and 1TBS. I am not a fan of conditionals without brackets. They do nothing for clarity, and make maintenance and modification more difficult. 
mocking :) 
I suspect he means that when he leaves, the customer doesn't use or maintain the tests.
in "web scale" development, tests are done by users.
I use if (condition) { statement(); statement(); } for short/insignificant blocks; and if (condition) { statement(); statement(); } for more important blocks Try it!
VS2017 (c++, c#), Atom js, Stroustrup variant. TABS! I want to use Clion on InteliJ, just hard to get out of comfort zones.
Haha. Duh. Yeah, project size is clearly a factor when you're mentioning how long it takes to compile and link your project. And yeah - still no one but you has mentioned that compile and link times are only an issue "If your tests are all bundled in a single target unit test output that has to compile a million lines of code at once, you need to rethink the way you write your dependencies and test your code." https://en.wikipedia.org/wiki/Straw_man 
&gt;&gt; It was much less useful when testing things like algorithms where the output is a calculation rather than a mutation of some other component's state. Yes, this is basically my experience as well. Most testing methodologies start to break down when it comes to algorithms. In the C++ world, an algorithm usually deals with multiple objects, etc., and that code is just really difficult to test because there are so many valid and invalid states, and so many points where an invalid state is also quite possibly correct/expected. It's like all of these methods are good at one part of the testing process, but none of them are good at all of it. To my way of thinking, unit tests are really good at testing classes, but generally horrible for testing code code that's not really in a class. TDD is good for micro stuff, but loses the big picture fast. I can't imagine trying to use all of them at once. Oh the horror!
Congratulations! This looks very promising. I'm curious about a related thing. What is the motivation behind giving newer boost libraries _curious names_ instead of naming them after the simplest noun/verb that they represent?
See "Beast is a terrible name" in the FAQ http://www.boost.org/doc/libs/master/libs/beast/doc/html/beast/design_choices/faq.html 
I've had unacceptable results from clang-format. It seems to want to modify code that it doesn't understand. Including header reordering, X-Macros, and lambdas. I may be misunderstanding how to use the tool, though.
&gt; sufficiently vague as to not suggest any particular functionality That _completely_ answers my question, thank you. &gt; There is precedent for proper names: "Hana", "Fusion", "Phoenix", and "Spirit" come to mind. That is what came to mind. :(
&gt; t took one of the teams I was on a long time to fully grok unit testing and TDD is something I agree. The notion that TDD is all about writing tests and coverage instead of focusing on the behavior. That's one of the reasons BDD was coined.
Reorder includes is a setting you can disable. The other two I'm not sure what you're referring to. Never had any issues with lambdas.
I think if someone (maybe me?) was to build a robust HTTP client with Beast, which handled all of those "out-of-scope" things that Beast doesn't handle - and it could pass a Boost formal review, then the name Boost.HTTPClient would be fitting.
Qt Creator, K&amp;R with 4 spaces indents.
I have had some weird issues with clang-format as well. But only a few compared to the metric tons it have helped me. And also, if you find an error in the code, just submit a patch for it :)
[removed]
And of course if you care about consistency then you need to be consistent with the standard library and use underscores.
Naming conventions are pretty arbitrary and which one you prefer is mostly down to familiarity. So mostly it's about being consistent, which means you should stick to whatever style the standard library uses. I find C# very easy to read since everyone sticks to the standard library style. Same with Go and Python. If other languages can, surely we can in C++ too. You wouldn't do #define BEGIN {
Eclipse for development. So I don't have to switch for writing Python or VHDL. Whitesmith indentation with real tabs (shown as 8 characters ). 
We write video surveillance software: we employ TDD all the time now, and the few occasions in the past where we didn't produced very bad outcomes. We decide usage scenarios with customers &amp; project managers. Then we record or collect footage, as realistic as possible. Then we automatize the testing of this footage against our software (and sometimes software from competitors). That gives us data to present to marketing people, showing exactly what sort of test we do and what results we've got. We never lie on the results we get, and we never try to hide where the software doesn't meet the requirements: I leave that burden to sales people :) TDD also works as a form of unit tests (though we also have more traditional unit tests) and allows us to make drastic changes in the code, knowing our tests should catch obvious bugs. I can compare that to the situation we had a few years back: we didn't have any argument to convince even our people that the product was doing what it's supposed to. Sometimes, new features would get implemented and would break the requirements of another customer. This would show only months later, when upgrades are done on the field and their carefully tuned setup doesn't work anymore. Some team members would say "I implemented this feature" and you'd have to trust that both him &amp; the salesperson responsible for that project had the same expectations for that feature. And I'm not even talking about all the arguments that would follow where everyone says "I thought you meant this and that, you should have been clearer!". 
And then if you use standard library and Qt you're screwed, there is not always an easy solution.
All of them. Well, sort of. Here's the usual process for writing software: 1) Examine a problem. 2) Conceive a solution. 3) Imagine the results that the solution would have. 4) Write the software. 5) Verify that the reality meets the imagination in (3). If so, continue, otherwise, return to 4. 6) ??? 7) Profit! The main difference between this and what we call TDD is that what is imagined in (3) is instead written down as an executable specification.
Funny enough most popular answer on SO on that topic contradicts this https://stackoverflow.com/a/1777008/1269661 It's not like if you set some guideline it will be followed unconditionally.
I wouldn't say that `boost::hana` is a toy header-only library, but thanks for mentioning your application - it is certainly more mature and more powerful. Added a link to `pcpp` in https://github.com/SuperV1234/unosolo/commit/7ae1e2ad5a1ff9519b33b5ff767b6a5c2b810c59
Soon^tm as long as he hasn't finished it I am not convinced that he will actually do it. He has a tendency of not finishing his series, and there is a lot of "we will touch upon that later again" in his videos
Well, it was my understanding that rapid switching between writing test and writing application code (as in every few minutes - maybe half an hour) is the goal of TDD, but maybe that is because I've only seen toy examples of how to do it. In any case, I think tool support and compile time make unit-testing generally less natural in c++ than some other languages, However, if the OP also was thinking about the broader definition of TDD as you do, then those points might not be the main reason for slow adoption. 
Programming using C++ by Bjarne Stroustrup. It starts from zero.
- Programming by Bjarne Stroustrup is for programming beginner and happens to use modern C++. - The C++ programming Language by Bjarne Stroustrup teaches you everything for C++ and is not merely a documentation, it's a real book. If you read both you will have a correct level of C++. Then you can use more advance book like Scott Meyers ones. 
&gt; Isn't it a direct violation of a single responsibility principle? No. It is an implementation of the [Interface Segregation](https://en.wikipedia.org/wiki/Interface_segregation_principle) principle.
In a long career in C++, I have never worked for a place that practiced actual TDD. Don't get me wrong - unit tests are great. Integration tests are great. I write very little without thorough tests, even toy programs. I just don't believe a program is really working without complete automated testing. But writing the tests _before_ you write the code - the key idea behind TDD - has never worked for me, and I've never talked in person to anyone it worked for, and I've never worked for a company that did it.
&gt; Quantum physics does not make sense to me Two different meanings there. When PP says, "TDD [...] doesn't make sense to me", they mean, "TDD doesn't seem logical to me, and I think it's wrong." When someone says, "Quantum physics doesn't make sense to me," they (usually) mean, "I don't understand quantum physics."
&gt; TDD is like insurance. There's a regular, recurring cost and in return you're better protected against unforeseen catastrophes. Surely this is true of any methodology where you do a lot of testing, not just TDD? 
Now I use JuCi++ I have always preferred two spaces as indentation. It is enough to see the indentation clearly and to keep the code from exploding horizontally too far, being effective use of space.
I would not work for such a place. It's simply too stressful to develop modern program without batteries of tests, particularly when you are first starting on an existing project.
**Warning: shameless plug ahead** I was confronted with the same problem (need for polymorphic cloning). My solution was to create a [polymorphic wrapper](https://codereview.stackexchange.com/questions/54371/polymorphic-owned-reference-wrapper-for-class-hierarchies) (over `std::unique_ptr&lt;base_class&gt;`). For this class, I implemented non-intrusive polymorphic cloning. The parts in my post that relate to cloning: - polymorphic cloning implementation (`stdex::details::polymorphic_clone`) - choosing the correct cloning API (in the `to_polymorphic` functions). - storing the cloning API with the data (in the `stdex::polymorphic` class). Advantages of this implementation: - transparent to the user (YourType::clone is not required in client code) - universal (non-intrusive implementation)
&gt; In my opinion, what you described: writing a set of tests, creating a design, and implementing it, is TDD. But that is not what PP is describing - specifically, there's no evidence that they are writing the tests _first_, which is the cornerstone of TDD.
&gt; This is due to the fact that I have to think prehand more about what type of data I am processing and where Did you try to do this as well for python?
Yes, but it is not as confortal to use and in Python you can not simply declare some variable to be a certain datatype.
Disclaimer: I'm still a Rust beginner. First, the obvious: Rust got the defaults right (e.g. `const` by default), is safer than C++, has destructive moves, has an amazing package manager, can check a lot of stuff at compile-time, has a more powerful type-system, etc... I like traits, the way you can extend existing types, and UFCS. I miss C++'s metaprogramming facilities a lot, especially when trying to create nice/generic interfaces. I've used macros in `unosolo` where a variadic template or multiple overloads would have sufficed, and I really dislike that *(especially because they don't work with UFCS)*. I also find closures a pain to work with: there were situations where in C++ I would have used a generic lambda to avoid code repetition - but doing the Rust equivalent rarely pleased the borrow checker. I also miss automatic return type deduction for functions and `auto` for function arguments - like in C++ there are inconsistencies in this aspect between closures and regular functions. I miss `constexpr` and I think that a generalized CTFE would be amazing to compute things like `format!` strings at compile-time. Rust has powerful reflection capabilities (e.g. you can reflect on custom attributes). See the `structopt`crate for a great example of how they can be used. C++ doesn't have reflection yet. I dislike exceptions and I find Rust's approach to error handling very intuitive and powerful. I generally like the fact that Rust is very functional. I think that Rust has a long way to go before it can replace C++ for people like me that really enjoy the metaprogramming and generic programming aspect of it, but I optimistically believe it will get there one day.
[Isolator++](https://www.typemock.com/isolatorpp-product-page) offers some advanced testing capabilities. It's commercial though.
I'm still using 2015 so I don't know if any of these features are now in 2017, but here's a couple I find invaluable: - [Code Alignment](https://marketplace.visualstudio.com/items?itemName=cpmcgrath.Codealignment). Formats your code vertically to improve readability. - [MixEdit](https://marketplace.visualstudio.com/items?itemName=MarcoAlamia-CodingLabs.MixEdit). Multi-carat selection and editing.
http://boost.2283326.n4.nabble.com/Boost-Dev-f2600599.html is goot for catching up, except that it obscures names.
I had this exact thought today in regards to reading other peoples code, especially for larger projects. Other peoples python code confuses me way more than an equivalent C++ code. 
&gt; But it is more about my own personality and mindset. Yes. And the fact that you cannot adapt to other languages tells us more about you than about the *other* programming languages. To summarize my opinion: You haven't reached a certain degree of abstract and conceptualized thinking (yet)! Once you have gained the ability to recognize common patterns and structures independantly from some programming paradigms or even more low level syntax, you would not describe your thoughts like the way you did. Of course everybody has some preferred languages for he personal uses (which implicity is based upon the familarity and productivity); but an experienced, polyglot developer wouldn't base this soly on one *paradigm* (you have chosen *dynamic* typing as the source of evil), that is even only true for some higher abstracting languages. I would suggest you to learn more about more global paradigms (like *functional* vs *imperative* programming or the above mentioned *dynamic* vs *static* typing and so on); it would be best to choose a language, that **differs** from C++ in the more emphasized *paradigms* and that is *typical* for some specific paradigm. You have to leave your comfort zone in order to progress! (for example *Python* or *Clojure* for *dynamic* typing, *Scala* or *Haskell* for *static* and some kind of *very* strong type system (C++ is *not so string* compared to even Python!), *Clojure*, *Scala* or *Haskell* for *functional* programming - just to name a few well kown languages for that kind of paradigms)
Also Java or C# for OO languages that are used in the industry ;)
Ok replace "toy" with "trivial" then. Hana doesn't do things like magic statics, ABI management, I'm not even sure if there is a single virtual function in there! Compare that to say ASIO. pcpp can make a working single file edition of ASIO. It's quite a bit of work though, ASIO is quite complex internally.
I would like to note that I did not mention me not being able to "adapt" nor I ever claimed to be a programmer with 30 years of experience. Sure I am not a super bright person who can adapt straight away to another language in any situation. I have self-studied programming for about 7+ years now and I am not afraid of being honest about myself and to myself (more importantly). I began to study programming with Python and I really love it. I was writing a reporting program for my personal use at work using Python and this thought just came up after programming PHP project and personal C++ project at home before this. Sure it was easy to switch the language and write it. Just realized the issue (have noticed it before) after writing and organizing the code more that it is not as easy for me sometimes to visualize the program in my head if I read Python language. Sure I could have listed all kind of languages to the topic but what differense would have it made?
&gt; In Python I can just work with variables without worrying much about the datatypes, this leading me to lose overall sight of the codebase much faster. In other words: for you, seeing variable types around helps. I kinda think it doesn't. I quite like `auto`. I rather think that most of the time, the type is more noise than useful information. However, getting to know the type by going to some declaration is possible in C++, not in Python. So the two make a very appealing situation: * no noise * info accessible when needed
haha that's totally fair, though I will give credit, as of late he's been pumping out videos at a healthy clip.
The fact alone that you cannot *name* the concept that makes the difference for you between easy to read and understand and not so easy to read and understand, clearly shows that you haven't gained enough knowledge to handle the task of switching and adapting to other languages well. In fact it makes things easier to study (and learn of course) if you stumble across those *terms* and then deal with them, read about them and try to grasp them. That's why I gave you simply an advice. Not need to defend yourself😉 BTW: The downvotes here are also just showing more about the people here being somtimes extremly biased towards C++ in a kind of religious bigotry than about the quality of the post 😎 If somone praises C++ over some other language, he is super cool and becomes member of the inner circle of enlighted people - if he mentions some critique or tell about some benefits of other languages he gets downvoted like hell 😁
You're right - thx for adding!
I know exactly what you mean. The downvotes are a bit annoying because I tried to raise the point that this is not so much about the language, but more about my personalitly and how my own mind works. Had I posted this on Python section I would have gotten downvoted instead. Yes I have issues with certain terms used, because I am a self-thought programmer so I am not familiar with them. I check new terms long as I go. So thank you for that advice. Funnily enough I defend myself by making sure you understand how slowminded I am :D. I would also like to mention seeing datatypes taken in, be it by reference or not and produced by functions for example, it is much more easier to understand what is going on and what kind of data the function processes in C++ P.S. What term are you referring to by the way?
Python's [typing](https://docs.python.org/3/library/typing.html) library might help you maintain expected types in your mind while you work. Types are never checked during runtime but various third-party libraries exist to ensure type consistency. Also, I use consistent, thorough code comments which can also be parsed by documentation generators. I currently use [Google's Python coding standards](https://google.github.io/styleguide/pyguide.html#Comments) for comment format. Both CPP and Python are good languages and I hope these techniques make it easier for you to work with Python should you so desire.
I won't, his C++ strings video starts with "Before you watch this video you should watch the video about pointers and the video about arrays". WHAT? Why would I need to understand arrays and pointers to use std::string? Oh thats right, because he doesn't teach how to use std::string, at least not up until two thirds into his video
Me, too. However... * avoid superfluous compile-time dependencies * use precompiled headers * don't "build all" in a development cycle; there, you only change a small part of the whole thing works wonders.
That exception with vector is pretty weird. My approach to braces is to only use them for default construction, and a list initializer, otherwise i use parens. Or for simple types I use braces when I want to initialize to zero. I think though that the standard library already tends to prefer parens, inside e.g. `make_unique` the arguments are forwarded into parens, not braces.
I often find the same thing to be true with Java being hard to understand sometimes. Whether its 20 lines of Java that does the same as 5 lines of C++ because of some memory trivial memory and/or type management which can't be done directly in Java... or the dreaded Java streams mess and lambda messes that can occur when you compress 20 lines of C++ into 1 line of Java that is 200 characters long. C++ just feels more raw, not the same sort of raw as in C, but raw in the sense that there are less barriers put in place by the language and equally the language doesn't hand you thousands of different tools to solve the problem which can happen in python. With C++ you kinda feel closer to the code.
I'm in the same boat. Having learned many other languages like C++ and Java; Python is by far the hardest language! It's too simple that it's stupid.
The most important fact is that whether you knew C++ and started with Python or the other way round. Second thing is what coding style you were using? But I need to agree with you at some point that types in Python are often miss leading and for me C++ is more neat, I quite often had issues of using bad type in python. Compilation is advantage in the manner that you will not fall into some pitfall during runtime. But consider the fact that C++ is getting "Pythonized" over and over which in my opinion is good since they are picking useful functionality to simplify the language.
Tangentially, I love this c++ logo. 
Well, I feel you there, but python added type annotations to function declarations recently, and while they're just for ease of documentation, it does help completion engines figure out valid completions. Of course, this isn't what the same as what you want. 
*[Unicorn initialization](https://gcc.gnu.org/ml/gcc-patches/2014-12/msg01129.html)
I just wish it wasn't so god awful slow. It freezes and stalls every time I compile. 
Well, I learned C++ first, and Python a lot later, but I still consider Python a much simpler language. For one, almost everything is just a function. Classes or types are just functions that construct a value. Methods can be trivially detached from an object and used. Once you get used to hsi idea, it saves you huge amounts of code. Another is the fact that the primitive types are extremely powerful and intuitive. Another is that comprehensions make for much shorter and easier to read code: `[i * i for i in range(10)]` to get the first ten squares instead of the half-a-dozen lines of C++ that you'd need to do that. Ten years ago I'd have said that not having to worry about memory management was a big deal, but modern C++ has completely squared that away for us. The really excellent runtime library also makes code much easier to read, because everyone's using exactly the same libraries for everything. The near-triviality of mocking makes units tests easier to write. Don't get me wrong - C++ is an excellent language, and when I need CPU and memory performance, it's my only choice. But Python is a much simpler language. 
&gt; does not mean that classical physics is better For most practical purposes, classical physics *is* better.
&gt; The downvotes here are also just showing more about the people here being somtimes extremly biased towards C++ Wrong. They are a response to your rudeness.
Using auto isn't the same as writing in python. I python def square(x): return x*x square([]) Is valid python int square( int x) { return x*x;} auto x = std::vector&lt;int&gt;(); square(x); Will give you a compile error in c++ auto doesn't improve or reduce types on its own, you still get the same contextual information from the IDE. You could write c++ like this for a "closer" experience. void square(void*&amp; x) { int&amp; val = (int)*x; val = val * val;} auto f = std::vector&lt;int&gt;(); square((void*)&amp;f); 
How big is your project and what are your machine specs? I work on a multi million line c++ project, and once I've disabled jnfellisense and replaced it with visual assist, I have very little problem with performance. 
&gt; Wrong. They are a response to your rudeness. I don't see any rudeness at all - well, the OP fortunately has understood this and we can discuss the topic further :-)
I've tried multiple times to move away from Xcode. However, it's not just about typing and compiling, or even refactoring. The most important items for me are profiling and debugging. While VS Code has gotten better at the latter (pretty impressive actually), it doesn't do the former. My view is ultimately: don't fight the platform.
The best way to handle the combined mutex + data problem is to have the combined object not return a reference to the object, but return a separate handle object which can provide a reference to the object. The mutex is locked for as long as the handle is alive. LockedData&lt;vector&gt; v; { auto handle = v.get_handle(); // locks v's mutex auto&amp; vec = handle.get(); // do stuff } // handle goes out of scope, v's mutex gets unlocked This can be still be circumvented, but it's not the kind of thing you can easily do by accident. I should write a post about this some time, haven't seen this before.
I wish I were you. I am currently learning C++ as well but I feel like C++, even with its gigantic standard libraries, is somewhat counter-productive. For example this is D: import std.stdio, std.range, std.algorithm, std.array, std.string, std.conv; void main() { //split string by whitespace, turn them into ints and store them in a vector auto result2 = "1 3 2".splitter().map!(to!int).array(); //how many unique numbers? auto result3 = [1, 3, 2, 2, 3].sort().uniq.count; //pairwise sum auto result4 = [1, 2, 3, 4].chunks(2).map!(sum); //3, 7 //list k-mers auto arr = "AGCGA".array; auto result5 = arr.zip(arr.save.dropOne).map!"a.expand.only".map!(to!string).join(","); //"AG,GC,CG,GA" //group the words according to their occurences and return a vector of tuples like (word, count) string text = "Two times two equals four"; auto result6 = text.toLower.split(' ').sort().group; //most common words //need a quick and dirty quicksort? No problem int[] qs(int[] arr) { if (!arr.length) return []; return qs(arr.filter!(a =&gt; a &lt; arr[0]).array) ~ arr[0] ~ qs( arr[1 .. $].filter!(a =&gt; a &gt;= arr[0]).array()); //such easy slicing! } } Translate them into C++ and you see my point. D compiles all those into very fast (often just as fast as C++) native binaries. The silver lining is C++20 is going to get ranges, and UFCS, which is going to make life easier for me.
I think the "auto as python" argument is more about how much less typing you need to do. In Python, you still need to write valid code, it's just less effort to do it. The first C++ example was bad C++ code because you need to be more strict about typing in C++. I guess this is all too trivial to be actually constructive, but the multiplies python func is clearly written for numbers where you're trying to use it on a list. That's wrong but yeah will still compile. Here's a little of how C++ can look like Python though, with auto and decltype (although I've almost never wanted to use decltype). It'll still only work with a vector (or probably any standard container, who knows) but the point is that you've got the expressiveness of Python with the typing of C++. auto x = {1, 2, 3}; auto square = [](decltype(x) x) { return std::accumulate(x.begin(), x.end(), 1, std::multiplies&lt;int&gt;()); }; square(x); 
6 core sandy bridge. The project size is tiny, a couple thousand lines. It would be easier to shift the blame from visual studio if 2013 didn't run so well. I've been trying to turn things off to try to find something that is causing the lag, but it seems slow everywhere. I think it is doing a huge amount of ipc through network loop back to use node.js service processes.
Interestingly enough that c from [this example](https://gist.github.com/BRevzin/7b7ee46e64dd490f8bab88c3b28a0a1a#file-copy-h) is of size 1 only if compiled with gcc. Both clang and msvc will give you 0. https://wandbox.org/permlink/yj1GK116tIyGqhIR
Python is not a serious programming language(for big projects, it is fine for small projects where most of the work is done by library you are using), but what I like in C++ compared to C#/JAVA is value semantics. Obviously there is performance and control that is also important, but value semantics is what I really like about C++. 
using ranges in C++ ``` view::ints(1, 10) | view::transform([](int i){return i*i;}); ```
AFAIK there are no consensus of adding UFCS on c++ yet. But yeah, the synergy between ranges and UFCS on D is awesome :)
The typing library is one of the big reasons I have been pushing to get to python 3 from 2.7. Have you used it? Does it add much? We have a huge python project, and keeping track of what is being passed around requires an extensive mental map.
&gt; Using auto isn't the same as writing in python Sure, I didn't want to imply that. Did I?
Adding to the fire of people showing you that it doesn't take a half dozen lines :-) auto i = 0; generate_n(back_inserter(v), 10, [&amp;]{ auto const j = i++; return j*j; }); Although I like the ranges example by /u/D_0b better, I've not played with ranges yet but find them very exciting. (BTW, I have no using statements in this code... the lack of std:: is due to ADL)
 &gt; No UFCS in the next C++ Why has god abandoned me?
I'm only kind of newbie but I understand this 100%
Clang implemented [DR 1467](https://wg21.link/cwg1467) (it's a plain copy) but hasn't yet implemented [DR 2137](https://wg21.link/cwg2137) (no, it's not). I've no idea what MSVC is doing.
I think Python also packs a lot more information into one line. The array manipulation routine with numpy can be insane. 
Likewise. I'd much rather read/write C++ over python because it just makes more sense to me, probably because I've used it for longer.
That's the new optional 64 bit integer type.
&gt; Had I posted this on Python section I would have gotten downvoted instead. 😅 I see we do understand eachother! 👍 &gt; I would also like to mention seeing datatypes taken in, be it by reference or not and produced by functions for example, it is much more easier to understand what is going on and what kind of data the function processes in C++ That's the core argument for people in order to judge *static* typing being superior to *dynamic* typing. I do not want to repeat all arguments pro or against each other. *Both* approaches have their benefits and limitations. The problem that lots of people have - escpecially if they come from a *statically* typed language first - is, that they cannot adapt to a *duck typing* style. They still think in predefined types; almost often some kind of *object* hierarchies. And that's the core problem! Within dynamically typed languages your API should not care about a special *type*, but instead for some special *behaviour*. In the end that doesn't differ from the advice within lots of OOP langs to program towards *interfaces* instead of *implementations*. The real difference in Python (or any lang with *dynamic* typing) simply is, that you don't need any kind of hierarchies. That makes the language more flexible and *terse* in many ways, but of course you kinda need more discipline in some ways, like a good documentation for example. &gt; P.S. What term are you referring to by the way? *dynamic* vs *static* typing - the classical *[type wars](http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html)* 
I use spacemacs with rtags &amp; ycmd. I use clang-format (from the emacs plugin) for formatting. For braces, the rule of thumb is that namespaces and control constructs (like loops, if) get braces on the same line. This is to prevent wasting tons of vertical space on trivial ifs and such. Classes and functions get the brace on a new line for clarity (unless they are empty or something like that). 4 space indent, 110 columns.
Can you elaborate on the custom attributes? I was on the strong impression that Rust does not have reflection, which is why you need to have crates with macros that you have to adorn your classes with to get serialization (basically, the Rust equivalent of Boost Fusion).
Just look at [`structopt`](https://github.com/TeXitoi/structopt): #[derive(StructOpt, Debug)] #[structopt(name = "example", about = "An example of StructOpt usage.")] struct Opt { /// A flag, true if used in the command line. #[structopt(short = "d", long = "debug", help = "Activate debug mode")] debug: bool, /// An argument of type float, with a default value. #[structopt(short = "s", long = "speed", help = "Set speed", default_value = "42")] speed: f64, /// Needed parameter, the first on the command line. #[structopt(help = "Input file")] input: String, /// An optional parameter, will be `None` if not present on the /// command line. #[structopt(help = "Output file, stdout if not present")] output: Option&lt;String&gt;, } You basically put some `#[structopt(...)]` attributes on an existing `struct`, make it `#[derive(StructOpt)]`, and the library will automatically generate the required code to fill the `struct` from command line arguments. let opt = Opt::from_args(); As far as I understand, it's reflecting over `Opt`, finding all the fields marked with `#[structopt(...)]`, and generating code. 
[here](https://github.com/philsquared/Catch/issues/1021) are the results
&gt; In 2012, Matt and a colleague were arguing whether it was efficient to use the then-new-fangled range for. Replace "ranged for" with literally anything else, I use godbolt on a near-daily basis to verify it. Especially as you gain experience with C++, when you write expressive code you have intuition on what exactly can be optimized away by the compiler; godbolt is the fastest way to verify that intuition. I only wish actual IDE's had interfaces as nice as godbolt for exploring assembly so I could look at much larger, and proprietary programs locally.
Yes, this is what I mean. This is not reflection at all, but code generation, just a more elegant version of Boost Fusion/macros. Reflection is not intrusive; it allows you to iterate over the fields of a struct without marking the struct with #[derive(...)]. This doesn't seem like a big limitation, but it's actually quite huge. This works well enough for "reflecting" over structs you control, but it does nothing in terms of helping you reflect over structs that you don't. I was incredibly disappointed when I heard that Rust had opted for "hygienic" macros instead of reflection. 
It's really helpful. Also, if you manage to annotate everything, then you can run the code with mypy, which enforces type restrictions.
i know this is r/cpp but you are not actually serious, right? The equivalent of the above in python is (x*x for x in range(n)) and this is an iterator by default. `[]` will make it a list. I am trying to learn python these days, and I am amazed how easy things get when you are not trying to squeeze out the last micros/nanos from your code. Edit: you did `iota` from 1, but range starts from 0, so it is not exactly equivalent, but you get the idea. 
For me it depends. When I develop a general purpose library, then I write most of the time the tests after the implementation is done. I nearly never use now TDD for application development, because I made the experience that most of the time, the problem is not within the single units, but in the collaboration between them. Here I go for end-to-end test. And when the sum of all tests take too long, then we add more hardware to it and run them in parallel. The papers that opened my eyes most are from Jim Coplien: [Why most Unit-Tesing is Waste](http://rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf) and [Segue](http://rbcs-us.com/documents/Segue.pdf )
When I wake up sad, I write some C++, get a template instantiation error, and am forced to read the code written by the legendary C++ programmers of our age, like: - Niebler the Mighty and Carter the Great: [range::v3::common_tuple](https://github.com/ericniebler/range-v3/blob/master/include/range/v3/utility/common_tuple.hpp) and [the MSVC necronomicon](https://github.com/Microsoft/Range-V3-VS2015/blob/2695c779d52717b635e97352fed6b75d32eba7a4/include/range/v3/detail/config.hpp#L109). - Hinnant the Timeless, Marshall of Heaven, Eric tenacious WOOF, Park the Shapeless: [std::bind](https://github.com/llvm-mirror/libcxx/blob/master/include/functional#L2336), [std::variant](https://github.com/llvm-mirror/libcxx/blob/master/include/variant#L605), `std::invoke`, `result_of` and friends. - Guzmann the Brave, Dionne the Stateless, ... and many others of whom I have no time to tell. After that I am no longer sad, because while I might need to read that code once, I can feel the pain of those that had to write it; they have it worse than I do :) Therapists should recommend it.
&gt; but it does nothing in terms of helping you reflect over structs that you don't I see your point now - it makes a lot of sense. While I think that the current `#[derive(...)]` mechanism is incredibly useful, I do agree that it's not "true" reflection and that reflection would be more powerful/flexible. Let's hope that the committee will be able to reach consensus on static reflection and metaclasses quickly!
&gt; Let's hope that the committee will be able to reach consensus on static reflection and metaclasses quickly! Well, I half agree with you ;-). Thanks though for posting this, it's nice to get a perspective on Rust from people who actually use and like C++.
Does anyone know when the compiler flag in GCC will stop being called c++1z and be called c++17 instead?
VSC is not an IDE but a glorified text editor. Also, Sublime Text is a superior text editor in almost every way (especially performance).
You’re right. So sorry.
Ranges are not (yet) part of the language...
Do really think this is as simple as `[i * i for i in range(10)]`?
Assuming you are not paid D promoter: This is cool, but I almost never hit this in real life... I rarely sort/unique stuff. And even more rarely I need to map uniqued array of ints to strings kind of algorithms. That being said you can check out the C++ range library, it should be nice for your use case.
As a heavy python developer, I know exactly what you mean. I think my biggest hangup with python is the lack of explicit typing. This makes it really hard to learn new libraries because the return type is often omitted from documentation.
FYI, Mypy ( http://mypy-lang.org/ ) works well in Python 2 comments: http://mypy.readthedocs.io/en/latest/python2.html and Pycharm has integration for it as good as for Python 3.5 typing. I'm not sure how many things it can express without the actual `typing` module.
Did I say that I did?
For example, if I have a member `int m_Test` in my struct, but in the JSON it is stored inside of another object: `"foo" : { "test" : 13 }` , I would like to refer to it as `"foo.test"`. Or maybe I just have to change my architecture. Is it possible to use a `std::vector` of custom (but readable using your JSON wrapper) objects?
you can do this already, in C++11, with range-v3
This was why I moved from python to learning C++: I had started a summer internship writing simple scripts for R&amp;D work, which Python is positively *splendid* for! But then I was offered a part-time position to rewrite an application written in MATLAB (no shit, entire app in MATLAB) to be faster in Python. I quickly realized how fast Python fell apart for large projects, particularly with the typing issues, and decided that C++ would work better (plus, IDE support for C++ is more mature and better for big projects anyways)
Additional, very high quality, but lighter weight than the Mersenne Twister, generators in the standard that are used in examples as the go to choice. xorshift or something. 
I truly dislike using runtime checks for something that can be determined at compile time, that's why I prefer to just use different implementation files for different platforms. It's also a simpler solution.
Could you please not use that title (or variations on it) for your future talks? I recognize that for this specific talk, you've already locked it in and it's probably too late to change anything, so this is more of a suggestion for the future, not for this specific instance. The problem is that for people like me, the existential void created in the pit of my stomach by reading anything to the effect of "Make 'X' Great Again", induced by its origin as a political slogan, is ultimately really distracting from the content itself. And while I don't know you personally, I'd like to give the benefit of the doubt by assuming that it wasn't your intent to inject this kind of political vitriol into a talk about software programming.
One possible reason is native libraries. If you compile all platforms into the library, it will have dependencies on native libraries not available on the other platforms, causing unresolved symbols at link time.
I've used it only briefly and found it helpful, though not overly so. Many believe that the typing library subverts the core "duck-typing" feature of Python and that its use necessitates a cascade of un-Pythonic patterns and techniques in order to pass static type checkers. If one has the need for stronger types, they believe that one should use another language more suited to the task. In my opinion, however, the expert knows *when* to use each tool and he knows exactly *how* to safely and maintainably use them when the time comes. I usually don't use the types library but I'm always watching for more cases in which it would help.
The thing about reading Python that I like so much is that it's much easier to know where everything is defined. In C++, you include a header and have access to everything in it. #include "foo.h" #include "blah.h" #include "whatever.h" // ... bar(); // Which header did this come from? In C#, you use a namespace and have access to everything in it. using System.Whatever.Foo; using Company.Things; using Third.Party.Library; // ... Bar(); // Is there a Company.Things.Bar or Third.Party.Library.Bar? In Python, you import a module, and have access to the module. import foo import things.whatever import os # ... foo.bar() or import a particular thing from a module: from foo import bar # ... bar() # I still know where this came from! Granted, it's possible to get the same sort of situation as the others: from foo import * But that's highly discouraged within the Python community.
I don't see what it would gain you. You still have to have separate implementation files (or ifdefs) as the platform specific code will usually not even compile on the other platform.
&gt; For example, if I have a member int m_Test in my struct, but in the JSON it is stored inside of another object: "foo" : { "test" : 13 } , I would like to refer to it as "foo.test". No, you can't. json_dto is a serialization/deserialization library only. To deserialize JSON like `{"foo":{"test":13}}` you need something like: struct Test { int m_test; template&lt;typename Io&gt; void json_io(Io &amp; io { io &amp; json_dto::mandatory("test", m_test); } }; struct Foo { Test m_foo; template&lt;typename Io&gt; void json_io(Io &amp; io) { io &amp; json_dto::mandatory("foo", m_foo); } }; then you can call `json_dto::from_json` and get access to "foo.test" like that: auto foo = json_dto::from_json&lt;Foo&gt;(some_string_with_json_inside); std::cout &lt;&lt; foo.m_foo.m_test &lt;&lt; std::endl; &gt; Or maybe I just have to change my architecture. Is it possible to use a std::vector of custom (but readable using your JSON wrapper) objects? Yes, you can. [Here is an example](https://bitbucket.org/sobjectizerteam/json_dto-0.2/src/abd1779853e632cafc8a088887acb7ef0abf7e75/dev/sample/tutorial6_1/main.cpp?at=default&amp;fileviewer=file-view-default)
That's what used to happen to me, but once I got a job at a company that solely used Python I quickly changed my mind. Python is a beautiful coding language and, like you said, if you're a slow learner you need to take time to learn it's syntax &amp; ins &amp; outs. If you really understand the function/class you're writing, you'll already know the data type of all variables being used. In Python just use more precise variable naming if you'd like to emulate the more descriptive nature of C++ code. In many cases you can do, in 100 lines of Python code, what you would struggle to do in 300 lines of C++ code. If you can justify that to yourself, or performance is the #1 issue, than C++ is the way to go. Otherwise, my project schema is; always make some mockups in Python to test viability, later, if required, transfer over the logic to C++ code and make lower level tweaks there. You can also always use Cython to convert Python code directly into C. Appreciate the post, just putting some thoughts out there.
Doesn't really matter. You can still use it.
[removed]
I think python is a good replacement to shell scripting, but that's pretty much it. It is not suited for creating complex programs like C++ is.
I've been using C++ to one end or another for years. Python just confuses me. I find it hard to read even my own Python code. Perl, on the other hand, is a breeze.
Vertically alignment, now that's an old-school thing that's completely fallen out of favour it seems. At my work this is banned for the usual reasons. 
This is a disaster of code any why so few people like C++. Procedural languages trying to be functional are often a mess.
Thank you for a very insightful response! I have heard of that term all over the place but have not really taken a note on it, Will do from now on!
I'd rather finally have Image Watch for VS 2017..... it's the biggest productivity boost ever. Will probably never happen so will be stuck on VS 2015 forever :(
This is why I use either a namespace or a class structure in C++ to know where everything is coming from.
Not in a cross-platform project. (I'm looking at you VS2017.3)
You forgot to declare `v` I think. makes it 3 lines ;)
[removed]
Not on VS2017.3 unless you want to pull 2 separate repos of range-v3 into your code-base.
https://github.com/Microsoft/Range-V3-VS2015 has been around for a while now... It's outdated but it gets the job done.
This. I love python but I really wish people annotated types in their documentation. 
I like C++ because of all the things that show up as compile time errors, rather than having to hope you find the runtime error in your testing. Python has its strengths, too, but for big projects, I prefer a more strictly structured language. 
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
What I find to be the biggest pain the the ass with C++ is managing dependencies/cmake and what feels like having to duplicate declarations in header files. Part of the reason that Python is so popular is the pip package manager. Conan still hasn't become ubiquitous. Recently I've found myself starting to write much of the code I would have written in C++ in go primarily due to how much simpler it is to manage dependencies and deploy binary executable. 
Just wait until you have to fix bugs in a large code base in Python, the hate will flow from your guts into the keyboard. 
To me C++ is only easier and logical to read / write if the developer uses both modern C++ and skips a lot of the stupid little corners of the language few people ever use. If you're using a subset then it's great. The trouble is I've never found anyone doing this. Even code that I get pointed to where it says the person who wrote it kept to a modern subset of C++ almost always uses lots of C is awkward places or some insanely setup templates that take me way, way too long to figure out. I love C++ but I think because of its C support and its incredible language size that most C++ code just won't be that easy to grok. At least for me.
VS2017.3 is not a C++11 compatible compiler.
[removed]
I know its not really C++ related, but since there's a decent amount of overlap with people who use C++ and shading languages: GLSL syntax highlighting support as an official addon would rock. There are nice extensions (like Sascha's) for compiling SPIR-V shaders, but no syntax highlighting extensions have been updated for 2017 yet (since I last checked, at least) :/
It got better: xoroshiro128+
Preface: Was C++ developer for 6 years. Now python dev for 3. In both cases for AAA game studios. In both cases thousands lines of code in the projects. &gt;This is due to the fact that I have to think prehand more about what type of data I am processing and where. In Python I can just work with variables without worrying much about the datatypes, this leading me to lose overall sight of the codebase much faster. I don't understand this reasoning. How thinking about TYPE helps you to keep overall sight of the codebase. When I program I think about abstractions. I don't care what type they are. If you write a function - who cares what actual types are used for input or output? All you care is domains of applicability. Interfaces and meanings of them. Write good docstrings with explanations what you will do with the data and what will be returned - and this is much more useful then just type. Same type can represent completely different meanings of data. Add to that type hints by itself or in docstrings and any normal IDE will provide you proper code completion. 
The typing module works in 2.7.
Tbh, std library code is convoluted so user code can be simpler and more expressive. It also has a finished state, which is rare in client code.
Thank you very much for taking your time to explain it :) I can make this work the way you proposed it.
TDD is an example of focusing on the tool instead trying to solve a problem. If it is adequate to solve a problem, good, use it. If it is not, don't try to put the square block into the cylinder hole. 
&gt; ~~std~~ C++ library code is convoluted so user code can be simpler and more expressive there, fixed that for you
&gt; At my work this is banned for the usual reasons. I'm getting downvoted, but not sure why, so I'm interested in learning some of those reasons. I suspect maintainability would be a big one, but I find the improved readability helpful in certain circumstances. 
They are a library feature. You might not have the library, but they (or similar) can be written in the language.
python is an example of a procedural language with functional subsystems, like list comprehension. 
Your identity element is wrong, should be 1.
maybe you can call 'go to definition' on your favorite editor/ide?
Oh the horror, in the job I got right after uni I had to write a 3D Renderer in MATLAB. It was a pain in the a**. But it worked in the end. To this day I don't understand why they wanted that, but they sternly insisted that they'd need it.
You claim to be able to read perl code? 
With a mutable lambda and in-capture-value-definition you can even avoid the `auto i = 0;`: generate_n(back_inserter(v), 10, [i=0, j=0]() mutable { j = i++; return j*j; });
&gt; identity element I'm not sure what that is, but I was trying to make a comparison between a python list and a vector or whatever container. 
True, I intentionally left it out as irrelevant to the task of generating the numbers, but that just points out one of the strengths of C++ in this example... no code path could be executed that skips the declaration, leading to a runtime failure. :-)
Good point. I didn't like the reference, that's cleaner. EDIT: I just now saw your edit with the code. What's up w/ code after the return?
...fixing this code example: generate_n(back_inserter(v), 10, [i=0, j=0]() mutable { j = i++; return j*j; }); 
The pattern of a single .h and multiple .cpp files is commonly known as "static polymorphism." One big reason to prefer it is that it's just simpler. Fewer classes (no interface or PIMPL interface required), fewer abstractions hiding details, and essentially no practical downside (you can't hot-swap platform-specific implementation details and have to rely on a larger CI infrastructure anyway to properly test them). There can also be space and performance benefits. Adding even a single virtual function adds some overhead thanks to the vtable and virtual function dispatch. If there's only ever a single implementation in the compiled binary, that's pure waste. For things like `File` the virtual call overhead is probably irrelevant in practice. For objects with many instances in applications running in constrained environments (embedded, budget phones, chromebooks, handheld game systems, etc.) the space overhead of the vtable may be very costly. For objects used in very tight loops, the indirect branch overhead of a virtual function call may be too costly. Some hardware handles indirect branches poorly enough that the overhead may be too costly even for interfaces outside of particularly tight loops.
This talk is not about politics - it is about writing better code :)
Off topic, and since no one else mentioned it, I figured you won't mind some corrections &gt;To me C++ is much more easier To me C++ is much easier. Same thing here &gt;One interesting thing I have noticed is that writing C++ and reading it is actually **more** easier for me One interesting thing I have noticed is that writing C++ and reading it is actually easier for me 
Brace initialization allows classes to imitate aggregate initialization. Use it (only, exactly) when you have something like an aggregate, where the contents of the result include the values inside the braces. One-size-fits-all thinking is bound to fail. But it's also a siren song to teachers who are eager to condense a syllabus and free to cherry-pick examples. This article's major omission is the difference between direct-initialization `T var{a, b}` and copy-initialization `T var = {a, b}`. This is really where most C++ users get confused. Personally, I prefer to keep the `=` when dealing with value semantics and omit it when the identity of the object is really important. And, when arguing against the "uniform" idea, it's good to remember the `explicit` keyword which forbids use with the `=` sign — signifying a departure from value semantics.
Have you ever looked at Boost source code? You need an IDE pretty fast to make it a useful endeavor 
[removed]
I'm sorry, I was writing this on my phone and borked the lambda body. But I hope it still got the point across
Which is my point: if the talk has nothing to do with politics, then it would be better not to use a title that (even if unintentionally) invokes political rhetoric. 
It should. I used clang pre-5.0 from SVN specifically because clang 4.0 doesn't work with libstdc++ headers from GCC 7.1.
This is an interesting viewpoint. When I'm reading code my understanding is entirely based around the involved entities and what the represent, something which is usually encoded by the type system. Without seeing the types I find it almost impossible to understand code.
The following code could be used to return reference to large object: struct Object { AdaptedSharedLocked&lt;LargeObject&gt; getLargeObject(); }; AdaptedLocked&lt;Object&gt; object; auto largeObject = object.getLargeObject(); largeObject.someMethod(); Both Object and LargeObject are synchronized. AdaptedSharedLocked is a shared_ptr around AdaptedLocked thus it contains reference shared together with Object without race conditions.
Your `square` always returns 0. Could also use [std::multiplies&lt;&gt;()](http://en.cppreference.com/w/cpp/utility/functional/multiplies_void) so the type is deduced.
I think the simple truth is that for some few people, such as myself, the incredible ugliness of C++ is itself rather beautiful. I've yet to find a language that appealed to me as much even though I can see how some alternatives are better in many areas. The problem with all alternatives so far is that they're simply not C++. Which is stupid...but it means I'm pretty good at this particular language. Not great...but pretty far above most people that find switching around languages a whole lot easier than I do.
Thanks for the tip, edited! 1*0 is what you're saying.
Writing C++ on a phone keyboard? Brave! My other response has a fixed version.
Thanks, I corrected my post :)
I would mention that the United States != The World. And that catchphrase was long in use elsewhere in the world, indeed it was borrowed I believe from some campaign somewhere in the late 19th century. If you're feeling things about it, that's more on you than anything. Besides, it's catchy, and getting people to just turn up at all at CppCon is very hard. As Vinnie will recall, I got like five people at my last CppCon talk. Compare that to the 120+ I got at my ACCU talk where I used a catchy title. I am learning!
&gt;I think this approach has so much subtlety wrong that it does much more harm than good. Just like your comment... ¯\\\_(ツ)_/¯
BTW, to any C++ newbies reading this, there's a very important reason that my original example, and the better version suggested by /u/shared_tango_ use a temporary (j) rather than just incrementing i. Some might be tempted to write: generate_n(back_inserter(v), 10, [i=0]() mutable { return i*i++; }); ...but this leads to undefined behavior as the values on each side of the `*` can be calculated in any order, so the increment could happen before OR after the multiplication.
&gt; my understanding is entirely based around the involved entities and what the represent Totally agree. &gt; which is usually encoded by the type system. Without seeing the types I find it almost impossible to understand code. Not so much here. Even just names of the entities play much greater role than types. int a=37; int b=crc32('ILLEGAL_TO_DRINK_ERROR'); can_i_drink(a); can_i_drink(b); save_error_to_database(a); save_error_to_database(b); Did it helped that they are all ints to see what this code does and what was wrong? Now remove types and add proper names: age = 37 TOO_OLD_ERROR = crc32('TOO_OLD_ERROR') can_i_drink(age=age) can_i_drink(age=TOO_OLD_ERROR ) # Woot? save_error_to_database(error_crc=age) # Woot? save_error_to_database(error_crc=TOO_OLD_ERROR ) Does it matter for the logic that can_i_drink takes int? No. Only makes sense that something representing age. Why shouldn't it work with double? 
True. It is much easier to do in some dynamic, quick and dirty languages like Python. The dynamic typing and GC really help. The other reason it is easier is that some common patterns have been promoted to syntax, like comprehensions.
&gt; Tbh, std library code is convoluted so user code can be simpler and more expressive. Yes, that's the [MIT approach](https://en.wikipedia.org/wiki/Worse_is_better#The_MIT_approach).
The only prior reference I can find for the phrase is the election campaign of Ronald Reagan. More importantly, [A cursory glance at Google Trends](https://trends.google.com/trends/explore?date=all&amp;q=Make%20*%20great%20again) shows that across the whole world, the phrase only became widespread at the same time as Trump's Candidacy began to foment, which means arguing that someone's use of the phrase was intended to refer to some other usage of the phrase is an argument in bad faith. I get that trying to come up with catchy titles for talks can be important and difficult, but I've seen plenty of C++ topic speeches that don't invoke the specter of unintentional political rhetoric/dog-whistles in their otherwise-catchy titles. And it doesn't seem like I'm the only one who feels this way.
I really think it comes down to the type of software you write. Strongly typed programming environments certainly have their advantages in some software spaces. It has actually been a long time since I've written any C++ often choosing Python instead. The tis mainly due to two things, no low level and lots of scripts that by themselves don't amount to much. If that wasn't the case I'd probably use C++. 
Your example is terrible. You're changing variable names, not types. Python can be a nightmare because you're staring at a huge mess of symbols without any types, and you have to spelunk around all over the place looking at implementations because you've got a tuple and something else expects a list. Or you have to run something in the debugger just to figure out it's passing you back a dictionary, etc. 
&gt; instead of the half-a-dozen lines of C++ that you'd need to do that. Am I missing something? Even without ranges or `generate_n` or other fancy stuff this would simply translate into: std::vector&lt;int&gt; v; for(int i=0; i&lt;10; ++i) v.push_back(i*i); Granted, the python example is still easier, but the C++ code is hardly unreadable or half a dozen lines.
&gt; You're changing variable names, not types. That's precisely the point I made. Even just variable names are much more important to understanding the code then types. &gt; Python can be a nightmare because you're staring at a huge mess of symbols without any types As a person with a decent experience in both of this languages, I've encountered nightmares also in both of them. Actually much less in python, since people are more-or-less forced to use descriptive names. &gt; and you have to spelunk around all over the place looking at implementations because you've got a tuple and something else expects a list. That is a C++ problem you are talking about. Since in python nothing in general would expect a list. It would expect an iterable, so it would work with majority of collections, including tuples and list or iterators. &gt; Or you have to run something in the debugger just to figure out it's passing you back a dictionary, etc. Or you can just read the name of the function or look at it's docstring to know what it returns, without haveing to know the exact type. 
Are you serious? Yes, it is hideously over-complicated.
&gt; That is a C++ problem you are talking about. No it ain't. Typing absolves you of this. You can see the damn return type right there at the call site. &gt; Since in python nothing in general would expect a list. It would expect an iterable, so it would work with majority of collections, including tuples and list or iterators. Return types. Gee, I just called a function... what the hell did it pass me back? I have no idea. I suspect it's a list, or maybe a tuple... nope, it's a dictionary. &gt; Or you can just read the name of the function or look at it's docstring to know what it returns, without haveing to know the exact type. This is just wrong. And relying on comments about code to be kept is sync with the code is just error prone. This is one of the biggest gripes about fully dynamic languages. It's not just Python. 
&gt; you've got a tuple and something else expects a list. First it gave you a problem ^ &gt; Typing absolves you of this. And then it absolved you of it. In python you don't have this problem initially. You work with meaningful abstractions. &gt;&gt;&gt; because you've got a tuple and something else expects a list. &gt;&gt; It would expect an iterable, so it would work with majority of collections, including tuples and list or iterators. &gt;Return types. Gee, I just called a function... what the hell did it pass me back? I have no idea. I suspect it's a list, or maybe a tuple... nope, it's a dictionary. Could you please reread this reply-chain? You complained about something expecting a list, I replied that nothing would, for what you reply about function return? How does 'what the hell did it pass me back?' even related to 'something expects a list'? But this showed me why you need typing. So that's a good argument I guess. Edit: A bit more polite version. 
I agree with this.
Also, half a dozen means literally 6 lines. 6 lines of code is hardly too much for anything more complex than foobar. If a task requires 6 lines of code, it's not the end of the world.
I agree with this. I actually haven't used shell for a very long time, except things like editing my .bashrc and making Makefiles etc... You can totally get away by just using python extensively and occasionally things like elisp if it is more convenient.
As a C programmer I really can't understand how people write low-level programs in Java. Not being able to organize my memory really confuses me.
For me, it's far easier than Python. If I need to write out some quick scripts, I'll user Perl over Python any day.
Yes yes, for example, reddit and YouTube are very small projects. 
&gt; the phrase only became widespread at the same time as Trump's Candidacy began to foment, In the English language since Google started indexing possibly. I remember Margaret Thatcher banging on about "Make Britain Great Again" back in the 1970s. It's probably where Trump actually got it from. And lots of South American leaders definitely said "hacer X de nuevo genial" or similar during their speeches right throughout the 60s and 70s as some countries there were amongst the richest per capita in the world in 1900, and experienced a long and horrible decline with all the consequences we saw throughout the 20th century. Despite the spin, an awful lot of Trump's image is well researched just like any President. A ton of well educated, highly paid people, did lots of research and crafted something which tested well with focus groups. It's made to look much more haphazard than it actually is because that also tests well with focus groups. If you haven't read it yet, try "The Hidden Persuaders". It's very old now, but not much has changed in sixty years. For the effects of such fakery on all of us, still can't beat Marcuse's "One Dimensional Man". But I'll stop now, this is a C++ subreddit. Either way, I support Vinnie's choice of title. Somewhat bait and switch given the talk content, but all the better if it lands bums in seats which is hard to achieve at CppCon. Whatever it takes.
This could be your six line task in conventional C: linked_list* list = create_new_list(); for(int i=0; i&lt;10; i++) { int* num = malloc(sizeof(int)); *num = i*i; append_list_node(list, (void*) num); } Needless to say it's a lot more to deal with than the other solutions. As a general rule of thumb, more lines of code mean more lower-level operations which means more trouble for you to deal with. Sure, it won't kill you if it happens once but unless you're doing a school assignment your program will probably do more than only listing some square numbers and suddenly those 6-liners start adding up. It's not unmanageable but there's definitely value in being able to write one-liners.
Yea it misses a few very small bits but important ones if you want to use range-v3 or you are a TMP wizard. For normal non-wizardy day-to-day coding it supports all C++11 features 99% of people would want. But I do hope they get to 100% soon.
This isn't really a good argument for C++ being easier and more logical than Python. :-D
Yea I don't really want to include two repos though, one for VS users and one for Linux. Apart from that I would bet that the interfaces of the MS branch and the "original" range-v3 are not 100% compatible anymore so you would be limited to the functionality that works on both, which is very painful to find out.
This doesn't work at the most important time - for code reviews, or when you're reading other people's code online.
Really? What kind of C++ code are we talking about? Have you tried reading the Boost library code or the stdlib code? I admit these are mean examples because the code is plastered with preprocessor directives and uses pretty advanced features of C++ to get the job done. My point is this. While you can write complex code in any language, C++ has so many levels of complexity and supports so many different approaches to solve a problem, and is terribly inconsistent everywhere as to not break old code or its C compatibility. Python is wonderfully consistent and easy to learn in comparison, because you only need to learn a small set of rules to master it. You need to spend many years mastering C++.
&gt; Assuming you are not paid D promoter You guessed it right, even if you review my profile you can see that I have been regularly asking C++ questions recently. One doesn't need to be paid to appreciate a programming language. &gt; This is cool, but I almost never hit this in real life. On the contrary I am creating a text editor in C++ as a hobby project, I chose C++ so I can learn the language through the project. There is a lot of text manipulation and range comprehension. &gt; Range v3 I'm excited about this. However, I'm sad that there is a possibility that C++20 won't be having UFCS, this will make the codebase very cluttered. C# has LINQ, Rust and Nim has UFCS in their language. Functional programmers love UFCS, it's just how many people think/approach a problem. 
I feel exactly the same way!
&gt; ...but this leads to undefined behavior as the values on each side of the * can be calculated in any order, so the increment could happen before OR after the multiplication. Is it still undefined in`C++17` though?
This is one of my biggest gripes with C++ and one of my biggest praises for Cargo in Rust (although its still missing a few critical features).
So, you never use `auto`? That would be interesting. Also, there are statically (and explicitly) typed languages other than C++, you might want to look at some of those to see if one of them suits you more.
Yeah, this post seems to be more about dynamic vs. static typing rather than Python vs. C++. The OP might like Java even more since you can't use auto there.
I love finding syntax errors in Python code like, 6 months after writing it.
I agree. You and I would get along well... Brennan: Did we just become best friends? Dale: Yup! Brennan: You wanna do karate in the garage? Dale: Yup! (Queue Hall &amp; Oats) *What I want, you got, but it's hard to handle...*
Yeah, there's a lot to talk about when it comes to initialization. Endless amounts of fun. I wanted to just focus on list- vs non-list-, and some new pitfalls we get in that regard in the new standard. Copy- vs direct-init merits its own story. 
Or when you can't be fucked to teach your editor where the include files are, and what preprocessor flags are currently in effect
Step1: write what you need in C++ Step2: make a mex-file for the bindings Step3: weep as you need to redo all memory allocation
Did I say that it was? :)
Maybe not, but C++ has ease advantages over Python when a project grows in complexity and needs to be refractored. I love refactoring tasks, they're quite fulfilling when you see how much better the project is when you're done, but I won't touch a major Python refactoring, doesn't matter how many unit tests the project has -- too many things will fail at runtime that a complier can find no problem. 
The correct code without the temporary uses the comma operator: generate_n(back_inserter(v), 10, [i=0]() mutable { return i++,i*i; }); Note that you're off by one but you can just start at -1 then depending on what you need.
Did you look at the examples they provide. It may generate c or c++ but that doesn’t mean it’s clean or efficient. If you provide a binary, unless it’s somehow decrypted on the fly, it will be “decompile-able”. It’s just a direct translation from assembly to c. Plus som heuristics. 
Paging /u/spongo2. It looks like we have an upgrade blocker here!
Can you share this tiny project? I'm interested in getting someone to repro your experience locally. 
Good call, the comma operator introduces a sequence point. I never use comma, so I didn't think of it. 
&gt; Two-phase name lookup drastically changes the meaning of some code What macro can I check to see if `/permissive-` and/or `/Zc:twoPhase` are active? [Last time I asked](https://www.reddit.com/r/cpp/comments/53ua8v/cppcon_2016_latest_and_greatest_for_c_developers/d7zsuzr/) I didn't get much of an answer, but given that it "drastically changes the meaning" of code, it's clearly called for... ;-]
I can't think of any change that makes it defined, but could be overlooking something. 
/u/spongo2 will give the same answer : ) And /u/STL will tell you that his STL is two-phase clean, meaning that it works the same with both old MSVC compilers and brand-new Clangs. If you need help rewriting a template, send mail : ) Sorry I don't have a better answer.