Thanks for pointing that out! Wordpress is such a piece of garbage, I'm sorry. It ate the characters somehow when we published it. It should be fixed now. I swear, we know how to write correct C++. :-)
Gotta say that as a consumer of the standard library, and the language... it really really bothers me that a function is a co-routine simply by the existence of a keyword inside the body of it. I feel very strongly that C++20 is turning into a cluster-fuck because we have 3 major underbaked features accepted into the standard already. Modules -- From the perspective of someone who writes build systems for work, it looks pretty damn useless as currently desirned, but I won't re-hash that here, it's been done to death. Co-routines -- Well, this paper talks about the problems. Concepts -- Gotta love syntax soup, a drastic increase in the complexity of the way the type system works for programmers, and a lack of full integration into the standard library (as far as I know..., maybe this has changed since the last hitpiece here in /r/cpp ?) I think the standards committee is playing with fire, and they have the potential to burn us all for a long time coming. Changes to the core language are incredibly unlikely to be undone. Get it right, or don't accept it at all. I'd rather never have co-routines than have crappy co-routines. My thoughts: 1) I don't care much about backwards compatibility, as long as it's not SILENTLY broken. If existing code that uses newly reserved keywords has a compile failure, then DO IT. Doesn't bother me at all. 'co_await' / 'co_yield' is significantly worse than needing to spend a couple weeks running find/replace on my codebase for 'await' and 'yield' 2) I've very concerned about compatibility between major changes. E.g. uniform initialization syntax and initializer lists. Like, wtf dude? I've been dealing with MSVC issues that stem from these two features interacting poorly for years now. (and GCC, and Clang, but mostly MSVC, *shrug*). What a cluster-fuck. 3) I'd rather see a small set of incremental changes to the standard that fill in small gaps of the existing standard library, (e.g. all the _v type traits in C++17. Super helpful) or clarifies minor points of confusion, with *one* big change, than a standard that pushes a bunch of big changes all at once. The confluence of all the *big* changes that are happening in C++20 are going to have major negative points of intersection that none of us understand yet. The committee is literally playing with people's livelihoods when they accept so many huge changes like what's going down for C++20. Further, that there was any significant discussion about the best way to move forward with these big features before (and after...?!?!) they were accepted into the draft is deeply troubling.
I have written tiny::bit_view, which is similar to your bit_span, but it only allows a view of disjoint bits over a contiguous storage. I use it with [foonathan/tiny](https://github.com/foonathan/tiny) to e.g. get a view on the padding bytes or other unsued bits of a type. Might be yet another use case you could consider...
I am also very concerned about this. I'd rather see none of the big named features for C++20, and only the minor changes, than see a bunch of unfixable-without-backwards-compatibility-problems features land.
Or don't get over it, and aim for an elegant language that's fluent to think in. I mean, 6 of one, half a dozen of the other, right? /s.
"Perfect is the enemy of good."
Anything other than inheritance.
&gt; Just one more stepâ€¦ however, thereâ€™s good news; you donâ€™t actually need to write the code above, because simply writing auto operator&lt;=&gt;(const IntWrapper&amp;) const = default is enough for the compiler to implicitly generate the separateâ€”and more efficientâ€”operator== for you! So even for a container where comparing `size()` would be enough to tell you if `a == b`, it will be enough to just say `operator&lt;=&gt;() =default;`?
Yes eg is similar to actor languages but different in that: 1. There are simulation cycles. Every action must go to sleep each cycle and then the scheduler will advance time. 2. When an action stops it generates an event within the cycle. Any other action may read the dimensions of the stopped action until the cycle is over. Thanks for taking an interest in eg at this early stage.
This still makes the parser pretty ugly, as you need a separate grammar for the normal function and coroutine case that are nearly identical, except that they treat return, yield, etc differently.
A starting point is to examine inner classes in C++ and the forward declaration problems. With a tree of types in C++ one can only reference previously defined types and one cannot forward declare inner types. Once this problem is solved using a closed approach instead of the open OOP approach we now have a tree where from within we can get from anywhere to anywhere. Think of the tree like a navigation mesh of stuff to locate from other places. The traversal system in eg enables doing just that with a syntax that starts out the same as C++ but can become a powerful query language. In order to implement this I have only required a constrained template shorthand mechanism and then the ability to invoke the traversal type on an eg reference. Thanks for showing an interest in eg at this early stage.
This is super confusing. Is it an executable that queries C++ programs? Is it meant to be something that programs are written in?
&gt;So even for a container where comparing `size()` would be enough to tell you if `a == b`, it will be enough to just say `operator&lt;=&gt;() =default;`? Can you give an example?
that kind sorta steams from the face that `inline` has 2 usages and no one agree what that usages. Although i don't think implementers treat implicit inline as a hint to inline. One of my motivation for P1604R1
The eg code is compiled to C++ which can then be compiled and linked like normal C++ code. Within eg actions you can write any c++ you would normally write in a function but you can also use the eg invocation system and declare dimensions.
It looks generally good, but it makes some compromises I'm unhappy with through being header-only. It's difficult to use with multiple shared libraries and the main application binary as a result. There are some workarounds for it, but aren't (IMO) sufficient to make it usable.
Of course! template&lt;typename T, size_t N&gt; class CustomArray { T arr[N]; public: size_t size() { return N; } bool operator&lt;=&gt;(const CustomArray&amp;) = default; } Will the generated `operator==` be lexicographic or will the compiler be smart enough to use `size()`? If not for custom containers, what about something like this: struct Things { int i; std::string s; bool operator&lt;=&gt;(const Things&amp;) = default; } In this case, I'm assuming `operator&lt;=&gt;` will just use `std::string::operator==`. Am I right?
 &gt; but you can also use the eg invocation system and declare dimensions. I don't know what either of these means. I really can't stress enough that for your work to not be wasted you are going to have take a giant step back and be very clear with what this is actually used for and what problem it solves. I get that it is to have some capability at runtime and that it has something to do with types, but not much else.
This kind of post is not welcome here.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c69fgy/learning_c_for_absolute_begginer/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
edX is good, it's how I started learning Python
This is the first time I've seen this paper, and after a quick read through it seems like a good idea. I wonder if this could be combined with Herb et al's work on lifetime tracking to provide full Rust-style "borrow checking"?
Space ship!!!
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c63wfu/rle_or_delta_encoding_for_networking/es7395v/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt;Iâ€™m surprised so many would want that So many people don't really understand what they're doing. I guess education on C++ is a big thing indeed.
MSVC's optimizer considers `inline` to be a very slight bonus for the decision to actually inline.
I think the question is more whether you would try to inline a constexpr method as much as you would a non constexpr inline function
Ah, I see what you mean. I had interpreted your original question to mean you were envisioning a container where size alone was enough to conclude that `a` and `b` were equal.
It doesn't really solve the problem though. It doesn't matter whether the backtick syntax exists or not, in the end - backwards-compatibility concern is the same (i.e. every now-keyword use would need to be renamed).
`std::function` would be an obvious starting point.
Pretty interesting. With that said, the paragraph &gt; Ah! The problem is that we forgot constexpr on our comparison function, drat! So one goes and adds constexpr to all of the comparison operators. A few days later someone goes and adds a is_gt helper but notices all of the comparison operators do not have an exception specification and goes through the same tedious process of adding noexcept to each of the 5 overloads. feels to me more like a symptom of the language getting bloated by too many specifiers. And Since some are now advocating for "constexpr everything" (after auto everything...), I'm starting to wonder if at this point constexpr shouldn't be the implied default behavior, with the actual keyword being notconstexpr.
Really? The only real problem with JS syntax I can immediately remember is the "optional" semi-colons and the problems it may cause. Other that that, the syntax turned out pretty nice. It's simple, easy to learn and powerful. Semantics however (i.e. type-system) is the whole matter entirely.
Let's talk about west async vs async east. Even though I'm a const east fan, I'm definitely a west async foo() { } fan in this regard.
True. It doesn't completely solve the problem but it does make significantly less painful. No need to come up with weird and funny prefixes for new operators, no complicated syntactic rules and. As a bonus, after the introduction of the syntax, your code is "backwards" compatible. Overall, the cost you will have to pay by having a more complex parser or typing larger and clunkier keywords rapidly overtakes the cost of adding a few backticks here and there if a new standard changes something. If a new keywords gets introduced that clashes with a previously valid identifier we just need to make tools that can fix that. Heck, a find-and-replace can work most of the time. Let's assume for a second that in C++17 we do have the backtick syntax. Right now, `await` is not a keyword, so having a function `void await()` is perfectly fine. In C++20, we have coroutines and await becomes a keyword. Yes, the compilation is now broken, but we can easily fix this by having a tool that can migrate our code. Once the code is migrated to `void \`await\`()` it will still work just the same with C++17, since the backtick is just a syntactic sugar for (possible) ambiguous syntax. I think we (as in the C++ community) could learn a lot from early Swift chaos. The amount of deep design changes the language went through and the (relatively) easy migration path is something we could take a page or two from their book.
Okay, just to make it clear, `size()`, when it differs between `a` and `b`, can tell you in `O(1)` time if `a` and `b` are *not* equal. I'm just trying to figure out how often can I rely on `operator&lt;=&gt;` to leverage that.
&gt;Okay, just to make it clear, `size()`, when it differs between `a` and `b`, can tell you in `O(1)` time if `a` and `b` are *not* equal. Yes, of course :)
Very late, but for anyone still interested: &gt; Using the types and functions in &lt;filesystem&gt; does not require linking with -lstdc++fs now. From release notes here: https://gcc.gnu.org/gcc-9/changes.html
Is the virtual function call in `std::function` more efficient than the virtual function call in this class? In this case it absolutely makes sense to have virtual functions you can override: that's pretty much how curl works anyway, except the C version does it without any form of type safety. And those function calls are pretty likely to want to access some data you are probably best of keeping in the inherited class in the first place.
Yea I think I remember seeing some contributors looking into having a compiled version that would be less compile-time intensive, but I guess they haven't gotten around to that yet. You aren't alone in that criticism.
You can. MSVC and Clang support it (at least partially). For Clang you need `-fcoroutines-ts` and for MSVC you need `/await`. Just a word of caution: beware with MSVC implementation. I had a lot of unexplainable bugs when using lambdas and coroutines. Things have gotten worse since 16.1. Luckily, just doing a clean build helps solve most of those issues (I have no idea why and haven't managed to reproduce any of it). The standard does very little with coroutines (you get just the basic machinery) and implementing your own constructs can be a bit daunting when first diving into them, so I recommend you to use a library to at least get to do some cool things with it. I recommend these: - CppCoro - https://github.com/lewissbaker/cppcoro - coroutine - https://github.com/luncliff/coroutine - continuable - https://github.com/Naios/continuable The first two are very similar and implement generators, tasks and channels. Naios continuable are continuations (aka tasks) that just happens to have support for coroutines.
Iâ€™m trying to think of whether thatâ€™d break old code, but Iâ€™m not sure how it could. Maybe it gets confusing to have constexpr function calling dependencies so deep. You want to call a function at compile time, then itâ€™s a major headache to figure out why you canâ€™t, since it calls on so much. Using constexpr allows you to explicitly tell the compiler that you *really do* want a statement to be constexpr, and to fail the whole compile if youâ€™ve made changes that break that behavior.
I'm not quite getting why the code will be faster than when compiled with optimization. Shouldn't the compiler do constant folding resulting in essentially the same result? In most code I can think of, most of the function parameters are not known at compile time, so constexpr will not change much with regard to performance. Am I missing something?
Padding bytes? Isn't that illegal?
Skimming over [P1185R2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r2.html), it defines a list of sub-objects comprised of base-classes and non-static data members, with arrays expanded recursively. This list is compared element-wise until the first mismatch. I don't see any special casing for arrays with known size. And of course there is no short-circuiting using an arbitrary `size()` member function, it could mean something totally different.
I'm using reinterpret casts to char and properly initializing them before reading, which should make it fine. You have to be careful about copying though, but the library handles that for you.
It's not an argument of efficiency; it's a matter of forcing an OOP design onto the user, which for me is a big turnoff.
&gt; Let's assume for a second that in C++17 we do have the backtick syntax. Right now, await is not a keyword, so having a function void await() is perfectly fine. In C++20, we have coroutines and await becomes a keyword. Yes, the compilation is now broken, but we can easily fix this by having a tool that can migrate our code. Once the code is migrated to void \await`()` it will still work just the same with C++17, since the backtick is just a syntactic sugar for (possible) ambiguous syntax. But the same argument can be made right now even without special syntax. "Special tool can be made to rename `class` to `clazz`", or whatever. It'd be even better, since it'll work on both the old and the new compilers (while backtick approach forces to either choose the most recent one or the older ones). It all becomes much more hairy when you maintain a library that has lots of users downstream. Clever tool won't help you there.
I don't have access to a computer right now so I can't really test myself, but does anyone know if defaulted operator&lt;=&gt; is supposed to compare c-style arrays as pointers? I found this to be the case in the version of VS2019 that introduced support for the spaceship operator, and was hoping it was just a bug. Please tell me it's not supposed to be that way by design?
Yeah, but you will automatically rename to what? With backticks you at least got a sane default name to rename to: just add backticks.
If they ever make a shared library, so the loggers are accessible and shareable between libraries and the application, I will switch away from Boost.Log in a heartbeat!
It really annoys me that constexpr isn't default behaviour. We should really only be using specifiers when we want to override default behaviour. The standard committee seem hell bent on having me hang 1001 different baubles on my method declarations for the sake of "self documenting code".
In CustomArray, are you asking if the compiler will automatically use your custom size() member first? I wouldn't think so, that seems like a jump of logic to just assume your size function is what it actually wants. That said, it should (based on my reading of this and the standard) do a == check on each member variable, so this.arr == other.arr, which would do a size check first, then only resort to lexicographic if that is true. That's what the section you're quoting talks about.
&gt;I don't have access to a computer right now so I can't really test myself, but does anyone know if defaulted operator&lt;=&gt; is supposed to compare c-style arrays as pointers? I found this to be the case in the version of VS2019 that introduced support for the spaceship operator, and was hoping it was just a bug. Haven't remembered to check it since then. Please tell me it's not supposed to be that way by design? That was a bug :). It was fixed in 16.2.
In your first example they will always have the same size so whats the point of comparing that? In the secong one, afaiu operator &lt;=&gt; will use the members &lt;=&gt;, but the defaulted == should use the members == so will potentially short circuit on .size()
Thank god
No, you'll need to write a `operator==` yourself. The compiler can't magically know properties about your data structure.
Well, that's the point of C++ - not the bloat, and not the too - but that you have advanced features available, but you have detailed control over when you want to pay for the overhead. Control means knobs. (and yes, I admit my case is weak with constexpr in particular, but that'd be a small wall of text still.) And, yes, at least for newer features, you *can* largely treat C++ as a high level language and use safe defaults. You can write excellent, productive C++ without ever typing `noexcept`. That's probably not excellent *library* code, but for the upper layers - c'mon. (and yes, again, this argument has a limp, because you will encounter many of these when reading other code - including declarations in API specifications.) --- FWIW, "had to modify all the functions - twice" is *not* a good argument for the spaceship. In a few years, this will be considered rookie mistakes, on the same level of not making them `const`. (oops) Spaceship rocks because it removes redundancy: in code typed, and moreover in code to review and most in pentuplicated logic.
I donâ€™t quite understand what this library is trying to solve. The language the article uses makes it sound like thereâ€™s a common problem but I donâ€™t really get it... anyone willing to help me out here?
&gt; I think I just got used to Rust's `match` keyword :P Yeah, but `match` is way too widely used as an identifier today. Codesearch for [`match`](https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=match&amp;search=Search) turns up 179,320 results, whereas [`inspect`](https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=inspect&amp;search=Search) turns up only 1,461 results. &gt; `inspect` feels somehow...sterile and surgical. Well, yeah. Because it is ðŸ˜„. Don't worry though, I assure you the committee will get their hands on it and if `inspect` survives, it'll be for a strong reason. &gt; I enjoyed the talk (online)! It was both approachable and informative. Thanks!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For `struct Things` : `operator &lt;=&gt;(...) = default` will implicitely generate an `operator ==(...) = default`, which will call `vector::operator==` (instead of bothering with `vector::&lt;==&gt; == 0`) For CustomArray: note that `rhs`' `N` will be equal to `lhs`' `N`, so the question is moot, there's no need to compare `N==N`. ... and I guess the following operator cannot be defaulted becausee it's unrelated types: template &lt;typename T2, size_t N2&gt; auto operator&lt;=&gt;(const CustomArray&lt;T2,N2&gt; &amp;) (note: your return type shouldnÃ„t be `bool` but `auto`, or - in this case - `std::strong_ordering`)
Usually no one looks at this courses from HR department
Provide more abstract/standard methods than bitwise ops for working with data at the bit level. At least that's what I'm getting out of it.
They are by definition very fast. As they trade-off correctness for performance. But in competitive programming, not all task can use greedy algorithms as the task may require the program to find the optimal answer. So I don't understand the intent of your question.
When I read your question, I think that you understood it, and my opinion is the same. Thanks for info :D
Glad to be of help
This is pretty much the "Barton-Nackman trick". It's quite useful to inject "default" behavior into a class. A prime example for this would be Boost.Operators...
&gt;It really annoys me that constexpr isn't default behaviour. Well, there's a reason even some people on the committee referred to C++ as the language that "gets the defaults wrong"...
No. The compiler can't intuit what the semantics of your type are. Defaulting a comparison operator is always member-wise invoking that operator. Let's take a look at something like vector: template &lt;typename T&gt; struct vector { T* begin; T* end; T* capacity; auto operator&lt;=&gt;(vector const&amp;) const = default; }; What this does is generate a defaulted `operator==`, which member-wise compares the pointers, and a defaulted `operator&lt;=&gt;`, which lexicographically compares them. That's not what you want. It means `vector{1, 2, 3} == vector{1, 2, 3}` returns `false`, since the two different containers are different. What you have to do is instead manually implement the two: template &lt;typename T&gt; struct vector { T* begin; T* end; T* capacity; bool operator==(vector const&amp; rhs) const { // this short-circuits on different sizes return std::equal(begin, end, rhs.begin, rhs.end); } auto operator&lt;=&gt;(vector const&amp; rhs) const { // this does not short-circuit on different sizes return std::lexicographical_compare_three_way(begin, end, rhs.begin, rhs.end); } }; The important thing is that you have to write both. `==` will never be implicitly invoked from `&lt;=&gt;` and `&lt;=&gt;` will never be implicitly invoked from `==`. They're fundamentally different operators. See [P1190](https://wg21.link/p1190) and [P1185](https://wg21.link/p1185) for more info here.
It's a bad language to learn as a beginner. To understand it properly you would need extensive study on computer architecture.
I also worked on one, here: https://github.com/lamarrr/swish
Try slack cpplang. In there, you will find many people that are learning and others that can help too. https://cpplang.now.sh Also, try https://www.cpplondonuni.com/ I haven't used this myself. I heard about them on cppcast.com.
I donâ€™t need that cert to show to the HR department
*grabs popcorn*
I had this thought about const the other day. It can be extremely annoying when debugging if you just need to mess with some property of something when const-ness is enforced, and if you've been good with your consts... well, sometimes you've got to change a whole bunch of declarations, which is super tedious It'd be great if the compiler could deduce const/constexpr, and then the const/constexpr keywords would *force* them to have that property, so that if they weren't const/constexpr then you'd get an error Obviously you can overload by const which makes it a whole lot trickier that constexpr, but it'd also make const a lot more usable in my opinion
computer architecture ? I am not familiar with it. what's a good language to learn first ? I have already invested some time in c++. Should I drop it? I said to myself that it would be a good commitment. but my self learning is at a standstill. I am very much a novice when it comes to anything related to computers.
But you can get a great deal out of it by just understanding that values live in memory addresses.
What class of a dimwit are you?.
&gt; What is c++ even used for? Writing web browsers, games, a lot of the applications on your computer, etc. Why are you learning C++ if you don't have a use for it?
 I had a reason in the beginning to make interactive projection but now I am kinda lost. I wanted to learn more about physical computing to make artwork. When it comes to prototyping hardware and software I am completely confused and drowning in paper and flashcards.
&gt; what's a good language to learn first ? Even though I learned a very rudimentary entry to C++ when I first started programming, I recommend Java. This way, you also learn about Object Oriented Programming (OOP). If you want to learn Java, I recommend this playlist: https://www.youtube.com/watch?v=r59xYe3Vyks&amp;list=PLS1QulWo1RIbfTjQvTdj8Y6yyq4R7g-Al
&gt; I wanted to learn more about physical computing to make artwork. That's one of the possible uses of things like Arduino boards. I think those are programmed in C++, but typically a simple subset of the language, and usually with fairly short programs. Since there's some of an art/maker community around those, it might be an easier way to work toward your goal.
I have yet to reach object oriented programming in the book I bought. I am working on classes
You can just `const_cast` if you want to change something whilst debugging.
Casting away the constness of something and then modifying it is UB though, right?
That's okay, you'll get there. OOP is a way of designing your program and it uses classes to achieve that goal. Here's a quick video in that playlist I sent you that helps describe it: https://youtu.be/ZHLdVRXIuC8?list=PLS1QulWo1RIbfTjQvTdj8Y6yyq4R7g-Al
And: { vector&lt;int&gt; v{3,5,7}; remove(v.begin(), v.end(), 5); for(auto i : v) cout &lt;&lt; i &lt;&lt; ", "; } returns... `3, 7, 7, `
Sure, but it's fine for debug builds in my experience. Don't do it in release or you'll find that optimisations will probably screw you over.
Java head first java and don't mind the downvotes because they are from clueless people. Once you learn java you can learn c++ easier.
In this case, quite the opposite. There's a lot of damage to be done with changes to the language that aren't "right". We'll be dealing with the decision of the committee, for better or worse, for the rest of my life. So lets save me a few decades of unnecessary trouble?
... Lombok for C++?
Auto everything was a thing? Seems absurd if that is true
If we're generating all these functions now, why not generate constexpr and nonconstexpr automatically?
Yeah, I think it should be auto generated too. It could break objects with non-const methods, though
Thank you
Yeah definitely. I do wonder if there's some way it could be done though without breaking absolutely everything. There's a lot of situations where you have one very trivial function (from a const-ness perspective) with no overloads where it'd be super handy for it to be auto generated
One of the common formats - RIFF - of which WAV, AVI, WebP and others are derived from is big endian if it starts with "RIFX" and not "RIFF".
Personally I've been bitten too many times by UB in various contexts, its such a pain when the compiler exploits it and you end up with the jankiest execution
Where are my frens?
No. Also that's west const.
Stepanov, I bow before thee.
Why isn't it `/co_await`?
Serious question -- has anyone read it cover to cover? I'm asking since that book is in the same category as TAOCP.
I was mentioning this in strictly a debugging context, where you just want to hack something to see if some state is as you expect or you want to see if an approach is correct or whatever. In a Debug build with no optimisations, the compiler shouldn't be exploiting anything and you can totally `const_cast` to try little hacky things without having to change your entire codebase.
Thank you! Just read the reviews on Amazon, on my reading list now.
Removed since this has [already been posted](https://www.reddit.com/r/cpp/comments/c6fjjg/elements_of_programming_authors_edition/).
I have, and several people I know in my office. It helps that I come from a mathematics background, as it relies heavily on those concepts but doesn't really teach them very well.
That moment when someone snipes Sean Parent's post on this particular book
What does "Authors' Edition" mean here? Is that something like a Director's Cut?
What about VSCode? Just wondering...
The compiler resolving functions that always return the same value and have no side effects at compile time shouldn't break anything. The tagging of the method is more of a contract in the API stating that "this method must be able to be evaluated at compile time". One of the consequences of having constexpr methods is that you can do things like: constexpr int GetFoo(); template &lt;int X&gt; struct Blah {}; Blah&lt;GetFoo()&gt; blah {}; If `GetFoo` isn't constexpr, this won't compile. If you were to not have it as part of the contract, in theory someone could change the definition of the function in the future and break the other parts of code, so you can't just infer "it's constexpr if it can be" and leave it at that. Also, once you declare that you intend for it to be constexpr, the compiler can help you by telling you when you make an error that would prevent it from being evaluated at compile time. If you don't have some way to mark it as a requirement, you can't have the compiler call it an error.
&gt; After ten years in print, our publisher decided against further print-ings and has reverted the rights to us. We have decided to publishEl-ements of Programmingin two forms: a free PDF and a paperback; seeelementsofprogramming.comfor details.The book is now typeset by us using LATEX, and the text includes cor-rections for all errata reported to us from previous printings (see the Ac-knowledgments). &gt; We will attempt to apply corrections promptly.We have made no changes other than these corrections, and do not expectto do so in the future.
Just reading the 1st chapter, "Foundations", is already a must.
You can very well write safe robust code in C++ without taking any tips from Rust. I'd advice by minimizing the use of C functions and features, start using smart pointers and avoid `new` and `delete`. Don't use C style casts, but instead use `static_cast`, `dynamic_cast` etc.
Look for safety critical coding standards Some are supported by static code checking tools.
There is \[cppcheck\]([http://cppcheck.sourceforge.net/](http://cppcheck.sourceforge.net/)) that can detect common errors and there will be a \`-Wlifetime\` in clang and msvc that will be able to detect lifetime issues with pointers and iterators/ranges. That can be tested in \[godbolt\]([https://godbolt.org/z/p-soKM](https://godbolt.org/z/p-soKM))
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c5zqkf/looking_for_c_online_course_that_provides_a/es8nwe1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Well obviously you have to call the vectors erase member WITH the remove algorithm. Just stating what you want like in your example is way to easy! /s (If a c++ learner is confused, read about "erase-remove idiom")
There are implementations coming for the CPP Core Guideline's Lifetime Profiles. Think "borrow checker", although someone will be along to correct me, I'm sure. https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf https://eurollvm2019.sched.com/event/MGhd/implementing-the-c-core-guidelines-lifetime-safety-profile-in-clang https://devblogs.microsoft.com/cppblog/lifetime-profile-update-in-visual-studio-2019-preview-2/
It is unfortunately not possible to get same level of safety as Rust's borrow checker provides in C++, at least not without introducing some runtime overhead, which is not desirable. The reason is that C++ does not have anything that looks like Rust's move semantics. In C++, the logical address of an object never changes. The "move" operation in C++ always only "moves" the internals of an object into another instance, so there must always be a "moved-from" state for any class that implements move-construction/-assignment. "Use-after-move" is not an error in C++, and cannot become an error with the current standard. However, you can get most of the way using various linters and static analyzers. This is usually "good enough" for most projects, but you won't get the hard guarantee that Rust provides (which is that code that does not contain any `unsafe` blocks is guaranteed to never segfault or exhibit data races). If you wanted to extend C++ compilers to include something similar to a borrow checker, _without_ changing or adding any semantics to the C++ language, your problem quickly becomes effectively uncomputable (resembling The Halting Problem). There is no good way to limit the problem space, because C++ lets you do anything with pointers. In order to actually do this effectively, you would need to extend the C++ language to allow annotating all references with lifetimes, like Rust's `&amp;'a Foo`, which would be an extremely disruptive change to the language.
MSVC implementation used just `await` initially.
Couldn't you just mark that member as mutable until you are finished debugging whatever issue you had?
Yeah, absolutely agreed
Provide standard data structures for bit manipulation that implement the usual iterator and containers interfaces, providing several benefits: any new bit container can use these bit iterators and all their power (for example if `std::bitset` gained iterator support it could use the one proposed here), and any contiguous storage can also use these iterators to gain this power. The aforementioned "powers" are: being able to use bit sequence with any algorithm using iterators, and being able to specialize an algorithm on a single bit iterator type and gaining improved speed/memory use for any container exposing that iterator. Having a single standard iterator type also to reduce the generated code when several containers and algorithms start using it. The bits views and span provide the power of container to any storage able to represent bits, which is also nice.
Avoiding `constexpr` by default is a matter of contract: if your function is accidentally `constexpr` because it just happens to be but never gave it a proper thought, and you change the implementation to use constructs not usable in a `constexpr` context, you might break user code. That's the main reason why `constexpr` isn't the default and why standard library implementers aren't allowed (anymore) to add `constexpr` to functions not marked as such in the standard.
Because co_await is an abomination which nobody likes
I don't get your point. He is checking for the systems endianess: &gt;Let's say your data stream has a little-endian-encoded 32-bit integer. Here's how to extract it (assuming unsigned bytes): &gt; i = (data[0]&lt;&lt;0) | (data[1]&lt;&lt;8) | (data[2]&lt;&lt;16) | (data[3]&lt;&lt;24); &gt;If it's big-endian, here's how to extract it: &gt; i = (data[3]&lt;&lt;0) | (data[2]&lt;&lt;8) | (data[1]&lt;&lt;16) | (data[0]&lt;&lt;24); Just because he didn't write the #ifdef doesn't me he didn't check. He's talking about swapping the bytes. You shold test for the endianess, but you shouldn't swap bytes.
Sorry for not responding sooner. I assumed my post was absurd enough to be obvious it's sarcastic.
C C++ C# and java are all C derived languages which means they share identical syntax so no you haven't wasted time learning C++.
The implementation was there before the committee decided on changing the names, so the flag was defined before that too.
After 25 years in software, there is no such thing anymore as "obviously absurd", I'm afraid.
only if the original object itself (not the reference / pointer to it) is const
a minimal ide? I currently use Xcode. Is jcreator also a minimal idea? how would you describe the use of eclipse and IntelliJ
freedom!
Take a look at core guidelines. It is a good starting point.
I wonder if the `async` proposal will be approved.
As a protest, I propose adding `co_` to all flags and specification names. `/co_std=C++co_20`
Is this API syntax something people really enjoy to use? // makes a GET request and async send it auto request = net::request_builder() .method(net::methods::get) .url("http://www.httpbin.org/get") .send(); // synchronous waits and get a response auto response = request.get(); This reads horrible in my opinion but I am an old fart who prefers simple function calls over fancy class method construct, so I am curious.
is it a compile-time conversion or a run time conversion, because that sounds like there might be a price to pay?
I write a lot of concurrent code, and feel there is no need for the additional safety that Rust would give me. If possible, I use event-loop and worker threads through for instance the C++ asio library, and in cases where I need to access resources shared across threads, Clang's Thread Safety Analysis ([https://clang.llvm.org/docs/ThreadSafetyAnalysis.html](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html)) is of great help. With respect to sequential code, the address sanitizer has been helpful locating logic errors in for instance optimised loops (not something that Rust would help with through). Additionally, I use clang-tidy and the clang static analyser.
Qt Creator 4.10 will have it bundled in the installer.
Your paper is arguing for removing automatic inlining. I strongly disagree with that, since it will have severe performance implications. I also suspect you are maybe confusing modules with DLLs. Modules are just source, they have no ABI that could break because of inlining. Inlining happens later, when the compiler turns the modules into object files. In my opinion `inline` should be removed entirely: as a hint to inline something it is already redundant as the compiler can figure it out by itself, and its ODR use should be the default even without the keyword present. In other words: we don't need it, it's just noise.
After you constexpr everything, the 'compiler' no longer produces any object files, but just interprets your program on the fly. Is the call to constexpr everything a plot by evil Python programmers to turn C++ into an interpreted language?
When the book was in print, I didn't have money to spend on it. This morning I looked again with intention of buying it but it was out of print. These news really made my day. Thank you Alexander Stepanov and Paul McJones.
He is not checking the endianness of the system, he is checking (assuming, rather) the endianness of the **data stream**; these are different things, and only the latter is relevant. The whole point is that no matter what endianness your system has, you read big-endian data streams using the latter snippet and little-endian data streams using the former -- same code on all platforms, because it is the *file* (or data stream) format that matters.
 * Compile with -ftrapv (in debug mode) or -fwrapv (in release mode) to match Rust's behaviour with regard to integer overflow (crashing or safely wrapping round respectively). Note that this might prevent some compiler optimisations where it assumes that signed overflow cannot happen -- but then again that may be a good thing. * Use a bounds-checking wrapper function for accessing elements of containers: perhaps something like (untested, off the top of my head) ``` template &lt;typename Cont, typename Idx&gt; constexpr decltype(auto) at(Cont&amp;&amp; c, Idx i) { if (i &gt;= std::size(c)) { std::terminate(); } return std::forward&lt;C&gt;(c)[i]; } ``` You could alternatively use `.at()` which throws an exception rather than hard crashing. Again, this may introduce overhead in some cases where the compiler cannot statically determine the size of the container. * There's really no way to emulate Rust's compile-time borrow checker in C++ (there is work in progress to do some lifetime tracking in compilers, but this aims to cover "common cases" rather than 100% safety as Rust does). Running your tests with sanitizers however will help you uncover many cases that the borrow checker would catch at compile time. Hope this helps.
try being a competent programmer who doesn't have to lean on redundant static analysis
I bought 2 copies of Elements and From Mathematics to Generic Programming when they came out in case it helped to keep them in print. Good job I didn't buy 3, the publishers might have withdrawn Elements but held onto the rights. XD I have the feeling that Stepanov's influence will only grow as time goes on
Would break backwards compatibility, because it's fine to not declare a function constexpr even if it could be, but not the other way round. Another problem I see is that constexpr implies internal linkage which could break some code. It might be an idea to separate constexpr from internal linkage, but I think then they would have to change the entire build pipeline, so that the part of the compiler, which chooses which functions to inline, would have to run after the linker. This would cause a lot of headache I assume.
it could be short for 'compiler option'
No point in responding to anything I post in this section. Every post of mine gets auto-downvoted to oblivion and no one will ever see your reply.
This seems to require some more detailed explanation from me, as an author of the blog post. There are several debugging engine here. VS uses vsdebugeng.dll debugging engine, which we canâ€™t use. CDB and WinGDB uses dbgeng.dll debugging engine ([https://docs.microsoft.com/ru-ru/windows-hardware/drivers/debugger/debugger-download-tools](https://docs.microsoft.com/ru-ru/windows-hardware/drivers/debugger/debugger-download-tools)). As it was mentioned in the comments already, we tried CDB and were not satisfied with how it works. So we decided to try another implementation, on LLDB engine.
Excellent and informative summary! &gt; Specialization: Rust wishes for sound specialization, and to the best of my knowledge all proposals to date ultimately fell short. As far as I know, it already works (to some degree) but is unstable and there are some open questions. We should probably make it clear what kind of specialization we are talking about in Rust. Specialization of a generic user-defined type Ã  la template&lt;class T&gt; struct vector { ... }; template&lt;&gt; struct vector&lt;bool&gt; { ... }; // ;-) will probably never going to be possible in Rust. That wouldn't play well with the rest of the language (type deduction, the ability to coerce a `&amp;MyType&lt;T&gt;` into a `&amp;MyType&lt;U&gt;` [in some circumstances](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3237facab2e2a842d40ed85299a0379f)). In Rust, "specialization" is about the ability to provide *overlapping trait implementations* where the "more specialized" is supposed to be picked. The standard library [already uses it](https://doc.rust-lang.org/src/alloc/string.rs.html#2088-2156) (the generic implementation for `T` overlaps with the other more specialized ones).
That's ok, I'm not here for riches and fame ;-)
 but inline really only has one meaning. It talks to your promise that all definitions are the same for that declaration. And then the compiler agrees not to give you ODR violation errors. Outside that, if the compiler inlines it or not is up to the compiler.
i felt this passage was very missleading in the article :-/ i thought they were showing now how to make use of the custom operator == but they show exactly the opposite. hm
That's the effect of `inline` in the wording (admire how normatively non-normative this clause is http://eel.is/c++draft/dcl.inline#2) , not the intent of it (see D&amp;E), it is really hard to separate the two because you cannot get the intent without the effect... so people in the committee seem to disagree and the use of `inline` is also not clear among users - who want both behavior at different times. In an interface or implementation module unit the effect of `inline` is moot. The symbole is tied to the module and can only be defined in one TU - because modules are TU. In this context it can only mean "please consider inlining this code", so it shouldn't try to mean anything else. I would personally prefer an `[[inline]]` attribute as this would make it clear, but i'm not sure it is the proper move from a teach-ability perspective. Said attribute is also suggested by Chandler &amp; Richard https://wg21.link/p1498r1 It is also an issues for header only libraries which cannot express "Don't mind multiple definitions, but don't try harder to perform inlining' Overloading keywords meaning leads to pain :D
It is arguing for inlining being only a hint for compilers in modules (rather that its effect on ODR) - i suggested removing it but implementers need the hint sometimes
As others have mentioned, the lifetime profile checkers are being worked on and are designed to prevent (most) use-after-free bugs somewhat akin to Rust's borrow checker. In the meantime, if you're really worried about safety, one strategy is to simply avoid using potentially unsafe C++ elements. I'll mention that the [SaferCPlusPlus](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/README.md) library (shameless plug) provides safe(r) substitutes for commonly used C++ elements. Including pointers. (Documentation and examples maybe aren't that great at the moment, but I think most elements are pretty straightforward or largely compatible with their standard (unsafe) counterparts). Unlike the lifetime profile checkers, this strategy incurs some run-time overhead, but generally [not that much](https://github.com/duneroadrunner/SaferCPlusPlus-BenchmarksGame), and you are free to de-prioritize safety in any performance critical parts of your code. One thorny safety issue is the fact that the `this` pointer is technically a raw pointer and a source of many insidious bugs. And its use is often implicit/invisible, such as when accessing data members in a member function. So in order to avoid inadvertently using the (unsafe) `this` pointer [implicitly](https://github.com/duneroadrunner/SaferCPlusPlus/blob/master/README.md#practical-limitations), you'd basically want to adopt a policy of requiring your member functions to be static, explicitly taking a (safe) `this`/"self" pointer as a parameter when necessary. This may be kind of an unconventional coding practice in C++ (and a little more verbose), but if you're willing to go there I think you might find yourself having significantly more confidence in the safety of your code. Of course, while you can use the library to make your own code safer, it doesn't make third party libraries that you use any safer. (At least not until an [auto-translator](https://github.com/duneroadrunner/SaferCPlusPlus-AutoTranslation) is completed.)
Apart from waiting for Sutter's zero-overhead deterministic exceptions, Outcome arrived in Boost 1.70.
Through much pain and anguish. Seriously though, I use conan.io package manager, which seems to be the best option nowadays.
Nope. But the first three chapters are pretty good.
I thought this was the setup for a joke... &gt; In production, what are the standard ways that devs go about this? Carefully-controlled build environments. We seriously put a lot of effort into carefully controlling which dependencies we take from the system (`libc`), which ones we pre-build a ship (Boost), and which ones get built alongside our software and linked in (`libtiff`). We actually avoid anything that automatically fetches dependencies so that we can control linking and versioning.
Recipes for big packages are still being written, and I had to write many recipes myself, but so far it's also proved to be the most manageable alternative.
What is there is really good, but incomplete. I'll continue to refer to [cppreference.com](https://cppreference.com) for my information. Have you considered using your time and skill to contribute to that site? There are lots of pages which need pragmatic examples of use adding to them.
The problem with that is that due to the history of fractured and unstandardized ecosystem every single package is its own snowflake. Also there quite a lot of companies with their own library stacks. So in the end, the most crucial part for the package/dependency manager is an ability to plug-n-play to custom projects, which is hard due to the previous point. Hard to win without rewriting literally everything! Hope one day we get a dependency specification to kinda unify the way build systems connect different libraries.
C++ package management is a pain. The best way is an abominable hybrid between CMake find_package calls and using Conan's cmake_paths generator. This handles system packages + user-supplied dependencies.
Totally agreed, and Conan is actually decent at handling the zoo of meta-make programs themselves handling the zoo of make alternatives that are made to handle all those pesky compilers and there options. I would say that conan-community and bincrafters do provide some real added value, but the next step would be for library maintainers to start adding conanfiles to their own repositories that are maintained along with the libraries.
Generally as git submodules or just installing the libraries on my system and having Clarke find them
Exactly, every project has its own way of being built, so adding dependencies in C++ is a pain. But the benefit of something like Conan is that the effort you would normally put into manually adding a dependency to your project you can instead use to make a Conan package, and then the problem is solved not just for your project but for any project that can consume Conan packages. I do hope for a day where there is a more standardized first-class build and dependency system in C++. Hopefully modules in C++20 is the first step in that direction.
I rely on autoconf. Whatever you think of it, it always works for me on unix-ish systems (well, GNUish systems anyway...)
Attributes have the problem of being optional. So an [[inline]] attribute might be a good start. Then something to replace the multiple definitions that replaces inline, but I don't think it will be allowed to be an attribute. inline is like vector&lt;bool&gt; not what we expect, good function, bad name.
you don't need the ODR definition of `inline` in modules at all
I have the specific versions of the dependencies in the source tree and I generally compile them. How I go about guaranteeing the "correct" versions depends on many factors which vary from one project to the next. If I were to write only for one fixed platform it would be easier as they have have canonic ways of doing things. When you mix up different ways of doing things, compiling from source universally works across the board. I dislike commercial "headers + libraries"-only APIs, unless they come from the platform like DirectX, OpenGL and so on. I mean, if there is some library to, say, load some file format, I'd rather compile it myself in the build scripts / project / solution files. Platform specific libraries like DirectX mentioned above can be library-only and don't care about that as it will be platform specific implementation, obviously. Stuff that should work on all platforms we go to, should come with source code, or we don't have maneuvering room when doing porting to customer-specific platforms. Programming is the easy part, the stuff that feels most liike work is build systems, test environments, validation and documentation. :)
Yocto, but we only target embedded Linux systems
Hello Reddit. I started writing a blog some time ago, and I would like to get some feedback. In any cases, I hope that you will enjoy the content. I aim to write mostly about C++ topics, and otherwise it will be programming-related (like tooling). I tried to search the rules of this subreddit to see if self-promotion was allowed, but I didn't found it (on the side bar, their is only Â« 1. Question/Help 2. Off-topic Â» without more details).
So modules would stop me from having two methods in different modules with the same name? Or would they now have a diff name even though the namespace and id are the same
&gt;One thorny safety issue is the fact that the &gt; &gt;this &gt; &gt; pointer is technically a raw pointer and a source of many insidious bugs. What? I don't think I've ever had a bug regarding 'this'
It could be the opposite. You could have a \`runtime\` keyword that allow more things (just like \`virtual\` allows to have a different behavior). &amp;#x200B; When you create a function/class/â€¦ you have to think of the customization points (by using const pointer/references instead of a value for input parameters, and by adding \`virtual\` on method). In my opinion it could be the same for the compile time/runtime contract of the function.
You cannot have 2 **exported** method with the same name
Just a note that with maven you do typically specify the version, e.g., ``` &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; ```
The proposed C++ lifetime checker uses similar elision rules like the Rust compiler. In cases the checker would make the wrong assumptions, you can be more explicit using annotations (attributes for functions and function parameters). But they are only annotations and not part of the type system. I expect these annotations to be easily lost through indirections like function pointers, templates, etc. And I don't think it's viable to introduce lifetimes into the type system this late in the game. For these reasons, I don't expect C++ to ever come close to Rust's safety guarantees.
meson, or nuget for c++, or I just have a folder with a bunch of source that I build and keep on a share for future use
That makes sense to me. The erase/remove idiom always seemed like an odd necessity to me, but I also don't see a situation where calling remove without using its value is particularly useful. I'm not in LEWG, but I'd probably vote in favor of such a paper.
Couldnâ€™t agree more. Well stated Also: I would like to add, one of the problems why the C++ sector struggles with this is the high number of options and settings, â€˜waysâ€™ stuff can be built. In java, a jar is pretty much a jar. In C++, the same lib may be built in many different shapes or forms. Which is why controlling and knowing these forms is important and to make sure everything you use is built to match. Otherwise you may end up with the weirdest and most unexpected bugs at compile or runtime. On Windows: check out vcpgk or conan or build everything yourself but know exactly why and how. And with what. On Linux: if you are on a stable binary distribution and happen to find all you need available for your distro, just roll with that. Discover stuff with Cmake. If not and you need your own builds, make sure you build them in a way that matches your distro. You will almost certainly end up mixing in system libs (libc, ssl, etc)
I agree absolutely about Conan being a very good candidate. But even then, Conan faces the same problem. It's very hard to glue projects with different build systems! The way now is to duplicate everything into Conan-specific format to pass around, but that just doesn't scale (in a sense that it's much more optimal to let build systems generate glue files since they know about everything the project needs!). While one can say that describing the project in a Conan recipe is a necessary thing to provide a proper integration - I still think that Conan community should strive for a better bootstrapping experience by parsing common projects' layouts (e.g. projects based on the pitchfork, single header, include folder). By making integration easier it reduces the inevitable mental overhead of "getting" the Conan model from the start. Especially considering that the project is young and there are not so many proficient with it people.
```#include &lt;itsy/bitsy.hpp&gt; ```
Modules \_are\_ not about build and dependency systems. Period. But they do solve some questions of ODR bombs due to a different mangling depending on the module symbol exported from (correct me if I'm mistaken here). With headers it's very hard to save yourself from ODR violations when you achieve a very complex DAG. Also, standardized first-class build and dependency systems in C++ is a myth. Too many projects in a myriad of different build systems. We already have quite a few different dependency systems. What we should do is to seek an ability to glue that all together. Easier to fix one build system than thousands of projects written for it.
A Vagrant script for a Linux VM with all the package dependencies and external repos explicitly handled in a few lines is nice when appropriate. apt-get install all the pre-packaged dependencies git pull thingy1 /vagrant/ git pull thingy2 /vagrant/ build_stuff.sh
Its so painful in c++ that most devs i know rather reinvent any given functionality than import it from somewhere. I guess you could say c++ has built-in NIH support.
We have a bunch of C and C++ dependencies, although they're mostly consumed by developers in other languages. We either dynamically pull in the source or vendor it, and build it all in one system. That takes a little work to set up but we know it keeps working and we don't need to wrangle a big set of tools.
How does autoconf manage dependencies though? I can understand using it to build make files, but how do you use autoconf to download and install Qt, boost, catch2, zlib, etc...?
Badly
Right. I'm not sure why I said "many". Maybe I was thinking that `this` pointer bugs can manifest in multiple/many ways or something. I've actually looked at a lot of CVEs for C++ code and I was a little surprised that the vast majority were just "ordinary C" type bugs. Even the use-after-free ones.
You can use this API without function chaining if you wish without any problems :)
Coming to C++ from Java, package management was the most painful part of the experience. Obviously the language is vastly more complex, there's memory management and overall a lot less hand holding, but all these things, once overcome, translate to great advantages C++ has over Java. It's rewarding to deal with those. Dependency management, OTOH, offers very little in return for the amount of anguish it brings. I mean, it can be a lot of work to get some things to work together, going in with a mindset that it's just another part of the coding task makes it bearable, while even starting to hope that adding a library to the project will be as simple as pointing the build system the right way often leads to sadness. Conan and CMake make this less unpleasant, but in my experience even a small project with a bunch of dependencies required a non-trivial amount of hand written glue to build, and all of that custom stuff tends to rot pretty fast, every time I take a few months break I dread having to go through the process of updating the packages and fixing the build scripts.
cppreference.com is my go to. I didn't know you could contribute to it though.
Basically, we don't have good solutions so we do with what we have for now. We are in a time of research for dependency management solutions that work for C++ and it's definitely hard. So you will see people recommand Conan (the most vocally popular), vcpkg (the one with the most packages) and some other similar tools, but there is no solution that works for everyone yet. On my side I've been exploring what it would look like if I had such a tool in my real big projects (involving a lot of complexity and organization) and these days I'm mostly focusing on Build2 (https://build2.org). It looks promising and in particular gives a good idea of "tools from the future". It lacks having more packages at the moment and might lack some utility features but it's interesting nonetheless, though maybe not a drop in replacement for your projects, like Conan could be. Also it does far more than package management. In some projects I use the copy-paste-in-a-dependency-repository technique because until recently most solutions were not working for me. At work we use a custom dependency system which I consider broken by design and cause a lot of headache. So I'm actively looking at solutions too.
Try an analyzer that implements the lifetime profile of the core guidelines (I think clang-tidy does). It won't give you the same level of safety, but probably close enough.
Can you point to any? Most "safety-critical" coding standards I've seen are little more than style guides. Don't use X, put Y on a separate line.
Step 1: Buy a lot of vodka Step 2: Drink it Step 3: Hope that the build is OK
pkg-config may still be used here, it's a took which is asked: what do I need to pass to the compiler to use $lib, what do I need to pass to the linker, etc. Quite simple, and handles cross dependencies poorly nowadays...
By writing Rust code in my spare time. Writing Rust helps me hone my "spidey sense", as I the borrow-checker regularly catches lifetime issues. With experience, you start recognizing these patterns by yourself when writing Rust code, and to stay ahead of the borrow-checker. And this translates very well to writing C++ code! Furthermore, there were previously instances where my "spidey sense" was tingling, but I could not find any fault with my C++ code. It left me uneasy, and sometimes I would pre-emptively rewrite a piece of code just in case. Nowadays, if I doubt whether a piece of code is right or not, I simply ask myself: "What would the borrow-checker say?" and just (manually) applies its algorithm. Either I catch a bug (yeah!) or I convince myself that the code is working. In either case, it's a win. TL;DR: To become a better C++ programmer, write some Rust.
In that sense, the approach of the Modern CMake native targets + Conan is very convenient. CMake generates targets with all information the project needs from inside the build system and Conan picks and passes them to consumers in a straightforward manner. The only block is to not overspecify the build environment in the project's CMake files. That way you have a very clean Conan recipe and CMake files.
Yeah, it should. And compiler warnings can suggest using std::erase.
I've used vcpkg once. Seemed fine but damn, package / library management in C++ is _awful_. I'm hoping the new module standard will make things easier to package up and we can _finally_ get something better.
It doesn't download and install them. If they are there, it (maybe) checks for a sufficiently recent version and works out how to link them in, and if they are not there it simply reports the fact for the system maintainer to deal with however they see fit; for example, if they decide a library does not belong in the system, it can be installed in user space and autoconf flags (or elsewise) can be used to locate them. It is my preference that package managers don't try to do this themselves. YMMV.
Well technically speaking, there's always a price to pay while casting something unless you're working only with static and constant types values. When the data is static there are ways for the compiler to inline and execute the code at compile time just like a normal compiler would be able to convert `2 + 2` to `4` at compile time. In the case of cast, it's not necessarily more complicated if all arguments and output are not depending on something dynamic. In the case of Rust, I can't tell if it can do it right now but it will certainly be able to do it some day if not already. In the case values that may change at runtime, then either way, you're not able to inline data that you don't already know. But the function for conversion is found at compile time and there is not dynamic lookup for the conversion as far as I can tell. If the trait can't be inferred at compile time, the program will not compile. For example, taking the example here: [https://www.reddit.com/r/cpp/comments/c5bnme/what\_are\_the\_advantages\_of\_c\_over\_rust/es2vr9b/](https://www.reddit.com/r/cpp/comments/c5bnme/what_are_the_advantages_of_c_over_rust/es2vr9b/) &amp;#x200B; You can write a method that hide the `into()` call in the method definition. The nice thing about this is that you can specifiy a method that take `i32` parameters. But Rust will be able to infer the proper cast at runtime. It's doing pretty much what I wrote in my example for you. &amp;#x200B; so if you do `vec(1,2,3)` or `vec(1.2, 2, 3.4)` or `vec("1", "2", "3")` it would all convert the 3 params to `vec(1.into(),2.into(),3.into())` or `vec((1.2).into(), 2.into(), (3.4).into())` or `vec("1".into(), "2".into(), "3".into())` then if the compiler is smart enough you'd end up with `vec(1,2,3)` or `vec(1, 2, 3)` or `vec(1, 2, 3)` as all of the cases above can be inlined in practice. The really cool thing about this is that while your method always receives i32. You can call it as if it would receive any kind of type that can be converted to i32 without worrying about casting yourself the types. So it may make rust look like a dynamically typed language by implicitely casting things for you. But the cost would still be at compile time in practice. And runtime for executing cast that can't be inlined.
I'm universally disappointed with just about everything logging. Everyone does it wrong. &amp;#x200B; I wouldn't recommend writing to a file, that makes... well, \*every\* presumption about what resources you have available and permissions for, which you shouldn't, because you don't actually have any such authority or control, and you shouldn't impose such requirements on your users. How about log rotation, archiving, and file and disk quota, are you going to assume authority over that, too? That's not your decision to make! That's up to the group policies, of which your application is subject to! &amp;#x200B; Instead, you already have an open file descriptor, which is always there, that is intended to be your log target: standard error, aka FD 2. Every process on both Windows and Linux get standard in, standard out, and standard error. Write your logging to standard error. All you need to do is push strings onto a queue and drain that queue into standard error on a thread. Beyond that boundary, you have no right to assume anything, and it's literally not your problem at the application level. The user is then responsible to redirect that stream through any number of filters and other tools to parse, react, and archive the logs as they are generated - and it's perfectly OK if your installer sets that up for them, too; what I'm advocating here is separation of concerns between what is your program and what isn't. We have the tools and whole pipelines to handle this already, don't reinvent the wheel. &amp;#x200B; Also, log levels are stupid. Tags are good. You can do a whole lot more with tags than levels. If you want a specific log, you may have to enable whole levels just to get it, which is that much more noise and not what you want, and if you want to cut down on noise, you may miss out on that one log you'd be interested in. Levels don't tell you anything, either. What's the difference between a warning and an error? I'll tell you - the difference is a prayer that your colleagues follow convention and level their logs intelligently and appropriately, which they're not going to do, because there will be logs whose level you don't agree on. And log everything all the time, you can filter out what you're not interested in, and again, quotas are a concern above the application's level. &amp;#x200B; But you're already built on writing files with log4j, so you're going to follow suit and use some other logging API. Unless you can specify a file descriptor so you can use the API as a convenient interface you're already stuck with, you're kind of screwed, doomed to log directly to file like everyone else has done wrong before.
It is a wiki and you can contribute, but you will need to go through a couple of hoops as the site gets vandalised otherwise. You will see the instructions when you try to edit a page. Don't forget that the whole thing, like the C++ ISO commitee, is a volunteer effort.
Good point! Can you think of other language features that C++ has and Rust is sorely lacking?
I agree with this. Relying on your build system to download and install packages is a recipe for disaster.
From years of experience in several large companies: they don't, mostly.
The main page sure is pretty.
Yeah, thatâ€™s why I said â€œfirst stepâ€. Modules definitely arenâ€™t a package/dependency system in and of themselves, but I suspect it might lead to more sane and consistent ways of using external code in general, which might eventually lead to innovations in dependency management. Also, I think it might encourage fewer gigantic monorepos, which I think are a biproduct of the poor build/dependency ecosystem in C++. Fewer monorepos and more individual libraries will hopefully eventually drive better package systems. Package systems will be easier to create when modules are commonplace.
Why is that? That's exactly how my build system works and I've never had a single issue with it. What should I be concerned about?
It seems like there are standard and non-standard attributes for marking functions like this, but are there compiler options to warn on **every** unused return value?
I read *somewhere* that C++20 (possibly with ranges?) will fix the issue of erase/remove. Could be wrong though.
It's a huge headache for anyone who uses your package downstream. People may not, or even require that they not use exactly the same dependency as you for a huge variety of reasons.
Yes. I read it before it was released - \*and\* did the exercises. (I worked at Adobe (Stepanov was there when writing the book) and they wanted people to look for errors, etc.) &amp;#x200B; I was a lot of work just to get my name in the Acknowledgements, but so so worth it :-)
If you use cmake for your project, for source references, you can use [vcpkg](https://github.com/Microsoft/vcpkg) For binary references, I use nuget, a private nuget server, and custom cmake scripts that call nuget.
And it is worth it just for chapter one even - a concise description of what is an object, what is a value, etc.
And indeed it is in MSVC's STL. Enjoy!
Yep, std::erase_if() and std::erase() were recently accepted into C++20. (Ironically, haven't implemented them in MSVC yet because we've been busy with other things, although the std::experimental versions are available.)
&gt; the next step would be for library maintainers to start adding conanfiles to their own repositories that are maintained along with the libraries. Don't package your library, write packageable libraries! 90% Of the open source libraries out there could/can easily be packaged without any special logic if they would stick to using simple cmake files (at least in addition to what they use for development) and stopped trying to reimplemented their own dependency management system as part of their cmake file.
Lots of functions have ignorable return values - most famously printf(), but also many Standard algorithms (e.g. copy()). I'm not aware of any compiler options in Clang, GCC, or MSVC to warn about all discarded return values.
I read your post on getting rid of comments with some alarm. The method seems to involve using layers of indirection and factoring to move the words of the comments into the names of classes and variables, but I doubt that this is the right approach in most cases; however your remark about the code eventually growing into something more unmanageable is valid, and your approach to re-factoring is a good methodology to take code forwards in that case.
As a newcomer a few weeks ago I finally settled on vcpkg to fetch libraries and its two-line cmake integrations to link into my builds. I'm using Visual Studio on Windows and its cmake "open folder" support.
That seems like an exception rather than the rule. If you need specific or specialized behavior then of course you should take steps to modify the build to suit your needs. But for 99% of people who want to get going, I don't see an issue with having the build system ensure the availability and integrity of all dependencies. At my company, as a matter of policy, we require that every project, whether it's a library or an application, can be built in one step by typing in ./configure.sh &amp;&amp; ./build.sh
Thank you!
Wouldn't the name `erase_many` be more appropriate? To underline that it erases *all* elements matching the query.
How is advocating constexpr everything?
Depends on what industry you work in. I do scientific work, users would riot if you shipped your own acceleration libraries that weren't optimized for their platform. Platform specific optimizations is a big reason not to auto-download. I'm not saying you can't provide the option to download dependencies. But it shouldn't be impossible to override without forking.
If you use visual studio, I find vcpkg to be pretty painless for most needs.
There are certainly valid uses of std::remove that are not just the remove-erase idiom. I've called it multiple times prior to doing one final erase, or written new elements in the range of [remove(), container.end()). That said, I think I agree it'd be rare when you wouldn't want to look at the return value. All I can think of is a case where you know ahead of time that there are N copies of the element you're removing, so you don't need remove()'s result.
Completely agree that the abundance of options is a main Problem.
Typically by including them into the source tree (via submodules/external locatotion or just directly to the source tree, some folder called vendors/ or external/ etc, then using one (or a set of) well defined toolchains to build all dependencies and own projects. External dependencies upgrade rearely and with a pain.The amount of external dependencies is minimized usually though. Its both bad (the pain to upgrade), and good - we dont have a JavaScript npm mess.
In my experience, by minimizing dependencies as much as is practical. For any dependencies we *do* take, we take them as source deps, building them ourselves to ensure repeatable artifacts with exactly the config we want. The source is usually checked in to project deps repos in parallel with the main project repos. Occasionally, if the deps are few and small enough, their source is instead checked into a subdir within the project repo. If a separate project deps repo is used, the actual libs &amp; user headers are usually then checked in to the project repo (so devs don't always need to build both -- only those pulling in a new version of an upstream dep). Not ideal, but works with any build system, allows max control of the deps (including maintaining a fork of a dep, in the *very* rare case that it is necessary), and isn't *too* big a PITA. Still, Maven &amp; Gradle are way less of a pain, IMHO, and Rust's Cargo is getting to be pretty sweet as well (now that it supports private registries).
CMake + Git Submodules have been pretty effective if you donâ€™t mind building from source. The caveat is that you obviously have to configure the build for every platform. For instanceâ€”CURL is a pain to build on Windows; Linux and macOS are fairly painless.
I work on HFT, and it's a requirement that every single build be exactly reproducible in the exact same manner and that every aspect of the build and deployment process be automated from scratch. We literally require our build process to take a fresh and barebones install of Linux and have our configure and build scripts do all the work needed to download g++, cmake, git, so on so forth. If someone wishes to use their own version of a dependency, for example a newer version of a library, or a different version of GCC, then they have their project override the original dependency instead of forking the project and modifying the original project.
`std::remove(first, last, value)` removes (in its weird way) all elements equal to the `value`. Ditto `std::remove_copy(first, last, result, value)`. `std::count(first, last, value)` counts all elements equal to the `value`. `std::replace(first, last, old_value, new_value)` replaces all elements equal to `old_value`. Ditto `std::replace_copy(first, last, result, old_value, new_value)`. Of the value-taking algorithms with `_if` counterparts, only `std::find()/std::find_if()` stop at the first element.
The best way is using gits. Simply clone them into your project as submodules and update them regularly
Why aboninable? I feel this is a pretty good way to go about things nowadays.
&gt; The erase/remove idiom always seemed like an odd necessity to me The trouble is that STL containers are pretty stripped down, so the intuitive way of removing a lot of elements, "going through a list and removing each element as you come to it", is going to involve a lot of shuffling of elements. The swap/pop idiom lets you remove one item from an unsorted list in O(1) time, and erase/remove is just a lot of swap/pops.
I just started using vcpkg. After a bit of setup troubles (corporate AV blocks JOM download) I eventually got it working and honesty it works pretty great so far (windows). Still need to integrate it into my Ubuntu machine
You still need someone to write &amp; maintain the recipes to package them and to make them easily available somewhere if you expect them to be used though. The ability to use many libraries from a central repository out-of-the-box helps both with adoption and with ensuring that the recipes work, even when they're simple enough.
I feel like you can do this because you've settled on one platform. With the stuff I work on we have to support mac/win/linux/arm. Library dependencies have to be built with different options depending on platform. If binary Intel or NVidia libraries are present we want to use them, but they may not be available. Do we want to have all this in our build script? Hell no, it's not our responsibility. The end-user expects to be able to use their libraries when building easily. Does that mean we don't want to make it easy to build our library? Of course we do! So we provide a Conanfile (basically a dependency listing) that you can give to Conan that will set everything up. But the point is, it is completely separate from our CMakelists.txt. We don't download anything in our CMake configuration step.
I found Cmake's "ExternalProject" plugin to be extremely useful. You can check if a package is installed and, if not, have it checkout the library you need at a specific branch and build into your project. It really helps when you need to specify a version or avoid breaking API changes from the third-party project. Yes it can increase build times, but having the ability to switch between an installed library or self-provided one can help.
That is the approach taken by linting tools such as PCLint. Because of so many functions have ignorable return values as pointed out by STL this approach is totally wrong. Several automotive companies take it further and maintain a whitelist of functions which are allowed to have ignorable return values and these lists are usually maintained by local architects. This works even worse in practice as it makes programmers wonder why some calls generate linting errors and others don't. C++ standard \[\[nodiscard\]\] is fortunately done right and it takes ignorable return value as the default, non-ignorable must be annotated. People who didn't experience PCLint pain will never understand but I can tell you you are damn lucky.
Almost no tutorials on the internet discuss this method. It's not even the recommended way to use Conan in the Conan documentation, which instead forces you to include it intrusively in the CMakefile with the `cmake` generator. Now you need to know two languages (cmake + Python) to build a third (c++). That's why it's abominable, and we all have Stockholm Syndrome.
But `std::remove` doesn't really work that way, right? It has to preserve the relative order of elements.
I freely admit to only being an intermediate level developer, so am lacking a great deal of knowledge, but what I have read about modules suggests that they are inherently linked to the build system because _how could they not be_? They define the useful surface of a build artefact after all. The articles I have read strongly suggest that the insistence of the C++ committee to consider modules in isolation to build systems was a mistake, and that there are some big risks that might slow or prevent the widespread adoption of modules. I remember watching a conference talk a year ago where someone demonstrated a vastly increased build speed with modules, but now there are articles pointing out situations where modules will be vastly slower than traditional builds because the build system doesnâ€™t know where to find symbols. Only time will tell whoâ€™s right at this point. Iâ€™m praying the naysayers are wrong, but Iâ€™m not overly hopeful now.
The presenter talks about C++20 but uses an older syntax or syntax which was never voted into standard. I am talking about concepts defined as functions and concept introduction syntax. It brings the usefulness of the presentation down a bit.
First the reflection proposal needs to come through.
The big thing about vcpkg over conan is that there is a single version of every package, so you don't have to decide which one is the right one. They are also crazy fast with PRs fixing portfiles. I love it.
Imagine what this would do to std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; z; I don't know of any reason to capture the return value except as the LHS of another call to &lt;&lt;. There always has to be a last one, so I guess you'd start doing something like auto x = std::cout &lt;&lt; "Why?";
I spent two decades building all those underlying things into a single, coherent system, so there aren't any external dependencies. Kind of radical; but, now that I'm there, it makes C++ into a whole different animal. * OK, technically there are two small ones, but that's well less than 1 percent of the code.
&gt; Shouldn't the compiler do constant folding resulting in essentially the same result? That's not true for relatively complex expressions (not to mention that it is not really guaranteed either).
We support virtually every platform under the sun, including literally SunOS/Solaris. The different types of hardware you need to integrate all together to run an incredibly efficient large scale trading system is just insane. Do we want our build script to handle all this? Hell yes. Every aspect of our build process must be automated and must not require a human to potentially make a costly mistake. I will respect that you have your own way of doing things and certainly you should do what works best for your team. At no point did I suggest you were doing something wrong with your build system, rather it was the suggestion that having a completely automated build process that automatically downloads every dependency, does every bit of configuration, and ensures every build is identical was a huge headache and inviting a disaster. I was hoping to get some insight into what that disaster or headache would be. I was not suggesting that doing something different from how I do things is sub-optimal because frankly it's a big world and people have different requirements.
Oh, sorry for that one, I've failed to properly translate my idea here. Yes, obviously proper modules are impossible without build systems support. Because it's a different model. And yes, I parroted the committee stance on the modules here. And that's the point. The point is that the goal of the modules is not to bring the proper build system artefacts (or any artefacts). It's to drive the language design. Tooling concerns were indeed embarrassingly last minute. My point was to not mistake modules with a step to the ecosystem direction because they are not, they are another language feature. They are not standardized libraries. It's not that the modules are bad, it's just that it somehow feels that many people are confused about what they are and "overhype" them. The point about build speed. One should keep in mind that some build speed gains in \_some\_ situations are a lucky coincidence. It all depends on the implementation, \_but\_ modules is not a magic wand. On a clean build, nothing can be faster than a unity build. But incremental builds should be faster in the general case. But a heavily templated code would probably not feel such gains. But it's all uncertain surely. Again, implementation.
I use [cget](https://cget.readthedocs.io/en/latest/) which builds most libraries out-of-the-box, so you can just point it to source tarball, and you don't need any recipes.
&gt; The problem with that is that due to the history of fractured and unstandardized ecosystem every single package is its own snowflake. I disagree. The majority of open-source libraries support a standard build and install workflow. Package managers like cget builds on top of this so it can install a package by just pointing to its source tarball, and there is no need to write recipes or rewrite everything.
I just use system packages for all my depends
Short answer, no. You can catch many errors using tools like static analyzers (like clang-tidy), or sanitizers like ASan or UBsan, and as far as I know that's the current best practice for writing safe C++ code. Still, even using the most modern C++ style it's easy to write unsafe code.
&gt; The ability to use many libraries from a central repository out-of-the-box helps both with adoption and with ensuring that the recipes work, even when they're simple enough. There shouldn't be a need for a central repository for all packages. You should be able to point it directly to the URL of the source tarball. &gt; Also I dare say that having to package them forces you to write things inherently more packageable. Having your package part of distros forces you to write it more packageable as you have to support multiple packaging systems. Supporting a single package manager usually does not lead to a library being more packageable. I have seen some libraries put the installation or usage requirements in the package manager's recipe instead of in the build script where they belong.
Ah, true, true.
I've seen several such bugs with callbacks. If you make a lambda that captures the this pointer (possibly by accessing a member variable), and it can be called after the lifetime of the object, then you have a use-after-free bug. It's only an issue because 'this' is a raw pointer, so capturing it will just take the pointer value.
The lifetime checker has the goal of catching a few common errors, but it's not intended to guarantee that the code is actually safe like the borrow checker does.
It actually it would be much simpler if we had the transparent return operator `=&gt;`(from [P0573](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0573r2.html)). And then you could just write `auto operator==(const IntWrapper&amp; rhs) const =&gt; value == rhs.value;` and then the compiler can deduce `constexpr`, `noexcept` and whatever new specifications that might exist in the future.
Bourbon
Generally horribly. So horribly that I've seen the advent of "header only" libraries. Giant groups of header files are l set up so that you just have to at them to your include path.
I use git submodules.
I think it's intended to be a start down a very rocky road. The borrow checker itself really only started to become ergonomic with the non lexical lifetimes. It's a really fantastic thing though. C++ isn't going away, so efforts like the cpp core guidelines, GSL, and the lifetime profiles can only be a good thing!
Oooh, if you do tiny::bit\_view and combine it with bit\_view, you can per-bit movement shifts at compile-time, combined with the constexpr iterators... Also, I love the library!
What's the "standard build and install" workflow? CMake, while being a pretty popular one, is not the only build system. [https://www.jetbrains.com/lp/devecosystem-2019/cpp/](https://www.jetbrains.com/lp/devecosystem-2019/cpp/) Even among themselves, CMake projects are not unified because of the Modern and Not separation and not all people even know or use that stuff. People (and businesses) still do use other build systems and while it's a major pita to bind everything together, it's simply impossible to force people to use any concrete build system because of the mass of projects already written. Autotools, [a-z]make, different "build"s, b2, etc. Even then people want to explore in this field, see Meson and such. My stance is that forcing people after the fact will not solve anything (Even assuming that it's even possible since C++ is not only about open source). The way is to solve the issue with minimal casualties - specification of intermediate formats.
I was re-reading it a few months ago and I came across your name in the acknowledgements. I had a "holy crap I know that guy" moment.
OP can also consider vcpkg which works too well with CMake and VSCode/VS
Feel like i had a stroke reading that
Iâ€™m glad I wasnâ€™t the only one
In a *huge* cross-platform C++ program, we'd pick a library version, compile it for all of our platforms, and check in the compiled libraries, source archives, the exact commands used to compile the libraries for each platform, diffs necessary for some of the odder Unix varieties, and headers into the repo (started on CVS, migrated to Perforce, and at least partially migrated to Git over the years). We used to be less careful, but eventually needed to prove that we hadn't modified+redistributed open-source code, and that we were abiding by all the software licenses (lawsuits were filed). The company's legal office basically had to be aware of each version of each library that we were using, hashes of the source archives, where we got them, etc. Basically, if it wasn't in *our* local repository, and approved by legal, we couldn't use it.
What if this version is no longer available online?
We write our own minimalistic implementations if required functionality! Why use a dependency? /s
I pull it out in LEWG whenever I want to convince people I'm right - "you know we are all just the stewards of Stepanov's work, and I have EoP right here and let me just quote ... oh my name's in it, huh, never noticed that, anyhow... I just wanted to say ..." (because why use actual technical arguments when appeal to authority can work)
The problem is that `find_if` is used more than the rest put together.
Children are typically covered under your employer's insurance policy, but unfortunately you still need to feed and raise them yourself.
I regret to inform you that `lock_guard` exists and is useful
Addendum: but they are still easier than dealing with C++ dependencies.
For native builds use docker and pull in the dependencies in the Dockerfile, then deploy with docker and a cut down version of the same Dockerfile. For embedded builds use Yocto.
warning: variable 'x' set but not used
I guess Gcc thinks other things are higher priority.
That's obviously a `stable_partition` Well, only half stable but the Sean Parent joke still stands
I don't disagree with this sentiment in principle but according to Daveed Vandevoorde implicit constexpr is ["really not a good idea"](https://youtu.be/m9tcmTjGeho?t=4568). I don't know everything he had in mind -- IMO the compile time argument is enough to say it's "not a good idea", and something like Morwenn's answer above certainly pushes it in the direction of "_really_ not a good idea".
What is the rss?
oh now I understand, thanks for the clarification
1) System devel packages for big open source things. 2) For dependancies against my own code I use the cmake FetchContent feature to pull dependant github repos and build them just before I need them.
&gt; We urge you to go out and try the spaceship operator, itâ€™s available right now in Visual Studio 2019 under /std:c++latest! I'm on VS Community 2019 ver. 16.2.0 Preview 3.0, compiling with /std:c++latest, and it can't open `&lt;compare&gt;` and doesn't recognize `&lt;=&gt;` as a token (`unexpected token after data member '&lt;='`) when I try to compile the examples. Anyone know if I'm on the wrong version or need to do something else to enable the spaceship operator?
MISRA is one of the most populars. FlexLint supports it: https://www.gimpel.com Most of such standards indeed forbid using some language feature under some rational, and frequently include exceptions for some use cases. Some ideas are pretty simple but hard to enforce by automated tools, and frequently you'd need to annotate your code with comments to bypass some rules on specific lines or code blocks. Also, in my experience, the default settings for agency standard checker tools tend to check as much as possible, and don't have the granularity to start without optional requirements, so you'd end up tweaking your checker configuration relaxing some rules initially if you'd like to apply it to an existing project. For non safety critical but targeting high quality, at least start with what your compiler offers. Some of the benefits of Rust would be available by enabling stricter warnings (-Wall -Wextra) or using helper compiler package tools like clang analyzer (https://clang-analyzer.llvm.org) or extra checks with clang-tidy. Also, I'd also make sure to use sanitizers (https://github.com/google/sanitizers), start with Address Sanitizer (ASAN) and follow with UBSAN.
MSYS2 and header-only libraries !
How does this work? What kind of freedom do implementations enjoy when it comes to e.g. marking standard library functions with attributes?
IIUC adding attributes and `noexcept` is encouraged as a QoI detail, but adding constexpr is forbidden.
Multiple responses recommending hard liquor. My people.
You can avoid this warning by either casting the unused variable to void, or casting the expression itself to void. eg, (void)x; // or (void)(std::cout &lt;&lt; "Why?"); Though it's a touch verbose if you're using it everywhere.
I used this site, when learning it like 2 months ago. http://www.cplusplus.com/doc/tutorial/
You can definitely add implementation-specific attrbiutes. GCC has been doing this for years with `__attribute__((__const__))` etc. Since C++11 they can do this with standard syntax.
Reading and easy access Learncpp.org
Thanks
I am super drunk but this code still seems like a mess
spack + cmake find\_package
&gt; Almost no tutorials on the internet discuss this method. Do you have any references to tutorials that do?
I was in the same situation and [learncpp.com](https://learncpp.com) helped me a lot. After refreshing my mind on the basics, I then practiced the challenges in [codewars.com](https://codewars.com) .
&gt; We actually avoid anything that automatically fetches dependencies so that we can control linking and versioning Nowadays, it seems like any Android project will have some online dependency that I have to download.
To elaborate on my question. I build my project which generates libmyproject.a. I then take this library and will eventually extract the symbols from the OpenCV libs (libopencv\_core.a libopencv\_highgui.a libopencv\_imgcodecs.a libopencv\_video.a) and add them to my live (for the time being, I have not yet done this step. I then use my library in a new project, for which the CMakeLists.txt is shown below: &amp;#x200B; cmake_minimum_required(VERSION 2.8) project(myproject-driver) set(CMAKE_CXX_STANDARD 14) include_directories(${CMAKE_CURRENT_LIST_DIR}/include) link_directories(${CMAKE_CURRENT_LIST_DIR}/lib) find_package(OpenMP REQUIRED) add_executable(myproject-driver main.cpp) target_link_libraries(myproject-driver myproject libncnn.a ${OpenMP_CXX_FLAGS} libmxnet.so libopencv_core.a libopencv_highgui.a libopencv_imgcodecs.a libopencv_video.a) Building this generates the following errors: Linking CXX executable myproject-driver /usr/bin/ld: /home/nchafni/Cyrus/myproject/lib/libopencv_imgcodecs.a(grfmt_jpeg.cpp.o): undefined reference to symbol 'jpeg_default_qtables@@LIBJPEG_8.0' //usr/lib/x86_64-linux-gnu/libjpeg.so.8: error adding symbols: DSO missing from command line collect2: error: ld returned 1 exit status How can I fix this. Is there some command CMake command which will link all these dependencies for me? Do I need to manually track down each dependency of those libopencv\_\* libs and link those manually?
I've gone back and forth between all of these in various small projects. I think I like \`m\_whateverCase\` for private variables and \`whateverCase\` for PODs.
Prefixes can give you code completion (and a list of all the class members), suffixes can't. Sometimes it's convenient.
[removed]
[removed]
Ugh, no. It's something I picked up by watching and taking notes on these videos on Youtube: The State of Package Management in C++ - Mathieu Ropert [ACCU 2019], C++Now 2017: Daniel Pfeifer â€œEffective CMake". I also bought the book "Professional CMake: A Practical Guide" which is written by one of the CMake core devs, which I really recommend. There's a 80% solution here: https://jfreeman.dev/blog/2019/05/22/trying-conan-with-modern-cmake:-dependencies/
At least in C++20 we're getting `std::erase` and `std::erase_if`: https://en.cppreference.com/w/cpp/experimental/lib_extensions_2#Uniform_container_erasure
I just use `this-&gt;name` and that avoids the confusion. It also avoids surprises with dependent base lookups.
&gt; I then take this library and will eventually extract the symbols from the OpenCV libs (libopencv_core.a libopencv_highgui.a libopencv_imgcodecs.a libopencv_video.a) and add them to my lib This is what I've done in the past. It did get a bit messy. You can see examples here: https://stackoverflow.com/questions/13128/how-to-combine-several-c-c-libraries-into-one
A very common problem is called dependency hell. One version of this is you have three shared libraries you want to link. A requires version 2.1 of B and you have C that requires version 2.1.6 of B (completely different somehow). So you start going through the mess and effectively making your own version of A, B, or C in order to make the damn thing work. Or in windows you have the multithreaded 32bit library that works so well with your existing library, but the new library you want to put in only has a 64 bit version. Great. Or MT vs not MT. Some libraries don't care if you use the non debug version in or not, others lose their minds. This is where header only libraries completely rock. People complain about notably increased compile times, but at least they usually compile. Or you get tight things like sqlite where a single .h and a single .c or .cpp file is all you need. Nice, very nice. A slighly less nice variation on this would be something like box2d. It is many files but getting it to pile in with your code is easy; and it is multi-platform without pain. Another trick i have used is to take the stupid dynamic library code and just stuff the 953 files that make up the library and figure out which ones are needed to make the damn thing just join into my code. This takes a sledgehammer to get it in and say goodbye to their unit tests. This and the other variations of dependency hell has my radar working hard to find a replacement for my uses of C++. Python has probably replaced 80% of my c++ and I am looking hard at rust; real hard for the bulk of the remaining 20%.
[removed]
Thanks for the resource! Is there a good way to track down all the dependencies for the opencv libs. Generally I use the ldd command, but this does not work on static libraries.
I wanted to contribute a few minor things to cppref, but those hoops you mentioned is what made me reconsider. The instructions say that a new user needs to visit the discussion page linked to the page that user wanted to edit. Yet whenever I open the discussion page, it's empty, so, at least from my perspective, there's no indication that starting a discussion there is the right thing to do or if that discussion would even be seen by anyone at all. And this is coming from someone who did jump through a lot of hoops to report a bug to gcc. The difference being - one is a place where I can see others who have jumped through those hoops before me and the other looks like a ghost town.
They are mirrored on company-owned servers where I work so that isnâ€™t a problem.
Eh, whatever works!
Yep, this is what I've seen too. Many small libraries I've seen have an option for what they call "consolidated source" where it's pre-compiled into a single .h and .cpp file (or sometimes also a forward declaration header file). This is generally my favorite way to do it, otherwise it usually involves hours or days if banging your head against cmake. That said everything I've done professionally has been statically linked so maybe it's different if you're shipping a Linux program with dynamic libraries or something
I prefer no extra syntax. If your classes and/or methods are so large you need Hungarian notation to disambiguate, you probably should probably make them smaller. Also, modern day IDEs can help a lot. As for constructors, if you initialize variables before the body, you donâ€™t have to have different names. If itâ€™s in the body, I think itâ€™s okay to prefix with â€˜thisâ€™ (though I would argue against using it elsewhere). In theory you should avoid leading underscores and make them a suffix (see the Google c++ Style Guide).
Agreed. I think Conan and CMake should be the "go to" options. However, some environments, particularly the embedded space, are more suitable to lower level "direct package management" with something like buildroot.
Hey, it keeps everyone from relying on `#include &lt;left-pad&gt;`!
Main point is that I want keep the standard C++ preprocessor status quo, because I don't think that C++ committee start to accept changes to the preproccesor to makes it better source code handler - and because I want write nonstandard code in standard way with preprocessor and only with preprocessor - no need for external tools and code generators (or at least code generation is integrated seamless to platform tools like C++/WinRT in Visual Studio). Sometimes the preprocessor behaves bizarre way, so it needs nested macros for doing the right thing. I seriously think that I can't enjoy C++ so much as now, if I can't use the standard preprocessor when I want, but actually I'm not sure yet if I want use that super freak initAs-macro, but it is one way how to tie variable's declaration to initialization block. By the way, I think that standard C++ derridaize, with same scope semantics (except noexcept), looks maybe like below (or maybe I be wrong - as usually): namespace unstd { class spin_mutex { public: auto lock () -&gt; void; auto unlock () -&gt; void; private: std::mutex self; }; } auto unstd::spin_mutex::lock() -&gt; void { if(std::thread::hardware_concurrency() == 0) { self.lock(); } else { int spin_count { 4000 }; while(!self.try_lock()) { if(--spin_count == 0) { self.lock(); break; } } } } auto unstd::spin_mutex::unlock() -&gt; void { self.unlock(); } auto derridaize2(Timestamp const&amp; timestamp) -&gt; Timestamp { auto result = timestamp; { static unstd::spin_mutex foucault; if(std::lock_guard panopticon { foucault }; false) {} else { constexpr auto nietzsche { 0 }, heidegger { 5 }, wittgenstein { 60 }; static auto derrida { nietzsche }; if((derrida += heidegger) &gt;= wittgenstein) { derrida = nietzsche; } result.second = derrida; } } return result; }
I add everything to source control. Why? Things disappear off the internet. You use some version for a long time and don't want to upgrade, for example you are supporting old and new versions. Sometimes i have real work to do, and upgrading is not a high priority. Examples:. Look for really old rpm or driver's for old OS. I once had an open source dependency become a porn site.
I've been packaging all my project deps in Singularity containers and using those. Has the advantage of being easy to distribute.
I'm not sure if your question is "What is rss?" (it's a protocol that aim at aggregate news, basically what a read-only facebook may look like), or if it is "What is inside the rss stream of my blog?". I didn't tested it (I don't use rss myself (but it was there for free, so I added it), but as far as I understand from the xml itself, you basically get the same information than the homepage of the blog, and a notification when I publish new articles.
If you're looking for a good introductory video series, watch **The Cherno Project** on YouTube and nothing else (unless you want to unlearn tons of back practice later). As for books, Get **C++ for Dummies** for discovering features without feeling too much overwhelmed then refer to **C++ Primer** when you'd like to know how a certain feature works under the hood.
https://mesonbuild.com/ It's newish, and also basically Jesus.
Generally, you have the dependency installed system wide and you link against the shared or static object of the installed library and include headers from the system include path. That's for *nix systems though, and doesn't help with requiring specific versions. In Windows and for me.personally, serious projects, I setup for submodules for each dependency from it's official repository at a specific revision and part of my build chain is to build the 'external' libs as a dependency for building the project. The project then links against specifically the local object files of that library as well as include those headers via header path variables For some projects where I don't even want to depend on a remote, I do basically the same thing but actually include a copy of the library to build inside my project. 99% of the time though, on Unix, I install Dec versions of libraries with aptitude and just link and include against the system paths.
I meant , what is the rss link to your blog so I can add it to my news stream. I couldnâ€™t find it on your site.
It's the rss logo at the bottom of any page: [https://robinmoussu.gitlab.io/blog/index.xml](https://robinmoussu.gitlab.io/blog/index.xml)
Mind if I ask how come? As in are your customers asking you for that? Or are you doing it more as a learning exercise? \`\`\` Additionally, I want for the user of my library to not have to install OpenCV 4 on their system (but do not mind if the user has to do simple installs using apt-get install) \`\`\` In my experience customers like installers and package managers so using a tool like CPack with DEB/RPM generators will automatically create and orchestrate the required dependencies for pretty much most targeted platforms. To answer your question more directly I'm not sure that it is possible in the generic sense. This is likely for two reasons, dependency hell and license agreements. Sure your library may depend on static libraries. But the dependencies that you are specifying will likely have dependencies on shared libs. And your dependencies dependencies will likely have dependencies on shared libs, and we can follow the rabbit whole down into dependency hell. Now assuming that we have a simple project and dependency hell is not an issue and everything is statically linked all the way through. Making the decision to compile a library static or shared has dramatic implications on your customers because of licensing. If you have any code that has hard FOSS requirements it means that your library will plainly not be used in business or probably the general sense if it is STATIC because the license agreements on things like LGPLv3 and LGPLv2 make it near impossible to incorporate into a customers environment. Now you need to manage and audit closely all of the ENTIRE licenses used by both you, your dependencies, and your dependencies dependencies. As a learning excercise on how libraries are put together though I think it sounds like a really fun project!
bazel
&gt; What's the "standard build and install" workflow? Usually its configure, build, and install, with a description of the compiler, its flags, installation directory, and some paths to the dependencies. Of course, some build systems like b2 and make don't have configure step unless you are using meta-build system like autotools or cmake. &gt; Even among themselves, CMake projects are not unified because of the Modern and Not separation and not all people even know or use that stuff. The issue is not really modern vs non-modern cmake. Modern cmake is helpful for generating usage requirements, and managing dependencies through `add_subdirectory`. No doubt, not having usage requirements should be considered a bug, but much more problematic cmake issues for packaging is having hard-coded paths or using non-standard cmake variables to find dependencies instead of using cmake's find commands. &gt; People (and businesses) still do use other build systems and while it's a major pita to bind everything together, it's simply impossible to force people to use any concrete build system because of the mass of projects already written. Autotools, [a-z]make, different "build"s, b2, etc. I am not saying everyone should use the same buildsystem, but even across the build systems you mentioned, they all use a standard configure, build, and install. As such, cget can install from cmake, autotools, boost, meson, and make. &gt; Even then people want to explore in this field, see Meson and such. Yep, a newer buildsystems like meson still works with this workflow.
Kate Gregory is a really good teacher. If you have access of pluralsight, you can take a look at her video tutorials. You can find some good videos on youtube as well but they are mostly focused on how to write better program. channel9 has some good videos / series by Kate and Stephan T Lavavej (another very good teacher, I loved his series on STL).
Sorry but cppcheck is really weak. Occasionally it will find a fairly obvious problem but itâ€™s so infrequent that it is almost not worth running it.
Thatâ€™s rather optimistic Iâ€™d say. If youâ€™ve worked in any sort of group environment you can guarantee at some point someone will do something stupid because they are inexperienced or tired. And if you are lucky code review will catch it and if you are even luckier your company can afford to have the best code checking tools around. But usually companies are not going to pay for the best tools because they are quite expensive and reviewers are sometimes tired or rushed so stuff slips through the holes in the net. And thatâ€™s all you can get with c++ â€” an imperfect safety net.
Very interesting question, I was wondering about that myself.
Like most of the "this is why we can't have nice things..." situations in C++, it probably has something to do with name mangling. Not that it couldn't be mangled (obviously, template lambdas work), but rather that it perhaps interacts weirdly with name mangling. Idle speculation: lambdas are nonce types, perhaps some compilers take advantage of the uniqueness of the "this" type when mangling the name of the lambda method. In other words maybe some name mangling uses "unique generated class name" to mean "operator () of ... said class name" whereas that wouldn't fly with a named local class with named member templates.
Use conan.io for a seamless experience with dependencies. Really, in 5 minutes you're ready to go with it and its documentation is also rich of examples on how to start.
Vcpkg is just cross platform system package manager for c++, it doesnt solve anything.
Huh? It gets things installed in the right place on all platforms. I don't see how this isn't a solution.
I like to name my variables as is, so no suffix or prefix: ```whateverCase``` or ```whatever_case```. This conflicts with my getters tho, which I also like to keep simple, without prefix: ```const auto&amp; whateverCase() { ... }``` Life is tough.
I recommend not using _ as a prefix. It is fine to use _lowerCase, but if you use _UpperCase it is undefined behavior. Personally I use mVariableName or m_variableName (depending on the existing conventions). I agree the â€œmâ€ feels somewhat arbitrary, but it is a common convention so itâ€™s fine. Additionally (as mentioned by others) the prefix helps with autocompletion, whereas the suffix doesnâ€™t really help with much.
Thanks for the great insight. Your suggestion of using CPack sounds like it may work well. Can you please elaborate on how this tool works as I do not have experience working with it.
CMake 2.8 is ancient. Is there a reason you're still using it? Newer versions introduce much more sane defaults for many things. You really ought to increase your CMake version requirement, which enables those [policies](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html). You can also enable them one-by-one, but that's not a sane approach. General advice: 1. Use [`target_include_directories`](https://cmake.org/cmake/help/latest/command/target_include_directories.html) instead of `include_directories` 2. Use [`target_link_directories`](https://cmake.org/cmake/help/latest/command/target_link_directories.html) instead of `link_directories` 3. Note that `CMAKE_CXX_STANDARD` is only available since CMake 3.1.
[removed]
and this is exactly why c++ has a bright future; programmers have free will as they are not forced to jump through hoops just to make some anal compiler happy while gaining marginal benefit. instead, they are trusted to use their intellectual capacity to actually solve real problems
The new GCC compiler with colour highlighting is a little bit better at pointing out errors. It's generally quite helpful for pure C/C++ until you make an error with the standard library and you get 200 lines about std:: whatever&lt;random characters&gt;
Python + c++ is a really powerful combo
Try https://cristianadam.eu/20190501/bundling-together-static-libraries-with-cmake/ It's an implementation of what the stackoverflow answer is suggesting.
Heâ€™s an excellent speaker.
It is something of an Achilles heal for C++. It is supposed to be getting better with newer versions (introduction of concepts) but TBH concept-related error messages are just as much hard work to decipher as the traditional messages were. The main thing is to look for \`\`at this point in &lt;file&gt;'' and go and have a careful look at that line of code; the rest of the error messages you scan quickly in the hope that you at least get the gist of the problem.
If someone wants to help me with the dependencies for other distributions, which I'm not very familiar with at all, that would be very helpful.
It's a bit scattered on the cmake documentation, but the idea is straightforward enough: &amp;#x200B; \- add an include(CPack) at the end of your main CMakelists.txt. \- make sure all Find\*.cmake scripts you're using have an install() stanza. &amp;#x200B; then doing a \`cmake --build -- package\` will make you an installer, with all binaries included, or for example on debian, with any dependencies set that you have specified. Setting the dependencies is the nicest way for the user of the package, it will prevent installing things twice.
Iâ€™m not gunna lie, I had never heard of local classes until ~5min ago, and Iâ€™ve never seem em used in code. Would love to know the historical context behind them. I betcha the reason why this doesnâ€™t work is just because all those restrictions are attached to the local class feature and they are so rarely used that nobody put in the work to relax those restrictions.
MISRA-C is exactly one of those standards I was talking about. They are good style guides and formally forbid many bad or dangerous coding practices (a lot comes down to "stay away from UB as far as possible", but last time I checked, there is nothing in there that gives you the kind of program-level guarantees that rust does. For that, you need a formal way to express meta-information (e.g. ownership, value ranges, relations between values) in the source code (e.g. via annotations or well known types). That's what misra lacks completely (IIRC). The core guidelines are the only example I have experience with that comes close. (SAL might too, but never used it or read "the manual ", so Imight be completely wrong.
C/C++ is what separates script-kiddies from computer programmers
Ah okay. I think a lot of the angst comes from people desperately wanting a more standardised ecosystem, and that gets channelled into modules. I still find the idea that the committee consider build systems beyond their remit a bit astounding. Yes, technically that is true but no standard is worth anything unless it works in practice, and given no-one sane compiles by hand anymore that means the committee needs to at least think about how things are going to play with build systems (in my opinion).
is it still true that clang has better error messages than gcc? iirc that was the consensus a couple of years ago
I mean, you might not want to erase immediately or reuse the elements, but still you would need to know starting where the invalid elements are, so [[nodiscard]] makes still sense. Multiple remove calls can probably be done better with a single remove_if, so you get less copying of elements and only a single pass.
In the last versions, they are getting quite similar. I try to make everything compile for both GCC and Clang, because they offer slightly different -Wall warnings, and in some cases, one has better error messages than the other, and viceversa. If you can, don't choose, keep both in your toolbelt, it will be very helpful.
A few years back it was definitely the case that clang had far far better warnings and errors. Dare I say that GCC had somewhat stagnated for a number of years in that area. However, given the new challenger they've definitely upped their diagnostics game significantly and even exceeded clang in a number of areas. I'm sure nowadays it's possible to come up with a multitude of examples showing one or the other doing a far better job than the other one. I hope they both continue to improve. Competition is a good thing.
Just wait until you try Boost :)
I use git submodules .. simple and easy
The only downvotes for this one are from script-kiddies.
Also wait till the time that C++ smacks you on the face with that order of magnitude performance increase in certain situations over python. The efforts definitely pay off!
What? It has a future, but not for that reason: it enables programmers to wring every ounce of performance out of existing hardware.
An issue in a template &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;type...
Or from people that simply don't like elitist gatekeeping.
What can I say, the truth hurts
If it works like any other Wiki, the admins and users will see recent activities and recent edited pages. In that case, they'll see your post on discussion, or you can always edit the page directly and in the reasons put something like *Updated info's blah blah directly due to empty discussion page*. The worst thing it can happen is that they revert the edit.
Itâ€™s usually multiple orders of magnitude
Agreed. 99.99% of the time, just focus on understanding the very first error. The rest is just the compiler getting more and more confused and rarely provides any useful information.
I don't really understand who is this for?
I have this debate at least 2 times a week ðŸ¤£
God I hope so. That's my programming CV right there!
Not a particular opinion on the topic, but: &gt; m_whateverCase / mWhateverCase: I feel hungarian notation or similar just adds clutter. If m is the only prefix used, then it feels like an arbitrary, meaningless character. a underscore suffix is just as much a form of Hungarian notation/a random char as the `m_` prefix.
In C++ a trick I always use when the error message is massive is to just focus on the first error. Anything else might be independent, which is why the compiler tries to be helpful and report more than one error every time, but it also can just be a consequence of the first error so focusing on that and compiling again will be the best strategy.
play around with pybin11. feels like magic ;)
It's a normal CMake project that builds bootable machine images. So, if you are interested in OSdev but all the glue is daunting, then (as the README states) this is for you. You can start reading/writing to device registers and things that are interesting immediately. Not to mention, it's fun to play with page tables and other things that is normally not allowed.
It's a normal CMake project that builds bootable machine images. So, if you are interested in OSdev but all the glue is daunting, then (as the README states) this is for you. You can start reading/writing to device registers and things that are interesting immediately. Not to mention, it's fun to play with page tables and other things that is normally not allowed.
Honestly never saw a company using Maven and mirroring dependencies. Anyways it's the same in C++: you secure your dependencies either through a package manager or in a form of source code, depending on how important it is. Dependencies comping from package manager usually aren't bound to a specific version though, if you depend on boost 1.54 specifically, IMO you better grab its source code and build it yourself. This is much easier to manage on Linux, but i would imagine it's a pain in the butt on Windows and that is why people use Conan instead of their system's package manager or just including dependency in their source tree. I guess i'm sort of out of loop, but i remember that it was always easier to cross-compile for Windows than to compile something on Windows.
&gt; you can always edit the page directly Cppreference doesn't allow new users to make direct edits.
We are really happy using CMake and git [through a custom CMake script](https://github.com/TheLartians/CPM) as a C++ dependency manager for our cross-platform app development engine. It's trivial to setup and basically works with any downloadable dependency (no packaging required). The main downside is that all dependencies have to be downloaded built from scratch for every new project, but for small to medium-sized dependencies this works great.
Oh sorry. Now I understand your concerns then.
An IDE helps immensely, at least in your first stages of programming in c++. It would for instance flag right away the issue with the semicolon.
So is C# or Java for script kiddies?
Submodules only work if you're not planning on using your project as a dependency itself though. Otherwise you'll get into trouble if some other dependency adds the same submodule.
From *Modern C++ Design*: &gt;It can be easily proven that any idiom that uses a local class can be implemented using a template class outside the function. In other words, local classes are not an idiom-enabling feature.
ExternalProject does not work well with a custom environment though, as you'll need to do all configuring manually. I use CMake's FetchContent as it downloads at configure time and you can add the dependency through \`add\_subdirectory\`. Also you can still build when offline.
Use a better IDE. Xcode will flag missing semicolons and even Unicode semicolon lookalikes without blinking.
Very much so.
I learned python in college(still am), learning C++ as a side hobby and oh boy python does hold your hand but tbh I acctually miss static typing, const and all that stuff when I use python
Absolute fact. If your "language" isn't compiled, you're a scripting soyboy laring as a programer.
I think modules are going to kill a lot of build systems that will not be able to evolve to bring support to the whole new way of building C++ code with modules. If that happens, this is actually a good thing, as we'll have far less fully-supported build systems, a chance to reinforce a defacto-standard one, or just a handful of them.
So besides spending an inordinate amount of time with smash bros, what's your professional cv look like that you feel you can call folks script kiddies as some weird early 2000s gatekeeping?
Now the STD is your new mama ;)
What's wrong with having a hobby? Is your hobby creeping on people's post histories?
Unix practically has standardized the workflows. The remaining pain mostly comes from trying to also support MS-Windows, which strays away from the good Unix conventions and lacks any guideline on the proper way to integrate together the thousands of OSS pieces we use.
That's coming from a guy who spends all his time on /r/bodybuilding.
In the project I work on at my company, we do keep private source and pre-built package repositories for both maven and conan (we use both C++ and Java).
People like me is who it's for! :D
How can having no choice about which version you need be a good thing? I can understand that way of thinking for distributions (e.g. linux ones) where the maintainers do a great job of making sure the provided versions do work well together, but vcpkg ain't a distro, innit?
Local classes are mostly fun when you want to return a simple structure with named members that can't really named outside of the function.
I run my C code in an interpreter don't @ me
Oh, okay! :)
&gt;programmers have free will Let's not get ahead of ourselves here. We're all just Turing machines after all
Well fuck something is causing infinite template recursion. What possibly could be the error? Oh of course, a small syntax error in an entirely unrelated part of the code.
Good luck trying to make me feel bad about being fit. 0 professional experience, eh?
Unix. On that topic, how does vcpkg make sense? You know, it's got "VC" in its name, so, that doesn't convey to us it's of any use in this land. It looks to me like a dead-end due to cultural clash. Just looking at the introductory webpage of vcpkg made me feel a strong aversion because of the... MSDOS (sic!) terminology they used all other the place, and amazingly basic explanations that are totally out-of-place. So, either the tool is effectively stuck in an alternate universe, populated with clueless developers, or it's just its documentation that was written by old MS employees who lack any culture about the way the world talks, and that needs a complete rewrite.
&gt; any idiom Including lambdas (which are local classes too). Are you ready to go back to functional objects in global scope?
This is well cool. I used to love messing with raw processors back in the days when you just put code in the first sector of a floppy and booted it. Wish to hell I had the time to play with this stuff nowadays.
There's nothing wrong with having a hobby either.
I literally don't. I do have a problem with the toxic gatekeeping about what languages someone uses for their job. So when someone does that, I like to see what their professional background is like when they start shitting on folks they perceive as below them. I'm assuming you're a hobbyist or a cs student who feels like they're so much better than those script kiddies because they use c++/c# in their personal projects/introductory classes but still don't know all that much. Which lack of knowledge isn't an issue in and of itself, the psuedo elitism is. Programming is an ever-learning career and everyone starts somewhere. Shitting on other folks for that won't get you far.
If you push the soyboy state of being beyond its limit and get rid of the remaining extraneous masculinity left, chances are that you're trans and actually a good C++ programmer :') And chances are that you'll also use scripting languages because they're often good at what we us them for.
Try c# it's pretty cool and it's a high level language
I've a background in dabling with C and C++ (commercial) but all the scripting languages are like this. I'm no future prodigy or KA Sommers picking fights with popular tech, mostly I have a greater understanding of what is happening inside. One of my colleagues pointed out that a Ruby Puma server was just released https://github.com/puma/puma/releases/tag/v4.0.0 it made me so mad when he told me that there were likely no trade-offs with their decisions. - Oh it's avoiding syscalls by using this API. Great less bureaucracy. Watch out for edge cases or things they didn't account for when boiling the wafer! Scripting languages are not just parents, they are trailer parents. They make so many decisions they arbitrarily decided you can't opt out of. I'm sure DevOps was meant to be a movement to teach youngling programmers that their saved minutes when using a library can have real-world business impact, but it doesn't. They just crap the details out anyway and keep going. Some midget with a ReactJS GUI once told me de-coupling from specific technologies was viewed by their business to be an academic pursuit. READ the libuv docs. Some decisions should jump out at you http://docs.libuv.org/en/v1.x/design.html The number of junior programmers that have been like "Dude I can code faster than you for an hour". Who was in that race? I was off by the water cooler, later alcohol fridge desperately trying to find a way to convince you that computers are not magic hats, there are always trade-offs. Please stop passing mutable state around. Don't code to a specific data-store or overly tie yourself to that store's functionality. I sat a programming test the other day where they were like. The thing you coded in 30 minutes has O(log(n*2)) complexity. It's 30 miinutes. I'm deliberately not writing anything you can pick up and use. If someone is going to write an O(log(n)) algorithm (which I disagree with because it generally only speaks to either input or output) in 30 minutes, you could capture and sell their solutions. There would be no reason to work with them at all. I'm going for something you understand. There is no leaky tub, async / concurrency is limited. Just out of habit because I like things to be portable to lower-end platforms I'll probably be making memory savings at the trade-off of cpu time, because it's my choice in my unbilled time what I code. Remember when there is mueller report length C++, you can compartmentalize and partition that into more generic high-level API's
You can use composition with a nested struct for the member variables, in which case you do not need a naming convention. Accessing member variables then is done by \`member.whateverCase\` (you get to decide what \`member\` is called.) Assuming the member variables are reasonably well-behaved, you can even use an anonymous nested struct with aggregate initialization, which means that you do not have to add member constructors. &amp;#x200B; class MyClass { public: MyClass(int x) : member{x} {}; int x() { return member.x; } private: struct { int x; } member; };
**Reading material** * [Programming -- Principles and Practice Using C++ (Second Edition)](http://stroustrup.com/programming.html) Written by a then-university teacher, to expose you to C++ from the ground up, imbuing the design philosophy in all of its lessons. The book was designed to go hand-in-hand with a first-year course at Texas A&amp;M University, but I've found myself learning from it even as a C++ teacher. Unlike many other learning resources, it focuses on *designing* programs using C++, rather than "here's a cute language feature, now go try it out". It's also got GUI activities, so you can see how windowed programs can be written. It's structured in a manner that ensures you learn how to write programs using C++, not another language with similar syntax. There's far more practical examples and exercises in this book than any other that I've read, probably akin to a first-year university maths textbook, so you won't be out of shape upon completion. It does, however, assume you don't have any programming experience, so I recommend experienced programmers read Tour++ (see below) before PPP, to get a feel for what's to come. Since every programming language is different, it's still a great way to learn how to *use* C++ to write *programs*, regardless of programming experience. * [A Tour of C++ (Second Edition)](http://stroustrup.com/Tour.html) This one is good for getting a whirlwind experience of C++. It's long enough to show you all of the salient features C++ has to offer, with an example or two, but short enough that you can finish it in an afternoon. You won't learn how to use C++ from this book, but you'll certainly be able to see what's *in* C++. When teaching, I recommended that students read this book before the final exam so they'd get a good refresher on things that they'd forgotten. **Paid-for courses** * [C++ Fundamentals Including C++ 17](https://www.pluralsight.com/courses/cplusplus-fundamentals-c17) Kate's got a knack for teaching, and has had many years of teaching C++ with lots of successful experimentation. The course takes you through tooling, and then the language basics that C++ programmers should be using, before moving on to specific language details after you've learnt how to practically use them. \-------------- None of the above will turn you into an expert overnight, but they'll all help you develop a skillset that will let you start writing programs using C++ or start contributing to projects that are written in C++.
I've down-voted all of you for falling into the trap of believing that we are not all script kiddies and elitists , geniuses and morons at different points in the day. Feel free to return the favor proving my point, or cowardly refrain for fear of emboldening my position.
I learned Java first, then c++, which ws surprisingly hard. Still, I had Python on a pedestal as this end-all programming language. When I saw how simple it was, I was....dissappointed.
which compiler support Spaceship Operator?
In that way, I think C is my prpgramming mama.
I wish the debugging story was better on linux though. My understanding is that visual studio can do cross language debugging*, but I've yet to find a way to approach the problem on linux. *I.e step through pdb until I enter a .so then step through on gdb (or debugger of choice).
The massive STL errors are usually just related to the compiler telling you every possible overload it tries for whatever function call you messed up (thanks SFINAE), so yeah, just the first error is usually enough to tell you what's going on. Concepts will help a lot with that in C++20.
I hate reading code that has no convention at all. Different contextual identifiers should look different, else this creates confusion for the reader.
Just trying to find the name of the function in a 400-character long error message is a challenge
I agree, this is an anti-feature of vcpkg and one of the reasons I don't use it.
Another trick is assign it to an int: &amp;#x200B; int foo = somethingThatIsNotAnInt()
Since you're a student, you can get access to the professional version of CLion as well
If you use the latest clang (gcc upped their error-message game as well), you should get much better and colored error messages. MSVC's error output window is actually also pretty good and should spot a missing semicolon, if you use the very latest version (2019). Other than that, yes definitely Python is spoon-feeding you :-) But that's good too!
It's a GigE-Vision camera which supports big endian only. On my x86 I have the time to convert, on a Raspi I haven't.
sometimes i wish the council of elders would just go ahead and make templates a part of a fully fledged pre-compiler c/c++ based meta-programming language, like what qt does, but more so. yeah, between macros, templates, and constexpr and the like, you can do anything a full programming language can do, but the crap you have to do to *get* there is sometimes astounding... and a lot of that lives in boost. i feel like with a couple of smartly added features, 9/10ths of boost's oddities could be replaced with sanity, instead of nested workarounds.
The m\_ bit can be used separated from whether you use a type prefix. I use both. The benefit of the m\_ part is that a parameter that is going to set a member or be set from a member can have the exact same name as the member, just without the m\_. That avoids the need to work around name clashes by either using redundant this-&gt; or coming up with a different case scheme for members vs parameters or having to name the parameters differently in some way so that it's not as obvious that the two match up. I find the schemes that use different case to be annoying personally. It's like Linux considering bob and Bob to be different names and all of the confusion and potential errors that can cause.
With color output, it just scroll up to the first red "error", and fix that. Had been surprising effective. I wonder if there was a way to tell the compiler that you don't want all the "note" messages about substitution failures and functions that didn't work. Most of the time it is a simple typo, and the "error" tells me that.
Donâ€™t think there was a specific reason as to why I was using it Thanks I will for sure upgrade
I prefer printed books. The Semigroup Press link doesn't say anything about "authors' edition". Is it the updated version, or no? Is the Amazon link available yet?
Get yourself a Clang compiler
I love C++, especially modern C++, but all my programming is in C++, some Python, C, and VimScript (and, like, a couple DSLâ€™s from early 90s video games). I know Iâ€™m not sufficiently versed in enough languages.
Are you asking if you don't understand who it is for?
400 characters? How quaint... I've seen a single error span more than 23 screens before (error with a Boost Python call). Another fun one to find was a missing &gt; in a template. I was helping a colleague with that one. The compiler didn't complaint until the end of the file, some 200 lines later.
I just ignore all that BS and just focus on the error that points to some part in my code. All those overload errors point to STL files
I agree with the point that clang did give better error messages than gcc in yesteryears, newer versions of gcc have upped their game. For clang, the infrastructure in it does really allow the compiler to give some good error messages. I've submitted code for clang and getting it past reviewers is far easier when you're showing in your test cases the exact location of the error and the reason. It's one of clang's goals to provide high quality diagnostics. Compiling with GCC and clang on broken code should give solid descriptions of whats wrong these days, modulo implementation dependant features of C++.
I know that feel. Iâ€™m really starting to think that the mania for dynamic typing was a mistake. Iâ€™ve recently been using type annotations and mypy to essentially do statically typed Python.
&gt; Life is tough. It is with that style.
I'd consider that a drawback of prefixes, in that you have to type more characters to get to the member you want.
I quite like `my` as a prefix. It's the same length as `m_`, but easier to pronounce. I anthropomorphise classes in my comments so it fits with that. Otherwise I'd use `_` as a suffix, or nothing.
Yup, welcome to C++! ðŸ˜œ As others have rightfully noted here, a lot of that error spew is simply the compiler informing you of all the potential overloads it searched and including the full type names for *every* type involved. And lest you think that can be a big problem, remember that because of templates, C++ types can be incredibly verbose; this is a [single type!](https://gist.github.com/rpj/11251783ec2788ea16db08bd5e0fcba9): `(&amp; g_TypeParseMap.std::map&lt;_Key, _Tp, _Compare, _Alloc&gt;::operator[]&lt;RedisObject::Type, std::function&lt;RedisObject*(String)&gt;, std::lessRedisObject::Type, std::allocator&lt;std::pair&lt;const RedisObject::Type, std::function&lt;RedisObject*(String)&gt; &gt; &gt; &gt;(((const key_type)(&amp; typeChar))))-&gt;std::function&lt;_Res(_ArgTypes ...)&gt;::operator()&lt;RedisObject*, {String}&gt;(String(((const String)(&amp; substr))))` (And this isnâ€™t even the longest type name Iâ€™ve ever seen, just one that caught my eye!)
Looks interesting! What's the main difference to boost.python? Simplicity / header only?
Personally I would probably have a templated function to register the handler, in that way you can avoid the virtual function call in `std::function` by passing a lambda/functor.
Gcc has gotten much better, though I tend to prefer clang still. I also think using libc++ gives saner errors wrt the STL
The lack of static typing is why i never particularly liked python and similar. Then if you take the structure of Python and run it on a JVM, you get yhe hellish apocolypse that is Matlab. Easily the worst result of the "if it ain't broke, don't fix it" mentality among engineers. Which, it totally is broke, the engineers just don't realize it because it still produces the right output. They'll spend all day trying to squeeze nominally more efficiency out of the car/plane/bridge they're designing, then throw the numbers into a cruncher that gets 2 gallons to the mile.
&gt; C++ gave me Mueller's Report to read for missing a semi-colon. yeah I know, I get errors like this all the time. error at line [REDACTED]: cannot instantiate template [SUBJECT TO ONGOING MATTER]: type error in `std::experimental::â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ` - cannot find external reference to `trump.h` (-Wmissing-collusion) = note: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ template â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ &lt;â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ&gt; â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ, defined in `std::dnc` â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ 33000 bytes definitely leaked, (7570 ~~emails~~ blocks lost at exit)
Of course, vcpkg coming from windows/vs is going to have a focus on that platform. My expectations for Linux are not nearly as high. I just want a toolchain.cmake that will be able to find the packages I installed with vcpkg
I'm not sure I follow.
Upvoted because of the picture of captain Okita/Avatar.
I think it is turned off by default, but MSVC has a project option that will show you the column where an error occurred (such as a missing semicolon or extra bracket or whatever). MSVC also has "Just My Code" debugging where it jumps overt STL/standard library stuff.
Haha
Hm, I'm pretty sure I did, about a year ago. Though it was on a localized version.
It gives you the exact type of somethingThatIsNotAnInt()
Lmao
Here's what cppref has to say: &gt; You do not have permission to edit this page, for the following reason: Due to recent vandalism, editing of this page is temporarily disabled for new users.If you want to suggest a change, please leave a message on the suggestions page for new users instead (don't be surprised if that page appears vandalized!).
Which things need fixing? In specific.
Last time I tried Boost Lambda (an EDSL for writing lambdas before C++11 was a thing and you could rely on them being in the language) I made a simple mistake and got an error message that was literally five megabytes long...
C is better at ABI compatibility and as such is also better at providing access to other languages, such as python or some shit.
I assume itâ€™s because there is no standard C++ ABI, so it can be different between compilers or even compiler versions. Itâ€™s also easier to hide implementation in a simple C API w something like PIMPL
I feel like I never know exactly what my code is gonna do in Python. C++ might be slower to write but I like how explicit it is.
&gt; `foo-&gt;_bar`/`foo._bar` is worse than `foo-&gt;bar_`/`foo.bar_` Worth pointing out that besides copy/move operations (which can themselves be rare to implement depending what you're writing), this doesn't tend to happen unless you prefix everything with `this-&gt;`. It's far more common for me to see `_bar` than it is to see `foo._bar` or `foo-&gt;_bar`. Even then, copy-swap is also a common assignment operator strategy, leaving just the copy and/or move constructor.
It's a blessing. And the fact you can use ALL of their tools for free. Saves me hours on programs.
I like python but I like to know that functions only return type X and you can only input what you specify. And I love that C++ acctually makes me have to know about type sizes, stack/heap and all that weird stuff
@Crazy\_\_Eddie and @Wh00ster &amp;#x200B; So a standard C++ ABI should be able to change the situation. Why haven't the ISO C++ standard haven't done it yet? &amp;#x200B; Is it even the ISO C++ community's job to implement a stable application binary interface ?
My dream lang would be C++ but without the legacy cruft, no headers, and a better solution than templates for generics. Py return types are a true pain in the ass and can lead to some baffling errors, especially when you're working with poorly documented code.
u/MaxEinstein &gt; So a standard C++ ABI should be able to change the situation. Why haven't the ISO C++ standard haven't done it yet? There hasn't been a consensus afaict. For example, how would this interact with [devirtualization](http://lazarenko.me/devirtualization/) or [empty base class optimization](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Empty_Base_Optimization) &gt; The compiler is **allowed** to flatten the inheritance hierarchy in a way that the empty base class does not consume space. &gt; Is it even the ISO C++ community's job to implement a stable application binary interface ? I think it's come up a lot. https://www.youtube.com/watch?v=ncyQAjTyPwU
and how exactly would you imply going around, implementing such an ABI? The majority of OS features differ; causing a break there. Many compile STL implementations vary, and even if you managed to convince everyone to write things the same way, you're still going to run into OS specific issues causing it to break horribly. Then name mangling makes everything brittle... I'm not disagreeing that it'd be nice, it'd certainly make mod support easier but there are techniques for that and with a little bit of tweaking reach the same goals.
Typically C API is all you need. C++ features like templates, polymorphism, OOP, etc. are very good for building large software systems, but aren't so needed for API imo.
Thanks @everyone and I m gonna check out the links provided now ? Can anyone answer only this : **Why some C++ libraries don't have C++ API ???**
You get 90% of the silver back for playing. It's just to keep people from attacking and then not showing up.
The main thing that python has for me over C++ is the easebof use of python packages over C++ libraries.
Here's hoping C++ modules become a thing
I think both polymorphism and (especially) templates can be very useful in APIs.
Oh, for sure! I'm definitely looking forward to using the lifetime checker in my own code. :) I just think that people have unrealistic expectations of what it can do sometimes.
I do not have any experience but I often read on the internet that providing language bindings is considerably easier with a C API and if the library has already a C API, also providinig a C++ one might be an extra or unnecessary work for the author. There was some discussion in here:, though library in the post provides a C++API as a thin-layer over the C-API https://old.reddit.com/r/cpp/comments/b8gclg/blend2d_2d_vector_graphics_powered_by_a_jit/ejxqmdc/
I was away from c++ for a while -- Then I started playing with Rust. Oh my god the errors have improved.
Hmm... So it all boils down to C++ not having a standard ABI.
&gt; My understanding is that visual studio can do cross language debugging* As in you're writing python that calls uses c(++), yet you can jump into and trace the c? Or are you referring to using VSCode on linux? Like: https://i.imgur.com/ojJa4gf.png
What are the biggest pain points today that Boost helps with? Back in the day, boost was the only way to use smart pointers.
A lot of python modules already use `c`. How you call them makes a big difference.
You should check out: https://www.bernat.tech/content/images/2018/05/type_missmatch.jpg - https://www.bernat.tech/the-state-of-type-hints-in-python/ - http://mypy-lang.org/
Isn't rust what you are looking for?
One could say Trump has a dangling-pointer to Truth
Also, side from many languages only supporting a C [FFI](https://en.wikipedia.org/wiki/Foreign_function_interface) to allow bindings, using a C API also makes distributing the library easier because you can usually just install a .dll/.so binary, instead of requiring that the user compile the library themselves along with (*shudder*) all of its C++ dependencies.
For typing # For JavaScript - use TypeScript # For Python use types - https://www.bernat.tech/content/images/2018/05/type_missmatch.jpg - https://www.bernat.tech/the-state-of-type-hints-in-python/ - http://mypy-lang.org/
Tried it, liked it, still waiting for it to mature. Still no good solution for desktop UI last time I checked.
C++ ABI is a lot more complicated to implement. There's no obvious way to do it.
It's not just that. A C library can be used in both C++ and C (usually), C++ libraries can only be used in C++.
Just to nitpick, this is more close to a "raw" reference than to a raw pointer, except that the address of said reference is obtained (like if it was "ref" behind the scene, and "this" expanded to "&amp;ref") And also I really don't see what using static methods with a first param would bring to the table (and at that point you could as well use plain C, but well, that's even an other story). If that's to be able to see explicitly where members are accessed there are other ways that do not neuter the language. Plus honestly destructing an object in the middle of the call of one of its method is kind of rare and IMO best to be avoided (unless the design mandates it is needed and the design can't change). From a purely logical point of view it is not that much different than other forms of use after free, so short of sound lifetime analysis you won't get it by merely syntax tricks anyway.
~5 million characters? How?
Template metaprogramming at its finest. :-) Mind you, this was over a decade ago so hopefully it would not be so bad today, but on the other hand today we all have reliable access to native lambdas in the language so there is arguably no longer a need for Boost Lambda.
How easy is it to move to newer versions of clang or gcc?
Even in lambda capture "this" is not really a raw pointer syntactically, there are special rules that apply to it. (And it is like usual in C++, a complete hell when you go into the details, like what happens when you use templated lambda with auto params... :/ ) But this is not even a problem specific to lambda captures; the problem is that C++ does not allow for sound lifetime analysis. You can reach that class of issues by tons of way, and capturing "this" for too long in a lambda is only one of them, but pretty much every time you get a pointer or a ref to something you can obviously keep it for too long in one way or another. It might be slightly worse when getting the ref/pointer is implicit in the program source code, I concede.
you realize these are runtime enforced if at-all &amp; enabled using C &amp; C++. In any case it's not about a notion of type A better push-back would be that C and C++ need preprocessors which enable them to circumvent the limitations of the core language
What do you think about these books?
&gt; technically it's already in the language Lambdas are "instantiated" as part of the enclosing templated entity (notably, this causes unintuitive interaction with `if constexpr`, see https://stackoverflow.com/q/55909018/4672588). Local templates should probably be done differently.
&gt; The borrow checker itself really only started to become ergonomic with the non lexical lifetimes. That's somewhat of an overstatement IMO. Sure it is nicer now, but it was kind of okay before NLL, and it is not even a huge revolution with NLL. But anyway that was not the point of what you are replying to: even before NLL the borrow checker was (intended to be) sound; C++ lifetime profile can not be. And of course it impacts the ergonomics, but even with NLL Rust rejects some valid programs, and maybe if something even better than NLL is found and implemented, we already know that it will *still* reject valid programs (but less). And one fundamental aspect of Rust (single writable ref) actually rejects tons of valid programs, and can only be improved by tiny margins. On some other aspects the C++ does likewise (that is the very point of anything involving static typing...), but typically far less (plus some implicit static type conversions are insane for historical reasons, reducing the value a bit) &gt; C++ isn't going away, so efforts like the cpp core guidelines, GSL, and the lifetime profiles can only be a good thing! I completely agree and of course even unsound static analysis is better than nothing, especially given we have a gigantic corpus of C++ code that will not disappear and that can benefit from any amount of additional checking... But I don't want it to induce a false sense of security: it is more like tests - except you don't have to write them yourself - in the sense that it can only show you some bugs of this class, and not "prove" that there are none.
Honestly a lot of the Packt books are garbage, you can hear the Indian youtuber through the pages. Out of that collection, Modern C++ Challenge and High Performing C++ are probably the only books I would pick up. Also, the majority of those books have been given away for free on Packt at some point. If you interested in a few of these, or even 5 - wait for the very frequent Packt Pub sale where everything is $5.
My bad, as my edited comment says I completely blew up what happened in my mind since it happened so long ago.
Hey, 52400 is still a shit load I work with boost::hana most days so I sympathise to some extent
&gt;I find it super ugly for something that isn't the class to access a member with any kind of prefix or suffix like this regardless of the specific convention. Yes I suppose it's effective to just avoid doing that entirely. In my current project I find I am doing this a lot to avoid getter functions. I'm not really certain if it's cleaner in my particular case or if I'm just lazy.
Yocto abstracts away the compiler for the most part, so at a very high-level it's just a matter of updating to a new Yocto release (which means updating a handful of git repositories that comprise the "metadata"). See for example the upgrade notes here: https://www.yoctoproject.org/docs/2.6.1/ref-manual/ref-manual.html#migration-2.6-gcc-changes. This will also bring with it updated system components. Where it might get tricky is having to update any components you yourself have added. But this is usually no harder then what it took to add the component in the first place. So long story short, it's pretty easy once you've gotten a hang of Yocto in general.
You literally posted total nonsense above and are now complaining about downvotes.
Since python has a huge overhead on the simplest functions, even print. You never really knows what's going to be called. You believe it's a print, but it's creating a FILE* opening and parsing the file, passing it through a dep to check what it says and so on. You do a lot more than just printing something. In C++ you more than less know exactly what's going to be called. But still, the only true way is to code in .asm.
&gt;The Return Of The Self ///////////////////////////////////////////////////////////////////////////// class Value final { public: Value() = default; explicit Value(int x) : self { x, 1 } {} auto x() const noexcept -&gt; int { return self.x; } auto setY(int y) noexcept -&gt; Value&amp; { self.y = y; return *this; } private: struct Self final { int x {}; int y {}; } self; }; ///////////////////////////////////////////////////////////////////////////// class Pimpl final { public: Pimpl(); ~Pimpl(); explicit Pimpl(int x); auto x () const noexcept -&gt; int; auto setY (int y) noexcept -&gt; Pimpl&amp;; private: struct Self; struct Self* self {}; }; ///////////////////////////////////////////////////////////////////////////// struct Pimpl::Self final { int x {}; int y {}; }; Pimpl::Pimpl() : self { new Self } {} Pimpl::Pimpl(int x) : self { new Self { x, 1 } } {} Pimpl::~Pimpl() { delete self; } auto Pimpl::x() const noexcept -&gt; int { return self-&gt;x; } auto Pimpl::setY(int y) noexcept -&gt; Pimpl&amp; { self-&gt;y = y; return *this; } /////////////////////////////////////////////////////////////////////////////
Well, it's called a joke, but I don't have the time to really explain the mechanics of those at the moment.
Well it's not just different styles, it's two completely different things. Objects and pointers are different things. In short, `stack-&gt;push()` is equivalent to `(*stack).push()`. I don't mean to be condescending, but it seems to me you'd benefit from reviewing the basics of pointers
Don't feel bad you're not alone. I have lots of experience with Python and a few other interpreted languages like Matlab which I've used extensively in engineering data analysis kind of applications. I also use Fortran 90/95 for development of more high-performance computational research codes. I tried to learn C++ because I wanted a more solid object oriented general purpose language under my belt, but I found it to be like an order of magnitude more difficult to learn. I have yet to implement anything that wasn't sort of trivial in C++ myself.
Actual URL: https://www.humblebundle.com/books/programming-packt-books PSA: This user is a lousy, low rent Humble Bundle "partner" spammer. Report this user and, if you've got the time, report them at Humble Bundle as well at the following URL (the partner here is "purplehub"): https://support.humblebundle.com/hc/en-us/requests/new
This is the best summary for me. Thank you!
For the future, this type of direct question should really be posted in r/cpp_questions, whereas this sub is more for general discussion.
&gt; more for Thank you i'll pay attention for that.
Is that a trick? I thought that was the general way to use it. First error is the error, the rest is spewed out random characters 95% of the time caused by the first error.
sorry, I'm really new to c++, but why is he getting downvoted, what is wrong with this site?
Think of just passing a string or array to an API...
&gt; As in you're writing python that calls uses c(++), yet you can jump into and trace the c? I'm referring to [exactly that](https://docs.microsoft.com/en-us/visualstudio/python/debugging-mixed-mode-c-cpp-python-in-visual-studio?view=vs-2019). I'd love for this to be possible on linux, but it doesn't seem possible.
There is a non-zero chance that build systems would kill modules though.
Yup, and just like the real world, C++ was never considered hard back when I learned it. Itâ€™s just what all programming was like. Itâ€™s a matter of perspective. Itâ€™s like it you grew up in the 70s before personal computers. You donâ€™t consider it a hard way of living. Itâ€™s just what youâ€™re used to, and certain things are just a hell of a lot easier now.
I think the former might even be an additional (experimental?) compiler switch.
lots of people have mentioned the lack of a stable C++ ABI, but the implications are vast for dealing with cross-language boundaries. Many languages that google use internally (Java, python, Go, even C++ itself) can speak C's ABI directly and load whatever .dll/.so you need upon running the program. C's stable ABI means easy FFI. If you write a C++ library and expose a C interface, your C++ code is now callable from all those languages (relatively) without a hitch. If you expose only a C++ interface, you can either only use C++, or you'd have to use SWIG or something.
I'm the exact opposite to you, OP. C++ was my first language and I now want to learn Python. Wish me luck!
Just wait until your first memory leak.
Wait until you gave a template error
Can be, but in a lot of cases it is overkill.
The most important reason is the fact that C is the de facto standard for a foreign function interface. Python; Haskell; heck, even C++: they all support libraries with C API. I think if you pick your favorite language (besides C++), you'll find it supports a C-based FFI. On the other hand, exporting a C+ API to another language is difficult and likely requires exposing a C API anyway. (The only exception I can think of is pybind11 for C++ to Python).
Aha, the steps are kinda the same give or take, sure. But that's not what's the problem with defining and using the dependency. Because of the build systems' zoo, we can't define and pass options and flags in a unified manner. We can't resolve requirements automatically, everything should be checked manually. Cross-building is especially broken for no good reason aside from sticking to old ways. As I said before, the lack of intermediate formats is what gives us the fractured ecosystem.
Yep, I have used pybind11. And it really feels good to use than python C API. (I know pybind11 is made on top of python C API though)
But without some form of type-erasure the entire class would need to be a template, not just the registration function. I.e., how would you persist the lambda you pass in?
What's your experience? What should be "fixed" with Windows to make it "right"?
Ah yes, reminds me of college. Do anything, get hit with the segfault bat.
Afaik itâ€™s still going. Error handling in general is controversial so there were a lot of opinions. https://issues.isocpp.org/show_bug.cgi?id=29
If you have a C-API DLL, you don't need to even have a project to make bindings. Any random Python dev can start calling your code immediately through Python's built-in ctypes library. Similar features exist for other languages, but do not work with C++ APIs.
Local classes in functions are useful in applications that make use of the visitor pattern. You define a local class with all the necessary `visit` functions and you have all the necessary algorithms on your object hierarchy right there in that one function.
My guess is, it's a lot of ceremony for not much tangible benefit in the way of handling errors. C++ isn't quite there yet when it comes to functional practices like this.
I copied and pasted a list of quoted strings into my code once and it gave me syntax errors. I though "oh, there must be an unescaped quote in the middle there somewhere," but... nope. I looked it over 20 times and there was no error. It turns out that they were curly quote characters which, with the font I was using, looked the same.
It's C++ templates that give nasty ass errors. I started with vanilla C before adding C++ ... glad I didn't jump directly into C++.
u/nwordcountbot last_useful_man
Local template alias is also forbidden, since no local templates are allowed. It would have been useful many times for me.
u/nwordcountbot u/last_useful_man
Thank you for the request, comrade. last_useful_man has not said the N-word yet.
Please elaborate on call methods.
i'm pretty drunk atm, but how about storing them in an array of strings and afterward printing them with a for loop? (I this could work maby think about using vectors (vector.h) as they bring some cool features (view cpp reference))
*screams in day job*
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
Thanks.
Look for the first error. Subsequent errors may be caused by the first one. If the error is showing you code you didnt write most likely you are calling this code (maybe through many layers)... focus on YOUR code because the error is there.
ALL the intro classes for CS at my school use C++. I felt like a total dumbass until I realized even experienced programmers struggled with it. Yeesh.
Might as well be for some people new to programming. I've had a handful of mentees conclude that their standard lib is wrong on some level.
Boost::beast is great from my end for using websockets, even if its a little complex to set up
I remember when I was having a play about with z3, I was using it to solve a problem that took 5-10 seconds in python. I needed it to execute in about 2 seconds overall due to me using it for an exploit for a game (with the developers ok) When I ported the z3 code from python to C++ (1:1 translation), even though python basically just shells out to z3, and my c++ code was doing the exact same, all the variability in my solve time went away and it solved consistently in 5 seconds I don't know that much about python so I can't tell you exactly why it did this, but it certainly made quite a big difference even though it was just basically calling quite a lot of c-api functions
C binding are easy, meaning you can use that library from Python or any other language. C++ bindings are hard.
[https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)
I agree. It seems people are assuming that typing "m_" first is useful because it will populate autocomplete with member variables? I feel like I usually have a pretty good idea of what I'm looking for ahead of time, so it is slower to have to type "m_" before the first character.
Yeah, Rust is pretty cool for errors, it sometimes tell you things that makes no sense but I'd say Rust is incredible in this case.
I like either monads. This is basically that. But yes, there is no magic bullet.
unless it is implicitly convertible to an int.
It is definitely not the committee's job to make a standard C++ ABI. Would it be the same ABI across OSes and CPUs (Intel, ARM, ...)? Obviously not. The committee could do some things to help, but it is really beyond the language.
&gt;I really don't see what using static methods with a first param would bring to the table The idea is that you wouldn't pass a native `this` pointer as the first parameter, but rather one of the safe smart pointers provided by the library. &gt;short of sound lifetime analysis you won't get it by mere syntactic tricks anyway. If you don't have a "lifetime analyzer"/"borrow checker" you can resort to run-time safety mechanisms (like, for example, the GC languages do, right?). The library provides (smart) pointers that use various run-time safety mechanisms. In the case where your pointer is a local variable (or function parameter) and you don't need it to be "retargetable", you don't really need a sophisticated borrow checker to avoid run-time overhead. Most of the compile-time restrictions needed to ensure safety in that case can be implemented in C++'s type system, so that option is available as well. This strategy of avoiding the use raw pointers/references, including the (implicit) `this` pointer, might be rather unconventional in C++, but you know, it is valid C++, it's effective (if verbose), and it's perhaps not that strange to those familiar with certain other languages. As you alluded to, I would image it might even be more intuitive to someone coming from C.
Interesting, there are good points there but they had a commit-or-abandon approach to it which I don't understand. std::optional is not widely used in the standard and they still made it.
The use of expected/result/outcome is still cumbersome. A more thorough solution would be zero-overhead deterministic exception. It does same thing as std::expected, but with common exception syntax.
Why do you think there is no much tangible benefit for it? You mean that they just want me to use exceptions or that there are equivalent ways?
See also https://github.com/tvaneerd/cpp17_in_TTs and feel free to help with https://github.com/tvaneerd/cpp20_in_TTs - C++20 is going to be a lot of work!
 T f() throws(E); seems to be preferred syntax over expected&lt;T,E&gt; f(); because the former does not obscure the return type. Both are much better than returning error code, admittedly.
Aye, if that is a problem then std::function might be a better option.
 template &lt;typename Derived&gt; class Self { Derived &amp; self; public: Self() : self(*this) { } }; eg: class Foo : Self&lt;Foo&gt; { int x; int getX() { return self.x; } }; P.S. this is not a good idea.
You should not put prefix/suffix on public member variables. As a caller, you expect just `pt.x` not `pt.x_`. Public members are typically accessed more from outside the class than within, so you won't see `x` on its own much (or maybe only in small member functions where it is obvious). For private/protected, sure people like the differentiation, but it does suggest that your member functions are too long. If you function fits on one screen, it is not hard to tell which variables are local or passed in (and hopefully you have no globals!). Mostly, just get comfortable changing styles - ever place you work will have a different one. â€œWhen one has no form, one can be all forms; when one has no style, they can fit in with any style.â€ - Bruce Lee
Google's c++ api is ugly, so they choose to publish c api only.
Impossible. Python will keep doing shit secretly behind your back and then you explicitly do the same thing that you think you need to be done but then everything is fucked
Because they consider it too much effort to provide and document another stable API in addition to the C-API and because they limit themselves to c-features anyway, a thin c++ wrapper around the c-api usually doesn't provide all that much benefit anyway.
I agree about the syntax. I just don't think it has to work only with exception mechanisms (try catch)
Sounds like you need to look into RefCell
I would love to see different exception-handling mechanisms be discussed more, as zero-overhead exceptions would level the playing field performance-wise. What is the difference between an error, an exception and a contract violation? Are exceptions meant to be "exceptional"? What is "exceptional"? When should one use which mechanism?
FYI, here's an (imo excellent) implementation of the proposed std::expected (with a few extra bells and whistles): https://github.com/TartanLlama/expected
Nothing of the sort, AFAIR the paper had support, but there were several details to be resolved, so that it was not ready enough to put it in before the deadline for 20. So, to answer the question, the committee did not \*not\* want it in the standard, we just didn't manage to \*do\* put it in, yet.
What is z3?
AFAIK functions exception specification is deprecated. That's because it's not manageable. Basically, when function says noexcept, it might throw anything.
Its a theory solver tool, basically you can stick equations into it and then ask it to solve stuff, or prove properties about the code Eg, given x ^ constant = some_other_constant, itll solve for x (assuming you provide the constants) In my case I was using it to reverse engineer seeds for xorshift128+ https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c7b3w7/wrong_syntax_in_example_in_programming_principles/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I have few specific objections, which I'll list at the end of this message. My main concern is that, in the *general* sense, co-routines or otherwise, the C++ community has to live with the consequences of decisions made by the C++ committee for a very long time. E.g., there are still many code-bases that suffer the woes of std::auto_ptr, and likely will be for another decade or more. And std::auto_ptr was a purely standard library thing. The damage that it could cause was limited because crappy behavior could be replaced with custom smart pointer implementations that had better semantics. But language features are a real wicked thing. Sometimes we get lucky, with things like "throws()" where they aren't really harmful. Other times we won't be so lucky. E.g. See various behaviors that we blindly yanked from C, like how a char[] decays to a pointer in function overload resolution, even if there's a template that accepts a reference to char[]. Quite the brain-teaser on how to get that one to work properly... because char* and char[] ***ARE*** different, from the human perspective, even if the compiler doesn't agree. But co-routines are expected to be the foundation of a lot of upcoming standardized functionality. In fact, I just talked to a library implementer on github about how they're not even going to consider offering async functionality in their code until co-routines are part of the language. The same argument applies to Concepts. And the same argument applies to Modules. It's deeply worrying to me that so many people are so blindly asking to push forward with the big features for C++20 despite so many dissenting voices offering justified criticism, with examples of how thing's aren't entirely sunshine and rainbows. Again, I haven't been paying attention to co-routines. My attention has been on Modules. As a guy who's been eyeballs deep in custom build systems for the last 5 years, I don't think that Modules buy me jack squat, but they do significantly increase the amount of tooling complexity that I would have had to deal with, were I still at that job, while also increasing the runtime cost of the tools. When I was seriously investigating how to use Modules to improve build times, I really did come to the conclusion that they were a solution looking for a problem. But who knows, I'm only human, and could have simply missed a key insight. I do know that the decision I made for my team was that we were not going to use Modules, because it would have been bloody horrible with no real improvement. I could be mistaken, but if memory serves, there was a person on the standards committee (or at least context clues at the time made me think that they were, I could be wrong) that said something to the tune of "Prove that this operation related to Modules can't be done in linear time". Which is a rather "prove a negative" kind of situation, and made me lose a lot of respect for the Modules proposal. Anyway, onto co-routines, as you asked. 1. The keyword's chosen "co_await", "co_yield" and so on are horrible. Full stop. Honestly, I'd really rather not see the co_routines feature *at all* than see the language adopt **language keywords** that start with underscores. What's next, _Bool? *ugh*. 2. Whether a function is a co-routine or not depends on the guts of the function, not the declaration of it. 3. Insufficent machinery to provide support for managing the heap allocation behavior. Very important for applications that are designed to have one or more threads conduct zero blocking operations for performance. (I'm aware that there is support for custom allocator new, I just think there's too much magic voodo happening for using custom allocators to be reliable) 4. Lack of support for variadic templates and integration into the whole set of constexpr shenanigans that we've been getting into the last few versions. 5). A general feeling of unease with how much *additional* language level functionality has explicit ties to things from the std:: namespace. 6) And finally, I just straight up don't see what this buys me. From my perspective, it looks like coroutines doesn't actually do anything to the language that a pre-compile step couldn't do, like the "Mock Object Compiler" from the Qt framework. I want to expand on 2 and 5. For 2 -- this is a serious concern for me. I tend to work in high performance computing / networking, where we're very particular about controlling the behavior of the program very carefully. Unless something can be guaranteed to happen at compile time and/or be optimized out, I want deep control over it. The possibility that a function can turn into a co-routine without the caller having a clue is a big red flag. It means that some jr employee can surreptitiously change from "return" to "co_return" (or whatever) and suddenly I've got heap allocations happening that weren't happening before, and a function that previously wasn't saving any state is now saving state in an unknown location. It's just a design that's badly aligned with control freaks like myself. C++'s history is littered with "Huh, well, now we know *shrug*" moments. Take the explicit keyword, for example. It never should have existed. It should have been the implicit keyword instead. std::string(char*) being an implicit conversion causes untold amount extra work compared to a universe where std::string() wasn't implicitly constructible from "". It's also rather amusing that the explicit keyword can be applied to functions with more than one mandatory argument, though I've never figured out why other than convenience. Consider the explanation that the OPs blog link gave on the override keyword. We can mark a function as overriding a base class function, but we can't say "this function *DOES NOT* override a base class function. It's just the whole story of the C++ language. We keep pushing new features, but each such new feature only implements a portion of the full story. Sometimes we get lucky and there's room for the other part of the story to be inserted properly, and other times we don't and we just never get that missing piece. Explicit vs. implicit can't be fixed without something like MetaClasses providing us a knob that the library author can tweak, or programmers diligently ensuring that the explicit keyword goes everywhere it should. Which is a tall order. Anyway, my last thought is about the language continuing to add explicit references to the std:: namespace. I suppose that at this point, the cat is *way* out of the bag, but it would have been nice if all of the more recent features, such as range-based for loops explicitly depending on std::begin() and std::end(), could have been avoided. (Well, ok ok, they don't expect "std::begin()" and "std::end()", but they instead call "begin() and end()" using argument-dependent-lookup. Which isn't *quite* as bad, but it's basically the same 'language depending on library' annoyance). From my perspective, range-based for loops could have been implemented as a macro, if only C++ macros had the ability to do some minor syntax rewriting. I mean, just look at what range-for is defined as in C++20: { init-statement auto &amp;&amp; __range = range_expression ; auto __begin = begin_expr ; auto __end = end_expr ; for ( ; __begin != __end; ++__begin) { range_declaration = *__begin; loop_statement } } with an example like such: for (T thing = foo(); auto&amp; x : thing.items()) { /* ... */ } // OK If the C++ pre-processor macro system had been improved upon such that it supported full Abstract Syntax Tree manipulation, then this feature could have been delivered as an AST macro provided by the standard library, and not something that was part of the actual syntax of the language. Perhaps at that point it wouldn't necessarily be the standard library, so much as the "Standard AST" ? Donno. Not sure the distinction would matter really. (Notably, AST macros would also allow us to stop having to write compiler specific plugins to get fun compiler enforced rules) So I see co-routines as just more of the same sillyness. Where we're making the (poor, in my opinion) implicit assumption that C++ always has access to some functionality from the std namespace. One such example is std::coroutine_traits, where the code written by a human doesn't point out that there is this relationship. The human's simply supposed to know. A total "layering" violation if there ever was one.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/c7b681/wrong_code_examples_in_programming_principles_and/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Just because it can be done another way from a mathematical perspective doesn't have anything to do with "I have this existing code. I'm not allowed to break backwards compatibility. I can't spend 3 months on this. If I could just have a template class local to this function, i'd be done in an hour".
The code sample uses new deterministic exceptions as proposed by Herb Sutter. Not the old deprecated function exception specification (it uses throws instead of throw)
I've tried to use local classes at least 5 times in the last 2 years, only to be yanked back to reality that it doesn't work. They can be useful, but it's very context specific.
What error do you get when trying it in VSCode on linux?
The ubderlying mechanism is different from classic exceptions. It doesn't use RTTI under the hood and it doesn't bloat the executable. Additional syntactic sugar is proposed as well f.e. there is 'try' expression syntax similar to Rust's ? operator
&gt; you realize these are runtime enforced Linters run *before* compiling.
I've enjoyed using Boost.ASIO, am using Boost.ProgramOptions, Boost.Process, and am about to start using Boost.Log. In the past, at a previous job, the only reason why about half of the C++11 functionality we were able to use could be done is because I was able to convince the *ancient* version of Boost that they were using to let me re-combine the Boost type traits code into the missing pieces. That really saved our bacon. They also used Boost.asio as the fundamental building block for a whole crapload of code. Millions of lines, highly abstracted away. Boost is great. Boost is also horrible, what with it's disgusting template soup error messages. Win some, lose some *shrug*.
1. They were accepted into the C++20 standards draft. 2. They're not going to solve most of the things you hope they will.
And also automatic propagation of unhandled exceptions. A key feature for me in any error handling mechanism is that it be very hard for me to forget to handle an error.
Any hope for epub version? Calibre fails to convert that pdf it to .epub...
You missed a significant part of the string. /home/ryan/Arduino/libraries/esp8266-redis/Redis.cpp:187:51: error: could not convert '(&amp; g_TypeParseMap.std::map&lt;_Key, _Tp, _Compare, _Alloc&gt;::operator[]&lt;RedisObject::Type, std::function&lt;RedisObject*(String)&gt;, std::less&lt;RedisObject::Type&gt;, std::allocator&lt;std::pair&lt;const RedisObject::Type, std::function&lt;RedisObject*(String)&gt; &gt; &gt; &gt;((*(const key_type*)(&amp; typeChar))))-&gt;std::function&lt;_Res(_ArgTypes ...)&gt;::operator()&lt;RedisObject*, {String}&gt;(String((*(const String*)(&amp; substr))))' from 'RedisObject*' to 'std::shared_ptr&lt;RedisObject&gt;' and no, it's not a single type, unless i'm missing some context here. What this looks like is the compiler attempting to tell you how it derived the error that it's complaining to you about. That, or it's spitting back out the line of (insane...?) code that was causing the error. My best guess is that g_TypeParseMap is a variable in the applications' code. The type of that variable is: map&lt;_Key, _Tp, _Compare, _Alloc&gt; With Key= RedisObject::Type, _Tp = std::function&lt;RedisObject*(String)&gt;, _Compare = std::less&lt;RedisObject::Type&gt;, _Alloc = std::allocator&lt;std::pair&lt;const RedisObject::Type, std::function&lt;RedisObject*(String)&gt; &gt; &gt; The function having problems was: operator[] And the parameter given as an argument was derived like: ((*(const key_type*)(&amp; typeChar))))-&gt;std::function&lt;_Res(_ArgTypes ...)&gt;::operator()&lt;RedisObject*, {String}&gt;(String((*(const String*)(&amp; substr)))) Where (*(const key_type*)(&amp; typeChar)) Is a conversion from typeChar to reference-to-key_type. -&gt;std::function&lt;_Res(_ArgTypes ...)&gt;::operator() ??? Calls std::function? The std function returns RedisObject* And accepts a "String" as it's argument? Whatever {String} means And apparently this "String" type is gotten via: String((*(const String*)(&amp; substr))) I certainly hope no one's ever written code this ugly by hand :-). But if you want to see a more complicated data type, look no further than : https://github.com/redboltz/mqtt_cpp/issues/297 Some code I was debugging the othe rday. #5 0x5555556db5db in boost::multi_index::detail::ordered_index_impl&lt;boost::multi_index::member&lt;Broker::session_state, std::variant&lt;std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt;, std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::ssl::stream&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt; &gt;, &amp;Broker::session_state::con&gt;, std::less&lt;std::variant&lt;std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt;, std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::ssl::stream&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt; &gt; &gt;, boost::multi_index::detail::nth_layer&lt;2, Broker::session_state, boost::multi_index::indexed_by&lt;boost::multi_index::ordered_unique&lt;boost::multi_index::tag&lt;Broker::tag_client_id, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, boost::multi_index::member&lt;Broker::session_state, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, &amp;Broker::session_state::client_id&gt;, mpl_::na&gt;, boost::multi_index::ordered_unique&lt;boost::multi_index::tag&lt;Broker::tag_con, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, boost::multi_index::member&lt;Broker::session_state, std::variant&lt;std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt;, std::shared_ptr&lt;mqtt::endpoint&lt;mqtt::tcp_endpoint&lt;boost::asio::ssl::stream&lt;boost::asio::basic_stream_socket&lt;boost::asio::ip::tcp, boost::asio::stream_socket_service&lt;boost::asio::ip::tcp&gt; &gt; &gt;, boost::asio::io_service::strand&gt;, std::mutex, std::lock_guard, 2ul&gt; &gt; &gt;, &amp;Broker::session_state::con&gt;, mpl_::na&gt;, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na, mpl_::na&gt;, std::allocator&lt;Broker::session_state&gt; &gt;, boost::mpl::v_item&lt;Broker::tag_con, boost::mpl::vector0&lt;mpl_::na&gt;, 0&gt;, boost::multi_index::detail::ordered_unique_tag, boost::multi_index::detail::null_augment_policy&gt;::erase(boost::multi_index::detail::bidir_node_iterator&lt;boost::multi_index::detail::ordered_index_node&lt;boost::multi_index::detail::null_augment_policy, boost::multi_index::detail::index_node_base&lt;Broker::session_state, std::allocator&lt;Broker::session_state&gt; &gt; &gt; &gt;) (/root/src/cloud-connector/cloud-connector+0x1875db)
Can you provide a link to relevant discussion on why constexpr is forbidden? I am curious to know more.
The difference, I think, is that if all return values were warned noisily by default, and the program needed to be adjusted manually to stop warning by augmenting the function causing the complaints, the list would never be out of date, because the function comes with it's annotation directly. Still a lot of work, but at least not quite as bad as PCLint.
A `[[nodiscard]]` slapped on `std::expected` would help for those cases where the output is not that interesting. Rust does the same thing with its `Result` class. It's not perfect, as you can simply stash the thing in a `vector` and forget to handle it, or other silliness, but it comes very close to being unforgettable.
In general, the agreed upon meaning of "exceptional" is "Don't use exceptions for control flow". That is, it's bad for a `map.find(key)` to throw if the value is not present because it becomes cumbersome at the site of use: void Class::something(Key key) { std::optional&lt;Value&gt; value_impl; try { value_impl= this-&gt;map.find(key); } catch (NotFound const&amp;) { value_impl= create_value(key); } Value value = std::move(*value_impl); // use value. } Compare with a proper "optional": void Class::something(Key key) { Value value = this-&gt;map.find(key) .cloned() .or_else([&amp;key]() { return create_value(key); }); // use value. } One is boilerplatey and clutters the scope with a useless `value_impl`, the other just flows.
'Self-derived' changes rules little, but it seems that you need more a name changes compare to 'self-member'. Main 'problem' is same what I have with keyword 'this' (with context that not use a prefix or a suffix with private members or with parameters names): it's only up to me (and perhaps compiler's warnings) responsible to reference the right thing, so I want to be forced to use 'self.' when I want reference to a class private members. template&lt;typename Derived&gt; class Self { protected: Derived&amp; self; Self() : self(*this) {} }; class Foo : Self&lt;Foo&gt; { int x {}; int y {}; int x() { return self.x; } // error: redefinition of 'x' // as different kind of symbol int getX() { return self.x; } void setY(int y) { int z = y; y = z; } // warning: private field 'y' is not used }; class Value final : private Self&lt;Value&gt; { public: Value() : Self { *this } {} explicit Value(int aX) : Self { *this }, x { aX }, y { 1 } {} auto getX() const noexcept -&gt; int { return self.x; } auto setY(int y) noexcept -&gt; Value&amp; { self.y = y; return *this; } private: int x {}; int y {}; };
Thanks, good to know that it's not considered bad practice. As an intermediate cpp developer I would really like to know there is a recommended way of doing this, even if it's not integrated tightly into the standard. Ive seen many times that if someone asks such thing, the response would be: "you should think twice before not using exceptions" and in my view, this is not a good answer.
Rusts ? Operator is interesting, it captures some uses of often written macros. I need to experiance with it more.
The problem with error handling is that there are already different styles and mixing them is impractical. I know Herb Sutter has spoken in the past about how there should be one universally correct way to handle errors in the language. Possibly, this is the stance of the committee and they are unwilling to introduce another way into the language without being sure it is exactly what it needs to be. std::optional might not have wide adoption but it elegantly solves problems without negatively impacting others in a significant way.
Both look "boilerplatey" to me, but it doesn't answer the question anyway. Where do you draw the line between "exceptions" and "control flow"?
*and the option to actually signal error state inside a constructor, which is required for using the standard library.
It's a matter of usecases; which requires analyzing how your API is used. If a caller can be expected to immediately `catch` the exception, then the exception is used for control-flow rather than to signal an "error". In this sense, I like the distinction that can be found in newer languages like Go and Rust, where an error is for something *possibly recoverable* while a panic is for something *unrecoverable* (close to an `assert` in C). For example, I used to work on a variety of servers written in C++, and the guideline was to use an exception only if it was impossible to complete the request as asked; for example, when the database connection was KO. At the top-level of the application was a single try-catch which would catch those exceptions and return a generic error message to the caller (similar to HTTP 500). All other "errors" where signaled with errors, containing a detailed error message: invalid ID, missing some piece, etc...
This could be solved with an easy way to handle exceptions inline without opening up a new scope block, something along the lines of Perl's `or die()` idiom: Value value_impl = this-&gt;map.find(key) or create_value(key);
It can also easily be proven that you don't even need a C++ compiler, as any idiom that uses C++ can be implemented by toggling hex codes on a front panel. Doesn't mean that that's how we want to work though.
Use raw pointers. Just like, you know, memcpy does.
it's basically same, iteration and copy. Some compilers could even recognize these memory copy loops and replace them with memcpy.
Interesting. Just to check, you're using `^` as a bitwise operator, not exponent?
Yep, its a simple example but it can solve non linear things as well (like operator+) The actual equations I was using in this case were uint64_t state0 = 134125447415289812; uint64_t state1 = 182415234512781923; uint64_t xorshift128plus() { uint64_t s1 = state0; uint64_t s0 = state1; state0 = s0; s1 ^= s1 &lt;&lt; 23; s1 ^= s1 &gt;&gt; 17; s1 ^= s0; s1 ^= s0 &gt;&gt; 26; state1 = s1; return state0 + state1; } Where all you have is the result (well, 3 consecutive outputs) of the equation, and you want to find s0/s1. Its extremely hard to do by hand!
Can you show an example? If I have T value; void * ptr = reinterpret_cast&lt;void*&gt;(&amp;value); memcpy(ptr, ..., size); and in the memcpy I do: void memcpy(void* dest, void* src, size_t size) { char* dest_ptr = reinterpret_cast&lt;char*&gt;(dest); for (size_t i = 0; i &lt; size; ++size) dest_ptr[i] // UB for some T = src_ptr[i]; }
Are you saying that exceptions should be used solely for signaling unrecoverable errors? I think I've heard this argument before, but where does that leave us in terms of error-handling strategies? And why is there a push for zero-overhead exceptions if they are to be used rarely anyways?
Are you saying that exceptions should be used solely for signaling unrecoverable errors? I think I've heard this argument before, but where does that leave us in terms of error-handling strategies? And why is there a push for zero-overhead exceptions if they are to be used rarely anyways?
My understanding is that it's not possible to do mixed mode debugging in vscode, is this incorrect?
Can you show how ? Everything I've tried has undefined behavior.
'''incrementing pointer to sub-object might point past its end''' Well it will if you give too big a size. As long as it stays within the bounds of the largest union member you will be alright. The point you seem to be ignorant of is that memcpy doesn't care about the types of objects you copy, it just dumps *size* bytes across.
I'm pretty sure that the fact that the pointer points at subobject `a` doesn't prevent it from also pointing at representation bytes of `T`. What if I have `union T { char a; char b; };`? Which subobject is being pointer at then? Surely it's both of them?
There's a clang-tidy checker that warns about discarding \`std::remove\` (among with some other std lib functions') return value: [https://clang.llvm.org/extra/clang-tidy/checks/bugprone-unused-return-value.html](https://clang.llvm.org/extra/clang-tidy/checks/bugprone-unused-return-value.html)
&gt; incrementing pointer to sub-object might point past its end It might, but if you dereference a pointer past the end of an object, then that's UB.
Indeed. One key different between C++ and Rust is that Rust is expression-oriented; nearly anything in Rust is an expression, rather than a statement: - A block is an expression, an extension that gcc and clang provide. - `if` is an expression, obviating the need for a ternary operator. - `match` (the equivalent of `switch`) is an expression. In this case, if `try/catch` was an expression, you could simply write: Value value = try { this-&gt;map.find(key) } catch(NotFound const&amp;) { create_value(key) }; I have some doubts that C++ will move in this direction, though, so a library-based (rather than language-based) solution such as chaining on optional seems easier.
Easy, use std::memmove. No UB? Check. No memcpy? Check. See, that's why rules lawyering is so annoying to people. But just in case there is a slim chance you are not trolling the subreddit (or such person may see this thread), here is the serious answer: memcpy/memmove family of functions is inexpressible by other means without violating some sort of a corner case somewhere (which is absolutely impractical, since typically you write your code to be executed on real-world CPUs and not some abstract C++-machines). That's why people who care about such things had to use memcpy for bitcasting if they wanted to stay strictly UB-free. Good compilers will optimize it out in release anyway, so it's generally as fast as doing any other trick, such as reinterpret_cast&lt;int&amp;&gt;(some_float) (this is an UB) or "int_float_union.f = f; i = int_float_union.i;" (this is also an UB), or something along these lines. But for the record: cast tricks are so wide-spread, that I doubt anyone will risk breaking it in the compilers, even for a good reason. Doing so will result in an enormous amount of code not working correctly. C++20 gave us [std::bit_cast](https://en.cppreference.com/w/cpp/numeric/bit_cast) for all practical casting cases. And memcpy is not going anywhere, so it's still good for copying stuff. Can we emulate memcpy-like functionality with bit_cast? I think that in some cases we can. If we have whole objects as sources, casting even something like "union T { char a; int b }" to "char[sizeof(T)]" should, if I read it correctly, downgrade undefined behavior to unspecified behavior if the T is in "a" mode (because there are multiple char[4] that correspond to this union). And since the compiler doesn't really know which mode T is in, you can realistically expect that it will just copy 4 bytes (so that it will also work for the "int" mode). You can find a loophole that if the compiler wanted to be nasty, and they knew that your union is in "char" mode, they could start randomizing inactive bytes just to make you angry. I can counter it by saying "the goal was to avoid undefined behavior, and this one is unspecified, so go away." Now, if you want to also emulate the interface of memcpy, I believe you have to just use memcpy (or any other function from its family). Seriously, it's there for a good reason.
Speaking of mypy, how do you annotate a type like `{ 'foo': [1,2,3], 'bar': False, 'baz': 'quux' }` or even a list of dictionaries?
&gt; Easy, use std::memmove. This definitely works.
Then you have falling into the trap of the byte order fallacy, you don't need to know your systems endian you just need to decode the bytes in the order that you need.
Slightly off topic but I really hope trivially relocatable gets in by C++23. It would definitely make me not think twice about using a unique/shared_ptr or reference wrapper. Of course I can use raw ptrs as needed, but I like the extra semantics of those types, whereas a raw ptr creates a lot more ambiguity when looking at code.
You can follow the link for details, or finish reading my post to figure out which practical cases I'm talking about.
Is there a paper for `bit_cast` ? The link only says that the _bits_ are copied, but provenance is not in the bits. So either `bit_cast` removes provenance information, or cppreference might be incomplete, which sometimes happens.
A basic loop would be fine with no UB within the constraints of memcpy itself. void memcpy(void* dst, const void* src, std::size_t bytes) { auto dst_p = reinterpret_cast&lt;char*&gt;(dst) ; auto src_p = reinterpret_cast&lt;const char*&gt;(src) ; for (std::size_t i = 0; i &lt; bytes; ++i) dst_p[i] = src_p[i] ; } Sorry if the formatting is crap, on my phone. Ps: in your loop you increment size instead of i.
That would suck
&gt; I think I've heard this argument before, but where does that leave us in terms of error-handling strategies? It essentially leaves you with regular return types: `std::optional`, `std::expected`, etc... &gt; And why is there a push for zero-overhead exceptions if they are to be used rarely anyways? First of all, the current exception mechanism implemented in the Itanium ABI (clang, gcc, icc, ...) and in Microsoft 64bits is called Zero-Cost Exceptions. It's a table-based mechanism where the cost of the "happy" path is zero... at run-time. In practice, the very presence of exceptions inhibits quite a few optimizations so it's not quite zero even then. Unfortunately, the issue with this mechanism is that the cost of the exceptional path is high (and hard to predict): look-up tables, unwinding run-time, etc... Developers working on embedded platforms are not too thrilled by the huge tables (10% to 20% more code), RTTI information, and bigger run-time (unwinding logic) required for all the machinery. Developers working on real-time or pseudo real-time applications are non too thrilled about this. Even if the only thing to do with the exception is scratching the whole thread and restarting, they need a guarantee on how long this whole process will take to ensure it matches their requirements. The idea of Herb Sutter, therefore, was to propose a different implementation mechanism for exceptions, which would essentially be implemented as return values but with first class syntactic support to make things convenient. It's unclear exactly where that proposal will go, of course. --- The proposal, however, does not seem to change the heart of exceptions. One of the key point of Go and Rust is that the exceptional execution path is invisible to the naked eye, which is bad. It's never clear at the call site whether a call can throw, there's no visual cue, making it somewhat hard when inspecting code to ensure that even if one of the dozens of function calls throws the function handles things correctly (not leaving half-baked changes behind). And therefore, for correctness reasons, it's better to just throw everything away rather than try to patch all the cruft the partially completed call could have left behind. *Note: Languages with immutable values are much less susceptible to this half-baked changes issue, obviously, so in such languages exceptions are much less fraught with peril. C++, however, is not such a language.*
&gt; Surely it's both of them? It's both of them. In that example one can't show the issue, but this one does: `struct S { char a; int b; }; union U { char a; S s; };`. There the `char*` points to the `char a` and `S.a` fields, but you can't increment it by one and dereference that to access `S.b`.
&gt; Ps: in your loop you increment size instead of i. Thanks, fixed!
You are wrong. Just wrong.
Read https://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing The relevant section is this: &gt;Type aliasing &gt;Whenever an attempt is made to read or modify the stored value of an object of type DynamicType through a glvalue of type AliasedType, the behavior is undefined unless one of the following is true: &gt; * AliasedType and DynamicType are similar. &gt;* AliasedType is the (possibly cv-qualified) signed or unsigned variant of DynamicType. &gt;* AliasedType is std::byte, (since C++17)char, or unsigned char: this permits examination of the object representation of any object as an array of bytes. According to it, it is always possible to reinterpret_cast an object to an array of bytes and read its representation, no UB there. For POD types (since they are trivially copyable) writing is also allowed through an array of bytes. See https://en.cppreference.com/w/cpp/language/copy_constructor#Trivial_copy_constructor
Sure. The problematic step is getting the array of bytes without invoking UB.
Resorting to run-time "safety" mechanisms can be better than nothing but is not a replacement for static analysis: sometime it will "just" replace an UB by a deterministic crash or an higher level logical bug, or introduce the need to add extra error handling code paths (and I count adding exceptions in those). In some limited cases it is fine to "arbitrarily" extend a lifetime though (ex: conceptually value objects - quasi-always fine, except sometime for gigantic ones), but those cases are far less at risk than entity, widget, or control objects, to begin with. Also at this point you really do not write stereotypical C++ and would probably benefit from switching to C# or Java or even JS (maybe with something like a C++ compute core that is less exposed to such risk and can benefit the most from C++ speed) The advantage of static analysis is that you know you don't have complicated runtime lifetime "extension" cases (with shared pointers), neither do you need extra error handling paths (like with weak pointers). That can be *extremely* neat, especially in a language that is RAII oriented (like both C++ and Rust are). Language with pervasive "shared_ptr" like things are typically not that much RAII oriented, and languages that have a full-blown GC even less so.
You are misinterpreting the standard and your memcpy is fine: that it is *possible* to interconvert a pointer to access a standard-layout member of union or first member of structure does not imply that all reinterpret_cast are *restricted* to this case, even less so when char is properly used to access the outer object representation.
Nice, I have also done this as well, https://github.com/jbaldwin/liblifthttp The main use case was to simplify the curl_multi_* functions via a simple to use event loop to make thousands of requests / sec as well as c++17 style api. It just uses libuv under the hood for the EL driver since that lib is available pretty much everywhere.
The standard says that the conversion happens. So where in the standard does it say that when you have a pointer of a sub-object, you are allowed to use that pointer to access other objects that are not part of that sub-object ?
The behavior is perfectly defined. You are giving to pointer interconvertibility a power it does not have. reinterpreting to char* is the correct way to access an object representation, and **if** you find a wording defect in the standard that would prevent that (that you did not do, for now), simply report it and it will be handled as such. But as far as practical matters are concerned, compilers won't voluntarily prevent the access to object repr using char just because of poor standard wording (if any such case exist -- because again: that would be a bug in the standard), so at this point it is purely theoretical mental masturbation to be afraid to use that code.
&gt; The behavior is perfectly defined. You are giving to pointer interconvertibility a power it does not have. reinterpreting to char* is the correct way to access an object representation, and if you find a wording defect in the standard that would prevent that (that you did not do, for now), simply report it and it will be handled as such. The standard is pretty clear: https://www.reddit.com/r/cpp/comments/c7btvz/how_can_one_implement_memcpy_in_standard_c/esely9o/
Oh my, I know I'm late to the party, but my master's thesis was similar-ish, but narrowed to STM32F4-Disco and focused on USB :D Great job!
You don't have a pointer restricted to a subobject. You have a char pointer to the object repr, that *also* can work on a subject, but that later fact is absolutely uninteresting given char is already powerful enough to do that even if the pointer interconvertion rule did not exist. That rule would hit you if you attempted to use something other that char. The standard says that "it is **possible** to obtain a pointer to one from a pointer to the other via a reinterpret_cast" -- not that all reinterpret_cast will be either UB or used in the context of valid pointer interconvertion, nor that there will be extra restrictions when pointer interconvertion can happen. Maybe the wording is not clear enough (that is a problem with natural language specs vs formal ones), but it is well known that you can access an object repr as chars, and there is no weird exception involving C legacy. So **if** you have more convincing evidence as for why it is **not** possible, then it is simply a standard defect, and will be fixed. For now I see nothing wrong.
And I absolutely disagree with your interpretation. I guess neither of us will change our mind at this point, so on my side I will stop now.
The standard says expr.static.cast.13: &gt; Otherwise, if the original pointer value points to an object a, and there is an object b of type T (ignoring cv-qualification) that is pointer-interconvertible with a, the result is a pointer to b. So if the original pointer points to a `T`, and there is an object b of type `char`, that it is pointer-interconvertible to `T`, you get **a pointer to **b**.
Off the top of my head, Dict[str, Union[List[int], bool, str]] or take the coward's way out and do a Dict[str, Any].
There's this too... http://www.eschertech.com/papers/ecvpp2016.pdf â€¦ which, using a subset of C++11, formally guarantees code to be free of runtime errors.
On that same link I posted, in one case reinterpret_cast is defined as: static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(expression)) So going from T1 -&gt; void* -&gt; char* is always OK, even with static_casts instead of reinterpret_casts.
It is ok, but the standard says that if char is pointer-convertible with T, e.g., because T is a union or a struct where the first (or firsts) non-static sub-object is a char, then you get a pointer _to that sub-object_, that is, to the `char` field of a struct or an union. This is not the same thing as a char* to the T: both have the same address, but denote different objects: one is valid only for the char sub-object, and the other for the whole T. Because you get a pointer to the char sub-object, once you offset it past it, to access a different sub-object, the behavior is undefined.
Good catch. I've never spotted the difference in "s" :D There is another difference, right? E in expected might be any type, whereas in Herbsceptions it's gonna be an error code. So if more information needs to be carried, then there has to be another mechanism.
A reminder that Boost has you covered: https://www.boost.org/doc/libs/1_70_0/libs/outcome/doc/html/index.html. No need to wait for the standard. If you really really want expected instead, Boost.Variant2 will ship in Boost 1.71 and it contains a highly conforming Expected implementation.
I deal with that in CIDLib in a few different ways, all of which are simple and don't require any magical language features. 1. A version of the method that returns by const ref or value, and whatever it's looking for must exist or it throws. 2. A version that returns by pointer or a boolean status result that is tolerant of failure, so they deal with the failure. 3. In those cases where the above distinction isn't required, I will often add a trailing boolean 'throw if not' parameter that has an appropriate default value that would be best for most uses. So they can choose to be tolerant or not, depending on circumstances. This gives the calling code options without any real extra overhead or fancy language stuff. The called class can usually implement the throwing one in terms of the non-throwing one, so no real redundancy. For the specific example, my collections tend to have 'find or add' methods, which do that for you, since it's such a common thing to do. Those never fail (at least not for 'not found' or 'already present' type reasons anyway), so they are quite convenient to have. They will return a flag that indicates whether they added or found, so you can react accordingly.
Ok I think I understand what the problem is. So you are saying that if we have a struct like this: struct A { char first_field; }; Then `reinterpret_cast&lt;char*&gt;(&amp;instance_of_A)`gives us a pointer to `A::first_field`. Which is true, because they are pointer-interconvertible and A is standard-layout. It is also true that the pointer we get is the object representation of A in the form of an array of bytes (because there is special casing in the standard for char, unsigned char and std::byte). And because they are pointer-interconvertible this is fine also to get the object representation in the form of an array of bytes: reinterpret_cast&lt;char*&gt;(reinterpret_cast&lt;A*&gt;(&amp;instance_of_A.first_field)) You can get a pointer to A from a pointer to its first member, and then get its byte representation. Again, there is special casing just for char, unsigned char and std::byte that always holds.
Yes, that's right, and for `A` AFAICT that works. But what about `B`: struct B { char first_field; int other_field; }; Here `reinterpret_cast&lt;char*&gt;(&amp;instance_of_B)` gives us a pointer to `B::first_field`. We wouldn't be able to use a pointer to a field to access other fields. You mention: &gt; It is also true that the pointer we get is the object representation of A in the form of an array of bytes Which IIUC means this pointer is special, and it points both to the first field of `B` and also to its byte representation, so I could use it to access the content of `B::other` via its byte representation. Is that what you mean? If so, could you point me to the specific wording ?
Why not use std::optional or std::variant with the exception type?
Rust does have that semantic - you can use the const keyword.
I've seen the Hour Glass Pattern used for this in the past: - Implementation in C++. - With a C interface. - On top of which an idiomatic C++ interface is built. Since the idiomatic C++ interface is just a thin wrapper over the C interface, it can be implemented as header-only to simply compilation and avoid ABI issues.
Thatâ€™s a compile time constant, I thought. Also, I made the assumption that a variable introduced with let *can* be modified if it is rebound with mut. However, I realized later on in the comment thread that let *does* imply that the thing itâ€™s bound to can never be modified. When you move a variable to a new binding, it is doing the equivalent of a C++ move, meaning copying the bits. The original memory is not modified. This was shown in my println example. I got it in my head that moving the variable was simply rebinding the name but nothing else. This confusion I had was from the â€œbindingâ€ terminology I had been seeing. I was used to â€œbindingâ€ meaning that the two names reference the same location in memory, where as in Rust, it seems like it means the same de-facto object, since the moved from object ceases to exist for all intents and purposes. However, modifying the new moved-to object does not modify the underlying memory of the original moved-from object. This is the source of the mix up. The last nagging ambiguity for me is whether the optimizer is allowed to alias the moved-to and moved-from objects to save memcpy operations. In which case this all circles back to my original comment.
This isnâ€™t true at all - lots of examples have already been mentioned but Iâ€™d also recommend looking at embedded rust - itâ€™s pretty obvious that you really only need unsafe rust where memory is being touched directly, you can then wrap that up in a safe wrapper and use it with the rest of your codebase, plus there are plenty of libraries that do this reliably.
I don't use the standard libraries, so that's not an option for me. And I probably wouldn't want to anyway, since I don't agree with the massive over-templatization of C++ to begin with.
I prefer member\_variable**\_** I could live with **m\_**MemberVariable or better **m\_**member\_variable, still this looks a bit weird nowadays I don't like \_member\_variable. Leading underscore smells bad in the C/C++ world No extra identifier is appropriate in books, articles, illustrations and so on. In reality any Member Variable represents persistent data and persistent data should be treated very careful.
Note that I said: &gt; P.S. this is not a good idea Reference members are awkward. You lose default copy/move/etc. Also it doesn't work with multiple levels of inheritance. It was basically a joke, originally looked like: ``` class SelfReferential { SelfReferential &amp; ref; public: SelfReferential() : ref(*this) {} }; ``` A useless, but somehow consistent, class.
I can't find the specific wording, but it is clear that a reinterpret_cast&lt;char*&gt;(&amp;some_obj) is supposed to give you the object representation as bytes. There are several places where char, unsigned char and std::byte are handled in a special way, but I couldn't find a specific wording that also addressed pointer interconvertibility. Instead I will refer to this http://eel.is/c++draft/span.objectrep#1 where a view of object representation is specified with the as_bytes function, which says: Effects: Equivalent to: `return {reinterpret_Â­cast&lt;const byte*&gt;(s.data()), s.size_Â­bytes()};`
 public: int counter() const { return counter_;} private: int counter_; Works perfect... camelCase for member functions is also compatible public: int rawCounter() const { return raw_counter_;} private: int row_counter_;
For this specific example, it should be `map.try_emplace(key)-&gt;value` to avoid double lookup. But in C++ standard library it's actually spelled `map.try_emplace(key).first-&gt;second`
&gt;I'm convinced that return values should not be returned as an argument to the function. C++'s memory management almost necessitates such a language feature. In-place modifications would be impossible to do with ordinary functions if not for some form of "return by arg". Nobody is forcing you to use it though. An alternative to `expected` may be `std::variant`. I think you can trivially implement `expected` in terms of `std::variant`, and I expect that performance would be similar.
So "there may be a wording bug in the standard, how do we get this fixed?" Is that what you are trying to say?
I can't speak for that guy, but personally I think whether you do exceptions or error codes or `expected` you're in a similar boat. At some point(s) in your application, you still have to check the outcomes of your operations and do something to handle the error. For the most part, the differences are cosmetic, and nothing is stopping you from doing what you need right now. Using `expected` would not really be shorter or mind-blowingly more clear than using the other schemes.
&gt;by toggling hex codes on a front panel ["Real programmers use butterflies"](https://xkcd.com/378/)
Call it "piece of advice" then
Well I have to give you credit you did fully explain your concerns. Most people who cite perception and feeling don't have much concrete to back it up. Let my do my best to try and address some of your points: First in general: people being people don't seem to fully agree with each other a lot of time. The people dissenting tend to be most visible because consensus is usually a quiet affair. By definition everything that's been voted into C++20 went through a room full of domain experts and a plenary of general experts by a ratio better than 2:1. Hundreds of the best people from compiler writers to library writers have had a look at everything in C++20 and have given implicit or explicit approval. That's no guarantee nothing can go wrong (clearly), but it's about as well as you can do given reality people need to ship actual products. C++ has always had a practical mentality, and has a large user base despite it's many many acknowledged warts and mistakes, and perhaps that says something. Every one of the complaints you raise *have* been raised in committee. They have been seen and resolved to the satisfaction of a consensus (always better than 2:1, often nearly unanimous). What hasn't been seen outside is the exact wording of the arguments (and sometimes even the arguments themselves, sadly). This isn't because committee doesn't like sharing, or doesn't like wider input, it's the simply practical limits on being able to effectively communicate and decide within arbitrary sized groups. There are ways to participate, you just need to use an appropriate channel. Specifically: - we try to avoid mistakes, but to attempt the task of *never* making a mistake would be Sisyphean and lead to paralysis -- an even worse outcome - "blindly yanked from C" is a feature not a bug (taking exception to "blindly"). C++ popularity is partially from riding on the coat tails of C, and C needs to correctly compile under C++ compiler. But everything in engineering is a trade-off, and C compatibility has a serious price. - including the inability to hijack the C pre-processor (you call "C++ macros") to do something as admittedly fancy as lisp-like AST manipulation - nothing in C++20 is "blindly" being pushed. We literally have years of experience with Coroutines TS (not to mention the general computer science concepts of Coroutines, Modules, and ... Concepts). - ability to control heap allocation in Concepts TS was deeply wanted and deeply debated, and resulted in multiple competing proposals. The bottom line is compilers simply could not offer the ability to do both low level optimization and offer heap control. Concepts TS was the only implementable version (not surprising since it was the only implemented version). - there have been multiple proposals to add various sigils to coroutines, and the reason they don't is whether a routine is a TS coroutine or "standard function" is an implementation detail. You're supposed to interface with the routine by it's return type, as always. Coroutines are for implementing library internals, not library APIs. See the examples in: https://github.com/lewissbaker/cppcoro - if the worst thing you can say about a feature is the keyword is ugly, you have a damn good feature. C++ has never been an esthetic language. - Asking dissenters to prove they cannot do X is of course not logically sound, but of course promoters can prove existence of ability to do X, which they in fact did during committee evening sessions: https://www.reddit.com/r/cpp/comments/axnwiz/cmake_gcc_module_proofofconcept/ - explicit on constructors arity != 1 is not a "huh" moment, but a useful feature. It's the difference between `return {1, 2, 3};` and `return Foo{1, 2, 3};` - bias towards putting features in the library versus the language is an old and very sane one -- it helps make mistakes less intractable to fixing as you yourself note. While I appreciate very much your feelings about C++, I do not believe they're fully in accord with the facts. I hope I offered some alternative facts to you today.
I'm not quite think you are right, maybe in the old days but even in cpp11 you have copy elision that can be 0 overhead and still keep the ownership rules. With \`expected\` you don't even construct the object if you return unexpected (error). Compare this to pass by ref (must at minimum default construct by caller) or by \*\* where you break ownership semantics, lose stack allocations and must do a lot of boilerplate checking. Correct me if I misunderstood you
This seems to be the way to go. It also makes it easy to create wrappers for python, java, etc.
Herb Sutter seems to be going in more of a Swift direction re throwing: APIs that can throw are marked as such, and expressions that can throw are marked as such.
Indeed. And rebuilding a C++ interface on top of the C one, rather than with direct access, helps ensuring that the C interface is *the* API and thus: - Has full functionality; not like clang-c :/ - Is well tested.
I played with Conan for the past couple of weeks, and honestly I'm very tempted to just do away with it and go instead with just writing scripts to compile each dependency I need. That's actually very easy to do, and I think I will continue to do that with larger libraries like CEF and Boost where you don't want to randomly download and compile the entire thing. What I figure is that the time to script the dependency builders adds up once you get more than a trivial amount of them, so I'm trying to stick with Conan. Conan isn't that bad, but one of the glaring things to me is that there isn't extra-fine control of how you compile. For example, if I want to enable interprocedural optimization for libraries built with MSVC, that seems to be a major headache if the conan recipes for the libraries don't support it directly. Considering that link-time code generation is OFF by default, I'm guessing that a lot of Conan recipes have that misconfigured for release builds. Personally I would like things to be a lot simplerâ€”perhaps a tool that could just scan C++ files, look at what's in #include &lt;...&gt;, and then map known header files to library dependencies that it needs to fetch and install, while also taking into account what compiler settings are being usedâ€”so those do NOT need to be manually input into a separate source/Conan profile and what have you. I hope this sort of idea will be more popular once C++ modules are released.
Can e we get details? More info?
&gt;I'm not quite think you are right, maybe in the old days but even in cpp11 you have copy elision that can be 0 overhead and still keep the ownership rules. With `expected` you'd lose that copy elision optimization, and the only way you could get close to taking it back is with boilerplate in the form of move semantics or similar crap. But I could be wrong, I mean compilers could implement copy elision for `expected` too. &gt;With `expected` you don't even construct the object if you return unexpected (error). I don't think hyper-optimizing for error cases is worth it. They're errors and are supposed to be uncommon. If you need to process millions of errors per second you're doing something wrong. &gt;Compare this to pass by ref (must at minimum default construct by caller) or by ** where you break ownership semantics, lose stack allocations and must do a lot of boilerplate checking. When returning by arg, there should always some kind of status variable to indicate whether the function succeeded or not. The amount of code to ensure that your state remains valid after an error is approximately the same either way. It's not a "lot" of boilerplate checking, it's the same amount just rearranged. I agree with you somewhat about ownership semantics. Using a language that allows you to return things by argument does complicate things. But C and C++ are like that and I doubt they will ever change. Anyone who's used C++ for any significant amount of time is used to it. I'm not worried about optimizing my stack allocations... I hate move semantics.
I'm not familiar with go's error handling but your solution seems similar to [std::expected](https://isocpp.org/blog/2018/01/introduction-to-proposed-stdexpected) (which I only know about from a recent post here). I saw std::get in your example, which is something I find really annoying to use. You could use C++ 17's [structured binding](https://en.cppreference.com/w/cpp/language/structured_binding) to make it a little more bearable.
That readme is lacking to say the least.
I am updating it, till then you can take a look at the example, :P
I am updating it, till then you can take a look at the example, :P
They are nice enough, but limited in that they force repeated recompiling to reveal more errors that C++ gives you first time.
Anything really. Ideally you would have an idea to solve a problem you have, to automate a daily task etc. But if you can't think of anything you can make your own version of any existing software for practice, iirc my first project was writing a Tetris clone on SDL2, if you're not interested in games you can try something like a simple text editor, FTP client, mp3 player or whatever.
It looks like you invented something similar to `std::expected`. The difference to your code is that `std::expected` is a wrapper over both the return value and the error but is only either value or error at any given time. You can have a look at an implementation [here](https://github.com/TartanLlama/expected).
If you want to get closer to Go's syntax you probably want to use C++17 structured bindings
I don't lose copy elision optimization with expected like class (checked) even without move semantic, and with initializer\_list its pretty easy to construct in-pace in the return statement. \`return { arg1, arg2 }\` And there no boilerplate there except maybe std::move. And there is no hyper optimizing here, its like saying I like my vector default construct every item when I preallocate it. If you hate move semantics, maybe you really don't need \`expected\`?
&gt; C++ project &gt; 50% CMake &gt; 37.5% Python
Depends on the type of error. Is it an error outside your control? (User Input, networking, filesystem?) Is it an error within your logic? (assertions, contracts) Is it an ambiguously caused error? (Default case, else statement that shouldnâ€™t trigger?) Is it an â€œexceptional errorâ€? (Any of the above) Is it an error that would need to be handled immediately? (cannot find file) Maybe you want to bubble it up to allow the user of some library to handle it? Would you create a custom error in this case? Programs are designed to do one thing well. Errors are kind of a strange case where unexpected things happen and we donâ€™t really design for unexpected things. Now the issue is, when something unexpected happens, what is the expected thing to do?
You are interpreting the standard wrong. You can convert a pointer to a standard layout type to a pointer to it's first field. That's because that field is at the same address as the object. There's no need to do any of that in memcpy. Just because the pointer is *also* a valid pointer to its first field doesn't mean it no longer points to the beginning of the object.
Why not just use return for an enum with error codes and a reference argument for the value you want to return?
Ahh yes saw that, :)
ohh, nice
spdlog already have a support of building as a compiled lib. See the example in its repo
I try to avoid passing non const references
Create a C++ compiler
Hopefully sometime. Iâ€™m on a codebase where we donâ€™t use exceptions.
"An idiot's attempt to..." pretty much describes my entire career.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c6r6ao/best_course_for_learning_c/esfmo4e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c7iu45/just_finished_a_c_course_and_would_like_to_create/esfmpok/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
haha
Oh no the Reddit police got me
ahh thats reasonable, STL uses exceptions in most of the places
Using a filename without an extension is a big no-no. Only the standard library is allowed to do that. #ifndef __ERRORS__H You aren't allowed to use double underscores either. And don't use something as generic as "ERROR_H", use "HELLOZEE_ERRORS".
You have to specialize std::get&lt;N&gt; to support structured bindings.
Did exactly the same a while ago just for fun with std::optional + errors that contain the line and file together with the error message. Never had the chance to really use it. Maybe one day I will in some pet project just to see how it goes :)
wow thanks, I didn't know that, :)
Wow, great work by the CLion team, as always! With regards to "The â€˜unused includesâ€™ check is back"; is this implementation available in upstream clangd, and if so which release will it be targeting? &amp;#x200B; Thanks for all your hard work.
Unfortunately things like std::string, std::array, std::vector, are very basic, and yes, they are desperately needed in C++ API boundaries.
Me: â€œAn idiotâ€
In C++17 there is std::variant, it looks like more suitable then std::optional. std::variant&lt;OkType, ErrType&gt;
The new exception mechanism gives you the benefits of actually throwing exceptions with the benefits of not throwing exceptions.. it's the best of both worlds. There is literally no reason to use expected instead of exceptions at that point.
The new exception proposal does seem to be a magic bullet.
&gt; Boost has you covered Sigh. Boost :(
Yeah that's definitely the way to go, then just use `if(std::holds_alternative&lt;ErrType&gt;(resultVariant) {...}` to handle the error, preferably you'd resolve it or pass it up, this also supports having multiple error variants were you could instead have the if block be on the OkType and handle the other errors in the else. There may very well be better third party or boost implementations of something similar, but this is the best thing in the standard I've seen.
Well... You may be able to avoid a copy of the `expected` result for a short time due to ordinary copy elision, but unless you want to carry that structure forward for the lifetime of the result you'll have to "unbox" the result. That means, at minimum, a move operation. The boilerplate I was talking about was with regard to actually handling the error. There is NO "boilerplate" when returning by arg, inside the function body. You just set a flag or return something early. There is "boilerplate" in checking for an error on the caller side. But that is there for any scheme you can think of. The number of possible error handling scenarios dictates the amount of code you need. Calling it boilerplate may even be disingenuous, because it's application logic and there has to be a shorter way to do it before you get to disparage it.
I am not sure whether I am successful or not, but I wanted to avoid involving exceptions and I don't think std::variant can be used while avoiding exceptions, though I might be wrong too.
std::variant when used properly will not throw. The only times it throws are if you all get for a type that is not currently stored in there, but you should be checking types beforehand either way. The only other way is if the initializer throws an exception which should be impossible if you aren't using exceptions.
Me, an intelectural
I mean, optional loses its purpose when you can dereference it without checking.
How far are you into your class?
Sanitizers and lots of unit tests. with no runtime overhead at all.
`snake_case` for public members, `m_snake_case` for private members, `this-&gt;snake_case` for when you don't care
Because you might break code with your no side effects compile time trigonometry functions.
&gt;A degree in software engineering or computer science is no doubt a sure way, but I have time and wondering if I can reach that level of programming competency without college. Not having a degree is going to close A LOT of doors for you in fields where C++ is relevant. You would need a substantial amount of professional experience to offset having no degree, and I know at the company I work at you wouldn't even get past automated filtering.
Yes I recognize this. The degree can help you jump into big companies easily. Iâ€™m wondering if thereâ€™s internships, personal projects, or additional steps/tips you would take to pad your resume. If you donâ€™t mind, what are some things to know that arenâ€™t just the programming language that is taught? General is fine as specifics may take ages to talk about and thatâ€™s alright.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
C++ is often used in 'mission critical' realtime applications like airplane controls, medical equipment, financial security trading software. If your code doesn't work properly people will die and millions of dollars will be lost. Companies are wary of hiring autodidact c++ programmers because of this. Contrast that with something like web development where an error in your code wouldn't lead to such a severe catastrophic failure. For someone without a college degree getting into the subfield of web development is much easier than something having to do with c++ (except game development of course).
StatusOr is the equivalent inside Google's code base. Exceptions aren't used. https://github.com/protocolbuffers/protobuf/blob/ee5f29f46e1bdd2e235224b0a1d8cf22e028a44d/src/google/protobuf/stubs/statusor.h https://github.com/protocolbuffers/protobuf/blob/ee5f29f46e1bdd2e235224b0a1d8cf22e028a44d/src/google/protobuf/stubs/status_macros.h
If you have a degree in this, do you know a way to show you know? There are certifications like a CPA or CPP from C++ Institute, would these be beneficial?
Wow, never knew that, thanks for this, :D
Better pursue a career in Java or Python.
CS degrees usually include data structures algorithms math up to calculus 3, linear algebra, differential equations discrete math automata theory software engineering some kind of GUI programming assembly language computer hardware classes (logic, architecture)
Much appreciated. Iâ€™m gonna try to look at course requirements at universities and investigate further with this.
While it is true that C++ is most commonly used in applications that are required to be high reliability, almost everyone I know that got into it were self-taught people who apprenticed under experienced C++ software engineers on real projects. That is the only way to learn, really. The people who invariably got those spots were those that took the initiative to learn the basics thoroughly. You learn things like systems engineering by doing. I agree with your overall point about the C++ programmers often require a higher standard of execution quality due to the types of applications they are often tasked with building.
A lot of people in this thread are telling you that you need a college degree to make it as a C++ engineer. I think they are dead wrong. I dropped out of college at 19 to teach myself C++. I do not hold a degree in computer science or software engineering. I've never taken a CS class (though I taught once); nor have I taken any online courses, certifications, etc. I have only ever read one programming book (Elements of Programming). A decade later, I am gainfully employed as a C++ engineer, I regularly give talks at C++ conferences, and I chair two subgroups of the C++ standards committee. My mentor at work, a distinguished engineer at our company and the chair of one of the C++ committee's main subgroups, also has no computer science degree. He went to college to be a mechanical engineer. Now he designs microprocessors and the C++ language. One of my best friends, who is also a C++ engineer, never went to college, and started working as a C++ engineer right out of high school. Today, he is a major contributor to LLVM and a senior compiler engineer at one of the FAANG companies. He's also a member of the C++ standards committee. One of my other best friends is the C++ lead at the same FAANG company. His college degree is in mechanical engineering. There are many paths to a career in C++. A college degree in computer science is just one of them. What really matters is your technical ability and your work ethic.
Write a database engine. It isn't difficult per se nor an unmanageably large amount of code but it is almost infinitely deep technically and touches virtually every aspect of high-end C++ engineering. You can also master the skills incrementally and iteratively, and this work will be reflected in the quality of the design and implementation. It is difficult to fake. I've personally hired a few software engineers with little more than something like this as their resume. Worked out brilliantly every time.
Those are some major accomplishments. How would I best show my technical ability professionally to your knowledge? Would working with local companies and developing applications with them be a first start? Is there more I can do?
Thank you very much. Definitely adding this to do.
That's all pretty anecdotal
Getting involved in an open source project is the route I took. I started contributing to Boost, and leveraged that into my first job.
Ancedotes usually are.
StatusOr was mentioned already, but here is another (from a friend of mine) - [https://github.com/zajo/leaf](https://github.com/zajo/leaf)
&gt; That being said, what are some general things companies look for or would like to see to show you know what youâ€™re doing? Depends on what kind of company you're after, honestly. I'm in high-speed data analysis so evidence that you care about scalability, understanding the basics of compilers, how your code actually interacts with the underlying OS/hardware, etc. would be what you need to break into my field. On the flipside, a game dev's probably going to care more about things like how well you understand modern tools and how platform-agnostic you can make your code. So you'll need to get a bit more focused on what flavor of dev you want to start out as. I would throw your projects up on github just so they can glance over the source, but your best bet is listing it on your resume and then displaying your competence during the interview. &gt; A degree in software engineering or computer science is no doubt a sure way, but I have time and wondering if I can reach that level of programming competency without college. Can you? Yes. Will it be fucking hard? Also yes. The problem with being degreeless is you need to first stand out enough to get considered (lots of companies will automatically shred your resume if you don't have a degree) and then demonstrate that you've put in the same effective learning hours, covered equivalent topics, and picked up the auxiliary skills a fresh grad has accumulated over the past 4+ years. Everything from the fun stuff like data structures and algorithms to the mind-numbing topics like proofs and mid-level math. &gt; What is taught for software engineers? For software *engineers* you need to go to school, full stop. For mislabeled software developers, the high level minimums are: * Algorithms * Data structures * Maths out the ass (I would mark linear algebra, statistics, Calc 3, and discreet mathmatics as required) * Operating Systems * Computer architecture &gt; Projects (game vs practical and how complex should they be) to work on? Whatever grabs your attention. It's far and away better to have a handful of complete, if middling, projects than a mountain of aborted skynets. It also wouldn't hurt to get involved in open-source, since it'll get you rubbing shoulders with professionals and let you start networking.
Probably best not to generalize from them though
Computer science, digital circuits, Boolean math, math (linear algebra, mathematical analysis, etc.), physics and electronics for example. Depends a lot on the field though. Then comes the tooling around the code that you write. Big list, but there is a lot of good stuff to learn out there! ;)
What about Qt? They used filenames without extensions for quite a while. I don't have sources but I think they predates the STL.
\&gt; What really matters is your technical ability and your work ethic. Time management, communication, ability to take orders/responsibilities and ability to work in a team are equally, if not more important. These are things that people develop during university/college. But this feels very much like Mark Zuckerberg saying you don't need college because he didn't. I would say that you are in the very very small minority when it comes to success without a formal education.
How?
They seem to use the standard library, which can involve exceptions, still a nice one.
Well the comment was half /s because I don't see much code that relies on it, but these functions change [`errno`](https://en.cppreference.com/w/cpp/numeric/math/math_errhandling) So code can behave differently if you would end up caching the results of the functions. Any code that breaks because of this should be burned down, but that's not happening.
Honestly, when looking at hiring people if you don't have a degree you will be lucky to even get past the recruitment agent. If you do make it to the desk of the person hiring, you're unlikely to get shortlisted. A degree is a basic "how to adult" qualification. &amp;#x200B; Going to college for 4 years teaches you basic skills required to be a functioning adult. You learn time management, responsibility, ability to take orders, ability to work under stress, work in groups/teams, show up. You can teach someone the skills to be a competent software developer in a few months, it's all of the sundry stuff that a degree provides that makes the difference between a good hire and a bad hire. Even if you had 10x the technical skillset of the next person, if you can't manage time or work with a team you're basically useless to most organisations. There used to be a concept of hiring "hero" developers, but in recent times this has gone out of fashion because they often lack communication and group skills so are an overall negative to the organisations. &amp;#x200B; That is my opinion are working in IT as a programmer, software dev, architect and manager over the last 20 years.
Self-learnt gamedevs are pretty common, even at bigger companies. Passion, general c++ knowledge and performance thinking is key. For a career in gamedev i would recommend you make smaller (but complete) games. You need a very strong portfolio without a degree, but it is very much possible. Good luck!
I do this all the time, using the built in types `std::variant` and `std::optional` depending on the situation. Only annoying thing is there is no pattern matching for variants that doesn't look like the person who designed it was busier than I one legged man in an asskicking contest, or plain old stupid.
I can obviously only speak of personal experience. I.e. as a lead programmer, and previous software dev business owner in game development... I, and my fellow programmers, do not look much at education. And instead focus on demonstrable knowledge. A degree is not a means to, or requirement for, a job. Your goal should be to concretely show that you have the knowledge to be productive in the workplace. That usually means: * Being able to debug problems. * Understanding the operation of software systems. * Sharing your knowledge effectively with others. I know that's broad.. But so is the domain in question. Reaching a particular level of knowledge in programming is about practice, like most skills. The more you do it the better you get at it. And a college degree barely scratches the surfaces of what you will learn. At the same time such education will give you a formalized foundation for the basic underpinnings of programming. Essentially.. if you can afford it, sure go ahead and get some formal education. But don't let that hold you back. As to your other questions.. &gt;What is taught for software engineers? It varies wildly depending on the specialization and institution. I've seen the full gamut when it comes to job applications that I read, almost daily. From expensive colleges that teach the equivalent of game scripting up to unheard of colleges with PHD programs in Computer Science with deep data structures algorithms and math. &gt;Are there any C++ certifications worthwhile to show I know? Not that I know of. Certifications usually come from companies that have a vested interest if having a trained workforce in their technologies. C++ is just not that kind of technology. &gt;Projects (game vs practical and how complex should they be) to work on? As others mentioned.. Get involved in some public projects that are relevant. But relevance depends on what you want to do. For example if you wanted to do game engine programming you'd want to think about systems and hardware projects. If you wanted game scripting programming you'd want to look for game projects (even starting your own). And so on.
I'd add OOP as well, properly architecting/designing is a essential skill.
Well, I wanted to avoid invoking std::exception at all cost, using anything from the standard library would carry a chance for invoking that, :)
Times change. You would be hard pressed to get a programming job these days without a degree. Doubly so for any C++ jobs.
&gt; For software engineers you need to go to school, full stop. For mislabeled software developers, the high level minimums are: I don't think distinguishing these is useful. Nobody agrees on terminology when it comes to job titles.
&gt; An idiot's attempt to do a `go` like error handling in `c++` A true sign of a Hacker News Superstar is using code formatting for any noun that is related to programming instead of for code.
&gt; You can teach someone the skills to be a competent software developer in a few months, it's all of the sundry stuff that a degree provides that makes the difference between a good hire and a bad hire. Gonna strongly disagree on this one. You can't learn how to be a good software developer in 3 months, no way no how. You might learn how to cobble something together to solve some small problems. But is that "competent"? However, going to school helps a lot in terms of giving you a broader knowledge base to draw from when it comes to solving problems. Self-taught people rarely invest the same amount of time as people who get degrees, and even when they do it is often less productive time spent due to having to struggle with stuff they can't figure out.
There is no definitive answer to this. It all depends on the requirements, i.e. what the program shall do. Maybe in the future someone will think about [event-based programming](https://www.reddit.com/r/ProgrammingLanguages/comments/m0f1o/how_about_a_programming_language_in_which/) and eliminate if, switch, match, exceptions etc as they are all control flow management mechanisms.
Version 2.6.0 is available :) [https://forum.adlice.com/index.php?topic=3584.msg9201#msg9201](https://forum.adlice.com/index.php?topic=3584.msg9201#msg9201)
Of all the people I know doing C++ outside of game development, none of them are really self-taught.
I guess that depends on the direction you're coming from. If you're going through college and want to get a job programming in C++, then it makes sense to check out what options you have through university. Some people learn better in the university environment. The other direction is "if I don't have a degree, should I avoid C++?" I think that's where the stories are more useful. No. You should not avoid a programming language because you feel you didn't check off your rights of passage boxes. You can learn it at any time in your life. If you want to do it, then do it. Don't find reasons to say that you can't.
&gt; There are certifications like a CPA or CPP from C++ Institute, would these be beneficial? Maybe in addition to a degree, but I've never seen anyone with a C++ certification in my whole life. If you ask around I'm sure you'll find that most people have never seen them either. Therefore it is reasonable to assume that those are pretty useless.
Most of the people have already given good answers to what companies are looking for. And You can definetely study evrything related to computer science at your home. [https://github.com/ossu/computer-science](https://github.com/ossu/computer-science) This is the link to ### Open Source Society University Path to a free self-taught education in Computer Science! &amp;#x200B; It covers almost all the topics related to computer science degree and beyond as well. **Organization**. The curriculum is designed as follows: * *Intro CS*: for students to try out CS and see if it's right for them * *Core CS*: corresponds roughly to the first three years of a computer science curriculum, taking classes that all majors would be required to take * *Advanced CS*: corresponds roughly to the final year of a computer science curriculum, taking electives according to the student's interests * *Final Project*: a project for students to validate, consolidate, and display their knowledge, to be evaluated by their peers worldwide * *Pro CS*: graduate-level specializations students can elect to take after completing the above curriculum if they want to maximize their chances of getting a good job. &amp;#x200B; You'll find all the best resources to study computer science from teachers around the world. Don't get overwhelmed by the number of topics it has as computer science is a very broad field. You don't have to study all of them as its a life long process to master programming so don't rush it. Just start with one basic course and you'll be able to find your path yourself. My recommendation would be "CS50 Intro to computer science by Harvard University ". It will make a good base of computer science fundamentals so that you don't struggle later in understanding complex things. I'm 20 and studying computer science from a local college but teachers are not that great so mostly whatever I have learned is from the internet which is a clear indication that you'll too :)
It really annoys me that this happened. It doesn't affect me personally since I have a degree and experience, but when I first started, anyone who was good could get hired. Some of the best devs I know are self taught. Now it has become a credential game.
While it's an inspiring anecdote, one has to be aware of survivorship bias. The reality is that a degree seriously reduces the friction you will have to face, not to mention the motivation and social aspects of attending college.
Both `std::variant` and `std::optioal` have `noexcept` constructors and accessors
Nowadays you could be damn talented, with a CS degree and experience to boot, and end up unemployed for several months. It's happened to me. The low hanging fruit is gone in the software industry. I feel like I may be lucky if I manage to avoid changing careers when I get older.
This is so true it hurts. I've written far too many half-arsed implementations of small library features to avoid taking another dependency. And the dependencies I do take tend to be large/broad (eg. Boost) or highly specific (eg. Eigen)
the future is now old man. that doesnt work anymore
but how would the smart pointer be implemented if all of its methods need a smart pointer for `this`?
I appreciate the back and forth. &gt; Well I have to give you credit you did fully explain your concerns. Most people who cite perception and feeling don't have much concrete to back it up. Let my do my best to try and address some of your points: Thanks. I never intend to be the kind of random internet persona that spouts off unsubstantiated bullshit. I may not always be fully informed of what I'm talking about, but I'm at least capable of making estimates of how accurate my guesses are, and making judgements informed by those estimates. *shrug*. Obviously C++ is something that I put a ***great*** deal of consideration into, as I'm literally using the language every day, hours a day. It's my livelihood. Further, I'll point out that I do understand that there are more stakeholders for the evolution of the language than just myself and my immediate concerns. I can hold a strong opinion on how i think things *should* be while also recognizing that reality doesn't always agree with me &gt; First in general: people being people don't seem to fully agree with each other a lot of time. The people dissenting tend to be most visible because consensus is usually a quiet affair. By definition everything that's been voted into C++20 went through a room full of domain experts and a plenary of general experts by a ratio better than 2:1. Hundreds of the best people from compiler writers to library writers have had a look at everything in C++20 and have given implicit or explicit approval. That's no guarantee nothing can go wrong (clearly), but it's about as well as you can do given reality people need to ship actual products. C++ has always had a practical mentality, and has a large user base despite it's many many acknowledged warts and mistakes, and perhaps that says something. Yep, understood. &gt; Every one of the complaints you raise have been raised in committee. Glad to hear it. &gt; They have been seen and resolved to the satisfaction of a consensus (always better than 2:1, often nearly unanimous). What hasn't been seen outside is the exact wording of the arguments (and sometimes even the arguments themselves, sadly). This isn't because committee doesn't like sharing, or doesn't like wider input, it's the simply practical limits on being able to effectively communicate and decide within arbitrary sized groups. Yep, Understood. &gt; There are ways to participate, you just need to use an appropriate channel. Can't afford to participate (opportunity cost, not actual cost, typically) in the in-person methods of participating. And while this is no fault of the wider C++ community, or the committee, I find mailing lists impossibly frustrating, and have no interest (because of the high opportunity cost) in a process where the only (well, the most commonly pointed out anyway) method of officially pointing out problems is "Write a proposal!" (E.g., see the 2d graphics situation, and one of the common replies to objections to that proposal being to --paraphrasing-- "write your own proposal then!"). Nevertheless, I understand your point. &gt; - we try to avoid mistakes, but to attempt the task of never making a mistake would be Sisyphean and lead to paralysis -- an even worse outcome Right you are. &gt; - blindly yanked from C" is a feature not a bug (taking exception to "blindly"). C++ popularity is partially from riding on the coat tails of C, and C needs to correctly compile under C++ compiler. But everything in engineering is a trade-off, and C compatibility has a serious price. C lacks templates, C lacks references. It's impossible for template&lt;size_t N&gt; void foo(char (&amp;)[N]); void foo(char*); foo("String Literal here"); //&lt;- Calls the char* version to be a C compatibility problem. So, yes, this is a "blindly yanked from C" feature. Namely arrays decaying to pointers when passed to functions. Of course, at this point, the behavior is a matter of backwards compatibility with existing C++ code, so it can't be fixed (though I wish). I understand that you feel like I was using hyperbole, but I don't think that I was. Working around this specific behavior of the C++ programming language (which, of *course* needed different work arounds for MSVC than for GCC) consumed nearly a month of my work-life in late 2018, for one of those subtle performance bugs that take a long time to realize are in your code, so I have a lot of hyperbole to go around on this very narrow subject. Fortunately, with C++17 or newer, 'if constexpr' provides an adequate (though, I'd still have rather it just work how one would expect) solution. template&lt;class STRING_T&gt; constexpr size_t foo(const STRING_T &amp; str) { if constexpr(std::is_pointer&lt;STRING_T&gt;::value) { // do pointer things } else if constexpr(std::is_array&lt;STRING_T&gt;::value) { // do array things } else { // do whatever else. } }
 &gt; - including the inability to hijack the C pre-processor (you call "C++ macros") to do something as admittedly fancy as lisp-like AST manipulation Not seeing why extending the pre-processor would cause a compatibility issue with the C language. &gt; - nothing in C++20 is "blindly" being pushed. We literally have years of experience with Coroutines TS (not to mention the general computer science concepts of Coroutines, Modules, and ... Concepts). I think you misunderstood my statement. Here's what I originally said: &gt; It's deeply worrying to me that so many people are so blindly asking to push forward with the big features for C++20 despite so many dissenting voices offering justified criticism, with examples of how thing's aren't entirely sunshine and rainbows. I meant that it concerns me that the community at large is blindly trusting that the implementation that the committee decided on will be the right fit. I know that we discussed the committee, and industry experts, and such just above, but that doesn't really alleviate my concerns. Again, I have opinions, and understand that I can't always get what I want. I don't have any animosity to the committee for whatever decisions they make. I just don't always think they make the right ones. It is what it is. &gt; - ability to control heap allocation in Coroutines TS was deeply wanted and deeply debated, and resulted in multiple competing proposals. The bottom line is compilers simply could not offer the ability to do both low level optimization and offer heap control. Coroutines TS was the only implementable version (not surprising since it was the only implemented version). Sure, I understand. But I hope you understand that from the perspective of my team at my last job, this means that co-routines are dead-on-arrival. The C++ co-routines for C++20 literally cannot be in that company's product in the situation that co-routines are designed for, because of this lack of low level control over allocations. Doesn't mean they won't get used in other areas of the code. But if control over the allocations was available, it would be a perfect fit for their multi-media engine. &gt; - there have been multiple proposals to add various sigils to coroutines, and the reason they don't is whether a routine is a TS coroutine or "standard function" is an implementation detail. You're supposed to interface with the routine by it's return type, as always. Coroutines are for implementing library internals, not library APIs. See the examples in: https://github.com/lewissbaker/cppcoro I understand what you mean, but I disagree with the philosophy behind your meaning. "Implementation details" tend to be the details that I need to know about in order to get my program to do what I want. My opinion is that C++ makes it far too easy to "hide" implementation details, and not "easy enough" to allow the code making use of a library to control those details. Wouldn't need to hide things if it was easier to present those as tweakable knobs than to hide them. Myself, and dozens of C++ devs at my last job, strongly would prefer the language to give more overt control over things. Hiding details, and "It's for library internals" are the wrong things to care about, in my opinion. &gt; - if the worst thing you can say about a feature is the keyword is ugly, you have a damn good feature. C++ has never been an esthetic language. I disagree that C++ has never been an aesthetic language (I happen to think it's quite, as far as programming languages go) , but nevertheless, elegance in expression is something I consider very important. I write code in C++, and not C, or ASM, because I can express the behavior that I desire from the processor at a sufficiently low level to have the control I want, while still being high enough to be able to express what I mean fairly fluently, and without getting lost in the weeds. My opinion is that ugly keywords are a significant determent to future language design (among other problems, they'll be used to justify adding additional ugly keywords), as well as discouraging potential users of the language from adopting C++. &gt; - Asking dissenters to prove they cannot do X is of course not logically sound, but of course promoters can prove existence of ability to do X, which they in fact did during committee evening sessions: https://www.reddit.com/r/cpp/comments/axnwiz/cmake_gcc_module_proofofconcept/ That's great that it was proven. Again, I don't recall the complete context of this, but I'm still pretty annoyed that the design that that comment was made over was even considered prior to proof that it was possible. Or maybe the internet simply presented the events to me out of sequence. Can't say. What I can say is that the committee does not do a very good job of making process and procedure information available to the community in such a way that a person like myself, who's very interested in the direction that things go, but is not very interested in trying to directly participate in the process, can find themselves informed on what's going on. I'm not saying they *should* do a good job at this. That's up to them if they want to. All I'm saying is that, from my *small* corner of the internet, I don't think I have good visibility into things. And that lack of visibility is how I came to the conclusions that I did, and the concerns that I did, with regard to co-routines and modules. You haven't changed my opinions on those two items, but I do appreciate the discussion. &gt; - explicit on constructors arity != 1 is not a "huh" moment, but a useful feature. It's the difference between return {1, 2, 3}; and return Foo{1, 2, 3}; Then why did I find the explicit keyword on constructors with arity != 1 in a header file written in 2001, before uniform initialization syntax was a thing? &gt; - bias towards putting features in the library versus the language is an old and very sane one -- it helps make mistakes less intractable to fixing as you yourself note. Right, I'm aware that I'm not the only one with that opinion. I was simply pointing out that co-routines *appear* to be baking in additional explicit library &lt;-&gt; language inter-dependencies, which I don't like. &gt; The fact that C++20 is a large release is an accident of the fact that several features were considered "not ready" for previous releases (Concepts going back to pre C++11). We've had years of accumulated experience, if they're not ready for 20 when will they be ready? There's no "blind push", there a recognition you have to ship or get off the pot. We ship every 3 years in a reasonable schedule, and this is what committee agreed to. We've also now had several years of experience dealing with multiple big language features interacting poorly. I think I mentioned in my previous reply that initializer lists interact poorly with the uniform initialization syntax. That's the kind feature interaction that I'd rather not see us repeat, and as a result, I hold the opinion that merging multiple huge features in the same major release is a bad idea. It's good that we're doing the whole TS thing now, which obviously makes it easier for these poor interactions to be discovered and addressed, but I feel once-bitten and twice-shy. As I alluded to, I've had quite a lot of frustrations in convincing that MSVC that the code I wrote for it to compile is, in fact, supposed to do what I think it's supposed to do, and our disagreements keep being about code that happens to involve those weird "big feature interaction" things, like the uniform initialization syntax and initializer lists. &gt; While I appreciate very much your feelings about C++, I do not believe they're fully in accord with the facts. I hope I offered some alternative facts to you today. You did help me clarify what I wrote, but sadly I don't really feel like my opinions have been shifted. Perhaps this is partially the fault of "why am I posting on reddit at 4 am", and perhaps it's that i'm not a language lawyer, so I approach these discussions from the perspective of an experienced C++ programmar, and how I would use the things I see being proposed.
I have a Masters degree in the humanities (history and linguistics) and then dropped out of PhD in computational linguistics last year to work as C++ programmer. It was super easy to find this job, since programmers are in very high demand right now. &amp;#x200B; And also, I had some student assistants from the CS department when I was still at the university, and my experience is that they didn't know jack about programming. IDK if it's much different in the US, but it's my understanding that they don't really teach programming in CS courses, and even if they do, they won't teach C++.
Somehow I feel I need point out I don't think we should not use exceptions. exceptions are a good mechanism, irrelevant of the semantics. You definitely want exceptions in your toolkit. I think I can argue that using returned base errors, when its done correctly is also a good tool in you toolkit. What I meant in the last sentence above is that I think the "community leaders" (lack of a better word) should give an expert example of how it should be done. I know there are many implementations out there but I would really like for some "official" one that also describes when the pattern may fail, just like many examples in the standard.
&gt;Resorting to run-time "safety" mechanisms can be better than nothing but is not a replacement for static analysis Yes, no argument there. I am perhaps more optimistic about the possibility of fully enforcing a practical safe subset of C++ via static analysis. In my estimation, the fact that the current design for the first version of the lifetime profile checker does not fully enforce memory safety is due to lack of ambition rather than an intrinsic limitation. So the idea behind the SaferCPlusPlus library is not that you would change to a "pseudo-GC" style of coding, but rather that you would (try to) code as if you were constrained by a borrow checker / lifetime profile checker. But instead of getting a compile error when you screwed up (as a completed static checker is not yet available and certainly wasn't available when the library was initially developed), you might get a run-time error if the mistake results in unsafe behavior. Then, when a completed static checker does become available, you can "disable" the library's elements (i.e. automatically alias them to their native/standard (historically unsafe) counterparts) with a compile-time directive and instead let the static checker verify that your code is safe. So to be clear, I'm not recommending that you replace your raw pointers with `shared_ptr&lt;&gt;`s or anything like that. The library provides [non-owning](https://github.com/duneroadrunner/SaferCPlusPlus#registered-pointers) (safe) [smart](https://github.com/duneroadrunner/SaferCPlusPlus#norad-pointers) [pointers](https://github.com/duneroadrunner/SaferCPlusPlus#scope-pointers) that can substitute for raw pointers (and like raw pointers can point to pretty much any object including local variables allocated on the stack). But while the library does function as a "better than nothing" stand-in as we await the completion of the static checkers, it will not necessarily become redundant once they arrive. First of all, the library can be used to enforce data race safety, in a somewhat similar fashion to Rust, which, the lifetime profile checker for example, does not address. But also, not everything can be checked statically. Rust, for example, still makes liberal use of run-time safety mechanisms (like with `Rc&lt;&gt;`, bounds-checking, and everywhere else a panic might occur). I suspect that some of the "run-time safe" elements in the SaferCPlusPlus library may remain useful even after the static checkers have matured.
Ahhh, yep I understand. Of course, errno is an abomination, so I'm supremely disappointed that it's used to justify lack of action on improving things, but thus is life I suppose.
Actually. I agree. I should've said "programmer". Someone who can write code in a chosen language. The problem solving aspects/design patterns of software development definitely not in a few months.
I don't have a degree and I has not held me back. I could not name a university here in Germany which cranks out up to date C++ experts, and its a moving target too. Good devs need to be able to stay up to date and keep learning without a typical classroom setting and if that's how they got to where they are chances are they are going to keep doing it. I happily hire people without CS degrees.
They shouldn't do that, but I guess they think they are too big to care for good practices.
Itâ€™s funny how you have to attend college/university to get your degree etc but i hear all to often that the teachers are crap and you have to turn to the internet anyway in order to learn what youâ€™re paying for someone to teach you.
Outcome comes in non-Boost form too: https://ned14.github.io/outcome/
Hmm, as a recent compsci grad me and my friends had a semi competition to see who could get the most job offers without applying We stopped playing because it was getting ridiculous
Some new proposal say that since it is pretty much UB to have side-effects in constexpr, constexpr trigonometry can be used and will ignore the errno -- "relaxing constexpr". I find this a bit silly but practical. (I don't know why they to not allow both "constexpr T" and "T" as function handlers, since the names should be possible to differentiate between. If a function is called wanting constexpr, prefer the "constexpr T"-handle if both exists, in non-constexpr prefer the "T"-handle, otherwise use whatever is available [i.e., legacy]. Would allow cleaning math-functions up from their C-history. I don't know why this is not considered, the returned "T" is the same.)
Lucky you I guess... Your time will come, probably.
Can you elaborate or give a reference for that statement?
Dude I'm 27.
Sometimes you need some ad-hoc class/struct that will be used only within the body of a single specific function. In such cases, defining the class locally allows you to avoid polluting the surrounding namespace.
I don't think things have changed that drastically since I entered the work force a decade ago.
&gt; the motivation and social aspects of attending college. College works for some people. It doesn't for other people. I hated college. I found it stressful and arbitrary. I didn't enjoy the social aspects of college life either, in part because I was working at the time. If it works for you, great. School isn't for everyone though.
No, things were bad 10 years ago too. Maybe you're unusually talented or lucky.
Most users feel the same way, there's a reason gcc ships with variants that don't have it. But as long as you have many members of the committee that want legacy it won't change.
Static member variable and static global variable initialization order at runtime is very complicated. I don't think you can rely on any two particular variables to be initialized in the same order between two different compilations. I think primative globals / static members start with a value of zero I recommend you look into different ways to assign I'd numbers to your classes. One way you can do it is to simply assign a number to each by hand. An alternative is that you can use the c preprocessor (I know. I'm a heretic) to "stringify" the name of your class (e.g. as part of a class boilerplate macro) and then pass that string to a constexpr string hash function to get back a single number (ideally with a debug mode version that ensures you don't have collisions), and then use that as your Id. That'll give you stable Id numbers so long as you don't change the name of anything that uses the ids. Another choice is to have each class register itself with some global table at statics initialization time (without regard to order of operations), and then walk the table in your main function and assign I'd numbers that way.
I recommend you add a UUID to the end of your include guard. Then you are guaranteed to never have an include guard collision.
A CS degree will for sure help. But you can also take a few courses on Coursera by yourself - you'll find the "famous" ones easily with a bit of Googling/popularity sorting - Algorithm class from Stanford etc. I'm not sure if you get an exam/mark in the unpaid classes, if not it might be worth paying for a certificate, but if you're short on money, I don't think you need it. If you manage to get to the interview stage of jobs, the important thing is that you do know the stuff, not that you have the certificate. Not sure about "no college education" but just try one of these (free) classes and see if you can pull through. If it's too hard, start with an easier/more basic class. There isn't really any worthwhile C++ certification I think. The best C++ certification is a nice GitHub project (or multiple), even better if it's something active which has a few stars/users. Start small at first, something in your field of interest, and can then grow slowly. As for software engineering, I'd recommend reading Game Programming Patterns ( [https://gameprogrammingpatterns.com/](https://gameprogrammingpatterns.com/) ) (in general, not just about games; and it's not C++ I think but that doesn't matter too much), or Head First Design Patterns (that's Java but again to get the general gist of patterns, it's great). But THEN, you also want/need something more C++ specific - for that, go watch CppCon/C++Now YouTube videos! If you're a beginner you can even go back as far as watching GoingNative 2013/2014 videos - start with the keynotes. Amazing stuff there.
Youâ€™ll be hard pressed to get your first few programming jobs, sure. It really doesnâ€™t make any difference past your late twenties ime, except in companies that donâ€™t let hiring managers make decisions. If you have relevant experience and interview well nobody even asks about a degree, why would they unless itâ€™s mandated by HR?
 inline static size_t counter = 1;
Either it depends on the country, or this Swede got really lucky. I got a decent software dev job as a high school dropout after my first job interview and a good programming job after studying things like English poetry and linguistics at uni for two years just by creating a LinkedIn profile and waiting for a recruiter to contact me.
That gave me a chuckle.
&gt;std::optional is not widely used in the standard and they still made it. How can it be widely used before it has been added? std::optional is not really about error handling. The lack of value could be the expected common case, and its usefulness is not limited to function boundaries.
&gt;it's the best of both worlds. Not in a world were memory is cheap and exceptions are rare.
GCC, I think.
This dident change anything, it does allow me to leave out the cpp file entirely, so thank you!
Fortunately, I've been studying on a tuition fee scholarship here so it is kind of okay for me to get an experience of both sides. What is frustrating is that I've to attend lectures of crap teachers even if I don't want to because of the attendance criteria BS :&lt;&lt;
Hmm alright. As i dont want to change alot at this point, i managed to fix it with another approach. Will edit original post.
"Common initial sequence" in the standard only refers to the members of a struct.
And all of them are prefixed with `Q` (at least I believe so). I dare say, Qt has pretty much claimed the whole space of names starting with a q for themselves in the c++ world.
I wrote it in the context of commit-or-abandon. There are examples of things gotten into the standard even though they did not commit into it across stdlib. In contrast there are many concepts (not optional) to deal with "lack of value" that are used across the library.
But do you really want to work for a company that employs such coarse HR filters during a talent search? In a tech-focused company i would say this is a sign of questionable management -- getting good talent in seats is one of their fundamental responsibilities. Personally, i would start to wonder where else they dropped the ball.
I think that not having a degree is fine when layoffs due to a downturn are being coordinated by engineering. As soon as HR coordinates layoffs however, they 99.99% of the time rank retainment based on qualifications. Those with PhDs go to top of list, then Masters, then Bachelors. Note that they don't tend to care what topic the degree was on, or its grade, *only that you have one*. I watched the IT bloodbath 2001-2003, and believe you me Bryce, it was galling. I saw the exact same happen again at BlackBerry when BB10 flopped, HR laid people off indiscrimant to talent or contribution. You had complete wastes of space retained, whilst some of the best engineers I've have ever known were booted. It's quite, quite scary how completely uninformed large orgs are about their talent. My very strongest advice to anyone without a degree is to *go get one* while the sun shines, and before the next tech bubble collapse. If you think that's not doable with full time work, WG21 participation etc, I should mention that I took a Maths degree part time by correspondance over seven years during full time work, getting a library into Boost, and having children. Don't get me wrong, it's hard hard work, but it's doable. Just set yourself to it. And, personally speaking, I found all my three undergraduate degrees very valuable. Education is never a waste of time, in my opinion. Plus, usually you can get your employer to contribute time and funding towards you taking a degree, and you can take it in a subject which proactively enhances your career e.g. in Management, Managerial accounting, or Machine Learning. Or go for the Classics, or Geology, if that's your hobby.
Ah, so if I have a disjoint collection of bits would I be able to use STL algorithms to collate them into a value, e.g. using std::rotate? Because that would be really nice.
[https://ned14.github.io/outcome/](https://ned14.github.io/outcome/) is guaranteed to work perfectly with exceptions and RTTI globally disabled. Indeed, one of its major user bases is reliable embedded systems with hard realtime constraints.
Last time I looked at the wording it was not ready for LWG review. It still needed a lot of work to get it into shape. I'm not sure what the current status is, as I haven't looked at the latest revisions of the proposal.
False positives are worse than false negatives in hiring. It makes sense to filter a bit coursely when you're a famous company that every other cs grad applies to
&gt; Using a filename without an extension is a big no-no. Only the standard library is allowed to do that. That's not true. The standard only reserves the names of the standard headers, not all possible filenames without extensions. It's good practice not to use filenames without extensions, so that there isn't a problem if some future version of the C++ standard adds `&lt;errors&gt;` (because then it *would* be disallowed). But it's wrong to say it's not allowed *today*. If you use a distinct convention like Qt's (e.g. &lt;QMixedCase&gt;) that will never clash with a standard C++ header, then you probably don't even need to worry about future versions of C++ clashing with your name.
That's what interviews are for. And profits/salaries at those companies indicate that they can afford to spend time properly vetting people in interviews. Phone interviews, online test prescreening, sample assignments, there are lots of ways to prefilter intelligently. Degrees are, and should be, an indicator of scholarly work. So they make sense, especially graduate degrees, for complex research positions -- but for general purpose developer positions, they really don't add much to the equation.
Perhaps, but one of my friends got a job working at an unspecified cpu manufacturer without being able to program. In my experience at least, companies are utterly desperate for anyone who can even pretend to code
Getting contacted by a recruiter isn't the same as getting the job
I work at a company which, for some of its groups, hires some of the best C++ developers in the world; this is not a hyperbole, I mean it literally. We have dozens of people who make their living out of writing C++ all day every day for critical environments where bugs can be catastrophic and performance matters. My suggestion is, without a doubt: **get a college degree, get it from a reputable place, and get it with a high GPA.** A college degree is still more than necessary: 1. it's a test of character and a measure of your attention to detail and determination. You can totally be a genius and not finish college... but over large populations, people who finish a good college with a high GPA tend to finish projects and finish them well. No manager wants to hire a genius that does not bring a single project to completion; 2. C++ is a means, not an end. C++ is just the beginning. It's like knowing the alphabet... but what are you going to write in it? Figuratively, you don't just need to learn the alphabet, you need to learn how to write poetry, and learning the alphabet is very different from learning to become a poet. Out of metaphor, you need exposure to some hard application domains and to math. This is why we ask for degrees in the sciences or in engineering or math or statistics. What's the point of knowing C++ like Bjarne if you don't know what a derivative or a quantile is? Verification: if you come in fresh from school, we actually don't expect you to be a C++ wizard, we just expect you to be smart, quick to learn, and have integrity. We test C++ competence mostly in experienced hires who claim C++ experience, and we don't care too much about outside ranking systems.
Getting offered a job is the same as getting offered a job though
My college had a two cs degrees, a science and an engineering once
I suggest also taking a class in object-oriented programming.
It is as /u/jonesmz says, the only guarantee for static initialization is that it will be initialized before its used. You might think that is fine, but in your case, what happens if the compiler decides to initialize `ComponentTypeIdentifier::identifier` before it initializes `ComponentTypeIdentifierCounter::counter`? Well, `ComponentTypeIdentifier::identifier` will get whatever garbage value the uninitialized `ComponentTypeIdentifierCounter::counter` has. This is what's happening to you. In your case, the garbage value happens to be 0, but you can't really depend on that always being the case. Its unsafe to have a static object's initialization depend on another static object. This is known as the static initialization order fiasco (https://isocpp.org/wiki/faq/ctors#static-init-order). Your fix in your edit is a fine solution to the problem.
Or unusually hard working, surely?
So much this. I worry people see these stories and think â€œI can do thisâ€ thatâ€™s not the case for Iâ€™d say the majority of people. These stories are great and impressive but they are the exception in my opinion not the rule.
I'll have to add -Wmissing-collusion to our process.
Having applied to CPU manufacturers, I am skeptical. Your friend hit the lottery basically.
As my wife went through a CS program (with C++ as the teaching language), one of her profs was fired mid-semester. They had not been giving out assignments/coding projects and frequently cancelling class. Fortunately I was able to work with her and we basically worked through the material together with Bjarne's Principles &amp; Practice Using C++ book. Now, she's a successfully employed SWE (though not using C++ these days). &amp;#x200B; It just makes me wonder how many people fail out of CS programs because of profs like this. How many of her classmates dropped the degree because they couldn't recover? How much does this happen nation-wide? I know several of my profs were terrible, though none were ever actually fired like this.
Times Have changed now,there are way more cs grads now and more and more people are taking up CS/STEM because it pays well the era of the passionate being in CS is gone imo. Academic criteria and cs courses are being lowered interms of quality . People are screeming gatekeeping at those who still have high standards.There are plenty examples on twitter of those from super non stem backgrounds taking up cs. If you think about it rationally why would a corp hire someone with no degree when they can get someone with equal experience and degree.
Personal bias; self-taught are so passionate about what they are doing that they go the extra mile and then 99 more miles just because they can't get enough! The motivation isn't money.. sure, it's good to get paid and even better if you exit or two, but the money is never the primary motivation (at this point for me it's just a number, not amazingly great one but it has come to that all by itself w/o trying too hard).
I see! I thought that since the identifier was 0, the counter was 0. And since 0 is not a garbage value(or atleast i thought so since it dident seem like a random messy value), the counter was initialized in some sense, just that it initialized in some unpredictable way i wasent in a position to understand without further explanation. So, it was just a coincidence that the garbage value was 0? Or was it 0 because its a kind of default value for unsigned integers?
I also got a job there as well despite being relatively new, although I could do a fair amount of the kind of programming they were looking for by relative coincidence. They were super desperate for anyone to apply
I know man, honestly, itâ€™s such bullshit but at least she managed to get it sorted with your help. Iâ€™m currently going through the PPP book myself, itâ€™s a great book, a bit wordy and sometimes not very clear in my opinion but getting on just fine (again, with a little help from the internet). Youâ€™re right, how many people have dropped out due to crappy support, you could argue that people need to help themselves but when tuition fees are so expensive you expect to be properly taught what you need to know and from what i can tell it just isnâ€™t happening, i plan to do 2 years of self study in C++ and then apply for a job but without a degree i donâ€™t know how far iâ€™m going to get, anyhow, thatâ€™s my 2 cents ðŸ˜‚
That may be sample bias. FAANG has a lot of high-end C++ software engineers without CS degrees or any degree at all. I agree with you that a CS degree helps at the entry level, no question. But it is insufficient to land a job designing the next parallel database engine at Google or wherever, and at that level of C++ software design the type of degree or even having a degree is almost orthogonal to competency. At the high-end of C++ software engineering, everyone is self-taught. If you work on database kernels or HPC or similar, you quickly figure out that most of what you were taught about data structures and algorithms is a polite fiction. The most valuable skill in these domains, somewhat independent of programming language, is the ability to design systems from first principles which isn't a skill you generally learn in school. And once you have a few years of experience, most good tech companies don't care about a degree, even for more average C++ jobs. Many companies are familiar with the research showing that after two years of experience, competency is not correlated with degree.
Hello, I've shared your program to the Italian C++ community and a member said: &gt; *Nice!* &gt; &gt; *There's not automatic padding management though* I know it could be done with `SKIPPING_&lt;N&gt;` to make it explicit, but maybe it could be integrated into the program. ---- Now that's my question: &gt; Do you think that being able to parse simple structs might be useful? Like defining them into a file, then using something like `hexibit --def=struct.def -f data.bin -i StructName` Then the output would show each member with their name. Perhaps that's a very time consuming task for a program that would like to remain simple.
College degree? Pfft. That one commenter above achieved everything in the universe without a college degree. College is for chumps. Hell I'll say even school is for chumps. There is this baby I know who is a C++ dev in SF pulling $350K plus bonus.
I know you were being sarcastic and you agree with what I wrote; at the same time, I don't dispute the claim that there are many paths to a career in C++, many of which unorthodox. I just gave a fair representation of the hiring practices where I work, and made an overall claim that in large populations, college performance tends to be a decent predictor of future work performance.
It really depends on the country / city, but here in Germany there is a serious shortage in developers. If you don't aim to only work at a huge company (like MS/Google or something like BMW) I would say it's not necessary to have a degree. I hire people from time to time / help with the technical interviews and I'm able to at least have a glance at all the applicants (20 per position). So when you don't have a degree, but you have a good online portfolio (e.g. personal Github account with your own projects / open source contributions, Hackathon prices or something like that) then I would definitely give you a chance. That being said not having a degree can still bite you later on. Even though you might prove talented it will probably block you from getting into higher positions (e.g. team lead) later on.
Standards committee really needs to resolve this issue. I know, I know...if you want it done then propose it, argue for it, etc...but I'm not the one to do it. Not qualified. And this is a huge sore thumb.
&gt; i plan to do 2 years of self study in C++ and then apply for a job but without a degree i donâ€™t know how far iâ€™m going to get, anyhow, thatâ€™s my 2 cents It can be done, especially looking at examples people give in this thread elsewhere. My biggest advice is that you have to have at least one demonstrable project you can show off and speak to the technical aspects of. It doesn't have to be some unique invention, but it has to be non-trivial. /u/blelbach I think gave a good example where he contributed to open source to get a solid start. Make sure to embrace some of the things that make modern C++ powerful and that show off your attention to building quality software. For example, write your program cross-platform. Use c++17 (and up). Compile with -Wall and -Wextra (on GCC/clang at least) and try to eliminate all warnings. Prefer STL features over platform-specific features where possible (like with threads, or filesystem access). Good luck on your future studies!
Any large scale online test screening would result in lots of cheating. Probably anything that doesn't cost an hour of engineer time will result in lots of cheating. It's not that people with engineers are better, it's just that they get so many good people applying (and even more bad people) that it makes sense to filter by things that will filter out a high number of unqualified people quickly, even if it filters some good people too. If 50% of programmers who had been to Canada were unqualified and 80% who hadn't been had been unqualified, they would probably filter by that too (if it was legal).
You NEED computer science, CS is not just some busy work, it is a rigorous science and engineering discipline. While a good deal of programming is accessible to people with high school education or less, those jobs are a race to the bottom with declining wages and benefits. The good jobs, require sometimes a Masterâ€™s and even Doctorate degree. That said, what matters is the knowledge, not the degree, which is why I recommend checking out OCW (OpenCourseWare). Many universities provide courses for free. If you are committed you can learn everything a CS student learns from home. This doesnâ€™t resolve the lack of degree (piece of paper) issue, but if you do learn CS on your own, maybe you will get a chance to demonstrate that you have the knowledge without a degree.
I hire C++ developers. For my company a degree is required. It does not have to be computer related if you can demonstrate strong aptitude. The language itself is not very important. Because C++ is a low level language, a strong understanding of computer architecture (hardware, operating systems, etc.) is required. Strong knowledge and background in algorithms. Math. The fundamentals are what matter - you can go look stuff up about the language itself on stack overflow all day long and I won't care.
Yes, LEWG did not yet clear it for LWG review, there were still design issues, however we did have consensus that we want something close to what was suggested. I guess there will be renewed discussions in the next cycle, and Herb's(deterministic Exceptions) , Niall's (/u/14ned, boost outcome) might change the proposal significantly (or even render it obsolete), but for the OP's question I think it is fair to say that the idea/style behind it has support in the committee.
&gt;A degree in software engineering or computer science is no doubt a sure way, but I have time and wondering if I can reach that level of programming competency without college. Getting a degree in CS or engineering is a way, but nothing is sure. C++ jobs are not very plentiful so getting one fresh out of school is not a sure thing. I can say that getting any kind of software development job without a degree will be hard. If you don't want to get a degree you're better off studying web stuff because the bar is somewhat lower in that area, and jobs are more plentiful. I think most C++ jobs these days are not general at all. They usually require some knowledge in another area relevant to the application being built. Most of these are very technical subjects and you won't be trusted to work on them without a degree or a very impressive portfolio. If your heart is set on doing C++ without a degree I think game development may be the easiest field to get into. But even for that field, getting a job won't be easy. Lots of people love games, and lots of those game lovers are CS grads. Many people study CS just so they can make games, and then they end up doing something else because the game industry can't absorb all those people. In summary, if you don't want to get a degree, try web development. No software job will be easy to get without a degree, but that's your best bet.
Did you mean to write CVS?
That's my point, it's a far off outlier. No way you are getting interviews for dev jobs (let alone C++ dev jobs) in today's date without a college degree. You may get lucky and land one, but it's probably like 1 in 5,000 probability. Not to say that a college degree makes you a master, but that piece of paper matters in the industry. To say that it doesn't is mocking everyone who busts their ass to get college degrees.
&gt;That may be sample bias. FAANG has a lot of high-end C++ software engineers without CS degrees or any degree at all. That may be true. Big companies love to yak about how they will take anyone smart, but I think that's mostly PR. &gt;But it is insufficient to land a job designing the next parallel database engine at Google or wherever, and at that level of C++ software design the type of degree or even having a degree is almost orthogonal to competency. I don't think it's orthogonal at all. You learn a lot of theory in school, and that would be the best place to apply it. A ton of competent engineers with degrees apply to Google, some of them famous even, and they get turned around at the door because they can't pass some bullshit interview that has nothing to do with the job. I guess it isn't just because of the interview though. It's hard because so many people want to work at companies like that, and it's really hard to legitimately select among so many qualified people. &gt; At the high-end of C++ software engineering, everyone is self-taught. If you mean they don't have degrees, I strongly disagree. If you mean, they have to figure out their own way because the problems they encounter are different from what they learned in school, then I strongly agree with that.
Be the change you want to see, and all that. I'm of the opinion that "software engineer" should be a legally protected title similar to the other engineering fields, so it's the one bugbear I let myself get a tad pedantic about.
For me personally, the current `std::expected`'s main design flaw is that it preferentially treats success over failure. I don't think that's necessary, (Boost.)Outcome will implicitly construct from either success or failure types whenever it is absolutely unambiguous which is which. There is a single hacky corner case involving `bool` inputs, but otherwise this has worked very well. End users are particularly pleased with having to type less, and generic code composes better with the implicit construction from both choices of type. Otherwise, `std::expected` seems fine to me. I have a few minor quibbles in a few minor corner cases, but nothing showstopper. I agree with Jonathan that it still needs a good bit of work to get its standardese complete, and I also agree that it might be worth revisiting if WG21 decides to **not** proceed with Herb's exceptions, as much more load will obviously get dumped onto it with different use cases than originally expected.
I think it should be too, but the idea of being forced to get an engineering license at this stage in my career somewhat annoys me. The idea of potentially losing my ability to work because someone fucked up the project I'm working on also scares me. Maybe I'm overthinking it though, and until companies start being more liable for their software fuckups I doubt a license will ever be required.
Skill alone will allow you to get some C++ jobs, though not many if we're honest unless you have an incredible CV/resume. A college degree will open up some more. A really good CV/resume will help some. So will a really good GitHub repo. A college degree in a technical field such as mechanical engineering, electrical engineering, chemistry, or physics will open up a ton more. If you can demonstrate a knowledge of the CS-topics tadziobadzio listed, you can get into a lot more jobs. For some limited, situations you'd actually be more desirable than a straight CS-student. A computer engineering degree is now assumed to include a fair amount of programming and can get you into even more jobs. And like the ME/EE/Chem/Physics degrees, it can actually be more desirable than a CS-degree for some jobs. A CS-degree will open up all the typical programming jobs.
I'm sorry I'm not quite sure I understand what you're asking. The library provides a few different (non-owning) smart pointer implementations with various performance-flexibility trade-offs that can be used as replacements for raw pointers (including the `this` pointer). The library [doesn't](https://github.com/duneroadrunner/SaferCPlusPlus#safely-passing-parameters-by-reference) intrinsically mandate that you use any specific type of (safe) smart pointer. You can make the (static) member functions of your classes/structs into function templates so that they can accept any type of (safe) smart pointer. Or if you don't want to do that you can declare the `this` pointer parameter as a "[scope pointer](https://github.com/duneroadrunner/SaferCPlusPlus#txscopeitemfixedpointer)", which is a fast smart pointer with significant usage restrictions enforced at compile-time. You can obtain a scope pointer from most of the other (smart) pointer types when necessary. Does that help?
Even at the best universities, you'll encounter crap teachers for any degree at some point. But at any decent university, you'll also encounter at least decent ones for a majority of classes and a couple good ones. But everyone loves to share the stories about their crap teachers instead of their good ones. "I had a really good teacher..." just isn't the beginning of an interesting conversation. "I had this awful professor whose lectures were just him reading from the textbook..." however makes for a much more interesting story.
Closest that I know of, and the one I based the performance papers on, is the cxx-modules branch of GCC: [https://gcc.gnu.org/wiki/cxx-modules](https://gcc.gnu.org/wiki/cxx-modules)
&gt;I know at the company I work at you wouldn't even get past automated filtering. That is a shameful way to handle applications. Please consider having your company change that.
Anyone who says you can't get a job in C++ without a degree is definitely wrong. There are some stodgy companies who might require a degree, but probably they aren't necessarily ones you really want to work for anyway. Any company with a brain in its head is going to be interested in one thing and one thing only, which is demonstrated capability and experience. The software world is full of extremely experienced people who are self taught. I'm one, and I'll put my portfolio up against anybody on the planet. The trick is to get experience. Ultimately you will only get that by doing it in the real world. A degree is obviously not going to hurt, but you aren't going to come out of college being able to compete with people who have been doing it for real for 5+ years and really digging in, unless of course you spend all your time not in classes also really digging in. Of course some of it comes down to what kind of job you want. If you want to work in some area where it's about doctoral thesis levels of complexity, then you may need to get the degree, but that degree probably will be not in software but in the problem domain you want to concentrate on, with software being a secondary undertaking. But, if what you want to do is just software development, you don't need a college degree to do that. If you spend the same four years in your bedroom working 12 hours a day, 6 days a week, learning everything you can and building real software always at the limits of your abilities and immersing yourself in it, you will almost certainly come out of that period of time with far more experience and understanding of the craft. Not because it's inherently a superior method to a formal degree, but because you aren't going to be required to put so much of you time into other things, which you will in school. I don't think you couldYou couldn't possible put in that much time at learning software in the same period if you are getting a general degree.
Being there in person, or writing a paper aren't the only options. Most people on committee are there to represent a set of stake holders, including users. Find someone on committee and have frank conversations with them.
&gt; Not having a degree is going to close A LOT of doors for you in fields where C++ is relevant This is not my experience at all.
That professor was an outlier for sure, but we all have to deal with awful professors at some point. That being said, there are some bad prof and sometimes even bad department decisions that make people change degrees. The one example I have is when my university became an early adopter of a way to teach calculus for soft-science majors where the first half of the semester was nothing but teaching limits using calculators and hand calculations. Theory, symbolic differentiation, etc... were taught the second half of the semester. I already don't like that way of teaching, but the kicker was that my university was a quarter school (3 quarters per year), so that for the first quarter students only had 2 weeks of theory and symbolic differentiation before their final. Over 50% of students flunked that first class for the two years they implemented that plan. The number that got As and Bs was tiny. The number of students who changed majors away from the soft sciences, including my now wife, was huge.
I appreciate your perception and feeling in the subject, and I think you'd find a lot of people on committee who agree. It's sad that Coroutines couldn't be perfect, but when you're arguing with your compiler writer, and he's saying "it's not possible in the next 10 years" at some point you've got to listen to him.
Yeah absolutely, i know thereâ€™s a mix of both, when i was at university i had terrible lecturers but obviously thereâ€™s decent ones, the problem is there shouldnâ€™t be any shit ones for the money your paying
Thanks for your feedback :). On the first point, user specified padding was initially gonna be part of my first release. Then I realized it was not needed for an MVP, since as you pointed out, you could emulate that feature with SKIPPED_. Good point though, Iâ€™m gonna start looking into this next. Your question is really interesting. I would imagine it to be the next feature one would want to add. For that to happen, automatic padding is kind of a prerequisite. Still, I could start with a naive implementation that would reinterpret your data as if it was tightly packed. I would definitely want to keep this tool as simple as possible, but if new features can be added upon without complicating the initial framework, Iâ€™ll go wherever the community wants to go :). Thanks again for your feedback and for sharing this as well m!
I'll be honest, I'm trying to make sense of static variable initialization for you, and I'm having a hard time figuring it out. The rules are here, under "Non-Local Variables": https://en.cppreference.com/w/cpp/language/initialization From what I read, I would have expected `ComponentTypeIdentifierCounter::counter` to be initialized to 1 during the static initialization phase, and then each ComponentTypeIdentifier&lt;ComponentType&gt;::identifier would have been initialized in the dynamic initialization phase, specifically as "Unordered dynamic initialization". If that were the case, then I don't see why your program wouldn't have worked as you expected the first time you wrote it. Either I'm not understanding the initialization orders correctly, some code you're not showing has a bug, or your compiler has bug.
Yes it is.
For all the reasons stated by others, it's difficult. If it was me, I'd try breaking into the industry through web development and then pivoting after a few years. Especially without a degree, getting industry experience and relevant lines on your resume is key. Delaying this for far too long in order to get a C++ job may be detrimental. &gt; Additional topics to be knowledgeable on (because a 4 year degree has to cover a lot) Many universities have their curricula available online. A cross comparison between various can give you a decent image of what a typical computer science student comes out with after a 4-year degree. &gt; I donâ€™t know if I want to work on game development, or practical applications and honestly Iâ€™d love to learn both to be efficient. You might want to get an idea of the domain you want to work it. Experience in related area in addition to C++ makes you a stronger candidate.
I hope not, who uses CVS any more? VCS as in Version Control System would make more sense...
Not going to happen. We have systems that are safety-critical and if something bad were to happen it would become a PR nightmare if we were hiring developers with no formal credentials. Just look at 737 MAX and the flak they are getting for outsourcing some of their development work.
Well it's settled then, apply away OP!
That touches on a major issue with education, particularly in the US. There's a lot of pressure on education, mostly from jobs and post-secondary institutions, to focus on rank-sorting versus education because "we'll teach them what we need... just tell us who are the easiest to train." As such, you get a focus on things like drilling the times tables, which is a skill that a 25-cent calculator can handle. Of course, you need to teach multiplication... but you don't need to spend day-in and day-out making kids compete over how accurate they can multiply 1-through-12 by 1-through-12 in their head. The problem: You're spending so much time teaching skills that can be replaced by a 25-cent machine that you don't spend the time teaching how to solve meaningful problems with the 25-cent machine. And we're finding that rank-sorting doesn't even really get the good candidates anyway. As public schools have moved toward formative-feedback, we're seeing things like gender- and racial-balance even out when assessed. So... like... sure. They can filter based on the statistics they see, but blindly following statistics also means that they're blindly accepting however those statistics were made... and that could be horribly irresponsible.
I had to make my own branch of clangs implementation to make it usable. GCCs is definitely the closest.
I like Scott Meyers' TD trick: template &lt;typename T&gt; struct TD; // no definition Now you write something like `TD&lt;decltype(thing)&gt;` and the error message tells you the type of `thing` (as deduced by `decltype`, of course, but in this case that's probably what you want).
A bachelor's degree has not been an indicator of interview performance over the 15 yrs or so I've been doing them. And good grades have been more an indicator of work ethic than technical skills. Guess I disagree.
thanks for reminding me why I don't frequent this sub anymore
Rip quaternions
Just as another anecdote. I didnâ€™t need to get a degree, since the company I currently work for offered me a job years before I got one. However, I decided to get one anyway, just to have the paper and I think it was a good decision. For example the amount of vacation days depends on it in Poland, which is where I moved to for work. The work is very specialized though so Iâ€™m pretty sure it does not generalize. If you are in a position where you do not need a degree early on (Iâ€™m 23 now) I would recommend you get one anyway. Itâ€™s only a few years and it happened to be a great experience for me too! If you are not in a position where you do not need a degree (which I guess would be most people) you have to realize that going through the motions and getting a degree does not make you anything. As mentioned it is really important to learn skills you will not learn as part of a regular curriculum (professional communication, real software development and work ethic being a few of those). Being interested outside of the curriculum and doing open source were great sources of learning for me and I would highly recommend you do the same.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/c7q56n/is_this_a_safe_way_of_giving_types_an_identifier/eshtplg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You're spamming this subreddit. Please stop.
Are they even going to solve anything? From reading (not very thoroughly, I admit) various sources I don't see how they aren't just syntactic sugar for a bunch of includes. What _do_ they actually solve, in concrete terms?
Very nice title
There's going to be a lot of bigger companies that will filter you out instantly for having no degree just like others have said. It sucks to be honest, but it's their choice. I've even had to show college transcripts before being sent an offer letter in the past and that was after working at AMD for 6 years. ...but I feel like I've seen a lot more places say that they don't care anymore as long as you can make it through the coding tests and such, which is really awesome to see. Also there's a lot of companies will hire you without a degree but you'll be stuck as a lower level employee, kinda like a contractor. I've actually met some of the most amazing engineers that were in that situation and on the flip side I've met countless PhD engineers that were 2 steps away from being unless... I would say if you're hella motivated and are willing to put in the time to push and learn... then go for it without a degree. Think of it as learning another language, picking up words and putting them together into sentences might make you feel like you've made it but in reality you need to be fluent in that language. It takes a lot time to learn all the nuances, methods, best practices, etc... Check out leetcode.com and try some questions there, check out the discussions and see how you fair. Though be mindful some of the answers are so beyond unreadable that you would never see them in production code, but the solution most likely will be similar just expanded out a bit or all encapsulated up. Good luck dude!!!
Yes, obviously it was a typo :D I meant VCS
Honestly the biggest hurdle is probably to get that first job that actually looks good on your resume just to get through automated filtering. After that, not having a degree might not be such a huge difference anymore. But before that you'll probably have to search for quite a while.
I suggest taking only what classes you can afford without going into debt. Let the high price of college work for you.
I knew someone would post a counterexample as soon as I post this ;)
This is the top-level comment for **meta** discussion. Reply here if you have questions or concerns about this post.
This is the top-level comment for **individuals looking for work**. Reply here if you want employers to contact you. You don't need to follow a strict template, but I suggest inverting the relevant parts of the employer template. For example, mention whether you're looking for full-time or freelancing etc. work, briefly describe your experience (not a full resume; send that after you've been contacted), mention whether you care about location/remote/visa, and list the technologies you're skilled with. Feel free to disregard all of these suggestions, except that you obviously need to provide contact details.
Why donâ€™t you elaborate on your experience?
 You donâ€™t have a degree? How did you learn and get your foot in the door somewhere?
And you still don't know how to printscreen.
\*\*Company:\*\* [Kudan](https://www.kudan.io/) \*\*Type:\*\* Full time \*\*Description:\*\* Currently searching for three roles: * Computer vision engineers You will be jointly responsible for the complete pipeline of visual processing from sensor evaluation and selection, through data processing pipelines, to SLAM evaluation tools. * C++ Software engineers You will be responsible for software development within the context of computer vision. You will be aiding our team by implementing and improving robust algorithms to support our research and development teams. * Software test engineers You will be responsible for ensuring the quality of our SLAM software delivered by the research and development software teams through robust automated tests and scripts. You will be testing the algorithms for reliability and accuracy for both offline simulation and in on-target environments as appropriate. We are looking to expand our team with engineers who are passionate about state of the art computer vision to help us continue to produce leading SLAM software for the global market. You will be aiding our team by implementing existing research approaches as well as performing research and development of our SLAM software. Ideally a minimum of a few years experience, aiming to hire into mid/senior positions. \*\*Location:\*\* Bristol, UK \*\*Remote:\*\* No \*\*Visa Sponsorship:\*\* Yes \*\*Technologies:\*\* C++17 on Linux &amp; Mac &amp; Windows, some python, x86/x64/neon intrinsics, some GPGPU, knowledge of OpenCV, g2o and other computer vision technologies is a plus. \*\*Contact:\*\* Email me via [careers@kudan.eu](mailto:careers@kudan.eu)
Congratulations! That's a great feeling.
Can't quite figure out the intent for this library. What would you say it is most useful for?
Oh I agree completely with you. At my employer, as a non-experienced hire you wouldn't even get a phone screen without a college degree, AND from a good college AND with a good GPA. I completely agree with you. I qualified my answer a bit because outliers do exist and I don't want to diminish their contribution or dismiss their experience. But, statistically speaking, they ARE outliers. I agree with you completely.
How important is it that your degree be in CS? Would a degree in engineering (e.g., mechanical, electrical) be acceptable, provided you have demonstrated experience in C++?
Right, but some annotations can break things, e.g. if a function annotated with `[[noreturn]]`actually returns, you get UB. I suppose `[[nodiscard]]` is harmless enough since the standard doesn't seem too concerned with what implementations warn about. When first asking the question I mistakenly assumed it caused an error, which could break existing (if misguided) code, so I wondered (and still do) what exactly the standard allows implementations to do with this sort of thing.
Type - Full Time, Senior Software Engineer Location - Orange County, California, US, but willing to relocate for the right job. Remote would be doable too. Description - 7 years of development in C++ on a cross-platform backup/recovery system (file-level, database, and VM image backup, mostly). Mostly Linux, although I did stints of working on Windows features, and we supported a gazillion different Unixes, and I'd sometimes have to jump onto one and fix platform-specific issues. Technology - C++98/C++11, GCC Toolchain, Linux, CVS, Perforce, GMake for the build system, Perl, Python, and Ruby for the glue code. Experience - 7 years in C++, 3 years in build+release engineering Contact - DM for e-mail or LinkedIn
**Company**: [ScyllaDB](http://scylladb.com) &amp;#x200B; **Type**: Full time; remotes welcome &amp;#x200B; **Description**: ScyllaDB develops an open-source, high-performance, distributed NoSQL database, also (total coincidence) called ScyllaDB. ScyllaDB utilizes the asynchronous I/O engine [Seastar](http://seastar.io), which we also develop, to drive million of operations per second on large multi-core machines with fast SSDs. The stack includes everything from custom memory allocators, through a user-space TCP/IP stack using dpdk, through high-level concepts like query parsing and compilation and maintaining materialized views in synchronization with the base table. Linux environment. &amp;#x200B; Take a look at [https://github.com/scylladb/seastar](https://github.com/scylladb/seastar) and at [https://github.com/scylladb/scylla](https://github.com/scylladb/scylla); if you like what you see you'll enjoy working with us. We have a strong C++ team and don't shy away from the bleeding edge. &amp;#x200B; **Location**: Mostly remote around the planet; Israel; San Francisco Bay Area (around 15 countries). We prefer remotes from Europe/Israel timezones or nearby but can make exceptions for exceptional applicants. &amp;#x200B; **Remote**: Very much, most of the workforce is remote &amp;#x200B; **Visa Sponsorship**: in special cases &amp;#x200B; **Technologies**: C++17, C++ concepts, boost, asynchronous programming, distributed systems, future/promise, C++ coroutines (eventually), JIT &amp;#x200B; **Contact**: [jobs@scylladb.com](mailto:jobs@scylladb.com)
*Error, printer needs magenta*
Hey that's nothing man. I dropped out of 5th grade and am currently working as an adviser to Bjarne Stroustrup.
Sorry about that! I thought I posted it on the right one
Nice
In my 12 years on the field, there was precisely one interview where they cared about me dropping out of university. And even they wanted to hire me if I was willing to go back and finish my degree. I do know my algorithms and data structures, so I definitely don't mean to imply that CS is not useful. Also, when I was sitting on the other side of the table during interviews, I saw only a small correlation between a degree and skills.
XD
The architecture is snagged from the functional programming world (Elm). The core concept is that there's a single source of truth, the model, that contains all state. There's also a set of update functions, that creates a mutated copy of the state based on messages it receives, but they cannot have any side effects. Testing code without side effects are super easy, and most code can be made to work without side effects. &amp;#x200B; Now all programs have side effects, but they are treated a little different from regular messages. You can spin off side effecting functions that returns a message when they are done processing (reading from disk, the internet, the keyboard etc.). These can all run in parallel as long as their resulting messages are sequenced and applied in order, and that sequencing is completely handled behind the scenes by the library. In other words, the library handles all the synchronization for you, no need for mutexes, semaphores or condition variables. &amp;#x200B; To keep the application running, the update functions has to keep producing new messages in addition to updating the state. For example, a \`download\_cute\_kittens\` function might add the downloaded kittens to the \`roster\` collection in the state and produce a \`set\_forth\_towards\_mordor\` message which updates the state by moving all the kittens to the \`fellowship\` collection, and then when the \`wait\_for\_user\_command\` asynch function finally returns the \`push\_big\_red\_button\` message is emitted which.......... &amp;#x200B; So in short, to write an application with this architecture you will: \- Collect the few side effecting functions (impure) you need and concentrate on writing those tests, because they are hard to write and get right. You might need to mock a webserver or fake some user input. \- Write all the straight forward code as non side effecting (pure) functions, which are trivial to test. \- Forget the thread synchronization primitive API's \- Forget about segfaults and memory leaks since there is no memory management &amp;#x200B; Clone it and play with it, it's quite fun ;)
Use your Linux distribution's package manager. Or FreeBSD ports or MacPorts. Or Homebrew. Or vcpkg. Or roll your own.
C
I use reddit on mobile. Im not logged into reddit on my laptop.
Thanks for the great explanation, /u/aerkenemesis, sounds really interesting. One question I still have is: when two update functions update the model state in parallel, how are these two mutated model states reconciled into one?
I have the same feeling. And in general, most of his stuff seems like an advanced tricks that nobody will use in production - it is just for the intellectual fun.
&gt; You would be hard pressed to get a programming job these days without a degree. Pff, couldn't be more wrong. Not the most high-paying/prestigious one, sure, but it's still extremely easy to find a job/be self-employed if you have enough self-discipline.
I've been technical leadership for core infrastructure teams at multiple FAANGs, it isn't just PR. You have plenty of people that came in sideways from the sciences or more classical engineering disciplines without any formal computer science education. Also, more than a few college dropouts, and in one exceptional case, a *high school* dropout. You can't even get into these roles unless your demonstrated mastery of theoretical and applied computer science is far deeper than your average CS degree holder. Having a degree, or a relevant degree, is not part of the selection criteria. The key point when I used "self-taught" with respect to high-end C++ roles like the ones I've typically filled, is the knowledge that gets you the job is not taught at MIT, Stanford, etc. It doesn't matter how you arrived, there is an enormous amount of foundational theoretical work that *everyone* must teach themselves. Teaching yourself CS basics is trivial by comparison; anyone that has demonstrably mastered advanced theory relevant to the project is presumed to have mastered the basics. I've been designing bleeding edge systems for many years at Big Tech and I've never taken a CS course in my life (science background). My extensive theoretical and applied CS work and experience speaks for itself. Everyone else I work with has a similar type of resume, degrees don't enter into it.
https://www.destroyallsoftware.com/talks/wat
Type - Full Time, Internship / Junior Location - Tashkent, Uzbekistan and would really like to relocate. Remote might be ok. Description - 7 years of using C++ in a competitive programming setting. Not that much skilled with the C++ itself (in a sense that I know well enough just the stuff I need on competitions), but somewhat good at solving complex problems using it. Other experience includes working on small-scale Unity3D projects with C# (casual games and virtual reality projects), a couple neural-networks related projects on Python &amp; Keras.
I only see support for building a *static* library [here](https://github.com/gabime/spdlog/blob/v1.x/CMakeLists.txt#L65). This needs to be shared to allow use within multiple shared libraries. It also needs to be built shared by default so that it's built this way by all the distributions and package managers which provide it, from apt to vcpkg, and hence usable by other projects' libraries and executables.
The update functions never run in parallel, they are all sequenced. What runs in parallel are asynchronous tasks doing some work, eventually producing a message. &amp;#x200B; **Example:** Two async functions are started in parallel \`download\_code\` and \`read\_file\`, both functions return an \`std::future&lt;message&gt;\`, where \`message\` is a \`std::variant\` containing either a \`code\_downloaded\` message or a \`file\_read\` message respectively. &amp;#x200B; When the eventloop encounters these \`std::future&lt;message&gt;\` in the queue, it will realize they are \`std::future\`'s, so they will be put in a special "in\_progress" collection, and each pass of the update loop they are checked for completion. &amp;#x200B; Eventually when they complete, the eventloop will extract the contents of the \`std::future\` and add it back to the message queue. Since they are no more side effecting processes (they are \`message\`'s now, and not \`std::future&lt;message&gt;\`'s anymore), they can safely applied by the update function. &amp;#x200B; I hope that is clear, english is not my native language and I'm quite tired.
I'm also not 100% informed on the subject, but my previous job was about 50% "Make our custom build system not suck" for the last 2 years, so I was pretty heavily involved in all things related to dependency handling, linker crap, ABI crap, and so on. I gave modules a very serious look about 12 months ago, and didn't walk away feeling like they did anything for me, in my situation. In fact, supporting them was going to require quite a bit of work on my end without any real benefit, TO ME, in MY situation. The quick and dirty explanation is that Modules are pre-compiled headers, with more user level control over what's getting included in them, and the ability to explicitly depend on other modules. What this means is that you should, theoretically, be able to hand someone a module file (and all of it's dependency modules...) and they'll be able to start programming against it immediately. Further, given that you have fine grained control over what's being "exported" into the module file, you should be able to not only *hide* your various implementation details, but actually make them completely not there as far as your module's public facing interface is concerned. E.g., you're supposed to be able to have as much of namespace impl { blahblahblah, all the sausage making here } and then simply not export that namespace. Not only is it not accessible to consumers of your module, but it's not even in the module file in a form that could be consumed if the consumers really really wanted to. There's certainly advantages to having that ability, of course. One such advantage that most people don't realize immediately is that this drastically cuts down on the amount of work that the Linker is going to need to do when you link all of your .o files together. But here's where it's not all good. Module file names have no relationship to the name of the source code that they live inside. Further, module file names can be controlled by the C pre-processor. This means that cat.cpp can export a module named "automobile" if macro A is defined, and "jupiter" if macro B is defined. (I don't recall if you can export two modules from the same cpp file. I guess I don't see why not?). And further, header files can export modules (because they just get copy-pasta'ed into the cpp file, so of course they can) This is problematic because it basically means you either need - A pre-compile pass that scans your entire codebase for every cpp file you're compiling - A cache of module data that contains the mapping between modules and the code that contributes to them for every unique combination of commandline arguments And the *reason* you need this is because you need to know if the module you're about to consume is up to date with the latest code changes. For my situation, this was a complete show stopper. We absolutely were not going to participate in the module ecosystem if we needed to do either of the above two steps. Both for architectural reasons, and also because we'd literally just stripped out the custom code scanner that was being used to determine include file dependencies (which can't be renamed based on macros, mind you) in favor of having the compiler tell us the include files the first time we compiled the cpp file in question, and got tremendous speedup as a result. "But why not do the same thing with the modules feature?" you might ask. Can't, because the mapping between file names and module names can change based on the cpp file being compiled, not the cpp / h file with the export keyword. The compiler *cannot know* based on only the cpp file / h file containing the export keyword whether a particular module is going to be changed based on recompiling the current cpp/h file. What the compiler *can* do is say "There is a possibility that a change in this file will change the module in question". But that's going to have plenty of false positives. So the "best case" scenario is for the compiler to spit out some kind of rule set that later parts of the build system can use to determine if they need to trigger a recompile the module in question. -------------------------------- But I have to say that my personal take on this whole situation is that people clamoring for package managers are missing the bloody point. I have zero issue with dependency management, because I don't want to just "include the package, and then I'm done!" I want deep control over what gets included into my code, and how the code i include functions. I'm not at all interested in allowing for a third party to push a package update and then blindly consume it. Modules are intended to solve a bunch of related "build the code" related problems, and while they tangentially touch on the whole package management situation, it's not a particularly strong connection, in my assessment. From a build time perspective, I would have been *much* more interested in seeing a specification that described how to compile multiple cpp files in parallel. E.g. A single compiler instance (with multiple threads) can be informed of all of the cpp files that will be included in a shared library, or executable, and will compile all of those cpp files in parallel. This has advantages for allowing the compiler to analyze the full include file list for all of the cpp files in the library at once, completely eliminating all of the advantages that might be found from using pre-compiled headers to, well, pre-compile a set of headers. Further, the compiler in this situation could still spit out .o files, and even spit out a pre-compiled header based on it's own internal assessment of what's reasonable to include in such PCH file, so that subsequent invocations with only some (not all) of the source files being changed allowed the compiler to dynamically skip what's being done. And finally, this approach also automatically results in Link Time Optimization happening, instead of the current LTO approach involving multiple compiler invocations resulting in intermediate representations, and then a final invocation (via the linker) resulting in the actual optimization pass, we can skip all of that and go straight to the link time optimization that happens at the very end of the process. While none of that does anything with regard to cross shared library boundary concerns, nor does it do anything regarding packaging, I personally suspect it would have resulted in much larger gains from the perspective of compile times, and is something I was much more interested in seeing happen when I was maintaining a build system.
Yes, that clears it up, thanks a lot and have a good rest. Really appreciate the thorough explanation. I live in the USA, but English is not my native language either :-)
You're welcome by the way. They are good and valid questions, and I can re-use the explanations for the readme :)
IIRC, last I asked the implementer, it is not ready for regular use.
At first I thought maybe only **Visual Studio** could, but I'm finding people who have mixed-mode **VSCode** debugging - https://www.reddit.com/r/vscode/comments/c254y5/is_it_possible_to_debug_c_extensions_for_python/eriniue/ - https://gist.github.com/asroy/ca018117e5dbbf53569b696a8c89204f
Don't become a C++ developer. Become a developer who can use C++. While C++ is a language I've worked in for many years, I can also develop in C, Java, Python, or whatever it takes. Picking up new languages is not hard, once you've experienced one or two. My last role was writing C++ libraries for image processing. My current job is embedded C for medical diagnostics. What I'm saying is, don't let yourself be pigeonholed by your choice of language. Become an expert, but don't let it define you. If you're going to have a whole career as a developer, you're going to have to consider the risk of being a specialist in just one thing. If in twenty years time, C++ is supplanted by some other language, and it becomes even more niche than it is today, you wouldn't want to be unemployable because of that. While I am a C++ developer, I also have degrees from Bachelors through to PhD in various biological sciences subjects, from molecular biology to immunology. That got me a job in C++ development for medical imaging, and now in diagnostics. Having experience in *applying* your programming expertise in other fields in which you are also an expert makes you unique and valuable. Programming is in high demand the world over in all sorts of fields. What interests you outside of C++ development. See if you can combine the two, and have a unique selling point and angle. Lastly, regarding degrees. A degree in computer science or software engineering is very useful. So is a science degree. I know people who succeeded without one, but they are in a small minority, so I'm absolutely recommend getting one. It will open doors for you. You can get to the same place on experience alone, and I started my career doing 12 hour day and night shifts in an industrial laboratory, but it's much harder, takes longer, and has less chance of success. However, you'll likely have much more domain-specific expertise if you go this route.
`[[nodiscard]]` only triggers a warning. Any function which return is not used will likely get somewhat different assembly, regardless of the attribute. But yeah, for `[[noreturn]]` it allows some optimizations which cause UB if the function does actually return.
Indeed, it's still a work in progress. But it's the farthest along that matches the C++ 20 language. The others are still tracking the TS or their own pre-20 variation. Would love to hear if there's someone else closer though. As we in the sg15 tooling group desperately need one for experimenting and testing of tooling and performance.
Well, at least your comment answer my question. \^\^ Can you tell me why you are calling my posts spam? I'm new at the Reddit thing, and it didn't occurred to me that posting a new article once a week on a subreddit could be considered as spam. You answer will help me to not reproduce my mistake again.
I'm right there with you, I'm rapidly approaching the point where if my engineering degree doesn't grandfather me in somehow then it makes no financial sense to go through the rigmarole of getting licensed. Though as a comfort, I don't think we need a ton of software engineers, since most of the implementation work can be done by devs instead. Hopefully this current boeing outsourcing will be the catalyst for change. It kind of blows my mind that because machines and infrastructure can kill people we require a special piece of paper to build them, but if software can kill someone we just kind of hope the ensuing lawsuits makes shoddy oversight unprofitable enough to write better code in the first place.
Is that a constraint to c++? Many languages use Linting without compiling. Maybe you are thinking static code analysis?
Hmm cool, thanks very much. I'll ship this around some of the people I work with and see if we get some useful out of it.
One of the all time greatest talks.
Does it compile? o.O
This is amazing! I've been looking for a project like this in its early days to learn how to do these kind of thing!
Very admirable job at attempting to be funny without offending anyone. Almost succeeded too.
**Type:** Full time, internship, contract &amp;#x200B; **Description:** Recent High School graduate, 4 years of development in C++. I'm a quick learner and am excited to learn new technologies. &amp;#x200B; **Location:** Menomonee Falls, WI, willing to relocate. Outside of the USA will require a visa sponsor. &amp;#x200B; **Technologies:** C++17, Vulkan, OpenGL, Git, Linux, CMake, Java &amp;#x200B; **Contact:** DM
Not sure if I'm missing something big or not, but isn't "view" part of the elm architecture? It doesn't seem to be here.
The core of OP's problem is that, since C++17, `reinterpret_cast&lt;char*&gt;(&amp;x)` formally points to `x`'s initial `char` member subobject if it has one instead of `x`'s first storage-byte. The distinction matters because pointer arithmetic across all bytes of `x` is undefined with the subobject pointer value, but well-defined (at least by intent) with the storage-byte pointer value. This looks like a de jure usability problem with the language, especially if there is no portable workaround (and I can't see one).
 **Company:** [Esri](https://www.esri.com/) **Type:** Full time **Description:** Viewing, exploring, and filtering geographic content is a key process for gaining insights into our world. Weâ€™re looking for someone passionate about interactive exploration of GIS data in three dimensions who can help us design and deliver software that helps our users gather knowledge and understanding from their content. As part of the map exploration team within the ArcGIS Pro software development team, youâ€™ll help design, test, maintain, and document the many tools and capabilities that allow users to filter and explore their GIS data. This includes enhancements to existing capabilities for navigation and selection, interactive 3D analytics such as viewsheds and lines-of-sight, and authoring fly-through animation videos. It also includes investigation and research into future capabilities, such as animated objects and scenario simulations. Youâ€™ll be actively involved in ensuring the usability, quality, and functionality of the software in order to support realistic workflows and use cases. We are redesigning and expanding many aspects of our data exploration capabilities in ArcGIS Pro, so now is a great time to add your skills to a diverse team of engineers and developers committed to delivering a host of innovative data exploration tools. **General Requirements:** Â· Experience with C++, C#, Java, or another object oriented language Â· Ability to work well in a highly collaborative environment Â· Knowledge of software development processes Â· 1+ years of experience using an application development language (such as C++, Java, or C#) Â· Strong analytical problem-solving abilities Â· Excellent written and verbal communication skills Â· Bachelorâ€™s in computer science, computer engineering, or a related field, depending on position level **Bonus points for experience with:** Â· 1 or more years on a commercial or open source software project Â· Working knowledge of computer graphics APIs such as DirectX and OpenGL Â· Working knowledge of web GIS technologies such as JSON, REST, and JavaScript Â· Familiarity with Esri ArcGIS platform technologies **Location:** Redlands, CA **Remote:** Not for this particular role **Visa Sponsorship:** Yes **Technologies:** Â· C#, C++ Â· VisualStudio Â· Git, Github Â· Jenkins Â· Bash, Python3 Â· OpenGL, OpenGLES, DirectX11, Metal, GLSL Â· Both Esri and open source GIS technologies and standards **Contact:** [www.esri.com/careers](https://www.esri.com/careers) is the best route. Some questions can be answered in the thread. We have several opportunities available currently in development, and Product Engineering. Product Engineering is a broader role that includes development, testing, and collaboration with other development teams across the ArcGIS platform.
Yeah if you want to do web development for poverty wages you might be able to do that without a degree easily.
**Company:** [Broadsign](https://broadsign.com) **Type:** Full time and internships **Description:** As the leading SaaS company in digital signage, weâ€™re a place for people who envision a better digital future and arenâ€™t afraid to embark on ambitious challenges to change the status quo. We're looking for C++ developers to work on our Control suite consisting of a back-end, cross-platform media player and desktop administrative application. A more detailed description is available [here](https://broadsign.com/job/software-developer) and some of the reasons why Broadsign is a kick-ass place to work are [here](https://broadsign.com/careers/). **Location:** MontrÃ©al, QC. Speaking French is a plus, but not required. **Remote:** No **Visa Sponsorship:** No **Technologies:** C++11, Qt, PostgreSQL, SQLite, CMake, Jenkins. Both Windows and Linux. You're free to choose your tools. **Contact:** [Online form](https://jobs.smartrecruiters.com/Broadsign2/743999689242583-software-developer). Feel free to PM me if you have any questions.
This library is not a carbon copy of the Elm (MVU) architecture, rather it's heavily inspired by it. One of these differences is that the view function is intentionally left out, since elm also renders html which isn't needed in a typical C++ application. There might be some value in adding an optional view function though, that can render whatever it is that needs rendering.
Exactly. It is a bug in the standard because it doesn't reflect the intent - the intent was to be able to read all the bytes of an object. So the wording needs to be fixed. It just seems the focus of the discussion is slightly off. The intent is for reinterpret_cast to work. There is no question about how you would write your own memcpy. The only question is how to fix the wording. It is all inter-related (you need to show the problem with current wording), but I think the focus needs a 5 degree shift to the left.
This is compilation with rustc vs 2 C++ compilers.
&gt; curly quote characters This type of thing needs to die
Here are some additional position openings. Graphics focused position (Great if you have a background in gaming) - [https://www.esri.com/en-us/about/careers/job-detail?req=7782&amp;title=Visualization%20Product%20Engineer](https://www.esri.com/en-us/about/careers/job-detail?req=7782&amp;title=Visualization%20Product%20Engineer) Desktop based role, focused on GIS Software platform development - [https://www.esri.com/en-us/about/careers/job-detail?req=9915&amp;title=Desktop%20Architecture%20Product%20Engineer](https://www.esri.com/en-us/about/careers/job-detail?req=9915&amp;title=Desktop%20Architecture%20Product%20Engineer)
I also work in safety (life) critical systems and I fail to see any relevance between formal credentials and ensuring product safety and/or quality and/or dealing with fallout from a defect. I've worked with folks that have tons of credentials and I wouldn't want one line of their code anywhere near me. In fact, I've had to delete much of it and re-write it myself on more than one occasion. Similarly I've worked with folks that are self taught in C/C++ and have years of experience and I'd trust my life to their code. Boeing is in hot water for exactly the same variety of failing which you describe in your company: A cultural failing. With your company the failing seems to be assuming a strict causal relationship between credentials and ability. As opposed to a correlation. &amp;#x200B; With Boeing the failing was putting profit and market forces above solid engineering sense and QA practices. Interestingly, this kind of management stupidity (at Boeing) is very similar to what got the challenger crew killed at NASA in the 1980's.
No, this is implemented in our own branch only. Not sure it's that easy to upstream, so no such plans for now.
Depends on where you live. Over here, you can easily get "good enough" paying job, that will pay the bills. It won't buy you a house or a new car or support a family on a single income, but you'll definitely won't live in "poverty". And there will be plenty of opportunities to grow and improve latter on. Of course, this is all true for the large metropolitan area, which has lots of advantages, however, you can work in IT basically anywhere with a decent access to the internet.
&gt; Not having a degree is going to close A LOT of doors for you in fields where C++ is relevant Which fields? Games and graphics (for instance) are absolutely no problem without a degree. Embedded and finance could be more difficult, I guess, but not impossible. A company that automatically filters by degree seems really terrible tbh.
Did he really generalize though? He was just pointing out his experiences, basically proving those wrong who claim that having a degree is mandatory for finding a good job.
I agree. We also don't look at degree very often. We've had terrible programmers/engineers with a master degree, and we had terrible ones without.
Yeah so basically programmers with a degree never write bugs, right?
&gt; Which fields? Aviation &gt; A company that automatically filters by degree seems really terrible tbh. For entry level positions? Not really. Being a strong developer isn't just how good at writing code you are, it also requires working well with others and being able to follow directions from authority figures. A college degree doesn't guarantee any of those qualities, but it's more than you get with someone who is self-taught. Either way, what people don't seem to appreciate is just how many people apply for software development positions with no formal education and are actually just not at all suited for the job. Finding those sleeper developers is literally a needle in a haystack with how many resumes my managers sift through. It is far simpler to just grab the candidate who at least has formal qualifications even if maybe there is some hidden gem buried under the giant stack of garbage.
Yeah my first thought with something like this is for GUI libraries.
Depends what you mean by "mandatory". I don't think anyone is reasonably saying that you need one in 100% of cases.
I had reasonable success teaching myself C++, writing some private projects (like game engines) and landing my first job in the graphics industry. A lot of people will tell you that it's impossible and, man, I had to argue a lot. But it eventually worked out. My salary is good, my tasks are fun. Of course this is "anecdotal", so take everything with a grain of salt. Your experience could be worse, but they could also be better. Who knows. Be self-confident, ready to prove your skills, show interest and dedication and you'd be surprised how many companies will be interested in your expertise. The fact is that good C++ programmers are rare and companies are desperate for them. Rejecting candidates base on their degree is a luxury
Well, many people in here were implying that you cannot get a "good" (as in well-paid, exciting and good chances for promotion ) job without a degree.
&gt; I also work in safety (life) critical systems and I fail to see any relevance between formal credentials and ensuring product safety and/or quality and/or dealing with fallout from a defect. Boeing was literally all over the news because they used outsourced developers. I'm not the one you have to convince, its the jury at a trial for negligence that you have to be worried about. &gt;Similarly I've worked with folks that are self taught in C/C++ and have years of experience and I'd trust my life to their code. I've had these experiences too. I've also had developers with college degrees that blew my mind with their quality and productivity. Conversely, I've had a 'senior' developer with no formal education ask me what 'static' in C# meant. We can sit here pulling anecdotes out of a hat all day, it won't actually mean anything. The person who made this thread is neither experienced nor has a degree. To a hiring manager for an entry-level position, they will easily get overlooked for people with work experience or a degree. You may not like it, but that's reality. &gt;With your company the failing seems to be assuming a strict causal relationship between credentials and ability. That is one hell of an assumption. For one, this discussion is in the context of an entry level job, not an experienced position, and for another, you're implying we just see the college degree and immediately hire them without vetting their actual ability.
no
But I doubt they meant that it was impossible. Just my interpretation at least.
\&gt; Not having a degree is going to close A LOT of doors for you in fields where C++ is relevant &amp;#x200B; I can not stress enough how incorrect this is. Sure, there are a few shady companies that gate on degrees, but not a significant amount. Maybe %10? &amp;#x200B; \&gt; You would need a substantial amount of professional experience to offset having no degree &amp;#x200B; The full-time C++ job I got based on a side-project (and 6 months non-C++ job experience) would indicate otherwise. So would the offer I got from Google after a recruiter randomly reached out to me. So would my roommate's full time job at Facebook from no significant experience. It's not just big companies obviously, I know a bunch of people making good money at startups without degrees, but that doesn't sound as impressive. &amp;#x200B; In software engineering, the only thing that really matters is competency. Granted gaining enough competency to get offers is not easy, but I'm not sure it's any easier in college than out. A lot of graduates lack basic industry skills (git, build systems, etc) and proficiency with modern concepts (If you're going to graduate after 2020, I would imagine that your college ought to be teaching C++20, unfortunately it seems that pre-C++11 is not uncommon). &amp;#x200B; My advice is to go to college if it sounds like fun, but don't expect it give you the skills you need to do a job, and \*definitely\* don't expect it to help you getting a job.
Pretty much the Same experience on my end. We really struggle to find *good* engineers and really don't have the luxury to filter by degree.
&gt; and definitely don't expect it to help you in the job search. If you didn't go to college for it, how can you even begin to make that assertion? Every CS major in my graduating class with half a brain got multiple offers, in part from all the networking that a university provides.
&gt; A college degree is still more than 1: Sure, a degree is a test of character, but so is learning something hard on you're own. If you manage to get to a professional level of proficiency in C++ *without* going to college, does that not show more determination and initiative? 2/3: You're arguing why someone might want to venture into the more advanced areas of C++ development. I don't disagree that these topics are rewarding, but I do disagree with the implication that the only way to learn them is by getting a college degree. Read blogs. Build hard projects. Watch conference talks on YouTube. Question how things work and then do the research to find out. In four years, surpassing grad level skills is not hard.
https://en.cppreference.com/w/cpp/concepts
Then why doesn't Google or Facebook filter out candidates without degrees?
&gt; how can you even begin to make that assertion? Because I know people with CS degrees, I know people without CS degrees, and I know people who hire engineers. Based on all my experience, getting a job usually just comes down to if you can program. Networking is valuable, but not essential if you know what you're doing.
That still does not explain how you can assert that going to college won't, and I quote, &gt; expect it to help you in the job search. I too know CS majors, non-CS majors, and hiring managers, and they will prefer a degree'd entry level candidate every time, see I can pull out anecdotes as an appeal to authority too! At any rate, my original post wasn't exactly me posting my opinion, it is a literal fact that some companies expect a degree for entry level positions (including some Fortune 100s, one of which I work at). My company alone hires hundreds if not thousands of software engineers, so if you want to nit pick the definition of 'a lot' per my original post go for it, but it certainly doesn't qualify as a 'shady company'.
When a lambda decays to a function pointer, there's nothing virtual about that, either. auto lambda = [](int x) { return x+1; }; int (*fptr)(int) = +lambda; assert(fptr(2) == 3); No virtuals here!
**Company:** [Stellar Science](https://stellarscience.com/) **Type:** Full time and internships **Description:** We're a small scientific software development company that develops custom scientific and engineering analysis applications in domains including: computer vision and image processing, space situational awareness (monitoring the locations, health and status of on-orbit satellites), image simulation, high power microwave systems modeling and simulation, computational electromagnetics (CEM), laser systems modeling, high performance computing (HPC), computer aided design (CAD), and more. All exciting applications and no CRUD. We emphasize high quality code and lightweight processes that free software engineers to be productive. *Experience*: We consider anyone from interns to recent college graduates to experienced software engineers and scientists. We generally look for a B.S. in computer science, physics, engineering, math, or a related field. Many folks have Master's degrees and almost 1/3 have PhDs, but that's not required. **Location:** Albuquerque, NM and Tysons, VA (Washington DC, on metro.) **Remote:** Generally not. However, we're currently hiring *near* current remote employees in Seattle, WA, Raleigh-Durham, NC, and a few other locations where we may open small satellite offices soon. **Visa Sponsorship:** No (U.S. citizenship required) **Technologies:** C++17 (moving to include much of C++20 soon), Boost, Qt, CMake, Jenkins, git, OpenGL, CUDA, OpenSceneGraph. Windows and Linux. Any productive IDE. **Contact:** [Apply online](https://www.stellarscience.com/careers_jazz.html) or contact me directly with questions/inquiries via PM or gravitational waves.
&gt; FAANG has a lot of high-end C++ software engineers without CS degrees or any degree No degree? Really?
Honestly, when I get 200 lines of error messages, I just scroll to the top and paste the first error message into my browser search, then click the first stackoverflow. Bam, instant explanation.
Vim can use Language Server plugins and clangd to provide completion and error highlighting. It also protects against semicolon look-alikes by ensuring you colleagues will be unable to use your editor, or even exit it!
There's literally a comment in this thread saying: &gt; For software engineers you need to go to school, full stop. And plenty of others like it. That's why I wrote my reply.
You think there is any connection between a CS degree and safer critical software? Your process should protect you, not a piece of paper.
You very clearly didn't even read the comment you are replying to, because nowhere do I say that.
Or maybe you just aren't as skilled as you think you are.
That is just not true at all if you can prove yourself.
Clearly what they meant was that you "need to go to school" because things will be much more difficult for you if you don't. I really don't think they meant that software engineers who didn't get a degree don't exist anywhere (I mean we've all heard of Bill Gates haven't we?). I think you have to use your common sense here.