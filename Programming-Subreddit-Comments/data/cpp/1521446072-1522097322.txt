&gt; So the prior lambda should be compiled down to just a function pointer to the function in std I've found no compiler that does that and I'm not even sure it is legal. Taking the address from two distinct entities should return two different addresses. I'm not saying that the overhead is significant though (didn't do any measurements, just looked at assembly and also didn't test with lto).
Languages which allow existing code to smoothly transition forward are desirable to many.
This thread is full of people who can't see anything other than how it affects their own project.
In many cases you do know - for example, when communicating with an external system, an I/O error could occur. Some errors aren't really recoverable and really mean buggy code, for example array indices out of bounds. You can catch those in Rust using a general `catch_unwind` handler (to avoid crashing an application).
Thanks!
I'm proposing that more software vendors to accept that code needs to be adapted over time. Be it to new language standards, new platforms, new compilers, to changes in 3rd party API's new threat models, build systems ... Hence they need to adapt techniques, tools and guidelines that allow them to refactor their code with confidence. IIRC there was a paper saying that breaking changes should be accepted, if the necessary changes can be identified by a compiler in the previous language standard and there exists a valid workaround in that standard. Under those circumstances, yes I'd be gladly willing to deal with language level breakages if that means I have to deal with less corner cases and complexity in the future. However, as I said before, I can think of only very few instances, where I'd like to break language level compatibility in the first place, so this is more of a theoretical discussion. Where I would like to see some breaking changes is a) simplification of initialization (how many different kinds are there now?) b) gramma problems around the most vex parsing and c) the handling of native arrays and strings . There are more examples in the standard library, but imho those don't necessarily need breaking changes, but could be resolved by adding new types (aka std2)
You do not understand what I mean are arguing past me. [`write`](https://linux.die.net/man/2/write) has no idea whether its failure is recoverable or not *for me*, its caller. It has to report the error of course, but it can't say anything about what I can/should do with it.
This is AMD's ROCm - CUDA generfication tool to allow for using other hardware 
Where did I say I'm against that? Unless I'm misunderstanding you, smooth transition still implies (gradual) change. That's what I'm advocating. But there is a difference between allowing a transition and making changes under the constraint that they must not break decade old code written in a different language. Btw.: Where I think the pursue of a smooth (aka zero effort) transition path will be actively harmful for the future of c++ is with modules, but that's a different problem, as it's not about breaking existing code.
Exactly.
This is where a technique known as ["COMDAT folding" comes in](https://stackoverflow.com/questions/15168924/gcc-clang-merging-functions-with-identical-instructions-comdat-folding). That eliminates duplicates.
Yes: static constexpr auto f = +[](int i) { return std::to_string(i); }; static constexpr auto g = +[](int i) { return std::to_string(i); }; static_assert(f != g); So at least one of f and g must be a thunk - a jmp to the std function. 
 while (a&gt;0) { [[unlikely]] g(); }` or while (a&gt;0) [[unlikely]] { g(); } Is this allowed and would their be any difference?
MSVC does aggressive comdat folding. It may be legal, the standard is ambiguous.
&gt; If code errors recoverably [...] If it errors irrecoverably How can the low-level routine know which is which? For example, in my current project I have a utility routine that reads a certain type of data file to return a dictionary. In some cases, if the file doesn't exist I cannot continue. In other cases, if the file doesn't exist, I just return an empty dictionary. 
`std::toupper` is not allowed, but there is nothing prohibiting you to take address of `toupper`, the C version.
&gt; sanitizers are at runtime, C++ sanitizers can very often be at compile time.
I have only checked the version available at compiler explorer (some version of 2017) and there it definitely does not generate the same address. Neither do g++7.3 or clang 6.0. Did you have a look at the generated assembly?
Will it work with scoped enums safely? Both g++ and clang++ ignore the underlying type specifier. enum class MyEnum : unsigned int { A, B }; format("%u", MyEnum::A); // ok format("%d", MyEnum::B); // not ok
I feel like that is just comparing a new language with few users to an established language with many orders of magnitude more users. (Replace users with LOC for a second or alternative statement)
Failure in `write` is potentially recoverable, so it makes sense to to allow handling it. This is mostly a distinction between errors that are likely to happen (any kind of IO error is like that), and "shouldn't happen" failures like accessing an array out of bounds or out of memory scenarios. If you want to convert an error into "shouldn't happen" error, there is a method called `unwrap` in Rust.
Are there any plans to allow formal parameters to lambda expressions to be structured bindings? This would be useful IMO.
Forgive me, maybe the tone of comment was not clear - I wasn't complaining, I was just surprised counting C++26 - C++11 = 15 years. I know the current direction is newer, but I also remember that there were earlier initiatives in 2011. So even though there was at least one reset in this feature, I would have very much preferred if there was something ready earlier. I understand though that resources are limited and there is no one set of priorities that everyone would be happy with. I feel there should be more focus on the things that need language support, as opposed to library enhancements. The reason being is that more often than not, there are libraries available already to do the work and very often those very libraries are what's standardized with slight changes. Which is great. But in the meantime, I can't use reflection without substantial effort (as opposed to using ranges or asio today, which I can do fairly easily). But this is just my perspective and I understand that others have different priorities. I'm grateful for all the work you guys do - I remember the pre-C++11 times, and the velocity today is so much better.
&gt; it's quite clear that you forget to include something otherwise this notification would not appear, Not true, because there could have been a `#undef INT_MAX` directive after the header was included. It's _likely_ that including the header was forgotten, but without performing extra work to check, it's not definitely the case. &gt; so it's like mocking you. srsly?!
Initialization was my #1 complaint (uniform init and the initializer vs non-initializer list) in the survey they launched.
It would be wrong to suggest `&lt;cstring&gt;` for `strlen`, because that header is only guaranteed to define `std::strlen` not `strlen`. (Yes I know you could have `using namespace std;` to allow calling it unqualified, but some people will tell you that's bad and should not be used. Yes, I also know you could have used `using std::strlen;` but in that case you'd already have got an error at the location of the using-declaration, so that's where `#include &lt;cstring&gt;` should be suggested, rather than when using `strlen` later).
Well... it does have guidelines. Systems level, nothing in-between C++ and assembly, user-defined types should be like primitive types and more. It is indeed well documented and there r papers about it. What is difficult is to stick everyone to the same goal.
Well... it does have guidelines. Systems level, nothing in-between C++ and assembly, user-defined types should be like primitive types and more. It is indeed well documented and there r papers about it. What is difficult is to stick everyone to the same goal.
No. It is well documented what C++ should be: general PL with a bias towards system programming, zero-cost abstractions, u dnt pay for what u dnt use and much more that is well documented even in some papers. A different thing is that all ppl stick to the goal. The commitee is very big.
No. It is well documented what C++ should be: general PL with a bias towards system programming, zero-cost abstractions, u dnt pay for what u dnt use and much more that is well documented even in some papers. A different thing is that all ppl stick to the goal. The commitee is very big.
No. It is well documented what C++ should be: general PL with a bias towards system programming, zero-cost abstractions, u dnt pay for what u dnt use and much more that is well documented even in some papers. A different thing is that all ppl stick to the goal. The commitee is very big.
See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84904 for dmalcolm's more recent ideas.
People often forget the headers for standard library features, because they just get used to things from the standard always being available, and not everybody can remember which header everything comes from (e.g. `#include &lt;algorithm&gt;` then wonder why `std::accumulate` isn't defined). It's limited, sure, but that doesn't mean it's not useful.
&gt; I know of zero languages that introduced C++ FFI in order to use Qt. [Then you've not even looked.](https://en.wikipedia.org/wiki/List_of_language_bindings_for_Qt_5) Python. 
The point about "recoverability" stands - the callee does not know if its failure is recoverable or not; it's all about the context of the caller, he knows. I do not see why we're mixing an assertion failure here. That's a program bug, only solved by changing the code, any error handling is out. OOM, however, is **again** about the context of the caller, not the callee. The callee has no idea whether the caller continue or not. Example scenario: I am a server of some fashion. A very big chunk of input data comes in on one of my input channels. Intake of that data runs out of memory. Should the process be killed (`panic!` in Rust terms)? And drop any other requests in progress? I don't think so. It's best to stop that request (and report the failure on it). That frees a lot of memory that this request needed and life is fine.
People who make arguments like this don't understand the point of exceptions. The point of exceptions is entirely that they evade the type system. That's the only reason why you can add a statement throwing an exception to existing code and not have to refactor every single function between the point the error is detected and the point the error is caught. If there's 10 call stack layers between these two points, this is annoying. If some functions in that call stack already return a sum type encoding a different error state from somewhere else, then now you have to decide how to combine error states and now things are really annoying. It's not handed down from above that the more statically typed something is, the better. Static types have benefits, and sometimes detriments. Changing the signature of a dozen functions to add a rare serious error whose handling code is already present in the codebase buys you little in terms of verifying correctness. It's just boilerplate.
This is not a problem. A `constexpr` function may be evaluated at compile time, but does not have to. Simply optimize for cases where it's possible.
Has made some big innovations in terms of the borrow checker, and move semantics. However, is really disappointing on the compile time computation side. Lack of non type template parameters and variadics make arrays and tuples feel second class. No constexpr. The biggest mistake Rust has made is its macros. Because effectively it's acted as a crappy band-aid to these very real problems in its type system. There's no sane reason that something like printf should be a macro (one that's too complicated to actually write; the core is implemented inside the compiler). But when you can't do variadics or compile time strings, you can't do printf another way, so you use macros as a (poor) crutch. What's sad is that Rust's compile time computation and these particular aspects of its type system are such a huge step backwards. Even from C++, but even more so from D. It's a real shame to see a new language fail to leverage existing knowledge/experience of languages/developers already working in its target.
That's what the new compiler errors are for. Compilers shouldn't be interacting with your files or how you write them. 
&gt; That said, your comments are personal attacks on the committee members and I think you are way out of line. The committee consists of some of the most talented individuals I have had the pleasure to work with. My colleagues and I pour a substantial amount of time into making this language great, and we do it because we are all passionate about our users. &gt; &gt; 1. C++30 is saying that network is still likely to be delayed by the C + + standards Committee. 2. C++17 may be a wonderful version for you, but not for me. C++17 No Networking, No Modules, No Concepts and Ranges, No Coroutines. Now tell us that c++20 may still not have these features or standard libraries. 3. std::filesystem no publish release version support it. GCC 8.0 not released (and need -lstdc++fs)!!! libcxx trunk no &lt;filesystem&gt; (only &lt;experimental/filesystem&gt; see:https://github.com/llvm-mirror/libcxx/blob/master/include/experimental/filesystem), Microsoft STL(VisualCppDaily) has &lt;filesystem&gt;. Although xfilesystem_abi.h is being used to support std::filesystem, it is currently unavailable. 4. You think my opinion is to the members of the personal attack, I apologize, I just think they pay too much attention to grammar and not focus on the standard library and the implementation of tools. C + + syntax is very complex, but the standard library is disappointing, a variety of third-party libraries. 
A lot of proposals and conferences are uploaded to YouTube (see CppCon channel).
I would use a different name. To suggestive for random number generation
Holy shit unicode group. The unexpected, unbelevieable is happening. I'm positively surprised that pragmatic utilities like likely/unlikely attributes, calendar/timezone and formatting library were merged into the language standard. Not expected these to be included that fast. We definitely need more quality-of-life easy-to-use stuff that many other languages provide out-of-the-box. Is there any proposal for `std::clipboard`?
Then why isn't everyone still using C? Or Fortran? I think pre-C++11 that a great number of C++ users were siphoned off to other languages. Primarily to Java, Python and C# -- basically the high-level language devs that were making general purpose apps and guis. Now we're threatened with a new class of languages, largely enabled by LLVM, that can compete in performance. And they are going to siphon off systems-level developers. It's not a matter of black and white, its death by a thousand cuts. 
Then you misread what i was responding to. He claimed that those languages added C++ interop because they needed Qt specifically.
You also misread. ;-] He said Qt was _driving_ the need for C++ interop, i.e. people want it for that reason. No one ever said it was actually added.
Why does it matter, if that pointer cannot ever be ultimately dereferenced, because there are no data members in the object to access?
Two use cases I'm aware of: * Detecting whether a handler has already been attached to an event * Use as a type identifier where std::type_info is overweight or unavailable. I'm sure there are more. There's an interesting discussion of the technique at the Old New Thing article [Why does the debugger show me the wrong function?](https://blogs.msdn.microsoft.com/oldnewthing/20050322-00/?p=36113)
I guess that makes sense. If the compiler could prove that we never actually check the addresses, it could theoretically make them the same, but that's a lot of work, and not always possible / feasible
D has `dub` which is the official package manager and very similar to `cargo` in many respects.
I would say that's the same thing and I reject it as nonsense. 
I'm up for D--.
Are the modules stored as source, or are they stored in IL?
I imagine the compile times will be much lower (than with rangesv3) once ranges (and concepts) land in the language.
Why don't they have their meeting coupled with online, public discussions? Then you don't need to physically be there.
AFAIK the code runs in JVM nowadays. I even used the Java date classes straight from the m files, in one project.
I find it funny that the C Embedded Extensions spec has yet to be incorporated into C++. Makes using C++ on architectures like AVR difficult when you can't mark a pointer as being in a specific address space... something C++ benefits from more than C.
Hmm I wish I knew how to quote on mobile, cause I really wasn’t clear, sorry! I was talking about the part about waiting for 3 or 4 compilers... give rust 10 or 20 years and they won’t have the luxury of making big changes like they can today. That’s the advantage of starting fresh, you loose all that baggage (existing users). Your point that llvm has completely changed the game for new languages is interesting as well, I wonder if maybe that is a bigger risk for rust. They need to gain enough developer momentum before the honeymoon wears off.
Perhaps we need a generic forward declaration semantic? That just declares a type with no additional information as to what it is?
I'm responding to this so I can come back with some ideas when I'm not using a tiny on-screen keyboard.
If I didn't have another project going on, I would probably start on a D--. It would be C++, based on D's syntax, with memory-mapped modules, compile-time reflection (with C#-like attributes to help with serialisation), no (bad) syntax ambiguities, arbitrary CTFE (but not calling DLLs), inferred `noexcept`, some support to help with memory-mapped data structures (that I'll use to create memory-mapped modules), no nul-terminated strings, and possibly implicit and/or explicit template instantiation caching (which would mean that most templates would have to be instantiated in a "vacuum" without knowing where they were instantiated). And then, ideally, I'll rewrite that big project in it. There's also another interesting language [here](http://www.c-up.net/) that barely anybody knows about.
&gt; That’s the advantage of starting fresh, you loose all that baggage (existing users). Good point -- it used to be that you couldn't just start fresh, as it would take you years to get good enough performance to compete. Now you can get there in months via IR. &gt; Your point that llvm has completely changed the game for new languages is interesting as well, I wonder if maybe that is a bigger risk for rust. They need to gain enough developer momentum before the honeymoon wears off. Very true. Every language is going to to have to find the balance between stability and backwards compat. The argument is not for one or the other, it's for finding the right balance. I think the OP thinks the balance is too far to the conservative.
&gt; What we're finding is that not only is range-v3 usable, but indeed the harder the problem, the more indispensable range-v3 becomes, precisely because of a) the excellent suite of views, actions, and algorithms, and b) because you're encouraged into creating small, unit-like functions that are much easier to reason about. If you ever decide to write a blog post about this please share it here... I am honestly struggling to think of any real life situation when I needed something fancy from ranges.
AFAIK you can not use range v3 with MSVC since compiler still does not fully implement C++11. :)
No, it will continue to go down the same error path.
I presented a paper in LEWG suggesting that the algorithms be moved into a `::std2::` namespace. That proposal was rejected. I came back a few days later and described a new strategy involving `::std::ranges`. The direction was improved, and I am to come back to LEWG with a paper suggesting specific wording. Assuming LEWG likes that in Rapperswil, they will forward to LWG for detailed wording review. My hope is the wording review can be expedited since LWG has already seen most of the wording in the context of the Ranges TS.
Depends on _which_ terse syntax and with what semantics, but yes I share that hope.
TIL
Inferred `noexcept`... man I hate it right now. Implies a performance hit. Opposite of what you'd think. I'd keep strings null terminated, just don't rely on it internally. Makes passing strings to C libraries easier without requiring an allocation, or at least a copy. I dislike O(n) things.
Why not as IL like Java or C# can do? Right now only the LLVM toolchain can really do that, and it's not perfectly portable. Makes module loading faster, will ease concerns of proprietary-source module makers, and you don't require a front-end to load.
Technically if it's fast enough it wont show up on a sampling profiler =P
Does godbolt do linking? Because ICF (identical comdat folding) happens during linking as far as I know.
exceptions don't "evade the type system"... you fucking catch exceptions by declaring which types you want to respond to.
The compiler already optimises what it can. What would be changed by having `constexpr` function parameters?
&gt; This worried me at first. But what I realized was this: once you had the compact, clean, formulation, that you could just look at and you knew it worked, suddenly, you could start having new conversations. "What if I run this algorithm interleaved instead of per-channel?" This reminds me of similar statement that Walter Bright did with D. Some people are concerned about the GC. But actually, he said: now with D I can finish faster and spend more time refactoring (not only bc of GC but bc of other features as well), which gives me more time to optimize code and the result is usually faster.
Standardize the mangling for exported symbols/types, or allow multimangling lookup.
Using an IL allows for target-specific optimizations. This would be functionally equivalent to high-level LTCG. It also makes modules far more portable.
It's lovely that our language can do things like that that aren't semantically defined for that purpose.
Which is handled at runtime. Sure. It evades the "static" type system. Happy? Because when you change your non-throwing function to throw, your program will always still compile afterward. Even if the exception is not handled anywhere in the entire program. I think it's pretty clear what I meant.
addition is also handled at runtime, no one would claim addition avoids the type system. 
Are there any flags to *allow* it?
Yes, for a standardised portable module format. But I'm talking about something platform specific, designed for compilation performance, and probably stored along-side library and object files or in a project's cache directory.
On phone so keeping short, but zero-sized objects/types would be a useful extension for embedded.
I honestly can't tell if you're trolling at this point but I'll give you the benefit of the doubt. The values of addition are not handled at compile time, but the types of addition are type checked at compile time. You can't `+` a string and an integer. Similarly, if you have a function: int parseString(const std::string&amp;); And you call it: int x = parseString("5"); The compiler verifies that the argument and the assignee of the function call are all compatible. If you now decide that `parseString` can fail and you decide to change the signature to: optional&lt;int&gt; parseString(const std::string&amp;); The previous line won't compile. The presence and type of possible error you can specify is being checked by the type system. If you instead change `parseString` to potentially throw, then the original usage will continue to compile. The presence and type of errors is not statically checked with exceptions. At least, not with unchecked exceptions, which are the only kind that C++ has. Notice the word "unchecked"? Unchecked by what? By the static type system. Obviously evade is personification but this isn't exactly a huge leap.
That's for functions with identical instructions. Template instantiations might have drastically different code depending on the type they were instantiated with.
I don't think the compilers fully optimize formatting functions even if they see constant string. It's always better to force and make such behaviour explicit than rely on unsure optimizations
&gt; The values of addition are not handled at compile time, but the types of addition are type checked at compile time. plot twist... &gt; you fucking catch exceptions by declaring **which types** you want to respond to. What you're so badly trying to say is that the types of exceptions that can be thrown are not a part of the type declarations for the function/method. No shit, but the conclusion that exceptions "evade the type system" is a non-sequitur. And you try to defend this premise by pointing out that exceptions are handled at runtime (no shit...). &gt; The presence and type of errors is not statically checked with exceptions. At least, not with unchecked exceptions, which are the only kind that C++ has. Notice the word "unchecked"? Unchecked by what? By the static type system. Obviously evade is personification but this isn't exactly a huge leap. Do not speak with authority about things you do not understand. checked exceptions are not called checked exceptions because the type system checks them. They're called checked exceptions because you are **required to catch them**. You are not allowed to let them bubble up and continue unwinding the stack (which is the point of exceptions, btw... to unwind the stack). Java has checked exceptions, Java also **does not require the type of exceptions to be declared in the interfaces of your methods**. 
That was not really nice :)
Is the compiler allowed to optimize the lambda away, if the emitted code is basically just a jmp? Or does it have to have a unique address?
What desired behaviour would constexpr arguments made possible which is impossible now? Optimisation is not observable behaviour, you cannot say in the standard "implementation shall optimise this away". The maximum you can require is "this shall be a constant expression". 
Probably not. Feel free to play around with it on your local machine: https://godbolt.org/g/jghGsu
No Idea. I'm a bit out of my league here but I've learned to be very sceptical about claims along the lines of "every compiler can optimize this". Many people overestimated what the compiler can do / is allowed to do. Often, higher level languages can actually be optimized better by a compiler than c++ (at least in principle), because things like memory locations or object layouts are hidden from the programmer.
Have you actually checked this? My experiments indicate otherwise. A lambda usually only brings an advantage if it is passed as a template parameter not a pointer (which is what the current discussion is about)
I don't agree that's what the discussion is about; previously it was legal to pass `&amp;std::func`. There was no indication of what it was being passed *to*. Even if you are passing it as a template parameter, that is still the most concise thing to do if that function does exactly what you want. I said it it will result in the "same or less indirection". If you pass by function pointer, it will result in the same I think. Are you saying that if passed by function pointer, it will result in worse indirection? I guess that is possible. That's not the sort of thing you should check by experiment though; you can just check directly in the assembly. 
And that's another point for "everything that's wrong with c++". Instead of giving the user a simple, clear function or language mechanism to explicitly do what we want (decay to pointer) c++ users learn to hack his way around such deficiencies by relying on maybe logical,but rather unintuitive interactions of language feature X and Y.
"Unspecified (possibly ill-formed)" is pretty darn close to UB. "Your code may not compile, and if it does it can behave nondeterministically." &gt; the standard library is already allowed to do things like add default arguments Nope, it isn't. [global.functions]/p3: &gt; An implementation shall not declare a non-member function signature with additional default arguments.
Can't you use a cast as well?
The actual wording is: &gt; Let `F` denote a standard library function ([global.functions]), a standard library static member function, or an instantiation of a standard library function template. Unless `F` is designated an _addressable function_, the behavior of a C++ program is unspecified (possibly ill-formed) if it explicitly or implicitly attempts to form a pointer to `F`. That covers every function in the standard library regardless of namespace. (The only "addressable functions" are the stateless iostreams manipulators.)
&gt; You probably just shouldn't talk about type systems at all. Pretty much every discussion about ADTs vs exceptions begins with the fact that ADTs encode possible failures into the type system, and unchecked exceptions don't. This is moving the goalpost, we are not talking about abstract data types, and I flat will not acknowledge this line of thought. Either you're able to stay on topic or there's not conversation for us to have, it's that simple. What you're trying to claim is that if a mechanism has a runtime counterpart then it's not a part of the type system. If you are to remain consistent, then addition also evades the type system because it's dispatched at runtime. According to your logic **anything** that's dispatched at runtime is "evading the type system", but your counterargument to that is that the compiler sets up the runtime dispatch and so it's not really evading the type system. Only the compiler also sets up the dispatch for the exception handling routine. Your problem is that you made an indefensible statement and rather than admit or clarify you've dug yourself deeper to the point that you've decided to get pompous and change the subject to something you imagine I don't understand. And the worst part is that when you wipe all the shit away what you're really trying to say is that C++'s type system isn't as strict as something like Rust or Haskell. Well no shit, but that doesn't mean you can get away with saying something as asinine as exceptions are evading the type system. casts evade the type system. polymorphism **weakens** the type system. exceptions do neither.
If you know (and want to type) the correct type sure.
&gt; All hotkeys were Mouse button combinations oh good lord that sounds horrible.
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Not yet that I know of, IIRC. If such a proposal existed, it'd probably depend on the standardization of an event-queuing and -dispatching system and other primitives for event-driven programming due to how GUI-related utilities are typically implemented in various OSes and fall under the purview of SG7 (currently limited to being for 'Compile-time programming,' but I've heard whisperings of it expanding to cover exporting compiler-generated data for dynamic use at run-time,) SG13 (HMI, for 'Human/Machine Interface,') and/or SG14 ('Game Development &amp; Low Latency,' as I've heard a non-trivial subset of the games that exist out there use event systems internally.) There might be a bunch of other entities that might have to be vetted first, too. In any case, anyone, as expressed a couple times in this thread already, is free to [write and submit a proposal](https://isocpp.org/std/submit-a-proposal). 
Why would a thing like `std::clipboard` be needing GUI support? AFAIK OSes have globally-accessible clipboard, into which you just save array of bytes and setup something like enum to inform other programs what's the type of saved thing.
I agree that C++ is moving slowly and it is really disappointing to see that a lot of features promised to be in C++20 will probably be pushed back again. This is one of the drawbacks of design by committee. On the other hand let's compare how e.g. C++ and D have evolved since 2010. C++ had a big improvement in 2011 and minor improvements and bug fixes in 2014 and 2017. Many C++ devs who remember the old days will agree that it is much more enjoyable to write C++ today than it was before 2010. How did D evolve? I remember that around the time Andrei Alexandrescu joined the development team of D (2007-2010) there was some kind of Hype about the D programming language and many D and C++ devs thought that D would have a bright future. But somehow the Hype faded out (mostly due to the lack of companies supporting D) and it is now not even clear whether D is actually improving or deteriorating. So yes, the slow pace of C++ is disappointing and important features being pushed back again and again sucks. But not everything is bad, C++ is slowly but steady improving. C++ sails while D is ... 
I tested it on my local machine and as far as I can decipher from the assembler code, even with full optimization, LTCG and /OPT:ICF it will msvc will not create identical code / replace the lambda's address with the address of the function it wraps.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/85nc60/new_to_c_any_tips/dvypupm/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Try to use 'new' as little as humanly possible or not at all.
If you want a function pointer from a lambda, all you have to do is store the lambda into a function pointer. That's about as clear and direct as it gets, it just happens to be verbose.
&gt; Couldn't this at least be open to "registered" persons? What do you mean with "registered"? Everyone who is at the meeting is free to walk in the room and vote when the proposal is being discussed. I've also seen people being called from other rooms for particular proposals as they were interested into discussing and voting on them.
The article never answers the first question, so this seems like clickbait. The second is barely touched on, either. The advice not to use new features purely for their newness or novelty is perfectly reasonable but isn't one taught by an ancient codebase which takes the decision not to use fundamental advantages of C++ like references. Why this "subset" was chosen isn't explained, but I don't think it's because it makes the code nicer. 
https://i.imgur.com/nnwVNui.png
The internals usually don't leak out Java errors so it's not as obvious.
\&gt;modules might be delayed to 2023 \&gt;why live
Imho pretty much the main/only purpose of the regular posts made by cppnext is to promote CppDepend.
Congrats. It's good to see `function_ref` progressing well. I'm really really hoping that if non-allocating-in-some-cases coroutines make progress, we can extend that to `constexpr`, allowing an elegant coroutine-based implementation of ranges that works at compile time without fancy bells and whistles like figuring out the stack frame allocation.
Such an exciting programme - I envy those who go there and look forward to the videos. The idea of having 45 min and 90 min presentations is good. Last year I felt that the one hour limit was a little bit to short for some presenters.
The paper and wording specifically call out namespace std and namespaces within std. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0551r2.pdf You could still get in trouble if you take addresses of functions that belong to someone else (like C). You would need to refer to their compatibility expectations to see if that is safe.
I think in general there's just no good reason to require a 2-3 times per year meeting just to vote on proposals. It's an incredibly ceremonious and unproductive fashion to review changes, especially the minor ones. The "RFC" process that so many other languages have adopted is out and out superior. C++ being an ISO standard requires the formality for approving final drafts but that's it. The big meetings could be reserved for electing maintainers of the draft, ratifying yearly releases, and a (more production) hackathon and coworking situation. Changes like both of yours could be put up in an RFC, reviewed, amended, worded, approved, and merged in the time span between meetings. Would be a decent way to formalize the co-development of a standard test suite (with a mandatory revision that all changes come with tests, and that vendors sign off that they can get the tests working in branches of implementations before final approval), too.
Ugh, sorry to hear you were so unwell, Guy! Always unfortunate to have that stuff hit right in the middle of a trip. :/
I do not understand the rationale for this. If you wish to add additional template parameters to a std template, I would prefer having the public template specified via a using declaration.
Might be worth exploring: I've added an item to https://github.com/fmtlib/fmt/issues/518. Thanks for the feedback!
Scoped enums are not implicitly convertible to underlying types, so as with iostreams, you need to either cast them or provide formatters (formatters for the underlying types can be reused).
It will allow reporting errors in format strings at compile time which is kind of possible now but with ugly API.
Precompiled headers are not standard, but that doesn't prevent people from using them. The benefits can outweigh the drawbacks.
4 year old project. Started with c++11, now on 14. Will switch to 17 as soon as I can get comfortable with the "backported" clang. (embedded device; updating the OS is scary and customers hate when things go wrong, even if it's easily recoverable)
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/85pmtc/im_learning_more_online_than_in_school_what_are/dvz6uq1/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
As a Mathy high performance c++ programmer, I wonder if a high performance standardised linear algebra library is desired or not. Quite a few high performance Expression Template Linear Algebra comes and go and only Eigen is left to survive and getting some love from Google. Here are some open concern I have about Linear Algebra to be in standard library while not having to read any of the std literature regarding linear algebra: 1. The amount of template trickery (or abstraction) in Eigen or any other ET LA to archive high performance is only comprehensible by a handful of the core developer. Should this level of template meta programming to exist in std? Should std have this much hidden complexity? Without expression template, performance is not going to come close to state of the art. 2. I feel that std tries to be portable more so than absolute performance in API design and specification. std::exp and std::log are good examples. Can we truly have portable performance in different platform? At least Eigen guys are testing on multiple platforms because they are indepentent. If it is standardised, are all std writer incentivised to write most optimal library on all hardware? Lastly portability often means compromise in performance. 3. Linear Algebra is deep, and numerical linear algebra is even more so. New algorithms are appearing over the decades. The closest things to standardise is Matrix/Array/Tensor ABI, BLAS API and LAPACK API in my mind. Do we know where is the cut off for standardisation? 4. Unlike discrete algorithm, FLOP algorithm has problems with tolerance, and different algorithms exhitibits very different numerical characteristic. This is a real problem that one can already face in level 3 BLAS routines. While there are quite a few maths PhD in the existing standard committee, do we really have all the expertise to completely specify and implement even the basic level 3 BLAS routines in high performance way? How do one even start to specify the require tolerance anyway. I really think that in linear algebra world, you can either be the fastest on a given architecture, offer the wildest classes of algorithm, or you have no user. Even you solve the FLOP problem, what about linear algebra in integral domain or a number field? Are we good enough to specific the semantics without anger all number theorist? 5. These days high performance maths are often off load to GPGPU. Are the API going embrace the existing of GPGPU so it doesn’t suck when we have to write application to work with CUDA and such? 6. The (D)NN application are driving much of the new high peroformance array library development, is the std going to move fast enough to support what the industries desire? It tooks decades to get to string_view so that performance doesn’t have to suck in certain use case, and this caused many companies to roll their own string library. The library must be design to be extensible enough to survive until next round of new API, otherwise people will just fall back to Eigen or alike.
Sorry, but 2D still doesn't belong in the standard.
I love the shorter name. Perhaps we can get a templated view&lt;&gt; of which string_view is a specialization...
I have to agree, modules have the power to make so many peoples lives so much easier, but the proposal seems caught between corporate masters...
This behavior is not acceptable.
Your client is apparently capable of double-posting comments; please try to avoid that.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8553pq/no_clue_where_to_post_this_but_im_getting_an/dvzcqja/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Additionally, please note that when asking for help, you should submit code in the form of full source code as text; screenshots are much less helpful and partly obscured screenshots are useless.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/85q52p/c_debugging_questions_resources/dvzcu8j/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Having `using view&lt;T, N&gt; = span&lt;T const, N&gt;` is a cool idea. Keep in mind that `string_view` has all the string member functions, and `span&lt;T, N&gt;` does not.
I've heard D (at least DMD compiler, not sure about the LLVM backed one), has very fast compilation, similar to Go.
Imho we don't need a high performance linear algebra library in the standard. We just need a simple to use linear algebra library (or more importantly, but connected a geometry library).
I think the `ConvertibleTo` examples for Herb's paper need to be spelled: void foo(ConvertibleTo{}&lt;T&gt; x); // x must be convertible to T void foo(ConvertibleTo{U}&lt;T&gt; x); // x must be convertible to T, x's type is U Assuming `ConvertibleTo&lt;From, To&gt;`. In TS syntax, it's: void foo(ConvertibleTo&lt;T&gt; x); template &lt;ConvertibleTo&lt;T&gt; U&gt; void foo(U x);
Actual production example: https://bugzilla.mozilla.org/show_bug.cgi?id=151066 Firefox's JavaScript engine was depending on being able to compare function pointers to test for specific functions. Folding broke it by making two functions test equal. Mind you, two functions don't have to be identical to be folded -- they only have to generate the same _machine code_. It is possible, and actually common, for two functions to be folded together that have wildly different semantics just because they happen to return a member variable of the same size and offset. 
Why would "being interested" matter in the slightest ? Only technical and quantifiable qualities should matter.
Exactly. function_view would be more consistent with string_view.
Interested people are generally also informed people. You can't give the same weight to someone who thinks 'that sounds nice' as to someone who has actually studied the proposal and heard the discussion.
We've come to define view as a non-owning _range_. `string_view` is a view, `span` is a view. But `function_ref` has nothing to do with ranges at all... `*_ref` is a better name than `*_view` for that reason. 
But why are you giving weight to *people* at all ? It's the papers which should be judged. There's a reason why scientific paper reviews are anonymous, both for the reviewers and the reviewees.
Java and C# also have AOT compilers, JIT is just one of deployment the options that most people seem to know about.
The reviewers actually read the paper though. If you allow voting without being present, you'll be inundated with people who just see 2D graphics and automatically vote yes or no without considering the merits of the specific proposal.
Excellent and very informative.
&gt; What? If you don't use a feature ever, you don't have to learn about it, because they're well designed enough to be avoidable. You absolutely only pay, in terms of learning, for what you use. Hell, if you really want, you can still write C++98 style in C++17 and not have to learn any new features. This only works if you write 100% of the code you use. The moment you need that cool library for PDF generation, that concept goes out of the window.
I agree.
Qt is the only library left for doing GUI development in C++, and even they are moving more and more features into their QML layer. All the major desktop and mobile OSes have moved away from C++ for their GUIs, even if the low level rendering code is implemented in C++, the APIs are exposed in other languages.
D would sail as well, if they had at least one OS vendor putting money into them. C++ progress is sponsored by Apple, Google, Microsoft, Bloomberg, ....., whereas D goes on with the help of volunteers.
Qt isn't moving to QML, QWidgets is just considered feature complete. But yes, there is a recognition everywhere that imperative languages aren't the best choice for actually *defining* your GUI. Designers have existed for this since the 90s though.
Well, it means that if you want to be able to attach and detach handlers to an event you can just keep them in a hash set, and rely on the user to not attach the same handler more than once. If "different" handler functions can have the same address then this breaks.
You mean in case the user attaches two functions that do the same thing but have a different name? I guess it could happen, but it seems pretty rare.
It also means you have a job that will let you take off for such a conference. In my experience, most of us don't.
With how much push back (eh) there is and how weak the proposal seem, I'm going to be really disappointed if it makes it to the standard.
Try to use QWidgets for writing mobile, IoT devices or mobile infotainment, Qt 3D Studio applications.
Faff then. Shame
My first revision proposed a default-constructible `function_view` with a possible empty state. The committee advised me to move in the direction of `function_ref`, and I have to say that it is a huge improvement over the previous version. Those semantics can always be re-obtained by wrapping it inside of an `std::optional`.
You missed one attribute for views: non modifying. This is btw the reason why span is not called array_view, because it is not a view. Your point for function_ref still stands.
As I mentioned in LEWG, I believe that some things are just "not standardizable". The scope is just too broad and a single design will never please anyone. What we need is a standard package manager / build system, so that anyone can distribute and consume the libraries they want. 
QWidgets is specifically for traditional desktop applications, and it's feature complete for this. Qt Quick is for the other areas, so you use it there.
You need to provide a pointer to the scanf destination arguments. Use "&amp;year" instead of "year".
Oh, that is unfortunate, I stand corrected. 
C++Now has always had this format. It's CppCon that does one hour long sessions, and a speaker can submit a two part session proposal if they wish to do so.
My bad. Thank you for the correction.
No. Views do not have to be non-modifying. Span **is** a view.
Good post and very good points! I believe that what they mean with "standardizing linear algebra" is just some vector_2d stuff and rotation matrices and stuff like that - things that are needed for 2D graphics. Nothing more. No arbitrary size vectors or matrices, no solvers, etc. I do not particularly agree with this approach and I would rather see multi-dimensional array-view in the standard and indeed something like Eigen, or at least the core of it plus the solvers, in the standard. But then again Eigen is header-only and easily installable so maybe that's not needed in std::. It would indeed be awesome to have a closer relation between linear algebra / solvers like Eigen, graphics (OpenGL) stuff (kind of like a hybrid from Eigen's Geometry module and `glm`), and GPGPU (via Executors or whatever?), and with that fast Neural Network operations like convolutions - and all that on "all" platforms (Desktop, iOS, Android). How awesome would that be. But I think the C++ standard could never move that fast, or it would need 25 new people for it, working 100% on it. Unrealistic. All they can provide is the core infrastructure, support in the language and std-library, that then enables library developers to create libraries for this. One thing I do not agree on: &gt; The amount of template trickery (or abstraction) in Eigen or any other ET LA to archive high performance is only comprehensible by a handful of the core developer. Should this level of template meta programming to exist in std? Should std have this much hidden complexity? std:: already contains tons of this. `std::variant` implementation is only comprehensible by a handful of wizards on this planet. There are many more examples like this.
I don't agree with this. Don't you think its more agile that the people (library writers) who are highly motivated in implementing the math-heavy algorithms can improve/add new features to their libraries without standardization process? 
I think it's a good idea though that these bunch of people meet 4x a year in the same building - physically. That's how you make good progress. Yes I agree, _in addition to that_, maybe it should also be a bit more online/RFC-focussed.
Maybe the author should read through this thread: https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/sg13/gUr98RZMU7M That's really good feedback what's wrong with the graphics proposal and what should better be done instead. But it's completely ignored "because it's an online post and not a formal paper".
&gt; In a world of Cocoa, Android, Flutter, UWP, PWA, how long will QWidgets matter if it is only for traditional desktop applications? As long as people want to write traditional desktop applications (long may that time last). Mobile / tablet GUIs only really work for consumption applications. Once you want to *create* something with your application, the traditional menu+toolbars (or perhaps ribbon) desktop UI is really the best way to go. Even with Qt Quick, you would still use C++ for the inner workings. QML is just for the front-end.
OP, that's not what "code unit" means, you're talking about code points. a code unit is the UTF types size, in UTF-8 it's 8 bits, in UTF-16 it's 16 bits. in UTF-8 you can have up to 4 code units per code point, in UTF-16 up to 2 code units per code point.
I think there is an argument to be made about getting infrequent error checking code out of the hot path of a program for performance reasons. This is something you cannot do with sum types, as you always have to check if the return is valid and then proceed. Ah, but if it's infrequent, then it will surely be predicted as valid by the processor's branch predictor, so we're quick anyways, right? Maybe so, but you're taking up an entry in the branch predictor which might have knock-on effects on the performance of real programs, but not on micro-benchmarks (since there is one other branch which had to be ejected and is therefore no longer predicted). Obviously I'm simplifying here but the point is you are consuming some kind of finite resource within the processor, even if that resource is not necessarily execution time. 
 A *a = new A; a-&gt;foo(); A *b = new(a) B; if (a == b) b-&gt;foo(); // This call could be devirtualized to A::foo() Is this not undefined behaviour anyway? It would surprise me if new'ing an object over an existing one and then using a pointer to the original wasn't undefined behaviour somewhere.
Hence why I also included Coca and UWP on that list, they are the traditional desktop application's future for Apple and Microsoft. Regarding Google who knows where they actually want to go with Flutter, Android and ChromeOS. Sure you can still use C++ in Qt Quick, but the point that Qt Widgets is done, all new Qt features are basically QML with C++ underneath, does not bound well for the future of C++ developers that would like to keep writing GUIs in pure C++. Specially given that Qt is the last worthwhile C++ GUI framework still standing.
This a thousand times
It already exists. Compile your D code with `-betterC` switch.
Yeah, lets leave that to new developers wanting to learn Java, .NET, Swift, Web instead. Aspiring C++ devs just get to learn about compiler and linker flags instead, if they want to see anything beyond text lines.
It is not assuming that: - sizeof(A) &gt;= sizeof(B) - you don't dereference pointer a after doing placement new (but you can still read the pointer value like here)
It's a recognition that writing GUIs in pure C++ isn't a good idea. It never *has* been a good idea, that's why we've always had designers, even for FLTK. &gt; Hence why I also included Coca and UWP on that list Apple's system language has always been Objective C, and .Net's flagship language has always been C# (though C++/CLR is an option).
Oh I didn't see it was Microsoft, sorry.
&gt; you'll be inundated with people who just see 2D graphics and automatically vote yes or no without considering the merits of the specific proposal. why would they be accepted as commitee members and have the right to vote if they behave like this ? 
I thought the idea I was arguing against is having the votes online so anyone can participate, without having to travel to a conference. Obviously, if you have an approval process for committee members, it doesn't really matter whether they have discussions online or in person, that's for them to decide.
&gt; I thought the idea I was arguing against is having the votes online so anyone can participate, without having to travel to a conference. indeed, it was a misunderstanding. Not anyone, but people involved enough in the whole process to participate to C++ developement, without having to resort to travelling abroad. But there would be certainly more competent people involved and proposing good ideas if it wasn't necessary to do that.
Even if you can't travel abroad, you can still join your national standards board, can't you.
&gt; you can still join your national standards board, can't you. ... uh... no. At least in my country it's reserved to companies.
Thanks for devoting your time to this. I'm glad smaller things are not overlooked.
Writing GUIs in pure C++ was perfectly fine in Turbo Vision, Object Windows Library and Visual Component Library. UWP is not .NET, is based on COM and although big parts of it are written in C++, even the Windows UI team does their demos on .NET Native. As former C++ dev I just would like to see a bit more of C++ love in GUI stacks.
In the UK it's free, and they let non UK residents join (https://www.cxxpanel.org.uk/).
Sure you can do this, but given a newcomer that wants to contribute to the advance of programming languages, do you think he'll try to register to whatever standard body, or just send pull requests to Rust ? 
I already get sound devirtualization by not using virtualization. I'm not sure this complexity of trying to take the wrong approach (from a performance perspective) and soften the performance degradation you get from it is warranted in the standard. 
Or they could download VS Community, create a C++ DirectX project and press F5.
Wow, what a low-quality article. I don't even know where to begin with it. It offers absolutely nothing, as far as I can tell, to anyone. Here are some points ostensibly made by the article: - Initial C++ code using the basic standard library is hard to explain to newbies - But you can abstract all of it away behind user-generated libraries - Why do other languages have so many libraries? On every project I've worked on, our team just reinvented the wheel without experts. - `std::cout` is low-level and no other languages have it (what??) 
Reading that hurt. Please proofread and edit before posting an article for others to view if you're the author.
I don't feel qualify to know if a high performance linear algebra can really support the standardization requirement: interfaces set in stone and very specified behaviors. But the subset used in video games such as vec2/vec4, mat2/mat4 (and quaternions?) looks very well widespread and would be a quite straightforward addition to stdlib.
The idea about epochs looks very good at first sight!!
Are you really suggesting newbies to learn COM, Win32, 3D Math just to draw a couple of `ctx.drawline(...)` calls?!!? No wonder newbies flock to other languages. 
I think this blog is written by someone who does not speak English. All their blogspam is riddled with grammatical errors and terrible flow. I don't have a problem with poor writers writing programming blogs. I have a problem with bad programmers spamming Reddit with terrible blogspam. The atrocious writing is just insult to injury.
Disappointing. I've seen it do similar things elsewhere.
If A is not the same as char[] explicit invocation of the destructor of a is necessary, isn't it?
&gt; Do you really want someone new to C++ affecting the standard? I'd rather have the experts write the proposals. And again, I'd rather not judge the persons proposing ideas, but the ideas themselves. And it's frankly fairly concerning if the "experts" in the commitee aren't able to do this.
I wonder if never destroying the object (`a`) is somehow UB. Definitely bad code though, has to be A *a = new A; a-&gt;foo(); **a-&gt;~A();** A *b = new(a) B;
I'm struggling to find a practical use for the given example.
Modules please, I beg you guys...
You complained about people needing to learning about linker and stuff, I gave an example where you don't. There's other libraries that include template projects for IDEs. When I was young I used allegro, it worked fine. I think you underestimate people.
You would probably never end up writing code like this, BUT you have know that your code could end up doing the same thing under the good with e.g. standard library. Placement new is widely used in std::vector implementation
I really hope we get a clean simple design without preprocessor support. The preprocessor makes many refactoring tools very unreliable. Maybe there will be more C++ constructs too supplant the preprocessor. Some core guidelines would be helpful too.
Sorry, wrong word there. I'd rather have the experts *evaluate* the proposals.
yes, and experts could mean "people with approver status on a public code hosting website" rather than "people who can afford to spend time &amp; money to go to commitee meetings".
&gt;Is this not undefined behaviour anyway? Nope.
Newbies install an IDE, click on "File &gt; New project &gt; Windowed application", press the big green "Run" button and are greeted with a hello world window.
does this works on Linux?
I'd hope it calls the destructor first.
Using the original(A* a) is undefined behaviour unless you call std::launder on it first. Using b is fine.
Finally I hear the news about standardization of reflection. I have been looking forward to this feature for a while. But looks like there is still a long long way to go...
FYI, that /r/cpp thread was mentioned several times (twice by me) in committee discussions last week. People don't always have time to reply, but it doesn't mean they aren't paying attention. The feedback is appreciated.
It does, but it is only because the specification says it does. Note that calling the destructor would save us from the miscompilation from example.
The worst C++ blog. An excuse to advertise. I'll make a point of never using your software. 
Nothing undefined about it. You know exactly what *should* happen. Placement new pretty exists so you can do this.
Signed overflow behaviour is undefined and so the compiler can generate really efficient code for a potentially broken program.
I've never used an IDE on Linux. I'm sure there's setup that let's you do something equivalent. It's not an environment where they complain about compile flags. I'd just sudo apt-get install libsdl2-dev
Placement new exists so that you can initialize an object into arbitrary memory, not over the top of another object... Looking in the standard, there's undefined behaviour here if A has a destructor ("with side effects the program depends on") so with foo being virtual here we may have that, which may trigger UB here.
&gt; that these bunch of people meet 4x a year in the same building - physically Certainly. But one doesn't need a formal ISO gathering to get people together, and it is arguably *even better* to get these people together without them having to spend 8 hours/day just voting on papers and proposals that they could have reviewed inbetween meetings. The work actually done at an ISO meeting is largely work that can be done online, and the work that best needs people to be co-located gets left as a secondary activity during an ISO meeting week. It's not a good setup.
"Interested" as in you have the time and money. That's a very poor criteria. I'm interested, but I can't afford to take a full week off of work and pay for a hotel and flight 2-3 times/year and not either (a) get let go from work for low productivity related to our actual shipping products which isn't a C++ compiler or (b) having my SO leave me for using all of my vacation time on ISO meetings instead of on vacations together. Further, *having* time and money is hardly a good criteria for "people who should be in charge of making decisions." The irregularity of the travel also leads directly into the frequent case of the "committee" changing its mind on an in-progress paper (or more accurately, the physically present membership of the committee changing meeting-by-meeting and thus having differing and inconsistent opinions).
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/85ufzj/c_matrix_expression_template/dw06fgw/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Just found out about `std::launder` thanks to this and wow, apparently most code using `aligned_storage` etc is UB in C++17 if you don't sprinkle `std::launder` calls all over the place?
Thank you for working on this. The current statu quo (having to pick either `printf` which is not customizable or `std::ostream` which doesn't work with i18n) is not exactly great :(
The rationale was given in other comments actually. It's not so much an issue of adding template parameters and more an issue of adding overloads. In C++, if you say `&amp;fun`, and there's a single declaration of `fun`, it's picked up. If there's two overloads of `fun` however, then the compiler will emit an error as it's ambiguous which you are referring to. Therefore, one rationale would be that by forbidding the formation of pointer-to-function, the Standard reserves the right to add new overloads.
moved [here](https://www.reddit.com/r/cpp_questions/comments/85uq73/c_matrix_expression_template/)
&gt; The scope is just too broad and a single design will never please anyone. How does this not equally apply to: &gt;a standard package manager / build system ?
I'm sorry to hear you fell ill during the meeting. :( Getting sick while traveling really sucks, but it's great that others helped you out. I also wanted to say thank you and Mike McLaughlin for your work on the 2D graphics library. I know how frustrating it can be to work so long on something, and have it not be accepted; at least so far. I personally don't think it should be in the standard library, but I really _really_ hope you try to get it into Boost, for the following reasons: * The API will get more real-world usage and feedback, similar if not better than having it in a TS would do. * Boost is widely used and popular, so issues with packaging+installing it have mostly been addressed, or at least explained in various searchable websites. * Boost generally supports older C++ standard versions and older compilers. So if the 2D lib could be made to work with them, it would get more use and a wider audience - arguably much sooner than if it had to wait for C++2x and however long it takes for people to upgrade compilers. * If it becomes popular, that would provide a strong argument for putting it into the standard library. 
See Rust's `cargo`. 
You might consider reading this: http://michael.orlitzky.com/articles/motherfuckers_need_package_management.xhtml This is not my post, I'm not affiliated with the author in any way, but I think that blog post demonstrates why cargo is just as unsuitable as almost all other package managers.
I was hoping for some [bytebeat](http://canonical.org/~kragen/bytebeat/) :p 
It would allow to pass function parameters that keeps their constexpr-ness. A bit like passing non type template parameters, but with no change to the syntax call. Think of it as explicit constant folding. Imagine if tuple had a `operator[]`! struct tuple { decltype(auto) operator [] (constexpr std::size_t n) { return std::get&lt;n&gt;(*this); } }; Then use tuple like that: auto tup = std::tuple{"abc", 2, 4.5}; auto a = tup[0]; auto b = tup[1]; auto c = tup[2]; Function parameters that keeps constexpr-ness is very powerful, and will enable many things such as string formatting, and constant folding with an actually good syntax.
It was always UB. The good thing is changing the active member of a union is now well-defined in C++17, so you don't need to use `aligned_storage` and friends any more.
&gt; Should this level of template meta programming to exist in std? Should std have this much hidden complexity? Dude have you read (tried to read) your standard library implementation recently? It's insanely complicated. Probably much worse than Eigen. I agree with your overall point though, and exp and log are good examples. People who care about performance rarely use exp and log because it's very common not to need insanely high precision and then there are much faster approximations.
I mean, in practice you could rely on e.g. `aligned_storage&lt;sizeof(T), alignof(T)&gt;::type storage; new (&amp;storage) T(); T* p = reinterpret_cast&lt;T*&gt;(&amp;storage); p-&gt;thing();` working; that's why `aligned_storage` exists in the first place. But I guess now with `std::launder` compilers will start implementing optimizations that break this, and so library code will have to be updated so that it doesn't start breaking randomly.
Why is this UB?
&gt; but I think that blog post demonstrates why cargo is just as unsuitable as almost all other package managers. I'll disagree, because cargo is not a package manager... or at least, cargo does not really *aim* to be a global package manager. I think that any discussion about package managers should recognize that there are **two very different types of usage**: - installing applications, - developing applications. OS-level package managers, such as apt-get, yum, ... are about *installing* applications, and maintaining them up-to-date. They are the package managers that the article talks about. Language-level package managers, such as pip, npm, or cargo... are about *developing* applications, a fundamentally different business, and really should not even *try* to install them (it's a recipe for failure). Those two usecases are both about dependency management, and downloading (and maybe building) stuff, but that's about where the similarity ends. For example, when using a language-level package manager I do **not** want automatic updates. I want my application to be compiled against a specific version of each of its dependencies, even 6 months hence, until I explicitly pick a new version. As another example: - an OS-level package manager is about having a consistent way to install applications from multiple languages onto a single machine, - a language-level package manager is about having a consistent way to develop applications across multiple OSes. They solve fundamentally different problems, and things would be much neater if they didn't try to tread on each others' toes (and instead focused on solving "their" problem).
It is not me, rather university teachers that never move beyond text based examples with C++ to avoid the headache of dealing with graphical libraries. Even Bjarne complains about this.
Great, I would enjoy to see someone explaining the example to them afterwards, in what is supposed to be introduction to programming with C++. 
You can't name a template with a reserved word.
Wasn't that conversion specified as UB before C++17 because of strict aliasing? I believe changing `reinterpret_cast&lt;T*&gt;(&amp;storage)` to `static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;storage))` would have solved the problem pre-`std::launder` and would continue to be correct after C++17.
Thanks Jon for teaching me the term "east const". I'd like to see this show up in tooling. The clang folks thing it belongs in clang-format, but I disagree and feel it belongs in clang-tidy. See discussion here: https://bugs.llvm.org/show_bug.cgi?id=34220
No, the cast contortions have no effect.
Why is that the case? [This answer on SO](https://stackoverflow.com/a/14557329) seems to make the argument that the standard allows it, but maybe I've missed something.
I understand that the author is pissed off, but the person to be blamed is certain Canadian that encouraged this insane idea of pushing 2D graphics in the standard. Yes it would be nice, but give me a break, ISO barely managed to do half of core stuff they needed to do for C++17 (by half I mean half will be in C++20, not C++17). No way that 2D graphics will make it in the standard when you have a gazillion mature and good libraries anyway while standard lacks certain stuff that no library can do. 
Simple. Install Qt Creator + Qt, open some of the numerous graphics example and you are done. Looks nice, works nice and you have a WYSIWYG designer to boot.
void foo(ForwardIterator{T} x, T y); *barf* if you are gonna use this syntax then natural meaning would be: void foo(T : ForwardIterator x, T y); // same syntax as inheritance 
There's no reason we should have a standard graphics library that exists solely for teaching purposes. It's unlikely to see much, if any, actual real world use, so knowing it isnt useful, and it will end up being too simple or general for anything serious, relegating it only to hobby or toy projects. Plus the incredibly weak and hostile proposal for it.
No, Microsoft Visual Studio does not work on linux. Nor does Microsoft DirectX.
`reinterpret_cast&lt;T*&gt;(p)` is equivalent to the expression `static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(p))`
I'm not familiar with the Rust epoch/edition, but the feature does remind me a bit of the GLSL `#version` directive (and perhaps the related `#extension`). The GLSL one is probably a bit less flexible - for example, it essentially has to be the first thing in the GLSL source (but, then again, GLSL has a bit smaller scope overall). Nevertheless, the feature works, and has permitted the GLSL language to evolve along OpenGL (and now Vulkan). I don't think that that evolution would have been possible (or, at least, not as painless) without something like that. Plus, like the report mentions, one already has to deal with different C++ version in practice.
Do you use linux? How do you feel about pacman, apt, yum, etc? What about python's pip, or rubygems, or cocoapods, etc. Are they *all* wrong? At what point will your perspective change?
Cool! That's awesome to hear. Thank you for letting us know.
Ok, got it now! Right!
Yeah, [you're right](http://en.cppreference.com/w/cpp/language/reinterpret_cast) (bullet 5). I think I got confused about the symmetry of the aliasing rules (any type to a `char*` is fine, but not the reverse).
I don't think we necessarily need a standardised linear algebra library. However, I would love a `ndarray_view` as an n-dimensional equivalent of `array_view` which would permit inter-operability between the representations in different libraries. Templated fixed rank and variable rank versions would also be a nice to have. The standard library could perhaps also provide a default concrete container type for this; but it could be as simple as a view onto an array, vector or arbitrary memory buffer. This is something I've started casually playing with, as it's a key gap in the C++ array types used in a work project, but I don't know if it's something which would have wider interest.
&gt; A virtual function call might still be something like 100x faster than calling malloc (around 10 ns vs 1 us; very very rough, context dependent figures). If you have an astonishingly poor allocator, you can expect 1 us. If you have one that is not complete garbage, I expect a few dozen of ns amortized, + sometimes (quite rarely) a few us to allocate memory from the OS. If you mostly only do very big allocations then your number makes more sense, but I don't think it is a typical workload. Still a virtual function call is probably faster than calling malloc. Except maybe if you need Spectre mitigations.
&amp;thinsp;&amp;thinsp;&amp;thinsp;&amp;thinsp;&amp;thinsp;The only example of a clipboard that's accessible from the command line would be OS X/macOS's via `pbcopy` and `pbpaste`, and I wouldn't be surprised if that's because it's exposed for AppleScript if those commands don't reach through some Cocoa APIs to get what they need. I could definitely just be lacking knowledge and/or flat-out wrong, though. 
That still doesn't mean that the library belongs in the standard, if the issue is that including such a library in a project is too intimidating for novices, then as others have pointed out the solution isn't to include it with the standard library, but rather to make including third party libraries easier.
Interested as in professionally interested, which would generally mean your employer would pay for it (if you're employed to work on a compiler) or at least give you time off (if you work on a compiler on the side). Also, at least with the BSI C++ panel, you don't need to attend any meetings.
BlackBerry10 had a clipboard that was basically a file hidden away somewhere, so accessible from command line and multiple languages. (2 files actually, one for the work partition, one for the personal partition) But anyhow, clipboards usually have ways to be notified when they change, etc. And a type system (mime-types). And multiple types in one clipboard (ie you copy text from MS Word, it gets stored as Word-specific format, RTF, and Unicode and ascii. I'm not sure the std wants to tackle all that.
Tell me which name you'd like, and it might become the recommended name, and you will be famous.
`rgs` or `rngs`
Looks cool! A few suggestions: - perhaps add CMake support for cross platform goodness - perhaps implement operator&lt;&lt;(std::pair&lt;int, int&gt; p) - automatically call close() on destruction
&gt; It also hasn't picked up some of Rust's best features yet, such as algebraic datatypes and traits. why would C++ pick-up "traits" ? they're a strict subset of what you can do with templates &amp; inheritance in c++.
More than the field or the company, its highly different depending of the team mindset I am working for a tier 1 bank for low latency components, we are using c++17 and we pushed toward its usage worldwide, but similar team of other region are relunctant to do the switch (for bad reason usually, e.g. not enough time for this kind of thing, which usually sound like they have technical debts) Once you do the switch the easy way to never had that issue again is to constantly update your compiler whem there's a new release, and little by little change your codebase with the newest feature available if it makes sense, that way the transition is much more smooth, and it's also easier for everyone to keep up to date and to avoid technical debt on this point 
How good does isolation actually work there? E.g. when the size of an object changes from one edition to another or inline/template functions (nut sure if rust has those) that get instantiated in the caller context? 
The spec can be a bit funny with language.
`sr` ? (Standard Ranges)
If it locks a mutex, that will very much affect your program.
I think this would be acceptable if reflection can do something like getNameOfFunction(function); . 
Not at all. They're actually much more like Haskell's typeclasses. Rust allows you to: * Require that template parameters satisfy certain traits * Implement any trait on any type anywhere, as long as one of them was defined by you Those two things make traits very powerful.
That sounds wonderful too! Can’t we have both?
I know the pile of template magic needed in variant. Inclusion of variant in std should not be viewed as indication that more template magic is welcome. Moreover variant is still mostly self contained. Once templatised expression is used, the amount of compiler filt generated by the compounded expression will be very difficult for the uninitiated. But we are not the uninitiated, are we? Granted, it seems that the LA std discussion is mostly on 2d 3d stuff. My concern is probably unfounded. 
I use Gentoo Linux. Apt, yum, and so on are all far superior than language specific package managers, though they still have the failing of being unable to handle on-machine compilation, multiple versions of the same package, and compilation and configuration options. They also fail to provide support for compile time patches Pythons pip. Rubygems, and so on have the significant failing of being incapable of properly handling system wide installation, stomping all over the files installed by my system wide package manager and providing few, of any, hooks to provide interop with it. I'll be happy with a language specific package manager that provides all of the hooks needed to properly interop with the system wide package manager, let's me determine the version installed, how its compiled, and configure time options to enable or disable functionality that I need.
The line about extern "C" seems like a bad idea. extern "C" disables name mangling. That's something completely different and unrelated to memory layout.
&gt; Apt, yum, and so on are all far superior than language specific package managers, though they still have the failing of being unable to handle on-machine compilation, multiple versions of the same package, and compilation and configuration options. They also fail to provide support for compile time patches /facepalm
Yeah, fair enough, I was spitballing I guess. I wish that C++ had more discretion to optimize memory layout of structs on its own the way that rust does, and only turn on ABI requirements when necessary. See `#[repr(C)]` https://doc.rust-lang.org/reference/type-layout.html
Linux works very different from ISO C++, but Linus cares _a lot_ about not breaking userland code. That's roughly equivalent to not allowing breaking changes in C++. You also need to consider how many people and how many large corporations use C++. Imagine c++20 would come with a lot of breaking changes... and most decide they will just stay with c++17 to save themselves the hassle. Think python 2/3. 
Effectively no, since the standardization committee is already severely over booked.
Done () is really good to have, I think, but flush () is more idiomatic, especially if we want to emulate file streams, and it should be safe to call multiple times.
&gt; changing the active member of a union is now well-defined in C++17 Could you link us the paper?
Over the top of an existing object *is* arbitrary memory. The only UB that exists is if you try to use the original pointer to touch the new object. There is also no call to a destructor in the code, and that line is a bullshit throwaway line that doesn't mean anything.
Yes. Quite some time ago. I don't think it's on the committee's radar.
[P0137](http://wg21.link/p0137), I think.
Back in early 90's, we used Turbo C++ with BGI. This is the experience 2D lib should provide, not having to go outside for something else. Not every computer system does IO the same way, why should the standard have the baggage of stdio and iostreams, lets remove them.
The same can be said of stdio, iostreams, networking. Not every system provides support for them, so lets not have them on the standard.
Someone who's writing programs whose core functionality isn't LinAlg but still needs to do some vector operations. That's exactly.g. almost anything with a guy, but also programs that process sensor data aka robotics.
&gt; if you are serious about making music professionally it would be helpful to look into sound editing programs instead. Agreed, though if you're interested in *generating sound* instead of making music then a book might be helpful: [Theory and Techniques of Electronic Music ](http://msp.ucsd.edu/techniques.htm) by Miller S. Puckette (yeah, the MSP in MSP/Max).
&gt; This is the experience 2D lib should provide, not having to go outside for something else. Why do you want such lib in std? &gt; iostreams, lets remove them. A lot of people will support such removal. But removing something from std is much harder than just not adding it.
This is great stuff, thanks for making it! Are you planning on doing more STL implementations? I would be very interested in EASTL..
I use `rs` (RangeS) for ranges-v3.
The graph has just numbers, do they have any units or just that, units?
The graph y axis is time in seconds, based on the data in the .csv files. He does specify in the Github repo that these numbers come from his python preprocessor `pcpp`.
&gt; Why do you want such lib in std? For the same reasons Bjarne, Herb and others want. To keep C++ appealing and easy to teach for newer generations, like we used to be able to do with Turbo C++ with BGI, or similar libraries in other compilers back then. Of course no one on their right mind then went to create MS-DOS 2D performance critical applications with BGI. The days of OWL, VCL, MFC, Powerplant are long gone, and C++ is left with plain text interfaces. It surprises me the 2D hate, while other IO related features, subject to the same constraints of not being always available, or not being the best on their class, get a pass.
I used mp11 recently to help generate unique combinations of type pairs to feed to gtest type-parameterized tests. The tests were for classes that inherited from stuff in `boost/operators.hpp` -- e.g. `Point&lt;T&gt;` that needed to support stuff like `(Point&lt;double&gt; + Point&lt;float&gt;) -&gt; Point&lt;double&gt;`. A+++, would recommend.
&gt; but i dont understand, what is wrong with creating a seperate class, instead of inheriting it from another(related) one? Nothing is wrong with it. (public) inheritance is all about implementing a contract and type erasure. When you have implementations of similar classes of functionality, by implementing them as classes within the same hierarchy, you can use one in place of another. Example (assume you have a Report class defining an interface, and a bunch of implementations - SalesReport, WeatherReport, ProgressReport, inheriting from it): void print_report(const Report&amp; r, std::ostream&amp; out) { out &lt;&lt; r.title() &lt;&lt; "\n"; out &lt;&lt; r.body() &lt;&lt; "\n"; } In this case, if `Report`is the base class of a bunch of report types, you can print all report types without caring what concrete type of report you are looking at (as long as they implement a `title()` and `body()` with similar semantics). Similarly, the code will print without caring what type of stream you print to, from the hierarchy of streams available (`print_report(r, std::cout);` works just as well as `print_report(r, some_file_stream);`) This principle (writing code in terms of base classes instead of particular classes in the hierarchy) is called "program to an interface, not an implementation" and it is key to writing maintainable software. There are further cases where inheritance is a key factor, but those are not about providing a public interface; see CRTP, aspect-based programming.
So far my experience is very good too. Documentation is good, but I wish more often one could see an example of how-to-use-this. One is so used to having this from cppreference.com xD
&gt; wish more often one could see an example of how-to-use-this If you don't mind contrived usecases, look at the tests.
The units are technically seconds, but you should ignore them. They are only relevant as a comparator to one another for the same STL. Indeed the hardware I ran the Visual Studio benchmarks on was particularly old and slow with a SAN hard drive, hence the up to thirty seconds in some cases. There is no compiler, it's my C99 Python preprocessor https://pypi.org/project/pcpp/. The reason I choose it is because it captures extensive microtimings for its innards, plus you can tell it things like to only partially expand tokens, or ignore system headers and so on. Normal preprocessors can't do that kind of stuff. Equally, a Python preprocessor is going to be much slower than a C one, however from my benchmarking both scale similarly to complexity of input. So it's indicative for a C preprocessor and C++ tokeniser, just divide by a linear factor of two to ten or so.
Yes, but I'm used to have the documentation open in the browser.
Lower is better. I skipped VS2010 simply because my work machine doesn't have that installed, and I couldn't be bothered going through the rigmarole of getting a licence from Legal etc You should also not take the VS2012 figures seriously. VS2012 uses preprocessor metaprogramming techniques which don't work on a conforming preprocessor, and thus pcpp is erroring out in places which flatters the VS2012 times. The other Visual Studios I tested have much more conforming headers though.
A weight only important to the other STL headers. Lower is less work performed.
My vote clearly goes to SFML. If you want to do "fun stuff", game programming, play around with a nice modern library and do some cool, interesting stuff, SFML is the thing to use. Also it's really easy to use so you won't have a learning curve. Dive right in and do something cool. If your focus is more on learning a GUI framework to build a GUI app, like a more professional application, then I'd go for Qt. But you'll be in a lot of pain.
Is it linked in the documentation?
You may also find my list of "likely lowest impact" STL headers in the Readme of use. Unsurprisingly, it looks very similar to the freestanding STL proposal https://wg21.link/P0829. # Low token count C++ 17 headers on both libstdc++ 7 and VS2017 Each of these is in the bottom quartile of token parse times for all STL headers in their respective STLs. You are therefore more likely to be safe if you include only these: - cassert - cctype - cerrno - cfenv - cfloat - cinttypes - climits - clocale - csetjmp - csignal - cstdarg - cstddef - cstdint - cstdio - cstdlib - cstring - ctime - cwchar - cwctype - exception - initializer_list - new - ratio - typeindex - typeinfo Some of the C headers like `&lt;cmath&gt;` can be quite heavy in some STLs!
I deliberately omitted them to force people to complain here about it, and thus read the many caveats I must make about reading too much into the units of the vertical axis. Very different hardware was used to generate the libstdc++ and VS numbers. Please draw no comparisons between those data sets at all, they are completely independent.
In science, people use ["arbitrary units"](https://en.wikipedia.org/wiki/Arbitrary_unit) designation for such cases. So, you could label your axis "Time (arb. unit)"
Good idea!
Don't forget there is also SFGUI, Thor and other libraries working on top of SFML. Not big, but fill some missing spots
I'm interested why many headers pull out the others. Why `std::array` pulls algorithms and streams? Why `&lt;complex&gt;` needs strings and streams?
What was the seed? `__TIME__` or such things?
This might be useful to /u/stl: ``` C:\Users\ndouglas\Documents\stl-header-heft&gt;python pcpp\pcpp\cmd.py -I "C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt" -I "C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\vc\Tools\MSVC\14.13.26128\include" "C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\vc\Tools\MSVC\14.13.26128\include\array" -D _WIN32 -D _M_X64=1 --time -o array.all.hpp Time report: ============ top level: 20.392500 seconds algorithm: 15.642328 seconds (76.706279%) xmemory: 14.544368 seconds xmemory0: 14.472176 seconds cstdint: 1.840151 seconds yvals.h: 1.801394 seconds xkeycheck.h: 0.044914 seconds crtdefs.h: 1.570051 seconds vcruntime.h: 1.124373 seconds sal.h: 1.041915 seconds concurrencysal.h: 0.054758 seconds vadefs.h: 0.034473 seconds corecrt.h: 0.434934 seconds use_ansi.h: 0.007290 seconds stdint.h: 0.023475 seconds cstdlib: 2.651165 seconds stdlib.h: 1.723877 seconds corecrt_malloc.h: 0.156867 seconds corecrt_search.h: 0.156866 seconds stddef.h: 0.010977 seconds corecrt_wstdlib.h: 0.430448 seconds limits.h: 0.014848 seconds math.h: 0.904798 seconds corecrt_math.h: 0.902033 seconds limits: 4.559668 seconds ymath.h: 0.017276 seconds cfloat: 0.100291 seconds float.h: 0.097908 seconds climits: 0.002088 seconds cmath: 0.478691 seconds xtgmath.h: 0.029021 seconds cwchar: 3.357440 seconds wchar.h: 3.343685 seconds corecrt_memcpy_s.h: 0.168592 seconds errno.h: 0.026120 seconds vcruntime_string.h: 0.095787 seconds corecrt_wconio.h: 0.239242 seconds corecrt_stdio_config.h: 0.021889 seconds corecrt_wctype.h: 0.181487 seconds corecrt_wdirect.h: 0.032017 seconds corecrt_wio.h: 0.137607 seconds corecrt_share.h: 0.003666 seconds corecrt_wprocess.h: 0.113343 seconds corecrt_wstdio.h: 1.463298 seconds corecrt_wstring.h: 0.549676 seconds corecrt_wtime.h: 0.137298 seconds sys/stat.h: 0.082686 seconds sys/types.h: 0.008593 seconds xstddef: 0.170655 seconds cstddef: 0.070797 seconds xtr1common: 0.050978 seconds initializer_list: 0.014274 seconds new: 1.271100 seconds exception: 1.219741 seconds type_traits: 1.001245 seconds malloc.h: 0.054165 seconds vcruntime_exception.h: 0.041578 seconds eh.h: 0.014461 seconds corecrt_terminate.h: 0.006230 seconds vcruntime_new.h: 0.037503 seconds xutility: 3.780096 seconds utility: 2.910559 seconds iosfwd: 2.739447 seconds cstdio: 1.695408 seconds stdio.h: 1.679485 seconds cstring: 0.600077 seconds string.h: 0.591991 seconds corecrt_memory.h: 0.054961 seconds crtdbg.h: 0.162949 seconds vcruntime_new_debug.h: 0.006523 seconds xatomic0.h: 0.010903 seconds intrin0.h: 0.072855 seconds iterator: 4.372935 seconds (21.443839%) istream: 4.212166 seconds ostream: 3.933985 seconds ios: 3.684231 seconds xlocnum: 3.614449 seconds streambuf: 3.138020 seconds xiosbase: 2.963146 seconds xlocale: 2.649486 seconds stdexcept: 1.378838 seconds xstring: 1.331152 seconds typeinfo: 0.059457 seconds vcruntime_typeinfo.h: 0.045934 seconds xlocinfo: 0.461457 seconds xlocinfo.h: 0.376341 seconds ctype.h: 0.204710 seconds locale.h: 0.075768 seconds xfacet: 0.008335 seconds system_error: 0.157680 seconds cerrno: 0.001732 seconds xcall_once.h: 0.007931 seconds share.h: 0.001076 seconds tuple: 0.259206 seconds (1.271084%) ```
Having seen your post history, I have to wonder if you are actually learning to program or just gathering resources indefinitely? Jump in!
Yeah, boost documentation often annoys me for a couple of reasons 1. Getting to it a. Google b. Click search result c. Click link to doc for current version of boost 2. Level of detail a. Documentation: not enough info b. Links in documentation: read the source code Of course some are better than others :)
Yea awesome suggestion, that would definitely help! :-)
Thanks, this information looks like it’ll be useful. I’ll be working on throughput in the near future (finishing C++17 is the only higher priority), and some refactoring is possible here. (Restructuring inclusion dependencies inevitably causes source breaking changes, but we may be able to do some of that.) Your metric is an imperfect one (our users don’t care how long a slow preprocessor implementation would take; they care about wall clock time, memory consumption, debug codegen size, etc. for actual compilation. A small number care about the speed of actual preprocessing but as a prelude to actual compilation; I think build2 does this.) Things like `if constexpr` will show up quite weakly in the preprocessor. Same for an hour’s worth of type_traits work I did yesterday that reduced compiler memory comsumption by 0.9% in my measurements. There are also some things that I would expect show up more strongly in your metric than actual compilation; we should remove our `_NOEXCEPT` macro at some point, since it clutters source and leads to unnecessary token replacement, but I doubt it has much real impact on throughput. And yeah, VS 2012’s faux variadic machinery was terrible; when true variadic templates allowed us to rewrite our codebase, it was glorious.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/860x44/sfml_or_qt/dw1n19e/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
STEP 1: Follow a shitty old ass C with classes tutorial that uses [] "arrays" STEP 2: write some awful code that will crash if you look at it wrong STEP 3: Post it Online STEP 4: Get C++latest EXPERTS teach your ass about how you have to use `std::experimental::std2::experimental::array&lt;decltype(std::experimental::mallocator::Global)..., std3::experimental::integral_constant&lt;std::integer_t&lt;32&gt;, 10&gt;` instead of `int array[10]`
Or you can follow [this book](https://www.amazon.com/Programming-Principles-Practice-Using-2nd/dp/0321992784) instead.
Who the fuck learns using books this isn't the 80s anymore, the industry is too fast and agile to waste ones time reading books that are considered outdated by the time they're published and by the time I'd finish actually reading this damn thing we'd all be complaining about C++23 being shit instead
SFGUI used to have their website with screens, I don't know the reason why they switched to plain github readme (costs?). Google image search is quite accurate about it though.
One thing that helped me is to use modern C++ libraries. Boost, range-v3, etc. give you lots of great functionality, but you can also learn a lot about modern C++ and its direction going forwarding by looking at how they do things. For example, you can use range-v3, and if you find it interesting, you look at how they do the pipe-syntax.
I really don't see why we need networking in the std, not all computers have network interfaces. Nor do I see why we need thread support in the standard, not all computers are multi-core. You can perfectly use OS APIs for networking and threading, when available. See what I did here?
Are you serious?
You can ask the same question about method overloading which can be covered by one polymorphic function. The problem with it is that you have to know the future in order to formulate a unified function covering all combinations of types which is impossible To overcome this problem you use method overloading which is extensible because of its implicit nature. The same holds for typeclasses. typeclasses/traits against to method overloading allows to overload a bunch of methods in a single step which would be otherwise be tedious and error prone with method overloading. typeclasses further give you an explicit type signature of the resulting multifunction(s) which is better when specializing. However, typeclasses are boilerplate when overloading only one function. In this case method overloading is more desireable.
Does this mean we'll be able to writer generators -- like in Python?
Hi, I work in engineering simulation and I was wondering in what scenario should I measure or take into account these metrics when building my code base. Is it more relevant for DB programming or some other sector?
It depends on how many thousands of source files you have. If it's less than 10,000 it's probably not worth worrying about in most cases.
The standard library can't make breaking changes across epochs, so they end up being the same in both mods. (Rust does have both of those, though they function a bit differently than C++'s do; type checking happens *before* expansion, not after, for example)
I'm not a graphics person particularly, so I'm not aware; I'll check into it, thanks!
I googled C++ tutorial: The first hit is cplusplus.com which is laggy enough for me that I just gave up at the tutorials index page. The second hit is tutorialspoint with a gcc from 2008, to quote: "The line using namespace std; tells the compiler to use the std namespace. **Namespaces are a relatively recent addition** to C++." Third is a 70 minute youtube tutorial from 2014 trying to show of the whole language. Give me a decent and recent book any day. 
There are a ton of things about `std::string` which any one of us would just love to fix now we have hindsight. Its whole design, and premise, is from an era which no longer exists and it would be done totally differently today if done again. All that said, I cannot imagine a more painful and unpleasant experience than getting a STL string replacement into Boost. Sure, it's highly worth doing. But I wouldn't wish it on my worst enemy. You're always going to be fighting "good enough". I don't think your proposed idea string has enough to make it sufficiently better than `std::string` to have much chance. The first thing I'd have in any v2 string is always UTF-8 storage, and an all-unicode manipulation API, but with the ability to see the underlying storage as a bunch of bytes. So something like http://www.fox-toolkit.org/ref/classFX_1_1FXString.html would be a good start, just more STLish. Once you lose the templated value type which we now know was a design mistake, you gain the stable ABI for free in any case. My widely disliked opinion that any redesigned v2 STL containers need to never implicitly allocate memory would not apply to a string object. For those I think implicit memory allocation is highly desirable. That would be my first stab at a v2 string. But I have a second stab too - a Peter Dimov style polymorphic string whereby the underlying storage is some UTF standard, but the public API always works in UTF-8. Peter argued forcefully for Filesystem's path to use that design, and with hindsight we now know he was right, and the eventual choice for Filesystem's path of a differing UTF string storage depending on platform was the wrong design. Ship has sailed of course, but I'll be attempting a remedial action on that via `path_view` at Rapperswil. A third stab is a LLVM type string. Chandler bangs on a lot about its superiority, and for situations where you're doing a lot of string manipulation work, it's unbeatable. It comes with significant added implementation complexity (expression templates) and lifetime concerns however. Nobody would call a LLVM type string "lightweight", but it definitely ticks the box in terms of value add over `std::string`. Hope this is helpful, and if you are a masochist, please do try to get an improved string into Boost and then the C++ standard. It's very much worth doing.
I had to `man xxd` to get what it actually is ... interesting combo of tools
Thanks for that explaination! This really made it clearer for me and I already found a use for it! Thanks
Yes.
Thanks. :) On second thought, no combo is needed: `-DSEED $(xxd -p -l4 /dev/random)`
Hi, great report! I was wondering if you could expand on the technical limitations you mentioned concerning reflection on overload sets. Mainly for what compiler vendors is this an issue and in what regard?
sure thing ! https://en.sfml-dev.org/forums/index.php?topic=18062.msg140437#msg140437
&gt; is it possible to determine the type of a inherited class? Ideally, no. If you find yourself needing to know the concrete type, that is usually a symptom of insufficient design.
&gt; It is just to add an immutable and minimalist type that could be converted from/to std::string and that could cross modules boundaries, and be fast to copy, and to compile. It's somehow similar to std::string_view, but able manage memory. It might be worth asking on boost-dev or SG14 for feedback. But I can see people will simply ask "why don't you simply derive from string_view adding a destructor which deletes the pointed to storage?" Also, have you seen https://ned14.github.io/status-code/doc_status_code_domain.html#standardese-system_error2__status_code_domain__string_ref yet?
btw zig does allow objects of size zero.
Yes, although we are pretty late in the design phase right now, and changing course would delay the feature.
This is completely wrong. You should research topics before teaching them to others.
"Too many words. Is there a video I can watch?"
First image I see: &gt; Inline functions are used to make programs faster No no no no no! Inline is about ODR, not inlining!
Welcome to C++!
Sounds neat - a worthy work! Good luck, everyone :)
std::byte is just an empty enum with unsigned char as underlying type.
You can do so with any STL class/algorithm (after all, the complexity requirements are usually given in big-O, no mention of the constant!). Yet, we have highly efficient containers and algos with different implementations competing to make it better. But it won't help when the feature is inherently flawed and can't be effictively used for anything other than toy examples.
stdio is from C, iostreams is widely considered terrible, and networking doesn't even exist yet? networking is fundamental to a lot of programs, it belongs in the standard. It applies to a LOT MORE than "graphical desktop". Networking is something that doesnt change. There is a right way to do it, period. The same cannot be said of graphics. Networking is also useful almost everywhere, especially in the real world. Not true for graphics. Networking is actually useful and feasible. Graphics is not.
I've been learning C++ by taking a Udemy course called "Unreal Developer Course- Learn C++ and Make Games". It's extremely well thought out and has made learning C++ a bit more fun. Though I believe it is at C++11. But, if you're like me and just now learning, it's perfect because they explain things very well and the instructors have built a very helpful and responsive community.
Yes I think I used `__TIME__` (whose resolution is seconds, afaik) because I remember thinking something like the time of compilations will probably differ by seconds because the whole compilation (of my project) takes longer than a second. But this was years ago so my memory is not clear. It was fun though.
There are lots of devices without network capabilities. The networking library fails short of allowing control over specific interfaces, implementing lower level protocols, doing networking over bluetooth, I2C, ZigBee, GSM, LTE, certificates management. All of which require accessing OS network APIs for serious real projects. So why burden the standard with half support for network programming, no need.
So the library writers for each competing C++ implementation are able to achieve good performance for their networking and threading libraries, yet they will magically loose their skills when implementing the 2D library.
That's still around, huh?
Are those figures relevant for anyone not involved in the standardization process or maintaining a standard library? It's not like I will suddenly stop using STL types just because the preprocessor needs a lot of time to process their headers (if anything, a significant increase in actual compilation time might result in such a decision). And because I must not forward declare standard library types there is little I can do about this. Don't get me wrong: I find the results interesting but it doesn't seem to be anything I could act upon.
They are zeroed.
&gt; Lack of non type template parameters and variadics make arrays and tuples feel second class. No constexpr. Not true. Check out `const fn`. AFAIK it's able to evaluate almost complete subset of the language (including heap allocations) at compile time as long as it doesn't make any syscalls and similar restrictions.
Well, they prefix their "the week in rust" blog post with this: &gt;Rust is a systems language pursuing the trifecta: safety, concurrency, and speed Works like a slogan. All other languages usually compromise one (or two) of those to achieve the others.
Well yes, but is effort. And with very little value add, VS2017 is very similar to VS2015. VS2010 would be more interesting, however.
I think the most relevant guidance for users is: include all of the headers that you're supposed to, but don't include unnecessary headers, and use PCHes wisely.
Hm, "fast, safe concurrency" **is** a great slogan. 
The reason I invested the effort was to correctly implement the new lightweight single file Outcome (https://github.com/ned14/outcome/tree/develop/single-header). I needed to know which were the "light" and "heavy" headers so the lightweight Outcome would not include the heavy headers. You might ask why bother? I've received the request from some big iron C++ users for it. Users with half a million source files upwards. Ones who really, really care about even a half second extra per compiland, and whose public interface files do not permit new `#include`'s, if you attempt to commit a delta containing a new include, it gets rejected. That sort of user.
learncpp.com is pretty nice
Yes. Because &gt;the feature is inherently flawed I.e. it can't be competitive with any existing professional graphics lib by-design. It's similar to the situation with iostreams (although much more extreme), where they can't compete with a basic printf despite being type aware (which is advantage), no matter how many clever devirtualization tricks the compilers employ. I.e. it solves a questionable point, promises to be a maintenance pain, and is based on already phased-out borderline legacy lib. Anyway here is a good writeup: https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/sg13/gUr98RZMU7M
True. But I have little doubt that it'll get there. And considering that Rust has been "out" for less time that the usual C++ standard iteration takes (and with speed only recently achieved) I think they are doing pretty well at delivering new features. It's not some fundamental limitation of a language like Go and its complete lack of generics.
Learn about recursion and stack depth?
 &gt; Do you develop software? Yes, I develop software, professionally, for about 10 years now. C++, networking code, internal STL-like implementation, so on. All C++, all the time. &gt; I regularly work on multiple branches of the same codebase, each branch having a different set of dependencies. Yep, same. &gt; The code that we compile must run on multiple Linux hosts, with different kernels/glibc versions. Yep. Same. &gt; The simplest way for us to manage this is to: &gt; &gt; * use a developer package manager (maven) to handle dependencies so as to get reproducible/isolated builds (independently on the host on which said build is compiled, so that you get the same result as any of your team-mates, the CI agents, etc...), &gt; * pin down the version of glibc against which we compile against (to the lowest common denominator), &gt; * then prepare a rpm for the hosts to which we deploy. Maven sounds like an incredibly annoying way to accomplish that. Does it work well for C++? I'm skeptical. Who's choosing your compile flags, and such? Are you hosting your own Maven repository, or just relying on some public repositories? How does that work out? What about ABI issues when you upgrade compilers? Does your Maven repository need to be recompiled for all packages before developers can use it? Or do you only address the packages that break? My teams continuous integration system handles most this for us, and the parts that it doesn't, are either included in our revision control system, or are handled by the OS package manager for the developers workstation. We control our entire dependency graph down to, but not including the c runtime. We do use the system libc because of how closely tied to the kernel they tend to be. &gt; So we are, actually, using both kinds of package managers: &gt; &gt; * The developer package manager to develop, &gt; * the OS package manager to install. &gt; &gt; You can reject the premise that there are two different usecases as much as you wish, but reality seems to disagree with you. I reject that there are two distinct use-cases. These are the same concept. Define the concept of a package as some collection of files, whatever they happen to be, in some layout that resembles a directory hierarchy like what you'd see on a Posix system. Packages may optionally involve scripts that execute at various points in the package managers operation, the nature of which I won't bother specifying. Define a dependency graph as a collection or set of packages, where each package has some relationship to each other package in the set, such that the relationships can be represented by (hopefully) a-cyclical directed graph, where the edges between nodes denote some kind of "A Needs B" or "A Recommends B", or "A Depends on B" and so on and so forth. Potentially there might also be concepts of "A Conflicts B", and that kind of thing. Your OS package manager installs a dependency graph of packages to "/", and may have features related to any of these or other operations such as installing, uninstalling, upgrading, downgrading, configuring, or otherwise dealing with tasks related to manipulating these packages. Your developer package manager installs a dependency graph of packages to "not /", and may have features related to any of these or other operations such as installing, uninstalling, upgrading, downgrading, configuring, or otherwise dealing with tasks related to manipulating these packages. Unless I'm missing a capability where the OS package manager and Developer package manager differ significantly, there's no difference between an OS package manager and Developer package manager, except that in common practice, from what I've seen in the wild, the Developer package manager tends to be significantly less capable than the OS package manager. Thusly, there's no difference between the tasks needed by use-case, therefore they are the same use-case.
A specialization could even offer those extra functions as long as they don't violate LSP like `vector&lt;bool&gt;`. 
It often uses a gtk back-end.
Its not the whole story, of course. But I figured that was the information they were after. 
Second this. I used it. I had prior programming knowledge though, which helps, and it can't beat a good book i'm sure, but it's a good start.
I'm looking at it very differently to you. I see curves and trends and outliers. Unless you did something really weird in VS2015, I would assume there is a simple progression from VS2013 to VS2017 of across the board general improvement. I can't see any reason why VS2015 would be an outlier with weird pathological behaviours. But in the end, you wrote it, not me, you know better than I.
Hmm.. I'm really unsure whether I should learn proper modern C++ (I know only some basic C with classes) or bet on Rust for now. C++ is way more popular in industry but it's also quite a mess and might become a legacy language if Rust takes off. Rust on the other hand seems to be less messy and is more strict, which is a good thing as we have learned from all the C problems we face. In addition to that, it *might* become popular. There is also the option to stick with C for now and do actual projects (gain experience) with that instead of learning languages all the time. I'm still a student and want to go into Embedded Development after university. What's more important? Knowing the tools the company uses or having some experience with toy projects?
Functional programming doesn't rule out stateful function objects (e.g. lambdas with value captures). Indeed, that's one of the most powerful forms of functional programming. What it rules out is state modification. Modifiable state allows many algorithms to be fast (e.g. graph algorithms), but it's also hard to reason about. You have to think about the timeline of the state, and who's been messing with it, and what it currently could be. People screw this up all the time when they aren't careful, and we have lots of conventions to get it right (e.g. class invariants, loop invariants, access control, etc.) When you forbid modifiable state, then you give up some efficiency and you also give up some clarity (some things are just simpler to express by modifying state), but you also rule out many forms of bugs. If the only way to effectively modify state is to produce a fresh object, then where an object is coming from tells you statically what kind of state it can be in. Coming from a Scheme background, I view functional programming as interesting but ultimately too limited and inconvenient. I'm glad that it taught me to respect the danger of modifiable state, though.
In what sense? 
There wouldn't be much UI. AFAIU, you'd just get a canvas on which you could draw something. Doesn't seem to be very interactive.
Does it not deal with input? (Keyboard, mouse or touch?) A canvas would be good enough for manny embedded systems with LCDs for display..
Would be more useful for comparison's sake to provide entity and component count alongside frame-rates. [This is a good example.](https://github.com/abeimler/ecs_benchmark)
So as I said on there: &gt; I would love a book similar to *C# In Depth* but for C++. The book takes you on an evolutionary tour of C#s features, version-by-version. One of my favorite programming books of all time and a good read even for someone who doesn't program in C#. Does anyone know if there's a modern book like this for C++?
This is a blog post. They aren't after information; they are disseminating it.
To be fair, the compile times quickly become fucking unbearable once your templates start getting out of hand. That and the STL performance used to be horrific on all compilers up until ~2013 or so. Even then it's still largely useless because you'll ineveitably have to rewrite every STL component you're using thanks to some inane snag. Hopefully ranges will be the first part of the STL that doesn't suffer from that.
And it's so nice! I recently wrote a gui for the classic MacOS (why ask why?) and I was flabbergasted by how my own program was responsible for in that ui (window management, system menus, key bindings, etc). Qt has spoiled me so much, I was expecting something largely callback-driven, albeit still yielding to the OS at regular intervals for cooperative multitasking, and what I got was so much more rudimentary. It's easy to forget how far we've come with this stuff.
Thank you, but I'm still being a bit thick. Say I have a function that models a state machine's transitions based on input flags and an original state. Why do I need to care if the object representing the original state is preserved? The function provides a new state but I'm missing why it should be copied and not modified in place.
`std::array`'s comparison operators are defined semantically in terms of `std::lexicographical_compare`, so it makes sense to implement in terms of it as well.
I never understood why people used wxWidgets. It looks just like the bastard MFC. I wouldn't want to touch it, since MFC was a nightmare to begin with anyway. I personally would just stick with Qt. Far more platforms, pleasant and well documented API, and much more easier to use and learn. A lot more features. On the other hand, it's gotten a little bit harder to compile on windows, and MOC, but meh, I'll survive. I wish, they had a C# bindings.
A few random thoughts: Don't confuse correlation with causation. I'm not surprised that people who use vim earn more money, it's not easy to learn and master it, these are the kind of people who seek challenges, want to learn, coding is their passion... they probably would earn higher wages even if they didn't use vim. It's probably more their mentality that makes them more efficient than their editor of choice (from which they will squeeze every bit of productivity). A good IDE has easier learning cure so more people will choose it. Some people might be just as productive or even more than the ones using vim, but the mass of less experienced people will bring down the average. Using vim might not cause you to be a better coder, but it's more likely being a good developer is a prerequisite to using vim. I don't use vim, it's not just that I'd rather not spend the time learning it instead of doing/making stuff, but I cannot afford the time to train new employees to use it. (If someone can, they are free to do so.) So you might be a genius who is working on radically new stuff, or someone could make an argument that if you spending most of the time writing code, then you are doing it wrong. Instead of reinventing the wheel you should research and use already written libraries... ;) 
I'm not too familiar with FP but from what I understand: Mutating your inputs make the function behavior less predictable. Some function like `updateX(x)` might do something different based on how many times it's been called (because `x` changes every time you call it). However, if you have something like `const updatedX = getUpdatedX(x)` (granted that `x` is immutable too), will behave identically no matter where or how many times it's called. You also don't really have to mentally track what happens to `x` (since nothing can happen to it). Plus just mixing inputs and outputs within function arguments makes it harder to understand what is output and what's not just by looking at function call.
Backtracking, for one. Things like functional data structures make unrolling to a previous state trivial.
&gt; I never understood why people used wxWidgets. It looks just like the bastard MFC. There are many people who worked in MFC and quickly migrated to wx ecosystem. wxWidgets look pretty good in windows and unlike Qt, wxWidgets is pretty much pure C++. In Qt, in GUI domain you can't use templates and many other things. As far as I have seen, wxWidgets are less energy hungry and does well for decent GUIs
*I wish, they had a C# bindings.* What's wrong with QtSharp? https://github.com/ddobrev/QtSharp 
From what I can see, there's hardly any development.
None of what you have said is true my experience, and I've been a professional C++ programmer since 2003 (a user since 1998). &gt; To be fair, the compile times quickly become fucking unbearable once your templates start getting out of hand. I've never seen "templates" be a problem for compile times. I've seen certain templates be a problem, and some meta-programming heavy libraries be a problem, and I've seen the occasional bug in STL where a template was expensive to compile, but those were typically bugs that have been fixed. Saying templates are bad for compile times is like saying functions are bad for runtime. You might have a slow function that needs optimizing, so you optimize it. It's the same with templates. &gt; That and the STL performance used to be horrific on all compilers up until ~2013 or so. How so? I don't believe it's really changed in the full 20 years I've been using the language. &gt; Even then it's still largely useless because you'll ineveitably have to rewrite every STL component you're using thanks to some inane snag. Hopefully ranges will be the first part of the STL that doesn't suffer from that. Hrm, I've never had to rewrite a single thing. I know that I've done the opposite of that a lot (rewritten "inline" containers in terms of STL, replaced custom container usages with STL, etc) and doing so fixed bugs, increased performance, and usually reduced code. Not always though because pre-auto, specifying an iterator could be a bit verbose at times. I will concede that I have had to work around the occasional issue, but I've never not been able to do that to the point of requiring some kind of rewrite. 
I wish we would not need `std::string` at all, and C/C++ had proper language native string type (not just character array/pointer). Then there is no `&lt;string&gt;` to parse... 
Moving runtime computations to compile-time is always(?) a good thing. :) --- Just a couple of coments: 1. `ComponentSystem::addComponent` is missing a return type 2. `template &lt;typename... Ts, typename Func&gt;` Is this allowed? My intuition says "no" because type deduction is ambiguous. 3. This for(int i = 0; i &lt; entities.size(); ++i) { auto&amp; ent = entities[i]; should be spelled for(auto &amp;ent: entities) 
Lol. I've been confused correlation and causality. People who are good at their job use vim because it allows them to code at the speed of thought. It's about ergonomics. Good tools doesn't make the artist, and good artists aren't held back by bad tools, but good artists seek the tools that don't get in the way or slow them down. This had absolutely no relation to using libraries.
1. Yes it is. I messed up there, I'll fix it in the blog post. 2. Yep, 100% allowed. [Look here!](https://godbolt.org/g/Cnno4S) 3. The non-ranged-based `for` is from an older version of the code where it did some slightly fancier stuff involving skipping entities. I benchmarked it and found it to not be worth the massive bookkeeping headache. Thank you for reminding me though! I changed it in the code and will update the blog post soon. 
I don't mean to hijack OP's post, but I am getting ready to write a GUI app in C++ that needs to run on Linux and Mac (Windows is a minimal concern). I was deciding between Tk, wx, and Qt, but was leaning toward Tk as I've used it in Perl and Python. I was surprised by the negative comments toward wx. To me, Qt seems to be the most complex with the moc compiler. Tk is fairly low-level, but the most familiar to me. For people who have _recently_ used more than one of these, which did you prefer?
@2, thanks for double-checking. I was too lazy! It's interesting that the compiler treats the pack as a single type as in template &lt;typename T, typename U&gt; foo (U u, V v); I was thinking more of the case template &lt;typename... Ts, typename U&gt; foo (Ts... t, U u); that won't compile. @3. Ah, ok. I understand needing to deal with legacy stuff. I just thought it was odd given all of the nice C++14 features you were showing off.
I think you're getting caught up on the C++ terminology of "function". The "functional" in "functional programming" is more like "math function". sqrt(4) returns 2, it doesn't modify anything. If "functional programming" were called "immutable programming", it would be more accurate and simpler to understand. (C++ has "lvalues" and "rvalues" so we certainly can't throw stones.)
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/868e8i/using_files_making_functions_etc/dw351xj/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Then you must hate the ASIO-based networking proposal because it goes beyond simple TCP or UDP, and is insanely complex in comparison to simple socket wrappers. There's nothing wrong with a toy graphics API. It is better than nothing. Same with iostreams, sometimes (most of the time) I just want to set something up quick to try something. Just like I don't want to have to deal with format specifiers and buffer bugs, I don't want to deal with different libraries and build systems just for a simple graphics application. Also, I think the C++ community could do to lose a few users determined on holding it back.
Nah, I wrote the skipping entity stuff myself. It's not really legacy so much as a stupid idea I did and realized was stupid but didn't fix fully.
Being a full-time Haskell developer, I'd like to disagree with the other answers. First of all, I think `T f(U &amp;&amp; u)` is a perfectly fine function semantically, as long as you don't abuse `std::move`. Because `f` will only mutate a `U` that nobody else will see, so you still get all the benefits of FP. I'll go further that `T g(U &amp; u)` might still be fine, depending on how you use it. After all, I can define a function: template &lt;class F, class Arg&gt; auto purify(F f) { return [f] (Arg arg) {return f(arg);}; } To purify any function like `g` to obtain one that doesn't modify its input. And I'd argue that `g` is in fact better for me, since I always have the option to use `g` impurely (to gain performance) as long as I can prove that nobody else is accessing that state (maybe I encapsulate it, and only dispatch copies of it, or maybe copies of parts of it). If you're using mutation for anything other than performance optimization (Always consider efficient persistent data structures first though), then you're clearly not doing functional programming. But if you have pure semantics, you can perform all kinds of side-effects and call it FP. For instance, you have a server that serves files with a URL that contains a cryptographic hash of the contents of the file, and you have some functions whose only side-effect is to access these servers over the network (which is a very impure operation) and verify that the response they get maches the hash. Then you could say that the functions are pure as long as they succeed. So, you could have two perspectives on your code. In the happy perspective, the functions always succeed (this is probably where your business logic lives), so your code is pure there, and you get the benefit of purely functional programming at the level of business logic. In the realistic perspective, the network might be down, your servers might be hacked and serving malicious data etc. In that perspective, those functions aren't pure, and their side-effects are first-class concerns (maybe, you have to recover from failure, or maybe some other non-trivial thing). At the end of the day, FP is all about having rigid semantics, and not some rituals that make your code look cool.
It throws me from a loop switching from heavy Qt to STD c++ every time
Nice link
VS2015 got back in the realm of sanity, with a lot more conformance and much less gotchas than 2013 had (also an improvement of 2012). I have code that compiled fine with 2015 but that 2013 would not compile.
I think Qt will be amazing once metaclasses land in the standard, because you will be able to use it without the complications you need now.
Also, many implementations of the "pipeline" can internally use in-place algorithms if they know the initial value will be thrown away. What it matters is that for the coder, it behaves "as if" it was never mutating anything.
Agree, it's really awful sometimes (frequently, even), especially anything to do with TBAA. Can you link the SO question?
What is complex about moc? 
How do you confirm that the optimization really takes effect? It is better if there is a performance statistic comparison.
Yes, IIRC.
And HTML version provided for free! http://msp.ucsd.edu/techniques/latest/book-html/ This is wonderful. 
My question was certainly not why bother with compile-times. My question was a) if the preprocessing time is a good metric for how heavy a header is and b) if there is anything I can do about it if I don't control the standard library implementation.
Could you show some examples of complicated features?
That's the basic idea behind technical specifications (TSes), which basically every major feature goes through.
Please consider this example, I'm not sure about what use cases that the feature was made for, the syntax makes it complicated to me. It's an example in this site: http://en.cppreference.com/w/cpp/language/variable_template ``` template&lt;class T&gt; constexpr T pi = T(3.1415926535897932385L); // variable template template&lt;class T&gt; T circular_area(T r) // function template { return pi&lt;T&gt; * r * r; // pi&lt;T&gt; is a variable template instantiation } ```
How is this more complicated than template&lt;class T&gt; struct pi { static constexpr T value = T(3.1415926535897932385L); l }; template&lt;class T&gt; T circular_area(T r) // function template { return pi&lt;T&gt;::value * r * r; } ?
thank you, I just searched for some proof, it indeed was in action, but not so long, it was since 2017-10-09.
what do you mean? I can see that you didn't use variable template, do you mean variable template is not necessary in this case?
Those aren't TSes, those are feature tests. If you look here you can see the current TSes and some previous ones: http://en.cppreference.com/w/cpp/experimental https://isocpp.org/std/status
Great article! I really like the explanations, which are detailed but somehow very easy to read and understand.
It's entirely free, including the pizzas and drinks.
Concepts terse syntax is still a hot topic in std comittee. Several proposals vere published. Obviously they have different tradeoffs and they are pushed by different people with more or less influence. I am interested in what would people here choose so I created a simle doodle voting table (disclaimet: I am not a comittee member)
Hmm.. I just want to consider feature use cases. In this case, I believe I was wrong when I said variable template is not necessary. It helps a lot in this case, for example, not all compilers support `__float128`.
It's basically the only reliable way to way cross-platform applications using GTK on Linux.
If the only thing keeping you from Qt is moc (despite it being a no-brainer), you should look into [Verdigris](https://github.com/woboq/verdigris): it's a way to do moc's work via ugly macros and C++14 while still maintaining 100% Qt compatibility. (As a bonus, since it's not affected by moc's parsing limitations, it can work even for complex classes where moc wouldn't work.)
Whatever as long as we can have auto as function parameter.
Uh.... What ? Given int f(int&amp;&amp; x) { return x++; } int main() { int x = 0; f(std::move(x)); returb x; } Your program outputs 1. Rvalue references are still references.
Sorry. "Speculative" was a polite way of saying I focus on concrete outcomes, usually positive ones. I don't discuss things that failed unless they are very dead and will not be revisited.
Just you, I think. LSP = ?
wg21.link/p0009 and wg21.link/p0454
LSP is Liskov Substitution Principle, just applied to specializations here instead of a derived class or interface implementation class like it normally is.
Using doodle for this kind of vote is so bad. Use a strawpoll or something.
That's a toughie. I might have to think on it FOR a WHILE. 
I'm not arguing whether half a second is a lot or not (I find it quite a lot), I'm asking if what you measured ( if I understand correctly processing the files with your own preprocessor) is a good metric for what matters (How much does my total compilation time increase when I include that header?). There is certainly done correlation between the two, but I have no Idea how good. I can blow up your compilation time by only including a few lines of badly written tmp code whereas just manually a few thousand lines of function declarations and macros might not be a problem. To me it feels a bit like determining execution time of a piece of code by counting the number of instructions in a program. Sure, both values will correlate somewhat but most of the time you might want to use a more precise metric. Btw. If you just want to know what gets included I get the point about some standard library facilities not being worth the additional compilation time
What is this title o.o
and 'i' with int i; ?
&gt; Half functional programming? Is it like half-vegetarian?
Oooomph, ... broken English, nice format with quotes and links. Short version: Concurrency is hard and becoming more important. There are other programming languages, and they to also have to deal with concurrency. Oh, and we claim concurrent programming is not scary as before.
Think kind of polls is moot, IMHO, especially since it takes place right after the Jacksonville C++ committee meeting, where the subject has been discussed at length and the outcome of such discussions hasn't been disclosed yet. By the way, the poll is also unfair, since the provided references are wrong: P0750 is not the paper about the "{} syntax" and P0956 is not the paper about the "Original syntax".
`/showInclude` ;) Just to be clear: I don't want to devalue your work. I do find the analysis and recommendations very interesting and hope some STL maintainers / committee will take your input to heart. And intuitively I'd expect those measurements to be indeed a useful proxy but it would be nice to validate that (e.g. by measuring compilation times of a cpp file that only includes a single header at a time).
Well, you learn something new every day. Only been using MSVC since 1996 ... sigh ...
Okay, I've had enough of these. No more cppdepend articles.
Whaaaaat? I just compiled v3.1.1! Prolly old news | I'm on rolling
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/85spsm/c_is_maybe_low_level_but_not_over_complicated_its/dw3jomx/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
Yes, but this code is bad. Just because you can do something, doesn't mean it's good to do it.
What does `__float128` have to do with this?
Ah, good to know, although I have no mac to try it, and I had to drop mac support entirely anyway due to their OpenGL policies.
&gt; This is like saying private fields are not really private because we can still read them using the object pointer and and offset. Or saying const is broken because it offer no guarantee that your object cannot change. well, if you want strong guarantees for instance for critical safety systems, both things are true and known problems. I can promise you that people who put `#define private public` in their commits *do* exist. And even in critical environments, if they can be abused, they will (see the Toyota case for instance). The only thing that matters in the end is what your compiler allows, no amount of human process will be able to catch everything. 
Troubles with licensing? If you mean Qt, i mean it's standard LGPL so.
It’s quite a bit more than that, since it overloads the relevant operators. It would indeed be the appropriate type here, if it weren’t for the fact that that [C++ IOstreams are fundamentally designed around characters](https://stackoverflow.com/a/47482075/1968).
&gt; To me, Qt seems to be the most complex with the moc compiler. just do `set(CMAKE_AUTOMOC 1)` and you don't have to care about moc *at all*.
&gt; In Qt, in GUI domain you can't use templates and many other things. you can, nowadays, with Verdigris (https://github.com/woboq/verdigris). Without reflection available in C++ it still isn't very clean though.
Nice article, thanks for sharing! In World::eachEntity I think you can create the tuple directly without using array: std::make_tuple(get&lt;Ts&gt;()...) 
the qt problem would be special preprocessing 
- template type deduction - initialization rules
2\. is allowed but only for template signature. You can't take `Args... args, F f`
There's no harm in looking.
GUI needs a stable library and a production quality library for a long. Verfigris is not suitable for GUi
... what makes you say this ? it only replaces a small part of Qt, and is done by the current maintainer of moc in Qt.
The point of the second paragraph was that if you don't work on a compiler, you're not really in a position to have a say, since ultimately it's the implementers that decide what features are available for use.
How is lgpl annoying to deal with?
It doesn't, as far as I can tell.
I just want to show my personal point, a programming language should be minimal, it's not minimal when there are more than one way to do a same thing. You can disagree with me about this, I just don't want to argue because it doesn't solve anything.
For TS libraries, we can use them before they are approved. But for TS language features, how can we use them?
Guys, I don't care about the stupid points of my reply, but what is down voting for? Does it solve anything? Those new features are complicated **for me** and it surprised **me** a lot. **I posted here with a question not to bring you guys down!** and so far, I don't feel the C++ community here is friendly.
&gt; But for TS language features, how can we use them? The compiler vendors implement them in branches or gated behind flags and you can try them out before they're finalized. For example, module support right now in GCC, Clang, and VS2017.
nana is also pure C++ (is actually heavily "modern") and very easy to set-up and make an application with it. Not quite in the same category as wxWidgets and Qt, but is pretty lightweight and under boost licence. I tried it few days ago on raspberry pi and it was very easy to set up (funny enough it took me longer to properly build it through msvc's remote build).
&gt; I posted here with a question No, you posted an uninformed complaint that sounded like all the other "C++ is too complicated" posts we routinely deal with. It had no examples of what you thought was too complicated and asked for a thing that has been the norm for years, which showed you'd not even bothered to go see how things work. 
Hey man, I carefully made **bold** my question in the post body: **Could we experiment a new feature with something like a compiler option (ex `--feature-function-return-type-deduction') for around a year before voting it to standardize? In this way, we can keep speed in innovating the language and its stability as well.** I'm complaining about complexity, yes! Why are there so many people complain about it? I'm here with a suggestion and asking for discussion. Anything rude here? I don't get it.
thank you
I meant that code could query whether a function may throw, not a `noexcept(auto)`. And something like `noexcept(true)` could be added to a function to have the compiler check for possible throws. And a `noexcept(abort)` could be used to *assume* `noexcept`. There's also a `pure` function annotation I might have, and I don't want source files to be litters with these annotation. Alternatively, I could do what D does, and simply declare a whole scope of functions as `noexcept` and/or `pure`. But I'm not fussed about these details right now, as I won't start on this compiler for a long while.
lazy evaluation is something nice to do, not something u have to, and it is only enabled by the nature of the functional programming. If data changes state, u cannot do the evaluation later. Brevity just means it is simpler compared to when data has state. All tie to programming data (not program control flow) lacking of state. 
I always wondered why they can't just make one first in boost ? Why insist on standardizing 2D Graphics? Are there special cases where it's needed (except for teaching C++ with graphics at first?). Maybe they could (after implementing something in boost), standardize just a 2D graphic interface.
&gt;In general, it is recommended to use the most recent standard version support by the toolchain, which is C99 (-std=gnu99) and C++98 (enabled by default default) for the Red Hat Enterprise Linux system compilers. Makes me so sad that a major Linux distribution still recommends C++98 in 2018. 
&gt; Guys, I don't care about the stupid points of my reply, but what is down voting for? Okay, this is highly offtopic, but whatever. So first of all, I do not see any offending post towards your person here. Therefore I assume your claim reddit C++ community != friendly is only based on downvotes. I would advise against judging the friendliness of the community purely on up/downvotes. Second of all, remember that, if the intention of your post was to solve questions of things you don't understand, you may have come to the wrong sub in the first place. Consider /r/cpp_questions In case you came here with the purpose of critique on the language and will to discuss the issues you see, you started off the wrong foot. If you want to start a discussion on such a subjective issue (too complicated in your opinion) you need to provide good examples and reasoning. They are completely missing in your starting post. Where are your examples? What points exactly do you criticise? Even better, where are suggested solutions?
I just finished making a good-looking kanban board desktop app (calls into redmine REST api). Used Qt, took me two days, blazingly fast for the features it has. qml &amp; C++ is such a pleasure to develop a UI in, especially for small projects.
Why? Qt on mobile is a thing, as far as I know there is no static linking involved, just bundle all the stuff into the apk.
&gt; a programming language should be minimal, it's not minimal when there are more than one way to do a same thing. then how would you feel programming using only the Intel `MOV` instruction ? [in practice you don't need anything else](https://github.com/xoreaxeaxeax/movfuscator)
[Does App Store accept Qt app linked with QT Library LGPLv3 ](https://stackoverflow.com/questions/35068054/does-app-store-accept-qt-app-linked-with-qt-library-lgplv3) The accepted answer is why anything other then MIT is an no go.
&gt;We have also implemented parallel algorithms conforming to the ISO C++17 standard. Awesome. Is this the first major standard library to offer the parallel algorithms? Also with Expression SFINAE complete, will range-v3 and Hana now work unmodified with Visual C++?
&gt; If data changes state, u cannot do the evaluation later. Yes you can, look up copy on write.
The initial finding/compile run for the C/C++ is fairly quick for me ( lines that start with 'Detecting' ). Now if you mean stuff like CheckSymbolExists ( lines that start with 'Checking' ) those could be speed up with parallel execution. 
I've only skimmed this article, but couldn't you simplify the code significantly and eliminate the need for std::index_sequence by using std::apply to iterate over your tuple?
copy is not evaluation.
sorry for taking your time, it was my mistake when posting this thread.
sorry for taking your time, it was my mistake when posting this thread.
&gt; ( lines that start with 'Detecting' ). It takes a good 4-5 seconds for me on windows with MSVC (infinitely faster on linux of course). And that's with a NVMe SSD. I can't even imagine on rusty platters.
IIRC some of cost on windows is file IO as we currently write a vcxproj file and invoke msbuild. I don't believe there is a way to pipe the file directly to msbuild.
&gt; I always wondered why they can't just make one first in boost ? Maybe they are lazy or boost does not want it... But ideally I agree with you.
They're just stating that those are the most recent version fully supported with the version of GCC redhat is on. Although, RHEL 7 is on 4.8 which supports most (or all, I forget) C++11, that's still before GCC switched to a newer standard by default. They 2 older still maintained versions also are on 4.4 :P
X11 also has CLI-accessible clipboard, though I don't immediately recall the commands.
We are tracking both hana and ranges and we aren't there yet. Some bugs across a few different areas going from memory. 
Cmake is a game changer for C++. Amazing 5 star software!
Concur that I run into the exact same problem. Also NVMe SSD + ryzen.
Wow, what an ugly poll. Just bunch of links(although technically links should be clickable) and expectation that people voting will bother to read 5 papers... LOL 
Yes. With lgpl you only have to release changes to the library, not code that uses the library.
What? No, you’re confusing things.
ok. in front of actual keyboard now. talked to /u/caseycarter to get more detail on range-v3. The remaining blocking bugs for ranges, are no longer expression SFINAE. There are some general bugs in templates and pack expansion that we still need to address, but nothing specific to one of the rows in /u/stl feature tables. no timeline to announce yet, but we track these carefully and really want these too.
&gt; on windows with MSVC Found your problem.
we are working on build tools improvements for 15.7 across all of VS trying to make it a one stop shop. Here are the docs for Build Tools into containers. https://docs.microsoft.com/en-us/visualstudio/install/build-tools-container If you see a bug (ideally test 15.7p1 or the imminent p2 but 15.6 is fine too), please please please send me a developer community link for the report and I will raise its visibility with our build tools team.
Right, but in the MSVC STL `std::lexicographical_compare` is defined in `&lt;xutility&gt;`, not `&lt;algorithm&gt;` or `&lt;tuple&gt;` (although both of these include `&lt;xutility&gt;`).
Update: product code wasn't affected (I can remove the workarounds just fine there). The problem was in my exhaustive test for Class Template Argument Deduction, where I wrote an unusually complicated form of SFINAE (here, without the workaround): template &lt;typename Void, template &lt;typename...&gt; class ClassTemplate, typename... CtorArgs&gt; struct CanDeduceFromHelper : false_type { }; template &lt;template &lt;typename...&gt; class ClassTemplate, typename... CtorArgs&gt; struct CanDeduceFromHelper&lt;void_t&lt;decltype( ClassTemplate(declval&lt;CtorArgs&gt;()...))&gt;, ClassTemplate, CtorArgs...&gt; : true_type { }; template &lt;template &lt;typename...&gt; class ClassTemplate, typename... CtorArgs&gt; constexpr bool CanDeduceFrom = CanDeduceFromHelper&lt; void, ClassTemplate, CtorArgs...&gt;::value; `ClassTemplate(declval&lt;CtorArgs&gt;()...)` is the tricky part that attempts to use CTAD within Expression SFINAE. So I'll reduce and file this, but it's nothing to be concerned about.
Thank you for your response. I didn't yet try it myself, but I read about some issues in one of the recent preview announcement posts on reddit. Sadly I can't find the comments anymore. I'm currently trying to simplify our CI process by moving away from manually created (long running) VMs and hardware installations, so containers would be awesome. I will try to find some time in the next few days and will report issues if I find any (or vote on reports). I really like the recent development with the build tools, it simplifies a lot of work for me!
I feel like the definition of FP itself is a moving target. Lisps are sort of the original FP language, and most lisps have tons of mutable state. They are primarily functional in the sense that everything is an expression, everything is a function call, and they make it very easy to work with passing around functions. Then Haskell sort of replaced Lisp as the "de-facto" FP representative. Now all these other things are associated with FP: strong types (which typically help enforce some kind of mutability), pattern matching, currying. A lot of that crowd barely considers Clojure to be FP even though most default data structures in Clojure are immutable. The conclusion I'm starting to come to is that the term "FP", like the term "OOP", is just more harm than good. There's a collection of features, approaches, and idioms, some of which are often used together, but are often also seen separately. It seems to just obfuscate conversation more than anything and make it easier for people who don't understand details to make themselves sound knowledgeable.
In general it's a good thing to make ill-formed calls (those which will always error) SFINAE out so that other metaprogramming facilities work correctly. I.e., if you have code whose logic is predicated on whether or not a call is valid, static_assert is not sufficient to communicate 'invalid'.
If C++ has to lose those users, then let it be. They don't understand or care for the language's philosophy anyways.
MSBuild itself has pretty miserable startup time, so I would expect that to dwarf the IO time.
I have major regressions that make this preview unusable for me: &gt; type a.cpp template &lt;class T&gt; struct S { using f = void (int); }; &gt; cl /permissive- a.cpp a.cpp a.cpp(4): error C2066: cast to function type is illegal a.cpp(5): note: see reference to class template instantiation 'S&lt;T&gt;' being compiled
Have you tried using Ninja with MSVC? For me, it works like a charm and the initial configure finishes an order of magnitude faster (as well as the main build itself).
It's true, Qt is sort of its own monolithic environment. You've got everything from thread pools to network request objects and xml serialization. 
The {} syntax link is http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0745r0.pdf The poll is wrong.
`std::apply` invokes a callable object with the arguments from the given tuple. This isn't what I'm doing here. I have a *tuple of callables* and a *tuple of arguments* and want to call them point-wise. In a different language this might look something like: zip(converts, storage).map(((conv, storage)) =&gt; conv(storage.get(entity))) Sadly C++ doesn't have those sorts of facilities yet.
Oh man, I'm glad to see someone is working on it. At work we had large amount of infra code written in CMake-as-a-scripting-language (including auto-generated CMake code! (think of test lists)) and we still had to use CMake 2.8.* (in late 2017) because 3.0+ versions were order of magnitude slower at processing all this stuff.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/86esf9/noob_question_how_do_you_keep_track_of_all_the/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You should be able to install newer GCCs by installing newer DTS I think :P
&gt;If you don't need the Qt (very many) features, no reason to use it over wx. This was the other thing I didn't mention about Qt: it's complete vertical integration (cf. QString, QVector, etc.). It's understandable, but certainly marries you to the framework. Thanks for your comments. :)
I think you responded to the wrong comment. I didn't make any derogatory comments about wx on Windows. I just don't need *my* code to run on Windows.
That it exists. I like the signal/slot system, but moc just feels too much like an extra preprocessor. And I really loathe the preprocessor. Admittedly, I've not used it extensively, so it may just be a learning curve I haven't climbed yet.
No no no no that is not what the LGPL say, it says that the user must be able to replace the LGPL part of your application with one of there own. Thus inheriting from an LGPL library makes that "difficult" 
We looked into that. Technically, we use CentOS, not RHEL, and there isn't a true CentOS DTS package. I forget the details, but installing it requires mucking with GPG keys and whatnot and it doesn't fit in with our custom OS packaging setup (we use CentOS as the embedded OS on an appliance).
Not my created issue but things like: https://developercommunity.visualstudio.com/content/problem/167194/cmake-intellisense-not-working-for-newly-added-cpp.html and https://developercommunity.visualstudio.com/content/problem/92374/intellisense-breaks-for-header-files-if-not-includ.html It seems like there's a class of errors that occur when project changes are made that don't get reflected into the intellisense system.
The LGPL says nothing about a modified version of the library provided by the user actually working. There is nothing difficult about inheriting from types provided by a LGPL library.
Oh yea, it does. Then again, so does wx. 
That is unusual. CMake 3.1 included a pretty significant improvement to the parsing engine ( https://cmake.org/cmake/help/v3.3/policy/CMP0053.html ) so if that policy is set to true I wouldn’t have expected a performance hit. 
Adding one more to the pile, I submitted one where there is a couple complicated source file where intelligence just gives up. https://developercommunity.visualstudio.com/content/problem/179645/intellisence-reports-too-many-errors-on-complicate.html
What are the problems? We can potentially fix them if you report them *immediately*.
&gt; wxWidgets is pretty much pure C++ So is Qt, to the extent that C++ itself is pure C++ while also having a preprocessor, or needing a compiler. moc isnt really that much of an issue, it's easily automated, CMake handles it, whatever *other* build system you're using should handle it, it's all really trivial.
I didn't want to make a fuss about it because AFAIK the release isn't `&lt;filesystem&gt;`-compliant, which I wrongly assumed it was after I downloaded the update. So I've really got nothing to report; I'll just have to keep adjusting my code until `&lt;filesystem&gt;` is fully conformant.
Thanks for the refactoring! Your version is much better and I'm a bit annoyed at myself for not figuring it out fist.
&gt; heavily "modern" Here's the example on the Nana website: #include &lt;nana/gui.hpp&gt; #include &lt;nana/gui/widgets/label.hpp&gt; #include &lt;nana/gui/widgets/button.hpp&gt; int main() { using namespace nana; //Define a form. form fm; //Define a label and display a text. label lab{fm, "Hello, &lt;bold blue size=16&gt;Nana C++ Library&lt;/&gt;"}; lab.format(true); //Define a button and answer the click event. button btn{fm, "Quit"}; btn.events().click([&amp;fm]{ fm.close(); }); //Layout management fm.div("vert &lt;&gt;&lt;&lt;&gt;&lt;weight=80% text&gt;&lt;&gt;&gt;&lt;&gt;&lt;weight=24&lt;&gt;&lt;button&gt;&lt;&gt;&gt;&lt;&gt;"); fm["text"]&lt;&lt;lab; fm["button"] &lt;&lt; btn; fm.collocate(); //Show the form fm.show(); //Start to event loop process, it blocks until the form is closed. exec(); } Here's a somewhat equivalent Qt example : #include &lt;QtWidgets/QApplication&gt; #include &lt;QtWidgets/QLabel&gt; #include &lt;QtWidgets/QPushButton&gt; #include &lt;QtWidgets/QFormLayout&gt; int main(int argc, char** argv) { QApplication app{argc, argv}; //Define a form. QWidget fm; //Define a label and display a text. QLabel lab{R"_(Hello, &lt;span style="color: blue; font-weight: bold"&gt;Qt C++ Library&lt;/span&gt;)_", &amp;fm}; //Define a button and answer the click event. QPushButton btn{"Quit", &amp;fm}; btn.connect(&amp;btn, &amp;QPushButton::clicked, [&amp;] { fm.close(); }); //Layout management QVBoxLayout lay{&amp;fm}; lay.addWidget(&amp;lab); lay.addWidget(&amp;btn); //Show the form fm.show(); //Start the event loop process return app.exec(); } is it really that un-modern in comparison ? you have a few more `&amp;` to take but apart from that it's almost identical.
Technically static linking isn't a no go, despite what Qt implies. it's just really annoying and complicated. Qt very much implies it, since they want you to buy a license, but they stay just short of outright lying. See http://www.gnu.org/licenses/gpl-faq.html#LGPLStaticVsDynamic https://stackoverflow.com/questions/10130143/gpl-lgpl-and-static-linking https://softwareengineering.stackexchange.com/questions/312758/does-providing-object-files-satisfy-lgpl-relink-clause Qts own FAQ. https://www1.qt.io/qt-licensing-terms/ relevant passage &gt; In case of static linking of the library, the application itself may no longer be “work that uses the library” and thus become subject to LGPL. It is recommended to either link dynamically, or provide the application source code to the user under LGPL. heavily implies to use dynamic, but doesn't outright forbid static. and this one https://www1.qt.io/faq/#_Toc_3_7 &gt; The LGPL allows you to keep the source code of your application private as long as it is “work that uses” the library. Dynamic linking is usually recommended here. etc https://stackoverflow.com/questions/12654613/static-linking-qt-with-open-source-version/15322678 IANAL but should be possible, albeit annoying difficult, to static link and stay compliant without also becoming LGPL. Probably too much work to be practical, though.
15.7 P3 should contain the completed `&lt;filesystem&gt;`; you'll be able to tell you have it when `yvals.h` mentions it in the list of features.
This is awesome news, very exciting! Nice! &gt; We are now complete with the full implementation of C++11 Expression SFINAE, and have made the corresponding Standard Library changes. Does that mean the value of `__cplusplus` will finally be increased to 2011xx, or what's the plan with that?
http://www.bitsnbites.eu/faster-c-builds/ From Jan 2017 showing 50% of a new llvm/clang build is spent in cmake in notes at end of blog. Be interesting to see how this now would perform with latest cmake.
The preprocessor overhaul is still on the list of things to do, but it won't be done in time for 15.7.
As a favor to you, I've filed VSO#588105 "/permissive- rejects "using f = void (int);" with bogus error C2066: cast to function type is illegal" in our internal database (if you haven't already reported this). Still repros with our current dev build.
You can already query whether an expression may throw with the [`noexcept operator`](http://en.cppreference.com/w/cpp/language/noexcept). I like the idea of saying 'nothing in this function should throw, give me a compiler error if I use throwing stuff', but still having the ability to disable those kind of checks. &gt;I don't want source files to be littered with these annotations How would you do that?
ConvertHelper is stateless and trivial. That solution you've posted is a lot nicer, although I'm a bit concerned about using `std::move` on `callback`—it's moved into the capture so it's only moved once, correct? 
Right, it's only moved once, when the lambda is declared. You could just capture it by reference since `callback` outlives `cb`; that's probably best anyway I suppose, thanks for pointing it out.
probably Bjarne's Design and Evolution of C++?
What is C++ "designed to be"? Even Bjarne Stroustrup admits he can't even say who C++ is designed for. Or, in other words, C++ has (increasingly) been "designed" by anyone who wants to see something enter in the language. Bjarne gave a talk on what he thinks C++ should be, and one of them was about being easier to teach. Which naturally includes a graphics library of some sort. I distrust anyone who claims they know, more than Bjarne (or other longstanding members of the committee), what C++ is designed to be, or who its designed for.
`noexcept operator` just checks the `noexcept`/`throw()` annotations, which have to be explicitly written out after functions unless `= default` is used. I'm talking about letting the compiler automatically mark functions as `noexcept` *by automatically inferring it* as the *default behaviour*, unless the function is explicitly marked with `noexcept(false)`, `noexcept(true, assume it is no matter what the code says)` or `noexcept(true, and check that it is)`. This is so I can try both methods out when writing up the standard library (with a special compiler flag, I suppose): * The C++ way of always being explicit about `noexcept(true)` (except `= default`, which infers it from members and bases). * The inferring way, where the compiler infers it from code as the default behaviour, and allows library authors to override and assert as necessary, and also allows user code to assert it if it wants to: `int main() { ... } static_assert(noexcept(main()))`. &gt; I don't want source files to be littered with these annotations `noexcept` and `pure` are two annotations I expect to have. There might also miscellaneous annotations to retrieve through reflection in the future. Writing annotations after functions might make the source code more noisy than I would like. This could probably be helped by inferring and/or declaring an entire scope with annotations.
Cool! Maybe this can be done under the `/permissive-` mode too? Would fit pretty well I think. Also, it would avoid the hassle of having a new switch and then it would take another few months until CMake adopts this switch (if anyone ever makes a ticket/PR). It took ages (a couple of versions...) to get `CXX_STANDARD 17` to work with VS2017's `/std:c++17`. And I think `CMAKE_CXX_EXTENSIONS OFF` still doesn't have any effect on VS2017 in cmake-3.11.
Can I ask you about your Qt experience? I am learning C++ and wondering if I should dive into using Qt to develop my projects. What are the pros and cons in your experience? Is it something an intermediate programmer can focus on or is it distracting from learning the basics well? 
!remove
OP, A human moderator (u/blelbach) has marked your post for deletion because it is not appropriate for r/cpp. If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/86evrk/why_you_should_really_care_about_the_c/dw52614/,%20was%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Coming from a Scheme background, I view functional programming as interesting but ultimately too limited and inconvenient. I'm glad that it taught me to respect the danger of modifiable state, though. Well IDK about Scheme, but plenty of people use Scala to do "real" programming so... :) 
&gt; I mainly need reflection for (de)serialization. If you do not care about performance consider protobufs :) 
&gt; I fear delays from a quest for perfection. &gt; I fear mission creep. It is almost like he has some experience with WG21. :( Poor Bjarne. Poor us. 
I think we were pretty surprised at how badly this blew stuff up in our testing. We're going to have to start cleaning up a bunch of open source before we can realistically do this. 
 #include &lt;iostream&gt; struct A { static const char * name() { return "global A"; } }; int main() { std::cout &lt;&lt; A::name() &lt;&lt; "\n"; struct A { static const char * name() { return "main A"; } }; std::cout &lt;&lt; A::name() &lt;&lt; "\n"; } This works just as well. No variables, no decltype. It's just shadowing at work
it's a static function: `A::name()`
a using alias would solve this as well no? struct A { ... }; int main(){ using outer_t = A; struct A{ ... }; std::cout &lt;&lt; outer_t::name(); std::cout &lt;&lt; A::name(); return 0; }
I recently tried to install and run Visual Studio 2017 VC++ Built Tools and was blocked by deadlocks/crashes from `mspdbsrv.exe`. I've been doing work to adapt our Linux builds to all be containerized, and I hoped to do similar work for our Windows builds, but `mspdbsrv` wasn't having it. Correct me if I'm wrong, but the link you posted above is regarding "VS Build Tools" (which includes the Windows SDK, MSBuild, and other tools) but this is separate from "Visual C++ Build Tools" (Which includes the compilers, linkers, and standard libraries needed to build C++ specifically). Following the instructions in the linked doc did not give me a Visual C++ installation. I was able to adapt the linked instructions to run the installer to add the Visual C++ workloads and components, but they failed to run when `mspdbsrv` begins to misbehave. Are you aware of any changes/fixes/tweaks made to `mspdbsrv` or the clients thereof that would fix the issues I've seen when running in Windows containers?
This works in the function shadowing case but not when redefining inside a class body e.g. http://cpp.sh/5azx4
Maybe I'm missing something. I do not see how this can be used to preserve the outer scope value when the inner scope is a class body, as in my logging context example. `app` needs to be accessible from `Connector` which needs to be accessible from `self()`. I tried using another struct in the class body [here](http://cpp.sh/2x47) but it picks up the A defined afterwards in the class.
How about `numbers.count(5) &gt; 0` ? Is this what you want?
set::contains: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r1.html
Any word on modules in the IDE?
in VS2015 there was the VC++ Build Tools. Now there is just the Build tools and there are workloads within it. there is a C++ workload that installs our libs, compilers, linker, etc. Can i get any more detail on what you are seeing with mspdbsrv? that's a helper process that is used during C++ compilation to help get the symbols into the PDB.
For the first thing set::count() should work For the second one, if you use Boost, look at boost/range/algorithm/sort.hpp
Not useful in my case. I need to implement existing protocols, not to make a new one. 
You can call static member functions and access static data members via `.` on an instance.
count always has to iterate over the complete set and doesn't stop after finding the first occurrence. It has the simple interface OP wants, but a worse runtime complexity.
Depends on whether you're talking about the `std::set` or the `std::vector`. ;-]
No! This way you sacrifice speed advantages as this will lead towards a time complexity of O(n) whereas a set based ``contains`` method would only require O(n log n) for tree- and O(1) for hash-based sets. 
&gt; In my experience, there is little chance to operate elements in partial range of a container, so using iterators is mostly unnecessary. I've been using algorithms more and more, and partial range operations are very handy in combination with other algorithms like the partitioning algorithms, rotate, or the set algorithms. They're not necessary, but they save you having to create multiple containers.
The STL isn't *pointlessly* wordy. `sort()` taking iterators allows it to sort arbitrary subranges, which it couldn't do if it were a container member function. (Developing the Ranges TS isn't a trivial task even with experts and 20 years of more advanced technology, so you can't just say "just take ranges".) `find()` returning an iterator allows you to access the element if it exists, instead of performing a separate lookup. Even with map's convenience `operator[]` function, I regularly catch people implementing "caches" with 2 or 3 lookups, which is woefully inefficient.
I don't have the details with me at the moment, but I was seeing cl.exe either locking up talking to `mspdbsrv` or failing to write the .pdb files and exiting non-zero and failing the build. I can get more details tomorrow and see what I can find.
Well they are quite similar indeed (to be fair I wasn't following Qt progress for a while, so I missed their modernized update), in any case Qt is a framework with a lot of stuff developed by a company while nana is a lightweight GUI library made by few people (with seemingly same GUI API, at least looking at the examples above). The best thing about nana is the licence and size, Qt for me is always associated with caution when is used in anything other than open source code. Of course nana is not as heavily tested and it's far from "industry standard", but qt has an according price as well either xGPLx or 460$/month per developer.
Small convenience versus eternal growth in size and the need to decide how exactly the convenience should look like (not a fan of x members who do similar thing). Not worth asking for it. Need a `bool contains`? It's some keystrokes away.
http://en.cppreference.com/w/cpp/container/set/count Read the part about complexity. 
&gt; (Developing the Ranges TS isn't a trivial task even with experts and 20 years of more advanced technology, so you can't just say "just take ranges".) Sorry, but I disagre. The ranges TS might be a complex beast but afaik, that was mainly because it does a lot more than "just take ranges"(introducing concepts, projections, fancy return types and what not). Adding a version of the algorithms that takes a range instead of two iterators is a trivial, almost mechanical task that could and imho should have been added to the standard library long ago. 
Mind elaborating what you mean by the last point? Caches?
There is a reason D is not supported by those big companies though. If it was so much better than C++, it would have easily been adopted and supported by those companies. The sad fact is D has very few advantages over C++, has some questionable choices and is still actively developed in its core, which makes it not an attractive option for large scale adoption.
for tree based sets this gives you a time complexity of O(logn) and hash-based sets gives you O(1) with this 
What C++ needs is a central repository of source code in which everyone can add libraries and that libraries are rated by others. This repository should also contain the Standard Library. The C++ commitee can then focus on that, where others can focus on gui, networking, etc. The difference with boost would be that this repository would be official, i.e. supported by the comittee, and they would be stricter guidelines about coding style, documentation style, etc. 
Yes you're right. Thx for correcting me! 😊
That was how Pascal's P-Code was born. Niklaus Wirth only wanted to have it as a portable way to bootstrap Pascal in new platforms. Meaning having a simple interpreter, without much care for performance, execute the P-Code of a self hosted compiler which would then produce the actual Pascal compiler for the new platform. After adapting the backend, of course. But then people started using it directly, instead of doing the full bootstrapping process.
3 year iterations are to slow!
The point being, if everyone ends up building these functions, why aren't they present in STL in the first place? The current STL is too low level for the basic usage, which honestly covers probably some 90% of the use. 
I think most people won't build those functions. In practice, having such syntactic sugar doesn't make development more efficient, because typing is the least of your problems.
I would say that at least 9 times out of 10 (being very conservative here, it's probably much higher than this) people who want to sort a container want to sort the whole thing. I agree with having the ability to sort a sub range of the container, but I really don't like that the STL makes the simple case hard. Why not provide a simple and intuitive member for the incredibly common case and have the more complex but more powerful facility that we have now for the few cases where it's needed. This goes back to the principle that we should make things easy to use correctly, and hard to use incorrectly - which unfortunately I don't think is the case in much of the STL.
While I agree typing being a lesser issue, there's still much to be improved in showing intent with the current, clumsy API: // Determine whether a container contains value 5 // Ideal: if (vector.contains(5)) ... // Current: if (vector.find(5)) != vector.end()) ... // What does "end" have to do with anything here? I remember STL and its use a long time ago and wondering why the .end() didn't actually point to the last item of a container but rather had a special meaning, asymmetric to .begin(). 
Sometimes it feels like a "beginner" package is needed and that it should be standardized but maybe it's a bad idea, it could just be a side thing maybe? Same things for the package manager. Really on Linux you have everything and it's quite easy to install a new lib or whatever (from sources, from rpms/debs..). Maybe it's really an OS problem, not a C++ one.
Couldn't agree more. Interface ergonomics is not something that C++ is good at.
I've been programming since 1985 or so, and I have yet to run into a situation where I want to sort a subrange. Surely an overload that would have taken a container would not have been too much to ask for. And iterators could have been defined so that this code: auto it = cont.find (...); if (it) ... would have been valid, instead of always having to compare against `cont.end()`. It's not major stuff, but it would have saved a lot of typing... 
Something like `map&lt;Key, shared_ptr&lt;Value&gt;&gt;` or with `weak_ptr`. For example, the key could be a filename and the value could be an image texture.
&gt; C++ values explicitness over brevity. Shock reveal - it is possible to do both. &gt; As the saying goes... it's a poor craftsman who blames their tools. ;-) Come now. OP isn't blaming anyone for anything. The issues OP brought up have been well-known for many years; the Ranges TS has been proposed and has a great deal of traction, and [this very use-case](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html#motivation-and-scope) is one of the motivating examples.
I assume PP means code like this: auto i = cache.find(key); if (i == cache.end()) cache[key] = value; The issue is that the programmer is doing the lookup in the table twice when they should be using `i` as a hint to insert and save the second lookup. (I'm not quite sure how that could multiply into _three_ lookups, however.) 
Rushing into things is how we got autoptr and locales. The are good reasons not to rush this.
"It's a trap!" Works perfectly well in the case above - but if you switch to, say, `std::multiset`, `count` is [linear in the number of the elements found](http://en.cppreference.com/w/cpp/container/multiset/count), which means it's `O(n)` (remembering that O() is an upper bound).
You might like the Qt containers: their API is very convenient.
"Let's have everyone reinvent the wheel!" As far as I know, C++ is unique in not having such a method for its collections...
Yes, surely. I'm not implying that .end() should point to the last element in the current implementation - just pointing out that for a new-comer these things feel very arbitrary at first.
End is the understood idiom for "container iterator that doesn't point to anything inside the container". There is some subtle value there... there's a reason iterators don't automagically transform to bool. There's actually a lot of elegance to how it all works... it's just kind of verbose. Nobody loves verbosity, but there are far worse crimes.
you can build a k-d tree sorting subranges of an array with a length of a power of 2. yes, i have done this, as for extremely large trees, pointers took up too much ram and were far too slow.
The expression isn't really about blame. It's about the approach to tooling. Sure, Range TS has a lot of traction. It took a long time to get there though, because of how easy it is to get this stuff wrong.
How about: if(auto inumber = numbers.find(5); inumber != number.end()) { // do something with inumber } and for sort "issue", would could have their own utility namespace with helpers like: namespace utl { template &lt;typename T, typename Allocator template &lt;typename,typename&gt; class Sequence&gt; void sort(Sequence&lt;T,Allocator&gt;&amp; sequence) { sort(std::begin(sequence),std::end(sequence)); } } Or simple just use the Range piping features. 
most of the time - typically with std::map or unordered_map et, if it contains the value you also want the iterator to the key-value pair, hence a simple bool return value is not enough.
Yes, I do know how the STL works, thanks. Just thinking from the PoV of a newcomer.
My toolbox, quite literally, has a plain Phillips screwdriver, a plain flat screwdriver, and a fancier bit driver. The plain drivers are there so I can tackle 90% of screws quickly without configuring a bit. The bit driver is there so I can tackle the remaining hard 10%. It cost me more to buy three screwdrivers, but I'm a serious enough craftsman that I'm willing to invest in my efficiency. I agree with the original poster that we should mirror this thinking in the STL's API.
Why?
So OP would need to somehow use `cpp/experimental/ranges/algorithm/find`?
&gt; It cost me more to buy three screwdrivers, but I'm a serious enough craftsman that I'm willing to invest in my efficiency. Form that perspective, if you think the contains function would really improve your efficiency, it is very little C++ code to write it. &gt; I agree with the original poster that we should mirror this thinking in the STL's API. Yeah, but you're wrong. ;-) [j/k] &gt; Ease of use in the common case is one reason .NET is so popular. I think even .NET developers would tell you that we don't need another .NET. The existing one is a arguably the platform out there most like .NET, and no one else is likely to best it. As always, there are trade-offs involved. Consider what it costs. There's a reason the Range TS has taken so long to come to fruition.
Ignoring the fact that I'd most likely use std:: count instead of find, how is `values.contains()` less explicit than values.find() != values.end(); I'd argue it is the exact opposite. 
I'm trying to speak to that POV. Someone reading the comments might otherwise get the wrong idea.
std::count() is likely to result in more work being done than find. You are testing against the container's iterator. It also makes it easier to figure out an error has been made if the variables have a typeoh.
Sorry, I meant std::set::count. Will fix.
Exactly my thoughts. The counter-argument can be taken to the extremes of "but everything can be built with assembler, RollerCoaster Tycoon is some keystrokes away".
In the context of a set, how is set::contains semantically different from set::count? Is this really just about a method not having the right name?
Auto_ptr was/is part of the std API and its design was rushed so it made bugs that we had to live with for years. You are claiming this is easy, so easy as to be "almost mechanical", that sounds like rushing to me. But if I am wrong and you are right you can easy demonstrate this by writing up a minimal proposal and make an example in one of the many open source compilers.
Every time I've ever used std::sort I've never wanted to sort a subset always the whole data set. I too am surprised there is no simpler version.
Thanks!
&gt; It's about the approach to tooling. Absolutely, and tools are supposed to save you work, and make errors harder. Having to explicitly compare iterators is more work, and it introduces the possibility of comparing iterators from different containers. And yes, I did that myself once, and I've seen several times seen other people do it. It sounds like it's impossible, but before `auto` when we were typing long strings like: typename Foo&lt;Bar, Baz&gt;::Bing::iterator i = a.find(x); if (i == b.end()) { // use i to perform the insertion it was surprisingly easy to miss the single wrong character in all that verbiage.
I think I mostly agree with you. But unlike OOP, I think there’s more direction to the change in meaning in FP; in particular, the way OOP became to mean whatever one wants kind of just happened, and was enforced by lack of proper knowledge by many early Java users. By contrast, the folks behind Haskell knew very well what they were doing and even though they were clearly biased they were on a mission to distill the “essence” of FP, which, in turn, shaped its meaning. Put simply (and somewhat provocatively), the change in meaning of “OOP”, shaped largely by Java in the 90’s, is the result of ignorance. The evolution in meaning of “FP”, shaped largely by Haskell, is the result of research.
Thank you so much. I hadn't noticed the warm cache. Feeling stupid and reactionary!!! Percentages are evil, absolutes are better. cmake took 10s and rest took 10s wouldn't have alarmed me. Especially if a full build took 3600s :)
you don't need ranges TS for this, boost.range is more than enough.
Here's my library of such things if anyone is interested : https://github.com/OSSIA/libossia/blob/v3/OSSIA/ossia/detail/algorithms.hpp
I do, however I found MSVC's `/MP` parallelization to be a *large* deal faster (like, it's 30-40% faster here) than ninja's per-source-file parallelization
Is it still one stream? Also whats the deadline for submitting talks?
Hello world example presenting `using namespace std;`?
I agree, but this is the sort of bad code that PP is talking about.
The point is that the Ranges TS is the best discussion of all these issues, not that you need it to implement `contains`.
I think that comment was aimed more at the sort call. The lack of a "contains" is a reasonable complaint.
Names are important yes. my_set.contains(5) is simply more natural to read and understand than my_set.count(5). The different return type might be relevant in some casesl but those are probably rare. Note that I already said in another part that std::set::count is good enough for me. My post here was about rejecting the claim that using find and compare the result was somehow more explicit than contains.
&gt; error messages that are so terrible that it may scare most people away Template error messages are so horrible, you basically have to guess what's wrong. The first time I tried writing a small C++ project, I quit the language right away and did it in C. (Although there were other reasons as well. The problems of C weren't important in that project.)
That's why it should return (or there should be a convenience function in &lt;algorithm&gt; that returns) an optional reference (so as it is, a `T*` since we didn't get `std::optional&lt;T&amp;&gt;` unfortunately). if(auto inumber = std::find_ref(numbers)) { // do something with *inumber }
Insert is only usable if you already have the value you want to cache - if you want to query the cache and perform an expensive operation otherwise insert might not be feasible. Hell find wouldn't be a great choice either - if you're using a set you'd want something that could return the insertion point if the element was not in the set to save you the 2nd lookup.
The statement should be "make simple things simple and hard things possible."
Devtoolset is the solution to that, and you can run the resulting binaries on vanilla RHEL/CentOS. Honestly this makes RHEL much better then Ubuntu LTS for C++ development
Is the preprocessor compliant?
You don't need boost.range either though. This is sufficient: template&lt;class Range&gt; void sort(Range&amp; r) { std::sort(std::begin(r), std::end(r)); }
https://www.reddit.com/r/cpp/comments/86c0k1/visual_studio_2017_version_157_preview_2_released/dw4sn3o/
There's a chris rock bit about people wanting credit for stuff they're supposed to do. You're supposed to have a compliant compiler. 
I think you're saying that by default functions should be `noexcept`, and it should be a compilation error if the function could possibly throw, and to fix it you would either change the code, or give the function an explicit `noexcept` specification. That could be an interesting way to do things, in C++ with everything being `noexcept(false)` by default there's a lot of code that could be `noexcept` but isn't because simply no one thought about it. Your way would fix that. Cool idea!
&gt; You're supposed to have a compliant compiler. And yet no one does :)
Last time I used .net I had problems finding operations like "lookup an element, and provide me a token that lets me insert the element or examine elements near it if you don't find it". Instead each operation returned a "user friendly" value that was useless beyond that specific operation. The goal of the STL was first and foremost to permit high level code that matched or exceeded the performance of hand-crafted C containers. When the STL was imported into the C++ standard library they didn't go and add a layer of user-friendly operations; they found things that they thought would be tricky to write correctly and efficiently and added them. Whenever possible they split algorithm from container; methods where restricted to cases where the algorithm would be less efficient on this container (for example, list.sort). It is true that contains is missing syntactic sugar; but it is neither hard nor expensive to implement yourself. Adding it seems ok to me, but I personally wouldn't bother with a proposal onky adding it. 
I do most of my dev under linux and just run the occasional windows build when something goes awry but yes, in the general case ninja may be better
There's a significant qualitative difference between what's missing. But I suppose fucking over an industry for 20 years means you can't be bothered with things like standards.
that's disingenuous as fuck.
Universal all syntax: add your own range functions. Oh please add universal call syntax...
sure, but ranges TS wasn't here five years ago. 
&gt;I've been programming since 1985 or so, and I have yet to run into a situation where I want to sort a subrange. Anecdotal evidence is anecdotal. For instance, I use it all the time in Competitive Programming. 
It's better to use free `begin` and `end` though to avoid precluding usage with C arrays.
“One-past-the-end” is pretty intuitive once you see how the concept jibes with how we’re used to working with array indices and pointers (a type of iterators). It also makes working with unordered collections much easier.
[Bjarne Stroustrup](https://en.wikipedia.org/wiki/Bjarne_Stroustrup) original author of C++ suggests the following in the end of chapter 10 of his book [a tour of C++](https://www.bookdepository.com/A-Tour-of-C++-Bjarne-Stroustrup/9780321958310?redirected=true&amp;utm_medium=Google&amp;utm_campaign=Base1&amp;utm_source=DK&amp;utm_content=A-Tour-of-C++&amp;selectCurrency=DKK&amp;w=AF4ZAU9SF7NZX8A80R1L&amp;pdg=pla-309174813079:kwd-309174813079:cmp-805635049:adg-45779905350:crv-191470506394:pid-9780321958310:dev-c&amp;gclid=Cj0KCQjwy9LVBRDOARIsAGqoVnuUZSOjYO56eq7l6O64uYX5KXZaOwYbIx19GkLnmxRVBo83946Z9KgaAj9lEALw_wcB). You define a new namespace called Estd, for extended standard library, to create these functionalities. For your case with sort he proposes: namespace Estd { using namespace std; template&lt;typenameC&gt; void sort(C&amp; c) { sort(c.begin(), c.end()); } template&lt;typename C, typename Pred&gt; void sort(C&amp; c, Pred p) { sort(c.begin(), c.end(), p); } //... } When you need a certain functionality, you find ways to create it.
That one is the most anoying one of all.
This is really neat. If you're interested in exploring perfect hashes/perfect minimal hashes there's actually a tool, [gperf](https://www.gnu.org/software/gperf/), that will generate a pefect hash function at compile time if you have a pre-defined list -- very useful and underrated tool imho. There's also [cmph](http://cmph.sourceforge.net/) that can generate a *minimal* perfect hash at *runtime*, however I've never used it and it may need some wrappers to have a modern C++ feel to it.
what is devtoolset ? 
Instead of void as the return type, shouldn't it be 'Range&amp;' ?
I think that you did: it's right here at the top level of the repo : https://github.com/OSSIA/libossia/blob/v3/LICENSE (LGPLv3 basically)
I see it now. I only want as high as: https://github.com/OSSIA/libossia/tree/v3/OSSIA Which I confused for the top level (I’m on mobile)
&gt; sorting on multiple threads You should use a library for that, either [`std::experimental::parallel::sort`](http://en.cppreference.com/w/cpp/experimental/parallelism/existing) or something like [`tbb::parallel_sort`](https://software.intel.com/en-us/node/506167). &gt; sorting chunks small enough to fit in cache `std::sort` should be optimized to use the CPU cache well. If using `std::sort` on cache-sized chunks, followed by something like `std::merge`, is faster than using `std::sort` on the whole container, then the implementation of `std::sort` that you're using is likely pretty bad. &gt; sorting no more than you need to get the answer How do you use `std::sort` on a subrange for that? I can see how `std::partial_sort` can be useful to get e.g. the top 10 items. But I don't understand how you would use partial `std::sort` for a similar purpose.
Says the guy replying with an unhelpful anecdote...
&gt; CMake is not slower on macOS Well, for my project the cmake configuration time (using the default "Unix Makefiles" generator) is measurably slower on macOS. My MacBook Pro has an i7 CPU (and no SSD) and it takes about 2 seconds to configure my project. On my Linux PC at work which has a slower i5 CPU (and no SSD) it takes only 1.3 seconds. But it actually seems that this slowdown is not caused by CMake. I just tested to build my project on Linux using Clang instead of GCC and now the configure time is also 2 seconds on Linux...
/u/spongo2 Can you say, when 'await' is not seen any more as a keyword but only co_await, potentially under /permissive-?
The lgpl doesn't mean that arbitrary changes by the user don't break things. Also, nothing about inheritance makes it easier for people to break things by changing the library
While the interface isn't as nice, you can use std::reference_wrapper inside of std::option. It's unfortunate cause std::option&lt;T&amp;&gt; would be perfect for checked access, such as in vector::at or find_ref.
It's a backport of modern development tools such as GCC for older RHEL/CentOS versions. For example, /usr/bin/gcc in CentOS 7 is version 4.8.5, but you can get a new and fresh GCC by installing the devtoolset-7 package.
std::partial_sort is the closest I've come, use that for grabbing medians on a moving 1d window.
&gt; And you can ship the resulting binaries and it will run on plain vanilla RHEL installations! How does it doe that? Does it statically link by default?
I would think you'd need to at least ship the associated implementation of libc++ (or whatever glibc's name for it is). That said, it also interferes with our build environment since we use a chroot environment so we can build for CentOS on Ubuntu workstations (don't ask -- I had nothing to do with it).
I ran callgrind on our cmake scripts (which take ~30 seconds to run) and came to a similar conclusion -- a significant amount of time was spent doing unnecessary path operations. Cmake 3.8 (latest at the time) was significantly slower than 3.6 (spending a significant amount of time in ConvertToUnixSlashes), which is one reason we've stuck with 3.6. IIRC things were (perhaps ironically) also worse if you use the ninja generator instead of the makefile generator. 
https://stackoverflow.com/questions/16880830/centos-5-8-with-gcc-4-4-7-links-against-libstdc-6-0-8-how-is-it-possible RHEL4: gcc 3.4(Default) -&gt; 4.1 RHEL5: gcc 4.1 -&gt; 4.4 RHEL6: gcc 4.4 -&gt; devtoolset RHEL7: gcc 4.8 -&gt; devtoolset
You can use gcc 7 easily on Ubuntu 16.04. https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test?field.series_filter=xenial My project uses CentOS 4 + GCC 4.1 for officicial product, but I also compile the project with GCC 7 on Ubuntu 16.04 with additional warning options. Developing environment is relatively not important, because we have Docker, CI stuffs, and so on.
I would be interested in hearing if CMake 3.11 improves over to 3.6. 
Exactly
No. 
You must be exceptionally dense.
Agreed. I wish they had some more "official" packages of newer versions of the toolchains without having to jump through hoops like installing DTS or something. Make newer toolchains part of the main repos. You can build the base OS using whatever toolchain you want, but allow users to have access to newer tools. They don't even have to be the absolute latest and greatest, just ones that are somewhat modern.
As somebody not in this situation, what value is delivered by sticking to a really old version of GCC? Are there bugfixes shipped for versions that old?
You are exceptionally unpleasant.
Not as comfortable but you could also run your toolchain in your version of choice in docker containers
never heard of it before, but it sounds awesome! Where is the catch?
You're making it seem like slowing down would solve things, instead of just giving us more `mersenne_twister_engine&lt;UIntType,w,n,m,r,a,u,d,s,b,t,c,l,f&gt;`s that nobody asked for.
99.99% of the time you shouldn't implement a model. Is tricky and time consuming. I learnt it the hard way as well. 
Sorry but probably never. I assume this is because you need bug fixes from newer versions? We have custom additions we added in our fork: https://github.com/Microsoft/CMake. The IDE is using those. Technically you can replace the CMake.exe at &lt;vs install dir&gt;\Common7\IDE\CommonExtensions\Microsoft\CMake\Cmake\bin, but some of our stuff may not work anymore. In particular Test Explorer integration relies on things we've added. 
Which guy?
Well, this is just a proof of concept. Not sure if I stick with Qts Model/View for things like QDataWidgetMapper or use my own implementation, which I already have written for my CMS. Currently playing around with an edit dialog, which is automatically displaying the members of a fusion adapted struct.
I agree 100% with Bjarne. C++ needs to be easier to teach. Graphics isn't easy to teach at all unless you want a toy, which would be useful to teach basic windowing, not the language. Thus, it has nothing to do with what Bjarne says. Text UIs are much, much easier to reason about, but for some reason many programmers lately don't want to leave their comfort zone. Graphics wouldn't provide an easier way to teach C++ at all.
No the extra parts of glibc is statically linked in so you can use the system standard glibc and don't need to ship anything extra at all
Can you run the resulting binaries using system default glibc though? You can with devtoolset on CentOS
OP
Which scenario? Has worked flawlessly so far for us
What about libraries? One of the very nice things about writing cod for Linux is that you don't have to make all the libraries. Boost, zlib, openssl - they are all readily available. Anyway, this is a nice initiative. Late last year, I had to decline to make a new SDK written in C++14 available for a customer that needed it for redhat. 
There isn't any catch, really. Maybe that it's a bit awkward to use, in the sense that you have to either put it on the path by activating it with `scl enable devtoolset-7 bash`or specify compiler paths directly which are somewhere in `/opt/rh/devtoolset-7/root/bla/somewhere/...`.
no glibc, but libstdc++ (they are two different project with different license.)
Obviously insert only solves the exact problem of find + check then directly insert, which I see inexperience stl users do unnecessarily. For your case you can use lower_bound if it's an ordered set and then use it as a hint which can help. For an unordered set you are kind of screwed by the standard containers unless you have something like a nullable type in the cache, then you can just use insert or operator[] at the start anyway, but that's not usually the case.
RHEL is fully supported until its EOL. So yes.
Yeah, I love clean and simple codes, but the usage of standard library is often in the opposite. Sometimes I have to write my own wrappers to simplified the code - these things should be done by the library. I don't known the background of the committee, so I usually get confused. 
Glad to hear that someone has submitted the suggestion.
Does ubuntu/debian have something like that ? Upgrading gcc compiler on ubuntu have only caused me headaches :( 
So do macro assemblers. Hell, you can build the basics in straight machine code, or hard-wiring a CPU with discrete components.
auto_ptr was a completely new class with new semantics. A wrapper function like template&lt;class R&gt; void sort_range(R&amp; r) { sort(r.begin(), r.end()); } Is pretty straight forward and doesn't have to invent new semantics or make any difficult design decisions. Sure, you can do some bikeshedding about the name and for some algorithms with output ranges you can discuss what exactly the return type should be, but it is really straight forward and people have been writing those wrappers at least for a Decade (and I'd guess for much longer). Regarding your suggestion: why should I write a proposal for this when a superior solution (ranges TS) is (hopefully) about to be merged into c++20. 
They did (thank G-d) add `erase` and `erase_if` that work on containers instead of iterators.
In that case, you do: if (auto itr = map.find(key); itr == map.end()) { map.insert(itr,key,value) } 
Problem with that is that noobs will try to increment the pointer. :) 
Yes I saw it too some months ago... not sure how progressed.
The issue I've found is that frequently if it is present you're going to want to use it. However, this requires a re-traversal if all you have is a bool. I don't see any way to combine the two without making find be less efficient by having it return a larger object containing information about the container the iterator is referring to.
Concepts are merged into c++20
Note that in general, since our version is a strict fork of the master branch, most of the behavior and bug fixes that are in the latest official builds of CMake will be identical. To date, we have been regularly integrating all changes from the master branch and will continue to do so. We also work closely with Kitware and the CMake development OSS community to push as many changes as possible back up into the master branch so as to remain as close as possible in behavior to latest and candidate releases.
std::set and friends already have `count`, though on multiset I suppose that's less efficient than a pure `contains`.
Yes, but standard library is not migrated to Concepts yet.
understood! we aren't declaring victory... just another milestone in the journey.
&gt; "Make simple things simple" is a great solgan (I think by strotroup or Sutter), but I see it applied far too rarely. Just as another point of view I'd say I see it applied far too often. Making a simple thing simpler is great only if it's not also making hard things harder. I run into abstractions and APIs all the time that are like this. Yeah, great, I can accomplish something basic with a one liner but now how I do anything slightly out of the ordinary?
&gt; Even if one rejects that for performance reason, an additional `bool contains()` wouldn't hurt. Actually, too often I've seen naive code being written as: if (collection.contains(e)) { auto value = collection.get(e); // .. } It's simple, it works, it also does 2x as many look-ups as necessary. 
If you want it so desperately, what's wrong with template&lt;typename T&gt; bool contains(T const&amp; container, typename T::const_reference value) { return container.find(value) != container.end(); }
There's no point in using template template parameters, they needlessly restrict the container.
 // first iteration - create simple C like function - use -1 to indicate not found // return true if element found, false otherwise // usage: found(numbers, 5); bool is_found(const std::set&lt;int&gt; &amp; s, int i){ if (numbers.find(i) != number.end()) { //Found the element. return } else { //Not found. return -1; } } // second iteration - generalize for any type - usage is the same template&lt;class T&gt; bool is_found(const std::set&lt;int&gt; &amp; s, const &amp; T i){ ... } // third iteration - generalize for any collection template&lt;class C, class T&gt; bool is_found(const C &amp; s, const &amp; T i){ ... } // forth iteration - exploit collection reflection to eliminate // template parameter and simplify interface template&lt;class C&gt; bool is_found(const C &amp; s, const &amp; C::value_type i){ ... } So you can use is_found(numbers, 5); for any collection which has a member find. Now you have what you want in about a minute. This is a much more efficient usage of your time than asking the C++ committee to do this for you. More effective as well. 
You're not wrong, but it'd be nice if those type of obvious and commonly implemented helper functions were already part of the STL.
Good to know. Thanks for the info.
What's wrong with `std::map::count`?
As a prelude, I would describe the current state of the expected syntax for the standard as "still in flux, may change". There are outstanding papers about changing keywords for the merge of the TS. We support the current text of the standard and the old words as well and don't have a set in stone plan for when or how to 'unsupport' the old behavior. We're trying to make life easy for people who are wanting to use coroutines. This is sort of new territory for us (being ahead of the current standard ;-)) and so we are very open to any feedback on the right way to handle this. What would you like to see?
I agree. Hopefully ranges proposal will be adopted into C++20.
Then let them do that. It's not like you can't just increment the iterator and blow your program up if it moves past the last element.
I started using it because I wanted to do windowed applications when I was in high school. I wasn't a qualified programmer at that time. had learnt PHP for about 2y and C++ for about 1y. I knew the basics like what is a pointer or a class, but didn't knew about templates. I'm bad at finding pros/cons, but if you want to orientate your careers to GUI/mobile/multiplatforms apps, it can be interesting, for gamedev, not really.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0458r1.html
Of course, I can create these tools by myself. My doubt is, since they are common requirements, maybe they should present in the standard library.
&gt; sort(r.begin(), r.end()); if I'm not mistaken, for something really clean and generic you should write: template&lt;class R&gt; void sort_range(R&amp; r) { using namespace std; sort(begin(r), end(r)); }
return type
map&lt;K,V&gt;::const_reference is const pair&lt;K,V&gt;&amp;, where you want to search by const K&amp; instead
 template&lt;typename AssociativeContainer&gt; bool contains(const AssociativeContainer&amp; container, const typename AssociativeContainer::key_type&amp; value) { /* ... */ }
namespace pollution
Complexity. `count` searches the whole container. `contains` would stop when it finds a single element. And this is why `contains` would be useful, so people stop using `count` for what it's not meant to be used for...
Exactly my thought. I simply didn't want someone to start spreading around that you've done it when you guys go to such lengths to make sure you're as open about your conformance as you can be.
&gt; try_emplace mhh... this seems to generated a fairly large amount of additional code: https://godbolt.org/g/nQkTBG 
 &gt; making the 90% case easier. In my experience this kind of designs tend to cause a poor developer to spend 90% of his time to deal with the remaining 10% of the cases.
(thread decoder: Jim is the lead of the team doing CMake and /u/aku911 is a dev on that team) :)
How would adding a few convenience functions makes life for someone more difficult? (Maybe for the standard library maintainer, but we are talking about really simple things here). By the way: If I make 90% of the cases simple, of course I'm spending more of my time (relatively speaking) on the remaining cases.
After looking at it more I really don't think this will work in a class, since unqualified name lookup will always look in the class scope first, and we want to define a class with the same name in the class scope.
My point is that it's easy to create wrappers around STL implementations to create the just the interface you desire. It's much more efficient and effective for each programmer to do this himself rather than have these things hashed out in some committee "process". To get an idea how this can end up way out of hand consider the recent history of expected, optional, outcome, variant and ? All these are very simple ideas which have ended much more complex than necessary and consumed immense personal resources due to the desire that they be over generalized. C++ standard library should be seen as a toolkit rather than a set of solutions. 
I think that this boils down to the fact that the std is written to make a clear separation between the containers and algorithms. When you use an algorithm on a container, you want to be explicit about what you are doing. This also helps for the next person that needs to read your code. Bjarne says this about the separation in the chapter I cited earlier: &gt; Iterators are used to separate the algorithms and the containers. An algorithm operates on its data through iterators and knows nothing about the container in which the elements are stored. Conversely, a container knows nothing about the algorithms operating on its elements; all it does is supply iterators upon request. This model of separation between data and algorithm delivers very general and flexible software. This generality allows the user to specify how they use sort, like you want. If you always sort the container from begin to end, then of course, define it the way you want. The way it is presented in the std allows for more generality. Another point is that making sort act on the container directly makes it potentially ambiguous what you are trying to do. What if sort is defined like this in another loaded namespace using a different predicament. Now future readers of your code need to look it up, making it more difficult to read your code. This can also make some hard to debug runtime errors.
It doesn't need to be a power of 2. (It just becomes slightly more complicated.)
Code would not express intent, and `contains` can maybe be implemented more efficiently for `multimap` etc.
Don't forget to handle is_transparent. Make the second param a separate type than the first. So you can use a `char const *` to lookup a string in a `set&lt;std::string&gt;`. And add some static_asserts or enable_ifs to help make better compiler errors when the user passes in the wrong thing.
&gt; It is true that contains is missing syntactic sugar; but it is neither hard nor expensive to implement yourself. But it isn't simply syntactic sugar. It's avoiding repetition of the container name. The current API allows for using `.end()` from a different container which is likely UB. That the simplest case requires this much care is like having to look down at your screwdriver to make sure you're gripping the handle the right way every time you use it, or risk breaking something.
 template&lt;class Container,class Key&gt; bool contains( Container const&amp; container, Key const&amp; key ) { return container.count( key ); } Maybe?
I guess that's a bit wasteful for the multi* containers.
Am I the only one thinking the Qt models are not that hard to implement? My current project has a few of them, and I admit I had trouble doing a fully arborescent one from QAbstractItemModel, but the other table models were quite easy. 
As long as you keep it confined to the gui it's okish but keep that stuff out your domain model.
Or even just ```` if(numbers.count(5)) { //do stuff if 5 is in the set } else { // do other stuff } ```` since 0 decays to false &amp; 1+ to true.
&gt; Problem with that is that noobs will try to increment the pointer. That's why it would have been nice if we'd gotten proper optional references, but it is what it is.
Forward to LWG for C++20. SF F N A SA 13 8 1 0 0 Generally issues related to the papers can be found in [bugzilla](https://issues.isocpp.org/show_bug.cgi?id=245). Though I am not sure, I suppose it is also possible to file a bug even if you are not in the committee
This is a good use case for uniform call syntax: template&lt;typename T, typename... TYPES&gt; bool contains( const std::vector&lt;T, TYPES...&gt;&amp; container, const T&amp; value ) { return std::find( container.begin(), container.end(), value ) != container.end(); } Usable like so: const auto containsValue = myVector.contains( someValue ); The general idea is that you can extend classes without needing to modify the code or inherit from it. I don't know if it's still being considered though.
I understand that you want to encourage the users to try the new coroutine feature and so you want to keep compatibility. As far as I know, the keywords will not change any more. So you could restrict the number of blocked keywords under the /permissive- flag to co_await and co_yield. Existing code, that uses the keywords yield and await, must not be changed.
You're right about efficiency but I slightly disagree with the intent point. `mp.count(x) &gt; 0` intuitively means `x` occurs in `mp`. It seems pretty obvious to me.
Take a look @ [range-v3 by /u/eric_niebler](https://github.com/ericniebler/range-v3) 
I'd recommend a SFINAE tutorial, it is really brutal to piece together from examples, but the STL is a good treasure trove of you're willing to be immersed. For that question, the answer is it depends. If you only know the subclass at compile time, you'll need inheritance and virtual functions. If it's known at compile time, you may be able to use something called CSTR. It's also super black magic and I'd recommend looking into tutorials. `enable_if` is a gem of SFINAE. Used with intégral type, you can cause template specialization to choose what code to compile, essentially letting you decide the behavior of a class by template specialization. So `my_class&lt;3&gt;` and `my_class&lt;5&gt;` will use different algorithms, all determined at compile time. The only benefits are either a saved vtable dereference (which are actually quite expensive performance wise), and/or a saved switch, and some memory.
type_traits are only useful if the information is known at compile time. Which means you'll have to pass in the derived types. Here's a couple examples, there's a third method of using "if constexpr" which is a nice way to clean-up some of these. They don't work in all circumstances, but I've used all 3 methods in various projects to ensure type safety/reduce code duplication. [Godbolt.org example](https://godbolt.org/g/EVPYHP) #include &lt;type_traits&gt; struct BaseType{}; struct DerivedType1 : BaseType {}; struct DerivedType2 : BaseType {}; struct OtherType{}; // Use SFINAE to remove this function from the possible overload list if the condition is not met. template&lt;typename T&gt; std::enable_if_t&lt;std::is_base_of_v&lt;BaseType, T&gt;&gt; MyAwesomeFunctionSFINAE(const T&amp;); // Use static_assert to trigger a compile error when you use the wrong type. template&lt;typename T&gt; void MyAwesomeFunctionStaticAssert(const T&amp;) { static_assert(std::is_base_of_v&lt;BaseType,T&gt;, "T must derive from BaseType!"); } int main(void) { #if 1 MyAwesomeFunctionSFINAE(BaseType{}); MyAwesomeFunctionSFINAE(DerivedType1{}); MyAwesomeFunctionSFINAE(DerivedType2{}); // Produces: error C2672: 'MyAwesomeFunctionSFINAE': no matching overloaded function found MyAwesomeFunctionSFINAE(OtherType{}); #else MyAwesomeFunctionStaticAssert(BaseType{}); MyAwesomeFunctionStaticAssert(DerivedType1{}); MyAwesomeFunctionStaticAssert(DerivedType2{}); // Produces: error C2338: T must derive from BaseType! MyAwesomeFunctionStaticAssert(OtherType{}); #endif return 0; }
Please look up the meaning of the word "rudimentary". It's not what you think it is.
It's like the argument of `container.empty()` vs `container.size() == 0`. The second has the same behavior, but the first is more direct.
Yeah, but why on earth does every project and every application out there needs to write its own convenience functions, when the STL could just provide it to everyone? And probably with a lot less bugs and better performance. I love the power and flexibility for the difficult 10%, but I don't want to waste my time writing stuff for the bread and butter 90%. 
It's obviously for simple exposition purposes - in this mode it would require various overloads et al - so no need to get your panties in a twist.
devtoolset-7 also provides newer versions of lots of supporting debug and performance tools like gdb. They (RH or Centos) also provide containerised versions of the build tools and the performance tools. There is also a tech preview of the llvm-toolset, admittedly at clang v4 but still able to build those compatible binaries. Note that you want to build using a host that is lower or same version as your minimum target version. e.g. toolset-7 on host centos v6.7 will create bins compatible with 6.7, 6.9 and 7.x If your host is say centos 7.2 toolset-7 builds are only guaranteed to be compatible with v7.2+ targets. Redhat's documentation is really good (and you can even get a free developer login to access more resources). Also note that Centos provides similar options to RHEL. The only downside is I don't think you can use the new ABI variant of CXX LIB as the ABI isn't compatible with older compilers like the default Centos gcc 4 Not really a problem as you can still use the C++11/14/17 features, just a few items are incompatible (such as list::size() still being O(n) and not const time, or strings still being COW)
Not sure if shorter release cycle would actually solve anything.
Languages like Java or C# came much later than C++ and have yet managed to provide a huge library for almost all daily use cases. And we are still waiting for basic stuff like convenient file I/O and networking.
This is an extremely bad solution, since it does not carry the intent easily. Even clang-tidy has tools that automatically convert if (list.size() ==0) into if (list.empty()). Now, the count() case is just as bad. std::contains is missing - it is as simple as that. Period ;)
I disagree. Common convenience functions should be provided by the library, because doing it right in one place is much more efficient than everyone invents it again.
See also [this discussion from two years ago](https://www.reddit.com/r/cpp/comments/31167m/c17s_stl_what_do_you_want_it_to_have/cpxmyj1/).
&gt; Somebody recently asked about it here [Very recently](https://www.reddit.com/r/cpp/comments/86icdm/stl_containers_and_algorithms_are_not_convenient/)
std::binary_search() if it's a sorted vector. std::find() or std::any_of() if not.
FYI I think the freestanding proposal is a great idea. Its value lies especially in making WG21 think about just how costly some of their "zero cost abstractions" are. I like the others get a bit annoyed when you advocate against virtual destructors etc - I like the others think that a fault of the toolset implementation - but most of the arguments you make are bang on the money. Please do remember that many won't say that in public, but think it in private. Rapperswil I think will have lots of raw meat for you and the embedded crowd. I won't say more until I know for sure, but I think we may start to try tackling C++ exceptions at Rapperswil, getting them deterministic and without table bloat. We'll see how it goes. I'll also be starting the ball rolling on getting (R)DMA supported in the C++ standard library. That's a long and tortuous road, but we'll get there eventually. 
with c++17 that could be if (auto inum = numbers.find(5); inum != numbers.end()) { // do stuff } 
What do you mean by that? 
It has to visit every item of the collection instead of stopping at the first matching item.
I assume they mean that you can write a non-member `contains(container, value)` but call it like `container.contains(value)`.
No, it can by definition only return 1 or 0. It stops on the first matching element.
It isn't about teaching graphics. It's about being able to teach with graphics. Totally different goals. Like the presence of iostreams isn't to teach about text processing. It's there so that you can make something reasonably quick. And it isn't actually about teaching C++, but about programming, of which C++ is one language. I think you've got this whole thing backwards.
Interesting. Turn a lot of code into looking like javascript probably that way.
Little late to the party, but the STL is actually REALLY good for generic code. The void function(InputIterator first, InputIterator last) paradigm seems excessive, but I can apply to a subset of a container, i.e, sorting the first half of a container. It also works with every type of container regardless of iterator traits, and `std::algorithm` uses SFINAE to select the best algorithms, so I can change from `vector` to `forward_list` and the behaviour of the sort remains unmodified. 
Yeah, I think it would let you do some interesting things and clean up some other things, but I don't think it's going to happen. Nightmare for existing code, basically. There is/are proposal(s) for it (I think it might be "unified" instead of "universal"?) along with a substantial amount of discussion about what to do and what the implications would be.
Or C# style extension methods
I stand corrected.
I don't see the point of contains. A better solution to me would be something that gets the iterator if it exists or returns something that converts to false if not there. Then we could do... if (auto maybe_it = v.get_if_exists(value); maybe_it) { // do stuff }
const auto&amp; variable = why_dont_you_use_reference;
Could just specialize it for bool. But what are its other problems? I am a little better than a decently college trained C++ guy so not a lot of real world experience here. 
`vector&lt;bool&gt;` "stores" bits instead of bools, so you can't get a real pointer or reference to one of its elements. Its iterators give proxy references.
If a guy needs a true, then just make it return true false, anyway, who would call a function like "get_if_exists" on a vector of bools? If someone needs a pointer to a bool, then they might as well just make it a vector of integers or something. But again, what are the other problems with this strategy?
Bring on your b'ar!
The area where `vector&lt;bool&gt;` typically causes problems is generic code, where you expect it to work for any sequence.
Bool could be specialized to return a proxy just like it is now among other solutions. Why are you ignoring my question?
I think it illustrates both points, or both sides: - On the one hand, if you want to do it _really_ right, it is hard, so the standard should do it. - On the other, you can write something "good enough" quickly and easily, possibly easier than getting it standardized, and easier than looking it up. (But then do you end up with multiple copies of it in your codebase(s)? At what point does your version become more effort than the standard version?)
Ah, I thought you were talking about `vector&lt;bool&gt;`'s problems at first. Anyway, it could, at the cost of a fair bit of extra code and documentation for one special case, although to be fair, `vector&lt;bool&gt;` already does that. Taking `vector&lt;bool&gt;` out of the picture, it won't work for any other similar iterators where you can't get a pointer to an element unless they all specialize it as well. Granted, there aren't too many of those floating around. You could imagine an iterator that does work to produce an element without actually taking on the cost of storing it. This could be an alternative stream iterator or something like a generator that lazily yields values with the expectancy that the consumer is responsible for storing them if needed. Having the type define its own iterator allows for this kind of weirdness to be isolated to the iterator implementation, with outside code going through that interface. Returning a pointer circumvents that. It also prohibits the implementation from being able to add debug checks that the result is valid when dereferencing it (e.g., an implementation could mark an iterator as invalidated and give a nice, clear error when it's used afterward). These debug checks are one reason implementations have for making `std::vector&lt;T&gt;::iterator` a custom type instead of a pointer. Now I wouldn't necessarily be against an iterator being contextually convertible to `bool`. It solves the above problems without requiring an explicit `end()` comparison. I'd have to think more about whether it imposes any unforeseen requirements that would negatively affect some iterators. Overall, it seems easier to return `optional&lt;reference_type&gt;` and call it a day except for the fact that `std::optional` doesn't support references.
&gt; I assume this is because you need bug fixes from newer versions? Yes, particulary the `FindBoost` fixes in 3.11. Though I'm quite fine with VS's CMake lagging behind because I'm using preview and new updates come often. It's when using RTM that the release schedule could potentially miss a [nearing] CMake release and it could take a while for the next update. I just have some quick questions if you have the time. Are you using server mode for the VS-specific integration? Are you planning on generalizing them and pushing them upstream?
&gt; We also work closely with Kitware and the CMake development OSS community to push as many changes as possible back up into the master branch so as to remain as close as possible in behavior to latest and candidate releases. I'm glad to hear this! Also, are you considering having preview CMake releases for VS Preview? Thanks for working on CMake for VS /u/jimgries and /u/aku911!
Wouldn't overloading `iterator.operator bool()` be sufficient? 
What is CSTR? Googling only yields results about `std::string::c_str` or C style strings.
Shoot, my bad. It's CRTP, the Curiously Recurring Template Pattern.
Ahh, okay. That makes much more sense
Is there a possibility to enable devtoolset globally on your machine?
Note that a version of std::contains that is based on std::optional would work: template &lt;typename T&gt; std::optional&lt;decltype(T::iterator) contains(...) This way, if std::contains(container, value) would work just like getting the iterator.
If UFCS is added to C++, it would allow calling member functions like free functions, not the other way around.
Close but not quite the same. For instance, `std::forward_list` has an O(n) `size` function, and most other containers at least have a `size` function that is more complicated than their `empty` function. 
With Ubuntu, you upgrade to the latest non LTS version. With Debian, you upgrade to testing. The whole point of Debian Stable / Ubuntu LTS / RHEL is that you trade having the latest software and libraries for (hopefully) greater stability since the older stuff is battle tested. 
Most of us are _already_ okay with calling it `find`... &gt;_&gt;
He isn't on the committee. Not sure why you are asking him.
Possibly yes. My point mostly is that these kind of solutios should be taken into account to finally pick the best one :)
It’s tricky, but class scopes can only be open once, while namespace scope can be edited freely. The possibilities with statically enhancing class interfaces is intriguing. Swift has class extensions for the same purpose. There is a lot to talk about, but consistency and expandibility could be enhanced with unified call syntax. We’ll see...
We invented (and standardized) programming languages to improve developer productivity through ease of use. We could apply the same rationale to library interfaces.
But they'll never need to trim their nails again!
It's more that the freestanding proposal demonstrates that there is an "essential" language and standard library, and all the other stuff. In my opinion, the essential stuff ought to be completely separated from all the other stuff, and used as the foundation stone for future C++ evolution. All the other stuff should be marked legacy, not deprecated, just no longer being worked upon. But then I'm a strong advocate in favour of new STL containers which fix many of the problems in the existing ones, in particular the rampant non-determinism. *Amortised* complexity guarantees is so 1990s. I want *absolute* complexity guarantees. I think C++ needs to gain that if it is to remain relevant in a world full of Rust et al. C++ needs to move much closer to the metal.
I don't think "Estd" is the simplification I'm hoping for, as then I'll be looking up which namepace the function I want was arbitrarily crammed into.
&gt; HPX (High Performance ParalleX) is a general purpose C++ runtime system for parallel and distributed applications of any scale. It strives to provide a unified programming model which transparently utilizes the available resources to achieve unprecedented levels of scalability. This library strictly adheres to the C++11 Standard and leverages the Boost C++ Libraries which makes HPX easy to use, highly optimized, and very portable. HPX is developed for conventional architectures including Linux-based systems, Windows, Mac, and the BlueGene/Q, as well as accelerators such as the Xeon Phi.
Something like [flat_set&lt;T&gt;](https://codesearch.chromium.org/chromium/src/base/containers/flat_set.h) is super useful if you wanted a sorted vector of unique elements.
I'm surprised to hear that a gcc 4.4 -&gt; 4.8 migration would take hundreds of hours of programmer time. A ton of the warts in C++ today exist because of the hoops the standard folks have jumped through to maintain compatibility with C++98 and earlier. Can you give us an example of a 4.4 -&gt; 4.8 change that's so difficult to fix? 
Exactly. Because if you have some variable like that you either have to "get it" out by doing that call chain any of the alternatives are just as verbose: add a method on my_class that does the contains, add a method on what ever my_ function() re turns that does contains, make a local reference to my_variable_name so you don't have to repeat the call. None of those are "nice" solutions. They're what we're currently stuck with but it's not what's nicest to use.
I've gone down this path last year and there is a catch with linking libraries and security practice. I'll leave someone else to comment on it as I didn't dig into the specifics.
https://www.youtube.com/watch?v=YQs6IC-vgmo But this question belongs perhaps more to /r/cpp_questions
As long as you can stick with Visual Studio just do so. There's no need to learn a meta build system like CMake at the same time as you are not familiar with C++ and its ecosystem. You may want to follow Jason Turner's recent YouTube series on getting started with C++ using Visual Studio.
Unpopular opinion: let visual studio handle it for you. Using external libraries will be a pain anyway, but as long as you don't need them, let VS take care of the build. When building external libraries, make sure to install all of them under a common prefix (e.g. `c:\ExtLibs`) and set your project properties ("Additional include directories", "Additional library directories") to `c:\ExtLibs\{include,lib}`). The rest should happen automagically. If linking with DLLs, in debugging properties also put `PATH=`c:\ExtLibs\bin` to "Environment" and turn ON "Merge environment". That way the debugger will find the installed DLLs and your program will run correctly. Also a tip: some builds will install DLLs in `lib` instead of `bin`. Copy them manually to `bin`.
The easy rule of thumb is never use std list. Except when you need iterator stability and insert in the middle from saved iterators way more often than any other operation. Oh and if elements are extremely large list gets less worse. But really, never covers 99.9% of cases, and the remainong 0.1% can be modified to use vector pretty decently.
Short answer is almost always never. If your C++ type aliasing and namespacing is perfect, you should be able to compare the performance of the two very easily. 
Yes I agree that it's probably best to start learning C++ that way before trying to learn CMake. Bonus points for vcpkg which not only makes the whole thing nearly painless (as long as the lib is well integrated though) but it also transitions well to a CMake project later anyway.
Just to clear up a misconception that you may have since you are new to C++, you definitely don't need to know `cmake` to understand code not written by you. You will (may) need to understand some aspects of it to include (headers) and link to other CMake enabled projects and/or link to prebuilt binaries. As much as CMake is appreciated by the `C++` community (myself included) as a build system that handles many edge cases for cross-platform development, it is a incredibly high learning curve and is not suited for beginners.
Getting dependencies is more or less the same for everything. There's only a few ways to do it. 1) If the dependency/library has a supported find_package module, you use `find_package(Depname 1.2.3.4 REQUIRED)` 2) If it doesn't have a find_package module, you can pull &amp; build if for them find_package(Depname 1.2.3.4 QUIET) IF(NOT Depname_FOUND) ExternalProject_Add(Depname # Project-specific stuff here # Ex: A URL &amp; build commands ) ENDIF() 3) You can not handle a missing dependency, instead forcing the person building it to handle it. Just make sure to document the dependency. find_path(_SOMELIB_INCLUDE_DIR NAMES "somelib.hpp" ) find_library(_SOMELIB_LIBRARIES NAMES "example" "libexample" "libexample-3.0" ) IF(NOT _SOMELIB_INCLUDE_DIR OR NOT _SOMELIBLIBRARIES) message(FATAL_ERROR "Couldn't find SOMELIB dependency!") ENDIF() Of course there's more literal ways like envoking `curl` and manually running build commands, but that should probably be avoided.
To add on the things that the others wrote: For many of the cases where a list is better than a vector, `std::vector&lt;std::unique_ptr&lt;T&gt;&gt;` might still be a better solution. While it has indirections too, at least the underlying array can be accessed efficiently.
Imagine writing a malloc-like class. Doing this with vector compared to list is challenging I think.
std::vector for almost all cases (as it is more cache friendly and has pre-allocated space). However std::list is useful when you need to a lot of inserts / deletions on random index positions.
Looks like the proposal was changed in response to feedback. I'm still hoping for something like that though, maybe something like C#'s extension syntax.
Growing a large vector can have a big performance cost from a certain stage. A list does not have this problem. Hence it depends on what is your performance requirements for read-access.
Algorithmically speaking, the only advantage you get from using a linked list vs an array is O(1) insertion and deletion at any position vs O(N) for an array, assuming that you have a pointer to that position. If you don't have the pointer, any search in a linked list, whether by index or by value, is O(N), in which case there is no advantage at all. The worst thing about linked lists is that you lose spatial locality which will affect cache hit rate due to both higher overhead per element and non-adjacent memory locations, slowing down your program even for the same problem size.
Excellent series, even though you don't necessarily need all the tooling for just starting out. Here's the link to the first episode: https://youtu.be/zMrP8heIz3g
I understand; I just meant the fact that random-access itself is O(N) is a pertinent, missing detail.
Ah okay thank you, you made the whole thing less scary for me 
I clarified it a bit, the gain is that it doesn't need to copy all the elements again to new memory location like std::vector does (so it avoids lots relocations). This relocations can have a greater performance impact than the O(N) access.
Ugh I’ve been using c++ my whole career on mobile and desktop platforms. Just learn C++ and save learning any cross platform build system for when the time comes. However, you will need to understand how native applications are compiled and linked together, so learn that as you go with visual studio. When the time comes for you to build on another platform, hopefully you’ll understand what you’re trying to do (which libraries your linking against, what compiler flags you’re using for your code, how to setup include directories etc.) and you can just figure out how to do what you want, on the new system like CMake or Makefiles or whatever you’re using. Good luck, you have enough to focus on with just C++. Don’t waste time learning a build system until you need one.
I used Wx long time ago in a internal project, and i don't have good memories about that. The worst thing is the very poor documentation and the "layout sizers"(they are tricky/awful to use if compared to Qt, for instance). Today i use Qt most of time, and when i need a simple GUI with no dependencies on Windows, i just wrap WinApi in classes.
The iterator itself also needs to carry the information needed for the operator to give valid results. The operator you speak of is usually referred to as “behavior in bool context” or somesuch. Essentially: how does it act when you put it where a bool is expected. 
One day... One day I'll get to write something using something as awesome as this.
For SG14, look at the [public forum](https://groups.google.com/a/isocpp.org/forum/#!forum/sg14) to find out how to join the conference calls. The details for the April call are not up yet, but we have traditionally had calls on the second Wednesday of each month. For wg21, there isn't an agreed upon way to teleconference in.
This would make sense if the language allowed an easy way to extend std::set without wrapping it :) Go go standards committee!
This isn't about forcing bad std lib code to behave. This categorizes the existing library into what is appropriate for kernel / embedded environments and what isn't. The categorization isn't obvious for most people, myself included. My expectation is that very little of the inner implementations of functions will change if this proposal gets adopted and implemented. There would be a maze of #ifdefs (or equivalent) that would need to get added though. Is it obvious that string_view has a compile time dependency on std::string? Is it obvious that stable_sort can use the heap? Is it obvious that atoi relies on thread local storage and locales? I will claim that while it may not be surprising, it certainly isn't obvious.
The one use case for std::list I've found is for maintaining an LRU cache: lru_cache.splice(lru_cache.begin(), lru_cache, iter); ... performed in constant time. You have to pair it with a map of some kind if you want searchability but the simplicity is undeniable. 
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/86u0x0/starting_c_build_system_scares_me/dw81hsv/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/86u2v5/what_is_a_good_rule_of_thumb_on_when_to_use/dw81j12/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; you can find docs everywhere But you'll have to make sure those docs use the good modern CMake practices...
I actually laughed a bit after I wrote it too haha. 
You can use `std::is_base_of` or `std::is convertible_to` to trigger SFINAE: `std::enable_if_t&lt;std::is_same&lt;MyDerivedType, decltype(instance)&gt;::value, void&gt;` 
Use `std::set::count()` as advised by Scott Meyers in `Effective STL`. http://en.cppreference.com/w/cpp/container/set/count A `sort()` function with iterators allows one to sort either the whole container or only a part of the container. Having the `sort()` method which takes just a container means you will also have to provide the version with iterators to handle the partial use-case.
Thanks for your continuing work on this! I feel like HPX is playing a key role in leading C++ to better places.
Well, several of these pages are dead. But I'll try.
&gt; it's also super black magic nah, it's really not. CRTP just means that you pass your type as a template argument to your parent class.
Cool stuff, should be implemented in stdlib or as a Boost algorithm.
Add a function on my_class called `has_employee` or whatever the meaning is behind the "contains". That _is_ a nice solution. But yes, it would be nice if that called a std::contains of some kind.
Pretty sure this is [`std::set_intersection`](http://en.cppreference.com/w/cpp/algorithm/set_intersection), in any sane STL implementation.
&gt; Add support for json property maps (std::map&lt;std::string, T&gt; enhancement #13 That's pretty awesome! Though when I firs saw this I was thinking it was a C++ REST server, not client. Any reccomendations on how **not** to handle making a rest API server in C++?
You've got to remember that most of this code was originally written 1994 to 1996. It's very old and riddled with unfortunate choices as people didn't know better back then. Most of the work in a compiler upgrade goes on warnings fixes. In a 2M line codebase, each compiler upgrade makes thousands of new warnings, and they need to each be examined and fixed. There was a problem with the parser, 4.8's parser is much stricter. Code had to be refactored, the original was syntactically wrong. There are increasing signs of UB causing problems under optimisation, the code base is utterly riddled with dangerous UB, unsurprising as it was written when no ISO standard existed. So none of these is due to ISO, rather it's just a very old code base originally written for Visual C++ in the early 90s, then ported to Solaris's not great compiler, then much later ported to Linux with GCC 2.96, then GCC 3.4, then GCC 4.4 and now GCC 4.8. The only good thing about the age is that this code base is pre-STL, so we're immune to changes to the standard library.
The usage of the heap is a big one for me. Like you said in your post, many people avoid using the heap, so I write all my code to ensure there are no heap allocations (memory fragmentation is a big one for me), so instead it's all done on the stack with worst case sizes buffers, in addition to copious amounts of bounds checking. I know I can provide custom allocators to various things, but the amount of work that involves and maintenance is larger than just using the stack for everything I feel, not to mention they are not trivial from what I've seen. This is why I tend to shy away from a decent amount of newer c++ features, I can't say with certainty that they do not use heap allocations. And even if I can, good luck getting that information across to the next developer who mainly did C and then is hit not only with C++, but having no clue what uses the heap.
You can do, but you shouldn't since it would effectively replace the system copies of the tools it replaces, and that might have some negative results. The point of it is that it's noninvasive and you can use the resulting builds on systems without it installed. Just source the `enable` script and you're done. You can do this in your user shell configuration if you want to.
This is an amazing writeup, thank you! I wish there was an ability to skype/google hangouts/etc in to view it live. Heck, I would be totally willing to pay a "participation fee" if that meant helping get this set up and in the long run having more people participate in this. Lastly, I am absalutly in favor of this. Adding to the standard the information and gurantee that such and such functionality can be used without an OS/Heap would be very helpful. Right now it's a guessing game.
One of the long-standing issues I've encountered with Jenkins or other CI systems is that if you have multiple concurrent jobs, there's only one instance of `mspdbsrv` shared between them. When the outstanding processes for this job are killed during job cleanup, all the other jobs using that `mspdbsrv` instance are going to fail horribly. Ideally, `mspdbsrv` should be started on a per-job basis, or the build tools should be able to cope with it being killed, and transparently start up a new instance without failing the build.
The binary search method is almost certainly bottlenecked on memory access latency. You can overlap memory accesses if you do parallel binary searches to hide latency; this is particularly true for early on in the search where half of your values will likely go to the same place in the larger vector.
I've played around with this a bit after watching a cppcon talk about it. The async promise interface is way nicer than what's in the standard, parallel algorithms, and more. Bit of a learning curve, though. Felt like the documentation was missing a lot.
I agree on the should part :) substr can throw out_of_range, and out_of_range has a string constructor.
I know that usually GCC would link against newer version of libc and libcc, but the redhat magic devtoolset scripts make it link against the old (system) libraries
It's a bit of a pain to deal with. Installing gcc-7 backport onto 14.04 or 16.04 updates libstdc++, so deploying the resulting binary onto another machine can be a bit explodey. Especially if you are trying to mix C++ libraries built with pre-C++-11 on 14.04. ::sigh:: That said, they way I am handling it is to keep some 14.04 machines with the stock gcc-4 installed, and some with gcc-7 installed, and the CI system dispatches builds to both machines where we want to keep compatibility with the stock compiler (or not, if we don't.) They get built in parallel. Then I have a script that we run that will basically use ldd to look for all libs that a binary depends on and include them in the archive that we install on other machines, including the newer libstdc++ that got installed with gcc-7. Then a different script sets up wrapper scripts that set LD_LIBRARY_PATH for all the binaries in a package. (If you set rpath to point to a private libs dir, you can skip depending on LD_LIBRARY_PATH to find it at run time.) You can also just build static binaries with no runtime dependencies, if that's your jam.
It looks like this is another library that uses Asio, but doesn't actually understand how to build something extensibly on top of Asio. The author could probably stand to read [this paper](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3747.pdf). Looks like it's tightly coupled to using real, operating system sockets, and real timers, so how can I integrate this into something I actually want to test? More importantly how is this actually effectively tested with decent coverage? Lastly [Beast](http://www.boost.org/doc/libs/1_66_0/libs/beast/doc/html/index.html) exists, why is this rolling its own HTTP parsing?
std::set_intersection exists and works for any sorted containers.
Qt has nice separation of UI and logic.
win32 api has that too . even more so with its resource files. he's a student, apparently uses windows and visual studio. why make it harder?
For simplicity, he might as well use C#.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/86ym62/gui_on_c/dw8xgqf/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
When I started this project in march 2016, I was not aware of Beast. I just had 2 - 3 weeks to make a working implementation for a commercial project - on the side of other work, so I kept the complexity low and chose the architecture most suited for the use-cases at hand. I had recently implemented a handful of servers (HTTP, FTP, DNS, SOCKS5) using asio coroutines, and really liked that approach. So I chose what I was comfortable with, that I knew well, and that I could test reasonable well within the time-frame of the project. Today the project is in relatively good shape. I will consider re-factoring it into a more generic architecture - and I will definitely look closer at Beast. However, adaption to Beast depends strongly on when Beast will implement HTTP 2. Some popular REST API's today require HTTP 2 (Apple APN did the last time I used it), and this is a very important upcoming feature for restc-cpp. 
Does anything in the specifications of std::set_intersection prevent this implementation?
I don't know for sure, but it does not seem so. I think the stdlib can enable these implementations for the special cases when they work, and use less specialized ones otherwise.
I'd you don't, why are your using c++?
As the article shows, the std implementation is slower than the one based on binary search for sets which differ a lot in size. This idea even works without SIMD. About SIMD, yes and yes.
Honestly, I think this syntax is a step backwards readability wise. I understand the advantages in terms of scoping, but I find two separate statements much easier to read.
Yeah, I agree, but at the same time, the alternative is { /// create scope artifically initialize var; if (var != end) { /// do stuff } } /// terminate artificial scope Really, most people don't need the scoping, but when you do, creating an artificial scope isn't much better because that opening { kinda just comes out of the blue. You can also do it with a do { ... } while (0) or a if (1) { ... }, but these are even worse because they don't express what you are actually trying to do and they leave you even more confused as a noob.
Yes - to be specific, it breaks the [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter). When I first read about it I thought it was pedantic but further experience showed me that breaking this rule is a disproportionate source of bugs...
But if you one day switch to `std::multimap` or some other container, you might get a nasty surprise...
What does this make a REST library instead of just another HTTP library? I have not seen anything related towards HATEOAS... but perhaps I have not looked carefully enough? 
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 100.0% out of the 18 submissions from /u/yoyogirl140 appear to be for Udemy affiliate links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Good bot
My experience with WPF has been uniformly negative; I'm told WinForms is better, though I've never used it myself.
Restc-cpp was designed to make it simple to consume REST API's. The fact that it includes a HTTP implementation at all was that I could not find a suitable HTTP client library at the time the project was started. HATEOAS I have not heard about before. What benefits would it bring to implement HATEOAS in restc-cpp?
true, but then again he asked the question in the CPP forum so I assume it will have to be a CPP project. If not , yeah, c# is easier to deal with.
Does that really need /s?
I don't know if you can find someone that has the time to work on a collab project but I can send you some really good exercises from my college. They start from basic and easy to complicated and hard.
This isn't C++ specific, but this GitHub Project has a bunch of projects ranging in difficulty. Since you program daily already, just solve the problems in C++.
+ pick an interesting, but not too popular project on Github + use a static analyzer (for example cppcheck + clang-tidy) + read through every warning the static analyzer gives + some of the warnings might be obvious errors (memory leaks, null pointer dereferences): fix them, submit a pull request + some might be the result of design trade offs/third party libs - understand them In the end, you are going to learn about c++, bug fixing and software design.
[OpenMW](http://forum.openmw.org/) http://wiki.openmw.org/index.php?title=Contribution_Wanted
Sure! I'd love this. PM me
Done.
I'm willing to [help someone on their project](http://webEbenezer.net/about.html) if we use [my software](https://github.com/Ebenezer-group/onwards) as part of the project. 
Can you please pM me too?
me too? 
If you can PM as well I would greatly appreciate it. Thanks! 
I wasn't able to get it compiling but I will say OpenMW has some of the better docs out there so this could be an interesting way to get involved. It's a Morrowind open source clone.
Me too, please...
Me too please!
And also support and enhance some existing open source project. This is great idea.
Implement your own version of `std::vector`
I'm willing to [help someone on their project](http://webEbenezer.net/about.html) if we use [my software](https://github.com/Ebenezer-group/onwards) as part of the project. 
Me too please
Here are the exercises for everyone to download. I currently have 3 because im translating them to English from my native language. Feel free to message me if there are any misunferstandings or problems. https://www.dropbox.com/s/a4i9ywl4t0kgoax/cppExercises.odt?dl=0 I will upload more later. Happy coding.
The easiest way for me to use Valgrind is not having a convenient graphic viewer that is able to fold the logs, but to jump directly into the debugger to the piece of faulty code (`--vgdb-error=1`). 
Not sure what I was thinking 
Each time you resize the array, you'll probably have to copy all the existing data to a new location. (probably, because there's a chance the memory right after the end of your array is unused and the allocation can be grown without moving it) Copying the existing data can be slow, so it's best to minimize the number of times you do that. For example, say you start with an array of 10 elements and you add 1 million elements to it. If you grow the array by 10 each time it fills up, you'll have to reallocate it 99,999 times, copying 49,999,500,000 elements. If you double the size each time, you'll only have to resize it 17 times, copying 1,310,710 elements. 
QtCreator also has a nice valgrind integration where you can jump directly to your code when there is an error (http://doc.qt.io/qtcreator/creator-analyzer.html). It also supports callgrind / cachegrind to show nice percentages next to each line of code.
Ah I see, thanks for the input
lol, that's totally reasonable /s
&gt; In the end, you are going to learn about c++, bug fixing and software design. And the most important thing as an engineer: making optimal and efficient use of the tools available to you ;)
I didn't know about this, thank you! 
oh dear, just use tbb. 
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/872lse/question_about_resizing_arrays/dw9yz23/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/8710cx/c_github_groupscollaborative_projects_for_the/dw9yzxq/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
:(
Where can I find these kind of papers? Are there journals on CPP?
&gt; Common mistakes when coding in C++ &gt; int *var = new int[5]; I would argue that this is the first mistake :P `std::array` is your friend. Also wouldn't a compiler warning catch the uninitialized variable? (at the least a basic static analyzer should?). But anyway great to see valgrind in action :-)
std::vector is more suitable for that case.
Supposedly you can just compile it with a flag and it uses an included MPI backend. [https://github.com/STEllAR-GROUP/hpx/wiki/Running-HPX-on-an-MPI-Cluster](https://github.com/STEllAR-GROUP/hpx/wiki/Running-HPX-on-an-MPI-Cluster) So you theoretically don't have to actually write the MPI code yourself. I'm not too sure of how it load balances or how configurable it is depending on the problem you are trying to solve. I'd recommend watching the talks from Hartmut Kaiser from cppcon. Not only does he have a lovely soothing voice, but the library seems really cool!
My only issue with Valgrind is that it triggers on memory leaks in the standard library. They optimized out the deallocs in _exit because they know the OS will do it anyway. Is there a fix for this?
Define valgrind suppression rules. Or use the ones included with th system if using an Linux distro that provides them.
Cool thanks, I'll check out the talks!
I think we'd be really unlikely to add an O(N) method to vector like that.
"It breaks vector&lt;bool&gt;" is not a motivating argument, as vector&lt;bool&gt; is kinda broken.
It's being allocated at run time.
Which is not necessary when you know the size at compile time and know its small enough not to overflow the stack .
But may be necessary if you want to pass it around outside of the function.
valgrinding your unit tests is a way to get a lot more value out of your tests and it helps valgrind because the slow performance of valgrind is less of an issue when you are just testing one isolated part. unit tests + valgrind + unique_ptr (and shared_ptr) + stl containers + raii wrapping every resource with a lifetime + std::algorithm (minimize surface level loops) == badass_programming_happyness.
Here you are asking for linear (or binary) search and these algorithms exist. LEWG would probably just tell you "no" if you tried clubbing them together with find() member functions... Do note, these are library features, so you can implement your own free-standing functions and even constrain them to specific containers.
`contains` is not an algorithm, it's a utility. ;-]
Pass it by reference, just like any other heavy type...
The example is kept simple, so obviously it7s going to look like bad code at some points.
Of course, if you want to be able to use enable if for different types with different implementations, then you need to use the second template parameter in std::enable_if template &lt;class T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, int&gt;::type = 0&gt; void getValue(T /*val*/) {std::cout &lt;&lt; "Valid integral type!" &lt;&lt; std::endl;} template &lt;class T, typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, int&gt;::type = 0&gt; void getValue(T /*val*/) {std::cout &lt;&lt; "Valid floating point type!" &lt;&lt; std::endl;} It is still not entirely clear to me what the difference between these two function signatures though...
My point was that `vector` is not the right dataset in the most common case where you want to search for an element by value. You can do it, but there is no need to make it easy. Likewise for `push_front`.
You should probably read more about REST! Its original meaning is just the name of an *architectural pattern*. The key of a so called restful system is the possibility to navigate entirely through the application without any knowledge about the structure and specific addresses of the endpoints. Therefore those knowledge must be provided by the service itself and encoded into the response values. This is where HATEOAS appears. There are some decent de facto standards in this area like HAL. If your library has nothing to offer for this aspect I simply wouldn't consider it a REST specific API but simply a HTTP client. 
Well, name some evidence without doing it anecdotally 
you can pass std::array to another function as a reference or soon span. and if needed to be returned from the function it is still ok since we have guaranteed copy elision.
There might be a misunderstanding. I'm not trying to say `vector&lt;bool&gt;` is doing us any favours. It's got serious problems. I certainly wouldn't use it on a whim and I'd love if it were deprecated and then replaced by the general template so it's actually consistent with every other specialization of `vector`. The only reason I brought it up is because pragmatically speaking, it currently exists, so _some_ decision has to be made when it's going to break something else, or else I suspect many people won't be satisfied by overlooking this. That decision could very well be to say who cares. In that case, we still have to consider that not all uses of it are direct and intentional, though this is probably rare. I'm just looking at this from the perspective I'd expect the committee to if such a thing were proposed. Bring up corner cases that one might not immediately think of. The world really would be a lot easier if we could time travel back and do Herb's #4 or #6.
Yes, RH makes a good thing for developing on EL based distros :)
The original meaning of REST may not be all that relevant for developers asked to *consume* one. In actual use-cases, my experience is that a contemporary REST API consists of a clearly defined collection of request uri's and clearly defined Json (and / or XML) payloads associated with those requests. (Restc-cpp can only speak Json). You may choose to call these API's something other than REST, but many people, me included, think about them as REST APS's. A very common pattern in the Java domain is to consume these REST API's using Java classes to represent the objects sent to and received from the API. This is a simple and convenient way to consume a REST API. Restc-cpp allows you to do something similar with C++. It's all about convenience - to just read the specs for the API, write some structs or classes to model the data you will work with, and then consume the API. No manual mapping (except declaring the structures with Boost.Fusion) or intrusive serialization code - just plain, simple C++ to work on objects sent over the wire. A HTTP library, in my understanding of the term, is concerned about the HTTP protocol - and not the payload. Restc-cpp is concerned about the serialization / deserialization of objects between the user of the library and the REST API server. I have written a handful of HTTP libraries over the years. None of them, including the embedded HTTP library in restc-cpp, concerns themselves with *what* is the payload of the requests (except maybe for convenience-methods to up or download files). I don't agree that Restc-cpp is a HTTP library, more than I agree that a libcurl is a socket library. The transport is not important to Restc-cpp. It just happens that today the standard transport protocol for REST is HTTP. If that changed tomorrow, restc-cpp would also change tomorrow to support the new protocol. Regarding HATEOAS. I don't like it. I don't even like the name - it has a negative karma. (If you put '*hate*' in a word, it gives me negative emotions). It also looks like something well suited to over-complicate simple things. (Like SOAP did, and probably the reason why SOAP failed - everyone I knew that worked with SOAP hated it because of the complexity (which of course don't *prove* anything, since I don't know everyone that worked with SOAP)). My point is; restc-cpp is not a research project. It's a practical solution for practical problem, a challenge that was thrown upon me: Implement a C++ wrapper for a REST API. When I failed to find an existing open source library that solved that problem, I made my own library. And since I'm probably not the only developer facing this challenge, I open-sourced it and put in some extra effort to make it generally usable. Restc-cpp is not a hobby or a show-off. It's a tool I needed in order to do a job for a customer. (Personally I think it's a terrible idea to use HTTP /1.* for RPC. Zeroc's ICE, protobuf over TLS or even grpc are much better alternatives in my opinion). However, in an imperfect world (we don't even have C++ concepts in this dimension!) I tend to take the pragmatic approach and just solve the problem at hand in the best possible way, within a reasonable time. Restc-cpp is a practical answer to a specific problem. That problem was never how to exchange data with a HTTP server.
That they put money on other languages is not relevant to if D succeeded in its mission to be an improved C++. Even if D did not exist, these companies would still put money on those languages since these languages fit their business plans better. The problem is those that use C++, and they haven't switched to D, or plan to do so in the near feature.
This can't be upvoted enough. People **really** should run their unit tests under valgrind and fail them if valgrind fails them.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/877m9d/whats_the_best_placewebsite_to_learn_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Thank you very much for sharing it! (PS: Totally agree on the name HATEOAS - never heard of it but a really bad name choice. Probably someone thought it was funny but it's really too negative.)
`std::array&lt;int, 5&gt;` is allocated at run time? Really? Why is that the case? And `int *var = new int[5];` is not?
Confuse people about overloading/overriding/virtual function dispatch
To acknowledge people who doesn't knew this
I want this for complicated gcc/clang template errors. Would love to have an interactive tree view to navigate huge template types
This looks like blogspam, going by the amount of ads and their placement. Makes it almost unreadable on my browser.
It helps to be precise and much better than the people you’re trying to teach. Otherwise it’s the blind leading the blind. 
ad revenue
I think maybe he’s referring to returning the array from the local stack frame. Wouldn’t be so bad to return 5 ints via the stack anyways... (with or without RVO/NRVO) even then, it doesn’t make much sense to apply ‘what if’s’ to contrived samples that were there for illustrative purposes.
Use the `overload` keyword, and this problem will be solved. You will get a compilation error because your child class doesn't overload a function from it parent.
This particular paper is a paper for the standards committee. All these papers are listed [here](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/) or, alternatively, [here](wg21.link/index.txt)
C++...? These are predominantly franken C-with-classes bugs.
It is still valid C++ code, even if the cause is the copy-paste compatibility with C.
Thanks!
There is also `mp11::mp_with_index` which does the switch statement thing.
Yes, good catch, I removed my quick edit.
Good posting that shows some magic of rvalue reference I have never seen. But I have to say that using rvalue reference correctly is not an easy thing, since there are too many rules need to be kept in mind, especially in templates.
An explanation for that would be that for the template static function syntax, the visibility of the templated function is specified. In the case of modules, you don't templating an exported function, but you export _the template itself_. That is the `export` affects the template as a whole, not just the function.
OK. I understand your concerns now 😀 But even if the term REST is undergoing a change in meaning, I don't like the aspect of ignoring the the relation between resources. It might fit for some APIs, but really make it more complicated for workflow driven scenarios.
I suppose that makes sense, but I still think it looks odd. I'd much rather favor consistency over a technicality.
The template can "stamp out" a bunch of static functions. The single template is exported. 
Ten years ago I'd have never believed we'd be back to exporting templates again! The march of progress ...
It does look odd now that you mention it.
I don't like the format either. You can take advantage of C++s lack of newline awareness and write it as: export template...
&gt;`std::array&lt;int, 5&gt;` is allocated at run time? Really? Why is that the case? Only in the same sense as any other automatic storage variable is - by increasing the stack pointer some fixed amount. As opposed to a vector, which does that *and* allocates memory on the heap. Which is why it's a better analog to allocating a raw array with new than std::array is. If the example code had something like `int foo[5];` it'd be the other way around.
By that logic, doesn't: // In translation unit foo template&lt;typename T&gt; static void f(T x) { } create an externally visible template that creates functions with internal linkage in `foo`? So theoretically other translation units can instantiate `f` and put the result in `foo` with internal linkage?
&gt;By that logic, doesn't: &gt; &gt; // In translation unit foo &gt; template&lt;typename T&gt; &gt; static void f(T x) { } &gt; &gt;create an externally visible template that creates functions with internal linkage in `foo`? No it's not externally visible. That would be export template&lt;typename T&gt; static void f(T x) { } Exporting is for visibility, the other affect the linkage. The two things are orthogonal, don't mix them up in your mental model.
Maybe we could make the subreddit /r/cppmasterrace for that.
So then technically, wouldn't you need: export template&lt;typename T&gt; export void f(T x) { } because being able to instantiate the template doesn't mean you can access the function being instantiated?
Same here. That's why IMHO you need almost whole life to master c++. 
Thanks for that tip! Going to give that a try!
I disagree. The code is indeed C-ish, but I find that most bugs are indeed C++y. For ease of discussion here is a summary of the bugs (/warnings): - 10) Use of `&amp;&amp;` instead of `&amp;`, - 9) Null pointer dereference, - 8) Forgotten `throw`, - 7) Use of `memset` instead of `memset_s`, - 6) Misleading indentation, - 5) Use of indexing instead of range `for`, - 4) Forgotten pointer dereference leads to `'\0'` being assigned to a pointer, - 3) Use of `strchr`, - 2) Use of out-parameters, - 1) Use of macro to define a function. With that said, here is my classification. Vanilla C++: (10), (9), (8), (6), (4). Performance sensitive C++: (7), (3), (1). Unnecessarily C-ish: (5). Poor code (in this instance): (2). I've seen (5) used even in plain C++, especially on custom data-structures where the developer couldn't be bothered with implementing proper iteration support (it's such a drag to fulfill all requirements of a random-access iterator!). I've seen (2) used way too often for my taste; people are often hesitant to throw a POD at the problem (and I don't blame them for not using `pair` or `tuple` as the lack of clear names is annoying). However what is true for trivial types does not hold for larger types, especially if returning risks a deep-copy.
Tried it today, so far no issues, looks pretty great.
I think this is a good case in favor of not using `static` anymore, and instead use an unnamed namespace.
Doesn't work if you need another function to take ownership. Also, guaranteed copy elision is not guaranteed in all cases though it'd probably harder to hit this with array.
I like unnamed namespaces and use them a lot for classes, but it doesn’t feel right opening and closing an unnamed namespace for the sake of one function.
Sigh, getting tired of all the content advertising on these subs and PVS Studio's been doing it for a long time.
If you want to have a confusing API, do what is being suggested in this article. Take for example the following function void foo(MyValue&amp;&amp; value); If you have something like this in a header, there's no way of knowing for sure if `value` was actually moved or not, so this can be quite surprising and bug prone. I see two issues in this situation: 1. The caller assumes that the value will always be moved, when it might not be. 2. The api itself doesn't cover all the cases that the move operation should take place. I don't like this uncertainty in contract, and that's not gonna fly on during code review. The proper way to insure that an api will take ownership of type is by using **move only** types, and have a API that takes them by value, forcing the caller to move the value into the API to make use of it. That's just my take on this subject. 
most code oop-ish style code to me. move to functional programming style (like rust).
A "cheat sheet" I just made. --- #### (Parameter or method) ref-qualifiers found by ref type &amp; |&amp;&amp; |const&amp; |const&amp;&amp; --------|---------|--------|--------- `&amp;` |`&amp;&amp;` |`const&amp;`|`const&amp;&amp;` `const&amp;`|`const&amp;&amp;`| |`const&amp;` |`const&amp;` | | #### Method const-qualifiers found by ref type &amp; + &amp;&amp; |const&amp; + const&amp;&amp; -------|---------------- None |`const` `const`| #### Ref types finding method qualifiers Qualifiers|T→T |T→const T|T&amp;&amp;→const T&amp; ----------|------------------|---------|-------------- None |`&amp;` `&amp;&amp;` | | `const` |`const&amp;` `const&amp;&amp;`|`&amp;` `&amp;&amp;` | `&amp;` |`&amp;` | | `&amp;&amp;` |`&amp;&amp;` | | `const&amp;` |`const&amp;` |`&amp;` |`const&amp;&amp;` `&amp;&amp;` `const&amp;&amp;` |`const&amp;&amp;` |`&amp;&amp;` | #### Constructors found by ref type (for ≥ C++17) &amp; + const&amp; + const&amp;&amp;|&amp;&amp; prvalue |&amp;&amp; xvalue --------------------|------------|------------ (maybe trivial) copy|move elision|move |move |copy |copy elision|trivial move |copy |trivial copy |trivial move| |trivial copy|
Okay! I got what you meant now, thanks :-)
Obviously last lines work for nested foo too: deep_at_id(bar, 2_c, [](auto v) { std::cout &lt;&lt; "BEFORE: " &lt;&lt; v &lt;&lt; std::endl; }); deep_at_id(bar, 2_c, [](auto&amp; v) { v = 6; }); deep_at_id(bar, 2_c, [](auto v) { std::cout &lt;&lt; "AFTER: " &lt;&lt; v &lt;&lt; std::endl; }); Yields: BEFORE: 5 AFTER: 6 
Yes, I totally agree - it's opaque and confusing unless you have a firm understanding of modern C++. I absolutely wouldn't recommend using it in an API meant for public consumption (in this case, I'd take a deep breath and implement the 2^n constructors required for n parameters), but I've been using it in personal projects as an optimization. Quite honestly, I think it's just a workaround for a language deficit (of which C++ has many, unfortunately). I wouldn't see it catching on in any style guide any time soon, but it's interesting to postulate all the same.