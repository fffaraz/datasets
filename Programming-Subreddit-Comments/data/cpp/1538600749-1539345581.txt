Hi, thanks for your posting. But kdonald1@bloomberg.net (London) is currently out of office.
`int&amp;&amp;` will match `int` literals but not variables ((unless `std::move`'d from).
I would argue that uint8_t is worse because it isn't cross platform, you require that all your platforms are 8-bit byte platforms. It also isn't safe to reinterpret cast to an underlying representation if that's your goal, which can lead to undefined behaviour.
Hi! Thanks for your comment. I considered writing about the widget counterparts because, like you said, they are easier to use. However, IMO they are more difficult to test and adding customisations to them can be tricky and can easily get out of hand. Personally, I prefer using the Model/View variant instead as there is a natural separation. That said, I definitely think you have a point, so I'll also add a section about them to the post (perhaps tomorrow though üòÅ). Cheers! Alex
It depends on the underlying data and the filter. I used to store the data as the underlying pointer of qmodelindex ([See createIndex](http://doc.qt.io/qt-5/qabstractitemmodel.html#createIndex)) You could store a std::map with the key being the internal pointer of the model index and the value would be all necessary for filter and sorting. It's just an idea. 
Yes this is the balance you have to face. Either you start quickly but you are quite limited with the interaction and customisation side, or you do 'all by hand ', it can be quite long and more complex but then you have full control of what you do. In the end, only experience will help you choose the right architecture depending on the situation. Imho, this aspect is relatively complicated in the qt framework. 
Technically meltdown is a specific case of the spectre family of attacks. It's just the most egregious vulnerability and the easiest to exploit.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9l63rh/first_year_compsci_major_need_some_help_with_a/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
...did I miss something? Doesn't `min_element` give an iterator to the smallest value, and on a collection with a RandomAccessIterator that's just as good as an index?
Sometimes you do need the actual index (e.g. you might have to write to a corresponding element in another array, or you compute some metric based on the index etc). I'm not sure what exactly the goal here is, but it seems like OP wanted to show some sort of new algorithm to do that.
Getting the actual index would be as simple as using the difference function, aside from the air case.
I did some work on this a little while ago... learned that GCC will incorrectly let you hack your way into private type data. Apparently this is a well-known (within the compiler space) limitation of GCC's compliance.
The article explicitly says that that didn't vectorize...
Looks interesting.. Ill need to pass this on to my coworkers.. FYI: i appreciate the permissive license since we license Qt commercially... being able to statically link all our other dependencies is key to a simple lawyer-free day of work!
This is way easier to illustrate with QML
Thanks for this series, it's providing some much needed clarification for my rough Qt skills. Have you considered showing ways to structure a program? The Qt docs are great for the fine grained stuff, but the only way I've been able to learn about how to actually structure things at the high level has been from reading other application's source code which is suboptimal.
Coroutine TS require heap elision and devirtualisation to be efficient, which only Clang can do both *sometimes*. I'm not saying it's bad, but the author of the TS should be honest about not having performance and being zero overhead as a priority. Core coroutine however seek being zero overhead, but other choices in the proposal make it harder to use for users. I'm pretty sure we could have a compromise somewhere to make stuff at least zero overhead and have a user friendly interface.
can't we release tech specs and wait for a few compilers to implement the feature before accepting it into the standard proper?
Hmm not sure to understand correctly. The inputs of the model proxy functions are source index, and from source index you can request the internal pointer. This is completly allowed by the api. Once you reset your cache, you just have to browse all source indices and store the internal pointer. I never had good experiences with persistent indices, especially their lifetime, so I don't have this kind of approach.
also, speaking from experience, this is a quite common pattern when trying to use autovectorization. The compiler is very fickle and minimal changes can beak vectorization. If you need it, it's often less work to write an explicitly vectorized wrapper than it is to continuously check and correct the compilers work.
I can't get godbolt to respond at the moment, but if you *need* vectorization I'd do it via OpenMP, something like this (I wasn't quite finished when it quit responding to me): #include &lt;cstddef&gt; #include &lt;cstdint&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; #include &lt;cassert&gt; using namespace std; ptrdiff_t min_index_simd(int32_t* array, ptrdiff_t size) { constexpr const ptrdiff_t width = 16; constexpr const size_t align = 64; assert(size &gt;= width); alignas(align) int32_t minindices[width]; for (int32_t i = 0; i &lt; width; ++i) { minindices[i] = i; } alignas(align) int32_t minvalues[width]; copy_n(minvalues, width, array); for (ptrdiff_t i = width; i &lt; size; i += width) { for (ptrdiff_t j = 0; j &lt; width; ++j) { const auto k = i + j; const auto value = array[k]; auto &amp;prev = minvalues[k]; if (value &lt; prev) { prev = value; minindices[k] = k; } } } auto lindex = distance(begin(minvalues), min_element(begin(minvalues), end(minvalues))); return minindices[lindex]; } 
It's a bit more nuanced than that. Herb just said that if you want to maximize performance you should still do const &amp; + &amp;&amp; overloads. The code generated is sometimes optimal, but not always. He also pointed out that in some situations it's a very significant difference, because it's not just about counting copies/moves. But rather, sometimes it's the difference between copy construction and copy assignment which can have very different performance. This isn't "purist" at all but actually extremely practical and you can see a massive difference in some cases. But he also pointed out that the overload approach doesn't scale with number of parameters, and in a constructor you're generally always doing construction not assignment, and you have lots of parameters. So Herb actually recommended pass by value for constructors, and overloads for member functions taking one parameter. 
Good points and I'll have to take that into consideration. Do you have examples where the performance is noticeable or a reference to Herb's talk where he might provide examples where the difference is massive?
Yes -- fixed.
This is good to know and absolutely worth considering, thanks.
That's not technically correct. All you need is \`float\_v&lt;size\_t Width&gt;\` Just as you can do : if (my_runtime_var) { std::array&lt;float, 4&gt; blee; } else { std::array&lt;float, 8&gt; blou; } &amp;#x200B;
What is operator "" ? template &lt;char... cs&gt; constexpr std::byte operator "" _bl()
https://en.cppreference.com/w/cpp/language/user_literal
The entire point of this video is that you shouldn't choose the perfect forwarding implementation over the pass-by-value-and-move one unless you desperately need the extra performance. He explicitly says as much as he's wrapping up. The length of the video is largely caused by him showing why you shouldn't implement perfect forwarding unless you need to.
If anyone is interested, I made some variations based on this. Specifically, I added code to allow for non-multiple-of-8 sized arrays, an AVX only version (that works by casting to floating point internally, so there may be some issues where precision is lost with sufficiently large values), 64 bit integer and floating point versions, and the maximum equivalents. The source is buried within a subproject of a subproject here: https://github.com/schombert/Open-V2/blob/master/concurrency_tools/vectorized_min_max.cpp
Hey, glad you are interested. Kelly is out just for this week, she'll be back on Monday. I've PMed you the email address for another recruitment contact.
 volts = ohms * amps;
So I deleted the previous "spam" links and collected (and will collect all future) stories in the series under this link. Sorry for the spam!
I changed it to that but I want the user to input the ohms and amps to produce the volts.
r/cpp_questions
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9l9j84/first_c_program/e751th3/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
haven't seen the CppCon2018 presentation from Gor yet, but if they can be used even for tackling memory latency, I think performance is high on the agenda: [http://sched.co/FnKT](http://sched.co/FnKT)
Thanks man! It worked!!!
And normal temporaries (such as the return value of a function or the result of an arithmetic operation).
Numpy is good for specific types and small amounts of data. Doing something where you simply can't use numpy and have a lot of it, python is an extremely bad choice for language. You could write those specific parts in c/++ but why then bother with python at all?
Finding the minimum value (notice the dereference!) gets vectorized, but without the dereferece it won't.
I don't think that's accurate. IIRC, export was introduced to the language itself before an implementation was available, which then proved to be too onerous for various compiler writers, so the feature was eventually deprecated and removed. Releasing features as a TS rather than in the language spec proper addresses this. Implementors can get real experience with the feature, and issues can be addressed before merging the feature into the language proper. This seems eminently sensible.
C-syntax order. This would not change any behaviour but just imagine this: int arr[10]; int* f(const int (&amp; arr)[10])[2]; being this: int[10] arr; f(const int[10]&amp; arr) -&gt; int[2]*; I think the order of tokens in C was one of the worst syntax decisions ever.
We need more shitposts.
I like to use compile time vector types e.g. `simd_t&lt;float&gt;` when I can, in combination with an extensive lazy varray like container. it has the problem of being tied to a certain instruction set at compile time but it's very straightforward to use and nicely compartimentalizes vector-optimizations away from program logic as best it can. I could just write `min(sqrt(x*x+y*y)[indices]))` for example and it compiles to a simple single loop with gather instructions over the indices. Often when I'd need to target multiple arch with a single binary I'd split the heavy work into its own compilation unit which I would then compile for each target and dynamically link at run time. But, doing mostly physics research, I hardly ever need to bother with distributing binaries.
This is a shame and sounds indeed like a low-hanging fruit for compiler implementors :-) It would be worth filing a bug on the gcc and clang bug trackers, I think. How about MSVC?
You need to be carefull with avx512/avx2 . It can lead to problems with frequency scaling. See : https://blog.cloudflare.com/on-the-dangers-of-intels-frequency-scaling/
The same function in ISPC: export uniform int32 min_index(uniform const int32 values[], uniform const int32 size) { // Vector int32 index_local = 0; int32 value_local = values[0]; foreach (i = 1 ... size) { int32 value = values[i]; if (value &lt; value_local) { value_local = value; index_local = i; } } // Scalar uniform int32 index_global = 0, value_global = values[0]; for (uniform int i = 0; i &lt; programCount; ++i) { uniform int32 value = extract(value_local, i); if (value &lt; value_global) { index_global = extract(index_local, i); value_global = value; } } return index_global; } Speedup vs. MSVC 2017 latest preview with full optimizations on i7 5930K (AVX2): `9.87` 
Often the frequency scaling vs. avoiding AVX2/512 still results in a net benefit, if you can use the full width of the instruction set (as you'll have a more computations flowing through in parallel, even if each operation individually is slowed down a bit).
I understand what you are saying with using internal pointers and this being allowed by the API, but it will break MVC in my case. I'll give you more context. I have a source model which has the data in the form of a tree node, each node being pointed by the internal pointer of a model index, as usual. Then I have a chain of proxy models after this one which use only roles to transform the data. The original data structure is never exposed to the proxy models. This lets me use these proxy models anywhere, with any model, in any view (I just need to return the right data for the roles in the "data" handler in the source model) and more importantly I can change the tree node very easily since only source models will depend on it (I have around 10 proxy models and I might add more). Pretty okay model view separation. &amp;#x200B; If I cache the pointers in a proxy model mapFromSource would work okay, but the problem is mapToSource. You would only have the pointer to find the original index in the source model, so you would need to traverse the tree as far as I understand. &amp;#x200B; It seems like in one way or another, I have to cache and map source model indexes in the proxy. &amp;#x200B;
&gt; so you would need to traverse the tree as far as I understand Indeed, I didn't thought of having several proxyFilters. In my code, we have one proxy with several policies for customizing the filter. If you don't want to expose the node data directly, one idea is to implement an Interface from which all your source model inherit. Anyway, i'm quite out suggestion here, and moreover, I don't think it was the subject of this topic ^^. 
&gt;That kind of defeats the purpose of implicit conversion. I could go with the idea that constructors are implicitly explicit and you have to make them explicitly implicit. &amp;#x200B; struct T { implicit T(int foo); };
What is ISPC?
It is indeed high performance for sure, but not optimal. You couldn't use those on embedded systems or real time applications for example, simply because of the implied type erasure + allocation. You can actually implement `std::function` using coroutines.
Jonathan M√ºller has a good talk on the topic: [C++Now 2018: Jonathan M√ºller ‚ÄúRethinking Pointers‚Äù](https://youtu.be/kYiEvVEh6Tw)
The array types are my own project, hopefully one day I'll release it but right now it's on hold (and in the middle of a rework because I need tensors not just arrays now). Nevertheless I just typed a nice long comment linking to my repo and describing how I use it and the design philosophy (this lib really is my baby, my c++ numpy) and how to extend it, what's in the pipeline... and then I realized realized I'm still on my "throwaway" and my github is on my real name so NOPE. Not linking to it... Sorry. For simd types I'm switching to [Vc](https://github.com/VcDevel/Vc) but that's partly because it's used in my sphere. (not that I have any complaints regarding it's usage). -------------- I can tell you how I made it though: I made one lib for simd types that has one generic type `simd&lt;T&gt;` which has everything you could ever need in terms of operations (masks, gather, arithmetic, etc.), and then I overload everything for specific instruction sets and include the overloads based on compiler flags. So e.g. you pass `-mavx2` and it will include the specialization file that sets `simd&lt;float&gt;` to be 8 elements wide and use `vgatherps` when you call `simd&lt;float&gt;.gather(...)`. If you want to add more instruction sets, you add a new overload file and put it behind an include flag in the main file. I'm thinking of swapping to [Vc](https://github.com/VcDevel/Vc) though, but that's partly a practical choice too (i.e. it's already being used in my sphere so I don't want to make two solutions for the same thing). The lazy arrays are then all written using the CRTP pattern and there are two 'base' types, arrays which own the data and slices which are views of arrays (borrowed data). When you write `a + b` it returns a type `sum&lt;typeof(a), typeof(b)&gt;` where the sum and `a` and `b` are all considered `expession` types (named for expression templates). The `Sum` object then contains a copy of `a` and `b` (a sized ptr if they're arrays, or another `Sum` like object) and has an `operator[]` and `get_simd()` call that will return `a[i] + b[i]`. All `array -&gt; array` operations operate like this, and you can nest them. So if you write `a*b+c` you get a type `Sum&lt;Mul&lt;typeof(a), typeof(b)&gt;, typeof(c)&gt;` with an `operator[](i)` which returns `a[i]*b[i]+c[i]`. It supports math operations, gather instructions, and logical operators right now. If you call a function that reduces an expression down to a float (or cast the `sum&lt;...&gt;` (etc.) explicitely to an array), it will loop over the expression and multithread with openMP. It's pretty straightforward actually if you're familiar with expression-templates the only real problems I ran into where lifetimes (solved by just copying expressions and using smart ptrs instead of references) and distributing things like `(a+b*c)[indices]`. Here you'd want to call (a[indices] + b[indices]*c[indices]) as opposed to doing `a+b*c` first and then indexing. I'm just about to (hopefully) pick the project back up, but I'm going to do a substantial rewrite so that it will work on `arrays-of-arrays-of-[...]` in addition to `arrays-of-scalars` so that I can use it for a much larger class of problems. I also had a small PoC of using the type-system to do (compile-time) rewritting to openCL kernels so that you could run your expressions on a GPU but that wasn't really viable yet (making that fully featured would be a whole master thesis I expect). Expression templates are a lot of fun once you get the hang of them. Compile times and error codes suck, but man can you write some insanely fast but readable code. 
Good old dependency injection, the solution that is more complicated than the problem.
So, it's not just me... this looks like a solution in search of a problem.
I was talking about the general concept that it can (and should) be done. I wouldn't use a library that doesn't have the capabilities to use different SIMD standards at runtime. Vc does support this with the following customization point : template &lt;typename T&gt; using Vector = Vc::Vector&lt;T, VectorAbi::Avx1Abi&lt;T&gt;&gt;; typedef Vector&lt;float&gt; float_v; It should be as simple as : using float_v_8 = Vc::Vector&lt;float, VectorAbi::Avx1Abi&lt;float&gt;&gt;; using float_v_4 = Vc::Vector&lt;float, VectorAbi::Sse&lt;float&gt;&gt;; Though how that integrates with the rest of the library remains to be seen (I haven't tried vc yet).
Never, Never and Never. 
Really? I‚Äôm curious, is this a real opinion, or a hyperbole about how it‚Äôs the least preferable option. Surely it‚Äôs _almost_ never...?
The problem with DI frameworks is that for simple domains it works great, but you could also archive the same functionality quite easily without DI. For complex domains it introduces as many problems as it solves and can be hard to debug. It's basically a too generic solution for very specific problems. 
What alternative do you propose?
I don't think I'll ever use it.
I hate how overloaded the term "dependency injection" is. Does it mean using a framework? Does it mean some service locator mechanism with contexts? Does it mean passing dependencies through the constructor? What are people talking about when they say "dependency injection"? Personally when I try to expound the benefits of "dependency injection" I summarize it as "don't go out and get what you need, let what you need be given to you" or "push, don't pull" which is a crappy version of the "Hollywood principle" which this Boost.DI intro page leads with. I think if most people would agree with the general design principle. Personally I have yet to find myself in a situation where I thought "I need some kind of DI framework". Maybe I just don't deal with software at such a scale. That said, I'm pretty impressed with how terse Boost.DI can make the initializations with so little explicitly-set relationships (by using the type system): &lt;http://boost-experimental.github.io/di/tutorial/index.html#1-basic-create-objects-tree&gt;.
On my last company we used a boost like property system where you could set a certain property at a root level and all objects lower in the hierarchy could obverse those properties and be notified of changes. Voilla no DI needed.
Doesn't that violate strict aliasing rules?
Any potential for a US mid level engineer to work in London?
True, but it at least gets most of the way to what you want.
Replay through serialization and hot reloading 
In general I find that terms like that are often fancy names for something you already did if you got well designed code.
Whenever there is unavoidable type erasure going on. One good example of this are plugins that access functionality that got introduced by other plugins. A basic example would be that plugins expose variables. Each variable has three pieces of data: a name, a type string, and the value. So, the first two are strings, and the third ... is an std::any . Of course you could argue that this perhaps should be an std::variant instead, but the question is how far you want to go with the extensibility. If for example an exposed value is actually a struct, then there's a good chance it might not be included in your variant. And then what? Resort to heap allocation and abusing pointers as values in this (meaning, one type of the variant would be a void pointer)? std::any is a better option than that. It might also be a good option for abstracting away and yet allowing access to platform specific handles, like HWND in Windows. You can justcase such handles to uintptr_t instead, and most of the time, this works because many of these handle types are actually pointer typedefs, but there are the odd cases when the handle is actually a struct for example. uintptr_t cannot deal with that. std::any can. (I am referring to stuff like [QWidget::winId()](https://doc.qt.io/qt-5/qwidget.html#winId)).
and how were the children in the lower levels of the hierarchy aware of the property tree ?
I've had my doubts before trying DI in c# with castle Windsor: https://github.com/castleproject/Windsor Give DI a try to and you'll see how much flexibility it gives you and improves testability, readability.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Reflection in C++, the way of EnTT](https://www.reddit.com/r/programming/comments/9lg232/reflection_in_c_the_way_of_entt/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I don‚Äôt think so, because the memory allocation (i.e. the actual 'new T') happens inside the type-specific loader function. Also, the C++‚Äôs shared_ptr atores a deleter alongside the pointer, so it knows how to destruct the object before freeing its memory.
Oh C with classes~~ Look at extractAll function call, you give it a pointer to first element of your 100 clients array. Yet inside this function you only use said first element inside your loop. Use accPTR[i].fname instead.
Great answer! I have needed things like this in the past, and my solutions have always felt more hacky than I'd like. Do you happen to know how portable std::any is at the moment? Is it supported in all of the major compilers?
Thanks for the tip. I tried switching it over to that, but it didn't work. You meant like this (https://imgur.com/a/NHLk5C) right? 
My bad, I didn‚Äôt notice you actually increment your pointer.
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9lg0tp/terribly_confused_on_importing_structarray_from/e76ih05/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
I just wish there was a way to attempt to get a pointer to a base class from something that is contained in a std::any. It's the specific case that prevent me to use it sometime, otherwise it's useful for letting user of your systems to associate their custom data to yours.
I personally haven't used void* in forever (maybe never?), but it's nice to know I have a better alternative if I ever needed it.
What do you know by this and what does it have to do with dependency management? Could you point me to some resources, I can read up on it?
On macOS, I got an error message: "Call to unavailable any_cast function introduced in macOS 10.14". So, you'll need to be upgraded to Mohave or you can't use it. No problems on Win10/MSVC or Ubuntu 18.04.
&gt; tmp.cc:6:5: remark: loop not vectorized: value that could not be identified as reduction is used outside the loop How'd you get that information? What compiler flags, etc. did you use?
Clang's `-Rpass-analysis=loop-vectorize`.
FWIW, actual proposal itself is analysed in a separate article coming in October issue of Overload (stay tuned). 
Already done (Coroutines TS is already implemented by MSVC and Clang, and is working like a charm). 
FWIW, _all_ the performance rants about Coroutines TS in P1063 fall under "Coroutines TS don't require such and such optimization - which is clearly doable, and the requirement can be added in later version of the standard without breaking existing one". In other words, Coroutines TS is underspecified - but can be improved to _require_ the best-possible-performance-latency. 
I used Ninject for one of our subprojects. It worked, it worked very well for the classical "one implementation for one interface" approach, but it simply sucked for decorators or dispatching classes (to apply multiple implementations at runtime, for example validators). So much work to bring those things properly to work. For further projects I started to write my composition root by hand, so I used the "pure di" approach, how Mark Seeman calls it. It has its drawbacks (sometimes more boilerplate code, especially for transient objects), but in general it is still better readable, especially for those sceneries that don't have one implementation for an interface. So I don't blame frameworks, but they aren't the single source of trueth when it comes to di. What you need is the ability (and the willing and curiosity) to structure your code to *enable* di! 
FWIW, my current reading of it goes as follows: - there are cases when allocation is fundamentally avoidable, and there are cases where it is not . This does NOT depend on Coroutines-TS-vs-Core-Coroutines choice (!). - Core Coroutines do allow to specify allocations directly (but it will take them at least 6 years to get into the standard). - Coroutines TS do not allow to specify allocations directly, relying on heap elision instead. One of the main performance-related rant of P1063 is that &lt;drumroll /&gt; Coroutines TS does not _require_ (yet) to eliminate heap allocation when it is possible. However, this requirement can be added into a later version of the standard, which makes the whole argument rather moot. - I would clearly prefer to get coroutines now - even without a _requirement_ to have heap elision, and wait for 3 years to get requirement for heap elision into the standard, than to wait for 6 years to see whether the claims in a currently-very-immature-P1063 really stand. Which is BTW IMNSHO very in line with Bjarne's http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0976r0.pdf - and also would allow coroutines to avoid the fate of Concepts which were delayed for 9(!) years now because of very-minor disagreements about possible alternatives. 
This is actually very informative. Thank you.
FWIW, http://ithare.com/a-usable-c-dialect-that-is-safe-against-memory-corruption/ is being currently worked on as a part of https://github.com/node-dot-cpp project . Not much to show yet, but we hope to get something-to-write-about (~="a thing which aims to provide safety guarantees in some cases and save for implementation bugs") in a few months. 
Each layer knows about it's parent and children. A property that you set at a certain layer would only be visible for children below that level. 
&gt; you can use [`if constexpr`] with `std::holds_alternative` for the types you care about This would only work for a `constexpr variant` thought, right? 
yes, so at some point you pass a pointer to the parent to the children, either in the constructor or via a `child.set_parent(p)` call, right ?
Do you know what happens when `float_v_8` is used at run-time on a machine that does not support `AVX` ?
MSVC guys, is it possible to have a *sensible* debug visualiser for std::any? I.e. show the actual stored value, and not \[empty\] / \[not empty (Small)\] / \[not empty (Large)\].
Yeah pretty much. Ususally you would do it the other way around (parent.createChild&lt;T&gt;(...);). The other option was a so called ProxyProperty. You could have a class derive from that base class and could then set such a class directly as Property (which then would automatically be added as child). I might release a library mimicking that soon actually. I hope it makes more sense then.
That's not the same at all. Here you are assuming that all that can be contained can only be inheriting from Base, which is not what I requested. I requested an Any, as in, can contain almost anything, that have a function allowing to attempt to cast the content to a given type as of the given type could be a base type of the content. It would return nullptr if it's not possible (the type of the content is unrelated to the type requested) or if empty. Unfortunately my understanding is that it's not trivial to implement without bloating the implementation of any. Or maybe it is possible for cheap, I'm not an STL implementor.
Ah, I think you're right. I guess I was thinking of [this pattern](https://godbolt.org/z/-Nuz9R): passing a single generic lambda to `visit`, using constexpr if and `is_same_v` to handle only specific types. But on that note, `variant`s *can* be `constexpr`, and `any`s can't. üôÇ
And you didn't even use tasks ;)
so... you are aware that you *are* doing constructor dependency injection then ?
The reason I want this: it makes implementing type-erazing types easy without having to rely on libraries with obscure dialects (we probably need a language meta programming feature anyway to get it the simplest way possible anyway).
Yeah, I intentionally left them out, to compare vectorization only.
Okay, I got my terminology messed up. C++ standard doesn't tell about "valid" C++ programs as I used that term. But what I wanted to describe is there. Let me fix my terminology and present my point of view one more time. C++ standard specifies requirements for implementations of the C++ programming language. One can offer C++ program to the implementations to execute it. The implementation can produce diagnostic messages and/or execute program. If the program is "well-formed program" implementation "shall, within its resource limits, accept and correctly execute that program". If the program is not well-formed it should produce at least one diagnostic message and may execute program. As we can see term "well-formed program" has nothing to do with "undefined behavior". Also we can see that phrase "correctly execute" here is used in the sense of "execute as specified by this standard's rules", nothing more. What is an execution of a program? "The semantic descriptions in this International Standard deÔ¨Åne a parameterized nondeterministic abstract machine. ... conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below." As we can see, executing C++ program is producing the observable behavior that corresponds to the observable behavior of the abstract machine described by the standard. There is three special behavior types that should be noted: 1) implementation-defined behavior - "Each implementation shall include documentation describing its characteristics and behavior in these respects. Such documentation shall define the instance of the abstract machine that corresponds to that implementation (referred to as the ‚Äúcorresponding instance‚Äù below)." 2) unspecified behavior - [it]"... deÔ¨Åne[s] the nondeterministic aspects of the abstract machine. An instance of the abstract machine can thus have more than one possible execution for a given program and a given input." 3) undefined behavior. And finally: "A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undeÔ¨Åned operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the Ô¨Årst undeÔ¨Åned operation)." My reading of it is as follows. In order to execute C++ program you need the program, the input to the program, conforming implementation. You select corresponding instance of abstract machine by looking at specified by the implementation implementation defined characteristics and behavior in respect to implementation-defined behavior. Then you collect all possible executions with respect to unspecified behavior. Finally, result can be one of the results of that executions with original input. But if the set of selected execution contains the execution with undefined behavior standard makes no requirements on the result of your original program with regard to this input. If standard does not require any specific result for such execution, the result can be anything. It is quite clear that the semantic of C++ programs can not be applied to reason about the results of such execution. Quite literally behavior of whole such executions is undefined by the standard. As a side note even if your particular instance of execution would not trigger undefined behavior but there is potential execution that leads to undefined behavior only when all unspecified behaviors "align" your execution is still undefined. This is the price we pay for the "as if rule". Let me summarize this: if your program on given input contains an undefined behavior whole result of your program is undefined, not covered by C++ standard, has no meaning in regards to C++. Your compiler vendor can define some subset of undefined behavior (by assigning it some meaning and expected result). There is multiple examples of this: traps on null pointer dereference; type puning in gcc and other. Then you can program in this dialect of C++ and rely on the more strictly defined behavior. If you OK with your program being not portable to other conforming compilers - that is your choice. On the other hand if your program uses undefined behavior that is not documented by compiler vendor as defined - you doing it wrong. But it is whole other topic. Let me address your other points. &gt; the standard even goes out of its way to state that correctly executing programs may engender undefined behavior (S 1.5 note 2) No. You took it out of the context. Note 2 reads as follows: "If a program contains no violations of the rules in this International Standard, a conforming implementation shall, within its resource limits, accept and correctly execute that program. [Note 2-- ‚ÄúCorrect execution‚Äù can include undefined behavior, depending on the data being processed -- end note]" As you can see this note is not about "engender undefined behavior is OK and your program is correct!". It is not about correct or incorrect programs it is about correct implementations and executions. As I read it, it states that such correct (or "by the rule") execution can result in undefined behavior, depending on input, but should nevertheless be considered correct. &gt; Applying the actual definition of undefined behavior to this article, all it means is that null references are possible, but the behavior of using a null reference is not defined by the standard. No. It means the opposite. When your particular execution of your program has null pointer dereference (and it is UB) you should stop thinking about your execution as if it is covered by C++ standard rules. That's why you can't check for null reference. Let me show you more obvious example: [wandbox](https://wandbox.org/permlink/D9zuPOwMCztldlnG) bool sanity_check(int left, int right) { while(true) { if(left + right != 4) return true; } return false; } bool test() { return sanity_check(2, 2); } int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; "2+2 != 4? " &lt;&lt; test(); } Compiled with clang 7.0.0 and -O2 we have this output: "2+2 != 4? true" Does it mean that 2+2 can be sometimes not equal to 4 in C++ programs? What your mental model says about it? My mental model allows me to predict that there could be conforming implementations that will throw away test for null reference. Therefore you should never even think about null references. Threre could exist conforming implementations that will optimize out nullptr checks after dereference of pointers and so on. And such implementations do exist. Once again. If you encountered UB it is already too late. You should prevent it.
In my experience, shared ownership is safer for the average C++ programmer than raw pointers. This is especially true for teams of more than a few people, that are regularly updated with new members etc. Also, in my experience, memory leaks through raw pointers are a lot more often than memory leaks through shared ownership cycles.
std::variant works fine, but std::visit *is* an abomination, and demonstrates perfectly that sometimes you very much should add a feature as a language feature even if just having it in standard library looks "good enough".
Imo \`std::any\` and \`std::variant\` solve two completely different problems.
Can you, before hand, state which type(s) you will want to try to cast the contents to? If so, like I said, easy. And yes I'd build it on top of boost or std any. If not, it would get stupid. Ie, then you will need to include the equivalent of a compiler and the source code of both projects with the data you store in any. When asked to cast to a type, you'd write the casting code, send it to the compiler, load the output as a dynamic library, run that code to do the conversion. Because C++ types do not carry with them the information required to determine all bases they can be cast to at runtime. I guess if you enumerated the types you want to be able to be cast to at/before the point where you where added to the augmented any, we could store a map from RTTI to a casting function with each augmented any. Heck, any exposes typeid right? So we can build that map external to the any and enable cast to base as a service separate from the any. Again you'd have to state what derived and base types can be converted, but that can be done on a distributed manner. C++ doesn't store those instructions by itself. But you can store them for C++. (In a post metaclasses world you could make a metaclass type that autostores the runtime conversions). The question I would then have is, I get your ask. But is there anything slightly narrower you actually need that solves your problem? 
One of the best libraries. Thank you.
Fuck, i just updated this morning before this came out
I was going to post a similarly snarky comment and decided against it. There‚Äôs some truth to it, though: it‚Äôs usually better to specify some interface ‚Äî *any* interface ‚Äî to the type that your API will handle. It should be very rare that your API will just pass through or hold onto a value without handling it in any way, and that this type cannot be specified at compile time (in which case, use a template, obviously). That said, such situations *do* occur; and when they do, `std::any` beats the alternatives.
&gt;Most of the time the widget alternative covers the need with a faster deployment. I've had colleagues make similar arguments, but I've mostly convinced them to transition `QStandardItemModel`. Working with `QStandardItem` is _almost_ as easy as working with, say, `QListWidgetItem`, but `QListView` with a `QStandardItemModel` has the advantage of being so much more extensible in the future compared to `QListWidget`. `QListWidget` might meet your needs today, but what if down the road you need dynamic filtering, dynamic sorting, custom delegates, non-standard selection behaviour, etc. Step one is going to be to port away from `QListWidget`. Also, if you decide you need to replace the backend with a custom model implementation for performance reasons, your GUI code shouldn't need to be touched. Writing custom models from scratch is a real pain and certainly could be friendlier, but just dipping your toes in the ModelView framework with `QStandardItemModel` is well worth the effort in my experience, even for the "simple" cases.
&gt; fully-modern C++ and with tons of flexibility That's why I use (like) it - thank you for your work /u/nlohmann !
I'm doing my best to write the DAW I'm working on with good practices and modern C++ in mind : https://github.com/OSSIA/score
Have a look at [Maps.Me](https://github.com/mapsme/omim), quite popular [mobile maps application](https://maps.me/). 
My only complaint is that I usually forget the n in nhlohmann. 
&gt;Let‚Äôs create a 3,3 matrix and multiply it by it‚Äôs identity torch.ones does not return an identity matrix
If you try to call AVX instructions on a machine without them, it should crash :)
It's "Niels", not "Neils" :-)
Not entirely related to your example but the \`TorchConfig.cmake\` file that find\_package relies on to integrate it in a separate project, is questionable at best and certainly doesnt follow "Modern CMake" conventions. 1) It's actually a find module in disguise and might find the torch library installed elsewhere in the system rather than the one bundled with it 2) The imported target doesnt have use the typical \`::\` namespace guard (a lot of other projects don't do this, but it's quite useful to have) 3) This is rather questionable: `# When we build libtorch with the old GCC ABI, dependent libraries must too.` `set(TORCH_CXX_FLAGS "-D_GLIBCXX_USE_CXX11_ABI=0")` Even gcc 5.4 on ubuntu 16.04 uses the default (so it is defaulting this to an arguably old value). It might also be unnecessary if the C++ API doesnt pass objects of certain classes (was it `std::string` and `std::list`?). But this can definitely cause issues as that flag will propagate to all targets that transitively link against the torch one, while leaving other targets using the new ABI ... I guess I should report these issues to pyTorch... 
auto is much faster to type, but if you care about const-correctness of your iterators, you'd best spell out the actual iterator type. That way, future you, and the compiler, can be sure of the exact type that the iterator is. The compiler can catch additional errors, and future you will have an easier time reading the code.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
IMO clang's codebase uses pretty much best practices in C++11, although they do use their own stuff like vectors, arrays, strings... I don't think it's that big of a deal though.
If only it supported comments and trailing commas. I know the reason, but it keeps me from using the library.
Are you new to software development?
No, he's just a 10xer
wtf... Updating a minor update for a header-only library is pretty trivial as library updates go. Why the ad hominem and negativity?
You probably should :) I didn't face any weird errors yet , still building toy stuff .
I have a couple of programs: [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/genz.cc](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/genz.cc) [https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/cmwA.cc](https://github.com/Ebenezer-group/onwards/blob/master/src/cmw/tiers/cmwA.cc) that might be of interest to you. They use a number of newer features. They've only been on github for a couple of years, but I've been working on them for over 8 years. These programs are open source, but they work with a code generator that is closed source.
GCC 4.8 support readded :) I can finally update the really old version I'm using on CentOS 7
It was just a joke about updating external libraries/code every day, relax
[`build2`](https://github.com/build2) is a build toolchain (build system, dependency manager, etc) written in C++14.
I don't need a JSON library yet ... but knowing this would make me reconsider using this library when that time comes.
What about this [https://github.com/miloyip/nativejson-benchmark](https://github.com/miloyip/nativejson-benchmark) ? Did it improve significantly? RapidJSON kills everything in almost all categories...
That was not what I meant at all. What I meant was: if LGPL is a problem for you, then you are either (1) paying for a commercial license of Qt or (2) not using Qt. &amp;#x200B; If (1), then you couldn't care less about the license of Qt3D, since you already pay for it when you pay for Qt commercial. If (2), you couldn't care less about this post, since it's a library to be used with Qt.
It uses custom RTTI so this is non-trivial. /u/CaseyCarter, this came up on vcsig on July 31, have you talked to the debugger team since then?
Just the first one ;) 
&gt; Can you, before hand, state which type(s) you will want to try to cast the contents to? If so, like I said, easy. And yes I'd build it on top of boost or std any. No I can't. I want to store other things there, but detect sometime if the thing matches a type. Otherwise as you point, there are obviously other tools for that. &gt; If not, it would get stupid. Or maybe you lack imagination ? I've hit that issue last year in real code. With storage that cannot know what is inside. We have only one case we want to check, but the user can store and get whatever they want associated to the objects we provide. There are real use cases for std::any. &gt; ... Yes you understand it right: it would imply making that type dependant on dynamic_cast/typeid. std::any can be implemented that way to do the check preventing you from acquiring the object of you are trying to extract the wrong type. Current implementations I looked at uses a simplified or different kind of typeid that is perfect for the current implementation. But to do what I want you would need rtti. So such a any type would better be a different type which only makes you pay when you want that feature (which exists in some alternatives based on rtti).
[ScyllaDB](https://github.com/scylladb/scylla), a Cassandra-compatible distributed database.
Check out x64dbg.com it‚Äôs truly not great üëçüèª 
Ok, that makes absolutely sense. Sorry for the confusion.
This is good to hear; being stuck on CentOS 7 had forced me to switch a project over to RapidJSON. I continue to be fairly torn because I like RapidJSON's speed and the fact that I've had better experiences with its handling of escaping characters, but its interface is pretty ugly; just a step away from writing C in many cases. nlohmann/json's interface is genuinely really nice, and I miss it. 
Ok, that makes absolutely sense. Sorry for the confusion.
I guess it depends on how you define "most of the way". E.g. you still can't do any compiletime checks to see if the value is in range and you imho accept far too much for it to be considered "safe".
Damn, that looks impressive. I woulnd't know how to use that tool ...
You can try using RedHat devtoolset which provides GCC 7.2.
You don't like whitespace, do you?
If only it wasn't a json library.
Sorry; I thought you where interested in why std::any could solve your problems. You appear to be here to complain, so my "if X then I can solve your problem" was not welcome. I'll stop right after I meantion you can even write a `poly_any` that can cast FROM any type that inherits from `struct poly_any_helper { virtual ~poly_any_helper() {} }` to any other type using RTTI. If you can list the types you want to cast TO centrally, or even register them centrally, you can write a `poly_any` where you can query and get a pointer to any of the base types listed. If at the point of storage you can list the types you want to be able to be casted to, you can also store that with an augmented `poly_any`. I can list a whole pile of other "if X, then no problem with a wrapper around std::any"; my point shouldn't be "I can solve your problem" but rather "your problem, if it isn't covered by all of these solutions and others that could exist, is a tiny corner case". I mean, neither the definer of the type *nor* the code putting it in knows what interfaces someone might want to query? And yes, all of these would use `std::any` as their data storage. Some of them require RTTI active in the build; others do not. 
I'm not sure what you're disagreeing with. Export was introduced without sufficient consideration of ease of implementation, and as a result, AFAIK only EDG-based compilers ever supported it. You make a good point about the TS; that's certainly an improvement over adding an unimplemented feature to the language. Either way, though, if a feature is to eventually make its way into mainstream compilers, either as a standard language feature or not, ease of implementation is an important consideration.
Thanks for the feedback. I didn't know about this class (one of the problem with the documentation, even if it's pretty well documented, it's still easy to miss important class or tips) . Indeed, it seems to be a good compromise. I'd probably give it a go next time!
I have trouble reading code when its grouped up that closely together. With lines of whitespace in between, you can pick out parts of it a little easier. Not saying I write good code, but I'm not sure that that code is an example of well written code in that sense. Maybe I'm alone in this, but putting that little whitespace just makes it look like a wall of text. Does it help you read it faster? I'd think that even if I wrote it, coming back to it a month later I'd need to take extra long to parse it myself.
I'm aware of it, and it would be a reasonable solution except that I have instructions that the code 'should build on stock CentOS 7'. 
6 Gb per process to compile though... oof
**Company**: [Cruise Automation](https://www.getcruise.com/) **Role**: C++ Software Engineer, **Type**: Full time **Description**: We're the driverless car company. We believe in improving people‚Äôs lives by making transportation safer, more accessible, and more convenient. We‚Äôre building the world‚Äôs most advanced software to fuel the driverless cars that safely connect people to the places, things, and experiences they care about. We seek and embrace diversity in all of its forms. We continuously push ourselves to think differently and take ownership wherever it's needed. This is a place for dreamers and doers to succeed. If you share our passion for achieving what some say is impossible, join us. We are looking to hire C++ engineers across the entire company so please check out our [open roles](https://www.getcruise.com/careers) Check out [this video](https://www.driverless.id/news/video-analysis-new-gm-cruise-self-driving-video-shows-more-mastery-sf-roads-time-with-pip-proof-0176178/) of our car driving fully autonomously through SF! [Honda Joins the Party] (https://medium.com/kylevogt/honda-joins-the-party-25a945ea8805) [Why testing self-driving cars in SF is challenging but necessary] (https://medium.com/kylevogt/why-testing-self-driving-cars-in-sf-is-challenging-but-necessary-77dbe8345927) [How we‚Äôre solving the LIDAR problem](https://medium.com/kylevogt/how-were-solving-the-lidar-problem-8b4363ff30db) **Location**: San Francisco **Technologies**: C++ on ROS **Visa Sponsorship**: We can transfer Visas **Remote:** No remote work **Contact**: Anthony@getcruise.com
Yeah, it's a text wall, but more stuff fits on your screen and it's easier for tools to process. I use the same terse format with the generated code. Before it can be used, it's created and shipped across the network. I have a limited hardware budget, so terseness helps with those steps. 
Couldn't you pass the code through a stripper of some sort? I don't know of any period, but there has to be something you pass C++ code to and it spits out a stripped version. 
I was talking to one of the main authors of the library and he said that he would rather pay that cost at compile time and have the runtime be very efficient. In vfx where you are operating on massive datasets, the runtime performance is what matters. 
Oh, no question, all props to those guys. I just fear how much larger and slower the compile process will get.
Does anybody know what happened to http://open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4166.pdf
I just hate actually using rapidjson. It is extremely verbose.
I'm curious about this and if the pull/iterator streaming parse API was or will be added (I forget what they were going to call it, but it's the inverse of SAX).
It would favor code easier to maintain. In current version you need to qualify them as const because mutable is the default. With default const you would need to qualify them as mutable. Lets say the code has 12 objects, 10 const and two mutable. Having explicit mutable qualifiers makes easier for the brain to spot what objects may change, and focus on those two instead taking care of 12. 
!removehelp
Huh
It looks like you're extracting digits correctly. Walk through step by step how you determine whether they actually unique if you have 5 values representing the individual digits. Also think about the case when you have a number like 7. The upper digits will all be 0. Also a stylistic nit: you don't need break statements in your if else statement. I believe the compiler will actually end up ignoring them in this case.
damn I understand it but I hate those strict requirements, we ended up building gcc and clang ourselves so we get use the latest stuff even on el7
Agreed, but there's an overlap for cases with a large number of known types that lack a common base. Just the compiler errors that `variant` spit out in those cases are motivating enough to consider `any`.
You can also avoid exceptions without introducing lousy string handling. Isn't cmdbuf already of the correct type? Why does it need to move through a stringview phase? Why wouldn't `bail` take a stringview instead of a zero terminated string? 
&gt; For everything else then no, you won't pass the logger, database, factories, etc. but that's an implementation detail. example articles pass all these as separate arguments to make a point, but there is zero difference between class node { node(const node&amp; parent): m_parent{parent} { } void do_stuff() { get_property["logger"].log("I'm doing stuff"); } }; and your usual service locator pattern... it's just that you coupled the service locator with the object hierarchy
Safety must be prioritized over performance. Computers are powerful enough to take the small performance hit from shared pointers even in the most demanding applications. On the other hand, safety issues cost the industry billions of dollars. The correct approach is then 'safety first, performance second'. If you wanted to use onwership and borrowing, then you could, but the default should be the safer option.
What are the reasons?
It seems cleaner than tensorflow c++ api. I will have to take a look at it! 
I think facebooks thrift is very well written. It lends itself well to being easily extendable
* [https://github.com/nlohmann/json/issues/192](https://github.com/nlohmann/json/issues/192) * [https://github.com/nlohmann/json/issues/150](https://github.com/nlohmann/json/issues/150) * [https://github.com/nlohmann/json/issues/376](https://github.com/nlohmann/json/issues/376) ...etc. He only wants to support strict [RFC 7159](https://tools.ietf.org/html/rfc7159.html). Sadly, standard JSON lacks both comments and trailing commas, making it not very friendly for humans to read/write.
Could you build this project successfully? I tried and failed last week, it's one of the hardest GitHub project to build I have ever seen. It required a long list of other repos with patches, so you likely need to build them from source but not install via `brew` for example. Of course there are countless of other projects which have good build instruction and you could build them successfully e.g. gRPC, ethereum.
Well, it's the personal insult part I think. If you had said "Famous last words" you would have gotten as many upvotes as you now have downvotes.
&gt; as library updates go. But library updates don't always go. Surely you must have had experiences of installing a seemingly minor library update and suddenly having unexpected problems? Some level of paranoia is quite justified. I would say that the majority of library updates I make go without incident, but I'm always pleasantly surprised when that happens, and it's the sort of thing I'd never do in, say, the last few days before releasing a product or significant update.
I like the ideas described in [The Harmful Consequences of the Robustness Principle](https://tools.ietf.org/html/draft-thomson-postel-was-wrong-02). Thereby, I assume that a deviation from the JSON specification may be harmful in the future.
It might, but as the developer I know it‚Äôs not written great üòÄ
My focus was not performance, and there are also faster libraries than RapidJSON. However, it would be great if the benchmarks on the site would be updated. However, a respective issue is open since February: https://github.com/miloyip/nativejson-benchmark/issues/100
I suggest you have a look at this pearl of c++: [https://github.com/arximboldi/ewig](https://github.com/arximboldi/ewig)
How do you deal with dependencies? I've looked into the devtoolset before and would have to basically rebuild all dependencies and statically link them.
It should crash if the execution actually reaches the AVX instruction, and older CPUs without AVX actually detect the AVX micro-code as invalid and raise a signal. I don't think the compiler backend, assembler, etc. guarantee that you will actually reach the AVX instructions though, since they will assume other CPU features that might not be available when adding padding, etc. that the actual CPU might interpret differently.
I mostly agree. Accepting non-conformant input leads to quirks mode and works-for-me situations. I'm not angry that implementations chose to stick to the spec - I'm annoyed that the spec is not good enough, and that the author of the spec refuses to incorporate any new features.
Wow. That‚Äôs harsh. Stock GCC on CentOS / RHEL is always years behind the latest version
I tried to explain every line of code in the comments. IMHO that was informational. But you're right, I should write this in README.
My argument is that properly used unique ownership combined with best practices for raw pointers (which can be checked and warned about by compilers today) are just as safe as anything using shared pointers and are probably significantly faster. In fact, shared pointers everywhere is likely much slower than a garbage collector. Shared pointers also mess with intuition about RAII since it becomes far less obvious in the code where the last use will occur and destruct the object.
Wow I didn't know it was an open source application. It's so nice !
Our small demo project [shrimp-demo](https://stiffstream.com/en/docs/shrimp-demo.html) (source code is [here](https://bitbucket.org/sobjectizerteam/shrimp-demo)) was written in C++17. It's hard to say how perfect (or imperfect) the code is, but it was a pleasure to use C++17 and its features after many years of C++98/03 and limited subset of C++11. 
Hi! I am sharing this threadpool I made for C++. While the code is not very complicated, it was the ocasion for to make a project from top to bottom. It includes documentation, tests and CI! Feel free to use it! Documentation: https://threadpool.readthedocs.io/en/latest/ 
Great puzzle! Thank you.
&gt;While the code is not very complicated &amp;#x200B; Actually it is good thing - I looked at the code and I like it - easy to read, no template mayhem and not over-designed. If you want to develop it more you may think of limiting number of executors to physical cores so each task won't spawn new thread and task will sit in queue. This will of course change behavior - but may give gains when you schedule thousands of small tasks and throughput is more important than guaranteed (if we even can use this word for threads) latency. P.S. - I would change name of is\_stop to is\_stopped or just stopped ;)
In my work I'll keep the tensorflow api as my main goto framework, but I will definitely explore it in my spare time. 
With many tasks/workers the single shared work queue will be a bottleneck, because it will need constant locking/unlocking. This seems to be also suboptimal for cpu cache usage. One way to improve this is to give each worker its own queue and have him "steal" work form other workers if its own queue is empty. 
There's no optimization you can do with T&amp; you can't do with T*
Indeed, I will try to implement that in a next version. This is kind of a first version of it. Thanks for the feedback!
This is a bit of an odd request though, right? `any` is a value type, not a reference type, but you want to get ask if it's derived from T and get an (unsafe) T* out of it.
I would read such post. Thanks.
That was awesome, good work!
Sure... I agree with all of that. But the guy just stated he _just_ updated it a few hrs before. So it's obviously a good time for him to do this in terms of release management etc.. My point is, given that he's ok with the risk of updating at that point in time, and its super easy to upgrade a single header, just repeat what he did that morning. 
I enjoyed the puzzles, except... Are you sure about #1 being correct? There was an interesting discussion on here a week or two ago where a similar snippet was discussed and someone said it was undefined behaviour. And #4 was too big for my mental compiler to completely fit everything in my head at once.
Awesome idea, love it.
I already have a pointer and length so making it a stringview is cheap. Bail() could take a stringview, but I call syslog() in that function so I need a null terminated string.
We deploy the libstdc++.so file with all our applications (bit of a pain but it works). Nothing else needs to be linked specially from our use case at least.
I tried #1 after #8, and came to the comments section to say much the same thing. /u/NotMyRealNameObv, can you link to that discussion? I'd interpret the words "The implementation may assume" in normative text to mean that if the assumption is invalid, the compiler may do whatever it likes - i.e. it's UB. Either way, it'd be good for the answer section to discuss why it's implementation-defined rather than UB, or vice-versa.
Serves to show how convoluted C++ has become.
https://www.reddit.com/r/cpp/comments/9hmoqb/herb_sutter_blog_lifetime_profile_v10_posted/
The given answer is wrong. As per http://eel.is/c++draft/namespace.std#6 the correct answer is implementation defined behaviour.
I thought the standard solution is a single producer, multi consumer, lock free queue?
 template&lt;typename ...Ts&gt; void foo(Ts...); + void bar(...); = template&lt;typename ...Ts&gt; voir foobar(Ts......); The comma before the trailing C variadic is optional.
May I ask why you chose rvalue references to functions and arguments [in the arguments to run()](https://github.com/reyreaud-l/threadpool/blob/d420477d33f49b03a954785c949c766817b11c1b/include/threadpool.hpp#L62)?
Puzzle #8 is linking to [Puzzle #7](http://stryku.pl/poetry/puzzle_7.php).
You mean unspecified, yes.
Fixed, thanks!
TIL. Like I replied to /u/Untelo, thank you guys for pointing that out. Now I see that I did misinterpret the wording. I'll change the answer in #1 too.
That's why I said small tasks - like 100's of instructions. This implies no IO operations, mutexes and other shit. This is a case when task switch overhead will be 10x more than actual kernel being computed. Big functions are fine with regular threads.
This won't compile on the latest MSVC with /std:c++17 unless I add the comma in the ellipses baz(Foo(*)(Bar......)) does not compile but baz(Foo(*)(Bar...,...)) does. Neat.
I would like if links to these puzzles popup here every now and then. Great puzzle
 ¬Ø\\\_(„ÉÑ)\_/¬Ø 
Though, in this case, it was a convoluted _C_ feature (variadic arguments) that's been around for decades.
Those are universal references since it's a template function.
These are universal references to allow perfect forwarding. Here's a read on perfect forwarding in C++ using universal references that explains it: https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c. Also Scott Meyers's Effective Modern C++ is a good read on perfect forwarding.
That's incorrect as well, since there is no guarantee that `::printf` even exists. Even though most stdlibs accept it, it isn't supposed to be there. (There was a paper recently to legalize that behavior, but I'm not sure that it is in C++17; either way there is no requirement.)
Perfect thank you for the reference. I'm still pretty new to C++ so hadn't encountered that construct before, and wasn't sure what to google.
Actually, according to this: [http://eel.is/c++draft/depr.c.headers.other#1](http://eel.is/c++draft/depr.c.headers.other#1) it's ok to use \`::printf\`, right?
They are now call "forwarding references" and this is official, it is written in the standard. 
if you `#include &lt;stdio.h&gt;`, you are guaranteed access to `::printf`. If you `#include &lt;cstdio&gt;`, you are guaranteed access to `std::printf`
If you dereference the pointer to the pointer correctly then it should work regardless of what it is. It's hard to know where the problems are without seeing the code though
&gt;deeringc Thanks, I appreciate your feedback!
What led you down the zero dependency path? I'm interested to know what you plan to do in order to add something like http compression without bringing in zlib or similar? Make it a pluggable interface and allow the consumer to supply their own? 
There's a LOT of posts on reddit. Expecting someone dig multiple layers into your post to see if *maybe* there is something there doesn't seem reasonable.
One for every javascript framework
[Parameter packs](https://en.cppreference.com/w/cpp/language/parameter_pack)
So much of the complexity and oddness of C++ stem from its origins in C. That's always what happens when you strive for near-complete backwards compatibility.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9m0hyi/need_help_with_splitting_a_string/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
OK, that's fair. 
I would also mention that Asio, and web-framework are very different things. Web Framework consists of many components and helps you to get rid of the pain putting all those components together (ex. Asio, curl, di-framework, etc...). And making framework zero-dependency gives you possibility to seamlessly put all those components together without tradeoffs (on the framework level).
I consider that to be a downside to stringview: there are so many interfaces out there that take a zero-terminated string, ultimately forcing a copy.
[This](https://www.reddit.com/r/cpp/comments/8wvyvo/update_on_the_status_of_movable_initializer_lists/e1yyg9s/) is the last I've heard about it.
As far as I know we did not compile to use an older ABI, we've sort of bootstrapped ourselves through the gcc versions up to 8.x using the base EL6 (now EL7) gcc to get there. And we actually only compile gcc to compile a newer version of clang (I think we recently upgraded to clang 6). Basically we have two RPMs &lt;company&gt;-gcc-devel and &lt;company&gt;-llvm-devel which we host in our devel repos and then every dev machine just installs them via yum/dnf normally into /opt/&lt;company&gt;/gcc|llvm and we override the default gcc/clang system with these. We then deploy a /opt/&lt;company&gt;/llvm/lib directory which contains the correct libstdc++.so file for all of our applications to link via LD_LIBRARY_PATH=/opt/&lt;company&gt;/llvm/lib:... in the systemd script to all link to at runtime. I hope that helps explain it a bit, we don't have any real hard requirements other than CentOS so I'm betting that makes our use case a lot easier.
Oh this looks super nifty. This looks like it would piece together easily with Qt and QTcpServer 
Modules isn't a magic bullet for solving the compatibility issues of today, but I believe it could be the key to writing an integrated build system that can solve the problem of easy distribution and consumption of open source projects. What modules gives us is the ability to isolate individual projects into a single interface layer for compilation on top of the static library for linkage. We no longer have to ensure we set the correct flags and define the same macros when referencing headers during consumption that we compiled with, yay! Now that the language itself gives us this power (or hopefully will), it is on the build system to know how to resolve dependencies, build individual packages and add the required references to compile and link the final result. I am currently playing around with the idea of a fully source based distribution model with a cli and service to see if the idea is feasible. I am fighting my way through issues in the Modules-TS implementations and actively prototyping. I will try to open the project up once I get past the initial implementation, but am always open to discussing the topic!
Why don't you do it the same way as you would have done async callbacks situation if the lifetime is not strictly known i.e create a shared_ptr to the class instance ? For eg: see asio examples. Maybe I am missing something completely.
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
\#include&lt;iostream&gt; &amp;#x200B; using namespace std; int main() { int number = 1; int high; int low; int ctr = 0; // use better names, whats 'ctr'? while (number != 0) { cout &lt;&lt; "Enter a number (Enter 0 to stop the series): "; cin &gt;&gt; number; for (int i = 2; i &lt;= number; i++) { if (ctr == 0) { high = number; low = number; } if ((number == 1) == 0) { // First you compare number to 1, which gives a bool, then you compare this bool to 0 (aka false) you need to write "((number == 1) || (number == 0))" &amp;#x200B; break; } if ((number == 1) || (number = i)) { // "number == 1" is already catched before, not a bug, but unnecessary. "number = i" IS a bug. You dont compare, you assign if (number &gt; high &amp;&amp; number != 0) { high = number; } else if (number &lt; low &amp;&amp; number != 0) { low = number; } } } ctr++; } cout &lt;&lt; "The highest prime number you entered is: " &lt;&lt; high &lt;&lt; endl; cout &lt;&lt; "The lowest prime number you entered is: " &lt;&lt; low &lt;&lt; endl; &amp;#x200B; return 0; }
It is a very wrongly popular solution. It's simply the way we shouldn't do it.
Academia has a very vast literature on how we should make thread pools and believe me, it is really really hard! Work stealing would be one thing, locality aware stealing by victim selection should be done too. The people behind Cilk also talk about how much we should steal each time. I suggest you to read related papers.
Static exceptions (Herb Sutters proposal) might help you, right? I believe those won't be forbidden anywhere. However you'll of course have to wait quite some time for those...
From the title I thought it was called "Zero-Dependency", which seemed weird.
Any time I feel cocky, I do C++ puzzles
I think you're basically asking "Why `std::weak_ptr` here?" Good question. It seems to me that if you use `std::shared_ptr` here then the coroutine keeps the underlying object alive indefinitely - and if the coroutine never runs, then the underlying object is essentially leaked until it does. Or, there might be very good reasons that you did not want the destructor of your class to run in the coroutine thread, perhaps due to synchronization issues. If it were me, I'd keep it simple, and just ensure that the coroutine is always run in a reasonable amount of time and make sure the destructor could be run on any thread. But sometimes you can't do that... some years ago I ran into some OpenGL thing whose destructor would occasionally barf if it weren't run on the main thread, that was annoying. :-/ ---- Honestly, waits without timeouts as in the `co_await`s in this code give me angst: I'm never sure-sure there's no race condition. I'd much rather have the tiny overhead of waking up my coroutine or thread every 10ms or so and checking if it's been interrupted or woken and therefore be sure I can never lock for more than that 10ms timeout. 
I don't like to depend on (older) Boost libraries, because they drag fast to much old cruft with them. But the general "zero-dependency-mania" in c++ projects is imho largely a result from decades without a standardized package manager and build system.
https://oatpp.io/ -&gt; "Simple API overview": Are these macros? E.g.: ``` ENDPOINT("GET", "demo/api/hello", hello) { return createResponse(Status::CODE_200, "Hello World!"); } ``` That doesn't seem a very "organic C++" way to me?
Probably the "cleanest" way to do this without user-defined attributes.
Creating your own thread pool might be an interesting exercise. But creating a really good one is its own profession. On Windows and OSX I would always use the one that comes with the OS. There is a great talk by Pedro Texeira about the creation of the Windows Thread Pool: https://channel9.msdn.com/Shows/Going+Deep/Inside-Windows-8-Pedro-Teixeira-Thread-pool. Then there is a good session about this topic as well available by Sean Parent from code::dive 2017 https://www.youtube.com/watch?v=QIHy8pXbneI
Summary of the answer: a task do not own it's launcher. It's the other way around. That's basically how you use RAII to have a sane understanding of which tasks are running or not. When the object is destroyed, none of the tasks it launched should continue (except in special cases). With shared_ptr the task would own and keep alive the object instead, which leads to the reverse of RAII: no deterministic destruction. It can be super surprising and hard to work with when you're in this situation.
What does "organic C++" even mean?
Could you coroutinize the weak ptr to this and co await it? auto x = co_await f(); (co_await self)-&gt;x = x; where self is an awaitable weak ptr. 
conan now has around 121 public packages and uses python. vcpkg has more than 640 packages and uses cmake. vcpkg is much more simple. Although lacking explicit versioning, vcpkg's simplicity allows users to build each project with specified vcpkg folder side by side.
Seems intresting... I don't like the idea of depending on python... 
To be honest i'm more interested in the usability rather than the sheer number of public packages. I'd rather build my dependencies by myself
conan is a full fledged package solution. You write recipes in python for your custom packages, and dispatch them via your private conan server. vcpkg now only supports windows and linux targets. You write ports in cmake for your custom package, and ... just use them locally.
Left shift and right shod moves the bits that composes a variable, they have the &lt;&lt; and &gt;&gt; operators respectively 
I found the discussion [here](https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/) to be helpful in understanding the concept. 
Vcpkg's lack of versioning makes it a non-starter for anything except toy projects
I‚Äôve had serious issues with vcpkg on macOS. Conan seems better overall. 
Except if you follow google and "live atpx head" ;). More seriously though: Most of the time it is absolutely trivial to make a private fork with the exact library versions you want (change the download source to whatever release you want and fix the hash). Only if the build process changes significantly from one library version to another, you may want to start hunting for previous versions of the port file in the git history. All that doesn't mean, explicit, built-in versioning wouldn't be useful anyways.
You can switch from CMake to Meson, an alternative delivering the same feature, build script generation machinery. Meson is not Turing complete, so it naturally prevents you from coding full-scale program. Conan, vcpkg and nuget are package managers viable for C++. Nuget is not a fit for native C++. Conan is very flexible, allows you to work with binary-only/compiles-from-source libs, integrates with many build tools, including CMake, Meson, Make, MSBuild, Ninja and many more. Vcpkg somewhat in between Conan and Nuget, IMO. Build2 provides you the next layer of tool chain in addition to the rest - CI. You can upload the package to remote service and get it compiled and tested for about a dozen platforms. Automatically. When it works, it looks like a miracle! Build2 is compiles-from-source only system. It doesn‚Äôt handle precompiled binaries (like proprietary shared libs). You must provide sources for your project and for all your dependencies, wrapped into Build2 build system. Build2 works with compiler and linker directly, in embeds build script generation (like CMake) and build script execution (like MSBuild). Both Build2 and Conan+CMake tool chains were presented in CPPCON 2018. Video should be available soon. My personal choice is Conan. All I do is conan install .. &amp;&amp; conan build .. to get my dependencies and invoke build process for my App. Works very smooth for me. 
We use vcpkg with CMake on Windows and Linux. For the most part, it's fantastic. I integrated seamlessly into an existing CMake project by cloning vcpkg via CMake if not present, and installing/updating packages automatically. I also hardcode a vcpkg changeset to switch to (to ensure all checkouts use the same versions, though we'll likely switch to a custom fork. Versioning is trivial. Just set your desired version in the appropriate profile. But it will be up to you to ensure compatibility among dependent t packages if you're changing individual versions. We use cross-compile Windows and Linux, and use vcpkg on both. vcpkg is amazing on Windows - it solves deployment woes but copying needed dlls as a post-build step. We recently integrated gRPC (large library with many dependencies and custom build process). Two simple lines in our CMake process! (one to call our custom function to install the vcpkg and find the target, and a target_link_libraries call) Here's the hidden part that *really* sucks: it currently only supports static linking on Linux. That prevents us from using it for a variety of common packages on Linux. For example: Qt can't be static-linked for non-FOSS, GDAL only supports dynamic linking, etc.
vcpkg is great, but it has some serious issues over the past months. More and more issues get opened (over 1000 now), and there's nearly no one to tend to them. Stuff stays unfixed, particularly on Linux/macOS, but also on Windows. The community contributions are not enough. I really hope they can turn it around, because vcpkg is really needed and awesome. But it needs maintainers and developers. Conan looks awesome too - I haven't tried it myself yet but I certainly would. Build2 is probably great too if you're willing to maintain two build systems (CMake + build2). Or, you're willing to give up CMake, which I wouldn't advise doing lightly.
So yet another design flaw in Coroutines TS that requires even more hacking and patching? Color me shocked.
&gt; #include&lt;stdio.h&gt; iiiek :\ Please: `#include &lt;cstdio&gt;`.
Currently vcpkg. I am not a fan of depending on Python, when we have modern C++ for implementing such kind of tooling.
That:s a big no go for me... 
Pragmatic choice: vcpkg or Conan (they work today and are complete enough) Pragmatic but need finer control choice: Conan (it gives more options) Long term choice: Build2 (show great promises because it uses a coherent model, but it's not considered stable yet by the devs - I experiment a lot with it and other than the potential interface breakages I think it can be used today for a lot of new projects) Ideal choice: helps SG15 (the group reflecting on tools vs C++) define interfaces for build systems and dependency managers so that your choice is not impacted by your dependencies choices.
Have you ever tried Hunter (https://docs.hunter.sh/en/latest/)? It's totally written in CMake. Getting started is very easy, only requires to include one cmake file in your project (HunterGate.cmake https://github.com/hunter-packages/gate). Hunter comes out with many CMake/C/C++ available projects, as well as non-CMake ones. If a library is missing, you can open an issue directly on the Github repository or even add it yourself, thanks to the community help. Hunter's development is carried out following modern CMake best practices. I personally recommend to take a look to it, even just for learning purposes.
Seems interesting! 
I think you meant to reply to some comment.
So according to your logic vcpkg is out of the question, because it depends on CMake.
Which I do bare, because as mentioned, *"Additionally it already replaced Makefiles and Autotoolsl in several C++ environments."*. There isn't a single activity on my daily job that relies on Python written software, whereas lots of C++ libraries have moved on to CMake. I do make the point that for me a C++ DSL would be the way to go. Now, if the community speaks louder and prefers to install Python to build C++ software, I just have to accept that is the way it is going to be. 
Had the same problem, we went with Qt. The next best thing is electron, which I won't touch.
By the way conan has around 120 packages in conan-center but there is also around 300 in bincrafters repo, though it is community managed and quality of the packages may vary. https://bintray.com/conan/conan-center https://bintray.com/bincrafters/public-conan
&gt; Build2 provides you the next layer of tool chain in addition to the rest - CI. You can upload the package to remote service and get it compiled and tested for about a dozen platforms. Automatically. When it works, it looks like a miracle! Have you seen/experienced it not working in some situations? If so, I would like to hear about it. FWIW, I used it live during my CppCon talk so we clearly have a pretty high confidence in our CI service.
Not sure if it fits in with your requirements, but I enjoy bazel for my projects. The only problem I‚Äôve had with it is that it doesn‚Äôt support precompiled headers well. Other than that, you can extend it to do most anything. I looked at build2 and was quickly disappointed at the readability in the examples. 
python is much more of a hassle than CMake for end users imho
Qt is the state of the art for cross platform desktop GUI written in C++. You might want to do some analysis about how difficult it would be to port your MFC version to wxWidgets, though. Wx is rather like the MFC API, so you might be able to skip a total re-write by re-jigging the codebase as Wx. In contrast, porting to Qt would probably amount to a re-write.
And what might be the reason for your distaste of underscore prefixed member variables? Do you like maybe the postfix version? The m\_ version? Or do you follow the ideology maybe that "if there are so many private member variables that you need to prefix them in order to avoid potention collisions in their infancy, you have overly bloated classes and you ought to simplify them" (which is far too much idealistic in my and most others' opinion)? Is it maybe because of what the standard says about how underscore prefixed objects are reserved for language implementors? Turns out, in reality you practically never run into any collisions due to this, unless you love them members starting with capitals maybe. Additionally, this convention is deep in the mainstream, with other C languages like C# as well. I am simply curious by the way, not trying to force a convention I deem most suited at this point on others.
If you are thinking on rewriting the GUI entirely, I'd take a good look at JUCE. It has different philosofies than Qt which makes it imo feel more modern. Some of them: - like QtQuick the GUI is entirely GPU rendered. - it comes with a resource structure called Value Trees which is amazing. - i love the UI editor, it is a pleasure to use. That being said, it looks like nowadays JUCE is selling themselves as a GUI framework for audio software almost exclusively which is a bit weird? Also it is of course less mature and has to be lacking on some features that Qt has. But it's worth checking out!
There's a few reasons I dislike them: - Typing it sucks, unless I make a bind for it on every computer. I have to press shift, press _, and move my hand far off of the main row of keys. This makes it very awkward to use. The shift key is no problem because my pinky is near it, but the underscore distance sucks. - It's an extra spacing character, more stuff that I don't want type and it makes the names longer... as someone who likes seeing code fit horizontally on the screen, C++ already is very good at making this difficult to achieve... adding underscores just makes this worse - I also think it uglifies names IMO, everything is 'spaced out' and looks like I'm reading Ruby source code &gt; The m_ version? I hate this even more. No editor in the last 10 (or 20?) years lets you access a private member unless you are inside the class, and that's the only reason I could consider people doing that. &gt; Or do you follow the ideology maybe that "if there are so many private member variables that you need to prefix them in order to avoid potention collisions in their infancy, you have overly bloated classes and you ought to simplify them" This has never been a concern nor does it play a role in the decision to use underscores. There also could be shadowing issues, but all sane compilers have a warning for this, and then some -Werror takes care of that. &gt; Is it maybe because of what the standard says about how underscore prefixed objects are reserved for language implementors? Having had to go through the std library multiple times, I became accustom to reading `__lol __something = __iter_ecks_dee` and understand why they have this convention. I can see why they'd do it in the global namespace, &gt; Additionally, this convention is deep in the mainstream, with other C languages like C# as well. Just because other people use it does not mean I suddenly don't despite it. If a project uses it and I contribute to it, then I'm doing underscores with no ifs/ands/buts. Any project I own will be doing stuff like LLVM does (which follows Java/C# naming conventions of no underscores and doing camel or pascal case). On that topic, C# uses `UpperCase` naming convention, whereas Java uses `lowerCase`. I don't recall any library I came across that uses underscores. I'm sure they exist though, but it doesn't follow the C# naming convention, as can be seen from the standard library. I don't know where you got that it's the mainstream
This is exactly what conan does by abstracting both the package generator and build helper. Projects can use any build system they like (cmake, bjam, autotools...) and the conan recipe can setup the environment and build variables accordingly. Hence my autotools project can depend on a projects that uses CMake or scons without any knowledge of such.
Meson is implemented in Python but ships [standalone MSI installer packages](https://github.com/mesonbuild/meson/releases) that you can just download, install and run. All Python stuff is hidden so unless you specifically go looking you can't even tell that it is implemented in Python.
Short story: - no short form is not voted in yet; - the main reason is that a lot of people want the short form to still be clearly stating that it is a template, not an actual function; - there have been tons of proposals and counter-ptoposals and I believe there have been at least some convergence to "void foo(Concept auto object)"; - we will know in November's meeting if there is something voted in or not for C++20; So just wait. Long Story: read the proposals which named include "concept" and "syntax" from the last 3 years to get most of the details. Th
I would go with whatever suits me in C++ and compiles to WebAssembly As an indirect example, currently I'm making games with unity which can compile it's C# scripts to WebAssembly+WebGL (by first generating C++). They do the embedding work but that shows how WebAssembly works well even for demanding games. So maybe focus on making your project compile when targeting WebAssembly, potentially change the UI library on the way.
I‚Äôve used Conan and vcpkg. For my project, Conan has problems building on Windows (AppVeyor), and vcpkg has problems building on MacOS/Linux (Travis-CI). Since MacOS and Linux are more important for my purposes, I‚Äôve gone with Conan on my main project, although I have a version building with vcpkg. I‚Äôve had to use Homebrew/Linuxbrew to fill in missing libraries. Both projects are responsive and I‚Äôve submitted (different) bugs that were fixed in both. vcpkg portfiles are east to use and develop, but I‚Äôve seen subtle issues, ie just because there is a portfile for a package doesn‚Äôt guarantee it will work on your platform. Conan packages seem much more difficult to generate, but have more flexibility and if there is a package it mostly works (except perhaps on Windows). 
Inheritance do not (always) imply that the stored type is a reference type. In the case in question, we want to store the object by value, but the inheritance is there to identify the familly of object (we can't do that by checking if the stored type matches a concept or not, at runtime, which would work better but... maybe with metaclasses?). It's not more odd than having inheritance in iterator tags. They are not even used as values but the inheritance is useful for expressing relationship.
Not only obscure: it also imply that you have to do this for any tool you use to track lifetime relationship between your tasks and objects. That's super problematic. weak_ptr is kind of an ad-hoc solution to this problem, there are better ones and having to have that hack for each one of them doesnt'seem to scale.
Consider making a paper pointing these issues? Assuming we are finally having tools (like executors) to be able to handle task concurrency using RAII (which is how I do it at home, makes things simple), the case you describe kind of make the coroutines almost useless.
Vcpkg may be easier if you are using Cmake only, and only need to consume packages. But if you need to create packages, or want to use something other than Cmake, then Conan is your best choice. 
Shameless plug, I summed up the whole thing. It's somewhat outdated though https://cor3ntin.github.io/posts/concepts_syntax/
A build2 CMake generator could really accelerate build2 adoption. I know it's counter intuitive to add the layer where, especially since the goal of build2 is to simplify and remove unnecessary layers, but all CMake project could suddenly expose build2 objets.
There was one short form that snuck through: `template &lt;typename C&gt; requires Concept&lt;C&gt;` can be abbreviated to `template &lt;Concept C&gt;`
Clients of Language Server Protocol tend to be named *lsp* while clients of Debug Adapter Protocol tend to named *vscode*. I hope this will be better than cgdb
&gt;There isn't a single activity on my daily job that relies on Python written software, whereas lots of C++ libraries have moved on to CMake. If you use gdb or lldb on a daily basis, you very likely use Python in a daily basis. &amp;#x200B;
Minor typo: &gt; Undefined bahaviour
Write-in: Vendor everything via submodules.
Neato, now we get swift-like protocols.
Basically, the 'terse' form of concepts was pretty controversial to about 1/2 of the committee. The fact that a concept-constrained function IS-A template is pretty scary. One such instance, is lookup rules, but I'm trying to fix that: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0782r1.html
My problem is that you keep on describing problems I'm saying I've solved and are easy to solve. And no, it doesn't require changing the guts of `std::any`. template&lt;class...Bases&gt; struct poly_any: private std::any { // piles of using, and some adapters template&lt;class B, // clause that requires B be in Bases... &gt; B* get_base() { // code that reads a B*(*)(std::any&amp;) table. // which returns null if the any doesn't contain a type derived from B } }; that table is populated via something like: template&lt;class B, class D&gt; auto to_base() { constexpr if (!std::is_base_of&lt;B,D&gt;{}) return [](std::any&amp;)-&gt;B*{return nullptr;}; else return [](std::any&amp; a)-&gt;B*{return std::any_cast&lt;D*&gt;(&amp;a);} } which uses `std::any` as storage. The table looks like: std::tuple&lt; Bases(*)(std::any&amp;)... &gt; to_bases; either stores as a pointer-to-static const or within the `poly_any` (depending on size vs locality requirements), and in the `template&lt;class T&gt; poly_any&lt;Bases...&gt;(T&amp;&amp;)` ctore it is initialized like: to_bases( to_base&lt;Bases, std::decay_t&lt;T&gt;&gt;()... ) the guts of `std::any` remain unchanged. `poly_any` just adds a type erasure wrapper on it. Now, this type erases "can I cast to `Base`, and if so, please do so". You can type erase *any* property of what you store in an `any` using a similar technique. So I can write a `printable_any` which supports `std::ostream&amp;&lt;&lt;printable_any const&amp;`. I can have it throw an exception if it isn't printable, I can have it print nothing if it isn't printable, or I can have it check that the argument is printable at compile time. Hell, I've written template&lt;auto...Operations&gt; struct super_any where `Operatons...` are a collection of arbitrary operations: auto print = smart_memfun([](auto const&amp; x, std::ostream&amp; os){ os &lt;&lt; x; }); and super_any&lt;&amp;print&gt; printable is now an `any` augmented with the ability to `(foo-&gt;*print)(std::cout)`. Again, not rewriting `std::any`. Of course, [boost type erasure](https://www.boost.org/doc/libs/1_55_0/doc/html/boost_typeerasure.html) probably does it better. I keep on saying I can do this, and you keep on saying "if only I could do this", so I'm not sure if I misunderstand you or you misunderstand me. 
For json values I would have at least took nlohmann's library. It's practically the standard for json in C++.
That's about 9MB of source, split over 15 static libs and 50 or so executables. Note that the 10GB figure is not just for the final generated executables, but also includes all the other stuff the compiler generates: precompiled headers, intellisense files, debug databases, etc. Like I said: I'm sure it is being used for something, but it still feels rather excessive. 
Why would I use this over something like Go?
When I think "playing with C++", I think "multimedia", so that's the reason for these: Pick up SFML and build a simple game. Or OpenCV and play around making new filters for webcam images. Build Conway's Game of Life, then optimize it to run as fast as you can. Read up on one of the MOD music file formats, and write a player. Pick an old game system (or something like Chip-8) and build an emulator.
SFML + ImGUI are generally my goto personally for building interactive content, they're easy to mash together and you can build thing out very quick with them
I‚Äôd highly recommend checking out [Dropbox‚Äôs Djinni](https://github.com/dropbox/djinni). It‚Äôs simply an interface definition language but takes the pain out of communication from C++ to ObjC and Java. Of course, it provides native view control so you have to do that yourself. I think Dropbox has said that they use Djinni primarily for logic libraries (like handling json data structures) or for interfacing with common services (like their own HTTP services or a local SQLite db). [I‚Äôve built some tools for managing views using it](https://github.com/adamtait/ctheworld). Looking at that project might help you get started. 
Why?
IF I can do things limiting dependencies i prefer to do it. If conan is much better I'll live with python, it's not a blocker... but if two solutions have similar value and one does not import a BIG dependency I prefer. It's a matter of taste... PS. JDK to me it-s a blocker.
`this' becomes a reference instead of a pointer. Secondly, I would like to have very local namespaces, as in using namespace in { }. 
I develop mostly on Windows with Visual Studio.
my 5 cents about vcpkg vs conan : 1) On my current project lead dev chose conan because it allowed managing 3-rdparty libraries of different version (even though, I personally find it absolutely wrong approach to build project against 2 versions of the same library) 2) I personally don't like conan integration and inability to specify which library from 3-rdparty package to link with (eg. : boost - conan generates files that link with all boost libraries available in package) 3) vcpkg provides the best integration (to VS via copying vcpkg.targets and by passing CMAKE\_TOOLCHAIN\_FILE to cmake command) without any extar file generation and necessity to include them to your project
Linux is not the only OS on this planet.
As a full time swift developer I dare to say if you mean PATs, they are the worst thing in the language in practice. Their biggest mistake probably.
why ? I have developed a lot of code with this pattern, and the performance and real-time behaviour has always been excellent.
&gt; Build2 [...] it's not considered stable yet by the devs [...] potential interface breakages [...] While both are true, as we are nearing `1.0.0`, we are becoming very conservative with breakages, reserving them only for grave design mistakes. Also having 30+ projects of our own that use `build2` gives a very strong incentive to think twice before breaking things ;-). There is also another side of the early/late adopter trade-off: if you try `build2` now and find something fundamental is missing or doesn't quite fit your needs, it's a lot more likely we will be able to fix it now than when `1.0.0` is out. &gt; help SG15 define interfaces for build systems and dependency managers Unfortunately, I think this is a pipe dream: there is just too much complexity and variability in this space. I think what could be achieved (though I will be the first to admit it's still a long shot) is a canonical project structure that makes it easy for a project to be built with any modern build system and packaged for any modern dependency manager. This is the topic of my P1204R0 proposal (should be in the pre-San Diego mailing). 
FWIW, we found that Conan on Windows wouldn't run as expected when using Gitlab CI. It turns out it simply a case of the CI runner running as a system account and not having a home directory. Setting CONAN_USER_HOME in the CI script solved that problem. Other than that, we're quite happy with it on Windows. 
Yes, that's definitely possible. In fact, I spoke about that with /u/electricCoder (Robert Maynard) at CppCon and he was (personally) quite interested. In particular, this would be a quick way to add C++ Modules support to CMake.
&gt;And for a little while, a truth was established, I believe you mean truce here.
&gt; I can‚Äôt wrap proprietary binaries (no sources) into Build2 package and use it as dependency. Correct. However, `build2` has a notion of *system packages* (i.e., those that come from system packages manages such as rpm/deb/etc or just manually installed). So you can satisfy a dependency with a binary-only package via this mechanism. &gt; It looks like CMake/Autotools projects should be rewritten in terms of Build2 to be used with other projects. Yes, if you do this, you will gain all the benefits that `build2` offers. But you can still consume projects that use other build systems from `build2` projects and the other way around. See [Using Unpackaged Dependencies](https://build2.org/build2-toolchain/doc/build2-toolchain-intro.xhtml#guide-unpackaged-deps) for details. 
This post is basically "design your pet language" and has been asked 100 times here. 
&gt; a language as close as possible in spirit to C++ You mean the language that emphasizes backwards compatibility above just about anything else? 
How so?
You meant /r/cpp_questions
thanks, edited.
So the base class doesn't do anything (e.g. it's not polymorphism we're after here) but is just a tag? I guess the only thing left is to see if the RTTI can help you out here?
Do you mean that something like: void foo() requires(requires(false)) {} is a template ?
Which itself conflicted with the proposed `Concept C;` short-form syntax for variables - especially now that `template&lt;auto V&gt;` is a thing now, and "auto is the most basic concept". Taking `Concept auto C` for variables resolves that at least, as well as potentially allowing multiple concepts on a variable in short-form as well!
I only use Qt occasionally, but I would say QML. Traditional widgets are pretty much bound to old style desktop applications. The focus seems to be full speed on QML controls, specially when targeting non-desktop platforms.
!removehelp
OP, A human moderator (u/blelbach) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9mb6cw/question_regarding_switching_domain/e7dtvjj/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Whoops it's more like I blended 2 sentences meaning the same thing XD
Yes, that's the way I do it, though it is possible to not use RTTI as user/NotAYakk pointed in the other answers.
Because pointers imply a lot of things that optional references don't - things like possible ownership, pointer arithmetic (is this a pointer to an array or a single?), and so on. An optional reference, by virtue of the fact that it doesn't support these things, is better code-as-documentation than a pointer would be.
Wouldn't an optional reference FORCE the programmer to check for null/empty, as opposed to a pointer? I believe that's the benefit.
I often like to do a poker hand or blackjack hand evaluator as a simple non-trivial project. The problem space is well-defined, but there's still plenty to design in there.
Optional behaves pretty much like a pointer in that sense. Accessing the contained value with the \* operator when there is none is undefined behavior: [https://en.cppreference.com/w/cpp/utility/optional/operator\*](https://en.cppreference.com/w/cpp/utility/optional/operator*)
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9mdn60/i_need_help_with_external_text_and_arrays/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Why do you say that wx is closer to mfc than Qt? You don't have to use qml if you don't want to, although it's a breeze to work with of course. The promise of cross-platform development of wxWidgets is a meagre one I find, there's plenty of widgets that behave differently on different platforms, the last one I ran into (last week) is wxMiniFrame having a small border inside in its gtk implementation but not in its windows implementation. Prepare to spend plenty of time ironing out those differences if you go this route.
&gt; Because pointers imply a lot of things that optional references don't References imply a lot that pointers do not as well. That's why the whole copy assign vs rebind debate happened. &gt; things like possible ownership I understand what you're getting at, but if you care about these semantics in your code, just designate that returning owned pointers must be done via std::unique_ptr or gsl::owned_ptr. &gt; pointer arithmetic (is this a pointer to an array or a single?) If it's a non-owning array, return a gsl::span. If it's an owning array, that's currently a hole that was supposed to be filled by std::dynarray, so the closest you've got is std::vector. Or make an owned_span type that's a unique_ptr to array and a length. Pointers have been filling this role for a long time and will have compiler checks that require null checking with the new lifetime profile, presumably using the same mechanisms that future checking for optional refs would use.
&gt;Or make an owned_span type that's a unique_ptr to array and a length. `unique_ptr` can actually manage arrays: `unique_ptr&lt;T[]&gt; = make_unique&lt;T[]&gt;(10)` - dynamically sized fixed-sized array (is there a better way of saying that?) owned by a `unique_ptr`.
This problem exists purely because C++ decides to have implicit referencing semantics. That was obviously a bad choice then, and it's still a bad choice now. As evidenced by this little nugget of ambiguity.
It's almost like they wanted to suck up a little bit of Rust's type safety, only to fall flat on their face because they're unwilling to enforce that safety at a semantic level.
I've been using for personal projects a `reference_ptr&lt;T&gt;` custom class, I describe it as having the semantics of a reference with the interface of a pointer.
You're saying that writing `optional&lt;T&amp;&gt;` is _not_ an explicit statement of intent that I want a reference? The post is correct - assignment semantics (and, to a lesser extent, comparison) was the reason.
To complete, the killer issue was: what are \`container\` and \`comparator\` in the following modified signature: &amp;#x200B; void sort(Container&amp;&amp; container, Comparator&amp;&amp; comparator) { &amp;#x200B; R-value references or forward-references?
Y'see, I'd even oppose that solution (it was proposed during the Boost Outcome peer review as well). My rationale is simple: show me a *compelling* use case for `result&lt;T&amp;, E&gt;` which is obviously needed instead of `result&lt;reference_wrapper&lt;T&gt;, E&gt;`. Remember the former means that `T&amp;` is *natural*, the latter means that `T&amp;` is *exceptional*. It's a huge deal in terms of declaring how we teach Optional, and best use for Optional. Any of the use cases shown during the Outcome peer review were much improved if the code were refactored to not be passing around references in Results in the first place, and after we arrived at that point, the decision to ban naked references became obvious to everybody. Now Optional is not Outcome, but I would similarly struggle to see any compelling use case for naked references in Optionals. My argument would be: "if you're tempted to do that, it's probably a bad design code smell, and it goes away if you refactor your design to something better". For the 0.01% remaining, that's not a big enough user base to add such a significant amount of extra metaprogramming and compile-time overhead because it violates not paying for what 99.99% won't use. I am happy to be proven wrong though, even for Optional. But I think the bar to meet naked references is rightly very high, and ought to be so for all vocabulary types.
One thing nice about optionals is you can have a function like so template&lt;typename A, typename B, typename F&gt; optional&lt;A&gt; flat_map_optional(optional&lt;B&gt; input, F func); where `func` has signature `optional&lt;A&gt; func(B input)` This allows you to write more straight forward logic and push all of your null/empty checking into this one function.
You're missing the fact that the implicit construction machinery et al sees references all the time. Being able to apply the rule of simply coercing those into a value is an immense reduction of complexity cognitively on the programmer, and on the metaprogramming, and thus build times of anything including `&lt;optional&gt;`. But ultimately I return to my original objection: why are naked references needed? Is there any compelling use case not equally or better done with `reference_wrapper` for the small number of people who actually need this facility?
You seemed so serious until the very end there
Maybe there just shouldn't even be an `optional&lt;T&amp;&gt;::operator=` in the first place, forcing you to pick one of the explicitly names member functions instead. Of course, this is inconsistent... so probably a bad idea.
**Company:** [Stevens Capital Management LP!](https://scm-lp.com) **Type:** Full time **Description:** Stevens Capital Management LP (SCM) is a registered investment adviser that manages a multi-billion dollar hedge fund that has been in business for 25+ years. SCM specializes in the rigorous development and disciplined implementation of empirically based quantitative trading strategies. Our highly productive team works in a fast-paced collegial environment, utilizing extensive data sets, technology and the scientific method to devise and employ trading strategies throughout the world‚Äôs most liquid financial markets. SCM is in constant pursuit of exceptionally talented and motivated individuals with a history of outstanding achievement, who are interested in developing and implementing automated trading strategies. **Location:** Philadelphia, USA **Remote:** No **Visa Sponsorship:** Yes **Technologies:** SCM is hiring for C++ Developers working in a Linux environment. **Contact:** For more information on open positions, please visit our careers page at (https://grnh.se/f330a6f81)
You cannot rebind a reference, so it seems entirely natural to me that optional&lt;&amp;&gt; also wouldn't rebind. Why would you expect this: int a = 0; int b = 1; int &amp;c = a; c = b; to have different semantics from this: int a = 0; int b = 1; optional&lt;int &amp;&gt;c = a; c = b; Similarly, you cannot declare a reference without immediately assigning it. The same rule would naturally apply to optional&lt;&amp;&gt;. I really don't see the problem the committee apparently saw.
JUCE has been focused on audio since it was initially developed. It was initially the custom toolkit for a DAW, and was split out in 2004.
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9merpo/newbie_need_help_finding_way_to_compress_all/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
It is, but it doesn't semantically represent an optional reference. It represents a reference that might or might not tolerate a null reference. It's impossible to tell from the signature whether it is valid to pass `nullptr` as a point argument. With references and optional references, the semantics are clear.
**Company:** QUANTA **Job:** [Software Engineer](https://cryptojobslist.com/jobs/software-engineer-at-quanta-santa-clara) **Location:** Santa Clara, CA **Allows remote:** No **Visa sponsorship:** No **Type:** Full-time. Competitive. + Token Compensation QUANTA's QDEX Tokens w/ Staking **Description:** QUANTA, a Silicon Valley based venture, is building a public blockchain for fast and scalable digital assets exchange. We aim to build a global eco-system for exchange operator, service providers, developers, and end users. Our work is inspired by decades of industry experience working on high performance and distributed systems such as Cassandra, Dynomite, and Dynamo. The work of Cassandra has its roots in Google FS. It was developed, and used at Facebook, then later adopted by Netflix. Cassandra and Dynamo provides all the features of a distributed database system such as fault tolerant, high availability, and scalability, except it is not suitable for sub-second latency transactions. The Dynomite work proposed memory as a storage layer while leveraging the benefits a distributed database. Join the technology frontier of blockchain and work on the important issues of blockchain: scalability &amp; liquidity. Candidate will work on a decentralized blockchain platform with a small, but growing, experienced team. Job Responsibilities: - Participate in the design of an in-memory distributed blockchain layer based on existing research. - Implement the design into an existing Golang, C++ code base. - Build unit and integration tests. - Make recommendations and lead the effort with the team and community to rollout the code to the production We're looking for an experienced developer who has a track record on: - Demonstrate in depth knowledge of developing in C/C++; other languages such as Python, Java, Scala is a plus. - Strong comprehension of computer science fundamentals, data structures, algorithms. - Resume containing your distributed system / blockchain experience - Downloadable code samples or links (to GitHub, etc.) that demonstrate your ability to build/architect a distributed system and/or blockchain code. Min. Experience: - Software Development: 1+ years Education: - University 4 year degree - Computer Science Degree or equivalent **Contact:** [https://cryptojobslist.com/jobs/software-engineer-at-quanta-santa-clara](https://cryptojobslist.com/jobs/software-engineer-at-quanta-santa-clara/apply)
**Company:** Rivetz Corp. **Job:** [Security Solutions Engineer](https://cryptojobslist.com/jobs/security-solutions-engineer-at-rivetz-corp-san-francisco-bay-area) **Location:** San Francisco, Bay Area **Allows remote:** No **Visa sponsorship:** Yes **Type:** Full-time. DOE plus equity. **Description:** You will be working closely with Business Development, Product Management and Engineering and responsible for providing technical support for Rivetz clients. From the solutions perspective, this includes creating and delivering presentations of Rivetz products, gathering technical requirements, creating test plans and enabling solutions with Rivetz technology. You will work closely with customers as their primary point of contact for feedback and resolution of issues and be the customers‚Äô advocate with Rivetz support teams. You will provide feedback to Product Management on new feature requests and product enhancements from your prospect and customer base. This technically oriented position will also provide support for developers and designers who are utilizing our Software Development Kit (Toolkit) in both mobile and server-based applications. You will provide support services and incident management via email, web and telephone and face to face with client. Responsibilities include first line interaction with developers, setting and managing customer expectations, timely communication, performance and process improvement, troubleshooting, trending and resolving complex support cases. ## Responsibilities * Drive the entire technical dialogue from initial customer engagement to closed sales (and in some cases through delivery and ongoing account management). * Develop and Deliver technical product presentations to prospects and existing customers. * Act as the customer‚Äôs focal point for all technical matters relating to requirement definition, architectural design, proof of concept implementation and deployment. * Become the Rivetz subject matter expert understanding applications that can be enabled with Toolkit and act as our consultant regarding suggested uses of Toolkit * Work with engineering, business development and product management to prioritize Customer requested enhancements * Assist through release cycles in testing new features, enhancements, verify bug fixes and provide test versions to the customer when applicable. * Develop sample applications that utilize the Toolkit / SDK and demonstrate possible uses. * Monitor and support email and phone Toolkit support requests * Log and track all customer issues including defects and feature requests. Participate in strategic and tactical account planning. ## Qualifications * Languages: C/C++, Java, Groovy. * Technologies: Trusted Computing, Global Platform, Blockchain. * Platforms: Android, iOS. * Tools: GitHub, Eclipse, Android Studio, AWS. * Customer facing experience. * Experience in developing and delivering technical/solution presentations. * BSc OR MSc in Computer Science or Electrical Engineering or equivalent work experience. * Excellent social skills and willingness to work in a collaborative team environment. ## Awesome to Have * Interest and/or experience in digital currency/blockchain/decentralization. * Mobile security experience * Cybersecurity knowledge * IoT Security experience * Android / mobile development experience **Contact:** [https://cryptojobslist.com/jobs/security-solutions-engineer-at-rivetz-corp-san-francisco-bay-area](https://cryptojobslist.com/jobs/security-solutions-engineer-at-rivetz-corp-san-francisco-bay-area/apply)
No, because a pointer requires an explicit syntax to create it, a reference is formed implicitly. So an optional reference would also be formed implicitly.
&gt; First paragraph doesn't make any sense to me. I don't know what you're talking about. In which you won't understand the objections to naked references in Optional. I hate to beat on that awful trope, but it's what Bjarne means when he goes on about Vasas. You want to add a feature to the standard that a very few ought to ever use just because "it's needed to fill in a hole in the type system". Yet you're imposing added compile times and complexity on everybody, just out of ideological purity. Not because of a need by the average C++ developer. That's why people are opposed, and request "please show us compelling proof of need". &gt; None of the use-cases for optional&lt;T&amp;&gt; are better done with reference_wrapper Hardly. It's deliberately and intentionally awkward and unpleasant to use to discourage usage. But it's there if you really, really, really need it e.g. you're writing interop code between third party code bases you can't change the source code of. 
Even though writing std::optional&lt;std::reference\_wrapper&lt;T&gt;&gt; is too verbose for my liking, I would actually use it if it could provide an overloaded operator dot. Always having to write .get(). or (). is just super annoying and makes using std::reference\_wrapper akward imho. It's comparable to using smart pointers and being forced to write .get()-&gt; all the time whenever you want to access it.
 template&lt;typename T&gt; using optional_reference&lt;T&gt; = T*;
&gt;wx is closer to mfc than Qt? Because it is? Have you looked at all three APIs?
templated using statements are awesome.
&gt;Similarly, you cannot declare a reference without immediately assigning it. The same rule would naturally apply to `optional&lt;T&amp;&gt;`. Huh? The whole point of `optional&lt;T&amp;&gt;` is to allow it to be unbound. 
Stroustrup says in the [FAQ on his website](http://stroustrup.com/bs_faq2.html#pointers-and-references) that he designed references this way to enable seamless operator overloading. He gives the example: void f1(const complex* x, const complex* y) // without references { complex z = *x+*y; // ugly // ... } void f2(const complex&amp; x, const complex&amp; y) // with references { complex z = x+y; // better // ... } One of the goals of the C++ has always been that user-defined types should (as far as possible) work in the same way that built-in types do. I don't need to say `*x + *y` to add two `int`s, so why should I need to for two `std::complex` numbers?
Understandable. I have no problem with python... I've also developed some project with it... but cmake seems to have conquered its space in C++ world: I'd say it's difficult to develop in C++ and get rid of it... so python would be an addition not a substitution!
If you're optionally returning an expensive to copy item, I'm almost certain that using `optional&lt;T&amp;&gt;` is the wrong choice for that. `optional&lt;shared_ptr&lt;T&gt;&gt;` is probably a far better choice. Safer, code more closely reflects intent, no lifetime issues.
Convention says a pointer can be null, use a `gsl::not_null` for when you need a pointer that is not null (when a reference won't do). -core guidelines
If you the end user really decides you need `optional&lt;T&amp;&gt;`, then you can subclass `optional&lt;reference_wrapper&lt;T&gt;&gt;` and override its `.get()`. My point isn't that some users sometimes need this. My point is that `optional&lt;T&amp;&gt;` has no business being in the *standard* when it really is a power user's option, and *most* end users would be advised to refactor their code instead of relying on the kind of inherently dangerous and brittle design which `optional&lt;T&amp;&gt;` usually involves.
I feel like I gave the most important one when I mentioned assign vs rebind. A retutned reference also strongly implies a longer lifetime than that of the caller.
In the alternate universe where references did not exist, then user defined numeric types would define operators to take non-null pointers (like in Go or Rust), and pointer arithmetic would have different syntax.
If you're asking why, then the reason is the problem posed by this post. As far as I see it, the only two *sensible* (note: subjective) possibilities is to not implement `operator=` on optional, but instead provide either accessor methods or to make sum types a first class citizen in C++.
I think the theory was "when you make an `optional&lt;T&amp;&gt;` you must initialize it immediately or it's empty forever". Not that I'm really on board with that either, but it would at least be workable
Huh, apparently not. That's an oversight IMO. Alternatively if a compile-time fixed size is acceptable you can use `unique_ptr&lt;array&lt;T,10&gt;&gt;`
The Software Complexity Survey II is now complete. Thank you to everybody who helped out! 
What I was asking (in a roundabout way) was, if all referencing in C++ was explicit, how would you implement operator overloading?
I don't see a design flaw here. You basically have the same problem to solve if you combine asynchronous execution and C++ object lifetime. Your asynchronous function will have to care of the lifetime of every object it uses, including `*this`, no matter you use coroutines or anything else.
&gt; You might want to make (or present) it as an "official" feature and not a work-around I am not sure what gave you the impression it is "unofficial" or a "work-around". It is even mentioned in the introduction in the "Using System-Installed Dependencies" section.
I've gotten a few reports here. Everyone please remember to keep it civil.
The way languages like Rust do so is by permitting automatic dereferencing. That means you can implement operator overloading for all types that deref to whatever type you're actually looking for. Personally, I've seen this work brilliantly throughout the Rust ecosystem, rarely producing considerable footguns.
[removed]
!remove
Didn't know that! Makes complete sense. Thanks for clarifying.
Whooops sorry! New to Reddit 
Re Eto, all links to the reference documentation were broken when I checked it out a couple of weeks ago. Where did it move? Is Eto still maintained?
reference_wrapper is brutally verbose to use. Aside from the name itself, it also doesn't even preserve being able to call member functions directly, so you have to preface every single member function call with `.`. The point of reference wrapper (AFAIU) is to allow reference types to be *deduced*, when not explicitly specified. In other words, a way to call functions and pass them references without explicitly specifying the types on the function call which can lead to many more problems. With `optional`, and `outcome`, in the vast majority of cases people are going to write out the exact type they want (e.g. they will write the return type of the function anyhow, since usually auto return type deduction won't even work for returning optional or outcome) so there isn't any reason we should have to get into that pile of verbosity.
It wasn't on the shortlist I was asked to review. Looking at it now, it looks fine, but without looking through source code it's hard to say. One thing Ultralight has was its predecessor Awesonium or some name like that, I trawled its source code online and came away feeling it looked good. Of course I made the huge assumption that Ultralight would be similar, but it's a fair bet given the same developer.
This is what people typically do these days, but one place this is very annoying is if you want to have an optional argument to a function. With `optional&lt;const T&amp;&gt;` you could bind to a temporary, and the function is convenient to call no matter what. If you pass a pointer then you need to have the argument in a variable and take the variable's address.
I always recommend TinyRenderer and always will: * https://github.com/ssloy/tinyrenderer * https://github.com/ssloy/tinyrenderer/wiki * (check both links) Other people have good suggestions too. (ImGUI, Vulkan, etc) 
A bunch are provided qt quick controls, and KDAB also wrote a wrapper for the normal widgets. https://www.kdab.com/declarative-widgets/
The problem with arguing from the core guidelines here is that in reality, if you see a `T*` you wouldn't know if that's a newfangled, core guidelines-following, non-owning nullable pointer, or if it's a just a `T*` that was written there 30 years ago and has never been changed. `optional&lt;T&amp;&gt;` is an affirmative indication that you've thought about it and this is definitely what you think you want.
While one solution would be to delete operator=, I personally prefer waiting until pattern matching finally arrives and we can use Maybe like all the cool kids do...
By "presenting", I was referencing to your message, not the official documentation. Re-reading your comment, I have a different feeling. I must have jumped the "or just manually installed" part - sorry !
1) `shared_ptr` already has additional empty state (as opposed to `T&amp;`). Therefore advice to use `optional&lt;shared_ptr&lt;T&gt;&gt;` as replacement of `optional&lt;T&amp;&gt;` makes no sense to me. 2) "optional **const** reference" is not the same as shared ownership at all. It is "this is a **const** reference, you can copy it if you want". Shared ownership is obviosly totally different thing.
Actually std::optional&lt;int * const&gt; can be [rebound](https://godbolt.org/z/tL40Ex). int int_a = 0; int int_b = 1; std::optional&lt;int * const&gt; opt_a = &amp;int_a; std::optional&lt;int * const&gt; opt_empty; opt_a = std::nullopt; // OK // opt_a = &amp;int_b; // error 'use of deleted function` // opt_a = &amp;int_b; // error 'use of deleted function` // opt_a = opt_empty; // error 'use of deleted function` opt_a.emplace(&amp;int_b); // OK opt_empty.emplace(&amp;int_b); // OK // awkward alternative to `opt_empty = opt_a;` if(opt_a) { // OK opt_empty.emplace(*opt_a); // } else { // opt_empty = std::nullopt; // } So your analogy with std::optional&lt;int * const&gt; can be used to argue that std::optional&lt;T&amp;&gt; should be rebindable (at least with emplace).
The typefunction proposal prolosed `Concept{type}` for types and `Concrpt val` for variables, and `Concept {type} var = init;` for a var of deduced and constrained type, with the typename stored in `type`.
Oh, I know Awesomium! Didn't realize it was the same developer. Thanks for sharing your exp üëç
That makes no sense to me, and `result&lt;reference_wrapper&lt;T&gt;&gt;` is really impractical to use. And yeah, `result&lt;T&amp;&gt;` makes sense. Consider for example getting a value from an associative container, or even a plain vector (wich would be better than throwing `at` and unchecked `[]` :p) And you might want to pass an optional parameter by reference and not using a pointer makes it clear what the intent is and who owns what. 
**Company:** Kitware **Type:** Full time **Description:** Kitware develops open source software platforms and supports them with services such as consulting and training. Among the company‚Äôs most known platforms are the Visualization Toolkit (VTK), ParaView, and CMake. Kitware is currently hiring scientific visualization developers to work on these platforms and other tools for data analysis, visualization, simulation input preparation, and modeling. Responsibilities of the scientific visualization developer include supporting fine-grained parallelism on massively threaded shared memory systems (e.g. Intel Xeon Phi and GPUs), building tools to improve scientific data analysis workflows, developing distributed memory parallel algorithms for data analysis, optimizing distributed parallel codes, and compiling and maintaining software on supercomputers. **Location:** Clifton Park, NY; Carrboro, NC; Arlington, VA; and Santa Fe, NM. **Remote:** No **Visa Sponsorship:** Yes **Technologies:** We use C++11. You can work on Linux, Mac, or Windows. Experience with Qt and Python are a plus. **Contact:** Email resume and cover letter to hr@kitware.com. 
&gt; when it really is a power user's option More power-user than a raw pointer?
I'm willing to spend 16 hours/week for 6 months on a project that uses this middleware: [https://github.com/Ebenezer-group/onwards/graphs/traffic](https://github.com/Ebenezer-group/onwards/graphs/traffic) More info here: r/http://webEbenezer.net/about.html
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9mgz2r/recommended_books_for_a_developer_looking_to/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
shared_ptr takes over the lifetime management and requires heap allocation. That's not remotely a substitute.
Hmm, it's still active on GitHub at least: https://github.com/picoe/Eto
OP did say the object was expensive to copy. That usually implies that memory allocation is not expensive relatively speaking. Also, shared ptrs don't have to manage lifetime, you can construct them so they don't.
You're considering this in terms of *ability* to implement, not in terms of good *design*. As you might have gathered, I'm not keen on handing shotguns to people in the standard unless there is a very compelling reason. `string_view` is an example - I hate it because it's very dangerous. But it has a very compelling motivation, and this is C++ not C#, so I can get over it. But for `optional&lt;T&amp;&gt;` I find no compelling reason to hand people that shotgun in the standard itself. I am open to being convinced. But I am also very sure that there *aren't* compelling reasons, because for every one of those I've seen so far, a refactor to avoid `optional&lt;T&amp;&gt;` would be a much superior design. And if people really do love `optional&lt;T&amp;&gt;`, it's trivially easy for them to subclass their own implementation out of existing standard library facilities. All this suggests to me that `optional&lt;T&amp;&gt;` isn't worth standardising. I appreciate how deeply unpopular it is to tell people no. But we need to do lots more of that in the C++ standard going forth. And this is an easy no. Saying no to Modules in their current presentation is much harder, yet is certainly obvious to me at least. I think they're a mistake, in their current design, and better tossed than standardised.
&gt; Consider for example getting a value from an associative container, or even a plain vector (wich would be better than throwing at and unchecked [] :p) Definitely use a delegate accessor class in this situation. Far better design. &gt; And you might want to pass an optional parameter by reference and not using a pointer makes it clear what the intent is and who owns what. I personally don't think `optional` should be used for optional parameters. There is very little value add over a pointer whose interpretation is widely understood thanks to C, and there is not insubstantial cost either. It adds significantly to compile times in particular to have public headers which use Optional, and for virtually no gain in terms of readability, maintainability, or overhead instead of a pointer. Optional is very useful for optionally present items in state config though. It's the only place I seriously make use of it, in fact, because in state config a pointer points at stuff, and I want to disambiguate optional stuff versus pointed at stuff. There Optional is exactly right.
And then people wonder why c++ code is so ugly and verbose. 
Yes, I agree. I may have been imprecise in my wording, but I don't think this was ever an issue that was up for debate. The question was whether `=` would apply to the `optional` container (as `.emplace` does) or to the underlying `T` referenced by the `T &amp;`. No one would suggest that an explicit `.emplace` would act differently (as far as I know) as it would with `int * const` or literally any other type. The question is and has always been what the implicit `=` does.
&gt; shared_ptr already has additional empty state (as opposed to T&amp;). Therefore advice to use optional&lt;shared_ptr&lt;T&gt;&gt; as replacement of optional&lt;T&amp;&gt; makes no sense to me. Well true. But Optional has multi-modal use cases. I almost never use it in parameters or returns for example, as I find no compelling reason to do so. Much of the anger against my opinion on Optional stems from those who do do this, they cannot see why you wouldn't use it in parameters and returns. But often when a feature first becomes available, people over use it until they realise the downsides from over use. I use Optional only where *there is no close substitute*. Otherwise I avoid it. This opinion stems from an awful lot of practice and use. Let's say I've "gone off" Optional in new code from experience. &gt; "optional const reference" is not the same as shared ownership at all. It is "this is a const reference, you can copy it if you want". Shared ownership is obviosly totally different thing. I'm well known to have non-traditional opinions on what shared ptr means and is. For me it's just reference counted lifetime, and there is no "shared" anything about it except in its name. If it helps others to think of shared ownership, good for them, but it's not how I see it (consider after all the aliasing constructor on shared ptr). Ultimately if you can afford a malloc during copy construction, you almost certainly can afford a shared ptr to potentially avoid that malloc. If you cannot afford a malloc, and your copy construction is very expensive (e.g. copying 200Kb of representation), and you need to optionally return a reference to that, I'm thinking you're now in a very minority use case which the C++ standard ought to deliberately not address. We ought to not standardise the possible, but instead standardise the useful to the majority 80%. Leave the remainder to the Boost libraries etc. For me that's what the Vasa paper was all about.
Which version? 2.6, 2.7, 3.5, 3.6, something else? The Python compatibility story is tragic. I would not want to introduce such a source of pain and fragility. After migrating from SCons to CMake, I wouldn't want to migrate back to Python in a hurry.
Hmm, I wonder if he knows that GCC replaced his SSE implementation with AVX code...ü§î 
Agreed
&gt; the main reason is that a lot of people want the short form to still be clearly stating that it is a template, not an actual function; Personally, I think the main Problem is FUD. I think Bjarne said it in one of his presentations: Whenever there is a new tool people are very good at imagining problems and bad at imagining benefits. Also, you can almost always justify some explicit syntax for a particular feature, but the more visual noise there is overal, the more likely it is that bugs get overlooked - not the other way round. 
That's not semantics that references imply, those are things that references don't offer that pointers do. That's the whole point of references
A string can hold multiple sentences, if you want. It's just text at that point. Or you can have an array/vector/etc of strings, if that fits your need better. And then I read your question again, especially the last part, and realized you might be looking for functions and maybe even function pointers and lambdas. I'd need more information on what you're trying to do, though.
Documentation states it supports Python 2.7 or Python 3.x (even before 3.5).
An enjoyable examination on why and how people choose their programming language is [the Blub paradox](http://paulgraham.com/avg.html) by Paul Graham.
&gt;OP did say the object was expensive to copy. That usually implies that memory allocation is not expensive relatively speaking. Not at all. I'm not necessarily constructing the object, it may already exist. &gt; Also, shared ptrs don't have to manage lifetime, you can construct them so they don't. That's horrible, nobody will expect those semantics. 
Sorry, I don't get what you mean?
I'm not sure how to handle your comment?
&gt; I personally don't think optional should be used for optional parameters. There is very little value add over a pointer ... What if I want to pass a temporary?
You realize who created Go, right?
Pass a pointer to an rvalue ref to it.
&gt; That's horrible, nobody will expect those semantics. Only if you assume that shared ptr has anything to do with shared ownership. Does it make sense why I don't consider shared ptr anything more than reference counted lifetime now? Also, I've certainly seen code which uses a null allocator with shared ptr so it doesn't allocate, and uses pointer aliasing in all construction so you can reuse shared ptr as a pure atomic reference counting mechanism. It might be somewhat uncommon, but I expect such use will proliferate with time. After all, the worst thing about shared ptr is the memory allocation ... so just do away with it. Don't allocate any memory.
Yes and the appeal to authority isn‚Äôt going to get you anywhere. Go is used primarily in internal services and cluster management operating on timescales long than what C++ servers offer. It cannot touch C++ for a number of reasons, lack of generics being the big reason. It is a productivity language in the same class of languages as c# and java (although people can argue all they want about which of those three is best). 
Maybe I'm missing something simple, but how do I get [line 13](https://godbolt.org/z/8xYrla) to compile?
You're the one who made the appeal to authority. :-]
Follow-up: it turns out Rust does do implicit referencing (or borrowing, to use the Rust terminology) in certain situations, presumably to avoid exactly this issue. https://doc.rust-lang.org/reference/expressions.html#implicit-borrows
I'm inclined to use Microsoft PPL or Intel TBB instead of classical thread pools. It seems like PPL and TBB are the optimal strategies for getting 100% utilization on today's massive core-count machines. I'm only a bit worried because NUMA-awareness seems to be only somewhat supported (ex: thread pools should be able to allocate memory "close" to where they're executing. Neither PPL nor TBB seem to give you an easy way to do that, aside from stack-based allocations).
This is good one. Like software HT that does not suck (lol). Hopefully they will update CppCon2018 git with materials from this talk so one can test this himself.
Activate warnings. On the second line, the first const has no effect.
&gt; But are you going to use the same version across every platform you have to support? Conan is pretty good at having the same set of features and behavior with different versions of Python, so I don't see the problem. But if you need to have the same version of Python everywhere, then use Flatpak on Linux and whatever you want on Windows. I don't know how these things are done on Mac, so I leave it as an exercise for the reader.
The functions i wrote were just something generic. there are functions that has two consts one at beginning, one at end. we were using a function like that in my data structures class my professor briefly explained what each of the constants mean but i forgot. Im interested to know what each of the constant do for the 2 const function. &amp;#x200B;
How would you suggest people handle optional function arguments? The natural way to pass most arguments to functions is `const T&amp;`, so if an argument is optional, it should be `optional&lt;const T&amp;&gt;`, right? It has major usability advantages over `T*`, as well as being significantly clearer and more consistent (IMHO).
Unicorn function call syntax had me cracking upon
It's worth noting that for complex types, the first `const` has the effect of slowing down your application by requiring needless copies rather than allowing moves.
If it is a class member function (method) it prevents calling it‚Äôs other, non-const methods or changing its members (fields). const int f1() just means the function is returning a constant integer. https://stackoverflow.com/questions/15999123/const-before-parameter-vs-const-after-function-name-c/15999170
In the future, please submit links as links instead of text posts. I've approved this post as-is, though.
I'm not offering ideas of what to work on, but after you pick something, I'm willing to help you if we use my software in the project. (I might hope that my offer would influence what you choose to work on.)
It could have been much much better.
What would be the use for that though?
&gt; This code may be typical of OOP in the wild, but as above, it breaks all sorts of core OO rules, so it should not all all be considered traditional. This kind of argument is a little weird, "Thing never worked in the wild, but it's because the people don't know how to use it...". If the great majority of programmers is writing the "wrong" kind of OOP, then either there is a flaw in the system itself (that allows for easily going the wrong route), or the author's concept of "core OO rules" is different from the majority (which is also a problem, meaning that these rules are ambiguous). I would also like to add that, showing how small examples in an OOP language are better if you use OOP, instead of a paradigm that is not well supported, is a little bit unfair. I don't think the same thing would hold value if you were trying to write a small sample in OOP, but using a functional language. The ECS example is indeed more like just an "EC", as it's lacking the systems part that would actually work on the components.
I‚Äôm extremely happy that people have come around on the idea that making object oriented programming as the first option of writing basically any software isn‚Äôt the right approach. Especially for all the people that tout c++ performance and speed, and then shoe-horn in layers upon layers of inheritance.
I get avoiding inheritance. It's not a huge overhead but it's not great. But how do you avoid classes in general? Do you use only structs? Is everything you work with just basic datatypes? I want to learn new things, but I've been using OOP for so long I've forgotten how it used to be done.
A video that doesn't start with the shitty songs they play in-between keynotes. Yay
The control block has to be allocated on the heap no matter what you do. The reference count has to live *somewhere*. 
&gt; the main reason is that a lot of people want the short form to still be clearly stating that it is a template, not an actual function; Which is of course still ignoring the fact, that telling them apart is trivial by looking at the types of the arguments: If any starts with a capital letter, it is a concept and the entire thing therefore a template, otherwise it's a regular function. (Yes, I know that many people lack the basic professionalism to use the correct naming-conventions, but if you point a gun at your head and pull the trigger, you don't have to wonder when it kills you.)
Application Verifier?
If you start to have many getters and setters, you should do away with those, use a struct and change the variables directly. Having many getters and setters just indicates you are encapsulating without actually encapsulating anything. You just have a lot more boiler-plate and [potentially] function call overhead. Structs are underused.
https://www.tenouk.com http://www.cplusplus.com/doc/tutorial/
&gt; the main reason is that a lot of people want the short form to still be clearly stating that it is a template, not an actual function. This is partially the reason, but a lot of people are missing another important (and IMO more valid) objection: Short form without `auto` means that `void fun(Something&amp;&amp; val) {}` becomes ambiguous: Is `val` an rvalue-reference, or a forwarding reference? It depends on if `Something` is a concept or a typename.
[citation needed]
I'll recommend you this video by sean parent. It'll give you the idea why it's bad. I could point you to papers if you wanted to but I think the video is straightforward enough https://youtu.be/zULU6Hhp42w
Seems like there's not (m)any options (or tutorials). I will check it out in depth, do my tests and report back on my findings.
Feel free to PM, I'll try to help. Application Verifier is awesome. Zero good docs though. Source: I used to work for MS.
&gt;&gt;It already has to be stored to make the destruction work correctly. &gt; &gt;Why? How else would it know to call the destructors on specifically 10 `T`s?
So cppcon is slowly becoming like any other "tech" conferences. Who is so sensitive that required to block comments on this video? Why not just block all comments and likes on all videos if you are afraid someone will not like what some people might say?
If you want to return optional const reference to expensive to copy objects, well, returning a reference is not a good candidate as it is way too easy for the user to incidentally trigger a copy. Better options are some sort of view object or good old pointer. The pointer is optional by definition and the view can have empty state as well. &amp;#x200B;
No! [Stop tesching C](https://youtu.be/YnWhqhNdYyk)
That‚Äôs good. I like to contribute somewhere 
Thanks 
The comment section in youtube wasn't blocked when I posted it if I remembered correctly. 
I know, it was blocked later. There are other videos like that which after few comments pointing out political or cultural push in the video gets comment section blocked.
I understand for getters, bust most setters aren't `void setfoo(int x) { m_foo = x; }`. Most will notify something from a change, change a display, reperform a computation... Else why are you setting it in the first place ?
You're forgetting `enable_shared_from_this` opts you out of that.
My apologies for the impossibly incorrect earlier reply. I was just about to go to bed. Long day. If you want to pass optional temporaries, use overloading. There's another answer in this thread I'll give detail for. See it.
While I agree with that, there is still the issue of void foo(Concept&amp;&amp; x) What's x? r-value reference or forward-reference?
The whole issue is that even if it's template, that doesn't answer the question.
What you do is use overloading with delegation. So, for example: class Foo { // internal constructor, uses nullable pointers to indicate optional pars Foo(double x, int *opt_int) {} public: Foo(double x) : Foo(x, nullptr) {} Foo(double x, int opt_int) : Foo(x, &amp;opt_int) {} }; And voila, we have avoided `optional`. I appreciate from all the downvoting people here don't get why `optional` in header files is bad. But then they're probably also people seeing non-trivial build times, and they're not getting that the cause is them using `optional` in header files, and using types where the compiler cannot use hash table lookups (like overloading), and instead forces SFINAE to be run on each and every invovation. It isn't widely appreciated that `optional` drags in `string`, the STL allocators, lots of other stuff. If you can stop using any of those fat headers in your header files, and restrict yourself to only those headers listed at https://github.com/ned14/stl-header-heft, you'll see big gains in build times. Indeed, if I'm allowed, I institute a commit hook where I work which tests for anybody including any STL header in any public header not on the whitelist, and if so rejects the commit. One day I hope to get around to writing a SFINAE smell tester, so I can further ban anybody who introduces unavoidable SFINAE execution into public headers. But lack of time, as always.
An optional is stupid. It doesn't track lifetime, or know about lifetime, nor can it. A delegate accessor class would have intimate knowledge of the lifetime of what it delegates. So at the very least, attempts to access via it when its parent has died would produce a nice process termination.
``` kvmap[key] = value; ``` Assume that key doesn't exist in kvmap and that operator[] returns an optional; how would you make the above statement work? 
I've worked with all three apis. I don't find the wx and qt apis to be so very different.
Your suggestion, `std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;`, isn't really what I would call "user friendly". At that point, I'd probably just go for the pointer `T*`
&gt; It'll give you the idea why it's bad I skimmed through the video (who the fuck have the time to watch 1 hour videos seriously ! text or nothing !) and don't see what you are talking about. He is proposing to use task systems instead of traditional mutex-based which is exactly when you should use lock free queues - how do you think that tasks can be passed from the scheduler to the other threads ?
&gt; good old pointer A "good old pointer" tells you little about its contents. When I see a pointer in code, without reading the rest of the code I don't know: * If it's nullable * If I need to `free` it when it's done * If it's even defined - because remember that `T* foo;` is perfectly legal I have seen problems in production code caused by each of these three cases. The whole reason we went towards references and smart pointers was to avoid such issues.
You completely misunderstood the conversation. The issue is to not use ONE queue for all the compute units. Doesn't matter it's lock free or not a single queue system simply doesn't scale. And to employ work stealing, victim selection and etc. And also I posted the video because someone asked for a 'citation'. I posted another comment below on what I suggest as improvements.
&gt; Actually, one last gripe -- Aras calls this code "traditional OOP", which I object to. This code may be typical of OOP in the wild, but as above, it breaks all sorts of core OO rules, so it should not all all be considered traditional. inb4 prescriptivism vs descriptivism
"I thought the standard solution is a single producer, multi consumer, lock free queue?" Yes someone said to do this. Scroll up the comment list please.
This is truly awful. Imagine if the construction of your object were non-trivial, so instead of all these `{}`, you'd either have to duplicate code, or call some additional "construction function" that all the constructors shared. This line in particular, which saves a pointer to a _temporary_ variable and thus exhibits undefined behavior, should show you how trappy your ideas are: &gt; Foo(double x, int opt_int) : Foo(x, &amp;opt_int) {} Note also that `Foo(1, NULL);` will end up calling `Foo(double x, int opt_int)` because `NULL` is an int. I, personally, always use `nullptr` for this very reason. Not everyone else does. I think, however, that you managed to create undefined behavior and not notice it in just a handful of code should indicate how had this coding strategy actually is.
&gt; optional&lt;T&amp;&gt; with a deleted operator=, which I think is the right approach. The whole reason people want `optional&lt;T&amp;&gt;` is to replace nullable, non-owned pointers, because they have extremely unclear semantics. But your suggestion doesn't do that. So what's the point?
&gt; Why not just encapsulate that in it's own class and just assign the variable directly? Then you don't need the setter. because then you will put it in a template because you have 25 different property kinds - e.g. template&lt;typename T&gt; void property { public: operator T&amp;() { return m_impl; } operator const T&amp;() const { return m_impl; } template&lt;typename U&gt; // you want perfect-forwarding, right ? void set(U&amp;&amp; x) const { if(m_impl != x) { m_impl = std::forward&lt;U&gt;(x); // hello template errors my old friend notify(x); // uh oh, now *every member* must in some way store a pointer to the context which will be able to notify. hello memory usage * ~2 for every class } } private: T m_impl; }; of course you wouldn't do this, because this creates so many additional problems that you would be fired at the moment you're suggesting it but still.
yes ? and it does not mean that you need a single one of these queues ? 
&gt; So how do you deal with, say, not finding any results when searching a collection? `it == cont.end()` &gt; std::shared_ptr is a heck of a lot more expensive than a malloc and is also more expensive to use during its lifetime. I'll take benchmarks please proving that a shared ptr configured with null allocator and control block in `enable_shared_from_this` has worst case times slower than malloc. Hint: it isn't, not by orders of magnitude.
It means a queue is shared across multiple consumers. The point is to use a dedicated queue for each consumer.
&gt; , just designate that returning owned pointers must be done via std::unique_ptr or gsl::owned_ptr. We're talking about `std::optional&lt;T&amp;&gt;`, so you're returning un-owned pointers!
Overloading constructors is both spammy, and prone to error. In general, overloading is a pretty trappy technique, and there are a lot of codebases that forbid it entirely - requiring you to have different names for the different methods. I don't go that far, but I have been burnt multiple times in my life by overloaded constructors - either when the wrong constructor gets called, or when someone maintaining the code forgets to change all the constructors when there's a change in how the object is constructed.
&gt; Imagine if the construction of your object were non-trivial, so instead of all these {}, you'd either have to duplicate code, or call some additional "construction function" that all the constructors shared. There can be an annoying amount of constructors yes, but if you're seeing a profusion, you probably ought to be using a construction delegate class instead. So, what you do is create a struct with defaulted member variables, and have it encapsulate the optional parameters logic. &gt; Note also that Foo(1, NULL); will end up calling Foo(double x, int opt_int) because NULL is an int. I, personally, always use nullptr for this very reason. Not everyone else does. You may have missed the internal vs external constructors. &gt; I think, however, that you managed to create undefined behavior and not notice it in just a handful of code should indicate how had this coding strategy actually is. Hardly. You can always pass an address to a temporary internally. It gets more interesting when you need to preserve rvalue vs lvalue input so move vs copy gets preserved, I usually use two internal constructors for that situation, one for copy, one for move, and have the external constructors delegate appropriately. You guys are way overblowing the weight of avoiding Optional in public headers, and greatly underweighting the cost of Optional. Most of the time Optional can be trivially avoided, and with great benefit. However certainly some of the time, especially in source files not header files, Optional is exactly perfect. That's where I use it.
In fairness, youtube comments tend to be a sesspool. On /r/cpp at least, many of the moderators also have a hand in running CppCon. A bottom floor is enforced here.
&gt; I use the word "totally" way too much. I need to change it to something that's different, but means the same thing. "Mitch, do you like submarine sandwiches?" "All encompassingly." ‚Äì Mitch Hedberg [Source: Mitch All Together](http://skulkersbole.tumblr.com)
Very interesting article. Explains a great deal about puzzling failure to inline on specifically GCC, something which had often stumped me. Thanks for posting it.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9mnq62/how_to_build_the_newest_odb_compiler25_b9_from/e7fyh4y/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
Since we have "Throwing values" proposal, there's no need to use coroutines as a hack for implementing more efficient error handling, if I recall google's core coroutine proposalcorrectly. 
&gt; But Optional has multi-modal use cases. ... Sorry, I don't follow, what is your point in first couple of paragraphs? &gt; consider after all the aliasing constructor on shared ptr Aliasing constructor has nothing to do with ownership semantic of shared_ptr. Even if you use aliasing constructor and hand over shared_ptr you *share* your object lifetime between all shared_ptr owners. On the other hand if all that you want is reference counting and safe access without potentially dangling pointers you should hand out `std::weak_ptr` (not `std::shared_ptr`). And then you can use aliasing constructor to give away (weak) pointers to your data members without compromising ownership semantics of your class. Another example of such use case (handing over weak ptr) is `QPointer` from Qt. &gt; if you can afford a malloc during copy construction, you almost certainly can afford a shared ptr to potentially avoid that malloc. Can you describe your idea in more detail? It is not obvious how one can use shared_ptr to avoid malloc during copy construction in circumstances described by previous post author.
&gt; and control block in `enable_shared_from_this` Can you clarify which implementation of standard library allows to have control block inside managed object (enable_shared_from_this is parent of managed object)?
How does `delete[]` knows? `unique_ptr` (without custom deleter) stores just a pointer, nothing else.
Yes, but the comment I was replying to was pointing out that assuming no other convention that this is the current status quo: // ambiguous, assuming no convention, as to whether or not I'm responsible for deleting pFoo without consulting documentation // if I am responsible for deleting it, then this is like an owned_ptr&lt;Foo&gt; or unique_ptr&lt;Foo&gt; // but if I must not delete it because I'm not the owner, this is like a optional&lt;Foo&amp;&gt; Foo* pFoo = get_foo(); I was suggesting to remove that ambiguity by designating that returned raw pointers are always meant to be un-onwed pointers.
It stores the count - which is exactly my point.
Then someone else will come along and say that we can do even better than Core Coroutines/Current proposal. And let's postpone it to C++26.
common...K&amp;R and Turbo C, it's not really 90s
`f(optional&lt;T&amp;&gt;)` would work, `optional&lt;T&amp;&gt; f () { return ref; }` would work; ` opt = optional{foo_ref}` would work ` opt = foo_ref` would **not** work 
best book The C++ Programming Language by Bjarne Stroustrup
so what is your solution then ? Let's say you have the following class : class foo { public: int x() const { return m_x; } void setX(int x) { if(x != m_x) { m_x = x; xChanged(x); posChanged({m_x, m_y}); } } int y() const { return m_y; } void setY(int y) { if(y != m_y) { m_y = y; yChanged(y); posChanged({m_x, m_y}); } } void float radius() const { return m_radius; } void setRadius(float r) { if(!fuzzyEquals(r, m_radius)) { m_radius = r; radiusChanged(r); } } void radiusChanged(float); const std::string&amp; name() const { return m_name; } void setName(const std::string&amp; name) { if(!validateName(name)) return; if(m_name != name) { m_name = name; nameChanged(name); } } void nameChanged(const std::string&amp;); }; how do you `encapsulate that in it's own class and just assign the variable directly?` ? what when you have 200 different class that all have different members but more or less follow this get/set pattern ? 
Lol, that could be UB, no?
&gt; For the record, assigning to an optional in Rust is easy: &gt; let mut x = 5; &gt; let mut y = 6; &gt; let mut y = Some(&amp;mut x); &gt; x = Some(&amp;mut y); // Rebind &gt; x.map(|x| *x = y); // Assign That won't compile. You assign an integer to `x` on line 1, but then try to assign an `Option&lt;&amp;mut Option&lt;&amp;mut {integer}&gt;&gt;` to it on line 4. What exactly were you trying to demonstrate?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9mohog/order_of_books_for_modern_c/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Despite the fact that C appears to give us great control over the generated code, it is not always the case. So the C programming language does not give the people that write kernels/low-level stuff great control over the generated code. #define ilog2(n) \ ( \ __builtin_constant_p(n) ? ( \ /* Optimized version for constants */ \ (n) &lt; 2 ? 0 : \ (n) &amp; (1ULL &lt;&lt; 63) ? 63 : \ (n) &amp; (1ULL &lt;&lt; 62) ? 62 : \ ... (n) &amp; (1ULL &lt;&lt; 3) ? 3 : \ (n) &amp; (1ULL &lt;&lt; 2) ? 2 : \ 1 ) : \ /* Another version for non-constants */ \ (sizeof(n) &lt;= 4) ? \ __ilog2_u32(n) : \ __ilog2_u64(n) \ } If it's this difficult to convince a C compiler to generate the code that people want, why are they using C for new-ish projects? Perhaps there's a need for a programming language that gives kernel/low-level developers a way of generating the code that they want with utmost precision, without having to drop down to assembly language. 
LLVM doesn't actually do the accurate byte counting he's talking about for inline assembly. I don't think it even tries when making inlining decisions (hence newlines don't matter). It certainly could do the counting though. I did actually write a patch to do it on ARM when one of the perennial constant-islands bugs happened; but I never quite convinced myself the complexity was worth it for the tiny number of edge-cases that would be affected.
I did a derp with my identifier naming. See my edit.
This presentation is great, and the kids are just amazing. I mean what the heck, they are talking on that stage being so confident, even joking/playing with the audience, it's so amazing. Many adult speakers, including me, would be less confident. It is really, really sad that such a talk gets so much downvotes... (46/39 up/down votes)... I mean seriously, what the heck? Sorry for the language but what idiots downvote this talk? People not liking girls and kids coming into computer science??? I don't have any words for that. I really cannot imagine what the negative comments could've been, maybe men feeling threatened in their position and power by 12 year old girls, yea, that must be it... Share and upvote this talk.
Two hours ago, there was 1 comment, "OMG where can I get a shirt like Godbolt's? ". Can't say if there were other comments in the meantime but they're now closed. The shirt is great btw o/
I am unaware of a standard library implementation which does not implement that.
Seriously, whether you like the music or not, it's really cool to have a live band on stage. Don't be salty.
&gt; Aliasing constructor has nothing to do with ownership semantic of shared_ptr. Even if you use aliasing constructor and hand over shared_ptr you share your object lifetime between all shared_ptr owners. &gt; On the other hand if all that you want is reference counting and safe access without potentially dangling pointers you should hand out std::weak_ptr (not std::shared_ptr). And then you can use aliasing constructor to give away (weak) pointers to your data members without compromising ownership semantics of your class. You understand precisely. People seem to be surprised it is possible to use shared_ptr without ever allocating memory, so I put together a proof at https://gcc.godbolt.org/z/dEqqnM. The call to operator delete in the disassembly is actually from pthread cleanup by glibc. shared_ptr itself never allocates, nor deallocates, dynamic memory. We supply the storage for it to use from the outside.
The recommended books are on the link in the sidebar of this very reddit: https://stackoverflow.com/a/388282
Only useful when multiple searches in-flight in parallel, right, no problem, but that would have been good to have known from the start of the presentation.
I agree. Too bad they happen to be bad.
Like I replied to the other guy, I agree it's cool. It's just too bad they happen to be bad.
Nope. Async functions could use a wrapper which would check those `weak_ptr`s. template&lt;typename F, class C&gt; auto ChecksWeakPtr(F f, weak_ptr&lt;C&gt; p) -&gt; function&lt;signature_of&lt;F&gt;&gt; { return [=](auto... a){ if (auto pin = p.lock();) f(a...); }; } class C : public enable_shared_from_this { X x_; Y y_; bool async_func(function&lt;void(int)&gt; callback) { async_f(ChecksWeakPtr([=](X x){ x_ = x; async_g(ChecksWeakPtr([=](Y y){ y_ = y; callback(42); }, weak_from_this())); }, weak_from_this())); } }; 
&gt; Application Verifier is awesome. Zero good docs though. I'll have to quote vim. &gt; - A feature that isn't documented is a useless feature. A patch for a new feature must include the documentation. - Documentation should be comprehensive and understandable. Using examples is recommended. 
Do you mean in the call \`bool const result = is\_large\_enough(x)\`, where \`x\` has type \`int\`? Yes, that is an error. Thanks, I have fixed it.
&gt; With `optional&lt;const T&amp;&gt;` you could bind to a temporary I'm pretty sure this wouldn't work, because `optional`'s constructor is going to "use up" the temporary's extended lifetime. Actually it's worse, because it would *appear* to work (no compile error), but the optional would in fact be holding a dangling reference.
I propose that the author of this article is some sort of wizard. 
Well, you say OO and immediately go to inheritance. That inheritance shouldn't be used crazy extensively, and especially not deep hierarchies, is honestly just consensus in the C++ community at this point in time (I'm not saying everyone does it, but basically all of the thought-leaders and people teaching C++ will agree with that). That is why it's strange when people say that, and then act like it's very radical. It's not radical at all, it's just consensus (or as close to consensus as we get in this industry). What *can* be radical in certain contexts about what DOD people are saying, is reducing data encapsulation. But even there, simply changing architecture away from what's most maintainable to a design that allows better performance is not uncommon. So really, to me, the radical, and very unsupported aspect of what's being said in DOD is that loosening data encapsulation somehow improves maintainability.
I liked this article, and agree with it. I've been seeing a lot of DOD articles lately, and I just haven't been impressed. Some of the things that they say are completely mundane (don't overuse inheritance; you need to restructure memory layout sometimes for maximum performance). And others are totally unsupported; notably that reducing data encapsulation magically makes code more maintainable. I just realized a new time saving technique for those articles that I thought I'd share. If you see a DOD article that purports to explain why DOD is an improvement over OO for anything other than performance reasons, just C-f for "invariant". If that word is not mentioned at all or barely mentioned, you can just save your time and skip the article because they are not doing an honest comparison of DOD to well-written, OO C++ (most of the articles I've seen lately did not mention the word invariant).
Well, it was poorly taught for a long time (and still is). The author's rules also aren't really different from the C++ community's; if you look at what thought leaders/gurus (yes these terms are cringe, but I mean people Scott, Andrei, Kate, Herb, etc etc) are advocating, they have advocated for a long time that classes should actually be designed around encapsulation and invariants, rather than inheritance, which should be used sparingly, especially implementation inheritance and deep hierarchies. In languages like Java and C# they have been slower to back away from this, and of course this hurts us too since new grads typically learn Java in school. But it's still not a fair comparison, insofar as if you are going to find a DOD guru and re-design and re-train your codebase and developers around DOD concepts, you could just as easily find a modern, C++ OO guru and do exactly the same thing. If the real problem with OO is that people in practice just can't apply it correctly, then articles arguing against it should explain why that's the case. They don't do that though. They almost invariable take bad OO as *the* OO and start from there, without even acknowledging anything else.
No language can force you to write good code. 
This makes so much freaking sense. I was working on the AVR backend for GCC and was wondering why it would literally process assembly twice - the first time not generating anything and only getting a string length and new line count. Now I know why. The Atmel people did add some heuristics for estimating instruction count, so that helps. I wonder if this would be helped if *all* instructions were exposed via intrinsics. Right now intrinsics are a bit hamstrung. Also, our of curiosity, have they tested with LTO?
Agree: it will clarify many topics, not covered in Stroustrup book. Also you‚Äôll quickly start to appreciate smart-pointers and understand why C++ has new/delete compared to plain C malloc/calloc/free.
No it's not. `enable_shared_from_this` does not hold control block. It typically store weak_ptr to shared_ptr owning host object.
It's worth mentioning that when a contract *violation* happens, the standard provides some [customization points for violation handling](Build_level_and_violation_handling).
GCC has four major problems: * Outdated codebase. It is officially C++. The files are still .c, and the code isn't even good C, let alone C++. It is painful to write for. LLVM is far cleaner, though sometimes overengineered, making it difficult to find things. LLVM plays nicely with IDEs, including Visual C++. Good luck with GCC. * Inflexible maintainers. Writing C++ for the AVR sucks as the g++ maintainers refuse to add the C Embedded Extensions to C++ as they aren't part of the C++ standard. No memory address spaces which are kinda critical on 8-bit Harvard ISAs. LLVM supports them intrinsically. * Split codebase. GCC treats the C and C++ frontends as seperate codebases, which leads to a disparity in functionality and features. I discovered a bug last year (still unfixed) where the g++ front end produced suboptimal code when shifting an unsigned char - it performed an implicit cast to int, but never reduced back. The C frontend handles it fine, despite both languages having equivalent semantics for it. Is a very problematic bug on AVR. Also generates different code for x86, though that code is the same size and speed, so no one will fix it. * Arcane, dysfunctional build system. Lots of custom rules to build submodules. Builds slow. Prevents some optimizations. I am working on a fully-LTOd system configuration of a modified Linux kernel. GCC causes trouble as several modules - libgcc in particular, don't acknowledge flag settings. If you force it, you get link errors as their build system links the object files weirdly. When I wrote my own makefile to build libgcc, it built and ran with LTO perfectly fine. I want libgcc with LTO as it gets included in literally everything gcc builds. LTO enables far better inlining and optimization- incredibly useful for compiler/runtime support routines. Especially on this experimental OS where everything is an LTO object, making dynamic linking equivalent to static performance-wise. * bonus reason: GCC relies on undefined behavior. The default build flags mask any issues. Build GCC with `-flto -fuse-linker-plugin -fno-fat-lto-objects -O3 -g0 -march=native -fipa-pta`, then try to build GCC again with that version. The errors you get are... weird, to say the least. `-fipa-pta` is necessary to cause it. It basically enables a much broader spectrum of cross-module and segment optimizations, but like any other optimization in that class it can expose undefined behavior that otherwise wouldn't be seen.
None of the standard library implementation *I know* implement that. As I already pointed out in another comment control block can not be placed in managed object (and `enable_shared_from_this` is part of the managed object). The reason is simple: 1) control block should outlive all `weak_ptrs` to itself even if none of the `shared_ptr` to the same object is alive; 2) when all `shared_ptr` goes out of scope managed object destructor must be called and it must destroy `enable_shared_from_this` part of the object too. 
I still don't get why they cannot be. They are in Clang, iirc.
In modern C++ these questions can (and do) have definitive answers. For extra insurance one can have both `not_null` and `observer_ptr`. `optional` is modelled around pointer interface and native references are themselvs modelled to be the object as-is. If we take these two into account a pointer is really how an optional reference should behave (pointer arithmetic and other features aside). 
C and C++ already give plenty of precision. Inline ASM is used when you need *specific* behavior that is beyond the abstract machines of C and C++. Intrinsics could possibly handle it, but there aren't presently intrinsics for every instruction. That *might* fix it for the kernel, though. They could effectively write their own intrinsics, force inlined, using one instruction per intrinsic. The writers would know the instruction length, and thus could add the appropriate number of newlines. This would solve both issues.
Thanks, I should probably address that in the following post, which is going to focus on the real proposal ([P0542R5](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0542r5.html)) more then this one.
If they merged the two frontends, it would help.
Yes it what I meant.
`enable_shared_from_this` causes the `allocate_shared` to allocate a block big enough for all state, so the object, and its control block. When the last shared ptr is destructed, it destructs the object, but not its control block. This keeps weak ptrs working as intended. In my example, the storage returned by the null allocator is managed by main(). In the link you sent me https://wandbox.org/permlink/IKhs3vq39pU8c9c6, you're destroying the storage and then using a weak ptr attached to it. Obviously that segfaults. If you move the storage above the weak ptr so it outlives it e.g. https://wandbox.org/permlink/rKEmUC45uxYMIrvb, now it works fine. The (mis)use of shared ptr to implement pure reference counting is not common, but it's also not unknown. I've seen code written by others doing this. That was my point: best to not assume that shared ptr manages shared state. It can be easily configured to do something very different, and if you assume shared ptrs manage shared state, you will get very confused when they suddenly don't, as the unusual configuration is type erased. You can't tell from the outside if a shared ptr is "weird" or not.
can't you use clang in windows?
I would already be happy if destructions would not need to be trivial. I really don't understand the motivation behind that limitation in the c++14 and 17 standard.
Didn't he mention it right at the beginning?
There is this link: https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list. In my opinion, you can start with Scott Meyers and Herb Sutter books before taking on bigger challenges.
&gt; they could iterate fast and in few years they cached up. Intentional pun? ;)
Accidental ;)
`enable_shared_from_this` causes the null allocator you supply to get called once instead of twice.
It's good to see this work being done, but I find it curious why people looking into this talk about this work like it's some new, never before researched or implemented feature. D has excellent support for compile time reflection and execution and has had it for over 10 years. It supports dynamic memory, exception handling, arrays, almost everything you can do at runtime you can also do at compile time. It's not like C++ hasn't taken things from D already, much of which taken almost verbatim... why debate over things like whether destructors have to be trivial, or whether `throw` is allowed in a `constexpr` or other properties as if no one has ever researched these things before and instead leverage much of the work already done on this topic? It's not like D was designed or developed by an obscure group of people, it's Andrei Alexandrescu and Walter Bright who did much of the work on it, these guys used to be major contributors to C++. I guess it feels like rather than learning both the benefits and the mistakes from existing languages, C++ is taking literally decades and decades to reinvent things that are well understood and well researched concepts.
Nope. That's all `allocate_shared` (or `make_shared`). `enable_shared_from_this` has zero, nothing, nada, nil to do with it.
&gt; enable_shared_from_this causes the allocate_shared to allocate a block big enough for all state No, `std::allocate_shared` allocate block big enough for object and control block even if object does not have `enable_¬≠shared_¬≠from_¬≠this`. Mayby you had in mind that it ["enables" `shared_¬≠from_¬≠this` with pointer to allocated object](http://eel.is/c++draft/util.smartptr.shared#create-9) (which means that *if* type have an unambiguous and accessible base class that is a specialization of `enable_¬≠shared_¬≠from_¬≠this` then it initialize inner weak pointer of `shared_from_this` with pointer to allocated object, [see this](http://eel.is/c++draft/util.smartptr.shared#const-1)) &gt; This keeps weak ptrs working as intended. Yes, control block being allocated **outside** managed object (and outside its `enable_shared_from_this`) is what keeps `weak_ptr`s working. &gt; In my example, the storage returned by the null allocator is managed by main(). ... If you move the storage above the weak ptr so it outlives it e.g. It does not make any sense. How can you move your storage that it guaranteed to outlive `weak_ptr`s? Consider that `weak_ptr` can be static in other translation unit. [Simple example with static weak_ptr and UB](https://wandbox.org/permlink/uey8klslab0Uv9YZ). &gt; best to not assume that shared ptr manages shared state. IMO this advice fails sanity check. `shared_ptr` [implements semantic of shared ownership](http://eel.is/c++draft/util.smartptr.shared#1). `weak_ptr` should not engender undefined behavior even if it is created with static storage duration in other translation unit. You should not assume Machiavelli. And as a side note such usage of `shared_ptr` is obviosly does not check *any* of the boxes: "Safer, code more closely reflects intent, no lifetime issues".
Books or websites are good for learning minutiae and the like: but they won't intensely improve your abilities as a daily C++ programmer unless you use them. The absolute best way to do this, imo, is to have some kind of personal project you can work on for at least a few hours a week. The more hours you pour into pushing yourself to try new C++ things, or to implement new knowledge you've picked up, the better. Keep your personal project something you can enjoy working on, and break it down into small chunks. I use a [trello board ](https://trello.com/b/F5LTrTTT/diamonddogs) to help myself track minor tasks, and to keep me motivated by keeping my long-term vision intact (and so I can write down new exciting ideas I have, and not forget them!). If you're tired after work or not feeling it on a weekend, just try to get started a little bit for at least 15 minutes - if you get sucked in (which happens a lot for me!) then that's great and you should keep going. Otherwise, don't push yourself to the point of burnout. It's helped me a ton: a few years ago I had never programmed before. Now I'm lucky enough to find myself interviewing for mid-level to nearly senior-level positions at some companies, despite lacking a degree and having only a few years programming at all (sure, my data structures/algos game needs work, but I am working on it!). Don't be afraid to learn from open source repositories (give credit and check the license though!). Transcribing good open source code, or trying to rewrite + optimize less ideal code (this was my initial experience, lol) to be cleaner and to use modern C++ are both excellent exercises. Transcribing is really underrated imo: I rely on it less nowadays, but it was SO useful in the beginning.
Well I see 1. The name and it's validation should be it's own class `ValidatedName` or something. This is by far the most common pattern of incorrect usage of getters/setters. Instead of having a `std::string` with the validation logic inside the getter/setter, extract out to it's own type. 2. As far as these listeners go, it's not something I commonly do. For a one-off I'd probably do as you wrote it. If I have 200 classes which all follow this patter then yes absolutely this duplication should be removed by extracting out a template. Duplicating logic in 200 classes sounds awful.
Well understood and well researched _for other languages_ does not equate to much for every language. Just because D does something does not mean that that thing can be easily retrofitted clearly into C++ without lots of research and redesign. D's design and evolution doesn't have to contend with 30 years of history (50 if you count C) and billions of lines of existing production code. Let's also not pretend that D is perfect. Just because D does something or does it a particular way is not a good reason to automatically assume that C++ _should_ do that thing. If we wanted D, we'd use D. C++ has been inspired by a few D features, certainly, but they end up rather different in C++ often for very intentional design reasons.
&gt; No, std::allocate_shared allocate block big enough for object and control block even if object does not have enable_¬≠shared_¬≠from_¬≠this. Mayby you had in mind that it "enables" shared_¬≠from_¬≠this with pointer to allocated object (which means that if type have an unambiguous and accessible base class that is a specialization of enable_¬≠shared_¬≠from_¬≠this then it initialize inner weak pointer of shared_from_this with pointer to allocated object, see this) Ah, I see where I have become confused now, thank you. So from my perspective of mostly looking at the assembler generated by C++, the effect of `enable_shared_from_this` is to enable the avoidance of memory allocation because the weak ptr attached to the object retains the lifetime of any previous allocation, and thus it gets reused rather than a new allocation being performed. This confused me, and I have thus generated much noise on this topic. Thank you for sticking with teaching me. I appreciate it. &gt; It does not make any sense. How can you move your storage that it guaranteed to outlive weak_ptrs? In the code I've seen, shared ptr and weak ptr get abused as part of an internal implementation which is wrapped up into an externally less evil looking presentation. I had thought there was a race in there, and spent several days investigating, but ended up finding the race elsewhere. Anyway, point is that the weak ptrs are controlled, they don't leak. &gt; You should not assume Machiavelli. That assumes non-anti-social programmers. As a contractor called in to work with code written over decades by many bored programmers in multinationals, I have learned to assume little about what evil people weave to stretch their legs when confined. I had a really fun week last year dealing with a guy who was dynamically restamping the vptr during object dispatch to "convert" the virtual function table between unrelated types. That sort of "fun". &gt; And as a side note such usage of shared_ptr is obviosly does not check any of the boxes If you look back, I never suggested that for the original point. I argued against reference optionals, and suggested that for expensive to copy things which you may want to only lazily copy, returning shared ptrs may be a better refactor. I certainly do not recommend to anyone to subvert the commonly understood meaning of shared ptr. That is anti social, and nobody should do it. Nevertheless, when you look at a shared ptr, remember it erases how it was configured. I've seen people inject a signals and slots implementation into shared ptr destruction. Bored programmers do terrible things.
If you think you can contribute, please write a paper or contact people in the committee that are working on these topics. Saying *"why don't they just do what D does"* is frankly ridiculous as there are no guarantees that D compile-time features are compatible with the way C++ works (compilation model, object model, abstract machine, etc...).
I did see that, but didn't delve too deep. I guess I'll take a closer look now. Thanks.
But I don't think I can contribute, I think there are already enough experts in this area that have already made contributions to CTFE and my advice is to work with them to integrate the already well understood solution to this problem instead of acting like C++ is so unique and requires such extensive consideration that C++ has to reinvent this whole thing from scratch, and take decades to do so. Is it really frankly ridiculous to say in an informal chat forum that we reach out to people who've already spent a decade working in this area successfully? Do I have to write a PDF paper and e-mail it to Herb Sutter in order to make that suggestion? May as well not discuss anything on /r/cpp about how to improve the language or the process, anytime someone wants to comment just tell them to write a paper and e-mail it to a member of the C++ committee. I think that suggestion is a way to silence criticism rather than promote discussion and get feedback from the community. I will also remind you that the two people I mentioned, Walter Bright and Andrei Alexandrescu, did do exactly what you say; they submitted a paper on `static_if` back in 2013 and the response made by Bjarne Stroustrup was that their proposal was a disaster that would destroy C++ (those words are in the actual response). That was the last time either of them participated or bothered working on anything related to C++. Three years later a slightly modified version of their proposal was accepted as `if constexpr`, but the damage was done.
I do see some of those jobs, and I'm curious where these people are learning the skills to code like that, since there's not many resources online. I'll try to learn more about the linux kernel. (Actually, I was interested in that after hearing about the mailing list drama, but I was a bit intimidated to join since they have like 1000 emails a month and it doesn't look that easy to get started, and code quality standards seemed to be a gigantic deal.) I searched for Carl Cook C++ on youtube, but it doesn't look like that person has an official channel. But I do see a few loose videos. (Actually, I watched one of them before lol.) Thanks for pointing him out. Are you saying to get employed by one of those companies? I can try, but...(lol) Thanks again!
good to know. 
This looks pretty awesome. The API seems like a bit of an acquired taste from the look of it, but feature-wise this is pretty much what I've been looking for for a while plus a few scoops more!
This was an extremely interesting presentation.
Yay for implicit behavior that does things it doesn't say it does!
Very interesting! Apparently this has just been released and unfortunately the talk, or more info on this is nowhere to be found online.
How does allowing `try/catch` inside constexpr look if we have deterministic exceptions?
The lectures by Stepan T. Lavavej are terrific (also always look for lectures by Herb Sutter or, of course, Bjarne Stroustrup. [STL lectures on STL](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-) [STL lectures on c++](https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-) 
I have also found the extension Concurrency Visualizer which has perfect reviews. Check [here](https://channel9.msdn.com/Blogs/LarryLarsen/Concurrency-Visualizer-High-Speed-Tour) - video may be old, but it applies for today (for Community edition). It's not a sanitizer, but provides nice and detailed visual inspections on the multithreaded behaviour. Not enough though. I'm still checking on App Verifier..
&gt; Typing it sucks Calm yourself that it sucks less than m\_iWidth that I need to use when editing some pieces of code at work. '&amp;', '\*' '(', ')', '-', '+', '='; arent't these like the most common special characters in C code? We have to live with these as well, you better get used to it. &gt; It's an extra spacing character. (...) seeing code fit horizontally on the screen (...) underscores just makes this worse The biggest point of prefixing private members, that I sort of took it granted you were aware of but it seems not, is that when dealing with member functions you instantly see which variables are the private members. An extra spacing character is just what we need. It's not the kind of additional horizontal space that makes your code too fat, a ridiculous proposition. &gt; I also think it uglifies names IMO We could use maybe a Unicode cat symbol, why not, or account for it with syntax highlighting or text styles or whatever to indicate which the private members are. For now, people use 'm', '\_' or their whatever combinations most often, it may be even beautiful if you submit to your programmer eye and realize the benefits. &gt; No editor in the last 10 (or 20?) years lets you access a private member unless you are inside the class CRTP, friend classes? &gt;Or do you follow the ideology maybe ... &gt; &gt;This has never been a concern nor does it play a role in the decision to use underscores. Of course it does, it is a major counterargument against marking private members. &gt; I became accustom to reading \_\_lol \_\_something = \_\_iter\_ecks\_dee Little contradiction there? &gt;On that topic, C# uses UpperCase With C#, for private/protected member variables practically all style guides use camel case, some advise the underscore prefix ([link](https://en.wikibooks.org/wiki/C_Sharp_Programming/Naming#Class-level_Private_and_Protected_Variables)). If you want some C++ libraries/frameworks utilizing underscore prefixing for member variables, on the top of my head I can mention Cocos2D-x, Magnum or sqlpp11. I could list hundreds more here, successful ones, if I invested addtional time, I'm pretty sure. Viewed from the class's member functions or other logic accessing its state, variables constituting the class's state should be considered special as opposed to other variables. This should be especially true if the representation of that state is complex and not structured sufficiently (which is the dominating real-life scenario). Prefixing is a primitive and aged but still very common and very much effective way of achieving this off-the-shelf distinction. Is it the future as well? No, but nor are 90% of all other convensions and methodologies of ASCII coding. &amp;#x200B;
This was reported as off-topic due to being about C instead of C++. I'm approving it due to upvotes, interesting comments, and possible C++ relevance; other C posts will not necessarily receive the same treatment.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9mplkv/are_there_any_open_source_c_financelowlatency/e7hb8ni/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9mlr5j/learning_material_recommendation/e7hbajz/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You can update your code base bit by bit. That's a way to learn modern programming. I wrote a post just the other day about some of the changes in modern C++. It's by no means definitive but it might help: https://www.reddit.com/r/algotrading/comments/9lswzs/is_a_masters_in_financial_engineering_or/e7dgojp Just take it slow, one piece at a time. Pace yourself.
I'm not sure I follow the argument about leaking objects if the operation runs too long. Can you elaborate or maybe give a code sample that shows what you mean? There are mechanisms you can use to interrupt/cancel an async operation if you no longer want the result. eg. using a cancellation_token
That's discutable (aka the ambiguity is the problem). The issue is that for humans it's ambiguous, whatever the rule is happening. What if Container and Comparator are suddenly concrete types? Then this code becomes r-value references. What if the concepts are used in a member function of a template class? then they are not template, so it's r-value references. Etc. I'm not saying it's an issue to define the behavior from the standard pov, I'm saying the ambiguity it shows when reading the code and maintaining it (because the code will probably change a bit through time) makes a big (for some people) point against having a non-obviously-template syntax. I myself would be ok with it I think but that ambiguity on reading still makes me unease. And I'm saying it's the reason that basically stopped people considering not making it clear it's a template and they started proposing ways to make it visible without being too noisy, basically.
Right, I mean what you're mentioning is the issue that I'm aware of. If it's a templated in both arguments or not does answer the question though. Also note this ambiguity already exists currently in the sense of member functions, although with a member function you should be aware that you're inside the class or implementing it non-inline based on the prototype. So, adding this to the standard, you only need to know two things to know rvalue vs universal: first is whether it's a member, but you already have this problem. Second is whether they are concepts or concrete types. Which is handled by the naming convention that started this whole thread chain, but I agree that's not a great solution.
&gt; take bad OO as the OO I agree that it's a problem in some posts, when authors use an OO based approach that you can clearly see that it'll fail (like showing that inheritance is bad by coding a diamond inheritance), and then presenting whatever their point is and how it's much better than OOP. But I would like to take this argument more towards the side of "why do we have so much bad OOP code, when a bunch of our languages were designed with OOP in mind?". C++, Java, C#, these languages were designed by experts, but they all easily allow bad OO code to be written, why is that? Also, why is it so hard to define what OOP even is? Some early definitions just say that it's all about objects passing messages to each other, other say that it's about modelling our world into the machine, and you can find some more definitions, but if you look at the functional programming paradigm, it's pretty simple to say that it's about using a mathematical function style.
Indeed, but they can make it easier to write good code. Modern C++ allows you to express concepts of ownership, for example, much easier than old raw pointers only C++.
Can somebody point me to where in the reflection proposal, provisions are made for annotating functions/members with attributes? (if any). For example, in games, we often decorate only a subset of class members that we intend to serialize. In some cases, we may annotate other members with data that should be server visible only, or only modifiable in an editor with cheats enabled, etc.
If it takes forever to compile, then you should look into your cmake/qmake file. &amp;#x200B; If it takes longer than the usual to compile, you should consider the followings. * Avoid unnecessary header inclusion by taking advantage forward declaration, pimpl idiom, private class. * Try to use standard c++ in the non-front end part * Use a distributed build system and a compiler cache. &amp;#x200B; &amp;#x200B;
&gt; A burrito is a sleeping bag for ground beef! ‚Äì Mitch Hedberg [Source: Mitch All Together](http://cynicsaccelerants.tumblr.com)
So far the consensus is if you throw in a `constexpr` context, that's a compilation error period. Considering most people also approve removing most exceptions of the language, it shouldn't be much of an issue.
I don't see what the big deal is. There's an instruction manual.
very very true! :)
Re: interview questions: 1) Go to: [careercup.com](https://careercup.com). On the top there's a link, 'questions', which leads to a multi-dropdown, by company, job, language, etc. 2) pick C++ or algorithms or ... 3) gorge.
I was thinking about that during the talk, but there's a catch. What exception would you actually catch and handle at compile-time? Unless we add compile-time stuff to interface with the build environment (e.g., read a file available at build time into a constexpr string), I can't think of any exception I would actually handle.
after studying the guideline, I agree with you and deleted the OP.
I'm definitely looking forward to all of this getting in, but for the reflection system I am authoring soon for my company, I will likely be a pass as there will likely be no way to support the functionality required without macros sadly. The best use-case I've come up with for the featureset presented in this presentation is using AST inspection/modification to automatically instrument callgraphs or allocations with profiling data and/or telemetry.
If he did, I missed it, just like the guy, who was there and who asked the question regarding this [that's when it dawned on me too].
I don't think it should require metaclasses. Plus, since you have the name as a string you could do regex (that will be constexpr) on it for pattern matching anyway, so if you want to have some kind of custom meta attribute you can do it. C++ is trying to avoid making people write insufferable boilerplate so a sane proposal with good arguments could make it in the standard. I think than matching on the existence of `[mycustomattribute]` is saner than matching on variable decorated like `foo_mycustomattribute`.
No need for macros, you can reflect on the name. It's ugly to put attributes in the name of the variable, but it's better than macros.
No that‚Äôs completely false. Relying on variable naming to handle attributes that might change or if you have multiple attributes (that need to be ordered somehow) or differently typed attributes. You‚Äôve just described a hell I would never want to be in, much less create for someone else haha
Your post has been automatically filtered because it appears to be spam (it was a link to imgur.com). If you think your post should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Spam%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9mwbkh/can_someone_help_me_out_with_this_code/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
You can refactor names, if you have a good IDE that's not going to be an issue. I still take extremely ugly TMP over macros and this, while far from perfect is nowhere as bad.
Do your own homework please
!removehelp
Please ask this question in stack overflow. [Grabs popcorn to watch how mercilessly one can get bashed and humiliated in a few minutes]
[https://nuwen.net/stl.html](https://nuwen.net/stl.html)
Hey. I‚Äôm Stephan T. Lavavej (‚ÄúSteh-fin Lah-wah-wade‚Äù), and I‚Äôve worked on MSVC‚Äôs STL since 2007. I‚Äôve also worked on several Standard proposals that were accepted (notably the transparent operator functors). I filmed a bunch of videos for MS‚Äôs Channel 9 years ago, introducing various Core Language and Standard Library topics, and I‚Äôve given talks at C++Now (formerly BoostCon) and CppCon which have been recorded. I‚Äôm also a subreddit mod (my username and user flair are hiding in plain sight in the sidebar). My current obsession is C++17 &lt;charconv&gt;, which is close to complete (floating-point is a lot of work). But I‚Äôve spent the last few days applying clang-format to our STL, which is almost ready to be checked in.
/u/STL might have something to say on the matter while he's not busy kicking ass.
My favorite method that I know of, depending on the use case, is to have a separate tool generate the reflection info from the C++ code. I.E. you can make a Clang tool to parse your code and encode the reflection information in generated C++ code. This works best if you only need the information at runtime.
!removehelp
I once implemented Tessendorf water in C++/CUDA, posted some videos on YouTube, tweeted the videos and got my tweet re-tweeted by Nvidia.
He starts explaining it from ~12.25. Prefetch can help you if you know in advance, what memory location you are going to access and the CPU can't predict it on it's own. 
That's a very good idea!
Name mangling to encode information comes with its own source of issues (extreme difficulty in using an inspector attached to a debugger, scary unreadable callstacks and compile errors), not to mention needing to mangle things at the call/use sites... I think you're trying too hard to come up with a fast solution to something that has a lot of demonstrably productive usage. For reference, here are all the property specifiers Unreal supports: https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers I'm not advocating for something that piggybacks off the existing C++ attributes system (although that could be extended to support a user-defined set of attributes), but literally anything that could be used to convey data/information to the reflection system that would not otherwise bloat or change the actual base type itself.
I'd the is one thing the committee isn't lacking it is papers for laguage features. A well researched paper making more library facilities constexpr might be welcome though (it's ridiculous, how long it took them to make std::array constexpr)
Lol
Wow that sounds impressive. Especcialy tweet part of the story) How long did it took you to implement?
Hey there, just wanted to say that I'm a fan. I've seen your video tutorials on the C++11 changes and they were a great introduction!
Oh, this was like 10 years ago so I don't remember. A week or two maybe to get it working, and then a lot of tweaking. I was a student back then though, so I had a lot of "free" time. ;) I didn't write everything from scratch either, though. I used a rendering engine, found a library to integrate CUDA with the engine, CUDA has a library that I used for the fast Fourier transform. So in the end it the work I did was just to implement the Tessendorf paper in CUDA...
Nice to meet you! It's very difficult to track you down by googling your initials. I just searched for my initials (mps) and discovered a file format for linear programming that dates back to the punch card days. 
Wow now, how does this flagging syntax work?
Yes, starting in VS 2019! We still need to use `_Ugly` names to avoid clashing with user code, but the indentation and braces will be nice.
Great job! The thing that bothers me is requiring the use of a macro without a _good_ reason. Would love to hear if you do have an excuse though ;)
People aren't likely to read a long-winded "clever" introduction to some random person's library. A concise list of benefits and examples would be far more useful than "don't use boost cuz I don't like it" type anecdotes.
That‚Äôs pretty funny since my full name is globally unique. üò∏ Welcome to the file format initials club, MPS! Apparently (and ironically), STL is a file format for 3D models.
Glog is too big and complex for my smaller projects. I don't want to trought the pain to add new native libraries to ios and android unless I really need to. Logfault is header-only, and just a few hundred lines of code.
Are you still filming new videos? I loved to watch your old ones!
She was the queen of all tortoiseshells, the very template from which all others were instantiated.
If you are compiling with msvc use [jom](https://wiki.qt.io/Jom).
Macros are not evil. They are one of C++'s big advantages over most other languages. Often, other constructs are better, but for things like logging, macros are very commonly used, and quite useful.
Same. He's easily my favorite C++ educator and wish there was more content. 
Good point.
Macros are powerful, but they do not belong in the user-facing API. They are great when you need to reduce boilerplate or provide mechanics that the language cannot yet (reflection, metaclasses, etc...), but I believe that the API should be ‚Äúvanilla‚Äù C++.
Are you using VSCode primarily for development, even given the availability of VS Pro? I'm interested to hear a perspective on that from a MS employee. I've tried VSCode (Mac/Linux) for some small things, but I didn't consider using it as a full C++ IDE. Currently using CLion, but I'm starting to feel like I'm not using enough of CLion to justify the cost? For me the visual debugger is the real value-add.
Then how do you provide the file and line of the log line in an optimized build? You are trying to pass off your opinion as a widely held standard, which is isn‚Äôt.
I politely disagree. Macros have a bad reputation (like goto), but some times they are the right answer. Notice that I only use macros to map expressions like this: ::logfault::LogManager::Instance().IsRelevant(level) &amp;&amp; ::logfault::Log(logfault::LogLevel::ERROR).Line() into a short macro that is \*much\* more readable for the developer. The macros are good citizens and have a prefix so that they don't pollute the global name-space. When you use the non-log statement API there are no macros.
&gt; Often, other constructs are better, but for things like logging, macros are very commonly used, and quite useful. I have heard this argument over and over (I heard it in the context of unit tests: "we do not use macros, except in unit tests where it's somehow OK"), and I think it's bogus: Parts of your code are not lower priority than other parts. Parts of your functionality may be a higher priority, but all your code should be kept at the same standard of quality (because code quality is there to ease maintenance and readability, and these are equally important in logging code and in any other code). You should not consider macros acceptable _for logging_ but not for the rest of your code (if you add logging in your code, the logging code _is_ your code). I would write an abstraction for a logging class, that embeds the `if (log_event_log_level is within current_log_level_range and we_are_indeed_logging)` part within its functionality instead. 
I never forget the shock I had when I learnt that it was not obfuscated code but it was just written this way intentionally :o God bless those souls who use it all the time.
That's definitely going to get fixed, though some are keen on a GC-based cleanup of constexpr destructed objects instead. My objection to that is if we make P1031 *Low level file i/o* entirely constexpr as some on WG21 want, then how do we close file handles during file handle destruction? How do we launch and control child processes from constexpr if we can't clean up after they exit? Besides, there's the consistency argument, why adopt GC in constexpr and no GC without?
I've implemented a library of data structures for great iteration and lookup speed : https://github.com/im95able/Rea
Current plan is that deterministic exceptions work fully within constexpr. In other words, they do not fail the compile.
The long term plan is to add file i/o to constexpr, and memory mapped files, but I actually think that's ancillary to this. If WG21 like the P1095 formulation of P0709, then that's all constexpr capable. In other words, proposed `std::error` is 100% constexpr throughout under a future not-quite-existing-yet C++. So you can throw and catch such value based exceptions without issue in constexpr, it all works exactly as at runtime. One fun quirk in this is that some P1028 code domains can't be available at constexpr time. So, for example `posix_code` can't have a message fetched from that, because that calls `strerror()`, and `strerror()` in the compiler might not be the same on the target running the program e.g. if we are cross compiling. So in truth only a subset of failure can be thrown and caught at constexpr. But it's a big enough subset that low level file i/o would work seamlessly at constexpr, and thus is probably not a showstopping limitation. For example, running out of memory absolutely ought to be supported in constexpr, but as OOM is process termination under P0709, within constexpr it means instead fail the build. 
* "they look like function calls or variable": Not if we follow convention and use UPPERCASE\_NAMES for macros. * "they pollute the global namespace": Only if you are Microsoft. I use PREFIX\_ANNOTATION so, in my case LFLOG\_ to ensure that the macros are unique, and don't collide with anything else. * they ensure that what the programmer and what the compiler see are different things: Some times that is a good thing. It's actually intentionally. Do you want to see '::logfault::LogManager::Instance().IsRelevant(level) &amp;&amp; ::logfault::Log(logfault::LogLevel::ERROR).Line() &lt;&lt; "hi"', or does 'LFLOG\_ERROR &lt;&lt; "hi"' look better? If you prefer the first, none prevents you to improving your code quality by writing unreadable rubbish - if you can live with a little lower code quality, at with the benefit or readable code, the library support that as well. * when you debug code, macros are a source of obscurity: That's most relevant for your own code. I can live with the pain of debugging my quite simple macros to make my life, when using the library, much, much simpler. Btw - I don't think I have manually expanded macros for debug purposes for at leats 10 - 15 years. And those m,acros were comples. The m,acros I use here are very simple and easy to read. * "they are tricky to write correctly, with many "gotchas"": No, they are not. Not the macros in this library. They are very simple, and easier to read than most templates. * "outside of a handful of exceptional cases (cases which cannot be avoided) they should not be used": That's religious bs! I'm an atheist. I do what's practical and gives what I believe is the best result. * "Macros are a good solution for C, where there are a no actual tools for writing generic code." Macros are useful for a lot more than quasi templates. * "this is a symptom for laziness (the bad kind of laziness, that makes for unmaintainable code down the line).": It can be that, or it can just be the best way to solve a problem. When a macro is the best solution, then it's justified to use it. It's that simple. In code, as in life - be pragmatic. Use the best tools at hand, and don't over-complicate simple things. 
Note that your implementation can never be as efficient as something implemented in the Standard Library, as [`std::get`](https://en.cppreference.com/w/cpp/utility/variant/get) on a `std::variant` will check the index (you're already doing this, so it's unnecessary work). What we need is some sort of `unsafe_get&lt;T&gt;(v)` that is UB unless `v` is actually a `T`.
That makes sense.
Interesting, I didn't realize constexpr file I/O was planned in any capacity beyond the couple of attempts at a utility like that one file literal proposal. I also look forward to seeing P1095 in the upcoming mailing, even though I caught the draft :)
I have been working on making [one with Vulkan](https://github.com/gan74/Yave) for about 2 years. It's super basic (I have probably spend more time working on non graphic things than on the rendering itself), but I acquired most of the skills I use for my day job while working on this thing.
&gt; Ideal choice (from the future): help SG15 (the group reflecting on tools vs C++) define interfaces for build systems and dependency managers so that your choice is not impacted by your dependencies choices. This indeed would be the ideal solution which would allow any package manager to work with the same project. I'm worried if it's utopia though.
It actually was raised originally as a joke at Rapperswil, then a whole bunch of the senior leadership came down on either loving the idea or hating it. So I guess it has some legs. But need to get P1031 into the standardisation track first!
I have written a small library providing STL-like algorithms for an improved version of an esoteric [poplar heap data structure](https://github.com/Morwenn/poplar-heap). The part I liked the most was that it was a project that I could actually finish, while most library project constantly grow and reach design issues along the way. Having a small and defined scope was really nice.
The compiler should be able to optimize away the second check inside std::get, because it can see that it was checked before and cannot change, right?
Wow, what a username to have. How old is your account?
No documentation link on github readme?
To add to your point, and that of another commentor below, logging is generally one of the very few places where macros are common practice (in my understanding it‚Äôs because preprocessor depdendent things like __FILE__, __LINE__, and __PRETTY_FUNCTION__ by definition wouldn‚Äôt be useful if you were to expand them elsewhere).
Have you written it for fun or are you using it yourself? From first glance I'm imaganing you are frequent participant in hackatons and such :-)
While I don‚Äôt think they cause any harm, I think the question of macros / non-macros aren‚Äôt very relevant here (given that you are providing a macro free API). I have yet to see a professional codebase where logging wasn‚Äôt a macro of the form PROJECT_NAME_* and implemented interally as some non macro based call to a third or second party API.
hi /u/STL, would you mind if I used your job template for the r/Qt5 subreddit ? 
&gt; Not the macros in this library. They are very simple, and easier to read than most templates. And yet there are problems with macros in your library: - Some are not side-effects safe. They use their arguments many times, which leads to any side effects being repeated. Use `do {int level_=level; /*...*/ } while(false)` idiom to avoid that. - Some are un-parenthesised, which leads to problems if they are used as part of larger expression involving operators with higher priority or wrong associativity. Surround macros in parentheses to avoid this kind of problem. 
You know when people tell you that you can't begin your names with an underscore? It's because he's using them.
Is that a reference to concepts?
&gt; "they look like function calls or variable": Not if we follow convention and use UPPERCASE_NAMES for macros. You could have a global variable called `LFLOG_ERROR` and the client code would look the same. When I see a single token in code (a single word identifier in this case) I assume it can be treated like a variable. This is a block of code (behaves like a function, but is not a function; looks like an object instance but it is not an object instance). &gt; Only if you are Microsoft. I use PREFIX_ANNOTATION so, in my case LFLOG_ to ensure that the macros are unique, and don't collide with anything else. You are saying that _when these macros pollute the global namespace_ that's fine, because nobody else will need to name a variable with your prefix. My point was they pollute the global namespace, not that you need to prefix them with something unique to ensure this pollution is not a problem. &gt; Do you want to see '::logfault::LogManager::Instance().IsRelevant(level) &amp;&amp; ::logfault::Log(logfault::LogLevel::ERROR).Line() &lt;&lt; "hi"', or does 'LFLOG_ERROR &lt;&lt; "hi"' look better? This was my point: this is a false choice (macros almost always have a better alternative): I would rather write code like this: error_stream &lt;&lt; "hi"; with error_stream being an object instance; No `::logfault::LogManager::Instance().IsRelevant(level) &amp;&amp; ::logfault::Log(logfault::LogLevel::ERROR).Line() &lt;&lt; "hi" in client code is required in this case. **Nor would a macro be required either**. The macro is not the solution, it is a way of hiding a problem with your API. I will stop this conversation now, because I'm in office / have work to do :(. 
&gt; my full name is globally unique At least you don't need a namespace.
&gt; We never get logging right, do we ;) Spdlog seems to have gotten logging right. https://github.com/gabime/spdlog
I upvoted your response; it directly and materially responded to the point being made, which was very welcome. With that said, I read the static_if proposal response by Stroustrup *et al* (linked in a response below). Sure enough, the first sentence says that adoption of the proposal would be a disaster for the language. But I don't think the authors were wrong. In cases of incoming disasters, I think urgent language is warranted. Unlike, say, the kind of response that a Linux Torvalds would have made in a similar situation, I think the tone stayed respectful despite its urgency. I think this response actually did avert a disaster, so we should be glad they wrote it. I don't have a very strong opinion about how many people should be involved in the language definition, but in this case the three respondents were not a random assortment; they were three of the stalwarts of C++ language definition and implementation. How do you think this situation should have been handled differently? Maybe the different answers will come down to whether this proposal was actually an incipient disaster in the making.
&gt; These two functions are both Template Functions, but they don't look like Template Functions For full correctness: *template function* is an incorrect term. It's a template (noun, not adjective), not a function and therefore named *function template*.
It's also a JetBrains tool for making your own DSLs: https://www.jetbrains.com/mps/
Does this mean you are no longer upstreaming your changes to Dinkumware?
You are writing a newline, which is not an exact newline character, but gets converted to an OS-specific sequence of characters that goes to the next line and first column.
I have no idea if it's RES giving me this info, but it's ~11.25 years old.
That's not really true, if you call get_if and things get inlined then the check will be removed. 
The problem with `error_stream &lt;&lt; "hi";` is that 'hi' will be evaluated even when logging is disabled. Without macros you will have to express the condition to log nor not log something in code. That makes the code less readable.
I understand for functions and things that aren't considered "public" why this is done, but why is this sort of thing done for local variable? I haven't looked at MS STL headers but in both GCC and Clang local variables use double underscore prefixes.
It is that 30(50) years of history that I think is the real root cause of the frustratingly slow progress. The fact that we have so many people involved in the language standardization is just a more proximate cause; we need so many people because there is so much history. Even if far fewer people were involved, those remaining unfortunates would constantly be mired in a game of whack-a-mole, trading one set of unacceptable interactions for another. Sometimes it makes me feel like C++ is a lost cause; I grow tired of waiting for modern features to arrive that are available *right now* in other languages. Unfortunately, those other languages have not yet gained the benefit of network effects like C++ has. But the main problem of C++ is *also* a network effect. At what point do the liabilities of the network effects outweigh their benefits?
Good observations. Thanks. I'll see what I can do about that.
Nice puzzle, I guess `......` is the most confusing and making it `..., ...` makes the template much easier to understand. Isn't it actually UB? The standard prohibits taking address of any standard library function.
Might add it to github readme.
&gt; The problem with error_stream &lt;&lt; "hi"; is that 'hi' will be evaluated even when logging is disabled. You say this after you spoke of being pragmatic. Optimizing for when things will be evaluated _before measuring such things or setting concrete measurable performance goals_ is premature optimization.
It looks like a nice library, yes. What my library have, that they don't (please correct me if am I wrong) is Windows event-log and cocoa (IOS) support out of the box. They have lot's of other nice stuff though. 
I'm using C++ from 1992 and wrote a lot of code. Some code was awful, some looked nice at the beginning, but I opinion changed after some time. Some of that code have beed rewritten or thrown out, some are still in use even after 15 years after writting. And I have seen how small and beautiful code become complex and ugly with time. So it is hard to select something that I really like. &amp;#x200B; But one project suprised me. It is small library [timertt](https://sourceforge.net/p/sobjectizer/wiki/timertt%201.2/) for work with timers. It was written more than 4 years ago, it still in the use. But there were not so many updates to it. It just works. And this is strange for me because the code that is in use usually requires some maintenance, addition of new features, some refactoring and deletion of some old and rarely used stuff. But not in that case. And this is still suprising me. &amp;#x200B; The library was created as an attempt to remove such heavy dependency as [ACE](http://www.dre.vanderbilt.edu/~schmidt/ACE.html) from some of our projects. We used ACE for such things like threads, mutexes, hash-maps, timers and so on. But during switching to C++11 we removed almost all ACE's stuff except timers. It was a hard decision to throw out ACE completely because it has a rich set of timers implementations. But we make it and wrote own implementation. It was an interesting challenge and I can say: don't do it :) If you need timers take something that already in use (ACE, Asio, libuv, you-name-it).
Exactly! Huge fun here too. Wish he had an YouTube channel. I can watch him talk all day.
[GCC 8.2 does not](https://gcc.godbolt.org/z/wWzFmt), but Clang and GCC trunk do.
I hear he uses the std namespace
/r/NominativeDeterminism
So macros are bad. Streams are bad. Is this a Java group?
Can you share your clang-format config?
I know that logging from my code on trace level take a lot of CPU, no matter what log framework I use. I have measured that many times over the years. Once I increase the performance of a server around 90 times by applying a similar optimization. Not constructing objects and building log-messages 60 times during a single REST call from a cheap Android phone is a good thing. Being pragmatic != being ignorant.
More of a C++29 group
Apart from formatting, do you intent to move implementation details into a dedicated "`namespace details`" (or whatever) to avoid polluting the `std` namespace? If not, is it reasonable to have some kind of smart filters into Intellisense to hide such implementation details since as a user of the stl, I don't really care about them? I have filled a suggestion report through Visual Studio but it was dismissed :'(
Change *"will be removed"* with *"can be removed"* and I will agree with your statement. 
Game engine with: networking, serialized, virtual file system, properties, logger, gui, scripting language, real-time editing and many more. But within this project the thing that I'm most proud of is [BitSerializer](https://gist.github.com/spaxio/b758b927aa1aa8656fa9bf1a6c8f842c). If you have an object with bunch of fields that you want to send over the network you can use SerializeBits to fit some fields inside a single variable (16bit in this case). This function will be used for serialization and deserialization (depending on **&lt;TYPE&gt;**). template &lt;typename TYPE&gt; void SerializePublicPart(Serializer&lt;TYPE&gt;&amp; archive) { archive.Serialize(Pos, Vel, ForceY); archive.Serialize(Hold, JumpForce); SerializeBits&lt;u16&gt;(archive, Bool(Jump), Bool(NeedRest), Signed&lt;2&gt;(ExtraJump), Bool(CanJump), Signed&lt;2&gt;(Walk), Bool(Flip), Bool(Drop), Bool(KeyState.Left), Bool(KeyState.Right), Bool(KeyState.Jump) ); archive.Serialize(SpawnBlockIndex); } &amp;#x200B; &amp;#x200B;
https://en.cppreference.com/w/cpp/experimental/source_location
It‚Äôs in experimental meaning that there is no guarantee that the API will stay the same.
actually, gcc 8.2 does optimize the check inside std::get https://gcc.godbolt.org/z/aJK8Pe
What does this have to do with C? I personally prefer using printf over iostreams some times, simply because they are faster to use.
Of course, but you wanted a macro-free alternative, so I provided you with the best one we have right now.
* main without int * first define all variables * printf and putcher =&gt; that's C.
To guarantee that they will never clash with user-defined macro names.
Curious then that it does not optimize away the check in __gen_vtable_impl which is called by std::visit. cmp BYTE PTR [rsi+8], 0 jne .L13 ret .L13: sub rsp, 8 mov edi, OFFSET FLAT:.LC0 call std::__throw_bad_variant_access(char const*)
And I always thought you just really really like the standard template library :S
My current project: NavDB ([http://navdb.io](http://navdb.io)). I'm working on v0.3 which will add persistence.
You are using streams which are slow. You are using scaled down version of QDebug.
Interestingly, gcc 7 and 8 are able to optimize away the visitation when using the implementation proposed by @imgarfield: https://godbolt.org/z/Er5ZXB https://godbolt.org/z/665TzY
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
&gt; main without int Without `void` it's not C either.
&gt; main without int That's not C.
I tried to create a library for precomputed real-time GI like [Enlighten](https://www.siliconstudio.co.jp/middleware/enlighten/en/) about a year ago, just for fun. &amp;#x200B; [Screenshot 0](https://i.imgur.com/LCxtNIE.jpg) &amp;#x200B; [Screenshot 1](https://i.imgur.com/QLognxq.png) &amp;#x200B; After analyzing Enlighten and all of its available documentation, the result became pretty good. But there were still a few bugs that prevented me from putting it on github. Didn't have the time to fix them and refactor the code, and I thought it's just not worth the effort anymore. It was a lot of fun though!
Not STL, but a former MS employee here. Very few people within Microsoft use Visual Studio, especially in the older teams like Windows and Office. When I worked there, the most popular editor was Source Insight.
I think you're comparing apples and oranges here. Languages sponsored wholly by a large multinational use a "break the world" version upgrade system which leaves behind all the code written for the older version. Most people who think these new languages are great don't think of the costs of lock in and getting orphaned until it's too late (they'll learn!). Besides, for many C++ is evolving far too quickly. I'm also on WG14, and they've been pondering the problem of exception handling for thirty years now, and only now are willing to add that to C having given it the proper consideration. They disagreed with C++'s implementation as being rushed and not fully thought through back in the 1990s. They were not wrong. WG14 are also pondering things like Reflection, constant execution, generics and lots of other stuff which C++ has or is getting soon. But they'll take what they think is the right number of years before deciding. So in the end, it's all relative. It's the balance between moving too early and having to break the world when you fix your mistakes, or waiting until the dust settles before deciding on something. C++ is currently right in between the upstart languages, and something very conservative like C. It's probably a reasonable balance, give or take.
Macros, or why we can't have nice things.
How did you paste git diff with color to your website?
Thanks for the info. That's kinda surprising, although I guess there's no reason it should be. I don't know anyone in this office that uses the "company editor" \**grin*\*
That's rather surprising. Can you elaborate on why VS Pro is not more popular?
I've been working on a finite element + automatic differentiation library for the last year that uses expression templates and lots of modern C++ features so that you can evaluate various discretization quantities using simple mathlike expressions. It will probably be another year before it is ready for public release. 
Yes, that is true. I would not use this library in a an application that normally logs a lot of information. But for occasional logging, and for debugging on various platforms, it is quite useful. 
&gt;the most popular editor was Source Insight. What a surprise! But it's really the best tool (or one of the) to navigate in large code bases. 
Ah, right. I suppose that's also why user code shouldn't use `__`: to prevent user code from using STL macros?
Wrote a multi ip camera video recorder and on demand adaptive transcoding service.
"Can be" is obviously more technically correct, but if this does in fact happen in all production grade compilers (which I think it does) then "will be" is a lot more useful and meaningful. "Will be" (possibly suitably qualified) is the only thing that can really guide both evolution of the language, and how we write our code. Example, btw showing there are no extra branches: https://gcc.godbolt.org/z/Hf8oJu
Technically, it is at the language level. Your implementation is allowed by by-pass any template magic and produce the code "in line" as it can for all other library types.
&gt; the best tool (or one of the) to navigate in large code bases. Depends on what you consider "large" :) VS was not able to cope with a code base I worked on. You had to turn all useful features like Intellisense and Code browsing off and use it as a plain editor. Some people did that, but most opted for different editors.
Where's the gets-autocorrected initials club at?
Is the destructor of constexpr variables promoted to static storage executed ? 
It is just wrapper around existing macros (builtins) [https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/experimental/source\_location](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/experimental/source_location) \- so no, it is not any better than macros, actually another layer of unnecessary code.
Am I the only one with "Lisp!" screaming in my head? 
Be aware that substantially editing your post is not helpful. Post a reply to yourself instead. Regarding Rust, I am willing to bet a silver euro they'll have to hard fork that language at some point. Same as Swift and Go have done. Lots of obvious cruft in there, cruft that will be too tempting to not sweep away with a hard fork. Remember that Mozilla don't have the deep pockets of Apple and Google, maintaining cruft is a bigger ask for them than for others. Besides, I'm ever more convinced that Rust is not the future for systems programming. I think it's Nim minus the GC. The fact it compiles into C++ is exactly the right future. I would not be surprised if a future C++ 2.0 were exactly like Nim minus GC, but with mixed source possible in the same source file because the compiler would compile both seamlessly. You then use Nim-like C++ 2.0 for high level safe stuff, and dive into potential UB, C compatible, C++ 1.0 whenever you wish. 
It doesn't matter how it's implemented underneath if on the outside it behaves like a normal function that respects namespaces and is a first class citizen of the language. 
I know of hotspot but this one is for Linux only as its based on perf-tools [https://github.com/KDAB/hotspot](https://github.com/KDAB/hotspot)
It is short but it is fast. [PegSolitaire solver](https://wandbox.org/permlink/NmRx4ehI47FvQjl2) which can solve [English board](https://en.wikipedia.org/wiki/Peg_solitaire#Board) in less than 1.5 ms.
My best project has been a game server emulator, especially the networking part as it allowed me to create all sort of tools ([https://i.imgur.com/qkhlHrX.png](network viewer, DSL+compiler ...). Currently working into making it an actual framework.
\_\_FILE\_\_, \_\_LINE\_\_ etc. are part of the standard and all know what they do. So would you use boost.format for example to do some formating stuff and say "It doesn't matter how it's implemented underneath" even though everybody knows it sucks donkey balls? &amp;#x200B;
Oh God I'm another MPS and I used linear programming a bunch in my last two jobs :-/.
This, +1000. We're aware of what other languages do (sure, maybe not all of them), but it's hard to find something that works with the rest of the C++ language and with existing compiler implementations. I'm not saying the Committee is never guilty of NIH, but in most cases it's just more complicated than "take this from another language and bring it in as-is."
Thank you for your time and effort on this series. I'm coming from Stroustrup's PPP text so I've been looking to upgrade my GUI kit from FLTK. I'll start on part 1 and hit you with feedback when I catch up.
it was a windows tool if i'm not mistaken - also with flamegraphs, here on reddit (cpp, programming,...) announced last week i think
Try this: logfault::LogLevel GetLogLevel() { std::clog &lt;&lt; "GetLogLevel\n"; return logfault::LogLevel::ERROR; } int main() { LOGFAULT_LOG(GetLogLevel()) &lt;&lt; "message"; } 
Also try this: LFLOG_IFALL_ERROR(false : "this should never be printed" : "this should be printed"); 
Clearly, only Java people think streams and macros are bad. Not, like, every single other language in existence that uses something more similar to printf and avoids C style macros.
https://www.superluminal.eu/
 isn't that a country song?
VTune is sort of like VTune, and it's supported on Windows. There is also the free Windows Performance Toolkit, by Microsoft, that has the core hooks built into windows itself. https://docs.microsoft.com/en-us/windows-hardware/test/wpt/ Personally, I prefer the Windows Performance Toolkit. The command that you often run for WPT is called "xperf". Bruce Dawson's blog has a lot of information on how to use it well. https://randomascii.wordpress.com/category/xperf/
The reason you have to use macros to write a reasonable (as defined by me), high level, logging API in C++, is because C++ with very very rare exceptions does not have ways to delay/avoid evaluation. If you wrote your API like this: my_debug_log_sink &lt;&lt; get_hello_world(); Then there will always be a call to `get_hello_world()`, no matter what, even if your logging ostream has a branch internally to do nothing, *even* if that branch can be determined to be untaken at compile time. And the compiler is very likely to ever prove that it doesn't need to call `get_hello_world`, so this will not be optimized out. When you see a macro like this: MY_DEBUG_LOG_SINK() &lt;&lt; get_hello_world(); What's often happening underneath the hood is that the macro expands to something involving say `&amp;&amp;`. This is one of the few places where you truly avoid evaluation of an expression in C++. If you set this up correctly and carefully consider operator precedence, you can make the above code work out so that `get_hello_world` really isn't called when logging doesn't happen. The only alternatives to a macro, are to either have eager evaluation in user code by default, with them writing out ugly if statements by hand to avoid expensive debug-only function calls for logging purposes, OR to have the user use &amp;&amp; directly. Both of these options are extremely bad, and I'm pretty confident (from long experience with loggers with macros in their public API) that macros are the least evil choice here.
Whoa. 20 years ago, someone at my company really loved Lex and Yacc and invented like eight domain-specific languages. They are all horrible. Such a high learning curve for so little payoff. Just extend a popular scripting language, don't reinvent the wheel.
On the side note, `LogManager` in not fully thread safe: `level_` should either be atomic or protected by mutex.
This has all changed with coroutines. You‚Äôre fully in control of when shit gets done. Operators can be coroutines :)
Sorry but this just isn't a serious stance in this context. If you work at a high performance shop and you are writing a piece of generic utility code like a logger, unless you know in advance that you *never* plan to do any logging in performance critical paths (and this is basically never the case), you are definitely going to consider performance very carefully from day one. It's really more the opposite: you typically try to make the logger as fast as possible, and then you constrain your usage of it to parts of the code where you can live with that performance hit. And you're definitely not going to be ok with user expressions being evaluated even when logging does not occur; expressions especially in debug logging can be extremely expensive to evaluate, so it could do massive performance harm. Either that, or users will notice this, and will be forced to write their own branches, which is a mess as well. Either way, this is a terrible API. Yes, I agree with your points about why macros are bad from above, but it's a question of making the right trade-off in the situation. In practice, here a very small amount of very simple macros vastly improve the API. Logging APIs are maybe the best use of macros in terms of bang for your buck, that I can think of, in the whole language. Emulating reflection, one of the other most common use cases for macros, by comparison, requires *much* more complicated use of macros.
And finally, try this without defining LOGFAULT_ENABLE_ALL: for (int i = 0; i &lt; 10; ++i) LFLOG_IFALL_WARN("log message"); std::cout &lt;&lt; "something else"; Do you still claim simple macros are easy?
You are the chosen one for C++ heritage
Do you mind expanding some on what in Rust you think will require breaking changes and why you think it isn't the future for systems programming? I'm not familiar with Rust, but I'm starting to look into it and I figure learning about its weaknesses would help me understand it better and make better decisions about when to use it. I thought Go was supposed to be pretty good about non-breaking changes after 1.0, and that Go 1 code is intended to compile and interoperate just fine with Go 2 code. That doesn't seem like that bad of a hard fork to me.
You mean like "Romanes they go the house"?
You'll have to show me a simple example of how exactly you can write and use a co-routine based API, that can entirely prevent the evaluation of `get_hello_world`; it's not obvious to me how it can be done.
So, you're saying rather than inventing make, we should have just stuck with shell scripts for building our code?
Boost has [`any_range`](https://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/range/reference/ranges/any_range.html), which is (depending on your religon) strictly better.
Thanks for pointing that out! The only problem I see with it is that doesn't really work for output iterators.
&gt;I switched to that after one of my more popular applications had an exploitable buffer overrun bug in a log function using "C" like printf() syntax back in 1998 or 1999. This isn't necessarily a problem with `printf()` syntax; it's more just that C's `printf()` (and C in general) is unsafe. See [fmt](https://github.com/fmtlib/fmt) for an example of type-safe `printf()`. `spdlog` uses `fmt` behind the scenes, so modulo bugs you shouldn't need to worry about vulnerabilities in the format string. &gt;It's also faster to write LOG &lt;&lt; "hi " &lt;&lt; 1; than to write LOG("hi {%d}", 1) and the code is simpler to read - especially when there are lots of arguments. I'm not sure stream syntax is simpler to read once you have to start using stream modifiers. Keeping track of them (especially if you have to use both ones that reset after something is printed and ones that remain in effect until something else is set) can be a huge pain compared to the more declarative syntax you can get with `printf()`\-style strings.
For me the single biggest mistake in Rust is the borrow checker. They stop you compiling code which could ever exhibit one class of memory unsafety, and while that's fine and everything, I think if you want to go down that route you're far better off choosing Ada or something similar. There is also a lot of cruft and poor design choices in their standard library, and I suspect without evidence that Rust won't scale well into multi million line code bases because of how arsey it is to refactor anything substantial in a really large code base. As much as C++ has its failings, it does work reasonably well in twenty million line - per project - code bases. Go 2 hasn't been decided yet, but they currently believe the standard library will change dramatically, so source compatibility might be retained, but all your code will need upgrading. Also, as much as Go is better than others, they've never attempted binary compatibility. Compare that to C++, where I can even today link a C++ program compiled with Visual C++ 4.0 back in 1993 into VS2017, and it'll probably work.
I'm going to name the next .NET high profile project "Project Lavavej" just to mess with you.
There was a discussion in Future Proposals list: https://groups.google.com/a/isocpp.org/forum/?utm_medium=email&amp;utm_source=footer#!searchin/std-proposals/any_iterator|sort:date/std-proposals/DWbZboFYCnY/ulhZXB-zEwAJ And the corresponding proposal https://github.com/Shaktal/any_iterator/blob/master/any_iterator.md I do not remember the full conversation in the list but I remember that the one of the early requests was a more convincing motivation
The first benefit can at least be that it doesn't use boost.
Well, in his defense, SCons is maybe an easier learning curve than Make (okay, it's not, but play along), and it's just Python, not a DSL. 
I developted a 2D Arcade/Rougelike Platformer (http://botlikegame.com/) for the last five years with two friends (I was the sole programmer). Its complete C++ (but using cef for the gui) with opengl+glfw for the base windowing/drawing stuff and many other libraries for various tasks but no overall framework. The basic problems for gamedev at 2d aren't that hard, but I leaned a lot on how to design systems to be somewhat modular/abstracted and still allow interaction with many parts of the game. So overall i would guess i learned alot about the design of "larger" applications (this is arround 120k loc).
The professor of zoology at Berlin University is called Mr. Elepfandt.
Oh boy! Oh boy! A new Kate Gregory video!
&gt; they look like function calls or variables, if you edit your code with notepad.exe I guess ? never in my life has this been a problem for me
&gt; Calm yourself that it sucks less than m_iWidth that I need to use when editing some pieces of code at work. Your English is weird there and I can't quite understand what you are trying to say. Please clarify for me what you mean. I also hope that's not some kind of hungarian notation to indicate an integer or else I'm not sure if you're trying to troll me with Poe's law or not. &gt; '&amp;', '*' '(', ')', '-', '+', '='; arent't these like the most common special characters in C code? We have to live with these as well, you better get used to it. I type these much less frequently than I do variable or class names. Autocomplete takes care of brackets so they aren't even a problem. &gt; The biggest point of prefixing private members, that I sort of took it granted you were aware of but it seems not, is that when dealing with member functions you instantly see which variables are the private members. An extra spacing character is just what we need. Why would you say this when you _know_ I already addressed it later on in the post? A bit disingenuous... and you _even commented on it_ as well. &gt; It's not the kind of additional horizontal space that makes your code too fat, a ridiculous proposition. I think you thinking it's okay is ridiculous, but to each their own. I'm guessing you haven't had to do a merge where you have 3 files open to compare the original/yours/upstream and get to see those nice long lines wrap around in a very ugly way. &gt; We could use maybe a Unicode cat symbol, why not, Why are you just saying random things? I've clearly made the stance I want less characters and I'm sure (...hope?) you're smart enough to understand that I'd feel just as negatively toward this facetious suggestion. &gt; or account for it with syntax highlighting Which as I already said, has been in editors for the longest time already... &gt; For now, people use 'm', '_' or their whatever combinations most often Definitely disagree here, I don't see the 'm' prefix often at all... in fact, rarely. I've seen '_' come up a in C++, but never at any place that I've worked nor any of the side projects or public repositories I've contributed to. You'd think if it was that "often" that I'd have run into it at least once by now in some professional setting or some public library I'd contribute to. If we're talking about Python that is a different story, but we are on a cpp reddit after all. &gt; it may be even beautiful if you submit to your programmer eye and realize the benefits No, sorry, disagree fully. There is no beauty. I've tried to adapt to it since I had to deal with tons of underscores when handling Python code and PHP (once, never again). It had ample time to 'look' pretty but it always ends up looking ugly. Having coded in it in Python, there were no benefits. This argument is also stupid because I could just say "it may be even beautiful if you submit to your programmer eye and realize the benefits to not use underscores" Remember, I don't care what you find beautiful or not. It means absolutely nothing to me. &gt; CRTP, friend classes? Whats your point? If you should be able to access private members depending on your scope then the IDE allows it. If this is not your point, please be more clear. &gt; Little contradiction there? There is no contradiction there. I have clearly stated that I think it is ugly. Just because I got 'used' to reading it doesn't mean I suddenly think it's not ugly. If anything, this is further evidence against your previous point of "may even be beautiful if you submit to your programmer eye and realize the benefits" since I had to spend enough time to where my eyes skipped over it and I still think it's bad. &gt; With C#, for private/protected member variables practically all style guides use camel case, some advise the underscore prefix (link). Fair enough, I take back what I said on the C# (where I am blindly trusting the wiki link you sent me without doing any more research because I don't care much about what you have to say to waste any time verifying it). &gt; If you want some C++ libraries/frameworks utilizing underscore prefixing for member variables, on the top of my head I can mention Cocos2D-x, Magnum or sqlpp11. I could list hundreds more here, successful ones, if I invested addtional time, I'm pretty sure. You probably could list hundreds more, and I wouldn't care because other people using it doesn't make me want to use it. As I said, I will only use it when a project requires it from the tech lead... and that is all. Overall the only thing I partially feel bad about at the end of this is that I'm leading you on to think I care what you say when I don't.
Yes, exactly, make sucks! But seriously, I'm saying the opposite -- instead of inventing a one-off solution that no one understands, use a standard tool.
He is the alpha, the omega, *and* the lambda.
I would argue that SCons is a DSL, albeit one internal to python (discussions about internal vs external DSLs are another can of worms). In any case make is just one common example. There are DSLs *everywhere*. Regular expressions, JSON, HTML (and its many relatives), LaTeX, SQL, UML, even the markdown in this very comment box.
Other that preferring the WPT, what was your general opinion of Superluminal?
Thanks. Well, it's not UB for sure. If I'd take an address of function from `std::` (what I initially did), behaviour would be unspecified (see [comments above](https://www.reddit.com/r/cpp/comments/9lv7ge/c_puzzle_8/e7aj7lp)).
Those are not from github. I generate colorized html from markdown with [https://github.com/trentm/python-markdown2](https://github.com/trentm/python-markdown2)
I wrote a regex puzzle generator. Unfortunately I don't like creating UIs. 
/r/OfCourseThatsAThing
__FILE__ and __LINE__ are not visible to the compiler, only the preprocessor. When something goes wrong in a statement i.e. with __LINE__, the compiler will only spit out a number without the semantics that it came from a file line.
&gt; Are you using VSCode primarily for development, even given the availability of VS Pro? VSPro is *GREAT* when you're doing debugging but since the cpptools team is doing so well with intellisense so far it's otherwise pretty useless, the only good things that VS has over VSCode are semantic things such as the testing library, that template pre-see how it'll work with a specific type, some debugging systems. however, it's hilariously slow for large codebases, which the STL *DEFINITELY* counts as considering there's... ~300 compiled files at a minimum with ~200 headers. There's also a lot more configurations than it seems for it, so...
My field is audio-related, so usually I either develop a plugin that processes sound or generates it (like a musical instrument). This particular one was a lot of fun to do. It's called "Bass Slapper" and basically emulates how a bass player would move it's hands on a bass guitar, while you're controlling it from a midi keyboard. [https://www.youtube.com/watch?v=YMQCAaWm\_MQ](https://www.youtube.com/watch?v=YMQCAaWm_MQ) Essentially, it's a 'smart' sampler, making many 'decisions' for you to sound a bit more contextual and realistic than your standard sampler. All of it was written in C++, using some libraries and tool written internally at the company where I work (Waves Audio), but the core of it is just a lot of real time time logic using standard C++11/STL, while being really cautious of when you allocate memory to avoid audio hiccups, etc.
I've been using C++ to create a game engine which can run the original DOOM. http://www.twitter.com/DOOMReboot
We'll never know without trying. Some people are proposing it so that will probably test the water.
And `range-v3` has [`any_view`](https://github.com/ericniebler/range-v3/blob/a469d99b891bb8039221313874d7d626e00e7de9/include/range/v3/view/any_view.hpp)
Ha! Just looked up my initials and mine is the file format of some Chineese academic journal software. Go figure. I wonder what percentage of the population has initials that represent some file format.
There are times in my day job I even have to use MPS files, though thankfully not that often. There are extensions to deal with SLP too.
We're going to miss your master-level trolling (and donuts) :-)
Oddly enough, the ugly names remind me that I'm writing production code, so I have to remember all of the other conventions that we need to follow (e.g. avoid ADL when calling pretty functions, True Placement New paranoia, comma/addressof paranoia, etc.). I'd still like to avoid the ugly names but they aren't that bad when you get used to them.
Yes - it also prevents non-macro conflicts, like name lookup issues (ADL and templates can grab things). For example, when we call a pretty function like equal, we need to qualify it as `::std::equal(args)` to avoid ADL hijacking. When we call an ugly function, we don't need to bother - `_Equal_helper(args)` can't be hijacked as long as users are being good kitties.
I don't think that's true. If you want other people to use your program, C++ is going to be where you start, since run times don't come for free. Having some sort of VM instead of a straight shot from language to instructions is huge, even webasm requires it.
I've never owned a cat myself (when we got Peppermint, my sister and I promised our parents that we'd do all the work, scooping the litterbox and so forth, they just needed to buy supplies - then we shirked all of the work and just played with the kitty). I might get one, someday...
Yay, that's exactly what I was hoping for! :-)
One year too in C++, a few more years in programming tho. The project I'm most proud of is the one I'm working right now. It's a implementation of the cho-protocol, a protocol used by a rhythm game called "osu!" to communicate between client and the server. I've teamed up with a friend and decided to reverse engineer the way client and server communicate to build our own server. We've now reached a stage where the vanilla osu! client can successfully connect and almost all features of the original primary osu! server (named "osu!Bancho" and hosted by the game developer) are implemented.
Speaking for myself, not for Microsoft or even as a typical Microsoft employee: I learned C++ in an unusual way, with unusually spartan editors (originally DOS Edit, then Metapad for over a decade - it's a clone of Notepad wrapping a rich edit control instead of an edit control). For me, switching from Metapad to VSCode was a step up in editor complexity and power (I was initially excited about multi-caret editing, and I've discovered much more since then). I've dropped Metapad except for the rare occasions when I need to print something, or edit in Windows safe mode. I also used Source Insight to browse large codebases at work (I learned SI when I worked in Office and kept using it), but I've entirely dropped SI now - VSCode search has superseded it. I didn't learn C++ in an IDE, so my habits are different from most programmers'. It took me a while to get used to syntax highlighting while editing, and I still disable autocompletion. When I need to debug a program at runtime, I use full VS (I've never put in the effort to learn WinDbg). I use it in a weird way, though - since my console test programs aren't VS projects, I launch the debugger with `devenv meow.exe meow.cpp`. (I do debug full projects if they're user repros, which is infrequent.) I see that VSCode can debug but I haven't tried that yet.
Let us know how you like the previews of VS 2017 15.9 and the upcoming previews of VS 2019 - early feedback *really* helps us improve the experience.
I think the dangers with printf() like arguments are solved today in most languages, including C++. I agree that the stream modifiers some times are a pain. But logging something that takes many arguments, like strings and digits, is much simpler to write with streams, than to match formatting token and argument. Take for example this statement from a real project: ```C++ LFLOG_IFALL_TRACE("Creating node " &lt;&lt; fromBip32Path(work_path) &lt;&lt; endl &lt;&lt; " key: " &lt;&lt; toHex(new_key) &lt;&lt; endl &lt;&lt; " pub: " &lt;&lt; toHex(pub_key) &lt;&lt; endl &lt;&lt; " ext: " &lt;&lt; toBase58Check(ext_key) &lt;&lt; endl &lt;&lt; " pxt: " &lt;&lt; toBase58Check(pub_ext_key) &lt;&lt; endl &lt;&lt; " d: " &lt;&lt; depth &lt;&lt; endl &lt;&lt; " ix: " &lt;&lt; index &lt;&lt; " (" &lt;&lt; (index &amp; ~HARDENED) &lt;&lt; ')'&lt;&lt; endl &lt;&lt; " hard: " &lt;&lt; (isHardened(index) ? "yes" : "no" ) &lt;&lt; endl &lt;&lt; " fp: " &lt;&lt; finger_print ); ``` Logging such statements will be a challenge with Python's string.format() expansion, not to mention expansion that require data-types in the formatting-tags. (And then, god forbids if you change the data-type for some variable, after you write the log statement. With streams, changes, like from int to int64_t adapt automatically). 
We would still need `_Ugly` identifiers, so `_Details` refactoring would just add complexity and not improve the appearance of our headers. I'll ping the IDE team about hiding ugly identifiers for autocomplete (we talked about it informally in the past).
There is nothing wrong with this. There are more optimal solutions, but whether it is a bottleneck would depend on how long the tasks are and how much can be run concurrently.
Why bloat and complicated a program if you don't have to? Not having a rabbit hole of dependencies simplifies a project not only for the person who creates it, but for everyone else who wants to work on it, or even just compile it.
If `LOGFAULT_ENABLE_ALL` is unset, nothing is logged from the loop, but `;` is still a statement in the if loop, so it loops 10 times without doing anything, and then prints "something else". What's the problem with that?
That cat on the picture on the right is being sqeezed too much or has seen some things he is not meant to see :/
It could. I have generally avoided that in the past in similar places to avoid negative impact on the CPU cache for very frequent tests - to great objections from some true C++ purists. In practice, it has worked fine, although, theoretically, it could cause logging on the wrong level. So I could / should add an option to use an atomic variable. 
The fun part is that one of our DSLs ran too slowly, but we already had tens of thousands of lines of code written in it. So someone wrote a utility to convert it to C++. The result was almost unreadable (but it worked, and it was faster!). Here's a real snippet (below) from the bad old days (although I tweaked some details for legal reasons). It's all been rewritten and/or cleaned up since then. if ((((hlotqty) &lt; ((zzzNum)0)) &amp;&amp; ((FindSingleTaxLot) == (0))) || (((((hlotqty) &lt; ((zzzNum)0)) &amp;&amp; ((FoundTheTaxLot) == (0))) &amp;&amp; ((FindASingleTaxLot) == (1))) &amp;&amp; (((txn-&gt;lot_tax_lot_txn) == (cntxt-&gt;_ADJLUMPCOST)) || (does_txn_match_taxlotid(cntxt, txn-&gt;lot_tax_lot_txn, txn_data-&gt;getTaxLotLevelEvent())))))
What's Nim doing so well that convinces you it could be the C++ 2.0?
To be honest, I like Boost very much, and I use it a lot. But not in all projects, and so far, never on mobile. 
So, this is then the "every single other language in existence", and not C++ group?
Designed mostly on my own, because I have quite a lot of spare time and I can afford to redo things again and again until I'm completely satisfied with both the result and the code quality :) I'm not really a theory guy but I should really read more about this to learn faster ! 
Hey I have a question question about Clang format, and I'm wondering if you have noticed it too. Let's say I have a source or header file that contains conditional macros Here's a basic example that's similar to the intent, but far simpler in the implementation than where I originally noticed this: #if (defined(__UNIX__)) #define _FILE_OFFSET_BITS 64 #elif (defined _WIN32) #define _UNICODE #endif (I have the clang format option IndentPPDirectives enabled) In Clang on Mac, when I use clang-format, it will only format the enabled code, so on my Mac it will only reformat the unix line. Does it do the same for you? is there just something weird about my configuration? I'm thinking about submitting a bug to them, but I really don't want to look like an idiot (anymore than I already do for preemptively submitting bug reports)
&gt; Overall the only thing I partially feel bad about at the end of this is that I'm leading you on to think I care what you say when I don't. Quite reduntant of you to say that at that point, there's been numerous hints about how rigid your mindset is. How you focus on less relevant details instead of the big picture, ignoring fully the essence of the problem. And even during criticizing the details you do it so sloppily: &gt; Your English is weird there and I can't quite understand what you are trying to say. Please clarify for me what you mean. I also hope that's not some kind of hungarian notation to indicate an integer or else I'm not sure if you're trying to troll me with Poe's law or not. Indeed I stated what you replied to with bad English, it happens, was it unclear? Hardly. m\_iWidth? Of course it is Hungarian notation; by the way, Star Citizen, one of the greatest undertaking in game development history uses this exect convention. Oh and your Poe's law smarty-pants observation is still as invalid as it can be. &gt;I type these much less frequently than I do variable or class names Too bad we were talking about private member variables, not all variables and class names. &gt;Definitely disagree here, I don't see the 'm' prefix often at all Did you notice the context already implied the use of marking for private member variables? I only stated which are, or could be, the most common ways of doing it in that paragraph. &gt;Remember, I don't care what you find beautiful or not. It means absolutely nothing to me. Haha, you would be a great villain too. You're starting to amuse me. &gt;No editor in the last 10 (or 20?) years lets you access a private member unless you are inside the class &gt; &gt;CRTP, friend classes? &gt; &gt; Whats your point? What's my point? My point was to point out you were factually incorrect, or at least how you phrased it made it very much seem as if so. When someone corrects you you just spit out whatever's on your tongue and avoid admittance at all costs? How neat! &amp;#x200B; There are jobs where people who are bad at holistic and clear-minded thinking are good for. Jobs that, to bluntly say, don't have to do with software or planning on the macro scale. I wish you luck (for your reply, because I know people this low can't just not have the final word, they do everything to avoid learning from conflicts in order to save what can be saved for their little-big ego)!
Y'all are just really overthinking the shit out of it. my logger is 100 lines of code, and it's 5 functions... 2 of which are just UTFX variants (oh yeah, and it's written in C) for opening files. 
* Orbit + https://orbitprofiler.com/ + https://github.com/pierricgimmig/orbitprofiler + Orbit Runtime Binary Instrumentation Tool is a standalone C/C++ profiler for Windows. Its main purpose is to help developers visualize the execution flow of a complex application. * Tracy Profiler + https://bitbucket.org/wolfpld/tracy + Tracy is a real time, nanosecond resolution frame profiler that can be used for remote or embedded telemetry of your application. It can profile CPU (C++, Lua), GPU (OpenGL, Vulkan) and memory. It also can display locks held by threads and their interactions with each other. 
&gt; It is that 30(50) years of history that I think is the real root cause of the frustratingly slow progress. and: &gt; I think they are also committed to not "break the world", but they have far fewer constraints because there is much less Rust code out there. I totally get the frustration and I've myself thought about clean breaks so many times. That said, it's folly to think that C++ is especially unique here; as you said, the only reason D or Rust or whatever aren't suffering from similar problems is because they're young and nobody is using them in such large scale yet. Just wait. Rust should consider itself incredibly lucky if and when it starts having these same conversations. :) I mean, we have similar conversations about English and how it would be so great if everyone just switched to Esperanto or whatnot. Nothing is perfect, and when those imperfect things become successful, their imperfections are multiplied out across their vast user base. :) That said, I genuinely hope that once C++ Modules are in place, we'll be in a far better world with a clear path out of some of these messes. It'll be a lot easier to visualize a world where module A is processed in std20 mode and module B is processed in std26 mode and expect them to work together, even if there are breaking language changes between them. The biggest impediment remaining will be standard library compatibility issues, and there's both active efforts to resolve those and some potential for their impacts to be minimized as we move into a world with more views, ranges, generators, and other abstractions over concrete types. 
Oh, apparently I confused myself with this example. But your reply actually points to another potential problem: someone can forget a semicolon and get surprising results. 
Including Asio and using its patterns doesn't complicate a program/library, it does the opposite. 
That's sexual. Can't wait for that to leave experimental.
It was in /r/gamedev
If an operation runs for so long that we don't need it anymore (e.g. user wants it canceled), a coroutine usually would still have to live until the operation actually ends. Future coro() { char buf[100]; co_await read(buf); // Can't kill the coroutine because it owns |buf| // and there would be use-after-free in |read|. } And the objects owned by the coroutine won't be destroyed until it ends. Such objects can be considered leaked - we don't need them, but they're still there. &gt; There are mechanisms you can use to interrupt/cancel an async operation if you no longer want the result. Not every operation supports cancellation. Lots of async operations are sync operations running on a background thread. And not every API supports cancellation even if it's possible theoretically. Not every API even have an `OnProgress` callback where you could check you cancellation token. &gt; eg. using a cancellation_token `weak_ptr` is a cancellation token. Now tell me how I'm supposed to use it with coroutines.
I saw vaguely similar behavior with our `_ITERATOR_DEBUG_LEVEL` macros. It's not doing a full compilation, so I think it's assuming platform-default macros and nothing else. I could be totally wrong as I'm new to clang-format.
lmao this just reads like a shitpost
Source code: [https://github.com/1991viet/ASCII-generator](https://github.com/1991viet/ASCII-generator)
Currently for work I'm finishing up on a video test automation system. I've wrapped some functionality from ffmpeg in C++ libraries, provide image recognition, moving video detection and black screen detection with OpenCV's C++ API and use Tesseract's C++ API to provide OCR. Higher level objects track the overall state of the video and provide a python interface through boost::python. The system as a whole isn't terribly complex. Dealing with ffmpeg is the really the hardest part. But that buys us the ability to open pretty much any any video resource anywhere, so I don't think I'd trade for for, say, the video4linux API or smaller encoding and decoding library. Now that it's close to being worthy of an early release, I'm going to try to get a discussion going about open sourcing the system.
You're confusing the runtime library with binary compatibility. Yes the visual studio runtime library historically broke every major release. But binary compatibility did not. At my current client we are literally linking in binary blobs last compiled in 1995 on Win32. If they make no use of the runtime, they work.
&gt; For me the single biggest mistake in Rust is the borrow checker. That's definitely one of the more interesting perspectives on the borrow checker I've seen. This doesn't appear to jive with the rest of the paragraph, though, which seems to say something more along the lines of Rust not being the systems programming language to use because it doesn't do enough in terms of addressing whole-program correctness. Is it more the borrow checker is actually harmful, or more that it's a red herring of sorts and there's bigger issues to address, or something else? &gt; I think if you want to go down that route you're far better off choosing Ada or something similar. This led me down a far deeper rabbit hole than I initially expected. I've heard of Ada, but didn't know too much about its capabilities. Thanks for spurring me to learn more about it! I wonder if we're going to see Rust adopt Ada's capabilities, given that it seems that SPARK has already added new features based on Rust. &gt; There is also a lot of cruft and poor design choices in their standard library Do you mind explaining this a bit more? I know of issues with `std::error::Error`, and issues with being unable to write functions that are generic across arrays properly (which I think are supposed to be addressed using const generics), but those are just things I've stumbled upon. &gt; I suspect without evidence that Rust won't scale well into multi million line code bases because of how arsey it is to refactor anything substantial in a really large code base. As much as C++ has its failings, it does work reasonably well in twenty million line - per project - code bases. What about Rust makes refactoring it so much more difficult than refactoring C++? I thought good type systems are supposed to help with this kind of thing, and Rust has a pretty good one. &gt; where I can even today link a C++ program compiled with Visual C++ 4.0 back in 1993 into VS2017, and it'll probably work Wait, what? I'm pretty sure that Microsoft explicitly stated that they don't promise ABI compatibility between major revisions of Visual Studio.
1. It's not an arse to program in like Rust. 2. Its output is binary and source compatible with C++. 3. It's got that Python feeling to writing it I.e. just get on with it. Its major cons are the GC and lack of maturity.
Maybe you can answer a question: Another name I remember seeing in MSVC STL headers all the way back to VS6 was P.J. Plauger. When I saw the name originally, I recognized it, but couldn't figure out where I recognized it from. Did he do something else previously? Maybe something in the video game community in the 90s?
No. I believe I'm not: https://docs.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=vs-2017
I see you've rated Akira as "A pointless waste of time". Your programming talks are now 100% invalid :P
Personally I just want the fully shortened form. 
I think my trace logger is pretty cool. https://www.ayxia.com 
Finally! That crazy indentation will be fixed!
For C++ questions, answers, help, and advice see r/cpp_questions or [StackOverflow](http://stackoverflow.com/). This post has been removed as it doesn't pertain to r/cpp.
**Company:** SMX (http://smxemail.com) **Type:** Full time **Description:** SMX aims to be a global leader in managed email security, analytics and deployment solutions. We deliver enterprise-grade email security, analytics and messaging as-a-service, with a unique focus on the Australasian and Trans-Tasman threat landscape. As a Microsoft Co-Sell Partner and NZ All-of-Government supplier, a growing list of enterprise and government customers trust their email security to SMX. We're looking for experienced engineers to build our bespoke mail stack which is primarily in C++ on Linux but also using Lua for orchestration. The primary role is software development, you will be required to configure, manage and troubleshoot email systems to ensure our customers receive world class service and uninterrupted mail flow. You will also be involved with systems integration, automated deployments, threat analysis, big data ingestion and product design. **Location:** Auckland, NZ **Remote:** No **Visa Sponsorship:** Yes (Govt. preferred employer status) **Technologies:** C++ on Linux, Lua, mail and networking technologies. **Contact:** careers@smxemail.com
Also VS offers limited help for templates. And STL is basically 99% templates.
I considered it early on in the project but then rejected it for some reason. I don't recall why, now. It's possible it was just that I already knew a bit about ffmpeg and not all that much about gstreamer and didn't want to have to spend the time learning another API.
Since this is the "say hi to STL" thread, thought I'd do the same. Loved your "[rand() considered harmful](https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful)" video. As well as being immensely entertaining, it also shamed me into fixing my game engine's Random class. I at least knew not to rely on rand() since it's so bad that I actually saw visible patterns when using it to generate terrain on a previous project. I was instead using XorShift, but still making the mistake of using x % y for distribution - it hadn't even occurred to me how wrong that was, I'm sad to say. Once I realized how tricky it was to actually implement it correctly, I just switched over to using the std lib.
Here's the revised version that I'm checking in: --- BasedOnStyle: LLVM AccessModifierOffset: -4 AlignAfterOpenBracket: DontAlign AlignConsecutiveAssignments: true AlignEscapedNewlines: Left AlignTrailingComments: false AllowShortFunctionsOnASingleLine: Empty AlwaysBreakTemplateDeclarations: true BreakBeforeBinaryOperators: NonAssignment ColumnLimit: 120 FixNamespaceComments: false IncludeBlocks: Regroup IncludeCategories: - Regex: '^&lt;yvals(_core)?\.h&gt;$' Priority: 1 - Regex: '^&lt;Windows\.h&gt;$' Priority: 3 - Regex: '^&lt;WinIoCtl\.h&gt;$' Priority: 4 - Regex: '.*' Priority: 2 IndentWidth: 4 IndentWrappedFunctionNames: true MaxEmptyLinesToKeep: 2 NamespaceIndentation: All PointerAlignment: Left SpaceAfterCStyleCast: true ... 
Thanks too all - i will try superluminal and orbitprofiler
See: https://channel9.msdn.com/Tags/stephan-t-lavavej My CppCon 2014, 2015, and 2016 videos are also on YouTube (just search for "cppcon lavavej").
VS recently announced Template IntelliSense, though! See https://blogs.msdn.microsoft.com/vcblog/2018/06/26/template-intellisense/ .
Hopefully the STL can serve as a shining clang-format example for the FE to imitate :-)
Awesome, it's great to hear about actual code improvements due to my talks! :-)
There's a Wikipedia article about PJP. Notably, the indentation style used in MSVC's STL (before my imminent clang-format change) is called [Whitesmiths style](https://en.wikipedia.org/wiki/Indentation_style#Whitesmiths_style).
Same here. Fan of the same guy. For the exact same reason. What are the odds?
 &gt;VS was not able to cope with a code base I worked on. Exactly. And I was talking about SourceInsight in this context. 
I just looooovvvveeeee how they show up in intellisense though... :-/
The "brute force" approach to order of operations. Just add parentheses then you're sure! I like it (but only because I don't ever have to read more than these 6 lines).
I know and I tried using it, but it's far from perfect. The UI is annoying, since you have to click twice to bring up the menu to enter a type, then you try to type in a simple type (like `int`) and it starts proposing you `INT16_MAX`, while the type is supposed to be a class. My wish is by the time C++20 is finalized, it will understand concepts and only suggest valid values (like type matching the requirements, or numbers when your template wants an `int`). You can't do this easily in functions because of overload that potentially allow many different types, but templates have strong constraints so it should be possible. The performance hit might be too big, I don't know the details of how this works. 
IIRC, there was a cppcon talk, where titus also explained why they role their own duration and time types, but considering that Howard's library will be part of c++20, I don't think there is a good reason for most non-google projects to switch to abseil::Time, except if it turns out to be much, much more user friendly (haven't tried it myself). 
Thanks for the really thorough response; very interesting stuff! I'm kinda surprised (from the other replies too), being a unix guy, as I'd always heard that Visual Studio was *the* development environment for C++ on Windows. But it sounds like VSCode has become a capable replacement, which is kinda good news for non-windows users too.
Sure it wasn't supported officially until very recently as they didn't want the hassle. But binary compatibility, both forwards and backwards, for both the major C++ ecosystems, has tended to be excellent in practice. And both standards committees go out of their way to make this easy for toolchain vendors (for the record, I think this overdone, I personally think source level compatibility sufficient, and those relying on specific UB in older compilers need to get over relying on that).
&gt; Sorry but this just isn't a serious stance in this context. If you work at a high performance shop [...] Heh :) This is the context for this use of macro, in this logging library (taken from the OP's readme file): &gt; It's more like a hack to get logging right, in libraries, smaller applications and mobile apps written in C++. No performance critical usage scenario here. This optimization (only evaluate logging arguments if you use them) is "a case of YAGNI". &gt; If you work at a high-performance shop and you are writing a piece of generic utility code like a logger unless you know in advance that you never plan to do any logging in performance critical paths. I did work in such a case, and the logging was performed on events: there was no message logged on the performance critical path; Instead, specific (numeric) events were emitted, and they go translated to logging messages when received (off the critical path). Hell, we had to take used network sockets off the critical path to close them, because _that_ took too much. In principle, I agree that logging should be fast and not mess up the performance of your application. In this case, we are looking at an API that will (as far as I understand) never be used in a HP scenario. Optimizing evaluation of arguments before even setting a measurable performance goal, _is_ premature optimization. Using a macro to ~~hide this~~make the API usable, doesn't make it a good API, it makes it a patch over a case of premature optimization.
I'd say that if you have so many setters with so many side-effects, that maintaining your program and making it efficient will become extremely difficult. Suppose for example that you get a completely new setup for your `foo`. In your solution, you call `setX`, `setY`, `setRadius`, `setName` and you re-render `foo` four times - three of them completely unnecessarily. In real-world application, you might easily have dozens of parameters.... Worse, in a large real-time program, you have no assurance that one day, this chain of side-effects won't end up being circular. I speak from bitter experience on a real-world system with just such a setup where this would sometimes happen in production, causing a key process to go into a loop. There is no magic solution, of course. Sometimes what you propose is right. Sometimes the right solution is `Foo` (a class) and `FooDesc` (a struct with `x`, `y`, `radius`, etc) and all mutations to a `Foo` with a single `FooDesc` setter. Sometimes the setters set a "dirty" flag, or one of a set of "dirty" bits, and the update occurs in a later phase. It depends on the application, how many parameters you have, your threading structure, etc. etc.
I had this scenario working in Solaris terminals (client's machine, no freedom to install or configure anything, I had a choice between vi and ed). I had a similar scenario working with Microsoft Visual C++ 6.0: For some reason, some MS dev thought it would be a good idea to define `min` and `max` as macros instead of functions, which gives you cancer when you call it with expressions: int a = 5, b = 8; int c = max(a++, b); int d = min(a++, b); Quick question: what are the values of `a` and `d` at the end of the block of code?
Nope, but you can probably simplify to a few number of common patterns rather than 200 special cases. You probably want x and y grouped together in it's own type since they together represent something very common (a point).
&gt; For performance reasons, some MS dev thought it would be a good idea to define min and max as macros instead of functions, which gives you cancer when you call it with expressions: that's why the -DNOMINMAX macro exists. It's mandatory if you work with C++.
&gt; There is no magic solution, of course. yes, that's my point. You can't have magic abstractions over this, because this is your business logic.
&gt; https://github.com/NanXiao/libtlscpp/blob/master/examples/tls_client.cxx#L24 what happens if the length is greater than sizeof(response) ? is the string null-terminated ?
`char response[1024]{};`Where is the C++ encapsulation?
TLDR (since the article takes a couple of pages to get to its point): splitting debug info out of object files and into separate files results in speed improvements of ~15% for from scratch and ~90% for incremental builds on a project (LLVM/Clang) that links large libraries statically.
Sorry, I can't get your idea.
Yes, this is indeed a bug. I fix it, thanks!
Danger.
&gt; Is it more the borrow checker is actually harmful, or more that it's a red herring of sorts and there's bigger issues to address, or something else? It's more that there's a tradeoff between (a) ease of programming (b) enforcement of correctness (c) performance. You can get two of those, but not all three. Ada is tedious to write in, tedious to refactor, but performs well and certainly enforces that what you specify is what you get. C++ is much faster to write in and refactor, performs well, but is riddled with UB. Rust is slightly more tedious than C++ to write in, much more tedious to refactor, and has the performance. My totally without evidence claim is that Rust is a trap: people are locking themselves into codebases because the entry barriers are low, and how large the maintenance costs will be is discounted. My suspicion is that in time, people will suddenly realise how Rust is a trap, and abandon it with fervour as a huge mistake. &gt; I wonder if we're going to see Rust adopt Ada's capabilities, given that it seems that SPARK has already added new features based on Rust. C++ is taking an alternative approach where it should become possible to formally verify a small C++ program in the future. So like CompCERT with a subset of C, we could do the same with a subset of C++. My hope would be that down the line, a C++ 2.0 would then build on that formally verifiable object and memory model into a much higher level language which can be source intermixed with C++ 1.0 and C. So effectively, current C and C++ would become opt-in "unsafe" in the sense Rust means it, and C++ 2.0 would be safe by default. (All these are hand waving personal aspirations, and do not reflect any formal position) &gt; Do you mind explaining this a bit more? I know of issues with std::error::Error, and issues with being unable to write functions that are generic across arrays properly (which I think are supposed to be addressed using const generics), but those are just things I've stumbled upon. Their standard library was rushed, no doubt. There is a profusion of member functions without clearly delineated and orthogonal use boundaries. In other words, a good standard library design has a well defined, few in number, set of composable primitive operations which are combined to solve each problem. What it doesn't do is have many member functions all doing variations of the same thing. And I think they get this problem, and they'll do something about it. Swift did the same, Go is doing the same. We could do with doing the same. I'd just love if we could dispose of `string` for example. I wouldn't mind of getting rid of most of the STL containers in fact, and replace them with a set of orthogonal Range based primitives which can be composed into arbitrary containers. But that's crazy talk, and would never get past the committee. It is what it is. 
surely you understand that for something as sensitive for security as SSL / TLS, this does not really put your library under a good light if the simplest example has a glaring coding mistake ? 
Yes, you are correct! Thanks very much again for pointing it out! Yes, even for a single example, I should take care of it.
`std::size_t read(void *buf, std::size_t len);` and the encapsulation is where?
For read and write, I just keep them simple. I think it is more simpler to use than std::string.
If one likes *that* kind of simplicity one would not use a C++ encapsulation. 
Is this analogy to PDB files which msvc has turned on by default for a decade?
Note that Vc ships a portable (across the supported compilers and platforms - but limited to x86) set of functions for inspecting CPUID. It also provides a type that depends on the active ISA extensions at compile time to easily create different symbols of the same source code when recompiling with different `-march` flags.
Hmm, this is subtly incorrect. Depending on wether the *targeted* hardware (i.e. the `-march` flag and related) supports SSE, AVX, ... C++ already has a dynamically-sized type for vectorization called `std::valarray`. But the consequence of it being dynamically sized is that all constructions map to a heap allocation. And since the compiler doesn't really know the `valarray` size a lot of optimizations are impossible. The Vc approach is to give you one type for SIMD registers (such as `float_v`) but without telling you up-front what the number of elements will be. That forces a specific style of vectorization; which ,in my experience, users of a `float4v` type wouldn't choose; but that is typically more efficient and obviously scalable to wider vector architectures. ARM SVE / Cray vectors is an interesting alternative to producing scalable (in vector width) binaries. However, I believe this specific feature is not very important and inhibits some very useful data structure choices: * HPC users typically run on homogeneous clusters (with regard to the vector width). They can compile to the exact vector width. * Desktop applications can easily dispatch to the right ISA extensions set / vector width. Either with a script that calls the correct binary, an `ifunc` mechanism, or virtual dispatch like used in Krita. * One the most efficient data structures in vectorization is "Array of Vectorized Struct" (AoVS) since it combines locality and vector access. Whereas AoS only provides locality (except for (de)interleaving loads and stores; see Vc) and SoA only provides vector access. AoVS is impossible to use if the vector width is unknown at compile time.
Note that in order to compile code using such a `float_v_8` you'd need to compile with `-mavx`, which allows the compiler to insert arbitrary AVX instructions where it feels fit (most importantly it will now code all SSE instructions using a VEX prefix). Meaning, that such a binary would quickly hit an *invalid instruction*. If you compile with `-mno-avx` `Vc::Vector&lt;T, VectorAbi::Avx&gt;` is an incomplete type (https://godbolt.org/z/aQF1P0).
Vc has a library for math functions (trig, log, ...) and a few other minor things. I agree that it makes Vc slightly harder to integrate in your project. Which is why I'm working on standardizing the feature set and getting an implementation into libstdc++. (See the Parallelism TS v2: `std::experimental::simd`) I honestly can't tell you how it compares to libsimdpp. You'd have to ask them why they started a new project instead of improving Vc for their needs. (the first public release of Vc was in 2009; back then it was hosted on gitorious.org)
Having language server support will be awesome. Qtcreator will be a really fast, lightweight way to use language servers compared to the alternatives.
&gt; C++ already has a dynamically-sized type for vectorization called std::valarray So that's not really a dynamically-sized type (`sizeof(valarray)` is not a run-time value) - `valarray` is just a statically-sized type that happens to point to some memory in the heap. 
LSP, Multi-programs debugging... that's a hell of a changelog!
cppcheck plugin is nice
Hands on results, have to watch.
This is pretty interesting. I am also curious to see how much of the performance is because the Makefile generator will not dependent TU's while linking. It would be interesting to use the Ninja generator (3.9+) as it has a more relaxed model and can build downstream TU's while linking.
&gt; I was talking about SourceInsight Ah, my bad. Yes, Source Insight has no problem with huge code bases. However, a couple of my coworkers used to write such convoluted code (templates+macros) that it confused even Source Insight. There were others who didn't like its UI for aesthetic reasons. I guess it's hard to please everybody. 
Ah, that's what you meant. Of course. There have been several attempts at getting *sizeless* types into the language. There's also been a paper by ARM for the last committee meeting (wg21.link/p1101r0 - sorry, still not public yet), trying to tackle sizeless `simd` types (guess why ;-) ). I don't have high hopes for resolving this any time soon.
You can get a similar effect with `std::experimental::fixed_size_simd&lt;float, 8&gt;` (or `Vc::fixed_size_simd&lt;float, 8&gt;` in Vc 1.4). It'll use all the instructions that were enabled at compile time (i.e. still no automatic multi-arch - a concept the C++ standard knows nothing about). But its ABI is independent from compiler flags. Meaning you can use those types on ABI boundaries (e.g. network I/O or shared libraries).
&gt; I dropped the exercises and practice sections of this book, because I found them quite boring and, more important, aimless. First off, that would be a mistake. Just do them, and try to do them well. That's like taking a course and skipping the final project that's supposed to be a demonstration of everything you've learned. As for a site, I use [codewars.com](https://codewars.com). It's not exactly what you're looking for but I don't think you're going to find what you're looking for. The best thing you can do here is to find something you can work on and just get to work. Whether it's a project or challenges like on codewars, just get coding. After you've finished some code, read some more. Reread chapters you've already read and then reexamine your code and think about how you could improve it. &amp;#x200B;
This is definitely something I'll try out when the next time I'll use Qt. The full [list of checks](https://github.com/KDE/clazy#list-of-checks) looks impressive. 
Is there a change we will ever get an integrated terminal/console?
While I understand what partial_sort is normally used for, it surprises me that the algorithm does not simply check whether the partial sort is "big" and then reverts to Nth element followed by a standard sort. This is an O(1) operation. This does not detract from the quality of the video which is excellent.
unreal engine please!, thx
Oh yes, Unreal Engine has one of the worst build systems I've ever had to deal with, and everything about Unreal Engine is so anti-modern C++.
Not quite: PDBs are produced during linking from debug unfo embedded into object files. This mechanism splits the debug from the object files.
&gt; wg21.link/p1101r0 Thanks for the paper, i just read it and its a bit weird. First it uses the term `sizeless`, but these types do have a size, this size is just not known at compile time and most PL literature uses the term `dynamcially sized` for these types. It feels weird that they invent a new term that's so similar to other PL terms like `unsized types` (types without a size - their size is not known neither at compile time nor run-time). It is also weird that they do not allocating these "sizeless" types on the heap, since heap allocations happen at run-time, and the size of these types is known at run-time (most languages with dynamically-sized types allow this).
The blog post is a bit too superficial for my taste - it states certain things, but provides no explanation. For example: "_none of these projects ship with a reproducible build-system_". So what were the problems with each build systems that make the builds not reproducible? And erm... where is BuildInfer? Nice announcement, but no website / download link? Is it correct that the only way to get it is to contact you via hello@buckaroo.pm? So the main (only?) goal of the tool is to help people port their existing builds to Buck?
I don't think so, not all debug info goes into PDB files AFAIK. If you do a debug build, your exe/dll/lib will be larger than if you do a non-debug build, so some debug information must go directly into the exe/dll/lib too.
I've been following along with [learncpp.com](https://www.learncpp.com)
&gt; Does auto-indentation via LibFormat which is the backend used by Clang Format. Enable the plugin ClangFormat to try it. I'm wondering, why do other IDEs use the clang-format binary (e.g. VS), while QtCreator seemed to have integrated this more tightly with LibFormat? &gt; We added support for simultaneously running debuggers on one or more executables. That's awesome! I hope more IDEs will start adopting this :-O
We've had the same experience with MSVC. We've been building debug builds without debug info for some time now, and it saves us lots of time during the build process. Debug info is only ever enabled on a temporary basis if we run into a problem. I can imagine compilers supporting a separate mode just for generating debug info, so you can just generate it retroactively after you've run into a problem (after all, you have the exact same source still sitting there). It would be a great way to speed up the edit/build/run/crash cycle. Also, note that Storm/C++ on the Amiga supported separating debug info from object files back in the nineties. IIRC it allowed you to ship small, optimized executables, and have a separate file for interpreting stack trace if it were necessary. 
This doesn't quite seem right as you pass the pdb output file as a compiler switch\[1\]. The linker does do something to combine pdbs at link time but I didn't think debug information was entirely with the objects. \[1\] /Fd [https://msdn.microsoft.com/en-us/library/9wst99a9.aspx](https://msdn.microsoft.com/en-us/library/9wst99a9.aspx)
You can get both performance and encapsulation if you \`use std::string\_view\`
**Company:** [Logos Network](https://www.logos.network/) **Type:** [Full time] **Description:** [Logos is a seed-stage startup backed by top VCs and sector focused investors. We are building a decentralized, hyper-scalable payments platform. Areas of focus in the field of Payments include: Micro-transactions, IoT, Peer-to-Peer, E-commerce. Requirements: You are a top-tier engineer that craft elegant solutions to intricate problems! You are a firm believer of blockchain/cryptocurrency technology and would love to be part of the technological revolution! You are not afraid of ambiguity and rapid growth! You are willing to go above and beyond to help other team members because frankly, this is a new market and it is amazing! Responsibilities and Duties: Derive software requirements, perform detailed software design/documentation and implement the core distributed protocol depicted in the software design Perform gap analysis on existing implementation vs enhanced software design and implement the enhanced design Develop highly performant P2P communication protocols that are optimized across a variety of environments Contribute to theoretical work on protocol, including synthesizing ongoing cryptocurrency and distributed algorithms research Aid in development of ecosystem applications, depending on skill set Develop libraries that expose node interfaces to a variety of common programming languages Qualifications include: Development skills: Experience in distributed applications or high frequency trading Software (HFT) using C/C++ Solid understanding of algorithms and data structures Experience using version control tools, bug tracking tools and Linux tool chain Experience with CMake Experience in one or more of the following (preferred): Cryptocurrency protocols, blockchains, smart contracts. Financial technology User experience and web applications Infrastructure related development Parallel programming Servers and RPC interfaces Internet protocol suite, particularly TCP and UDP] **Location:** [New York City, NY] **Remote:** [Not unless you are truly exceptional] **Visa Sponsorship:** [Yes] **Technologies:** [C++14, Boost, Linux, AWS, UDP, TCP, LMDB, LevelDB, RocksDB CMake] 
I've been going through [The Modern C++ Challenge](https://mariusbancila.ro/blog/2018/05/25/my-book-the-modern-c-challenge-has-been-published/), it's got a great spread of puzzles and challenges that are sorted by different parts of the language. For example, I wanted to brush up on modern language features and there's a whole set of problems just based around that.
Thanks for your feedback! \&gt; The blog post is a bit too superficial for my taste - it states certain things, but provides no explanation. For example: "*none of these projects ship with a reproducible build-system*". So what were the problems with each build systems that make the builds not reproducible? There is only so much information you can provide in one post without distracting from the main message. We have a series of blogpost in the pipeline. &amp;#x200B; \&gt; Is it correct that the only way to get it is to contact you via [hello@buckaroo.pm](mailto:hello@buckaroo.pm)? &amp;#x200B; Yes, BuildInfer is still in alpha stage. Our current focus is to gather more case studies, learn from them and make buildinfer more useful. &amp;#x200B; \&gt; So the main (only?) goal of the tool is to help people port their existing builds to Buck? &amp;#x200B; Our main goal is to analyze the build and give you actionable insights. &amp;#x200B; Things we use BuildInfer so far: \- Graph visualisations with various level of detail \- Identifying bottlenecks in builds \- Identifying files with high number of dependents \- Performing semantic analysis to create a concise descriptions of the build. &amp;#x200B; In the process we discovered that we can use the description of the build to generate eg. a buckfile.
Is there documentation available how multi-arch (wrt SIMD) is done in Rust? Note that `fixed_size_simd` gets its ABI compat by resorting to "never pass as register, even if it's a single register on the current target hardware" + aligning to `sizeof`.
It would be easy enough to build a terminal window plugin. What would your usecase be though? It seems like for the most part when using an IDE if you have to touch a terminal it is because the IDE was missing functionality. I also don't see what it would provide that just having a terminal window open woudn't.
Unfortunately, STL is a file format that is not worthy of your name. Having had to work with it extensively... gosh, I wish they had just gone with AMF from the start
I like the term *sizeless* since it isn't as ambiguous as dynamically sized (`std::vector` certainly is dynamically sized; i.e. `vector::size()` is dynamic). And it hints at the `sizeof` issue: at compile time those types don't have a `sizeof`. The constraint to not allow them as data members stems from previous discussion on `std::dynarray` and follow-ups. AFAIK, this was a conservative choice to not get into the `dynarray` rathole. It goes both ways: ARM develops what they believe their customers need/want. And the same time they'd like that development to become standard C++. To propose something for the standard you better be able to show an implementation. So yes, similarity with existing implementation work should be expected. Yes, I share your criticism of how it kills the portability aspect of `simd`. And that was also the feeling in SG1 when the paper was discussed. It's not going forward in its current form.
How about cross? Is there anything related to cross compiling? Manually writing ini files seems like backwards then forward thinking. 
&gt; The best proposed solution about how to solve all these issues in Rust is to reify target-features as first class Effects and handle them at an Effect system level. I'm not sure I understand this part. In C++ terms I was thinking that the target needs to become an implicit template parameter/argument. Thus ```cpp inline __m128i min(__m128i a, __m128i b) { if constexpr (__builtin_target_supports("sse4.1")) { return _mm_min_epi32(a, b); } else { const auto mask = _mm_cmpgt_epi32(a, b); return _mm_or_si128(_mm_andnot_si128(mask, a), _mm_and_si128(mask, b)); } } [[gnu::target_clones("default,sse4.1")]] __m128i f(__m128i a, __m128i b) { return min(a, b); } ``` becomes ```cpp template&lt;_Target _T&gt; inline __m128i min(__m128i a, __m128i b) { if constexpr (__builtin_target_supports&lt;_T&gt;("sse4.1")) { return _mm_min_epi32(a, b); } else { const auto mask = _mm_cmpgt_epi32(a, b); return _mm_or_si128(_mm_andnot_si128(mask, a), _mm_and_si128(mask, b)); } } [[gnu::target_clones("default,sse4.1")]] template&lt;_Target _T&gt; __m128i f(__m128i a, __m128i b) { return min&lt;_T&gt;(a, b); } ``` Is that what you were saying?
Also remember that debug built binaries are much bigger due to the lack of optimization, and the sheer amount of `mov` that has to be everywhere (all variables have to be in memory at all times in order for debugging to work).
I did not do that in the articles but I did in some project myself. I hope to publish something more complex at some point.
Linking sucks. LLD helps, can't link everything though. Some things require bfd, not even gold.
MSVC can already put debug info into seperate pdbs.
We still use openssl after heartbleed.
Build. (Why would you get different runtime performance for from scratch vs incremental builds?)
He's pointing out that your C++ code is effectively C with some C++ flavor - it doesn't take advantage of C++ features that would be very helpful.
A dedicated array view would be clearer since it isn't necessarily text.
I need to be able to use a specific version of clang-format, how do I do that with LibFormat? 
This is a murky business, see https://github.com/build2/build2/blob/master/build2/cc/compile-rule.cxx#L4344-L4358 for some background.
Not quite. MSVC's equivalent is "/debug:fastlink", and it works pretty much like this article describes. Debug information is kept in the obj files, the PDB is just an index of the data in the objs, and there's a separate command to turn a fastlinked PDB into a full one if you need to save it. 
Depends if the compiler/linker generates something different during the incremental build. Jamming debug info into a build can also change the binary's layout and thus impact performance due to cache effects.
Yeah, I had a lot of fun getting a SCons build to produce a reasonable set of pdbs without utterly killing parallelism. So one issue with using the single pdb per obj file is that lib (AFAIK) won't concatenate the pdbs together so if you have a static library as your artefact, you can't just store MyLib.lib and MyLib.pdb, you have MyLib.lib and twenty thousand tiny Foo.obj.pdbs with it. How did you get around that with build2?
We didn't -- it's left as an exercise for the user ;-).
&gt; Well, you say OO and immediately go to inheritance. More importantly, let's remember that inheritance has nothing to do with OOP itself, but rather is a facet of the type system. OOP fits in perfectly with languages using structural typing, trait-based typing, prototypical polymorphism, etc. Polymorphism with is-a relationships is modeled in C++ with inheritance by default, though it certainly doesn't have to be even for C++. Templates for example can use so-called static polymorphism and get very OOP-like behavior with objects with any inheritance in sight. :)
Has anyone successfully used on Windows?
Can we implement an automatic filter into this sub? These questions get asked every single day. It's tedious.
I'd rather it was left as an exercise for MS: [https://developercommunity.visualstudio.com/idea/355400/lib-should-allow-you-to-produce-a-pdb-of-all-input.html](https://developercommunity.visualstudio.com/idea/355400/lib-should-allow-you-to-produce-a-pdb-of-all-input.html)
To be honest, the main issue I've had with timezones were... timezone changes. ###1. Missing Summer Time information When talking about the future, many countries will not yet have announced the dates for switching to Summer/Winter times. If you schedule expecting that the day will be Winter time and it's not, you're off by 1 hour. ###2. Changing Summer Time information Related, some countries will either move the data of the switch, or cancel Summer time for the year. Once again, any time scheduled in the affected span is now off. ###3. Timezone change And of course, some countries, or part of, will decide to switch from one timezone to another. --- It doesn't appear that Abseil helps here, and it is possibly very domain-specific, but it's certainly a real issue for which a "definitive" solution would be appreciated :)
I'm confused. In the incremental section time goes from 3m16s to 1m42s. That's a significant improvement, but nowhere near 90% as far as I can see. Am I missing something?
I find its avoidance of \`std::chrono\` sufficient reason to use it.
!removehelp
OP, A human moderator (u/STL) has marked your post for deletion because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20Appeal&amp;message=My%20post,%20https://www.reddit.com/r/cpp/comments/9n9eyi/siteresource_to_practice_c/e7l6svg/,%20was%20identified%20as%20a%20help%20post%20and%20removed%20by%20a%20human%20moderator%20but%20I%20think%20it%20should%20be%20allowed%20because...) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
3m16s is ¬´ 90% worth ¬ª than 1m42s. Although it still does not mean it improved by 90%, I guess it‚Äôs where they‚Äôre coming from. 
We have some AutoMod rules to identify posts for review, but it‚Äôs hard to craft auto-remove rules without annoying false positives.
I don't think this replaces the Beautifier plugin, which can already use a specific clang-format executable on trigger or file save. Instead it replaces the "Code Style" option in the C++ settings.
`array_view&lt;char&gt;` ? 
Well, if you use ancient C++ version, without std or any other lib that you don't completely control, and expose only "safe" API subset, then yes, you can be rather compatible (especially if you don't rely on the `sizeof` your types and their memory layout). But that's not saying much. It's harder to find any relatively popular/established language that doesn't provide at least such guarantees.
It is integrated in QtCreator. You have to enable it in the clang code model I believe. I tried building it to put it in a build server and I had some issues.
All you checked was binary size. No check for execution time? Would a binary tree be faster/smaller than a linear tree of branches? You can clean your code up; in both cases, it consists of "call a function with a compile time value equal to a runtime value". template&lt;std::size_t max, std::size_t offset, std::size_t range = max, class Scalar, class F&gt; decltype(auto) at_compile_time(Scalar&amp;&amp; s, F&amp;&amp; f) { if constexpr (range==1) { return std::forward&lt;F&gt;(f)( std::integral_constant&lt;std::size_t, offset&gt;{} ); } else { if (s &lt; (offset + range/2)) return at_compile_time&lt;max, offset, range/2&gt;(std::forward&lt;Scalar&gt;(s), std::forward&lt;F&gt;(f)); else return at_compile_time&lt;max, offset+range/2, (range+1)/2&gt;(std::forward&lt;Scalar&gt;(s), std::forward&lt;F&gt;(f)); } } now your code becomes: template &lt;class F, class Variant&gt; decltype(auto) myvisit(F&amp;&amp; f, Variant&amp;&amp; var) { return at_compile_time&lt;std::variant_size_v&lt;std::remove_reference_t&lt;Variant&gt;&gt;&gt; ( [&amp;](auto i)-&gt;decltype(auto) { return std::invoke( std::forward&lt;F&gt;(f), std::get&lt;i&gt;(std::forward&lt;Variant&gt;(var)) ); }); } where you can try linear-search, folding, binary search, binary folding, etc. 
&gt;Qtcreator will be a really fast, lightweight way to use language servers compared to the alternatives. I've always used Qt Creator to strike a balance between performance and features! 
Provided there are safe conversion functions yes. If the different time libraries don't know about each other, the only way they can provide such conversation functions is to go via std::chrono types or (in the worst case) ints.
&gt; My totally without evidence claim is that Rust is a trap: people are locking themselves into codebases because the entry barriers are low, and how large the maintenance costs will be is discounted. Might this be more of a tooling hole? I haven't written large-scale Rust programs before, so I have very little experience with what is required for Rust refactoring. &gt; My suspicion is that in time, people will suddenly realise how Rust is a trap, and abandon it with fervour as a huge mistake. Has this happened with any other language/framework/etc.? &gt; C++ is taking an alternative approach where it should become possible to formally verify a small C++ program in the future. So like CompCERT with a subset of C, we could do the same with a subset of C++. Sounds exciting! Given the pace of progress so far I'm not too excited about the timescales in which this is going to happen, but it's an interesting direction nonetheless. &gt; Their standard library was rushed, no doubt. &lt;snip&gt; Interesting. Now that I have some idea of what to look for, I wonder how badly it'll stick out... Thanks for explaining! &gt; I wouldn't mind of getting rid of most of the STL containers in fact, and replace them with a set of orthogonal Range based primitives which can be composed into arbitrary containers. But that's crazy talk, and would never get past the committee. Wasn't there some talk of a `std2` namespace that could do exactly this? Or did that get shot down?
Maybe I'm really late to the party, but I actually didn't know about C++/WinRT. I think the title is rather misleading, but it's such a great library/tool being finally able to write C++/C# without the ugly C++/Cli. 
&gt; and I still disable autocompletion. What! Why? I took a similar path as you and the first time I saw code completion I drooled wiht excitement. I have sworn not to use anything without code completion that day.
&gt; (all variables have to be in memory at all times in order for debugging to work). Hm, I'm not 100% sure, but this seems wrong. On x64 even calling convention encourages some variables to live in registers, so I'm pretty confident that with the right amount of debug info (and appropriate optimization level), good debugger can figure most stuff out without everithing being in the memory.
So I prepared a long comment after seeing the video but scrapped it. My prediction for constexpr: Basically everything which is a valid C++ program will be allowed in constant expressions which leads to the removal of the keyword because the compiler automatically deduces it without the unnecessary help of the developer/code. There will be a switch to deactivate these optimization and a keyword to force a compile time evaluation to cover the cases the compiler is unable to properly deduce it (flaw in deduction logic-&gt;basically a bug). This allows any code without the keyword constexpr to be checked if it can run at compile time with inputs know at compile time. In the end every compile time computation is just a value/data returned from function evaluated at compile time called with values/inputs that are know at compile time. This is the same has compiling two programs where the compilation of the second program is dependent on some returned data of the first program. Lets see what c++36 will say about it (pessimistic estimation). 
What do you mean?
Your post has been automatically removed because it appears to be a "help" post - e.g. asking for help with coding, help with homework, career advice, book/tutorial/blog suggestions. Help posts are off-topic for r/cpp. This subreddit is for news and discussion of the C++ language only; our purpose is not to provide tutoring, code reviews, or career guidance. Please try posting in r/cpp_questions or on [Stack Overflow](http://stackoverflow.com/) instead. Our suggested reference site is [cppreference.com](https://cppreference.com), our suggested book list is [here](http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list) and information on getting started with C++ can be found [here](http://isocpp.org/get-started). If you think your post is on-topic and should not have been removed, please [message the moderators](https://www.reddit.com/message/compose?to=%2Fr%2Fcpp&amp;subject=Help%20Post%20False%20Positive&amp;message=Please%20review%20my%20post%20at%20https://www.reddit.com/r/cpp/comments/9ndh39/lf_help_w_a_very_simple_program/.) and we'll review it. #####&amp;#009; ######&amp;#009; ####&amp;#009; *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp) if you have any questions or concerns.*
&gt; Might this be more of a tooling hole? I haven't written large-scale Rust programs before, so I have very little experience with what is required for Rust refactoring. Maybe. The problem is that the borrow checker forms a directed acyclic graph of dependency and ripple propagation. I suspect that makes it as painful as it is in Ada to refactor, but without all the other benefits Ada comes with. &gt; Has this happened with any other language/framework/etc.? I can think of three recent case: Perl, Ruby and Javascript. Perl and Ruby people just abandoned/are abandoning. Javascript was saved by being impossible to abandon. So people abstracted away Javascript, and that makes large Javascript programs somewhat manageable. Historically Lisp is the classic example. Such a powerful language. Too powerful. Lets everybody build their own special hell with it. &gt; Given the pace of progress so far I'm not too excited about the timescales in which this is going to happen, but it's an interesting direction nonetheless. It's literally shipping in compilers today. It's called `constexpr`. We expect to expand that to as much of safe C++ as is possible in the next three standards. I'm actually currently arguing with WG14 that they ought to adopt the subset of C which is constexpr compatible formally as "safe C v3". &gt; Wasn't there some talk of a std2 namespace that could do exactly this? Or did that get shot down? Shot down. Many on LEWG were disappointed about this. But in the end international standards is all about consensus.
The calling convention does, but look at the output of debug vs release mode of gcc on the following stupid arithmetic code. [godbolt](https://godbolt.org/z/DCrist) The debug code is 1.5x the size of the release code. If you look at the stack management at the top, it is clear why this is: Debug: func(unsigned long): push rbp mov rbp, rsp mov QWORD PTR [rbp-40], rdi mov rax, QWORD PTR [rbp-40] add rax, 1 mov QWORD PTR [rbp-8], rax mov rax, QWORD PTR [rbp-40] sal rax, 3 add rax, 4 mov QWORD PTR [rbp-16], rax mov rax, QWORD PTR [rbp-40] test rax, rax js .L2 Release: func(unsigned long): lea rcx, [rdi+1] lea rdx, [4+rdi*8] lea rax, [rdi+rcx] add rax, rdx js .L2 Besides the removed stack management code, the very first thing the debug function does it take the value out of the input register and immediately save it to memory. Then when it is being used, it loads it right out of memory again. This is definitely due to the debugger needing to know what the value is. In release mode, you can just use lea's and adds without ever actually touching the stack. The cout function calls don't change much due to what you said, the calling convention, but the actual computation is much streamlined. 
I've personally never been fond of using `char` to represent potentially-binary data. To me, seeing `char` implies textual data - I generally prefer using `unsigned char`, or something more specific (`byte` or `uint8_t`).
If the debug info is completely separate, no. Some compilers/linkers to generate 'hybrids' where most of the debug data is in separate sections, with *some* glue code.
Ha, dis not know about this ! Are we talking about arcane compilers here, or does this mean that I may also see differences in code/text section on, say, a gcc/ld build with with or without debug info ? I know just a tiny bit about DWARF and DIEs but I don‚Äôt see how glue code could be needed. I have literally no clue about other platforms and formats...
Well it would still be overhead in case the user already knows nth-element + sort wouldn't be faster. Let's assume a program does lots of computations like "get me the largest three elements out of a set of 20 elements"(pulled the numbers out of thin air. you get the gist). I think here the overhead of doing the "should I fall back to nth-element + sort" every time partial_sort is called could be a non-trivial performance decrease. Exactly what C++ usually tries to avoid. 
I've wished for this feature for *years*. Very often I debug clients &amp; servers at the same time and thus have to launch two QtC instances
have this problem with people building my software on ubuntu currently :( both lld and gold segfault while bfd works fine (but takes ages). In contrast in arch linux lld works fine and is blazing fast.
&gt; but look at the output of debug vs release mode of gcc on the following stupid arithmetic code. godbolt &gt; &gt; This is not debug vs. release. That O3 vs. nothing. Here is debug vs. release: https://godbolt.org/z/vPOK3R The code for quoted part is almost identical.
Frankly, i completely forget about Og because it's not portable between gcc and clang (and I mainly build with clang) and afaik MSVC doesn't have an analogue. If that's what you mean by debug then yeah I have no idea where the size it coming from, unless O1 O2 can make sizable differences by collapsing code after inlining. 
Agreed. OP‚Äôs article would be much better off with ¬´ almost twice as fast ¬ª in place of *¬´ We get a roughly 90% speedup in elapsed time. ¬ª*. 
Sometimes a little CLI interaction is needed (e.g. cat a logfile or similar actions). VSCode and Eclipse integrate an interactive terminal, and this is just super convenient, IMHO. It may help to keep context (instead of switching between the IDE and the console).
Sometimes a little CLI interaction is needed (e.g. cat a logfile or similar actions). VSCode and Eclipse integrate an interactive terminal, and this is just super convenient, IMHO. It may help to keep context (instead of switching between the IDE and the console).
**Company:** [Microsoft](https://careers.microsoft.com/us/en/) Visual C++. **Type:** Full time. **Description:** Compiler Front-End Engineering Manager: Are you passionate about compilers and parsers? Do you love C++? Do you want to lead the development team that's responsible for compelling new features to make programming in C++ easier and more natural? This job is for you! We are the Visual C++ team and we produce the C++ compiler for Windows, aka MSVC. We're looking for an Engineering Manager to join our compiler front-end team as we continue to take on our new charter for C/C++ compiler development. As a Software Engineering Manager on the C++ compiler front-end, you will have the opportunity to work directly with customers, MVPs, and other Microsoft teams as we add new features to the standard C++ language and libraries. You will be directly managing one of the core teams at Microsoft with years of rich history and engineers who are industry-known. We work closely with the C++ Standard committee and continuously evolve our compiler to adhere to the language evolution. We are embarking on some very ambitious and impactful features in several fronts, including language innovations from C++20 standardization, making the parser robust and fast, and continuing to invest in compiler conformance, that truly target cross-platform development across Windows, Linux, Android, and iOS. Your passion and skills in language design, parsing, binding, static analysis, and C++ programming will help you succeed as a leader of the team. Responsibilities: To be successful in this role, you must be able to do the following: * Lead the team in developing C++ compiler features that adhere to the latest C++ standards. * Lead the team to raise the quality of the compiler. * Work with multiple internal and external partner teams to implement new features that don't impede adoption of new compiler versions. * Manage and grow a team of highly capable engineers developing a world-class C++ toolset. * Champion engineering practices that improve the status quo. * Implement and maintain excellent design and development processes. Basic Qualifications: * 10 years of advanced C/C++ knowledge and experience. * BS in Computer Science or Engineering. Preferred Qualifications: * At least 5 or more years of experience in designing/shipping imperative language compilers/languages/APIs/tools. * You should have a strong track record of shipping secure, high quality software through all phases of the product cycle and have demonstrated successes in cross team partnerships. * Experience leading, mentoring, and managing a team of software engineers as large as 15 engineers. * Proven track record of growing your team and employees. Microsoft is an equal opportunity employer. All qualified applicants will receive consideration for employment without regard to race, color, sex, sexual orientation, gender identity or expression, religion, national origin or ancestry, age, disability, marital status, pregnancy, protected veteran status, protected genetic information, political affiliation, or any other characteristics protected by local laws, regulations, or ordinances. The ability to meet Microsoft, customer, and/or government security screening requirements is required for this role. These requirements include, but are not limited to, the following specialized security screenings: * Microsoft Cloud Background Check: This position will be required to pass the Microsoft Cloud background check upon hire/transfer and every two years thereafter. **Location:** Redmond, WA, USA. **Remote:** No. **Visa Sponsorship:** No. **Technologies:** We use the C++20 working draft as our compiler compiles itself. **Contact:** Email Ulzii Luvsanbat (Group Software Engineering Manager, C++ Language and Toolset Group) at batul@microsoft.com .
[removed]
I wonder if oat++ could run on iOS or android.
I tried Conan last year and it was interesting but it lacked an important feature we were looking for. We have a few core libraries that run on different OS(Linux, Windows) and HW ( Intel and AMD) chips. The feature we were looking for was to differentiate between the binaries based on compilation flags. Basically we build some of the libraries in 10 different configurations just using the `-mfpmath`, `-march`, `-malign-double`, `-ffast-math` flags and it is not possible to differentiate between these "Conan packages" based on the compilation flags. As long as I remember they were not planning to support flags to create different Conan packages in the same build configuration. It only supported creation of a different package if OS/x86 or x64/ Debug or Release was different. I personally think it is the wrong approach when considering a C++ package manager. C++ is not Python or C# or whatever. Compilation flags can considerably change the behaviour of a program. The funny thing is that they do indeed support x86 vs x64, but in fact this is just another flag (`-m32` vs `-m64`), the same with release vs debug. What does Release and Debug really mean? It's different for everyone. `-O1` might be optimized for some use cases and `-O2` might not be for some other use. IMHO they should have first supported flags as a first class type and then built different configurations Debug, Release, x86, x64 on top of those flags. After all the configurations are simply a name and what defines a configuration is the flags used to generate that configuration. 
Ok but how is it different from a raw pointer if it's a function parameter? You could make a purely decorative struct like `could_be_null&lt;T&gt;`
I believe technical term for this is "vaporware"
The power of Conan is that it does not limit you to "Debug means `-O0`, Release means `-O2`". It allows you to define your own build types, you may even call them "O0", "O1" and "O2" if you want, "Debug" and "Release" are just examples, you are not limited to using them. Conan is a powerful framework that allows you to map what Conan calls settings and options to environment, build tools, compiler flags and other ways to create artifacts in different ways. Conan can resolve dependencies for you, but you can override which packages are compatible and which are not if you don't like how Conan does it for you.
This served as the basis for my CppCon 2018 talk. That recording is still being released, but my [slides](https://github.com/CppCon/CppCon2018/blob/master/Presentations/class_template_argument_deduction_for_everyone/class_template_argument_deduction_for_everyone__stephan_t_lavavej__cppcon_2018.pdf) are available.
You can though. Edit your [settings.yml](https://docs.conan.io/en/latest/reference/config_files/settings.yml.html). 
This is awesome. I don't really how I would go about changing the settings.yml to accomodate the gcc flags. But with package_info I assume I can add additional options to the settings attribute. That would then flip some options in my cmake file. And then by using the same settings attributes I can create a custom id for my package. Hope your following my train of thought.
You'd just pick some names, and add the lists of allowed values in settings.yml. Then conan will let you set them with -s fast-math=True or whatever names and values you picked, just like the default ones. If you open the default settings.yml the syntax should really be pretty obvious. Or you can nest some new sub-settings inside the existing options if you want it to be `-s compiler=gcc -s compiler.fast-math=True` (that way existing packages that say settings = "compiler" would include this setting in their package_id by default. If you add new top-level keys, any package that cares would need to list them in its settings=line. If you want the matching to be more sophisticated than the key name and value, verbatim, you'd have to implement a package_id method to decide when you care about which ones. Obviously you also need to include some logic in your build method and CMakeLists (or whatever build tool you're looking) to convey the conan settings and actually build the package with corresponding compiler flags.
I watched it for you.
Does it ever do better than clang-tidy, though? 
Awww shit, didn't know that! Thanks! Yeah I'll definitely turn off -O0 then. It makes sense. I think the size growth may come from the lack of some other optimizations (I think small function inlining may help a lot by allowing the compiler to see through a lot of stuff, allowing it to remove a lot) but that's just a hunch.
Why was CTAD not supported from the start like deduction for function templates? And why was it added now? Did anything change?
Change log not mentioning about mercurial diff being fixed, sad.
 &gt;I'm wondering, why do other IDEs use the clang-format binary (e.g. VS), while QtCreator seemed to have integrated this more tightly with LibFormat? I'm guessing because there's no way for a plug-in written in JavaScript to link with a library but there's a built-in way to just run new processes.
Thanks very much for your reply! Could you show me how do you think defining read() and write() properly? Thanks in advance! 
It is possible. Just like function templates, if every template argument can be deducted from the constructor, then you don't need any deduction guides. I don't know about the other stuff though.
I believe that's exactly what it's meant to be.
PDB files that are uncompressed, and potentially multiple times the size of the binary and all the libraries the binary links to. For my use case, the PDB files represent a significant bottleneck in my build process, both generating them, and shoving them off to storage somewhere.
Thanks! That‚Äôs exactly what I and the rest of the MSVC team were hoping to hear. üò∏
I try to make my slides relatively readable by themselves, although the recording will give more context and emphasis.
Great article, however the code and CML sections needs some formatting love (no double line breaks, monospaced font, coloring, ..).
Besides read() and write(), my C++ encapsulation also saves you from considering freeing resource (such as memory, socket) and faciliates you to use libtls (at least from my own view, a simple C++ interface). OpenBSD's netcat code uses libtls, but also needs great care to guarantee freeing all resource correctly (e.g., I find a bug this month:http://freshbsd.org/commit/openbsd/8ca9d63f60e7b0b7f2515d4aff9a56c54f767818). 
&gt; Is that what you were saying? I think that's an alright way to put it in C++ terms. In general, reaching a function that uses target features at run-time, in a machine that does not support those features, is undefined behavior (in LLVM, most assemblers, and most hardware, particularly Intel CPUs). So in C++ terms, you would then have to use Concepts / `requires` clauses to make sure that an SSE4.1 function doesn't call an AVX function without checking at run-time whether AVX is available and so on. The approach also gets more complicated if you want to use dynamic dispatch (e.g. via type erasure - like `std::any`) because all these functions are "implicit templates" as you put it, so you would have to instantiate them for some features at compile-time to be able to do dynamic dispatch on them. In some sense, target features kind of fix on with CPUs the function can execute, and its not that different from other C++ features like `noexcept` (whether the function can be called from code that must not throw), `constexpr` (whether the function can be called in the "CPU" that the compiler can emulate), `const`, etc. An Effect system is just a "fancier" language feature to abstract about these effects (target features, `constexpr`-ness, `noexcept`-ness, etc.), for example, if you have to write generic code that is not only generic over types or values like templates, but also generic over `constexpr`-ness, `target-feature`-ness, etc. 
&gt; std::vector certainly is dynamically sized; i.e. vector::size() is dynamic Technically, `vector` uses dynamic memory, which is different from being a dynamically-sized type. The size of a type in C++ is obtained using the `sizeof` operator, and `sizeof(vector&lt;int&gt;)` is not a dynamic value, its a compile-time constant. This might be weird to think about in C++ because it doesn't have dynamically sized types. It might be easier to think about this in C, since it has VLAs, which can also be put on the stack but their stack size is dynamic, and which can also be put as the last element of a struct, making the struct a dynamically-sized type. C++ already has some forms of dynamically sized types, e.g., when you have a pointer to a virtual-base class, the object behind that pointer does not have a size known at compile-time. There are also pointers in C++ that are larger than normal pointers (e.g. pointers to member functions of virtual classes are often two pointers wide). I fear that this proposal is doomed because it proposes adding dynamically-sized types to C++ without thinking it through - it's a hard topic. Many people, including Bjarne, have proposed adding much more limited forms of DSTs to C++ (the VLAs proposal from the 2011-2015 period) and they all failed.
Any recommendation where to put deduction guides? In case of overloaded operators they simply don't compile if a declaration is not visible. But in case of deduction guides if one is not present (or just not visible) it makes the difference between `&lt;const char*&gt;` and `&lt;char[N]&gt;`.
&gt; uses dynamic memory, which is different from being a dynamically-sized type Thanks for the nomenclature lesson (I mean it; it's important to speak the same language). Though from a quick search it seems DST is mostly Rust-speak, whereas in the C/C++ world people talk about VLA and `alloca` specifically. The Array TS drafts called it "array of runtime bound". There's little talk about the underlying family of types. Which is why (I guess) the ARM paper had to invent the term *sizeless*. FWIW, I still believe the use of *dynamic* for such types is unfortunate, because dynamic memory typically refers to heap allocation. Quoting [Wikipedia](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Rationale): "The C programming language manages memory statically, automatically, or dynamically. [...] automatic-duration variables are allocated on the stack and come and go as functions are called and return" &gt; C++ already has some forms of dynamically sized types Base *a = new Derived; // heap allocated Derived d; a = &amp;d; // points to the stack, but sizeof(d) is known at compile-time constexpr x = sizeof(&amp;Derived::member_fun); // well-formed &gt; I fear that this proposal is doomed Right, that's why the proposal can't progress unless DST becomes a thing in the language first (via an EWG paper).
But then it's too small to be worth standardizing (at least that's the response I expect).
I don't think so, the capacity of the language syntax to reflect the developer intention is a big deal. In Java you have to explicitly write which method throws an exception so that when you call the method you either have to catch it or explicitly write that your method can throw too. This is the same kind of deal, we just want to signal the caller that this pointer can be null (it's not a pointer anymore but it conveys the same meaning).
Oh, I forgot about the deduction guides. Have not yet had an opportunity to try this out myself. Given the need of those I understand CTAD was not supported earlier, the deduction guides seem pretty complicated.
This is surely actually C, not C++?
Yes, and javascript has basically the same conversions, evaluating it to 0 (because the empty string is converted to false).
Also a favorite for me: a+++b Compiles in C
J language says hello :-) The difference is that in J it would throw an error...
&gt;You should use QString() instead of QStringLiteral() and QString("") instead of QStringLiteral(""). What is the difference between QString("") and QString()?
We inherit the OP's claim from C, not C++. Only thanks to C does `-1 &lt; 1U` evaluate to false.
That doesn't absolve Javascript of any of its sins. Of which it has many.
As far as I know, this works the same in just about every language with a post-increment operator. It even works in Python, which doesn't, but parses it as `a + +(+b)`.
The standard requires that when you convert `true` to `int`, you get 1. It doesn't guarantee the representation of `true`.
Cute, but this is a remnant of C's legacy. C++ actually gives you the tools to avoid this (e.g. `explicit`, as mentioned in the article). All this does is make me hate C more :)
OK, it makes sense, thanks.