A few comments [here](http://blog.marcocantu.com/blog/delphi_2010_released.html)
Delphi development and programming services by OTS Solutions LLC. 
That's great --- one wonders why there are so few postings in this subreddit
I love it. It's far too pricey for me though, being someone who designs/codes mainly as a hobby and is currently saving up for C&amp;C4. I'd certainly use this. I've only found one slight issue that's nothing more than a very minor breach of expectation: &gt; EditorForm.OKButton.Default:=true; I'd also like to be able to place a blank form object... But maybe I just missed it when I looked. 
Unless the UI elements can be converted to actual usable code automatically, it's not worth the price ---- just as easy (indeed easier) to use some yellow stickies. 
Whatever works for you. Yellow stickies are pretty good for mockups, too (white paper is better, though :), unless you want to share your work and you don't have a scanner. Creating mockups is different from creating a working UI prototype (like Delphi forms), from which you can generate code; they are for different stages of development/planning and for different purposes. Thanks for your feedback!
Thank you! Agree on Default :) As for blank form object, there's a box, do you mean that?
Yeah, the box is cool but, the lazy shit I am, I'd like a box that includes a window-like titlebar and min/max/x buttons, for when I want to show someone an application UI design.
ScreenSketcher was developed by [Jacob Thurman](http://www.jacobthurman.com/?p=56) using Delphi.
I have found my own delphi books largly unread, since I usually find what I need in the help pages. All the easy/middling stuff is available at a press of f1 and the more technical stuff is available on the internet, with examples. Probably not the answer you wanted, but it could save you from buying a book that you never read.
I would highly recommend Marco Cantu's Delphi 2007 Handbook (http://www.marcocantu.com/dh2007/). He also has them for Delphi 2009 and Delphi 2010. As ws1984 says, a lot of the information you're likely to need is online too but sometimes a book explains things better.
It's pretty sad how Delphi got muddled up with the whole .NET thing. Never compete with Microsoft when they're calling the tune, especially in a core area like tools.
urusai: I actually quite like Delphi Prism, it's a great tool. I think the mistake was the original Delphi .NET when the burden of their toolset couldn't keep pace with .NET Development.
thanks, I'll have a look at your link and yes I've already read some very nice explanations of object pascal in these links http://www.latiumsoftware.com/es/articles/00012.php (In Spanish) http://edn.embarcadero.com/article/34324
BTW I also found this http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/devcommon/languageguidepart_xml.html
Great idea. Not only are languages like Pascal much better for teaching and encouraging abstraction based top-down development techniques, it is often just easier to get things done in those languages. I have yet to encounter a project where I wished I was using C++ or Java instead of Delphi....however, I have certainly run into cases where languages like PHP or Ruby were more convenient.
At least students still have access to a low cost version of Delphi.
I did some friend's Pascal homework for a case of beer in college four years ago. Had to learn Pascal for that. That's about it.
1st question for you: Which version will you be using? Definitely worth reading Nick Hodge's guide to "what's new in Delphi since Delphi 7" which is slightly out of date for Delphi 2010 but shows a lot of useful stuff: http://edn.embarcadero.com/article/34324 Would also recommend the appropriate versions of Marco Cantu's books to help get you up to speed: http://www.marcocantu.com/books/default.htm 
&gt; 1st question for you: Which version will you be using? Delphi 2010 Thanks for the link!
Excellent, advised to look for recent articles on any component sets particularly heavily used by your application (eg Any Database components or reporting components). The bits I would have hated/loathed about Delphi until recently were the lack of full object reflection capability but that has since been resolved in Delphi 2010.
I haven't used Delphi but I have used FreePascal, I would suggest reading the libraries really carefully. 
I use [Delphi Basics](http://www.delphibasics.co.uk/) as reference. [About.com](http://delphi.about.com/) is also an excellent reference for everything related to Delphi. To get a feel of what you can do with Delphi, here's a shortlist of some [well-known software developed in Delphi](http://delphi.wikia.com/wiki/Good_Quality_Applications_Built_With_Delphi): Auslogics Disk Defrag, Skype, MediaMonkey, MySQL Administrator, Webroot Spy Sweeper, Spybot - Search &amp; Destroy, SyncBackSE, KMPlayer, Space Rangers 2 etc. The only thing I dislike about Delphi is that the IDE (using 2007 currently) can be unstable.
I'm actually PKV in my products now, the idea is brilliant! Obviously, I replaced the PKV_GetKeyByte with a hash checker, and added support for string seeds, and other things that make it a commercial viable solution. But his article is fantastic as a starting point!
Delphi has hovered about the #9 or #10 mark for some time but the ascension of Objective-C would appear to be responsible for this... those pesky iOS devs!
A very helpful article indeed!
Actually, it didn't fall compared to the same month in previous year, also there's small increasing " +0.33%", but it didn't make it come to the top 10. 
It's too bad this article is only about FPC, and not about Delphi itself. As far as I know, no information about the future 64-bit Delphi compiler has been released.
What about cross-platform, or 64bit support? I hope they don't screw all this up again :-( All I could hear and read was SVN (what about other DVCS), modeling, web, and OMG (tool)cloud bullshit. We'll see what happens next, but it's a damn shame, because Delphi had so much potential.
Agreed. SVN integration is a welcome but not exactly ground-breaking change. I'm still holding my breath (possibly foolishly) for the cross-platform preview to see how it is implemented.. 
Come on Embarcadero, this is all good but is ultimately small change stuff at the moment! Stop withholding the juicy stuff!
"Nihil novi sub sole". i.e. "Nothing new under the sun". Need 64 bit support or cross-platform SW? Go to Lazarus or http://www.twinforms.com/products/wxformsdelphi/index.php
The last Rad Studio XE screen shot didn't talk about 64 bit Delphi compiler at all. :(
So how soon do we take over the world?
http://www.google.com/search?hl=en&amp;q=read+hard+drive+serial+number+delphi&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai= leads me to, for instance, [http://delphi.about.com/od/windowsshellapi/a/volumeserial.htm](http://delphi.about.com/od/windowsshellapi/a/volumeserial.htm). HTH.
If you want to tied it to the motherboard, a google for "read motherboard serial number delphi" brings me to http://www.latiumsoftware.com/en/delphi/00050.php
Not quite what you're after, but it's a really good article that was posted on the subject of serials: http://www.brandonstaggs.com/2007/07/26/implementing-a-partial-serial-number-verification-system-in-delphi/
what, no wallpapers?
useful to have though!
Good links
If only!..
I'm not very exciting by these new features... It sounds more like fixes and inclusion of third-party libraries. Nothing worth upgrading to XE.
I'm no RAD man. What I like with Delphi, is the object pascal language. The RAD approach is good for designing forms, but I prefer real classes instead of non visual components. Thanks to the good IDE, you can navigate in the code even more easily than in your data modules.
Somewhat agree. Not blown away by the integrations they've been tauting, seem more desperate than anything. I am interested in seeing more about some of these RTL enhancements though. 
What could be of some interest, could be to know how the future 64 bit RTL layout. If some part of the Delphi XE lowest RTL (i.e. System.pas / SysUtils.pas / Classes.pas) could already show how to program safely for the future 64 bit compiler: which type to use (NativeInt is OK, but will there be other changes?). So we could be able to prepare our code to this upcoming compiler.
Hahaha :D Awesome. Thanks :) This part got me rolling on the floor &gt; Plus a 64-virgin compiler on arrival in heaven.
A+++++++ Would read again!
Just a tool that am working on
http://www.lenniedevilliers.net/preview/DAndroid_01.avi
Very interesting lenniedg2000, any plans to write it up in the near future?
I'm still working on it, first goal is to complete the tools core to make it easy for me to add controls, Android framework functions etc... As I make progress am going to post more videos. 
Not worth buying it for me. Sorry. :(
Sounds like it will be a good quality release though, I like the sound of 80+ Generics bug fixes! (even if they arguably should have been part of the initial generics release). You need to decided your own upgrade value calculation.
Rob got a video of it (http://robstechcorner.blogspot.com/2010/08/rad-studio-xe-delphilive.html), keep an eye on the VDUG site for it in the next few days. 
Thanl you. With nothing on youtube i was wondering what the silence was all about.
i cant seem to find the VDUG site, can you link me?
Sure, it's http://vdug.org/
I've tried it in a VM, and it does the same thing. Disable error insight and it won't happen. I wonder if EMB has any QA? If this thing isn't sad, it would be very funny. 
The bug was officially fixed by EMB. You'll have to wait for an update, in order to use Error Insight. See https://forums.embarcadero.com/thread.jspa?threadID=42743
Sure it's "fixed", after I reported it on the forums. The point is, this should have not happened. You write **if a &lt; (** and the whole IDE starts leaking memory like crazy. This is just embarrassing, and shows how good their QA is. Anyway, I won't be buying this release anyway (noting really interesting in it), D5 serves me well for the legacy code I have to maintain. 
Sure is taking a while to upload a video to a website. 
more info: http://lenniedevilliers.blogspot.com/2010/09/delphi-for-android-sneak-preview.html
I don't use any particularly special keyboard, let alone a pascal optimised one but this rather [standard dell one](http://accessories.euro.dell.com/sna/productdetail.aspx?c=uk&amp;l=en&amp;cs=ukdhs1&amp;sku=580-14366).
http://lenniedevilliers.blogspot.com/2010/09/delphi-for-android-sneak-preview-2.html
So are you writing wrappers around the native GUI elements? This looks exciting. 
sort off yes but i say its magic ;)
If it helps, I'd be interested solely in Delphi.
pure awesome..
Actually he used the FreePascal compiler to produce binaries for iPhone, but you can do all the work on delphi then compiler with FP.
Nice to see another VGScene subscriber! I &lt;3 VGScene!
Firstly I think you may be trying to get the variable 'students' as the uppermark in your for loop and not 20. Let any other variable be the counter, not students which should be the total number of students you want to enter the marks for. Secondly, you have two choices here. First, you can make a large chain of if-else statements to achieve the logic. What is happening right now is that a mark of 78 is &gt;=40 and 55 and 75 giving you all three results. A neater approach is the 'case' statement where the mark would be the control variable of the 'case'. Have a look at any text you refer for the syntax of the 'case' statement. The concept is similar to the 'case' of other languages.
The other thing you might consider is constraining the if clause more tightly: if mark &lt; 40 then writeln('Fail'); if (mark &gt;= 40) and (mark &lt; 55) then writeln('Pass'); if (mark &gt;= 55) and (mark &lt; 75) then writeln('Merit'); if mark &gt;= 75 then writeln('Distinction');
Hey there! First off, in this case, you probably want and to structure it like: if blah = 1 showmessage('1'); else if blah = 2 showmessage('2'); else if blah = 3 showmessage('3); else showmessage('not 1, 2, or 3'); That way, only one condition will ever be used. Aside from saving time on CPU by not rewriting the variable, you won't process each result before the one you want to see. To properly handle order the conditions, you can do it two ways: 1: Checking for lowest score, to highest. Check for lowest (&lt; 40), then check the next lowest (&lt;55), etc. until you hit the top. The topmost score doesn't need a condition because it failed all the others, so just have it in an *else* 2: Going from top down. Check for the highest score (&gt;= 75), then the next highest (&gt;=55), etc until the lowest. Again, the lowest just needs to be an *else* because it didn't meet any of the other criteria. Hope this helps! edit: just noticied that it took me way too long to respond! haha
I don't think you can do ranges with the case statement.. unless you have a case for each possible mark (except for the last criteria, which can be grouped in the else.. 60 possible cases?) As for the students variable, I agree with you. He will need an iterator variable (i?) to act as the iteration index, where i = 1 to students
Yeah, I just noticed the 20, that's not the issue, though thanks for pointing it out. I can't do it with cases can I? They can't do things like this can they? Wouldn't I have to enter each value as another case?
The 20 was a mistake, it should have been students.
Thank you! This works perfectly. I tried using and before, but didn't use brackets! 
Actually 'case' can work with ranges. In this case, you can try something like case mark of 1..40 : writeln('Fail'); 41..75 : writeln('Pass'); 76..100 : writeln('Merit'); end; This would achieve the same result without using a case for each mark and without using an if-chain.
You can do this with a case statement. See my reply above to thestamp. Case does work with ranges and it just seems like a neater approach to me eyes. And you won't have to enter each value as another case.
I used someone elses suggestion. I used and previously, but didn't use brackets, so it wouldn't work. 
Interesting! I'll try that out sometime!
http://lenniedevilliers.blogspot.com/2010/10/delphi-for-android-going-open-source.html
I've just read this on EMB's fora, and can not believe that they would leave this out for x64. &gt; possibly support for linking in object files assembled with something else Well that's just great, NOT :( And the lame excuses begin again, A. Bauer said that 64bit VC++ does not support this either. Well, gcc does, and it does not matter, because Delphi is supporting it right now. Lame EMB, very lame. Fire all those Borland monkeys and hire new people ASAP. 
Stupid. Assemblers are easy to write. In fact, if you haven't written one yet as coursework, you need to go finish your CS degree.
Er.. This is about BASM (inline ASM) - writing ASM directly in pascal source. Currently you could write something like: function Foo(X, Y: Integer): Integer; asm mov eax,X add eax,Y mov Result,eax end; instead of purepascal: function Foo(X, Y: Integer): Integer; begin Result := X+Y end; I've been using this for hand optimizing routines for a long time. Also, it is very useful for scripting engines for example, and a few other cases. 
I know. Throwing together an internal assembler should be especially easy, since you don't have to worry about macros, .CODE/.DATA, etc.
Good to see a Delphi magazine still in circulation!
Another step towards assembler becoming a forgotten art.
There's an Arabic Magazine published as PDF by Arabian Delphi forums http://www.delphi4arab.com/forum
link? :)
sorry, Added.
Congrats to the fpc team!
&gt;this should have not happened That applies to all bugs, even yours. I would've never noticed this one because I always write if (comparison) then //... or if BooleanVariable then //...
this looks great ... let`s hope more VCL components will be supported in the future
Agreed!
A must for any Delphi developers that can get there!
Glad you feel so strongly about it. ;-)
great sessions on homepage!!!!
oops.. ;-)
Who's purchasing a copy for home?
I totally am! 
I do not see the price anywhere. 
What about if you click through to the Emb store?
With the lack of VCL/RTL source code and the Ctrl+Alt+C shortcut not working, I definitively won't put any money in that version! :(
I don't need the source, and the ctrl-c and ctrl-shift-up/down will quickly be addressed by an OTA addin i'm sure.
I've owned professional versions of Delphi for more than 15 years, and have rarely, rarely even peeked into the source code. Maybe I'm just doing it wrong. I will miss Ctrl-Alt-C to create class methods, but that's a minor thing. I preferred using CodeRush (when I worked in an office that had it) anyway.
I just did.
http://code.google.com/p/delphidroid/
I wonder if it can be used with firebird :) http://blog.cincura.net/232132-connecting-from-android-to-firebird/
Oooooooh
Does this mean that you can create Android apps in Delphi? Also, has anyone had any success/experience in creating iPhone apps with Delphi?. I have been asked by my boss to skill up in Cocoa, but I would rather go with the Delphi/Mono route as I already have several years of Delphi under my belt and was wondering how suitable it is, or if there are any gotchas.
And a very good example of DI.
Thanks for submitting my article.
No problem, it's a great read :) Love the wallet analogy, and was a welcome sanity-restorer after inheriting some code from someone who definitely hadn't heard of the LoD ;)
That sounds quite complicated... [Just write a z-machine game.](http://www.inform-fiction.org/manual/html/s3.html#s3_1)
If you want a combobox that looks like a label then that should be straightforward (for example, you could create a sub-class of TComboBox and override its paint method). This presumes you're happy with happy multiple labels interspersed with your custom combo box. I've uploaded a [prototype](http://www.alimonster.co.uk/downloads/HotspotLabel.zip) of what you described in your post: a single label with items that you can click on to select (Delphi 2009 - although you might be able to install it in earlier versions, dunno). It's probably buggy and it lacks some useful functionality but it could get you started. (Some missing features/bugs - ability to use stuff other than comboboxes to select items, handling wordwrap nicely, making it pretty, keyboard navigation as TLabel's based on TGraphicControl, removing the reliance on markers in the strings so you can specify them independently). If any or all of the above flies over your head then it'd be a good idea to follow creaothceann's advice and simplify matters for yourself. GUI stuff can be annoying when you're learning to program - but you've not said what level of programming experience you have so I don't want to sound patronising either. :) EDIT: if you're doing a game then you should take a look at [PascalGameDevelopment.com](http://pascalgamedevelopment.com/) for lots of like-minded people.
So... what does it do? Not much on their page.
About time that they should take another swing at the VCL..
I was at the Auckland, New Zealand product launch for XE2. Wow. Best thing to happen to Delphi since I started on Delphi 7. Can't wait to create some 3D GUI's.
Good news, if this is the truth and not just some marketing bullshit.
I would love to go back to Delphi again and am eagerly waiting to see if they can deliver for OSX
How many of those people have used it in the last few years at work? There are absolutely no Delphi jobs where I live in London, the language is dead in commercial settings, apart from supporting legacy applications, and porting them to C# and those jobs have pretty much dried up due to the economic circumstances
I wonder if it'll be a debacle similar to Kylix.
Yeah, I had great hopes for Kylix --- wasted a lot of time with it. I wish there was a decent RAD environment for FPC (Lazarus is not there).
It isn't, although the Lazarus team did make good strides in the past years. Plus I like the idea of compiling to different toolkits a lot, Delphi could learn something from that. 
We use it for our primary project. Our database server also uses it extensively for their front end projects and are starting to use for their web api's. Because of that, I meet many companies every year who use it for their primary apps. This is North America though. 
I am currently using it (Delphi 7) for an optometrist dispensing kiosk app that I have written. I really love it. I have yet to come across anything that it can't do either natively or with one of the many dozens of third party component libraries. Have tried the later versions, but I just think that D7 hits the sweet spot as far as IDEs go. We actually just recently won a [BRW Best Use of Technology in Retail award](http://www.brw.com.au/lists/specials/retailer_of_the_year_2011) with it. Also most GPs/medical practises use a Delphi app to process patients. There is also a major bank here that has a lot of core systems written in Delphi. It is a real bummer that the chief architect for Delphi was poached by MS to develop C#
I don't dispute Delphi is a great language for small and medium sized enterprises especially when interacting with databases (I worked with D7 for 5 or 6 years), it's fairly simply to write and is a powerful language, it's just that very few companies who are planning new software systems (and in a near/real recession that becomes something they try to delay) would think about going down the Delphi route, Borland (et al)'s continual failures have all but killed it as a language worth knowing going forwards. I wish it weren't the case, I wasted 2 years trying to get a new Delphi job after I was sacked shortly following the financial crash, and I'd have been better served spending that time learning C# or perhaps Java, it's where the work is, as there really is fuck all doing Delphi. There are some jobs supporting legacy applications, but all those want either C# or Java so they can port existing code over to more up to date languages.
I think the title buries the lead. FTA: "Delphi sales have steadily grown by 15 percent year-over-year since 2008" This is talking specifically about new sales, not old copies of Delphi 7 that are collecting dust on someone's shelf. This suggests that Delphi's usage isn't shrinking, but growing, and at a healthy pace. Speaking for myself; In spite if its ups and downs (and there have been some doozies!), Delphi has been a substantial part (&gt; 80%) of how I make a living since it was introduced in 1995 in applications that range from tiny command line utilities up to multi-tier applications with hundreds of users across half a dozen countries. I'm surprised people aren't seeing more Delphi activity in the UK, especially since their largest exam board (AQA) is recommending it: http://store.aqa.org.uk/qual/gce/pdf/WITHDRAWAL_OF_COMP1.PDF 
***mjsoftwareUK***: &gt;[2011/09/04][10:11:25] &gt;[[Translate]](http://translate.google.com/#auto|auto|“@PascalCoder: Made an iPad app with Delphi XE2! Very excited!!!” RT %2D Same here! 'google translate this tweet'): “[*@PascalCoder*](https://twitter.com/PascalCoder 'twitter user profile'): Made an iPad app with Delphi XE2&amp;#33; Very excited&amp;#33;&amp;#33;&amp;#33;” RT - Same here&amp;#33; ***PascalCoder***: &gt;[2011/09/04][22:08:50] &gt;[[Translate]](http://translate.google.com/#auto|auto|@mjsoftwareUK The iPad app I made: Check it out! http://t.co/FtIDldD http://t.co/5cjPKE1 'google translate this tweet'): [*@mjsoftwareUK*](https://twitter.com/mjsoftwareUK 'twitter user profile') The iPad app I made: Check it out&amp;#33; [*i.imgur.com*](http://i.imgur.com/cv7lu.jpg 'url unshortened via longurlplease.com, images rehosted by imgur.com') [*i.imgur.com*](http://i.imgur.com/U24LO.jpg 'url unshortened via longurlplease.com, images rehosted by imgur.com') [[This comment was posted by a bot][FAQ]](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[[Did I get it wrong?]](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/delphi/comments/k4qqn\) 'report an error')
What the? Crazy :P
Starter edition is $199, I would go with it.
Lazarus is pretty good for an open source alternative. It's a little clunky at times and can be a little difficult in using the IDE but it's still fairly good and usable. I'd try to find the "Personal Editions" of Delphi since those were typically free and without limitations other than commercial purposes. I know it's going to sound dumb, but you can also just download a trial and see whether you like it. Anyway I use it quite often and really like it. Hope you do too. Good luck!
Depends on what you want to do with it. You have a few options. Lazarus and FreePascal isn't Delphi, but it is a modern Object Pascal with useful libraries for creating visual applications. There are a few rough corners on it though. Another option is Embarcadero Prism (FKA Delphi Prism), which gives you Object Pascal and full access to the .NET Framework for ASP.NET, WPF, Silverlight, WinForms, etc. You can pick it up from http://www.remobjects.com/shop or directly from Embarcadero. Coming in the near future is Oxygene for Java. It uses the same compiler and language as Prism, but targets the Java and Android platforms. You can find that at http://www.remobjects.com/oxygene/java.aspx Both Prism and Oxygene for Java run inside Visual Studio (included), so if you are used to Visual Studio that might be a major plus. Of course if you really want to use Delphi then get the free trial, and then you will probably want to upgrade to the Start edition for $199. It has a limitation of $1000 annual revenue, which is no issue if you are just curious. 
Try [Delphi 7 SE](http://villavu.com/forum/showthread.php?t=3408) Pretty sure Delphi 7 is still the most popular version (if it isn't first it definitely is in second place). It is still compatible with almost 100% of all modern components and is very light and fast. If you need the indy components you can get them [here](http://www.indyproject.org/index.en.aspx). Also you can pretty much find any component you need from these sites:[hidelphi.com](http://www.hidelphi.com/), [delphifans.com](http://www.delphifans.com) and [filecrop.com](http://www.filecrop.com). Just make sure you scan them with [jotti](http://virusscan.jotti.org/en) or [virustotal](http://www.virustotal.com/) Also I have found the DevExpress suite to provide 80% of my component needs. Their theme/skinning suite is the best I have found (very easy to create/customise skins) and for database connectivity you can't go past UniDAC. If you are new to writing compnents, try [Component Create](http://www.torry.net/tools/components/compcreation/cc40.zip) or [Component Builder](http://www.torry.net/tools/components/compcreation/cobuild.exe). These give you a basic skeleton that you can build on.
Could it be related to this? http://stackoverflow.com/questions/2156013/savedialog-execute-not-doing-anyting-in-window-7 
Very interesting! I applaud, and graciously thank, your sharp eye and excellent memory / tracking skills. I had not found that stuff in my searches. It turns out that most of what's in that thread (and another, linked to, at Embarcadero) doesn't help -- but one offhand remark *did lead to a solution!* Turns out my app uses a .ini file that specifies, among other things, the default / last-used data file name. This is used as the initial value of the SaveDialog's FileName property. **If that property's value is not a valid file specification, the Save Dialog will not appear!** IMHO this is a goofy design decision on someone's part... but "it is what it is." I can solve the problem for my current customers by having them (ugh) hand-edit the .ini file, and can put code in the next release to validate what's coming from the .ini file before feeding it to the dialog. Thank you very, very, very much for pointing me in what turned out to be the right direction. 
I'm surprised by this news.. I work in the southeast USA, and we have used Delphi exclusively at my workplace for the last 15 years, but I've never met anyone else who uses Delphi. I've been working on maintaining legacy systems since I started here, but right now I'm trying to figure out how to use Delphi to create a new web application.. really have no clue what I'm doing. Delphi for PHP? RadPHP? I'm pretty much lost.
Why are these fixes not already in Delphi?
So go on, tell us dumbasses what a flair is, and how to use it (please)
No worries, can you see a checkbox and a link below the subscribe/unsubscribe button to the top right of the page with an edit link?
Ohh yes, thankyou.
Good question. I think he does contribute quite a few fixes back to the Embarcadero team, if nothing else.
We could do with some styling for them, but I wasn't sure what to style them. Any suggestions? 
Many of the IDE performance improvement on recent version are result of Andreas work, so he always debug and IDE better, then they add his work on newer version of the IDE.
The last 5 releases? Hmm... that would be 2007, 2009, 2010, XE and the just-released XE2. If I had to rank them, I'd say there's been a steady progression in quality from 2007 to XE, each release being better than the last. XE2 is a bit different, though. It adds a lot of new features, including 64-bit compilation and cross-platform development, but at a noticeable cost in stability. If you need the new features, XE2 is your only choice. (Yes, there is Lazarus, but it's missing a lot of the basic language feature set, especially the cool stuff added in the 2009 and 2010 releases.) If not, I'd stick with XE for the time being. Though it's worth noting that Embarcadero is very much aware of XE2's shortcomings and they're working on it with a pretty aggressive update schedule. My recommendation: Buy XE2. Included in the license will be licenses of earlier versions back to Delphi 7 at no additional cost, which is pretty cool. Then see if XE2 works for you, and if not, you can download and use XE, which is pretty solid.
Not true. There have been several unstable releases (notably Delphi 8/.NET and Delphi 2005/D9), but now they're pretty stable and starting with Delphi 2010 environment is really fast. Language and compiler also got various upgrades, you can now use Generics (C++/C# "templates"), operator overloading, records with functions and more. All in all, Delphi 2010+ is much, much better than D7 in almost every way. As for Unicode, you could always be Unicode-aware, even in D7, by using WideString instead of string/AnsiString and using TntControls. You can certainly do this in Delphi 2007 too. That's the last one where string is defined to be AnsiString. Starting with Delphi 2010, string==UnicodeString and you get full Unicode compatibility by default (you still have to mind various international stuff but that's another story). Delphi XE2 introduced compiling to both 32 bit/64 bit. So, if you just want to get the best one and have no compatibility requirements, take XE2. It is certainly the most powerful Delphi right now, has the richest feature set. If you need compatibility with the old code which relies on string==AnsiString, take Delphi 2007 + Updates.
You read wrong. After a couple of (let's call them "challenged") releases, Delphi 2007 was the first release that surpassed Delphi 7. Each release since has improved on the previous releases in features, stability and usability. The latest version (XE2) works very well (I use it daily), even though some bugs have been introduced. If you want to use the most stable release as of right now, I recommend XE.
Some solid advice here already. I'd recommend going for XE2 if these are new projects, simply because it already contains the latest features and will smooth the path slightly if you need to upgrade at some point in the future (e.g. more platforms for firemonkey?).
Each release is better than the last, in my opinion. My major grievance with Delphi is what I refer to as toy features that are crammed into each new release. I really wish that Embarcadero would focus exclusively on the core product. Getting the IDE solid. Fixing bugs and really getting the documentation up to speed. They should leave component development to third parties. The quality of their own work is clearly lacking in that department.
Have you learned about trees yet? Because this would be pretty easy to implement with a tree in which each node has five children...
No, we didn't. And it has to be console application tho :3
here is an answer :) program Project1; {$APPTYPE CONSOLE} {$R *.res} uses System.SysUtils; var i,j,k,L,M:integer; begin try { TODO -oUser -cConsole Main : Insert code here } writeln('Groups of 1');readln; for I := 1 to 5 do write(i,' ');writeln; writeln('groups of 2');Readln; for i := 1 to 5 do begin for j := 1 to 5 do write(i,j,' '); writeln; end; writeln('groups of 3');readln; for i := 1 to 5 do begin for J := 1 to 5 do begin for k := 1 to 5 do write (i,j,k,' '); writeln; end; writeln; end; writeln('groups of 4');readln; for i := 1 to 5 do begin for J := 1 to 5 do for k := 1 to 5 do begin for L:= 1 to 5 do write(i,j,k,l,' '); writeln; end; writeln; end; writeln('groups of 5'); readln; for i := 1 to 5 do begin for J := 1 to 5 do for k := 1 to 5 do for L:= 1 to 5 do begin for M:= 1 to 5 do write(i,j,k,l,M,' '); writeln; end; writeln; end; readln; except on E: Exception do Writeln(E.ClassName, ': ', E.Message); end; end. 
Thanks, but it should work for groups of 6 and so on, but I will edit it(I hope so)! You shall dive in karma! Thanks.
I had a look at the trial version of XE2 and everything was fine until I tried to create a custom dialog based on OkCancelDlg. I found the IDE got stuck in a loop about "missing OkCancelDlg" after I renamed the dialog to what I wanted. I eventually figured out the .pas file had been updated but not the .dfm. Sad to see Delphi QA is as bad as ever. I had a look at the latest Lazarus as well, quite a good package. Unfortunately I have been working with C# and WPF does blow away Delphi to some extent.
Really? I thought Delphi was in decline. Occaisonally I've been asked about jobs for Delphi but rarely. Everyone is interested in C# and WPF.
I guess this is kind of interesting as a research project, but after going through your examples, I have a hard time seeing how this could be of any use in the real world. Maybe I am just completely missing something.
Ask Embarcadero? 
http://code.google.com/p/delphi-orm/
Sounds like what Perl CGI scripters would say about PHP in its beginning days. You're part right, I'm late to the game and there's a lot of options to choose from that have proven their worth. But that won't keep me from letting this thing do any trick I can think of, and draw the best possible performance from it. In the mean time it is already doing just fine in the real world of my day job for several (internal) websites. Perhaps if I would have an extra 30 hours per day I could look into the code of wordpress/drupal/typo3/joomla/phpnuke/... and port it. But what I really need to know fow now is to get to know the people that fit into this narrow niche (if any): advanced Delphi coders (that do loads of non-UI work) that are also advanced in HTTP/CSS/JS/XML/SQL/NoSQL/...
actually XE2 does with help of FreePascal compiler. Native OSX compiler planned later this year
Not bad at all but it uses Generics so it limited to recent Delphi versions. Many people still using D2 even :)))
I went slighly diffrent way :) - using IE5.5+ XML parser via OLE2 late bindings. Works well even for long and complex documents and source just slighly bigger than yours. Interested? :))) 
Are you sure you don't mean registry? I don't think you can save settings to a normal exe file. (In any language.) For one thing, if it is installed using a regular installer, it resides in a subfolder of C:\Program files\ which is a write protected folder unless you are administrator. Whenever I need to save program settings I usually use one of three methods. TStringList.Values, for key-value storage saved to a .ini file somewhere. TClientdataset either saved to a database or using a binary storage file. TRegistry. This is what MS thinks you should do.
I'm positive I don't mean registry. I wrote a small VB app (long since lost the source) that wrote settings to the EXE file. http://www.dondraper.com/2011/01/easily-save-and-retrieve-application-and-user-settings-in-vb-net-or-c-apps/
&gt; "With VB.net, I could save some settings into the EXE file." You probably couldn't. Both Delphi and VB save control properties (which button is placed where, whether checkbox is marked etc) in EXE file on compilation. But you're not talking about that. And there's no way neither in Delphi nor in VB to save anything to EXE file when already compiled. So you're misunderstanding something.
I'm getting into single-file apps. This is something that I'm considering for my app. I use Putty and WinSCP. Thanks for your reminders!
Actually the only way to save settings to EXE - save it to File Streams (NTFS File System only) http://www.tek-tips.com/faqs.cfm?fid=7167
If you buy the current Delphi version (XE2) you still get access to Delphi 7 http://cc.embarcadero.com/item/28123
New features * Embeddable Grid Editors. * 64-Bit support for Delphi XE2 * Seamless keyboard capture and filtering. * Advanced form navigation using customizable keys. * Anonymous Callbacks for D2009+. * 7 new demos to demonstrate new features. * Ext JS run time installer. * Support for C++ Builder uniGUI is based on Sencha's Ext JS library and makes it possible to create rich web applications using Delphi and C++ Builder. uniGUI is not claimed to be ready for production environments and you should take note of the licensing terms of both uniGUI and Ext JS while evaluating the framework.
Excellent
[Yes](http://docwiki.embarcadero.com/RADStudio/en/Release_Notes_for_XE2_Update_4).
file not found.
Well, thanks for the advice. The relevant code is now admittedly less messy: procedure TForm1.FormCreate(Sender: TObject); //this fills the initial listbox (frakcje) var TF : TStringList; begin TF := TStringList.Create; TF.LoadFromFile('pliki/frakcje.txt'); frakcje.Items := TF; TF.Free; end; procedure TForm1.frakcjeChange(Sender: TObject); //this reacts to clicking an item in frakcje var //and loads respective file into okrety TF : TStringList; begin TF := TStringList.Create; TF.LoadFromFile('pliki/' + frakcje.GetSelectedText + '.txt'); okrety.Items := TF; TF.Free; end; However, this still doesn't solve the issue of not being able to click the first item in the frakcje listbox - it still can't find the file (it's definitely there, and the other two work perfectly). Could this be GetSelectedText at fault?
strange, my (cheap) web-host won't serve .pas files. Replaced the download with a .zip, thanks.
I'm not familiar with MySQL, but there are some definite factual problems on the Firebird side. Saying that Firebird is dynamically typed, that it does have a BOOLEAN type and a UNIQUEIDENTIFIER type, and does not support VARCHAR(?!?) or TEXT? None of these are true. (Well, FB has TEXT support, but it's called "BLOB SUBTYPE TEXT", not "TEXT". Close enough.)
Booleans [are in 3.0](http://asfernandes.blogspot.com/2010/12/introducing-boolean-datatype.html). Also, someone might consider implicit type conversion a form of dynamic typing. 
Is 3.0 actually available? There's nothing easily discoverable about v3.0 on firebirdsql.org, and from what I have seen, it looks like it's still under development.
Thanks, I did what you said and it shows the error is here http://imgur.com/KukLE any idea of how to fix it now?
It's probably because you've got different versions of MDAC on the WinXP and Win7 machines. There's a tool for checking the version here: [How to check for MDAC version](http://support.microsoft.com/kb/301202). I suspect it's a COM exception you're receiving, eg. an exception in the external library, not in your own code. Maybe you've simply run into this issue: [A Better solution for the Windows 7 SP1 ADO GUID changes](http://blogs.msdn.com/b/psssql/archive/2011/10/03/yes-we-made-a-mistake-and-are-finally-going-to-fix-it.aspx).
What is the value of ErrorCode? Can you check the call stack (Ctrl+Alt+S) to see if you can spot something more meaningful than OleError()? 
I looked at the bottom link and followed the UPDATE on that page and it led me to some downloads that when i tried to run, said they weren't applicable on my machine.
Yeah, that is definitely a COM initialization error. Error code -2147221163 equals 0x80040155, which is "REGDB_E_IIDNOTREG Interface not registered" according to [COM Error Codes (Generic) ](http://msdn.microsoft.com/en-us/library/windows/desktop/dd542643%28v=vs.85%29.aspx). Maybe your MDAC is broken or you're linking to an outdated OLEDB in your connection string. What is your provider in your connection string? It should be something like "Provider=SQLOLEDB.x.x".
Here are what i'm connecting to, i've tried the top 2 http://imgur.com/2XcHS Thanks for all the help so far!
Win 64bit. I finally upgraded to SP1 and tried downloading some ms hotfix through the links you gave, restarted and got the error again. :(
Thanks for the reply, how would I put an exception around it ?
you're probably better off just changing/rewritting the connection layer. Youre problem is a missing COM component you (or ADO, or ODBC and whatever's behind) depends on. If you really want to debug, you should put a breakpoint on OleError. Don't forget the event log either, it can help with COM.
That's good to hear. Will it finally have support for Packages, Delphi-style? I think that's the biggest omission in FPC/Lazarus.
I don't know. I don't think it will be in this release. My wishlist include docked UI like newer Delphi versions and better support for generics programming.
 try //your code except // end; What other way would you expect? I get paid to make things work, not to make smart coding decisions. 
no problem, needed this for https://github.com/stijnsanders/TMongoWire/blob/master/mongoAuth.pas
I took a look at this a couple of weeks ago as I needed to implement thread pooling for some db tasks in a REST server. I thought it was really hard to figure out which classes matched my use case. The patterns seem very abstract and hard to figure out. I was really missing some proper documentation. I ended up just implementing a couple of thread safe collections that I needed myself and doing a quick threadpool implementation using standard TThread objects.
GExperts saved us months of work switching from BDE to Absolute DB. The replace component function replaced hundreds of TTable components with their Abs counterparts with very little cleanup work needed afterwards. We had anticipated this switch to take a year if we have had to replace the components by hand. Instead we had a test version up and running within a couple of months and were able to complete the transition within one release cycle. As a sidenote, Absolute DB is 25-50% slower than Paradox tables on a lot of critical tasks for us, so switching to a supported database has come at a price.
Most of us use it at work but the managers (who still develop a bit in it) don't. It kills me now because I'll help one of the managers with some code I wrote and ask him to hit Ctrl+G (brings up procedure/function list). Nothing happens. Or when I ask him to right click on the DFM and hide the non-visual components (which really cleans up the form as we have a shitload of them) and I don't see it in the options. Or when I ask him to grep a certain variable to see the number of hits in the whole project folder for that variable and where it's used. In short, GExperts is awesome and I can't live without it.
You can also set [Data Breakpoints](http://docwiki.embarcadero.com/RADStudio/en/Add_Address_Breakpoint_or_Add_Data_Breakpoint).
I use DataSnap - client datasets and dataset providers with queries (FIBPlus for Firebird).
Weird, I have XE2 update 3 right now, and when I 'check for updates' it says there are no updates.
Just curious as to why you chose Absolute DB? (I use embedded mySQL for my local database needs).
Unidac. Unfortunately it is single user for embedded use. I use it for config data, everthing else I just grab from the server. I actually used to use absolute but I wanted to use the same SQL scripts as absolute doesn't support the same syntax as MySQL.
Hey thanks a ton! Works like a charm!
I haven't come across that before, sorry.
Could you provide a copy of the unit that defines TCoFPESO (just guessing, but it might be named "FPESO_TLB.pas") somewhere online like pastebin?
CgDevTools takes great pleasure in announcing a new set of jQuery Mobile components for Intraweb. Main features include: * Support for all popular mobile device platforms * Most jQuery Mobile features (options and client API) * Design Time support with HTML Render * Dynamic runtime Theme support for professional application skinning * Javascript Intellisense Edition for direct Script event handling. * Ajax navigation &amp; transitions * Touch and mouse event support * HTML5 Markup * Mobile project structure is similar to Delphi project, each page is a form We have launch promotions, please visit our web site for more information about our special offers. http://www.cgdevtools.com 
hmm, I only asked the question initially, because I thought it might be free, but the license gave you support etc. But now I just thought of it... "License" most likely implies that you need to pay in order to use it. I don't see the point in this... It's opposite of how things normally work. Hobby programmers can't afford donating $100. And if they donate what they can, say $20, they will have to get a license afterwards anyway. And hobby programmers certainly can't hope for the developer getting $45,000. And if you donated what you could, say $20, and the developer doesn't get $45,000, you essentially "wasted" your money besides supporting the development of this project, which you can not benefit from because it costs more money than you gave. Am I looking at this the wrong way? :/
You are right, but some people may donate what they could offer to say the project alive. but you are right, it's really not something we could understand and support in this way, I think EMB* should give some many for the project to make it alive
No, and sorry it I wasn't clear.
It's all good!
It's sad news, I thought this version will introduce native Delphi compiler for iOS &amp; Android. EMB* became a far behind all other competitors.
Come on...
Spaghetti and meatballs.. Without the meatballs..
If true, they're probably trying to squeeze money out of corporate buyers... Although, I don't know. In this day and age, not many develop for desktop anyway, most anything is on the web now. They should have been expanding on the ability to quickly connect to anywhere, not cutting it.
I am not sure how this is even enforcable? Oh how I wish there was a magic tool to convert Delphi code to C#..
It's official now; it's been confirmed by David I on the forums. He's trying to downplay it, of course. I don't think EMB realizes what a disaster this will be for them.
Lazarus IDE is pretty usable. Compilation is slower than Delphi, but works fine and IDE learning curve is very small, when coming from Delphi IDE. Try CodeTyphon - see http://www.pilotlogic.com/sitejoom/index.php/codetyphon - for installation. It is very easy to install, has a lot of third-party components, and can create most cross-compilers directly from an easy interface. It is amazing to compile the compiler and the IDE 100% from the sources. I'm adding FPC support to our http://mormot.net Client-Server / SOA framework, since we are facing the XE3 license change issue directly, and FPC/Lazarus is now a good move.
The problem is that in order to install packages you have to recompile the whole IDE, which is kind of an issue if you want to put it in Program Files, since all files in there are write protected by default. So until it gets hacked to not need a recompilation in this case, it probably isn't very likely to be suitable for putting into program files.
The best thumbnail for the release announcement :) remember the turbo button and the fast pascal compiler compare now with current java,.net, rails world where everything is slow and slower and bloated compared with the native speed 
What do you mean no exe? If you could run it, then there was an exe... As for installers, InnoSetup is what you're looking for in Windows (and that's true fro Delphi programs as well).
Co-couldn't they do it the same way as with Delphi, dynamic packages?
I guess, but apparently it is "very hard to do"(TM).
It really shakes my confidence when a compiler doesn't know how to exist properly on Windows. It works, i just had to create a reparse point in `C:\Lazerous`.
Thanks. I tried forums but nobody was helpful. I got the impression that I must have been asking the wrong question. What I was looking for was whatever Lazarus was building for an exe or equivelant, but the answers I got back were akin to "just run it in Lazarus", which was of little help. I tried hand-copying files between computers, but that did not do it. Definitely a case of my own ignorance here, I just share the story of my experience.
Usually the project exe file is created in the project file with no exe extension for example project1 will create project1 file if you open the terminal you can see that with ls -la (the x in the rights zone is executable) ls -lah project1 -rwxrwxr-x 1 mariuz mariuz 18M Aug 30 21:47 project1 you can check if is executable with the file utility: file project1 project1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.4.0, not stripped Ahh and the first project create for you in the ide by default is created in the /tmp zone ls -lah /tmp/project1 -rwxrwxr-x 1 mariuz mariuz 18M Aug 30 21:47 /tmp/project1 
It's available as eBook and printed.
I'm looking forward to trying this.
First go to [the main page](http://synopse.info/fossil/wiki?name=SQLite3+Framework) - it will state that it allows to add basic ORM or Client-Server features to simple applications for hobbists, or let experienced users develop scaling and strong service-based projects for their customers. You have a client-server ORM over in-memory storage, SQLite3, ODBC/OleDB/Oracle DB. And you have client-server services defined by interfaces - think of light WCF for Delphi, using JSON and REST. Browse the [download page](http://synopse.info/fossil/wiki?name=Downloads). Then get the source, read the ReadMe.txt file, and consult the main [SAD pdf documentation file](http://synopse.info/files/pdf/Synopse%20mORMot%20Framework%20SAD%201.17.pdf) - no need to read all 800 pages, just the introduction and first diagrams. All libraries are decoupled (trying to follow SOLID principle), but are used alltogether within a mORMot application. You can use e.g. only kernel-mode http.sys server, or the pdf generation, or the reporting, or the SQlite3 engine, or the SynDB database access. But if you mix all those in a mORMot application, you'll get everything needed to create up to the most demanding Domain-Driven-Design architecture. There is e.g. the "*SynFile main demo*" which is a working example of client-server ORM works. The "SAD" pdf has some guide detailing how this demo work. You will find out with this demo how Client-Server, ORM, SQLite3, UI and report generation, pdf export units are linked together. We need to improve the web site - graphic designer and marketer help is definitively needed... Some OpenSource project have a nice frontpage on the web, but no documentation and unstable code. With have a huge documentation with huge amount of code - but web site is not where we spent the most of our time. Help is needed! Thanks for the comment!
Have you tried profiling the code to see where the time is spent? Is it spent on Windows API calls or your own initialisation/shutdown code?
Have you considered Lazarus?
I have done a couple of windows service apps and it is not my experience that they are particularly slow to start or stop. There is probably some kind of bottleneck. I can recommend sampling profiler as well, although it is not always useful.
Some additional notes from other users on the web that have made the jump. In this from D2007 to XE, but since D2007 is almost identical to D2006, [the comments here should be useful.](http://stackoverflow.com/questions/5694931/how-hard-is-it-to-migrate-a-project-from-delphi-7-to-delphi-xe) [Here is an additional white-paper on Delphi and Unicode that also looks good.](http://edn.embarcadero.com/article/38980) [Another blog here with someones notes of interest](http://compaspascal.blogspot.com/2009/05/upgrading-major-project-to-delphi-2009.html) 
[IBObjects](www.ibobjects.com/) has a CreateDatabase method on its Connection component. It's not a free library, though.
Wow cool. I've always liked his blog, video series, and his books. Good for him. I think this bodes well for the Delphi environment at large.
I'm happy for that, but also worried, because seems the Delphi product manager doesn't have enough power for not releasing half complete features of new Delphi version.
I am maintaining a financial application on Delphi 7 and it has 6 million lines of code. Migrating to newer Delphi versions is a nice thing but I have to find replacements and upgrades for the components used in it. A daunting task. Would it be cost-effective to migrate or just keep working on it?
It is a commercial product but I'd also recommend RemObjects Oxygene to achieve the same.
See http://blog.synopse.info/post/2012/09/10/Don-t-be-confused-by-our-little-mORMot-%21 about a more high-level presentation, which may help you. From your comment, it is clear that our documentation was not clear enough. You can use the interface-based services with you own DB back-end, of course. Or use or optimized OleDB/ODBC/Oracle/SQLite3 classes. Delphi is not s...t. You can do wonder with it: mORMot is stable, faster and uses less resources than others, from this independant blog article. Of course, we do not have the marketing power of Micro$oft! Any help is welcome. 
I have worked with Delphi for 15 years. I have experience with PHP, Javascript, C#, fortran, IDL and couple of other niche languages and I can say for certain that the only reason, the absolute only reason you should be considering Delphi, is if you have a legacy application you need to support and that therefore you don't really have a choice in the matter. For everything else there are much better solutions out there. Yeah, I am bitter about it. Delphi has soo much potential, but even Embarcadero isn't realizing it.
http://edn.embarcadero.com/article/42770
http://blog.marcocantu.com/blog/delphi_xe3_update1.html
Interesting.. but I don't get why the need for extra toolbars in each unit tab. The uses cleaner would be helpful though!
Corresponding thread has been deleted from official Embarcadero forum. Not a big surprise. ;) Reddit does not have such "censure"... 
As usual, Simon prevented to post any thing in EMB* forums. Because that I posted it here and on google plus ;-)
You can disable any feature you dont like in cnPack
Great stuff!
At least I'll try to have a tip every day! Got any suggestions? List em out here!
Don't understand the use... Lazarus is a great editor nowadays... Why this?
Well that looks cool. I wonder if XE3 has similar functionality for Android.
It's on the [roadmap](http://edn.embarcadero.com/article/42544) estimated for mid 2013.
Congratulations to Dmitry. It would be a shame if true but it sounds like this will only make it into the most expensive version of delphi.
Marco says it will be part of Enterprise, which isn't the most expensive version of Delphi, but it will cut off access for some people that used it as a third party db framework for one of the cheaper version of Delphi, so of course it sucks a bit for them.
First they tried to force Pro users to not use 3rd party database drivers in order to force them onto Enterprise; when that failed they've now bought up the most popular 3rd party database driver and are going to force people to use Enterprise to get it. This company is really a piece of work.
I have a similar concern with this as I have with the Embarcadero blog aggregation page. There are blogs in all kinds of languages, but I am probably only interested in anything written in english.
Planet pascal will agregate posts related with pascal code so it should be readable ;) , from what i see is mostly English 
I support the endeavour but how do you intend for it to differentiate from delphifeeds.com? I do also like the fact that most of the feeds seem to be directed at the "delphi" category for each of the blogs. 
This is great for beginners!
[i used the simple solution](http://stackoverflow.com/questions/2519145/win32-htmlhelp-doesnt-work-from-a-network-share-whats-the-alternative): if the help file is on a network share then copy it to the `%temp%` folder. 
Yes, it's a workaround, but does not work in some cases.
Does anyone know what the status is with generics in Free Pascal? There seem to be two independent solutions. [From the wiki](http://wiki.freepascal.org/Templates): &gt; templates are replaced by a native-language implementation of so-called “generics.” Native implementation of generics in FPC 2.4.0 is neither complete nor practically usable yet. Until that is so, templates can be used. There is a long [discussion page](http://wiki.freepascal.org/Generics_proposals) about generics, but it is hard to figure out what the actual status is. 
Yeah. It's a pain. It's for personal use so a grand for the pro version isn't really an option. Thanks for the response
Would you care to try this? http://sourceforge.net/p/xxm/code/277/tree/trunk/Delphi/demo2/03%20Data%20ADO/xxmData.pas ADO may not be available in XE3 Starter, but using the plain old COM TLB wrapper should work, as long as you don't need data-aware components. (That said, I've seen a number of times people prefer to use plain-COM ADO to fill a TClientDataSet)
Did anybody watch the webcast?
It's not a component, it should work by just using the unit(s). Anyway, what I was trying to point at is the technique used there: use Connection and Recordset objects directly to perform a query, optionally putting the data in something else like a TClientDataSet.
You could try the old OnGuard product from TurboPower http://www.drbob42.com/review/onguard.htm which is now open-source http://sourceforge.net/projects/tponguard/ ...
Open source and Linux users eliminated.
I assume you QC'd the assembler error? (The missing opcode.)
No. Every attempt I ever made to use the official QC was a failure. Feel free to help and report the issue.
I am not really well versed when it comes to assembler stuff. I could make a report but I would not be able to answer any questions that might follow. I do have a reasonable succesrate with QC though. Bugs do get fixed eventually in most cases. By eventually I mean it can take a couple of releases or more, but still better than nothing right? ;)
I am a bit rusty on Delphi - but it should be a case of adding a Button &amp; TSaveDialog on the form, then setting up button onclick to something like if SaveDialog1.Execute(Handle) then begin if not CopyFile(pchar(sourceFile), pchar(SaveDialog1.FileName), false) then begin ShowMessage('Unable to backup file'); end; end; You might want to look for a [zip util](http://www.torry.net/quicksearchd.php?String=zip&amp;Title=Yes) 
Are you wanting to try this while you have (a) connection(s) open to the db? In that case I would import the ADO multidimensional type library (ADOX) to generate a blank Access DB, and copy data from recordsets from original to backup. (On a slightly related note: Access? really? That's so nineties, these days I would go for http://sqlite.org/ perhaps using https://github.com/stijnsanders/TSQLite )
This is Delphi, no forward-thinking allowed! :)
Nope. The way to fix the "raise e" is to change it to just "raise" with no argument. Trust me.
It's certainly unexpected that raise e does what it did though. I guess they could have added a check to make this equivalent to simple raise.
Classic case of 'read the fine manual' here. Although the Delphi documentation is often not the best, in this case it is fairly straightforward. http://docwiki.embarcadero.com/RADStudio/XE3/en/Exceptions
The manual says that Exception objects are automatically destroyed after they have been handled and the manual also explains in detail how to reraise the same exception. It shouldn't really come as a surprise that this will be the result, in my opinion.
Formally, maybe. Intuitively, it's "when you re-raise the exception it's not destroyed". And "raise e" is clearly a re-raise (what else?).
Thats actually helpful, thanks!
After 10 years using delphi I honestly didn't know that. 
I have thought of that. But I was distracted by everything else in my application. And the error msg wasn't helpful at all. See "e" was in my and the debuggers view still assigned (I could read it's values ) even in the "outer" try-except. After finding it to be the destroyed exception object it's obvious. 
Delphi is about a lot of things. Intuition is not one of them!
It only took me 12 years to figure it out! 
At the release seminar for XE3 Steven Ball said that as far as he knew, Rad Studio Mobile would be included if we bought Rad Studio XE3, in other words a free upgrade. It wouldn't surprise me if they've decided in the mean time that they would earn more money by making Rad Studio + Mobile an entirely new version of the product. Thanks Embarcadero, but no thanks...
I think you would have an easier time finding a book that teaches general oop principles for a popular language and then think about how you could apply those principles to Delphi.
Software assurance. It is essentially a subscription.
I cannot speak of Delphi since Embarcadero took over, but I've maintained and extended applications developed in Delphi 7 for over a decade now and that version is rock solid. It might help if you mention specifically why you took an interest in Delphi. Are you weeding out languages for a new product or is it purely on a hobby basis? Maybe you are looking to educate yourself for a potential job? 
Sadly, Delphi is pretty much dead. Learn it if you're interested but don't expect it to be a route to riches, there isn't much work there writing Delphi. There are still companies working with legacy systems that have all been built on Delphi who recruit every now and then, but very few are starting out writing new systems with it.
You are missing the bespoke market here... There are a huge amount of Delphi-based applications out there (I would not call legacy...) and I, personally, have applications that I built in D6 still going strong and providing royalties. Delphi as a creator of standalone or even socket PC applications is till relevant, easy to use and quick to deploy. As for web apps, I will grant you your argument. 
&gt; "FireMonkey is buggy/incomplete" Hearing that a lot. Personally, I'm not commiting to another framework. VCL has a history, a lot of components for it, FireMonkey has nothing and if we're starting anew, using native platform UI like Oxygene did is metric tons more logical. &gt; "Delphi is buggy" Mostly nope. Latest versions are pretty stable. &gt; "Delphi performs worse than other languages" Not really. It might, in some cases, be slower than C++. But if you know the language and don't do stupid things, it ends up in a difference that doesn't matter. It is I believe on par or faster than other compiled or almost-compiled (.net) languages. And compared to interpreted languages it's lighting speed. &gt; I wonder if it is as fast as the old one (written by Anders Hejlsberg) when it comes to compilation speed? It is, at least it's not noticeably slower. And the old one wasn't written by Anders Hejlsberg, AH was a cool guy but he left long ago and I'm not sure he even contributed code personally. &gt; "Delphi is too expensive since Embarcadero" It was always too expensive... &gt; "Delphi is dead" Not dead as long as I code in it. Anyway there's FreePascal and Oxygene so pretty of escape routes if the ship sinks.
I work for the biggest independent retailer in the UK with well over 1200 stores (and growing quickly) with over a billion pounds turnover per year, and we develop exclusively using Delphi. 
Delphi appears to me to be a dinosaur now in terms of usability. After working with C# for a while, going back to Delphi just seems archaic. Sure, it's added generics etc. It's tree control beats what you get with C# .NET 4.0 which is still based on WIN32 tree controls. FireMonkey seems to be new and missing features that VCL has. Given Kylix, what will happen with FireMonkey? The IDE is buggy but Delphi VCL seems to be pretty robust. The documentation/help seems to be broken and has been that way for ages. If you want a bug fixed, you have to buy the next update. That's just way too expensive.
Just to give a signal from the real world: the last Delphi meeting in Brussels I went to had the room packed. (was the one for Delphi XE3 if I remember correctly) Delphi is going strong as far as I can see. And even with Embarcadero you can have a basic version starting $200. But indeed Delphi 7 is a rock solid version and I use the most still, though I've updated a big project to Delphi XE2 to have it compile for 64-bit, without much problems (tip: leave some parts in AnsiString). FireMonkey may be a bit of a bet, but if it turns out to be a good decent way to get applications out there on all the new platforms (mac OS X, Android, iOS, ubuntu) from one and the same project, it may get interesting. As a language I've always liked it much more than C/C++. C/C++ is so much a 'shoot in the foot' language, brings you dangerously close to the underlying assembler. Pascal always had a little more mathematical background, and Delphi does a great job at bringing object orientedness to the language. And the recent versions have all the new tricks like generics and advanced enumerators (foreach!). And if you keep to good pratices and common sense you get exactly the same performance as anything else native. Anyway, I find the compiler and language so powerfull I wanted to build websites with it, so I created http://xxm.sf.net/ so I can do what PHP does with the Delphi compiler instead of a script parser. 
In my opinion... I use Delphi because I have to. My company has an existing application with a shitton of code using old legacy Delphi technology that is impossible to migrate to any other language. If it was possible I would do it in a heartbeat. Anything else is better. You can start up with VS and C# for free. Get a modern language with a ton of features and gizmos and gadgets that there is absolutely no hope of ever getting in Delphi. FireMonkey will be the framework for iOS development, so if you want to develop for mobile platforms, that will be the main framework. For Windows development, I am not so sure it is up to spec. Third party vendors are taking a wait and see stance as well. Delphi is buggy. Yeah! Buggy as hell. I am using Delphi XE3 daily and Error Insight chokes on the most simple of applications. Red squigly lines all over the place. After a few hours of coding the context menu stops working. Refactoring will not work properly. The critical 'Find declaration' function just gives up when the code becomes too complex. I see a flurry of IDE access violations in the message box from time to time and it does crash occationally, but not often. Eventually you will have to restart the IDE though because it just gets too choked up. Then there is the documentation. It is getting better.. But.. There are still so many undocumented sections of the framework (VCL/RTL). The IDE is still native Win32, the same as ever. There are some .Net parts here and there which causes a lot of weird dependencies during installation. The Visual Studio version that you heard about is only for the oxygene language that Embarcadero bought from a third party vendor. It is an object pascal language for .Net that isn't compatible with Delphi. It lives inside a Visual Studio shell. The product is called Delphi Prism. Object pascal does not run slow. It compiles very fast and runs just as fast as C++ code in my experience. The 64 bit linker is slow, but it isn't too bad. I don't think compiler/linker speed and executable speed are issues that need to be considered. Delphi is too expensive. Waaay waay waaaaaay too expensive, considering what you get for your money. A buggy IDE for an outdated language with an accompanying framework that is really showing its age. And the latest rumors are telling that Embarcadero is starting to adjust their price points in order to encourage all users to switch to a yearly subscription model (called Software Assurance). You will still be able to buy Delphi as a software package, but if you intent on using it for a project that you are going to maintain for years going forward, and you want to keep reasonably up to date with new versions of Delphi, then it looks like the price points will be such that even if you hold back several years on acquiring new versions, you would not save money compared to the yearly subscription service. If you have any kind of choice. Stay away!
Starter Edition is horrible. No source code, not even interface definitions. No code completion and lots of other missing IDE feature. The IDE is basically crippled. Most database connection components are missing and a lot of other VCL components are not there either. Compare this to VS Express. Pretty much fully featured. No critical components missing. Modern IDE. Modern language. Modern frameworks. For free...
You are lucky if bugs get fixed at all, haha.
A few people mentioned Oxygene, the language that power Delphi Prism. Depending on what you want to do with Delphi, and why you are looking at it, I would suggest you take a look at [Oxygene](http://www.remobjects.com/oxygene/) too. Oxygene is an object pascal compiler that naively targets platforms like Android, Java, Windows 8, WP8, .NET, iOS, OS X, etc. It has many great language features too. I created an [Oxygene Language Overview](http://www.remobjects.com/tv/oxygene-20-oxygene-overview) video a few months back that covers some of the details, although the [iOS support](http://www.remobjects.com/tv/oxygene-24-storyboards) has come a long way since then.
I compared Delphi Prism with Visual Studio Express a few months back and was pretty discouraged. A lot of project templates were missing in Delphi Prism. I couldn't make an Asp.Net MVC project with Delphi Prism.
I agree. I haven't seen Starter Edition for myself, but I heard this also. To be fair, it's a difficult decision to make what to put in the low-end/free version of your product in regards to how much people it will draw into buying the full/high-end product. Microsoft can afford to give that much away, perhaps because more VS(-Express) users will cause more use of Windows. Also, I forgot to mention that FreePascal/Lazarus is getting better with each release. And even LLVM can compile Pascal, though I haven't checked that for myself yet. All good for the language I guess.
I agree that MVC is a great technology. I think WPF is another major improvement technology for desktop development. Great productivity and incredible performance and features. Of course there are a lot of other cool features in Oxygene too. I love the tuples and parallel language features. Async futures are very useful. But it is the additional platforms that makes Oxygene really cool: Android, iOS, Mac, WP8, WinRT, etc.
Have you tried: http://codegearguru.com/ ?
How have I never seen those before? Those look exactly like what I am looking for. I'll check them out. Thanks!
I am glad that I could help. Good luck with your Delphi training! :)
I am curious. Would you consider it feasable to create a Visual Studio Shell for Delphi itself? Using the delphi compiler but using Visual Studio's features for intellisense/code completion/error insight?
feasable for whom? The people that write delphi could do this with ease if they wanted to. Visual Studio Shell is an IDE but it doesn't deal with intellisense itself (That's up to the language, all you do is give Visual Studio a list of things to show and it does), nor highlighting, that's all up to the project/language services.
&gt;I have a question. I recently took an interest in Delphi What caused you to take an interest in Delphi? What attracted to you it? &gt;"FireMonkey is incomplete". I also remember Kylix and C++BuilderX, &gt;and I wonder if FireMonkey is both stable and complete enough to &gt;survive or whether it could be another cross-platform failure? Embarcadero can't pull the plug on it because it's their Plan A and they don't have a Plan B. They're hinging their entire cross-platform deskop and mobile strategy on it. That said, even though there's no sign they would (or could) discontinue it, it certainly is not feature-complete compared to the VCL nor stable at this time. It's also very young/immature and has seen breaking changes from v1 to v2 with no sign that will stop anytime soon. So the smart money would be on both: A) Embarcadero sticking with FireMonkey B) Users not adopting FireMonkey It's not a particularly attractive possible future for either developers or Embarcadero. &gt; I'm especially worried when I read posts complaining of FM's &gt;incomplete feature set or inconsistent/buggy behaviours. I also &gt; wonder if it can fully replace VCL? Not yet, not by a longshot. That's the goal, however. &gt; "Delphi is buggy". This is about the IDE rather than the language. &gt;Just a few Delphi versions seems to have pleased forums contributors, &gt;especially versions 6/7 and XE1. I think I read somewhere that the &gt;IDE transitioned to Eclipse or maybe Visual Studio at some point. Was &gt;this the cause for the perceived poor quality of Delphi? If it had transitioned to Eclipse or VS users would be a lot happier. It was rewritten when they were pushing "Delphi for .Net" and it requires .Net to function even though the .Net version of Delphi no longer exists. It has long-standing issues with Code Insight and other features. Some devs off the record have said that the code behind the Code Insight feature needs a complete rewrite to fix the problems but management won't ok the time, so the problems go unfixed version after version. &gt; "Object Pascal runs slow". I read that the compiler was rewritten &gt;for 64-bit. I wonder if it is as fast as the old one (written by Anders &gt;Hejlsberg) when it comes to compilation speed? According to testimony on Quality Central (I have no benchmarks), it runs significantly slower and has memory issues. It also lost some of the optimizations found in the 32bit version. There's a new compiler based on LLVM coming. That means a host of new bugs. :-) &gt;I also saw some benchmarks showing resulting code was slower than &gt;similar C++ code. But is this confirmed in real life projects? I can't address real life projects, but I have seen results like that with benchmarks when I was researching languages. Maybe we saw the same benchmarks. :-) In reality, though, any compiled language (and most interpreted ones) should be "fast enough" on modern hardware. &gt; And of course "Delphi is too expensive since Embarcadero" It's too expensive since the market changed and languages became commodities or open source. Embarcadero's main issues involve unfair pricing for foreign markets and placing essential features in higher-priced SKUs. &gt;and &gt;"Delphi is dead"… but this latter one has been running since '95 in &gt;forums, so I see it as more of a joke. If you see it as a joke, you haven't looked around lately. Delphi is indeed dead, just like COBOL, PowerBuilder, Clipper, etc. The latest leaked numbers suggest no more than 125K-150K active Embarcadero customers, with only about 20K patronizing third party component vendors. I've seen programming *libraries* with more users than that. Jobs are also non-existent, such as one full-time Delphi position listed within forty miles of New York City, and none within 40 miles of Baltimore, DC, or Denver. There's only one listing nationwide for Intraweb, the web solution for Delphi. &gt;What is your experience? Are FireMonkey's immaturity, IDE's bugs and &gt;Compiler's performance smear/anecdotal PR or real/mainstream issues &gt;in Delphi? I completed surveys of the field for two startup companies looking to choose their software stacks. The answer to the question depends on what exactly you're interested in using Delphi *for* - hobby use, internal software, commercial software, further job skills, etc. For all but the hobby side, the "death" of Delphi is a huge factor. From capabilities - I found FireMonkey to have been shipped in a non-usable state in XE2 and still far from fully functional in XE3. Qt, its competitor, has over 14 years of maturity and is in a far more stable and usable state. It also has bindings for many languages, several times the number of developers on the project, dual licensing (commercial/open source), etc. To this day, genuinely useful examples of software developed with FireMonkey appears to total: 1, from what I can find. There's no way I'd advise a business to adopt FireMonkey in its current state, nor do I see anything it offers that Qt can't do, while Qt targets more platforms. The compiler performance I don't see as a major issue; "Developer time is more expensive than computer time". You can solve that with a faster processor or SSD. The IDE does have many issues that appear to go unresolved from release to release. Some bugs, while not common, are complete, total showstoppers for those who encounter them. For instance, the memory problem with the 64-bit compiler makes one bug reporter have to compile a large project from the command line. Debugging is also another problem with 64-bit. Embarcadero itself is a major issue. Officially one only gets 1.5 years of support, while in practice the update releases are for much less a period of time and one if compelled to purchase a new release just for the bug fixes. With the quality of the last few releases, this can often result in a slew of new bugs and people having to use both the old and new versions at the same time depending on which showstopper bugs they need to avoid for each project. They've tried several times to change the EULA in unfavorable ways that make them appear to be frankly, desperate for cash: trying to prohibit users from using a version purchased in country A in country B, trying to mandate that users could not access non-local databases - even with their own code - with the Professional version, etc. In the latter case they lied about the leaked EULA change not having been final. They also obfuscated the fact that XE3 isn't Windows 8 compatible by claiming it was "ready for Windows 8", which meant a skin could be applied to make a program *look* like the Metro UI. In reality, it can't use the WinRT library and can't be sold in the Microsoft Store. They purchased the most popular 3rd party database driver Pro users were using and plan on raising the price soon, which eliminates a cheaper solution for users than their C/S pack or Enterprise SKU. They were also in financial troubles before being taken private by a venture capital firm and have outsourced some Delphi development to Romania and Spain and had several rounds of layoffs. In short, this would not be the company I would want a business user buying products from, regardless of what the product was or its relative merit. Price-wise, it's also significantly more expensive than other, similar alternatives: Visual Studio C++, Visual Studio .Net, LiveCode, RealBASIC, Oxygene, etc. There are also free, open source alternatives like Java/Eclipse, Mono, Python/IronPython(.Net)/Jython(Java), Qt, etc. At $1K for the professional version and another $500 or so for their client/server pack, it's far more expensive than most other alternatives and doesn't offer anything unique or compelling compared to the competition unlike when it was released in 1995. In summary, the Delphi of today appears to have many drawbacks, structural and functional, compared to other programming languages/IDEs/frameworks (and that you're stuck using all three together is another annoyance). There are reasons the enterprise shuns it today, and not because "it's a secret weapon no one wants to talk about" like a few diehards will claim. :-) I struggled in vain to conceive of a compelling case for Delphi in 2013 and failed to find one. In an interview, Embarcadero's own CEO, when asked what Delphi could do that C# couldn't, replied that C# was a ".Net IDE" and hence "not our competition". When the interviewer changed the question to VS C++, he replied that that was "not their focus". His criticisms of managed languages prompted the interviewer to ask on their blog if he were "still living in the 1990s". One of Emb's evangelists also couldn't answer a straight question in an interview about what Delphi brings to the table over and above the competition, giving a rambling answer about producing Windows software. It seems that even Embarcadero can't make a compelling case for their own software (their own sales literature makes *zero* mention of any competitor at all, something they share only with Microsoft, but Embarcadero is far from being a monopoly). I reached the sad conclusion (I used Delphi successfully in a startup I was involved with from '95 to '03) that if the people who produced the software couldn't make a compelling use case, there was no way I could either. Although it was my not-so-secret weapon for eight years, if I were doing it all again a decade later, I'm sad to say Delphi wouldn't be my choice of development platform. The untrustworthiness of the company, the lack of quality, and the fact that language development has progressed mightily in a decade and Delphi has either welded some features on or let them pass it by, lead to a platform I would not find pleasant to work on and would be a major financial risk to do so. That it is a dying platform just reaffirms this. If you have a compelling personal vs. professional interest in the Pascal language, you'd probably be much better served with FreePascal.
&gt;Just to give a signal from the real world: the last Delphi meeting in &gt;Brussels I went to had the room packed. (was the one for Delphi XE3 &gt;if I remember correctly) Delphi is going strong as far as I can see. Just to give a signal from the real real world ;-) : packing a room is not impressive. A room? 2013's PyCon just wrapped up and they were sold out six weeks before the conference - they reached the occupancy limit of 2500. JavaWorld packs in 10,000-15000 users. A room is not strong. A room is a joke. The webmaster of the SciPy webpage (SciPy is a science-oriented library for Python) said that for the last two years the website has gotten 100,000 unique IP hits per year. That's for one special-purpose library, not the language. PyCon's sponsors included Microsoft, Google, HP, Facebook, Twitter, Amazon, Ebay, Disney, Lucasfilm, RedHat, Rackspace, DropBox, Oracle,Netflix and Reddit itself. There hasn't even been a conference in the United States since 2011 and no plans to have one in the immediate future either. No company of any significance trumpets its use of Delphi. Jobs for Delphi, at least in the United States, are almost non-existent. There hasn't been a commercially published book on Delphi in America since 2005. Sadly, Delphi users have really had to redefine what "strong" means lately. :-( &gt;FireMonkey may be a bit of a bet, but if it turns out to be a good &gt;decent way to get applications out there on all the new platforms &gt;(mac OS X, Android, iOS, ubuntu) There's no current plans for FireMonkey to support Linux. FreePascal does, though. &gt;And the recent versions have all the new tricks like generics and &gt;advanced enumerators (foreach!). All tricks that everyone else has had for at least four to five years previously. :-( That's part of the "going strong" problem... when everyone else is leading and Delphi is just picking up their ideas five or more years later, that's not going strong. When's the last time there's been something original and new in Delphi? Language development has passed it by and without Barry Kelly around to champion the new technologies, Delphi might not even get those 5 year old features grafted on anymore. &gt;Anyway, I find the compiler and language so powerfull I wanted to &gt;build websites with it, so I created http://xxm.sf.net/ so I can do &gt;what PHP does with the Delphi compiler instead of a script parser. I don't know what you see in the language compared to modern languages for web development, but that is a very impressive library you put together. Nice work! 
Nice list, and it's good to see I'm not the only one who's seen the language features available "in the real world" nowadays and feel that Delphi compares poorly with them. I'd add programming by contract, arbitrary precision arithmetic, functional programming features and optional dynamic typing a la C#'s "dynamic" keyword... but then I've fallen in love with some of the dynamic programming languages and how much faster they are to develop in. Oh, and let's not forget the wish for a 3rd party library ecosystem as rich as .Net's, Perl's, Python's 28,000 open source libraries, etc. I hear operator overloading for classes will finally be coming in XE4. Oh yes - duck typing would be great too. :-) Automatic parameter/tuple unpacking would be nice.... 
&gt;You are missing the bespoke market here... There are a huge amount &gt;of Delphi-based applications out there (I would not call legacy...) I'd strongly disagree. Even Marco Cantu's annual list of commercial software using Delphi contains programs that began development around 1998 or 99. There are essentially zero examples of people choosing to develop new software in Delphi today. &gt;and I, personally, have applications that I built in D6 still going strong &gt;and providing royalties. Case in point. You use Delphi today because... you used Delphi then. No one can point to examples of businesses starting to develop software today and still choosing Delphi over modern competition. If you developed it in D6.. it's legacy. &gt;Delphi as a creator of standalone or even socket PC applications is till &gt;relevant, To who? There's an entire generation of kids now entering college who have never seen a line of Pascal in their entire lives (the post-Turbo Pascal generation). They've grown up with their development tools being open source and free. There hasn't been an commercially published book on Delphi in America since 2005. There are no more conferences in America. How is Delphi still relevant? Who cares about Delphi? Does Steve Ballmer go to bed at night worrying about Embarcadero? Larry Ellison? Who, outside of the handful of Delphi users or former users/current fans who are left, care what Embarcadero does or what's going on in Delphi? What cutting-edge feature has appeared i Delphi first and then been adopted by other languages any time during the last ten years? It might be relevant to you or me, but on a larger scale, it's simply not relevant. Try dealing with an HR employee today. One frequently hears "Delphi - what's that?" That's not relevant. &gt;easy to use and quick to deploy. Which was great circa 1995-2003. But between 2003-2013 everybody else, including C# .Net, can say that. And the "scripting languages" have been demonstrated to be far easier to use and much quicker to develop in (published papers show at least 50% savings on non-trivial problems vs. statically typed languages). The question remains: what are the strengths of Delphi today vs. today's competition? That's a question Embarcadero simply won't address. They also don't seem to bother trying to compete with anything other than their own previous version. I used Delphi quite successfully at a start-up between '95 and '03. It was my not-so-secret weapon and combined with Crystal Reports and first BDE then CodeBase it was my "Access Killer". If I were doing it again in 2013 though, I've come to the sad conclusion it would be impossible to make the case for Delphi. It lost the lead a long time ago and simply began trying to add enough new/borrowed features to justify an upgrade. Development tools have also become commodities in the meantime and a user could sit down with a new PC, formatted hard drive, broadband internet connection and a Linux install disk and in less than an hour have a more potent development PC (everything from compilers, IDEs, debuggers and UI builders to enterprise-class databases, bug trackers, profilers, and report writers) than anything I ever had commercially. The days of needing to pay four digits for a development tool are simply gone. And that leaves the huge problem of what Delphi has to justify that four-digit price tag, along with the aggravating EULA, NDAs, lack of bug fixes and "black box" roapmap and management-controlled product development that go along with it vs. today's open platforms. 
Haskell isn't mainstream. Lisp isn't mainstream. Delphi is functionally dead.
And there's some big companies that use COBOL too. When I was working at one of the biggest retailers in America in 2004-05 all of their in-house development was done using Visual Basic (already discontinued)! That does not mean that Visual Basic is alive and going strong. That means that large companies, like large ships, take a long time to change direction. 
&gt;It has many great language features too. And to elaborate/testify, by this he means cool, modern features not found in Delphi, like design by contract: http://en.wikipedia.org/wiki/Programming_by_contract 
I sometimes get the feeling that a lot of Delphi developers live inside a cocoon, completely oblivious to what technnologies are available in other languages and development environments. They are stuck in their old ways and are unwilling to learn anything new, and Embarcadero is not ashamed to take advantage of it. 
The infographic is hardly exhaustive, missing as it does any mention of Modula-2, Modula-3, Oberon, or Eiffel in the list of languages influenced by Pascal, and there is no mention of Free Pascal which supports a number of dialects of Pascal. 
We use Delphi by choice, and not because of legacy requirements. Is it so inconceivable that there are developers that actually like Delphi? 
I was a little tight for space and didn't include them. I believe they were in an early edition. I may update and find a way to include those. Maybe "extensive" would be a better word than "exhaustive".
Good point. I'll see about updating it. This was actually from a while ago. Just happened to find an icon for Wirth that looked a lot like him.
Having been tasked with evaluating development languages for two new startups, yes, it is somewhat inconceivable to me because I found it impossible to make the case for Delphi. In fact, Embarcadero's own CEO punted when asked first what Delphi could do that C# couldn't and then VS C++ during an interview with The Register. Their own sales literature makes *zero* reference to any competitor. They can't make the case themselves. I'd seriously, honestly love to hear a compelling case for choosing Delphi today. I've practically pleaded for it from Embarcadero themselves and got nothing. If I've missed something major it's not too late for me to correct my mistake. I'll be flabbergasted if I did though, since I was a Delphi fanboy who chose it for a startup myself in the '90s and I still couldn't identify any compelling reason to choose it today (before getting into the price issues). 
Interesting and worth the read, although I disagree with one of the conclusions.
A good list: LINQ, Type Inference, a better generic collection library would all help massively.
If I were you... FreePascal/Lazarus. If I were someone else... python and Qt, or C# and Mono/.Net.
Use FPC/Lazarus, or even wxForms - see http://twinforms.com/products/wxformsdelphi You can try Oxygene which will help using object pascal code... to some extend, of course. You can try to use Java, or even Mono... Of course QT/WXForms are good libraries - QT is huge, wxforms is native, but less complete. But if I were you, I would switch the paradigm, and use SmartMobileStudio - http://smartmobilestudio.com/ - or EWB - http://www.elevatesoft.com/blog?action=view&amp;id=elevate_web_builder - to write HTML5 apps. It will work on Windows, Mac, Linux, and Mobiles... Then use it stand-alone, or with an Open source Delphi server like our little http://mormot.net - which works perfectly with the Delphi XE3 starter edition, with full support of databases... 
Did you ask about your issues on stackoverflow.com?
http://delphibyexample.wordpress.com/
You should really check out the Lazarus and FPC. If you haven't used any "exotic" components you should be able to recompile your project after few days of work not whole days, just your spare time). Or you can wait for the XE4, some people are saying that this release might be really good.
I'm tooling around with mormot for sqlite in xe3 at the moment. I think I'll be looking into FPC over the next few days. HTML5 is something I hadn't even considered - and may take a look too - but something I can rework my existing code on now is pretty much my priority. (My application is for windows but it's for use with photoshop - which has a majority mac userbase so getting it out there is my first priority)
Looks neat, but I don't know how much people will appreciate having to pay $10 for your source code to an example though. It looks like it scrapes anything that's a link and you can either do that with an HTML parser or a regular expression to search the document. I think it's a neat example but I just wouldn't pay $10 for it.
I think if call yourself a programmer and you can't build a simple web scraper in an hour in any language, without asking for help, let alone paying for it, it is probably about that time where you should consider a career change.
@Glaaki - Not everyone calls themselves an advance programmer. There are beginners out here you know. Maybe they are just wanting to start their careers. Not a nice statement to make
Yeah. Love this program
Another vote here. Took about half an hour to get to grips with it an produce a nice installer.
You should also check out this as well. An nice GUI which I use in preference to the wizard or monkeying with the script by hand: [inno script studio](https://www.kymoto.org/products/inno-script-studio/)
Thanks!
&gt;Unfortunately there is no exact component or source code that can be &gt;used to extract what you need from every page. You must hand code &gt;each and every extraction and parsing – needed. That's sadly because of Delphi's minimal ecosystem. Other languages do indeed have libraries dedicated to scraping such as Scrapy http://scrapy.org/ 
Couldn't this be said about any programming language? Embarcadero's forum is helpful along with any other 3rd party software you might be using. 
&gt; Couldn't this be said about any programming language? Couldn't StackOverflow be a "help desk" for any programming language? Delphi is nothing special when it comes to that website.
It might be because most new delphi developers don't know English. 
There are a couple of decently active forums on Embarcaderos own site, but in general you are much better off asking a question on stackoverflow. I have had questions lying dormant for weeks on Embarcadero forums and after I gave up on them suddenly someone answers. On Stackoverflow I see most questions answered within hours.
Um, I'm sure you have made some very nice points. But those points lose their meanings when you blur out the actual damn points! Honestly, if you can't show the code for whatever reasons to make your examples, use other pieces of code. I honestly can't tell if these are legitimate problems or not.
The important parts aren't blured. Honestly I feel it is quite easy to see the problems even though the names are blured. Just look at the color coding and the context of the code. And to sum it up, most of the examples are code with red squiglies, meaning code should not compile, but it does and it works just fine. It really isn't any more complicated than that. EDIT: This is important actually! It is useless to try to create simple test cases that I can show you with code that I don't have to blur out. It would be very tedious to be able to replicate these problems with simple examples. Error insight only stops working after you smack it around a certain number of times. As I noted simply closing Delphi and opening it again and reloading the project is usually enough to reset error insight so that the problems no longer appear. I would litterally have to sit for days creating a mock project if I were to be able to replicate these bugs. 
I always just turn off Error Insight. Delphi's compiler is fast enough that I can just hit Control-F9 and a few seconds later see if it compiles.
I believe this is a common approach to the issue.
I've skimmed through your complaints and they seem legit, I've encountered most of this. But last time you asked (was that you? was that me who responded that Delphi is stable?), I thought you were asking about deal-breakers like IDE crashing or code not compiling. Object/Error insights were always more like "we sometimes can help you" type of features, if it acts up, no big deal, just ignore it.
&gt; Object/Error insights were always more like "we sometimes can help you" type of features, if it acts up, no big deal, just ignore it. I mean, I don't know if this is how most people feel about it. Maybe it's true. Personally.. In my personal opinion... It is this kind of apologetic attitude that I believe is really screwing the whole community over. It gives Embarcadero an excuse for not providing a quality product. I feel Emb. should focus solely on providing a base IDE tool with solid stable features and a modern language. Let third parties handle frameworks.
Error Insight is not able to compile the official RTL/VCL units shipped with the system. Just unusable! :)
Delphi noob here. I get the idea from reading this thread that I should turn off error insight and/or code insight. (Are they the same thing?) What else should a Delphi noob know (besides object pascal)? IOW, what do you wish someone had told *you* when you started working w/ Delphi?
Yay! Embarcadero really doesn't know how to make/keep friends, does it?
You can try to convert the png to a 32 bit bitmap file and load that into the bitbtn. Probably wont work though because all the build-in image buttons in Delphi are shit.
Have you taken at look at the stock icons? PNG+bmp, 8x8 all the way up 64x64 I believe, in full 32bit color.
I'm not sure I understand what you are saying, but I'm not having trouble finding icons. It is displaying them that is the trouble. The .glyph property of TBitBtn only accepts .bmp, and apparently no alpha-blended transparency. So, I'm trying to find a way to get alpha-blended 32 bit transparency onto a TBitBtn - perhaps that means writing my own code to do it, though I haven't figured out how to do that.
We are talking about the bitbtn control, not icons. I think you are missing the point.
I would recommend asking on Stackoverflow instead. That is a much better venue for these kinds of questions.
For additional information (since all this was obvious to me since the XE3 source code release), you can look at: http://blog.synopse.info/post/2011/12/08/Avoiding-Garbage-Collector%3A-Delphi-and-Apple-on-the-same-side http://blog.synopse.info/post/2012/10/06/Delphi-XE3-is-preparing-reference-counting-for-class-instances http://blog.synopse.info/post/2012/06/18/Circular-reference-and-zeroing-weak-pointers 
Delphi slowly creeps forward, yet again offering features everybody else had five-plus years ago. Yay?
Congratulations! I'm glad to hear that things worked out. SQLite is a wonderful little database. Since it's public domain I've never known why it wasn't included in Delphi; it's built into python. If you need a free enterprise-class SQL database, PostgreSQL is the way to go. I'm not an expert in prettying-up Lazarus, so I don't think I can help you with that. I did have a similar experience when I ended up changing my home PC from Windows to Linux and suddenly felt like my hands were tied since the only programming language I had major experience in was Windows only. I needed to parse a podcast list from my Windows podcast manager to get urls to put into my new Linux podcast manager and hesitantly installed Lazarus/FPC and tried it out. I spent more time trying to figure out the file format I was parsing than I did Lazarus. On top of that, it had some nice features my old version of Delphi lacked. :-) In the end I got the program working and and it parsed the file amazingly fast and I was suitably impressed. It was a big relief and I was no longer hesitant about switching OSes. Nowadays I'm in love with Python, but it's still good to know that FreePascal is there for any compiled language needs I may have. I wish Embarcadero would consider Lazarus an ally rather than a competitor and open source the language component of Delphi. They could keep VCL and the IDE proprietary for professional use and free up resources to work on them since they won't have to worry about the Pascal language/compiler anymore. Lazarus would become the entry level/student/hobbyist tool and maybe attract more people to the platform. Sadly, I don't think that's going to happen. But unless it does, I don't see how they can justify their product as being $1000 better... plus $500 to access non-local databases. 
&gt; I'd wanted to use a database originally but couldn't afford the full XE3 Studio price tag - Couldn't you just download any of the 3rd party SQLite headers?
Agreed. It's kinda "dead" for new developers. I'm from Indonesia, my 1st programming language is Pascal and I love Delphi when I was taught about it years ago. Now not even my uni teaches Pascal. all starts with VB and so on. The company I work for still using Delphi and we are in grave danger looking for new Delphi developers. But actually in Indonesia Delphi still going strong (esp. for business apps that uses grids and such). top 3 local business apps in indonesia developed under Delphi. Some start to move to PHP and Java with Android &amp; iOS support, but the main app still built under Delphi. I, myself will probably sticks with Delphi for windows app programming since that's what I'm confidence for. That's what my most optimum speed in programming windows based app, so I will stick on Delphi, until it sinks. I too learn java as in Android programming, PHP and javascript for web programming and I use them too, but in windows based app programming still my choice is Delphi. Learnt about VB and .net using C# a while ago, but still more familiar with Pascal language. just my 2 cents
I used 3rd party component TSilang. but our market need not multilanguage :|
what behavior? o.O
I think it is the fact, that you can click anywhere in the code editing area, and the text-cursor will be where you click. This makes it possible to write whereever you want, without putting spaces first. Personally I like this, and I miss it in Visual Studio. 
He would prefer that if you are at the last character of a line, and you press **`Right`**, you are brought to the first character of the next line. ala Notepad, Wordpad, Word, the memo input box in any browser, any other text editor ever invented. Personally, i've never felt it was *"wrong"*. If i want to go to the next line i press **`Down`**.
Yes. Agreed with @inputcrash. I'd like it like current cursor setting
I guess this is kind of interesting, but making a blog called Delphi Hater isn't exactly constructive.
First off, even a very experienced Delphi programmer would struggle to get a working prototype in two weeks. Maybe if you limit your scraping to a single website and even then you'd end up with a lot of unsolved issues. Secondly, most of the ticket websites got several techniques to fight off scrapers like the one you want to write. There's JavaScript safeguards, they modify ticket prices every time you visit, they'll even report incorrect prices if your application isn't undetectable. Last off, any prices you do manage to extract and show your visitors will be outdated minutes after you get them, for reasons listed in previous paragraph. There's a reason you have to pay airlines for going through their API.
Well I agree with you, I am supposed to have a detailed explanation of what is required of the app but in this case I'm not so I'm taking my case to a certain level and that is to integrate as much as possible. I'm not alone on this assignment there are two other students, problems is those two are failing everything and I know this will sound very idiotic from my side but they only know how to operate google chrome and that's it; to answer your question on how are they going through university then well the answer is simple they've been failing 2-nd year of uni for 5 years in a row. So I'm pretty much alone in this. So generated information or perhaps some free api or something I know I'm pushing for more than I can chew but I like stuff when they're legit ( yeah I'm also being funny when stating this and there is room for flexibility and seriousness. ).
I feel you, I truly do! University American College Skopje.
As others have said, your time table is an issue. Limit your scope. Keep it simple. Populate a free db with some data. Setup a connection and display the data. Aceppt and store an order. Make orders searchable. Print a confirmation if your ambitious. A prototype doesn't need to actually do much or be robust, usually. Just implement some common use cases with some typical data. 
This is a step in the right direction. Looks like it needs a little bit of polish to make it more accessible.
Code snippets could be useful if they weren't such an undocumented mess of black arts.
Agreed. They're not exactly intuitive to template at the moment.
The TCP latency with their demo site is poor (195ms from here). I am following WebFMX since beta 2 and "Wow" was my first word when I saw the demos. Currently, the trial seems very very fast over Internet.
Yes, the removal of copy-on-write strings might well be the last removal Embarcaderro ever does. Good languages need *more* of language-assisted common stuff, not less.
Copy-on-write strings are out of favor. The new school of "functional programming" has arrived, and modifying things in-memory (creating a "side-effect") is a no-no, as it hampers parallel programming. It also makes memory management easier. I'm disappointed that when Embarcadero finally begins realizing how much of Delphi is out-of-date or bloated with bolted-on features and starts to modernize things and clean up the language to make it competitive, the community isn't embracing that. 
How exactly removing a good, stable, liked by everyone feature is "making the language competitive"? Why should the community embrace taking something from them and making tasks more difficult? This is just counter-intuitive.
Delphi is not, and will never be a functional language at all. There is no benefit of using immutable strings in a OOP language. In fact, COW allows the best of immutable and mutable string paradigm. Multi thread programming, nor better speed in Delphi was never the goal, in all the recent Delphi release. But you can achieve high multi-thread speed with current Delphi COW paradigm. See http://blog.synopse.info/post/2011/05/20/How-to-write-fast-multi-thread-Delphi-applications and alternative memory managers, like ScaleMM2. Delphi is not out of date. Do you think C is out of date? Do you think C++ is out of date? Do you really want your Delphi application use as much memory as Java or Ruby? On a server side, in which the more client you server the more money you get, Delphi is very competitive. I suspect you are making wrong assumption about the competition.
&gt;Delphi is not, and will never be a functional language at all. Embarcadero owns it. It'll be whatever they make it to be. In 2003 the COBOL standard was updated to include objected-oriented extensions, so never say never. :-) &gt;There is no benefit of using immutable strings in a OOP language. You keep repeating this blanket statement: "no benefits". However, there are many benefits.There's a long list of them here: http://stackoverflow.com/questions/2365272/why-net-string-is-immutable Another article give this summary: &gt; They work better for concurrency (you don't need to lock something that can't &gt;change!) &gt; They reduce errors: mutable objects are vulnerable to being changed when you &gt;don't expect it which can introduce all kinds of strange bugs ("action at a &gt;distance") &gt; They can be safely shared (i.e. multiple references to the same object) which &gt;can reduce memory consumption and improve cache utilisation. &gt; Sharing also makes copying a very cheap O(1) operation when it would be &gt;O(n) if you have to take a defensive copy of a mutable object. This is a big deal &gt;because copying is an incredibly common operation (e.g. whenever you want to &gt;pass parameters around....) You can disagree that the benefits outweigh the costs, but to keep saying there's no benefit suggests that Embarcadero's developers just flipped a coin or lost a bet or something. They had legitimate reasons. &gt;Multi thread programming, nor better speed in Delphi was never the goal, in all &gt;the recent Delphi release. &gt;As was mentioned, anonymous methods are a step toward some kind of &gt;LINQ-like functionality. However, my ultimate goal is to use this underlying &gt;mechanism for increased parallelism both in terms of a library-based solution in &gt;the near-future and ultimately as intrinsic parallel-computing functionality of the &gt;language itself. &gt;Building the foundation is the first step in building a house. &gt;Allen Bauer. CodeGear/Embarcadero Chief Scientist. Four years ago, but still, improving parallel computing is something they have in mind. David I. mentioned this in one of his blog posts as well. &gt;But you can achieve high multi-thread speed with &gt;current Delphi COW paradigm. I don't suggest you can't. &gt;Delphi is not out of date. I definitely disagree with that. Modern languages are offering type inference, garbage collection, design by contract, iterators (which Barry Kelly did add to some extent), generators, function decorators, some flexibility for dynamic typing (e.g. C#'s "dynamic" keyword to turn off static checking for a variable) and many other features. Delphi's come a long way in the last few years thanks to the work Barry Kelly did (e.g. generics, dictionaries) but even he left. What did he write on his blog? &gt;Delphi is very procedural. It grew out of Pascal, a language designed in an era &gt;when memory was very expensive. So most of its core runtime is based around &gt;mutation and destructive updates. &gt; &gt;But the longer I've been coding, the greater and greater benefit I see to more &gt;functional approaches - which pretty much require garbage collection - and &gt;persistent data structures like you see in Clojure. &gt; &gt;I've also lost some of the object orientation religion I first picked up when I was in &gt;my teenage bedroom, figuring out how virtual method calls worked in my copy of &gt;Turbo Pascal 6. I remember the epiphanies of those days. But these days, I see &gt;the bureaucracy and busywork involved in creating class hierarchies, how it can &gt;fool you into thinking you're doing productive work when you're filling out various &gt;idioms and "patterns". Some problems - like GUI widgets - work really really well &gt;with OO. But others work far better with the functional approach, where the set of &gt;data structures is closed but the set of methods is open. Shoehorning these into &gt;OO results in ugly architectures with extra indirections. &gt; &gt;Suffice it to say, if I was creating a language I was truly in love with, it would look &gt;quite different to Delphi. So I generally agree with Mr. Kelly, although he thought Delphi couldn't be changed enough. In addition, begins and ends and one-based strings and a lot of Delphi syntax simply isn't used in other languages today and the current generation just thinks "old" when they look at it. In that sense, too, it's out of date. Going further, in some ways all corporate-controlled languages are out of date. Other than Microsoft thanks to its monopoly power, single-vendor languages have almost all died off or faded away. Most developers today (non-Delphi) are used to languages that either have official standards or the community itself controls their development. Honestly, you wouldn't have seen these kind of changes in most other languages without vigorous debate. &gt;Do you think C is out of date? For what? Low-level code? No. The Linux kernel? No. Most modern desktop apps, data crunching, etc? To a large degree. Many languages today will allow one to code those much faster (and safer) than you could in C. &gt;Do you think C++ is out of date? I think it's broken. :-( The "special cases" have multiplied to such an extent that even someone who was on the standardization committee has said they don't feel they've mastered the language. I believe languages like D fix a lot of C++'s flaws. It has a large ecosystem but its language is far more flawed than Delphi. I wouldn't recommend C++ generally; I think anything C++ is good for there are languages like D, C# on the desktop, Java - that could do as good a job with less effort. 
&gt; Embarcadero owns it. It'll be whatever they make it to be. No, he's right. At this point Delphi will never be a functional language. You can drop pascal and redo it from the scratch, but that would not be Delphi. &gt; However, there are many benefits.There's a long list of them here: And if you look at that list, all the benefits are possible with copy-on-write, and someone even states that in the comments. And one of the benefits is even: &gt; I once produced a memroy saving of about half a GB by comparing immutable objects and replacing references to duplicates so that they all pointed to the same instance So he did what COW does by default. Wow. &gt; but to keep saying there's no benefit suggests that Embarcadero's developers just flipped a coin or lost a bet or something Yes, that is basically what happened. This is an easy way out: "You can't say they're *completely* wrong. They may be wrong but they had their reasons." Why can't I? They're wrong. They're wrong once by following the fad and thinking Delphi must have immutable string since every cool kid does it, they're wrong again by threatening to replace normal strings with those. If they really wanted immutable strings what they should have done is created a way to declare and implement your own string classes. This would also have been a "Finally!" moment because I'm sick and tired of all the cross-version and cross-compiler (Hi FPC!) string differences which make it impossible to write something which consistently works. Instead they make another breaking change. Well thanks for that, I'm looking forward to writing even more IFDEFs and working with strings in even more constipated manner than before. Instantiating TStringBuilder every time I need to build a string. More boilerplate code, yay! We're not even in C++ land where you can just write TStringBuilder str and it'll be instantiated on the stack, no, I'll have to go full retard with try..finally and Freeing it at the end. 
&gt;How exactly removing a good, stable, liked by everyone feature is "making the &gt;language competitive"? Ok, to understand this you must embrace the awful truth: no one uses Delphi anymore. There. I said it. In order to be competitive, the language at minimum needs to modernize. The world at large has moved to immutable strings and they're generally happy with it. Immutable strings make it easier for EMB to port the compiler and easier to perform optimizations. It's something they needed to do. They didn't just flip a coin here. &gt;Why should the community embrace taking something from them and making &gt;tasks more difficult? This is just counter-intuitive. It isn't making tasks more difficult; it's reactionary kickback at any change whatsover. If Java, .NET and Python can deal with immutable strings, so can Delphi. EMB is finally attempting to clean up the language and compiler and we shouldn't be throwing hissy fits and suggesting they're doing things for no reason. They wouldn't break compatibility without their being worthwhile advantages to doing so. Did you notice that there was no press release this year about increased sales the way there were the last two years? Rumors say that XE3 sales were down 20%, no doubt to the quality of XE2. Then they rush XE4 out and essentially charge people for an update. They've already outsourced some development. They've got somewhere between 15-21 developers or so, and that's for the language, TWO frameworks, the IDE, standard library. They're down to one Interbase developer. If this is something they had to do to help get a working product on a reasonable schedule, then that's a perfectly valid reason too. 
&gt;No, he's right. At this point Delphi will never be a functional language. Pure functional? Of course not. That doesn't mean elements of the functional paradigm can't be incorporated. Heck, you don't need to program with the object-oriented paradigm in Pascal, thanks to first-class functions and procedures. In C# and Java, everything has to be in a class. Actually, Pascal wasn't originally an OOP language either. &gt;And if you look at that list, all the benefits are possible with copy-on-write Thread safety? Compiler optimizations? Wikipedia, Stack Overflow, two of the big three (Java, C#) and one of the big second-tier (Python) all suggest otherwise. In my mind, it's an extraordinary claim that all these languages and all these information entities are all mistaken and have no reason for doing what they're doing. In http://www.drdobbs.com/from-mechanism-to-method-distinctly-qual/184403779 the author goes through the way COW works and explains in detail how it only benefits in a few corner cases and can cause a lot of sub-optimal situations, describing the benefits of COW as "a myth". That's yet another, well-documented, technical source explaining in detail the benefits of immutable strings. I simply can't accept the assurances, without explanation, that there's no point to it. &gt;Yes, that is basically what happened. This is an easy way out: "You can't say &gt;they're completely wrong. They may be wrong but they had their reasons." Why &gt;can't I? They're wrong. They're not wrong; Delphi users just don't want anything to change or admit no one pays any attention to Delphi anymore. &gt;They're wrong once by following the fad See, there's the thinking. Java, C++, C#, dynamic languages are all just "fads" and if people would just realize that, Delphi would be #1. I can't buy into that. &gt; and thinking Delphi must have immutable string since every cool kid does it, "Every cool kid" are languages that easily consist of more than half of all LOCs being written today, probably a lot more. When people are more successful than you are, it's a good idea to pay attention to what they're doing and ask if you should be doing the same. &gt;they're wrong again by threatening to replace normal strings with those. Threatening? If they really wanted immutable strings what they should have done is created a way to declare and implement your own string classes. This would also have been a "Finally!" moment because I'm sick and tired of all the cross-version and cross-compiler (Hi FPC!) string differences which make it impossible to write something which consistently works. Instead they make another breaking change. Well thanks for that, I'm looking forward to writing even more IFDEFs and working with strings in even more constipated manner than before. Instantiating TStringBuilder every time I need to build a string. More boilerplate code, yay! We're not even in C++ land where you can just write TStringBuilder str and it'll be instantiated on the stack, no, I'll have to go full retard with try..finally and Freeing it at the end.
I think it is important to keep in mind that although delphi is not and will never be a functional language, there are elements of functional languages that are quite sound and make sence even in non-funtional languages. We shouldn't be afraid of adopting those elements into Delphi. Now, all this doesn't matter since Delphi is still a dying IDE and this new mobile platform isn't the right way to go about saving it.
&gt;Now, all this doesn't matter since Delphi is still a dying IDE and this new mobile &gt;platform isn't the right way to go about saving it. What do you believe would be the right way? And bonus points for being realistic about the fact that there aren't many Delphi developers anymore. Also, would you agree that the PC market is beginning to contract while mobile is still on a huge rise and that mobile software development doesn't have any firmly entrenched leaders the way Microsoft and Oracle dominate enterprise development right now? From that perspective, EMB's actions don't seem unreasonable, although I honestly feel most people who really needed mobile already left for other products. 
My apathy is too great to offer any meaningful suggestions I'm afraid.
Wow, the argument that it will be cheaper to keep Delphi and upgrade than to totally re-code our application in something else keeps getting thinner and thinner. EDIT: Not to say that there aren't valid reasons for all their changes. It just puts a small company in a bind when they've got so much invested in older code. It ends up really being a whole new evaluation.
Resource constraints? We will get Error Insight fixes, when?
Please checkout my blog http://delphibyexample.wordpress.com/ and participate in the survey http://www.surveymonkey.com/s/5YPK97G
It would be a good idea as its clear that after 18 years the market simply isn't going to adopt Pascal en masse. However, they're a relatively small company that as Glaaki notes don't have the resources to develop a new language while actively maintaining/improving the existing one, expanding into mobile, etc. 
Simon, the "huge component market" hasn't existed for over ten years. :-( 
Note that those Delphi language changes is not imposed by the LLVM backend itself, but by the "NextGen" new compiler frontend. LLVM is perfectly able to generate efficient code of mutable strings, and AnsiString kind of types. Note that I'm confused by the fact that the LLVM "Next Gen" compiler is just dead slow, even in comparison to the Win64 compiler (which was already much slower than the Win32 compiler). We are loosing one of the great feature of the Delphi IDE, which was very fast compilation. And with no obvious performance improve at execution, AFAIK. Note that this PDF states that the strings are not yet immutable, but will certainly become immutable.
No Android support?
Check the mobile studio. when XE3 released they said that next year's mobile studio will have the ability to compile for android apps rather than ios apps only
Ah yes, checked the roadmap - Android support for XE3 expected mid 2013. I'll see if there's a trial version when they announce it.
http://docwiki.embarcadero.com/RADStudio/XE4/en/Procedures_and_Functions http://docwiki.embarcadero.com/RADStudio/XE4/en/Parameters_%28Delphi%29 http://docwiki.embarcadero.com/RADStudio/XE4/en/Calling_Procedures_and_Functions
I am assuming you are wanting to know about parameters being passed into the procedures or functions right? Here you go: http://wiki.freepascal.org/Parameters If you are having trouble understanding what exactly are you confused on? 
Where are they teaching Delphi 7?
South Africa. (in my school anyways, not sure about others) Also, I'm in Grade 11 (Standard 9). We first started in Grade 10 (Standard 8)
Thank you for your help, will certainly read this. I'm just confused about using parameters in Functions and/or Procedures as variables.
Thanks!
I can help but I need a little more understanding. Pretend we have have something like: Function AddTwoNumbers (num1 : integer; num2 : integer) : integer; var sum : integer; begin sum := numA + numB; num1 := 42; num2 := 69; result := sum; end; Now in your main applicationyou have something like this: var A : integer; B : integer; C : integer; begin a := 1; b := 2; c := AddTwoNumbers (a,b); end; At the end of this a and b are one because they are passed in as a value, which means the procedure has a local seperate copy of A and B called num1 and num2. Procedure IncrementBy (var variableToIncrement : integer; HowMuchToInc : integer); begin variableToIncrement := variableToIncrement + HowMuchToInc; HowMuchToInc := 69; end; Now in your main applicationyou have something like this: var A : integer; B : integer; begin a := 1; b := 2; IncrementBy (a,b); end; In this situation a would end up being 3 and b would end up as 2. The reason for this is that by using var in the procedure's parameter variableToIncrement uses the same memory location as the main routines variable a, or variableToIncrement is a pointer to a. and HowMuchToInc is a brand new variable pointing to a brand new memory location that has a copy of the data in variable b. When the procedure ends the garbage clean up will destroy variableToIncrement and free up its memory but for variableToIncrement it destroys the pointer but not the memory location because variable A still points to that memory. NOw just say you had to write two subroutines, one to swap two numbers, and another to increment a number by a value (like the sample above). The swap subroutine would probably be a procedure with two VAR parameters. The increment subroutine would be a function that has two non-var parameters and returns the result. Clear as mud or am I way off track of what you are trying to learn?!?
If you update your method to something like this var input: Integer; var sqrtInput: Extended; var truncSqrtInput: Extended; var rounded: extended; begin input:= StrToInt(Edit1.Text); sqrtInput:= sqrt(input); truncSqrtInput:= frac(sqrtInput); rounded:= roundto(truncSqrtInput,-2); if truncSqrtInput = 0 then showmessage('It is a prect square!') else showmessage('Nope!'); end; you can use the debugger to step through the code and see what the variables are set to - it will help show the issues with the algorithm something like this will work fracSqrtInput:= frac(sqrtInput); if fracSqrtInput = 0 then 
Honestly what that would seem to do is make the code needlessly verbose (a flaw of modern Delphi generally). I wouldn't suggest doing it everywhere all the time; only in situations where you actually need to debug.
 Function PerfectSquare(num : Integer): Boolean; Var square : Extended; Begin square := Sqrt(num); If Int(square) = square Then Result := True Else Result := False; End; 
&gt; If Int(square) = square Then Result := True Else Result := False; why not just: Result := Int(square) = square; 
reminds me of this 'integer-sqrt' I concocted once: https://github.com/stijnsanders/primes/blob/master/primeUtils.pas if it wasn't this late in the day I would see if I could tweak it to find the 'remainder by sqrt' to see if that is zero. (or use if isqrt(a)*isqrt(a)=a which might even perform better...)
So many inaccuracies, half truths and unsourced claims. Even if you agree that Delphi is heading in the wrong direction, I don't think this is the right approach towards improving the state of affairs.
There's no evidence presented to suggest this is anything more than a rumor. They've also reported sales down, and a time when sales were down wouldn't be the most logical time to try to find a buyer. No doubt the present owners will be looking to do either a sale or IPO at some point in the future, but there's no reason yet to believe that the time is right now. 
Why would the present owner be no doubt looking for sale?
Instead of lamentations how about providing some suggestions for solutions?
I've enjoyed the site, but nowadays the articles are just getting repetitive. There's a lot more interesting discussion/debate on the forum about ways to improve the language and if the language needs to be improved or changed. 
&gt; Posted by [Delphi Haters](http://www.blogger.com/profile/15833669175331711891) at Sunday, June 09, 2013 That certainly explains some of the *"rational"* points.
If you have rebuttals to the points, feel free to share them. 
Why would someone who hates Delphi so much dwell on it to the point of making a blog? Seems like a pissy rant on steroids to me. If you hate Delphi so much, just don't use it. Go away. C# is out there, after all. Use that, and quit your whining.
&gt;Why would someone who hates Delphi so much The whole point is that they DON'T hate Delphi; they hate what's been done to Delphi. That's like saying that someone who has a problem with a policy of their country hates their country. &gt; dwell on it to the point of making a blog? It's been a great resource to learn about things that Embarcadero doesn't talk about. Heck, I'd love to see anyone at EMBT address the unpopularity of Delphi, the lack of jobs, the vanished ecosystem, etc. &gt;Delphi so much, just don't use it. Go away. C# is out there, after all. Use that, &gt;and quit your whining. And that's how we create Delphi Island... a little mist-shrouded land off the main continent completely cut off from everything else. We don't want to create an insulated little environment where groupthink prevails and we only hear how great everything is all the time.
Besides, a Delphi hater probably wouldn't like C# either.
I do not think the forums are starting to become like a gay bar. Not do I agree that attracting women to use Delphi will solve Delphi's problems - or that women is even a problem that needs solving.
I'm not so sure about that. There's a lot of differences, including automatic memory management and less verbose syntax. On the other end, both have robust frameworks.
Some potential for statistical gaming here. What's the period in question? XE4 shipped not too long ago while there was no comparable release in the same time frame the previous year. That could lead to inflated numbers. It's like talking about how a show's ratings are up this week without noting that it ran against repeats this week vs. last. They used to release these press releases in February. Instead waiting until June after XE4 debuted seems suspicious. Without details (what exactly is the year-over-year growth of? Upgrades? SA? New purchasers?) They're saying "sales". Are they counting $49 XE4 upgrades as sales in the same way they'd count an XE3 $490 upgrade as a sale? 
&gt;I do not think the forums are starting to become like a gay bar. Agreed, and I posted a comment saying that was a poor choice of words. It's not the first time there's been some questionable language like that on the website. :-( &gt;Not do I agree that attracting women to use Delphi will solve Delphi's &gt;problems Agreed. &gt; - or that women is even a problem that needs solving. Absolutely disagree. There is a disparity in the number of men and women entering STEM (Science, Technology, Math) fields. Some programming communities are doing their best to change things. Delphi could certainly do its part. 
Presumably, the period is their fiscal year. I believe it follows the calendar year. Embarcadero has reported consistent increases in Delphi/Rad Studio sales. However, you are correct that they are only reporting on part of 2013. I can only speculate whether the trend will continue. Allen Bauer commented on this after the first press release. Increases included revenue and units sold (new sales, upgrades and SA) and revenue. I believe the numbers from the press releases represent increases in revenue from the previous year. I don't know how much of the latest increase is a direct result of interest in XE4 and iOS and how much is just a continuation of the growth they have seen in previous years. * http://www.embarcadero.com/press-releases/embarcaderos-delphi-reaps-three-consecutive-years-of-double-digit-growth-since-acquisition-from-borland * http://www.embarcadero.com/press-releases/embarcadero-technologies-grows-delphi-and-c-by-54-in-2011 * http://www.embarcadero.com/press-releases/demand-for-ios-support-drives-year-over-year-growth-in-sales-for-rad-studio-development-tools 
Article was re-published removing the bad content.
Not really. The blog is run professionally and diverse mix of people. There is QA persons, content writers, legal team, coders, experts for advice and peer-reviewed. All are unpaid and do it on their own time. Some infos cannot be reproduced, liked what source-code UDK references, DX11 sources. The blog gets lots of mail from disgruntled Delphi developers hinting for Emb. to change their ways. The blog is trying to improve more in terms of unique content and removing duplicate yeda yeda. The article about HTMLBuilder is eye-opening as Emb. uses Joomla for their site. if you try to reproduce the same kind of quality with HTMLBuilder, it is almost impossible. Does this blog hate Delphi? Image a kickass (not Jackass) Delphi were you can use DataSnap mano-e-mano Java and using Delphi means respect, not trolling. It's time for Delphi to grow-up!!!! 
Thank you!
i was trying SynPdf recently, in Delphi 5. The `SynCommon.pas` unit tries to take over implementation of `@Move` with an implementation from FastMem. i discovered that it's not a 100% compatible replacement; it introduced a crash where none existed before. The issue comes from a 3rd party library that *essentially* calls: CopyMemory(nil, nil, length); The stock Delphi 5 RTL `@Move` function does *not* crash because it first checks if `Source = Destination`, and bails out: procedure Move(const Source; var Dest; count: Integer); asm ... MOV ESI,EAX //eax is pointer to source MOV EDI,EDX //edx is pointer to destination ... CMP EDI,ESI //compare source to destination ... JE @@exit //if equal, exit ... end; The `SynCommon` (i.e. FastMem) version does not have the same sanity check, and crashes with an access violation. &gt; **Note**: Agreed, the source code should be fixed. But Embargadero bought the rights to the 3rd party library, and shut down the sourceforge site. But any function taking over RTL code should be 100% compatible. i only mention it here because you're listening! Other than that: nice work on SynPDF. Processing metafile records, and handling transforms is not an easy task.
Thanks for the feedback. I just committed a fix. See http://synopse.info/fossil/info/f41dd910fe Note that our *move()* version in X64 in fact checks if source=destination. procedure Move(const Source; var Dest; Count: NativeInt); asm // rcx=Source, rdx=Dest, r8=Count .noframe mov rax,r8 sub rcx,rdx // rcx=Source-Dest je @11 // if rcx=0 (Source=Dest): jump to @11 .. @11: ret // that is, exit 
I've just enhanced the library to produce smaller PDF file. Gain can be huge, even if the 1.5 format is specified, which allows compressing almost everything. See http://blog.synopse.info/post/2013/06/21/SynPDF-now-generates-%28much-smaller%29-PDF-file-size
Even Embarcadero's starter Delphi seems expensive to me - I can't see them rebuilding any serious market share without a free choice to encourage things like open source. The only option I was aware of is Lazarus - according to [FreePascal wiki](http://wiki.freepascal.org/IDE) there is [MSEide](https://sourceforge.net/projects/mseide-msegui/) but I have never tried it. What sort of problems do you have with Free Pascal/Lazarus? Another choice might be to learn C# and use [Visual Studio Express](http://www.microsoft.com/visualstudio/eng/downloads)
Lazarus ide is quite easy to install these days and quite stable after it hit 1.0.x http://lazarus.freepascal.org/ , i test it mainly on Debian Linux Indy seems to be supported on Lazarus http://forum.lazarus.freepascal.org/index.php?topic=20782.0 Also zeosdb components are ported to lazarus , and can be used with Firebird ... http://wiki.freepascal.org/ZeosDBO
It will be interesting to see if Oxygene do anything for hobbyists now that they're out of the agreement with EMB. A free/cheap edition would be great but I'm afraid that you might be forced to fight with Lazarus..
After that unexploded IED post on the front page, I read this as "Any inexpensive IEDs now days?" the first time, and wondered what subreddit I could possibly be subscribed to that warranted that question.
I believe the command-line Oxygene compiler is free for Linux, but on the other hand the newest version isn't working with the open source IDE MonoDevelop anymore. :-( You might want to investigate this though. There's the option of DWScript, which is an interpreted version of Delphi with a lot of improvements over Delphi such as automatic memory management, type inference, etc. There's also an experimental JIT compiler that in some benchmarks produces code that's faster than Delphi! :-) http://delphitools.info/dwscript/ But the big picture answer is that it's only the Pascal-alikes that are costing hobbyists (and in most cases even professionals) money these days. Essentially every other language has a host of IDEs, compilers, libraries and frameworks available for free, with better support, more users, books and magazines available, free online courses, etc. You might be a lot better off learning another language. Most people find the idea of learning a second language the hardest, because they're afraid it'll take as long as it took to learn their first one. It's not even close though. If you choose Python (renowned for its ease of learning and use) you'll need about a week to get up to speed, and the language is cleaner, simpler and more powerful than Delphi (and I say this as someone who's programmed in Pascal as their primary language back to the days of Turbo Pascal). Honestly though it's really only Pascal-alikes that 
 Pascal as a language will eventually become like Latin. Nobody will use it because it is very expensive and costly to use. The users themselves are drowning themselves in debt and mismanagement. Are there new Delphi jobs for senior developers? What about job security for senior Delphi developers? Why are there so many pay-walls for every 3rd party component? Why are there so many database components but few working ones? Try learning Java or PHP or C#. The future for them are very bright. There are many jobs for those languages. Good free IDEs are IntelliJ for Java, KomodoEdit for PHP, Mono C#for Windows. Delphi is a parody of Wheel of Fortune. Call it Wheel of Delphi Misfortunes. Spin the wheel, business problem - I need to buy a library. Spin the wheel again - another business problem - I need to buy another library set. and so on. The winners gets high debt load and life-long pyramid scheme sending lots of money to various vendors and never having enough for oneself. 
You are most welcome. 
Your problem is Windows. From a hobbyist perspective the OS is not the point usually. Windows is already strongly focused on Enterprise IT. If you want to stay on Windows ... take the free stuff from MS. .net is capable. Take open source stuff. I am doing hard to believe that installing Lazarus/FPC on Windows is a problem. I use it under Linux every now and then. Delphi is not for hobbyists anymore... I doubt it ever was. From head to toe commercial, expensive. If you want more convenience maybe in the open source world try Jetbrains for example. Free Komodo. A thought. Millions of other don't use Delphi and develop software too. Millions of other never heard of Oxygene. Others obviously help to make the IT world a better one.
These blog posts with a provocative title of yours seems more and more like aimless ranting by a grumpy old man with zero constructive criticism. It's not that you're not wrong, it's just that you're preaching for the choir. And if Embarcadero didn't listen before, then your style of writing sure isn't going to change anything. Besides I am sure that they're well aware of what is going on, but there isn't much they can do to fight the fading image of Delphi/Pascal - as you correctly point out. 
&gt;These blog posts with a provocative title of yours seems more and &gt;more like aimless ranting by a grumpy old man with zero constructive &gt;criticism. I wouldn't classify it that way, so much as it's often the same (valid) points over and over. But the official EMBT policy seems to be to ignore this issue (and sometimes deny it completely), so you can't blame someone if they find themselves repeating themselves louder and louder. Some "discontented" like myself have come up with a lot of good ideas to try to rekindle the ecosystem and shared them on the official forum to no response or interest whatsoever. Meanwhile the marketing department puts out press releases that use phrases like "the vast Delphi ecosystem". They misinterpreted (or intentionally distorted) a claim a few years ago of 2 million Delphi licenses sold over the life of the entire product (18 years) and put out a press release saying that there were two million Delphi users and that this made them the largest Windows development community in the world outside of Microsoft(!!!) - which would obviously be Oracle and Java, not Delphi. In fact, it got even worse when I was looking at some recent press releases as now in 2013 they're claiming *three* million users... I guess if your numbers had no grounding in reality in the first place, they can't get any less accurate by inflating them. So in the face of EMBT's marketing suggesting the user base has grown by 50% in the last two years I can forgive anyone for shouting from the rooftop in response. I put forth a detailed plan on how EMBT could cultivate a new generation of (self-published) Delphi authors - instead of just ranting about the lack of books, I had a solution that involved EMBT setting up an online course for aspiring new authors, making a technical editor available for free to those who complete the course to make sure the quality of self-published Delphi books is up to par with the commercially published books of old, an advertising plan, ways to attract new authors, etc. No response to the plan, and marketing decides it's easier just to add a million more users to their press releases. :-( &gt;It's not that you're not wrong, it's just that you're preaching for the &gt;choir. And if Embarcadero didn't listen before, then your style of &gt;writing sure isn't going to change anything. Maybe it warns potential new users away? &gt;Besides I am sure that they're well aware of what is going on I'm not. Some seem to be (like Marco Cantu), but after engaging with David Intersimone on another forum he seems to live in his own alternate reality and was in complete denial (at least publicly) about the state of Delphi in schools, adoption among young/new programmers, jobs available, etc. And we seldom or never hear from those in managerial positions that it's impossible to say with them. &gt; but there isn't much they can do to fight the fading image of &gt;Delphi/Pascal - as you correctly point out. It would be nice if they did +anything+ though, or if they do have some master plan that they could come down from the mountain and share it. Is moving into mobile the totality of the plan or is there more? I'd love to know. And as the chief scientist has made clear, any ideas/changes need to be cleared with management and shown to have a net positive ROI. I get the feeling there's a lot he'd like to do with the language but there's a bunch of nameless suits who just want a bunch of features to check off on a product comparison matrix and that's why things like IDE and help quality suffer, because they can't be used to sell more product. :-( 
Direct2D takes longer at bitmap creation, each bitmap in Direct2D is a resource, but faster at actual rendering, painting bitmaps. See Improving the performance of Direct2D apps article at MSDN. GDIPlus is faster at bitmap creation, but slower at rendering. 
I begged for datasnap performance and error insight fixes. But for the sake of my own health, I wont be holding my breath for any changes! 
87% of the readers of a Delphi blog use Delphi as their primary development tool? This new knowledge amazes me! :D One interesting thing to take away from this is that the percentage of people who are looking at android development is significantly higher than the percentage of people looking at iOS development for the immidiate future. With that in mind it seems unfortunate that Embarcadero selected the iOS developer platform to be the first to launch. I guess way back when the decision was made, it was not that clear cut which platform developers would prefer?
This was my thought. I recently wanted to switch some apps to the native client. That's when I realized that sqloledb had shipped with the OS since Windows 2000. The native clients only come with a redistributable. --------------- This isn't stackoverflow, but i'll add some code snippits i created to handle this. First is the defines of the different providers: const Provider_SqlServerOleDb = 'SQLOLEDB'; //Microsoft OLE DB Provider for SQL Server. Can connect to 7/2000. Can connect to newer, but recommended to use newer native client. Provider_SqlServerNative = 'SQLNCLI'; //SQL Native Client 9.0 OLE DB provider (sqlncli.dll). Release with 2005. Can connect to 7/2000/2005. Can connect to 2008, but recommended to use version 10 Provider_SqlServerNative10 = 'SQLNCLI10'; //SQL Server Native Client 10.0 OLE DB Provider (sqlncli10.dll). Released with 2008. Can connect to 2000/2005/2008/2008R2 Provider_SqlServerNative11 = 'SQLNCLI11'; //SQL Server Native Client 11.0 OLE DB Provider (sqlncli11.dll). Released with 2012. Can connect to 2005/2008/2008R2/2012 //Alias for the "default" provider Provider_SQLServer = Provider_SqlServerOleDb; //i.e. the Native clients do not ship with Windows. Must install native clients separately. Then you realize that the name of a **provider** is simply a COM `ProgID`. Knowing this we can test if providers are available: constructor TSQLServerAvailableProviders.Create; var clsid: TGUID; begin inherited Create; (* OLEDB provider names are simply COM ProgIDs e.g. HKEY_CLASSES_ROOT\SQLOLEDB @default = Microsoft OLE DB Provider for SQL Server \clsid\@default = {0C7FF16C-38E3-11d0-97AB-00C04FC2AD98} HKEY_CLASSES_ROOT\SQLNCLI10 @default = SQL Server Native Client 10.0 \clsid\@default = {8F4A6B68-4F36-4E3C-BE81-BC7CA4E9C45C} Except that Windows doesn't ship with SQLNCLIxx providers. Those have a separate redistributable. *) SqlOleDB := Succeeded(CLSIDFromProgID(Provider_SqlServerOleDb, {out}clsid)); //Microsoft OLE DB Provider for SQL Server. Can connect to 7/2000. Can connect to newer, but recommended to use newer native client. SqlNCli := Succeeded(CLSIDFromProgID(Provider_SqlServerNative, {out}clsid)); //SQL Native Client 9.0 OLE DB provider (sqlncli.dll). Release with 2005. Can connect to 7/2000/2005. Can connect to 2008, but recommended to use version 10 SqlNCli10 := Succeeded(CLSIDFromProgID(Provider_SqlServerNative10, {out}clsid)); //SQL Server Native Client 10.0 OLE DB Provider (sqlncli10.dll). Released with 2008. Can connect to 2000/2005/2008/2008R2 SqlNCli11 := Succeeded(CLSIDFromProgID(Provider_SqlServerNative11, {out}clsid)); //SQL Server Native Client 11.0 OLE DB Provider (sqlncli11.dll). Released with 2012. Can connect to 2005/2008/2008R2/2012 end; Finally, the available providers are cached, and a singleton helper class is created to help get the *best* available provider: type TSQLServerAvailableProviders = class(TObject) private function GetBestProvider: string; public SqlOleDB: Boolean; SqlNCli: Boolean; SqlNCli10: Boolean; SqlNCli11: Boolean; constructor Create; property BestProvider: string read GetBestProvider; end; var _AvailableSqlServerProviders: TSQLServerAvailableProviders; function GetAvailableProviders: TSQLServerAvailableProviders; var a: TSQLServerAvailableProviders; begin if (_AvailableSqlServerProviders = nil) then begin a := TSQLServerAvailableProviders.Create; if InterlockedCompareExchange({var}Pointer(_AvailableSqlServerProviders), a, nil) &lt;&gt; nil then a.Free; {$IFDEF Sqm} Sqm.SetBoolean('SqlServer_ProviderAvailable_SQLOLEDB', _AvailableSqlServerProviders.SqlOleDB); Sqm.SetBoolean('SqlServer_ProviderAvailable_SQLNCLI', _AvailableSqlServerProviders.SqlNCli); Sqm.SetBoolean('SqlServer_ProviderAvailable_SQLNCLI10', _AvailableSqlServerProviders.SqlNCli10); Sqm.SetBoolean('SqlServer_ProviderAvailable_SQLNCLI11', _AvailableSqlServerProviders.SqlNCli11); {$ENDIF} end; Result := _AvailableSqlServerProviders; end; Note: You can ignore the Software Quality Metrics (SQM). That's just part of the *Customer Experience Improvement Program*, to help us understand how many customers might already have the *native* clients installed. Then it's just a matter of constructing your Connection String using the *"best"* provider: class function TADOHelper.ConnectionStringSQLServer(const Server, UserID, Password: string): string; var provider: string; begin provider := GetAvailableProviders.BestProvider; Result := 'Provider='+provider+ ';Network Library=DBMSSOCN'+ //DBMSSOCN = TCP/IP ';Data Source='+Server+ IfThen(UserID&lt;&gt;'', ';User ID='+UserID, '')+ IfThen(Password&lt;&gt;'', ';Password='+Password, '')+ // ';AnsiNPW=No'+ //ANSI Null Padding Warnings ';Application Name='+ExtractFileName(ParamStr(0))+ ';Workstation ID='+Toolkit.GetComputerNameString; // ';Initial Catalog=[Default Database]'+ //name of default database, or database to use with Initial File Name // ';Initial File Name=C:\Program Files\Microsoft SQL Server\MSSQL\Data\OrderOnTime_Data.MDF' end; 
I bought a copy of the starter edition - the debugger is crippled, the comment was "hobby programmers don't need that feature". such crap. edit: thought I should mention the feature - mouse over a variable and get a tooltip with the current value, standard fair for even free IDEs, but not Delphi Starter Edition ($150)
Neat! (As is your other example, AnimateWindow.) Have you thought of adding a RSS feed of your articles to DelphiFeeds.com? You'll probably get a much wider audience there than here on Reddit. Adding a comment ability to your articles would be cool too.
Not much sense here... the Delphi compiler for iOS uses LLVM for its code generation, so will be as fast as ObjectiveC, and certainly faster than C# or Lua. BTW, C# is not available on iOS (unless you use MonoTouch, with a sub part of the Windows API, and very badly integrated to XCode for UI generation), and Lua is not compiled. 
Here's a test case: Load 7000 data into listbox need 75 seconds, too slow. (Add item method) Already try BeginUpdate and EndUpdate. 
Huh?, Pascal was originally designed as an aid to teach students how to code. It was taught alongside C when I went to Uni.
Should point out that [Android beta program application can be found here.](http://forms.embarcadero.com/RADAndroidInfoBetaRequest?cid=701G0000000WLhl)
Thanks, I will post it as new link
The future of Delphi? I think we'll continue to see a decline in active Delphi projects and in active Delphi developers as well. Personally I do not know a single professional Delphi developer that only knows Delphi, everyone got a second language (or more) - never put all your eggs in one basket. :) There are however many active Delphi based applications out there, as well as a lot legacy applications. Combine that with a declining number of Delphi programmers, there should be enough work for us in the near future. Embarcadero was too slow to adapt to .NET and it took them too many release cycles to polish their .NET framework. I believe the same thing is happening to their mobile platform framework, but only time will tell. As for what Embarcadero can do to get more people to use Delphi? I wish I knew; there are too many good alternatives to everything they offer. Maybe if they innovated something new rather than playing catch-up with existing frameworks?
I think the cost is a shame. From my point of view, money is no object for the best developer tools available. My sister who cuts hair spends $1000+ for a good pair of scissors, after all. If you do something all day every day for years, the cost of the tool becomes negligible if there is even the slightest improvement in productivity. Where the cost factors in, though, is bringing in new blood. If someone wants to "get into programming", program for hobby, program for school, or program from a country with low incomes, they are not going to drop $3K. For the customer like myself, with 10 developers or so, even $30K is not that big of a deal. If it makes each developer 5% more productive, I have more than paid for the tool. What is a HUGE deal, though, is that the same money that is not so important to me is driving other developers away, so that I may end up training 10 developers to use something that won't be around in 10 years.
Offering the same $0 as their competitors.
&gt;My sister who cuts hair spends $1000+ for a good pair of scissors, after all. But your sister wouldn't be foolish enough to pass up an equally good pair of scissors that cost $500, would she? I once worked at the HQ of a huge American retailer that at that time had a billion dollars in the bank and no debt. Regardless, only the legal department was allowed to have Post-It Notes. Everyone else had to make their own with scrap paper and scissors! (Not necessarily defending that particular decision, but the reality is that even billion-dollar firms don't spend more than they have to). &gt;If you do something all day every day for years, the cost of the tool becomes &gt;negligible That's an interesting "if". If the person/firm is just starting out, though, that cost is going to be significant (and new Delphi customers are not likely to come from established firms deciding to incur the time and cost to convert to a different, less popular, more expensive tool). One serial tech entrepreneur once said that it used to be that once a start-up got their first million in venture capital funding, they had to turn around and hand a third of it to Oracle and a third of it to Microsoft, but they don't need to do that anymore (and then went on to extoll the benefits of open source). Open source is far more likely to gain the startups, as this allows them to even the playing field right off the bat without squandering their seed money. &gt; If it makes each developer 5% more productive, I have more than paid for the tool. And there's another point. It's not 1995 anymore. I chose the tech for a start-up in 1995 through to 2003. During most of that time period, Delphi was indeed the best tool for the job; I even called it my "Access killer". But after being requested to help two start-ups choose their software stacks in 2012 I did a serious "deep dive" into the current state of the art of programming languages, databases and BI software for the first time in 10 years (and my current responsibilities hadn't seen me do direct programming for the last few). I was hoping Delphi would come out on top, but honestly I was blown away by just how far development tools had come, especially open source, which had gone from often being poor-quality, undocumented clones of existing commercial software to often being state of the art, market-leading, better-supported software than its commercial counterparts! I was also saddened to see just how little Delphi had gone forward in that time, particularly in regards to the language itself. Honestly, I reached one professional and one personal conclusion. The professional one was that I couldn't recommend Delphi to either start-up, and the personal one was that if I was doing what I did in 1995 all over again in 2013 I wouldn't choose Delphi for that either. :-( Delphi simply is not more productive than its competition today. Even ignoring the product, the ecosystem alone forces one to reach that conclusion. In 2013 in America and much of the Western Hemisphere there are no more commercial Delphi books published (last commercial title in the U.S. was in 2005!). There are no magazines. There are no free online courses. It's disappeared from almost all academia. This makes the "barrier to entry" very large compared to more popular languages (before we even consider no free version and the high cost). This means few know the language and training them is that much harder. Libraries are another factor - little commercial software supports Delphi today (unlike in the '90s when professional software like Crystal Reports shipped with Delphi components). Libraries are few compared to the hayday of Delphi and are dwarfed by what's available for Java, .Net, C++, Perl, Ruby, Python, etc. This is a HUGE consideration. With a good library ecosystem I can look at something that needs to be done and perform a cost evaluation: how long would it take me/a team to produce this and what would be the total cost? I can then compare this to the price for a commercial library and purchase the commercial product if the cost is less (which will often be the case if the language is popular such that the cost of development of the product can be spread out over a large number of expect buyers). One may also buy the library even if the cost is higher if time to market is critical. With Delphi in 2013, there often simply isn't a viable commercial product. That means a competitor can purchase an off-the-shelf library and move along while the Delphi user will have to do the development themselves. Jobs have vanished in North America (along with user groups and conferences). That makes it hard for any existing Delphi developer to maintain or improve their skills or to recruit new Delphi developers. As for the language itself... today, nothing beats the productivity of the dynamically typed languages e.g. Python, Ruby, etc. In scientific studies on non-trivial test problems those using dynamic languages finished in half the time (!) with no increase in errors. In fact, one big study actually created its own language in two flavors, statically and dynamically typed, and taught them to groups of Java developers (obviously more familiar with static typing) and took more time to train the static language users. But once again, the sample using the dynamic variant completed the assigned work significantly faster with no significant decrease in quality of results and actually spent _less_ time debugging their code! Delphi is filled with antiquated hold-overs from Pascal and its single-pass compiler system, including the separation of interface and implementation. Duplicating function headers does not make one more productive. Ditto for manual memory management, lack of operator overloading for classes, lack of generics for first-class functions, lack of first-class types, and many other deficiencies. In fact, I'm not really familiar with any statically typed language that's been created from 2000 onward (this century) that hasn't employed type inference to remove the task of defining all the variable types. Even Delphi-based DWScript and Oxygene use it. Then there's design by contract, slice notation, and many other features that statically typed languages have employed to increase productivity (forgetting dynamic typing for a moment). Even older languages have begun to add these things to their standards. Delphi... Delphi just keeps chugging along, remaining at least 4-5 years behind everyone else on.. well, everything, and often much, much farther behind. The biggest obstacle to Delphi's future is simply that it's an old, outdated language which got ignored for a long time except when Barry Kelly worked at EMBT and he quit and wrote a blog post stating that if I were to create a language he truly loved, it would be very different from Delphi. The state of the art is embracing functional programming, design by contract, type inference, features designed to aid massively parallel computation, etc. and Delphi is still fighting with its own users over getting Unicode right and facing open rebellion over immutable strings and memory management. It's simply going to be viewed as a step backwards for an enterprise to put a language in place that offers nothing they don't already have and lacks much they do. Even EMBT knows this - check their web page. Unlike almost every other product on the market, they have absolutely no marketing material comparing themselves to the competition. I tried during my time investigating languages to get EMBT people or TeamB to answer questions like what features Delphi had that no one else did (a routine question I asked during my research). At best, I'd get back answers that showed the respondent simply didn't know the real state of the art, and at worst I'd get no concrete reply to this type of question at all. Even during an interview with The Register, EMBT's CEO wouldn't answer the question of what Delphi offered that C# didn't (even claiming C# "wasn't a competitor"!) and wouldn't then compare with VS C++ either. :-( It really seems like they're just milking the cow for as long as they can. Ok, very long-winded reply but I've dreamed up a dozen things to help Delphi out and in the end as of today I'm just not sure anything will be effective. No tech product has ever fallen out of favor and then "bounced back". EMBT's resources are tiny compared to monopolist Microsoft and open source has vast amounts of contributors who don't have to answer to marketing or accountants and can enhance products and change strategies and respond to the market much, much faster than EMBT can. Open source has made development tools a commodity market and commercial development languages controlled by one firm are an anachronism that only MS is big enough to continue to pull off. That's simply a fact of history (that Borland saw coming, even if they couldn't successfully transition). Trying to change the tide of history may be like trying to empty the ocean with a teaspoon. 
&gt;I think Delphi is awesome / ahead from the technology point of view. Ok, I'll bite. This is a very, very different conclusion from my own analysis of programming languages I did in 2012 for some start-ups. By what criteria do you reach this conclusion? In fact, if you can tell me what (useful) feature(s) Delphi has that no other languages have (what makes it unique) you'll answer a question I couldn't get TeamB members or EMBT's marketing to answer. &gt;What it is missing from my point of view is lots of people using it, so I can feel &gt;safe that it has a future. The trajectory has been downward for quite some time. The product has also changed hands multiple times. You shouldn't feel safe about this, and for this reason alone I couldn't with a clear conscience recommend Delphi to start-ups I was advising 2012-13. &gt;What are your thoughts? What do you think Embarcadero could do better to get &gt;more people to use Delphi? In the past I've dreamed up a lot of things. One of my favorites was recognizing that commercial books were no longer being published. In order to ensure that self-published books continue to appear and are of the same high quality I wanted Embarcadero to create an online course for prospective new authors. Those who successfully completed it would gain access to a technical editor provided/hired by Embarcadero, free of charge, to insure their manuscripts were of high quality. Perhaps such publications could be published under a EMBT brand (Embookadero?) and actively promoted by EMBT. EMBT could also commission e-book authors on topics it feels its customers are interested in, etc. The idea is not without precedent. When Steven Crist took over the floundering Daily Racing Form he noted that there were few books being published on horse racing (one of the best publishers of racing and handicapping books had gone out of business some years prior and other commercial publishers had not had good relationships with their authors). He founded a "DRF Press label" and recruited some of the best writers of racing material still living (more than one of whom had sworn off writing after having been mistreated by a major publisher) to release new editions of their classic works. He also commissioned volumes like "Bet With the Best" and "Bet With the Best 2: Longshots" in which each chapter was written by an accomplished handicapper/author and had to contain original work new to print. Lots of actions like that helped get horse racing books back on the shelves again and thus made it easy for those who wanted to learn more about the sport to do so (and being on shelves, probably attracted some new fans that way as well). We need more user groups, real conferences, etc. Python simply has an amazing community. They've got pyvideo.org that acts as a central search engine cataloging video presentations about their language from all around the world. Presently there's some 1775 videos available! They also have the Python Package Index (PyPI) which indexes open source python libraries. Presently there's over 33,000! There's a command line tool and an API, which means users can search for and install, delete or update libraries from a command line and this feature can be built into Python IDEs. Delphi has Torry, which when you throw out the large numbers of files that are available only for something like Delphi 5 or earlier and there's little content there and certainly no easy access API. It's also a far cry from a central index of all Delphi open source libraries available no matter where they're hosted. Recently Embarcadero asked about something like this in their annual survey, but unfortunately it was in the form of a software store and seemed to be concentrating on how much users would pay for software and how much of a cut they would be ok with giving to EMBT. :-( These folks just can't think long game or show any interest in building user base/community. We need a central software repository, not a software store. Python has one, Perl has a huge one (124K files!), R has one, etc. Just some of the many, many ways we're behind. Of course a free edition would remove the barrier to interested parties trying out Delphi as well. But in the end lately I'm just not sure any of this will ultimately change the fate Kalroth predicted of becoming a niche legacy tool only used to maintain existing programs, like COBOL and Powerbuilder. Actually Powerbuilder still sees releases every 18 months by Sybase, can target the web and .NET now, etc. However, outside of a handful of legacy Powerbuilder users, no one knows this or cares and many people probably don't even remember what Powerbuilder is. Sadly, outside of Delphi users, it's the same thing. Even in 2004-5 when I was working at a billion-dollar company outside of the IT Director none of the IT employees even knew what Delphi *was*. I've seen this in HR interviews, too, more than once: "I see on your resume you list 'Delphi'. Is that a programming language or a reporting package or what is that exactly?" Delphi simply isn't *relevant* anymore. No one's lying awake at night worrying about what Delphi is going to do next (which makes all the NDAs and such so laughable). Delphi won't disappear completely (as COBOL hasn't) but I'm not sure any change will be sufficient to make it relevant again. Open source is developer driven (which hurts it with consumer-focused products). But the customers for development tools are... developers. That makes development tools the best fit of any software for open source. That has led to an explosion of open source in the development tools area and it dominates the field. Outside of MS' monopoly, languages controlled by a single proprietary entity are an almost nonexistent anachronism. Open source can move quicker and innovate more without being beholden to accounting or marketing. Developers can have direct influence over the direction of products and no one understands the needs of developers better than developers themselves. Enterprise can feel safe that these languages are in the hands of standards committees or have a formal language specification so they can be sure they won't disappear or hijacked in a poor direction. The future of development tools simply belongs to open source and if Microsoft can't change that, I don't see how Embarcadero can ultimately be successful doing so. http://www.h-online.com/open/features/Your-next-language-or-how-open-source-changed-programming-1858734.html On top of that, the current/future trend is developers using more languages, so the Delphi-fanboy-who-only-uses-Delphi-no-matter-what is doomed. Check this out and see how fast things have shifted just in three years: now only 2% of developers report spending more than 50% of their time in one language! http://www.drdobbs.com/jvm/the-quiet-revolution-in-programming/240152206?nomobile=1 I just don't see room for the stereotypical Delphi developer (which I admit to once being) or $1K jack-of-all-trades, master-of-none proprietary languages in the future. I'd been hanging out on the Embarcadero Delphi forum for several months now, my inner fanboy hoping could change my mind (thinking of trying a startup myself as I hit middle age before I get too old). Unfortunately no one has, and sadly no one really tries. The only response to a 400-line summary of the state of the Delphi ecosystem as of 2012 and how hard it made it for new users or to safely choose for new projects/startups (no books, courses, jobs, magazines, few libraries compared to other products, high costs, no user groups or conferences, etc.) was "If you don't like Delphi, don't use Delphi." :-( Seriously, the ONLY rebuttal at all, let alone from a TeamB member. The thing is that I know in my heart that if I start using another language (and I accidentally fell in love with Python during my state-of-languages review in 2012) I probably won't ever come back to Pascal no matter what I tell myself now. I think that's why I've been dragging my feet about my own personal choice of programming languages even while advising other people on what to use. I wanted someone to talk me out of moving on. :-) But as of today though I think that on the day XE5 comes out, barring an incredible improvement in the product, the price, and a plan for a revitalized community (something EMBT seems to show no interest in, making it clear they just intend on milking the few remaining users), I think I'm going to have to say "So long and thanks for all the FishDBs". :-) I've been a Pascal user since Turbo Pascal days, and I wouldn't change my choice of Delphi for the logistics start-up I was the first employee of, eventual 10% owner, and in charge of IT for from 1995-2003. I'll always love Delphi for how it helped a tiny company produce external software faster than a competing firm with 12X the employees and especially for the internal software it helped me create that was able to analyze large amounts of data and give the firm a palpable competitive advantage in freight rate negotiations. It was the "Swiss Army chainsaw" of its day, and I called it "my Access killer" when integrated with Crystal Reports. But just like Lotus 1-2-3, dBase, and Wordstar all had their time, times have moved on and Delphi isn't the market leader any more and never will return to its former glory. That doesn't take anything away from what it did "back in the day". But today there are quite a few open source Access Killers that are leading edge with thriving ecosystems and are simply more productive (in some tests I've done I've reproduced Delphi programs in Python and only needed 1/4 the code!). Sooner or later most of us are probably going to have to let it go (in one online search of a 40 mile radius of the NYC area I found only 5 Delphi-related jobs and just one that didn't involve porting code to C# or just maintaining a Delphi legacy app while writing new code in another language). 
Epic reply, and I wholeheartedly agree. You really know what you're talking about.
Yeah, that was kind of my point (but I was typing on a phone, late at night!). You're not going to get new blood starting out in development to choose Delphi as their language of choice, because who's going to want to spend money (even the starter edition costs around £150 and that's missing loads of features) when you can get into most other languages for free? Ramping it up to established developers moving into Delphi, if the company that I worked for wanted to buy an enterprise license for every developer, you're looking at £150,000+ and then there's the extra licenses for the additional third party libraries that we use. It's just not going to happen. I have two young sons. I'd like to think that once they're old enough to take an interest in what I do, they'd like to do some development themselves. If so, I'll be starting them on Python or something similar. I can't see the point in paying a three figure sum to get them started in a language that is on the decline.
If you program in C# would you not agree that it is better than Delphi in every single way? Better 64 bit support. Better IDE, although debatably the Delphi editor probably beats VS's editor. More language features, like extension methods, compact lambda functions and not least LINQ(!!!). VS has fewer bugs and is faster. C# has better documentation. The framework is more mature. It is easier to build internet applications in C#. Top three things Embarcadero needs to do: 1. Fix the IDE. 2. Update the language and compiler. 3. Double the documentation staff. They also seriously need to look at the pricing, because it is just ridiculous.
The idea of making Delphi relevant again is wishful thinking. No one should complain about EMB seeing things realistic. If you have a look from the perspective EMB 'just' supporting Delphi, they do good job. I just finished 2 applications for my own use and those work pretty smooth. I really don't care if I could solve the one or other issue in a more sophisticated fashion in .net. That's not the point. But if I would be young I'd rather go for open source completely. The whole story started decades. The problem was simply, at the time when IBM or DEC were king there was no chance to enter IT business for someone except a few chosen - getting a good job without knowing COBOL or PL/I was impossible. Then the C64 and similar computers entered the market. This was not the enterprise league but a great opportunity for everyone even outside the western world. MS allowed everyone to enter IT business in the professional league. Databases played a vital role too. This is almost forgotten today. Turbo Pascal as well as Delphi were part of that opening. MS finally opened the door to the world for everyone into every direction. The next logical step in order to allow everyone in the whole world to start up in IT was open source. It's about equality of opportunities. That's why open source matters. IT is the first profession that achieved the goal of international corporation. I see no reason why we should miss out this opportunity. It requires a shift in the mind-set. There are several guys in the IT world that are willing to do this shift and others try to go back to the old days ... this road is closed. When there is a paradigm shift, there is always a certain period when things seem go on as usual. One day anyone else does things a different way. These shifts are groundbreaking. In 2k companies on 'Oracle' appeared at customers sites showed up and said - now we do E/R Modelling. You can have best team with amazing an experience in the area of building software - if there is another one with a solution that already provides 80% out of the box and the paradigm moves towards customizing you can either start to get to know the new way, jump on a new train departing or try to compete those who have been driving the paradigm shift over a decade. You don't have good cards in the latter case.
I've been a spectator since 1995 with Delphi, and didn't really jump into it as a programmer until about 2004. I have spent a lot of time &amp; money trying to track down books, training videos, etc. on it since I had a lot of catching up to do. After learning how to program in it the hard way (and I have 30 years of coding experience in other languages), I found myself in an environment I loved. I think many share this view of the language and thought process (and tools for that matter). The problem for me isn't one of whether there is enough work out there for Delphi developers. I'm self employed and I develop mainly for 'the cloud' so my employers (clients in this case) couldn't give a rats a$$ about what language I use. I choose one that has high performance and lets me get up and in the morning and enjoy being a programmer. In 2007, I left the Delphi world because there wasn't a solution for developing web apps that I could host on Linux that was easier than doing it in PHP. So I've been doing PHP ever since. I don't love PHP. But with the recent XE5 announcement, and with a willingness to compile with FPC for Linux, and with a lot of REST API calls, I've been able to get Delphi to almost a workable state. Android development is a big deal for me, and that's probably the turning point to return me back. Certainly if they had an integrated Linux compiling option, I'd be all in with Delphi. But I can't help remember back to the biggest obstacle for new adopters - the lack of training resources. The biggest problem is that older books can completely steer a noob down the wrong path, and newer books focus more on "What's new in version XXX of Delphi?" than a soup-to-nuts training experience. Its very hard to shine a new light on old technology in our world. If it was, there'd be a lot more dBase III programmers out there. But the world moves on. Delphi may be relegated to being a niche tool, but the one thing that would make them a solid and popular choice is cross-platform support and I do think they are going in the right direction there. I don't think Embarcadero can win the war of new adopters but they may be able to bring back a lot of ex-Delphi developers back to the fold. However all this said, the price is WAY too high a barrier to entry. They need a $1000 product that does Windows, Mac, iOS and Android development - even if it is crippled or limited in capability. Then a developer who can turn a $1000 investment into a profit, will easily front up another $2K or so to make it even better. Right now there is no such option that I can see once you factor all the costs of doing it a piece at a time.
Why would I buy Delphi when I already have c# for android?
Jim Mckeeth bizarrely claimed that C# users believe that there's more code and knowledge reuse available by switching to Delphi than in using C# for Android. He eventually closed the comments on the post he made about this. :-( 
Agree on all these points, but Delphi still provides native executables and close to the metal code when you need it, not to mention stand alone executables without having to worry about the state of a client's .NET versions. I wish they would look at your post and focus on those things instead of spending enormous resources on catching up on mobile development. Why are there still two different methods of parsing in Delphi where red squiggles dominate compilable code? It's madness! Fix that shit! We just need a low-bug native compiler with high level language support. That is the niche Delphi should be focusing on IMHO.
As someone who isn't interested in mobile development and spends their time trying to write performance desktop apps, it is refreshing to see that my opinion on mobile development being wasted resources isn't true. Perhaps over time the mobile development will leech funding into the language development options, especially if the new compiler comes to windows.
ESPERO Q LES GUSTE 
It has more features than Java
&gt;I feel like we have almost-solutions for a lot of high level tasks but things just need a &gt;bit more 'completion'. LOL - several weeks ago I took a piece of paper and started writing down on it things I felt in Delphi that weren't "complete" - partial implementations, flawed features, etc., not completely new things I wanted. I'd jot something else down whenever I thought of it, often when using another product, language, tool, etc. Now the paper is so filled up I'm scribbling in the margins. :-( I think when I counted it was over 40 items, from big ones like automatic memory management, operator overloading of classes, and generics for first class functions to little things like 18 years without a "step" clause for FOR loops, a power symbol for math, or string conditions for CASE statements. &gt;This is just time spent on basic stuff, and my time is expensive! And this is why they're getting their you-know-what handed to them by languages with extensive standard libraries or frameworks and modern, productivity-enhancing features (such as type inference). Sadly, the attitude among many die-hards is that we're just lazy for wanting these things and doing it all oneself somehow means they're smarter (as opposed to masochistic). Once upon a time Delphi was marketing as a RAD tool (although the die-hards now spin that and claim it was marketing as a super-fast, low-level, almost-substitute for C). It was far faster to develop a Delphi program than it was to use C++ with MFC, and far more powerful to pair it with something like Crystal Reports than to use VBA/Access. Now the language has grown more complex (at a much greater rate than its grown more powerful) while other languages and frameworks have rapidly advanced. As you've noted, it's now often slower to develop in Delphi than in other tools. What makes it worse is that because the ecosystem has collapsed it can be very hard to find 3rd party libraries, books, compatible tools, etc., which lowers productivity even more. 
I wonder then, since you've already done the research, what would be the best language to write something that ends up as native code these days? You may say "it doesn't matter these days", but I am often writing software that depends on extremely high performance coding, where I know what's going to fit into the CPU cache, where a GC would get in the way (as well as providing no advantage), and the concept of choosing interpreted or even JIT languages for this seems crazy (you say that JIT compares to native, and I can believe that in a *general* case, but I'm not convinced in the places where it speed really matters). Most languages these days rely on being "fast enough". C++ is great for speed, but comparing the process of writing a performance desktop app in C++ to Delphi it's just not worth the hassle in C++(unless you're writing a utility or a game). So there doesn't *seem* to be a good compromise, aside from Delphi. I like the syntax of C++ but not the convolution (looking at you templates) and lack of safety. I've spent too long looking for compilation issues in C++ let alone type safety issues to be convinced of it's ultimate productivity, compared with Delphi. All the other languages I've seen are either interpreted or JIT. So what's the best option? It's one thing saying the language is behind the times, but quite another when you have to decide between that and the pain of writing desktop apps in MFC or the prospect of dragging .NET frameworks about. As far as I can see it, the best option seems to be to use different languages for each part of the software. So, essentially we've gone back to language fragmentation. I know, I know, appropriate tool for the job, etc. but it's hardly a great solution - especially with all the framework overhead in using different languages. Then of course, you need a way of communicating between these languages effectively, as always. Why on earth isn't there hard compilers for some of the more fancy languages so we can use that high level power and also get good performance? Is that too much to ask? :) Also, as an aside... Perhaps I'm just stuck in my ways but I really like the strongly typed aspect of Delphi/Pascal. From what I've seen of languages like Python they do seem very convenient and 'productive' in a sense, but how much of that type safety comes back to bite you in the posteria? I spent a considerable amount of time writing a thread safe structure for handling vast amounts of text data, ensuring that none are duplicated, and are fetched in as fast time as possible. I would be tinkering with this structure for quite a while, optimising this or that to squeeze a few more ms out and sometimes this was the difference, overall, between running okay, running well and running impressively well. Then I look at Python and see that essentially all variables are variants. What am I to think of this in terms of performance?! I realise I'm probably in a small arena here, but I wonder if I genuinely have any options to get the speed/convenience/productivity when writing apps that HAVE to be *fast* to do their job (ie; beat competitor products).
Yes, but I am writing enterprise applications and I care about speed a LOT. If I'm going to the trouble to build a cache for database items to improve performance, I am absolutely going to care how long an index for this or that takes to set up, and how fast I can cross reference vast amounts of data on a server. I have read that Python, for example, has problems with multi-threading in that essentially all threads are piped through one 'master'. That kind of defeats the point, but I'm sure it works "fast enough" for most people writing casually threaded code. Stand alone executables aren't a major concern, but they do make things a **lot** easier when distributing to clients with complex IT and security arrangements. Somewhere someone mentioned they use Python for Eve Online and I almost spat out my coffee. Are they really using it for anything substantial or is it just book keeping behind the scenes? If the former, I may take a look at that.
I'd love to be able to use Delphi for Android and iPhone development. But I love not being £3,000 overdrawn even more. Seriously baffled at their logic... 
Ok. Java is older, that's true.
[More info on the individual technical sessions can be found here.](http://www.embarcadero.com/coderage/coderage-8-delphi-sessions)
Cool, Thanks for linking that! Be sure to check out my session, Seperating UI and Logic!
Delphi will never be == C#. Since C# is already founded by the Delphi father. :)
What the heck is up with this presentation???? &gt;Functional Programming in Delphi XE5 &gt;This session demonstrates efficient usage of the latest language features for &gt;functional programming in Delphi XE5 such as unanimous methods, class &gt;helpers, and record helpers. &gt; &gt;Level: Advanced Unanimous methods??? Anonymous methods are not exactly the heart of functional programming, but class and record helpers have absolutely nothing to do with functional programming! Delphi really doesn't have the core features of functional programming yet. The presenter is confusing functional and fluent programming, as explained in the comments of this post: http://sergworks.wordpress.com/2012/02/04/functional-programming-style-in-delphi/ I can't believe EMBT picked this talk and no one noticed a problem with it or its "unanimous methods". But then the presenter is apparently a sponsor of CodeRage, as the following talk is highlighting that presenter's product. This is a crying shame; other conferences forbid buying speaking positions. Anyway, good luck with your session, thestamp! Hidtorically there's been very little emphasis in Delphi literature on readability (and too much on making code "fast"). Your talk seems like one of the most useful as well as addressing a neglected topic. 
I suggest keep trying on Lazarus/FPC for client side applications, cross platform support is impressive. I my experience latest versions installs smoothly on Linux and Windows, but there is also a good support forum and issue tracker if you still get troubles. For creating installers, IMHO a good and simple way to go is InnoSetup, using Delphi like syntax, so basically you have a powerful tool (and a lot of useful add-ons) for creating Windows setup packages using basically the same language.
&gt; As for the language itself... today, nothing beats the productivity of the dynamically typed languages e.g. Python, Ruby, etc. That's a **big** lie/illusion. If it were true then PHP would be orders of magnitude better by that simple virtue: it is not. (In fact, I would argue that "the web" should start looking into very strong typing, like Ada -- especially when dealing with (a) private, (b) secure, or (c) critical information.) &gt; Delphi is filled with antiquated hold-overs from Pascal and its single-pass compiler system, including the separation of interface and implementation. Er. Delphi **really** doesn't have that separation of interface and implementation. See [Ada](http://en.wikibooks.org/wiki/Ada_Programming/Packages#Parts_of_a_package) for a real example of separation. &gt; The state of the art is embracing functional programming, design by contract, type inference, features designed to aid massively parallel computation, etc. Agreed. Though what's being embraced might be a poor metric of how *good* it is. (Ex: USB winning over FireWire, VHS winning over Betamax, x86 winning over... any number of nicer architectures [and what it's become with all the extensions], C++ winning over Ada.)
&gt; We just need a low-bug native compiler with high level language support. That is the niche Delphi should be focusing on IMHO. I hear that and I think GNAT.
Those are really good points about adding language features "on their own terms". 
&gt; Delphi always seems to be late to the party in arenas where others have already succeeded. Why not play on their strengths? Because that would put them in the scary situation of leadership? Of not following others and buzzwords? (Also: Why don't we encourage people to play to their strengths?) &gt; release the basic version for peanuts to get people to appreciate how good it is to write performance, easily distributable native apps that require no support libraries. That's a good idea... but they won't do it because Microsoft doesn't. (Obviously forgetting about the `express` editions of visual studio.) 
Older has nothing to do with it: Ada is a good counterexample, the original standard [1983] had: packages, generics, parallelism [`task` construct], and more. Java only got generics fairly recently, and they're less powerful/useful than Ada's.
idx := AnsiMatchText(search,[Target1,Target2,...]) case idx of... what's one extra line between friends?
That's not more readable than a regular Case statement, but the big drawback is that it only works for a boolean proposition, in which case you're probably going to want to use a regular If statement anyway. The benefit of Case is in avoiding a large, cascading If structure caused by many possible choices. 
Sorry that should have been AnsiIndexText - it was late.
I have the same question, did you find an answer somewhere? I'm particularly curious about rapid GUI development using Delphi, after seeing some Delphi enthusiasts do so surprisingly quickly.
2 thoughts 1) I'd live to use delphi for app development but its too expensive. 2) How many keyboards does that guy get through a year. Jesus - go easy on the return key. 
What is this?
If the developer is following this thread, I have a couple of questions I'd like to ask. Is it possible to use class names and method names for routing? (Like datasnap and asp.net mvc.) Can you have additional route values converted to method arguments? - For example /myclass/somemethod/42 will call the method myclass.somemethod(42)
TWebBrowser is a wrapper around the WebBrowser com object, so much of the documentation of that com object is relevant to this question. http://msdn.microsoft.com/en-us/library/aa752085%28v=vs.85%29.aspx Submitting a username and password usually goes via a form submission, but each site may have its own slightly unique method of doing it. You have to check the source code of the site you are looking at to see how login works. For simple Form submissions, use the [Navigate method](http://msdn.microsoft.com/en-us/library/aa752093%28v=vs.85%29.aspx) I think to do an action in the background on a website, you could put TWebBrowser on hidden form and use it from there. 
http://curl.haxx.se/libcurl/pascal/ or similar should work for you. also get more familiar with how GET/POST work http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol 
Here I'm. 1. Currently is not supported but it is on the roadmap 2. It is not planned because IMHO it is very unflexible and save very few code to write. In jax-rs there is but I decided to don't put it in dmvcframework. There are a lot of routing samples in the repository.
Why do you want to move from Delphi? You need better reasons than just "looking for a modern language". If nothing else then take a look at the latest editions of Delphi XE, it really has evolved a lot. But if he's an experienced programmer, then he'll have no problems learning any of the top languages quickly. My advice would be C# if your applications are Windows based, Objective-C if they're Mac OS X based, or Java if they need to be cross platform.
That's easy! C#. It was invented by the same guy that invented Delphi, and I really think it shows. It feels very familiar coming from Delphi.
FreePascal + Lazarus
Plenty of reasons. We had a good discussion about this a while back, the thread was removed, but I had it archived. http://www.reddit.com/r/delphi/comments/1b3rbx/delphis_quality/
In that case I concur with /u/Glaaki.
C# it's the new VB. Either he knows the OS level than I think you would not ask and if not C# is the most compatible option left concerning the paradigm. Today the language does not matter that much anymore. The class library and the execution environment is the essential thing. Wondering why you want to switch in case of a desktop application/CS application. You can benefit if you make extensive use of the .net framework for example XML processing, such things... But on the Java stack and MS (.net) stack you find many open source solutions today that bring you beyond what comes out of the box, wonder why those exist.
Agreed. If Delphi is his strong suit, FP+Laz should be great especially since it's cross platform and is now supporting iOS and Android.
One really big consideration is: Does the system have to support MULTIPLE theater seating maps? i.e. is there only one theater, and the seating is always the same, or is this a generic program, and you could have any number of maps? The more flexible the system needs to be, the more complex the programming task will be. You can use a generic component, such as a spreadsheet style component, and just set the background color based on seat status, or you can be more creative, and use a charting/graphing component. You may want to check this component out. It is called TSimpleGraph. It works with Delphi 7, it is free, and has full source code. It can handle chart objects, and it lets you be as flexible as you need to be. It can be found at: http://www.delphiarea.com/products/delphi-components/simplegraph/ 
For form submissions (including API calls), I use TidHTTP. 
Don't choose a new language because he "just needs to learn a new language." There is no business value in that, and actually will cost the company more (loss of productivity, resources spent learning, could be working on value projects). Choose based on the solutions that gives the company the most business value. As lead (I'm assuming you are), you're in charge of what the next step is, and how it can benefit the company. You take that strategic decision, and turn it into milestones. You then develop a plan for your developers to develop to reach those milestones. Once decided, get your company to invest in your developers: buy them books, reimburse for passed exams and courses relevant to the company. A developer is there to develop, using the tools the best serve the company, regardless of language.
The author replied back to you, he just didn't press the correct reply button :P. Look at this thread for his answer!
Thanks!
Interesting. Thanks for replying. I feel like the ASP.Net MVC way of using convention above configuration is really powerful, as long as you can decide on reasonable conventions of course.
Funny enough, yes because many years ago I wrote one for a commercial cinema Point of Sale system in Delphi 5. The approach I took (as best I can recall) – I built up a simple hierarchy of objects to represent the Hall, Section, row (of seats) and seat. The Hall had dimensions and background image (so you could display information like screen, exits etc if desired - just a metafile, though it can be a bit problematic making them draw correctly), each section had size and position relative to hall, each row had position and “row number” in section and each seat had size, position and seat number. When you needed to draw the hall – you would pass in a canvas object, with origin and scale (allowing you to zoom in on large halls) – first the hall would draw the background (correctly scaled and positioned), then each seat would draw itself in the right position and colour depending on whether it was available, reserved (by another terminal, but not yet sold) or sold. I would have used a TPaintBox (or maybe something derived from TPanel) to display on the screen. When you changed the status of a seat, to avoid flashing, you would only draw the seats again (but I recall a lot of effort to ensure screen didn't flash on redraws, scrolls) When the user clicked a mouse (or touch screen) – the code would scan the seats until it found the one that would be displayed under the click (you had to convert the X &amp; Y to an absolute position in the hall, then each seat could be checked). The previous attempts by the company had involved creating seat blocks and seats as button type controls – it was poorly coded and some PCs seemed to choke on the larger halls (could be 1000+ seats in them and each seat would have it's own winproc and handle) , it also couldn't cope with row where seats were offset from each other– so I took it right back to basics and totally re-worked it. Now if I was to repeat the exercise the one big thing I would do differently – I would have a render to draw hall/seat, rather than each item knowing how to draw (would make it much easier to change what is displayed) and probably just use a bitmap for the seat (rather than drawing it in code). Some of the other things I had to consider (but may be out of scope for you):- There were usually multiple POS selling tickets for same showing, so you had to show sold, reserved and available, when you selected alternate seats to ones reserved you had to double check no-one else had sold/selected them them since you loaded screen. I used a system where each row had a number of changes column (each seat was a byte in a blob) – if when you tried updating it the number had changed, you had to reload, recheck still OK and try again. When selecting seats to purchase you want to try ensuring you have a good block for the group (i.e. for some reason most couples don't like sitting opposite sides of the cinema) and the cinema – i.e. no gaps between groups. 
You should probably put projects somewhere in your Documents folder under your user profile, not in Program Files.
When you create a project, just save it in a subfolder under your documents folder.
You should always save a project before you compile and run it. In MY opinion. Others may have other ideas. I am going to find the earliest version of Delphi I have access to and do a step by step guide in another post. Hang on.
Right-click the Delphi shortcut that you're clicking to run Delphi. Select "Properties", and on the "Shortcut" tab, set the value of "Start In" to a work folder (for example, C:\Delphi or C:\Work\Source-code\Delphi) - basically, the default location where you'll be saving your applications. When you run a project without saving it, this is where the project related files will be created. It's also worth going to the "Compatibility" tab and checking "run this program as an administrator". Having said that, you're much better off doing as Glaaki suggested and creating a folder to save your projects into, and then saving projects before you compile/run them. I have a "sandbox" folder to save projects that I throw together to test a concept and a "source code" or "work" folder (home/work PCs) to save actual projects that I'm working on. Your error ("Can't create output file") is because Project1.exe is already running, and Delphi is unable to create another process with the same name (likely because it'll save it in the same place in order to run it). End the project via task manager (not sure why it's still active, but it's probably authority related) and try compiling again - or save the project somewhere and try again. Once you've saved it into a folder, that's where Project1.exe will be created so you'll get around the error that way.
Thanks alot for all your patience and help,but unfortunately i didnt get to try fixing it by this guide,cause i justfound really quick solution to this problem.I tried running it as admin(anyway im admin all the time),didnt help,so basicly what happend was,my antivirus program automaticly recognozed "project1.exe" as virus and prevetably (is that a word?) put it in cofin,so when i tried to run program, "project1.exe" was running in backround,i could see it in task manager,but it was used by the antivirus and therefor i couldnt run the program.And solution? i went to C:\Program Files\Borland\Delphi7\bin rightclick Delphi32 -&gt;Run as and i ran it as Active User and unchecked the "secure computer and data from unauthorized actions of this program" (antivirus wont trigger anymore) imgur link: http://imgur.com/M5BQnPo Anyway,kudos again,for your time and patience
edited fix,thanks every1 for your time and help =)
Stupid stuff like this is why I never run antivirus on development computers.
I've always used Rave reports which comes with Delphi. I think I'm using the enterprise edition of XE. I've never used the report builder that Rave comes with. I just build my reports in code from a blank report and sometimes I use a report sans data as a background image and fill in the blanks in code. [Edit] I'm using the professional version.
Export to HTML, XLSX, or automate Excel.
We have some Rave reports that are generated that I couldn't do in Fast Reports. The business execs like designing and running their own reports that don't come with the software package so it's tough to find something that can be made in a designer. I never used the Rave Report designer either so I'll have to check on that out. 
My current project so far doesn't use any reporting engine like Rave, but instead uses [active query builder](http://www.activequerybuilder.com) for the builder for both search queries and reports. The reports are exported to excel for mail merging etc. The query result is loaded into a 3rd party dbgrid by ([TMS Software](http://www.tmssoftware.com)). I built a simple builder which can talk to the query builder so the users can build searches and reports without sql knowledge or they can use the advanced builder which resembles the MS Access query builder. Having a builder like this gives them the most flexibility without requiring me to hard code any reports.
I wouldn't bother with designer. It is horribly broken. Buckets of A/V's every time you try to change an existing report. We tested it thoroughly as a Quickreport replacement and fortunately found out it was unstable before we committed to a new framework. I have heard other people report the same problems in EDN forums. On the other hand lots of people use Rave for code based reports, apparently with a lot of success.
I see nobody mentioned. There is also FreeReports, which is a free tool, source included, based on an old version of FastReports. It is rather old and the designer is a bit clunky and I actually never tested it with newer versions of Delphi but it works and you can also do your improvements. Much better anyway than obsolete solutions like RaveReports or, shudder, QuickReports. 
I've swapped over to creating a temp html and then openning it in the default browser. What's not to like? - table, font formatting, printing handled by browser, user accustomed to using a browser, portable.
cleanup on close.. and use events like OnConnected to where put the join stuff..
I'm not sure if this is what you're asking about, but you have to **install** Indy before you can use it. For that, I bet there's an installer or readme. Follow the instructions there and you'll have all Indy classes available in the tool palette. By the way, if you use latest Delphi versions (2010, XE, XE2, XE3, XE4, XE5), they should have Indy already installed. So just look in your Tool Palette, there should be tabs named Indy whatever.
https://www.google.com/search?q=indy+installation
Which version of Delphi?
I was using turbo, but I got my hands on 7. The same thing still happens though, it never does the joining phase of the program. It connects, and then tries to join but nothing happens. At first I thought it may be taking really long to join, and that's why it was throwing the error on the exit, but I'm dubious now, it's much too long.
I think you would be better off using something like Lazarus instead of such an old version of Delphi. I am not going to get a hold of Delphi 7 and test this. I tried that once in here and it was a waste of time for me.
The answer to this depends greatly on *what* you're doing. Assuming the main "workhorse" of your applications is algorithmic/data-processing, I'd recommend Ada. (Coming from Delphi he ought to pick it up really quickly.) I list a bunch of reasons why Ada is considered good for safety critical systems **[here](http://www.reddit.com/r/programming/comments/1pgyaa/toyotas_killer_firmware_bad_design_and_its/cd2jqur)**, most of these features are applicable to software in-general. Three notes though: * Ada doesn't have as good a reputation in GUI-land as Delphi, even though there *are* some tools (GUI-builders, IDEs, etc) for it. * I haven't found a good [and free] Database interface. [Gnatcoll](http://libre.adacore.com/tools/gnat-component-collection/) is supposed to have postgres support, but I cannot get that to compile cleanly. * While you can use C-headers to generate a library-binding via `gcc -fdump-ada-spec`, the generated bindings are very thin; it may take a bit of work [and thought] to make thick library that takes advantage of Ada's abilities.
Visual Studio / C#
Why not try /r/forhire?
What do you mean, please fork?
I suspect you could add mORMot in some other categories: 1. Inversion of Control - Dependency injection - see http://blog.synopse.info/post/2012/10/14/Interfaces-in-practice%3A-dependency-injection%2C-stubs-and-mocks 2. Unit Testing for both: * Unit testing - see http://blog.synopse.info/post/2010/07/23/Unit-Testing-light-in-Delphi * Stubs and Mocks - see http://blog.synopse.info/post/2012/10/14/Stubs-and-Mocks-for-Delphi-with-mORMot 3. Reporting for 2 main features: * Report from code - see http://blog.synopse.info/post/2010/06/30/Making-report-from-code * PDF export - see http://blog.synopse.info/category/Open-Source-Projects/Synopse-PDF-engine 4. User Interface: Dialogs - see http://blog.synopse.info/post/2011/03/05/Open-Source-SynTaskDialog-unit-for-XP%2CVista%2CSeven 5. n-Tier / Client-Server - see http://blog.synopse.info/post/2012/03/07/Interface-based-services and http://blog.synopse.info/post/2010/07/18/DataSnap-like-Client-Server-JSON-RESTful-Services-in-Delphi-7-2010 6. Http server - see http://blog.synopse.info/post/2011/03/11/HTTP-server-using-fast-http.sys-kernel-mode-server
What?
Thanks ! I've updated the list with your links.
Delphi support for mobile is not very old and Android support only started with XE5, so no idea how stable it is, but I imagine that documentation and community support for it is pretty lacklustre. Delphi is not that different to other OO Languages. It can be more verbose sometimes and will probably miss some features that you are used to from other languages, but it's usable.
&gt; how steep/long is the learning curve on xe5? No problems here. Delphi should be a pretty easy language to learn. In some way it feels like an extremely verbose form of C#, but with less polish and missing a few modern features like linq and stuff. The IDE is nice as well. One of the selling points of Delphi is that it is a RAD, meaning rapid application development, and that certainly isn't false advertisement. It is kind of low quality and rough around the edges. You WILL encounter bugs in the ide and weird crashes from time to time. Embarcadero are well known for focusing more on features than bugfixes. &gt; how is the documentation and community support? In the range from adequate to non-existant. Lots of missing docs, and it can be very hard to get help for your specific problem. I recommend stack overflow for asking questions over the official forums. It isn't exactly a popular platform these days, so you will occationally feel very alone on the prairie. &gt; are there any dramatic gotchas that you wish you'd known about before you started with xe5 Not really. I was stuck with it since it is what my employer uses. In general as I mentioned earlier, Embarcadero (and the previous product owners as well) has a reputation of favoring features over quality. You will encounter bugs and things that dont work as expected, it is just hard to say beforehand what those things will be. A lot of the time you will just have to figure out some workaround. Also, since mobile support is a new feature, expect bugs bugs bugs especially in these features! &gt; how is the finished product? the claims are pretty tall; does xe5 really deploy cross platform as well as advertised? I think so. You might have to struggle a little bit to work around the rough edges, but overall I think it should work as advertised.
Your client is telling you what tools to use, that will not go well. As for Delphi XE5, it's a pretty good bet for a multi-mobile-platform RAD environment. But you should expect bugs in the core libraries, because it is still very new.
&gt; Your client is telling you what tools to use, that will not go well. Seriously? If I'm contracting out software development damn straight I'm telling you what technology to use. I'd also own the code - and what's the point in owning code you can't then maintain? Of course I wouldn't be specifying Delphi.....
If you're contracting out software development, would you also 'damn straight' pick a team of four developers with zero experience in the development environment of your choice? Would you also want to maintain their mess afterwards? Also I've worked on several projects where the developer owned the code, but the client owned the product and its licensing. There are many valid reasons for such a setup - price for one.
When you get your car fixed, would you tell your mechanic what type of wrench to use? If you knew what was best to use, you'd probably be doing the work yourself, wouldn't you? Generally a client should be specifying what to do but not how to do it. Presumably the team with the development experience is going to be the authority on what tool is best for the situation (including what they are most experienced with).
What was confusing about that?
You can add mORMot in EVERY category. :-) I suspect it's a few thousand lines of code away from achieving sentience... unless it already has and is posting as "abouchez". ;-)
Guru.com is one of the biggest sites for finding coders for projects.
Just so much technobable for something as simple as a list, that's all. It seems like a lot of work. I don't use github personally, but I guess everyone else already has an account? So I need to learn how to use github first and then clone his repository just so I can add some weird library and then send the changes back? Maybe I am just a glass is half-empty kind of guy, but I am just not seeing the usefulness of this.
&gt;When you get your car fixed, would you tell your mechanic what type of wrench to use? No. But we're not talking about fixing a car with wrenches. &gt;If you knew what was best to use, you'd probably be doing the work yourself, wouldn't you? Why would I? I have other things to do with my time - I'm no longer a developer (in my day job). Developers are to some degree a commodity. We need something building that we don't have the internal resources to build, so we go to market. We have several suppliers that we use. Sometimes it will be turnkey, sometimes it will be to supply contract resources - always it will be using functional specs we supply, mostly our tech specs but always we will approve tech specs and architecture. I'm not saying this should happen every time or even most times - just that a client specifying tools is not always a recipe for disaster. 
I don't think this analogy holds. This is more like designing a car and asking someone to build it. Then you can say you want the body build out of steel and not plastic or glassfiber.
Some of the more complicated stuff is pre-calculated via Delphi software, but the data comes from a database, and it gets rendered to HTML via PHP. It's flexible, easy to develop, easy to deploy, online, so the reports are easy to distribute securely (https). The reports are flexible, always contain the most recent status if needed, and you can split development work easily between web developers, dba's, backend developers and graphical designers. I used to use Crystal Reports in the past, but it was a constant nightmare to design the reports, to keep track of who needed to get which document in which format, and to actually send the documents around. Switching to web based reporting opened up a new world of possibilities, and made life for us developers a lot easier. PHP has its drawbacks, but the general idea to ditch reporting engines in favor of online reporting should really be considered. I personally wouldn't switch back to an offline reporting engine anymore. It would feel like a major step backwards. 
I am a professional user of Delphi and I think XE5 is a pretty solid release. The Android and iOS stuff that you'd be using for the Tablet app are LESS mature than the core Win32 stuff, but it's the only product out there right now that (a) targets both Android and IOS with single source, and (b) offers a framework. The only thing else out there that is even close to capable of doing what Delphi does is the C# + Xamarin stuff, but it's got no cross-platform framework yet. As far as "as well as advertised", I guess I wonder what it is you want to do? If the app is going to stretch the limits of mobile development, I'm sure you'll find Delphi (and any other technique other than writing two completely separate tablet apps one in objective C and one in Java, with nothing shared but your bitmaps/assets) comes up short. If your requirements are modest, functionally, XE5 for mobile development should be just fine. 
Me? :-)
Thanks for posting something positive and not delphihatersblog!
I still use Delphi 7 + several extensions (CnPack e.g.). But all my code is Delphi 7 up to latest Unicode versions compatible. Delphi 7 is my main IDE. Then I have never versions of Delphi, just to check that it compiles fine in Unicode mode and Win64 mode. Of course, our apps are mainly based on our mORMot kernel, which is already Unicode ready (UTF-8 from the ground up), even with Delphi 6-7-2007. :) Newer IDEs are only used for Unicode UI and/or Win64 target. You can do wonders, even without generics, thanks to the Delphi class system: the "TMyClassClass = class of TMyClass" then "aInstance := aClass.Create" works very well, so I use the "class of" type instead of generics for most cases. Pretty powerful!
Go back and read the haters blog. They've been hating since 2008 and delphi is still going strong. Ignore the haters and make your own decision. Download the trial, test it out. 
All this can be yours for the low-low price of... In the meantime i'll sticking with Delphi 5. i'd love to upgrade to Delphi 7, but no customer wants to pay for their applications to have the code-base updated.
&gt;All this can be yours for the low-low price of... Yes, Warren doesn't address any of the actual objections people may have for upgrading. He showed up with a post on the Embarcadero forum in "The Case For Delphi" thread but he did a hit-and-run post that avoided the question and claimed that the case had been made a million times and then didn't respond to a rebuttal. What's also missing and part of your "low low price" objection is an answer to the fact that everything he cites as a gain for upgrading can also be gained from switching to many other development tools for a cheaper price (or even free). He still needs to make the case of if someone is going to purchase new dev tools and refactor code, why specifically stay with Delphi. I'm not saying a case can't be made, just no one seems willing to try to make it. Even Jim McKeeth, EMBT's chief evangelist, made vague claims about productivity in his last blog post and then failed to present any examples of it. When this was pointed out and discussed in the comments, he again made vague statements and confessed that other languages have improved their productivity too but again failed to give a specific example of a Delphi feature that improves productivity over all its other competition. :-( Warren doesn't address any of the structural issues, such as a switch to a rapid release cycle (6 months) with a lowering of the support window to 8 months(!!!), which is frankly insane. Do you want to be upgrading your dev tools twice a year? EMBT had a significant quality control problem with a yearly release cycle; how much worse will it be when they try to put out two releases a year? Even free open source tools have a 3-5 year support window. Lowering theirs to 8 months is not how one competes with free. Then there's the up-front cost and the need to be on SA or else the 6-month release cycle will make the pricing completely nonsensical - essentially you'd be getting half the features as one used to get per release but still paying full upgrade price. Of course, road maps are another issue. EMBT never updated their roadmap past 2013, other than mentioning a vague list of things "for the future". We're 3 months into the 6 month release cycle now, and there's still no word on what's going to be in XE6. How can one use a dev tool whose roadmap consists of yelling "Surprise!"? No one knew what was coming in XE5 other than Android (answer: not much) until a week or two before release, and even then we didn't have an official release date in advance and then they went and changed it at the last moment which even caught marketing by surprise. There's just no way to talk about the merits of Delphi without addressing the elephant in the room of the company that runs it or the price they're charging (made worse now by almost compulsory "software assurance").
I've tried in lazarus and have gotten the same problem with the same code.
You shouldn't use **with** in modern code. It leads to scope ambiguity, which can cause subtle, hard to find bugs. You are creating at TIdIRC component in code. Why not take it from the tool palette and put it on your form or in a data module? That way it is automatically created for you when your program runs and it is automatically freed as well when you close your program. The way the code is right now you have a memory leak every time the event is triggered, because the TIdIRC component that you create is never freed. If instead of using TIdIRC.Create, you use TIdIRC.Create(Form1), the component will be owned by the form and will automatically be freed. You can use that method if you insist on dynamically creating the TIdIRC component. I have a suspicion that using TIdIRC.Create(Form1) might possibly get your code to work.
[Link to where the apps would be showcased.](http://www.embarcadero.com/products/rad-studio/application-showcase)
I just installed the free trial and I'll try to make a test app for my nexus 5. Now if I could convince my boss to give me the money to upgrade...
Two hurdles I can think of right off the bat: migration to Unicode (not really that hard) and 3rd party components (some older Delphi components from 3rd parties haven't been kept up to date with the new FM application framework). I would suggest running the new XE5 trial and just try compiling your app to see if it will run first; and then figure out what needs to be changed.
A complete rewrite is free, where you live? The drugs are free too, I guess?
One annoying thing is String's lower bound index is completely different on Windows platform and Android. You have to change all string manipulation functions to android aware, using Delphi's string helper.
Thanks for that info.
Yes there are public procedures. If one unit includes another unit, it can use it's public calls. For 2D fun I would reccomend checking out ZenGL.org and screwing around with their samples
&gt;Of course, I'm also struggling with some things regarding the language itself, like procedure hierarchy. Is there a such thing as public procedures? There must be a way to call a procedure from other units, I just haven't stumbled across any resources that thoroughly explain what's going on. Try getting a copy of Turbo Pascal and reading through the built-in help. That's how I learned Pascal; no manual or anything needed! As for that particular problem... unit MyUnit; interface // declare all public stuff here, e.g. procedure MyProc; implementation // all private or implementation stuff here procedure MyProc; begin ... end; end. Remember to include the unit with `uses MyUnit [, ...];` after `interface` or `implementation` in the unit/program that uses it.
@xamomax: What components are giving you trouble? 
This is a big help! Thank you :)
Yeah, I found ZenGL yesterday in my searches. Definitely seems like the best option. I was also looking into that Vampyre one as well.
Below is a cut and paste of my notes. These notes are current as of about July of this year, so things have perhaps changed since then. When I first attempted and failed at the upgrade, many of these (and more than listed here) simply were not available for XE. Fast forward a few years to today, and it seems I am in good shape, though I have not yet attempted the conversion again... * Our internal code: We have a lot of units, some of which are very string heavy (file parsing, expression processing, etc.). We generally don’t do anything too weird with strings, and use the standard Delphi functions for string handling, but are unsure if the new wide string stuff will be a big pain, or just a minor hiccup. * Multilizer: We use Multilizer to translate our projects at the exe level into 16 languages, with approximately 20,000 strings (so 320,000 strings total). Multilizer works by looking at the resourcestrings and forms in the applications, creates a big spreadsheet, the translators translate the spreadsheet, then Multilizer rebuilds the exes with the translated strings. Multilizer is extremely finicky, and can easily have its database confused and get out of synch. We worry that if we upgrade to the new wide string stuff, that the database will get out of whack, costing thousands, if not hundreds of thousands of dollars to fix (which really means abandon the upgrade). [Status: According to Multilizer: “Switch between Delphi and Multilizer versions shouldn't affect Multilizer project since Multilizer correctly reads both ANSI strings and wide strings from target file, the only difference in Multilizer project will be native and respectively target encodings. However, if you worry about possible results you can download evaluation version of Multilizer 8 and try migration before making decision on purchasing upgrade. Here's download link to free tool that converts Multilizer 6 project to Multilizer 8 format: http://www.multilizer.com/download/data/ml72/utils/mpr2m7p.exe Alternatively you can create new project in Multilizer 8 and then import translations from old project.” * FastScript: [Available for XE3] * ASynch Pro: We have some code that relies on this for text and email notifications. We have not researched yet if a XE3 version is available. [Status: Instructions for installing here: http://edn.embarcadero.com/article/41301. Apparently we do use ASynch in a few places, so we’ll go ahead and upgrade it.] * GLScene: We use this for some 3D display, and have not researched if XE3 version is available yet. [Status: XE2 support added November 2011, according to: http://glscene.sourceforge.net/wikka/HomePage] * ImageLib from Hi Components: We use this for bitmap file importers (jpeg, gif, tiff, etc.), and have not researched if XE3 version is available yet. [Status: Vendor says, “should be no problem”, “maybe a couple lines of code to modify, but probably not”.] * vclZip: We use this for creating .zip files, and have not researched if XE3 version is available yet. * SVN: We use SVN for version control, and are unsure what will happen if we want to upgrade to Delphi XE3, but then need to make a patch using Delphi 2006 – especially since many 3rd party components are installed outside of the SVN (like in C:\Program Files). [Status: Maybe just dedicate an old computer to old software, as an insurance policy should we need to make a change to old pre-XE code??]
My personal take on the price, is that no matter what they charge development tools are practically free when compared to the time one uses them. My sister cuts hair for a living with a $1000 pair of scissors, for example, and it's worth it to her. I would gladly pay $10K for my developer tools, if I knew they would save $10K or more of my time - which Delphi often does. Where I have a problem with the price, though, is that by being expensive it drives OTHER PEOPLE away: Students and Hobbyists, for example. When this happens, it hurts me, because I can no longer quickly find a library to do what I want, because nobody bothered to write the Delphi version, or translate the headers, etc., etc., Unlike scissors, for developer tools if the user base is small, then the tools are not as good because the support network is not there. I would much rather see Embarcedaro take the strategy of a very solid entry level system for free, that does just about anything a student or hobbyist would want, and then let us developers pay for the upgrades that make us 10% more productive than the rest.
There's nothing about when the app was created. It'd be a lot more impressive seeing a new application built with Delphi than one that was originally designed with Delphi in 1998. A lot of the applications that are touted as being done with Delphi, such as Skype and MediaMonkey, date from 2001-2003.
Sounds like you need to learn the Pascal language. Ask yourself this question "What is a unit?". Now ask yourself this question "What are the interface and implementation sections?". Now ask "what is a uses clause and why do I need one?". When you know the answer to this, then the "procedure hierarchy" question you are asking will be solved. Right now you sound like a confused PHP script programmer who has never used a structured programming language. If you even remembered how VB6 worked, you might not find Pascal so confusing.
Agreed. Once you add a VM, everything changes. C# is Java, done with nicer syntactic sugar, but slower. ObjectPascal is closer in scope and capability to C++ but without the sharp edges.
It actually started life as a proof of concept for an iPad app but other things came up and I've not got to grips on XCode. It'll fit no problems (not a phone but I'm planning tablet only). I've run it on an ipad through RDP to a windows machine - works fine. I don't own XE5 - only XE3 starter - and don't have the money to upgrade - so I'll be limited to a month trial to prove it out. If it works well I'll then have to decide whether to stump up the cash or not....
Re-install? When you get something like this that's probably the best thing to do.
Perhaps it would be better to rephrase the question... Given a situation where you had all of the .pas files originally contained in the ActiveX Library but you are not able to load/edit the type library, what would be the best, most efficient method of recreating the type library from the source files available? Hope this makes it clearer...
Delphi install is fine... The typelibs got killed in the hdd crash and all i have now are the .pas files for the ActiveX Library... I'm hoping I can recreate the typelib somehow...
No. From the error you describe it sounds like you are missing a component of the Delphi IDE itself. As far as I know there are no source code supplied for the IDE itself, so consequently there is no way to rebuild the component you are missing from source. That's what it sounds like to me at least.
All gui-stuff for our applications are made with Delphi :) http://www.softcolor.fi/ 
Cool! Good luck with this!
yes... for theses there were no incremental versions... I've tried re-registering from the compiled DLLS, but the IDE still gives the error when I try and open the typelib for editing... I think it's a mismatch of CLSID in the registry or something like that since all the .pas files are fine...
Amazing how far Delphi has moved forward within the last week.
It appears as though the official location for the Omni Thread Library is [http://otl.17slon.com/index.htm](http://otl.17slon.com/index.htm) However, when I go there, there is no news about this new update. Likewise, the web site appears to be quite out of date, with no mention of this new update, nor support past XE2. Finally, it's support page links to a forum that does not exist. I am very much interested in using this, and it appears to be a phenomenal product, but is it something that can be trusted?
Ouch.
It's very trusted, it's the only complete solutions for threading in Delphi, which is still actively developed.
&gt; Is Delphi dying? Yep. There's some struggle, but with $1+k price it's not going to get any new enthusiasts. And I don't think they'll attract lots of corporate clients, even with mobile development. But post-Delphi pascal is not just Delphi. There's FreePascal which compiles Delphi code for almost every platform. There's Oxygene which seems modern and cool and it's development is actually guided by people who understand what programmers need, not just follow every fad. If I were switching to Delphi now, I'd definitely go with Oxygene (at least for starters, I dunno if it's good in daily use). Then there's C# which is in lots of ways similar to Delphi. Oxygene can compile to the same .Net and supports close to the same feature set, but Oxygene can also compile for mobile and other platforms, so there's that. C# == slightly cooler language + more solid choice (e.g. C# coders will be needed for many more years), Oxygene == compiles for more platforms + based on post-Delphi Pascal.
...and Linux and iOS and Android. Lazarus just plain rocks.
Embarcadero has reported big increases in revenue from Delphi every year since they acquired it (with the exception of 2012). They have also been investing heavily in R&amp;D. In the past two and a half years, support has been added for Mac, iOS, Android and 64 bit Windows with more on the way. And I use it every day. So no, it's not dying.
Have you used it for mobile? How big a jump is it to start using Lazarus for iOS build? I've done Mac and PC but thinking about iOS...
Sorry but no. I just know that it's possible but have never played with doing a mobile app on it.
Lord, I hope not....got bills to pay!
I have been using Delphi since version 1.0, and my opinion is that it's going through a renaissance due to the new mobile features. I mostly do development for the windows desktop, but you can now write code that targets Mac and Windows desktop, and iOS and Android. Obviously only some of the code is shareable on all four places, as the mobile world's user interfaces are very different from desktop, but that's one IDE, and language syntax, and two very powerful, but very different frameworks (VCL and FMX).
+1 for Oxygene, which allows you to enter the .NET world with a more modern Delphi.
Does it have code completion (code insight)?
Yes, there are programmers here. Delphi is not dying. You will not escape to choose more wisely than ever before for a specific alternative serving a decent purpose. In the most simple case you could give sharpdevelop a try. If you are happy with that, I think you found a smart way to address Windows specific requirements but still rely on you own creativity when it comes to controls. Sharpdevelop and open source .net stuff does integrate well and is maybe a way you are already used too. Adding that will not make you more effective since you can solve most of the issues anyway already with what you very likely know. All the other alternatives have already been listed. In general. All solutions found in the 'Pascal' world share a certain commitment to simplicity at different levels. Oxygene allows you to address the APIs provided by a platform very straight. FreePascal on Linux does offer various clever tricks to overcome the complexity of a solution found in C solving the same issue at the OS level. Delphi especially on Windows is as straight as Python and not that coltish as Java in general. It's not VB - it never was. It still requires a certain commitment to object orientation but does not introduce the complexity of a whole stack in a first place. You can simply grow into Delphi. All Pascals are very common in one point. Pascal code is never wrong. A better solution found 3 years later can easily be integrated, design decisions reverted and even compromises deployed don't impact the program. You can do a step by step migration without considering that the architecture from the early beginning. Feel free to do, but it's not a requirement. Since not all developments are that huge a pragmatic improvement does the job. Some people call that sloppy but I call that - not wasting my time with shadows from the past.
Delphi is not growing in any measurable sense. In most first world countries it barely registers in the job market, no commercially published books since 2005, every language popularity index shows it declining, etc. There are still people using it, but it's a rather small community compared to what you'll find with Java, Python, C++, C#, Ruby, etc. The major drawbacks are that it is very expensive, there's next to no learning materials available for modern Delphi, you don't have anywhere near the extensive 3rd party libraries of major languages, no one makes APIs for it, you need to run it on Windows, it's not known for being bug-free to put it nicely. Perhaps you might want to share why you really want to learn Delphi. Perhaps the qualities you're looking for might also be present in another language or tool. As others said there are also non-Delphi Pascal products. 
Revenue &lt;&gt; users. In addition, they've employed all sorts of tricks such as different time periods, comparing periods in which they've released two versions to periods in which they released one, omitting the period during which it was rumored sales plunged, etc. What is really needed to determine health is the number of new users, and even would be complicated by those who wait several releases before upgrading and needing to pay full user price. We really don't have the numbers to support the idea of a growing Delphi user base and frankly neither does Embarcadero. If you want to look at numbers, look at membership right here on Reddit. 427 users subscribed to /r/Delphi. The other two languages the poster uses, Java and Python, have 25,388 and 63,189 members respectively. Reddit skews young, so that should be all one needs to get a leading indicator on how well Delphi will be faring in the future. &gt;They have also been investing heavily in R&amp;D. In the past two and a &gt;half years, support has been added for Mac, iOS, Android and 64 bit &gt;Windows with more on the way. I'm not sure this is something to brag about. Every other language already ran on OS X and not getting 64bit Windows support until 2011 was embarrassing. In fact you can't use a 64bit integer in a for loop with the 64bit compiler, so technically they still don't have a working 64bit implementation in 2013. They added ARM support, but then again everything else was already there. iOS and Android support are the only things they added that were significant, and even there they had an aborted start. They no longer have Linux support in the era of Raspberry Pi and CES 2014 even bringing us a Linux-powered slow cooker (I want my slow cooker to run Delphi, dammit!). PowerBuilder has also signficantly retooled - it now supports .NET and the web, for instance. Regardless, that had no impact outside of the handful of PowerBuilder users left. &gt;And I use it every day. Well that settles it then. Why didn't you say that in the first place? :-) &gt;So no, it's not dying. Yes. Yes it is by every quantifiable measurement we can make. Delphi users are switching or retiring and there's no sign that there are any new young developers to take their place. Younger people have never seen a line of Pascal code nor do they even know what Delphi is. Worst of all, no one at Embarcadero or their TeamB/MVP allies are capable of explaining to non-Delphi programmers exactly why they should choose Delphi in lieu of more mainstream options - what specifically does Delphi offer *that no one else does*. And that's how languages die. From a talk by Van Lindberg.... &gt;Asking "why do I care?", he explained that it's important to keep &gt;growing — otherwise [a language] will end up where Smalltalk and Tcl &gt;are today. He rhetorically asked the audience when the last time was &gt;that anyone did anything interesting in Tcl. Noting that these are &gt;fantastic languages, Lindberg argued that "they have died because &gt;they have not grown". It's not just the language, but also the &gt;community around it, that can die. SmallTalk, Tcl and COBOL aren't "dead" in the sense that there's still someone, somewhere that uses them. But they're completely irrelevant today and have no impact on modern computing. Many people who came into programming past these languages' hayday have no idea what they are and no one seriously considers any of these languages for starting new projects anymore. That's the fate of old languages that stop growing. Delphi may have finally begun to target new platforms (way behind C, C++, Ruby, Python, PHP, Perl, of course Java, etc.) but the language itself remains steeped in antiquated concepts. Basic enjoyed a renaissance for a time thanks to Visual Basic but only by reinventing the language along with the platform (no line numbers, OO, etc.). Is Delphi willing to go that far? That's the state of Delphi today and the problems it faces. Ask yourself this: when's the last time that a new (not new to Delphi, but new to languages, novel) feature was introduced to Delphi that made other language developers say "Oooh! I want that!" and other languages copied as a result? The answer to that question is when Delphi wasn't dying. There was a mistitled article that came out a while ago called something like "Delphi: 18 years of innovations". An innovation is introducing something new and unique, not catching up to what other people already had for 4-5 years (64 bit, generics, anonymous functions, etc.). If Delphi wants to grow it needs to attract people with something new and useful (as the functional language folks are doing, as Scala is doing by fixing all the warts of Java, D is doing by trading a little of C++'s power away for a significant decrease in complexity, etc.). What is Delphi offering that people need? What problem does Delphi fix? In 1995 that was easy to answer: It made rapid application development for Win32 desktop possible as it was much quicker and easier to develop in than C++ and the notorious MFC and much more full-featured than VB. But in the era of Python/Ruby levels of RAD and .NET, JVM etc. full-featured libraries, what's Delphi's killer feature today? And if there is one, does it justify the significant pricetag over other products (including free products)? Those are the questions that need to be answered and on which Delphi's most fervent supporters are mute. Unless and until those questions have answers the language will continue to bleed users.
Hell no and no once you've used anything else, respectively. Although this may be a trick question as for most of its existence Delphi hasn't had anything approaching a serious web framework. I think the Mormot project is the only thing resembling one today. 
such a great answer to my question. thank you sir.
What are you talking about? Google or Apple have nothing to do with the Firemonkey framework. The post is clearly referencing the numerous places in Embarcadero's documentation where you click on a method or property and it comes back as no information being available. 
I'm just trying to figure out what SDK is being referenced, since you are right: Apple &amp; Google have nothing to with FM, other than the fact that you use iOS and Android SDK's that are required to build an FM (mobile) app. The post makes it seem like there is some proprietary FM SDK.
What development environment has some dickhead who's dedicated an entire blog with regular updates just to whine and complain about their development environment.... Maybe it's time for this blogger to just move on to something else? Gees, if I hated something so bad like that, I'd just go do something else. 
Anyone out here using Multilizer? What are your thoughts? Are the newer versions more stable? Are the updates worth it? I don't need the twitter feed feature in the new version, but I am using an older version that is quite quirky, so am curious if the quirks have been fixed and if the stability has been improved. 
Only if the Soviet Union should have been flattered by Voice Of America: &gt;In 1947, VOA started broadcasting to the Soviet citizens in Russian under the &gt;pretext of countering "more harmful instances of Soviet propaganda directed &gt;against American leaders and policies" on the part of the internal Soviet Russian- &gt;language media, according to "Cold War Propaganda" by John B. Whitton. The &gt;Soviet Union responded by initiating electronic jamming of VOA broadcasts on &gt;April 24, 1949. &gt;Over the next few years, U.S. government debated the best role of the Voice of &gt;America. The decision was made to use VOA broadcasts as a part of its Foreign &gt;Policy to fight the propaganda of the Soviet Union and other countries. 
That it took Digifort to produce a working demo to show off FireMonkey? 
&gt;On top of the working demos that ship with the product, you don't have to look very &gt;hard to find lots of discussions, webinars, This is completely irrelevant to the point. Someone looking to use the product wants a demo of what it can do, not a webinar or white paper. &gt;samples (graphical and business related) Again, this doesn't address what I wrote. For two years there were no demos outside of tiny, toy demos which did not show off the power of FireMonkey at all. Digifort's work was the first significant application written with FireMonkey to appear in two years. &gt; tutorials, third party libraries and production applications. No, there are not "production applications"; we can still count on our fingers the number of FM applications that have made it to the app stores. &gt;I don't see this scarcity you are talking about. Bruce, show me the amazing, wonderful, powerful FM app produced by EMBT that does the equivalent of better of this from Digia: http://www.youtube.com/watch?v=vhWS_bN-T3k&amp;feature=youtu.be Otherwise your claim is just ridiculous. Digia gave users that before the product was finished; we got pizza menus after FM was released. It took two years for a serious FM app to appear. &gt;More impressive demos certainly couldn't hurt They were vitally necessary if there was a chance to sell the product to anyone outside of existing Delphi users - you'd need a powerful demo to persuade them to learn a new language to code with the FM framework. EMBT didn't produce anything and now two years have passed and Digia, Xamarin and others have moved into the space offering the same benefits and allowing users to code in mainstream languages such as C++ and C#. They blew a potential lead by having an underwhelming marketing strategy. &gt; If you want to make requests in QC, your specific and detailed suggestions would &gt;be very welcome. Yes, because this would be an idea that never occurred to anyone before and if I just file a QC request about how to market their product they'll see the light and proceed to do so immediately. 
You couldn't find anything in all of the webinars, tutorials and video demos that have already been posted? Seriously? Are there any cool QT videos that show multi-platform support using the same source, multi-tier or database support? That would be cool.
Most of the time I just use TStringList. Much easier to use IMO and you don't have to worry about setting the size each time you want to grow the list.
If you are using dynamic arrays for most of the use cases in this article, you are doing it wrong. Unless you are absolutely certain that you can't live without dynamic arrays for your particular problem, you should be using generic collections. Either Delphi's build in ones, or use Spring4d. Btw. Good job shaving 10 milliseconds off of your array reallocation routine. I am sure your users will be greatly appreciative. ;)
TStringList is so last decade. It is all about TList&lt;string&gt; now. (Yes, I know TStringList has some cool features like loadfromfile, etc..)
What does? TStringList?
&gt; TList&lt;string&gt; 
You raise a lot of good points. What is it with Delphi developers and premature micro-optimization? 
&gt;Embarcadero likes mentioning Altimum Designer when asked about high-class &gt;large-scale successful commercial systems made with Delphi. Like all examples of this type, we find that the system is written in Delphi because it was written in Delphi ages ago. In fact, the developer states that the code actually began in Turbo Pascal! What would be much more interesting is an example of a significant project that someone chose to undertake with Delphi in the last few years, or at least in this century. There are quite a lot of multimillion line programs in use today written in COBOL, too, but that doesn't form a testimony as to the value of COBOL as a programming language today. 
I confess to having done this on many occations. It's like an itch that just begs to be scratched. I am currently reading [Fowler's Refactoring](http://refactoring.com/) and some of those patterns, like for instance replacing temporary variables with queries, obviously are nonoptimal from a hardcore performance perspective. But in the large perspective, micro or milliseconds here and there are just completely irrelevant in comparison to having more readable and maintainable code. In the end, and this is what I often experience as well, performance issues almost never stem from these suboptimal patterns in your code.
Admittedly with Delphis own generic collections, it is hard to argue for using TList&lt;string&gt; in place of TStringList, especially when the later is so engrained in the rtl/vcl as it is. However if you start using Spring4d with its extension methods for enumerables, you begin to see more benefits of using generic collections.
What is ugly about it? It is a generic list? It is very useful and clever under the right circumstances.
Maybe down the line, I'm a somewhat-new Delphi dev (rare, I know).
I mean the `&lt;` and `&gt;` characters. IMO functionality should be added through keywords instead.
Then your language keeps getting bigger and bigger (and your typing gets longer and longer). 
&gt;Then your language keeps getting bigger and bigger That's not related to keywords. Look at C++: it grows and grows because it tries to support new programming paradigms and practises. Keywords at least make these things easier to distinguish. &gt;(and your typing gets longer and longer) Not with IntelliSense (which is not useful when overloading symbols).
&gt;You couldn't find anything in all of the webinars, tutorials and video demos that &gt;have already been posted? Seriously? A serious and sophisticated piece of software on the scale of Digifort's? Heck no. And what a reality some of us are living in... the potential customer isn't going to hunt through webinars and tutorials. They want something that can be plopped down on their desk running on a laptop. At trade shows (including several that EMBT skipped) they set up a display with a MacBook air, laptop running Windows, laptop running a Linux distro, and an assortment of Android phones and 10" tablets, iPhone and iPad and have the same powerful demo running virtually synchronized on all the different systems at the same time. Xamarin, which debuted their mobile solution in 2011 too, has a large list of major enterprise customers on their front page right now and 54 (!!!) pages of real example applications. And our answer to all this is... it's up to the customer to hunt online themselves through webinars and tutorials and try to find something that shows off FireMonkey? Do you see the problem here? I've been in the position in the past of selling enterprises software. If I were trying to sell them FireMonkey, what would I do? Show them the Lego app Marco's kid designed? Meanwhile Digia sales reps or a firm using Qt begin setting up their huge cross-platform display. Why is it so hard for EMBT or their MVPs to see the huge problem here? Xamarin has 54 pages of case studies, we now have: one. If you're trying to sell to non fanboys, that's an insurmountable obstacle. &gt;Are there any cool QT videos that show multi-platform support using the same &gt;source, multi-tier or database support? That would be cool. Didn't I post links to several? Not only that, Qt is (in most instances) available as an LGPL2 license. You can go to Github, download the demo code and compile it yourself too if you wish. As posted before, this is one of the newest iterations of their "running on everything at once" demos... http://youtu.be/-SJh3Xy2QKI A pizza menu app or Lego pictures just doesn't compete. This was something EMBT shouldn't have deferred to 3rd parties to create. They should have brought a party interested in a serious Delphi mobile app design in when they were still in alpha stage to have had something to hit the ground running with. Unlike the desktop, there is no monopoly in cross-platform mobile development tools yet and gaining an early lead was still possible and very important. 
It's a shame there still needs to be talks at CodeRage and other places about DVCS and unit testing. Maybe because Borland et al never provided them with Delphi? 
But what if you are storing a list of integers? You'll notice none of his examples are handling strings. Or are you saying you would store integers as strings? That is not ideal to say the least.
"Borland et al never provided them" Delphi has had DUnit and Subversion integration for several releases.
That is snazzy. Is the source code identical for each platform, or are changes required? I still didn't see anything about built in multi-tier or database support. Very pretty, though. If you couldn't find anything that shows off Delphi and FireMonkey features in all of the other links that have been posted, you could try looking at the RAD Studio Application Showcase page: http://www.embarcadero.com/products/rad-studio/application-showcase
I've been writing Delphi for about 2 and a half years now and I have yet to come across a situation where I have to store a list of Integers. I'm not saying I won't come across but it's rare for me. I'm sure I'll use an array or maybe a TList.
Try Marco Cantu's example on parsing XML on Android: http://blog.marcocantu.com/blog/delphifeedsclient_android_ios.html Edit: Try using JSON instead. using the TJson generics class in delphi makes populating your class object really simple, makes your parsing a one-liner. https://developers.google.com/maps/documentation/geocoding/#JSON 
Thank you for the reply! This is where I'm at now. I have the XML and can parse it. I can't figure out what to do with the result. I can get to the html instructions, and can display them on the form. I also have the polyline points, start and end lat/lon, etc. I will look at the JSON results, 'cause who doesn't like one line parsing :) I need to figure out how to use this data to form a url string, or pass to a function call like: HTMLWindow2 := (WebBrowser1.Document as IHTMLDocument2).parentWindow; HTMLWindow2.execScript(Format('GotoLatLng(%s,%s)',[Latitude.Text,Longitude.Text]), 'JavaScript'); The code above doesn't work in my Firemonkey application. .Document doesn't seem to be a property/method/function/attribute of the TWebBrowser in a mobile project., and IHTMLDocument2 is part of MSHTML, which gives me an error if I try to use it in my mobile project. Definitely on the right track though, so thank you! 
TWebBrowser.Navigate() The below example details specifically google maps and the TWebBrowser Component :) http://sourceforge.net/p/radstudiodemos/code/HEAD/tree/branches/RadStudio_XE5_Update/MobileCodeSnippets/Delphi/Location/uMain.pas Edit: you may need to find out exactly what the parameters are for setting route locations, but its the same idea as setting the current position I believe (Http GET Url)
I'm not talking about integration. Delphi should have had unit testing as part of its standard library since the beginning or close to it. Unit testing isn't something optional for the community to provide. Then again, neither is documentation, logging, profiling, code coverage or stack traces either, but the community has had to fill in those holes as well, plus the work Spring4D is doing (and Mormot) to fill gaps in container functionality and web services. Subversion isn't a distributed version control system, it's an old-fashioned central control system which is my point. By the time we got any integration it was of something no one was choosing for new projects anymore and now Delphi users are behind while the rest of the world moved on to git and mercurial or another DVCS some time ago. Joel Spolsky explains the differences between a distributed VCS and Subversion here: http://hginit.com/00.html 
Thanks again. I was using the TWebBrowser.Navigate, but the example from theroadtodelphi seems much more feature packed, with the ability to generate scripts, then call them based on user interaction. Anyway, I need to move on, so I'm just going to navigate to a google maps url with saddr and daddr. It displays a bare bones map with a route highlighted. That will have to do for now. Thanks again! 
[**+Jim McKeeth**](https://plus.google.com/110876565870703831905) [_2014-02-01T00:07:51.101Z_](https://plus.google.com/110876565870703831905/posts/QmsvMmDEAZY) &gt; &gt;Video of Delphi app controlling the Parrot AR.Drone 2.0 quadcopter. Code coming soon . . . 
This is very intriguing!
Yep, the situation with Initialization/Finalization is well known to be bad. I don't know why they went that way. C++ style auto-generated constructors/destructors are just so much more logical, fast and customizable. And while we're at it, I vote for object system upgrade as usual. Modern TObject descendants are slow enough, records are clumsy enough.
The so-called EntityDAC LINQ language has only very little in common with the DotNet LINQ language. You don't have strong typing in the IDE: sounds like if all is checked at runtime (e.g. column names). Plain SQL sounds more convenient to me. What I like is the integration with Entity Developer, when working with an existing database: what is the generated code quality?
Define bad. We are talking about a few hundred milliseconds on ten million iterations here. I have a hard time seeing this being massive bottleneck in my application.
Bad as in "done in a very, very inefficient way". But if you need practical examples, what about Pentium 2 something something? Mobile phones? A certain app annotates text with auto-translation; 1 megabyte of text gives something like 500 000 expression hypotheses, each needs to be tested against the dictionary which contains 200 000 entries. With binary search that's about 18 comparisons initially + 10 linear comparisons on average. That's already 15 000 000 calls, which takes 500 ticks, half a second, on Core i7 just on one record begin i, j: integer; s: string; end; initialization/finalization on the stack. Of course, 99% of times you can live with current system. But it's not like they couldn't have been generating the initializers. I wonder why they made it this way, maybe they were trying to save memory.
Cutting cost probably has a part to play.
This looks more readable (and portable) than plain SQL. What's the point of having an ORM if you're going to be using SQL anyway?
The DUnit library has been bundled with Delphi for the same amount of time. And libraries exist for almost every single thing you're complaining about, whether they are part of the product, provided by third parties or available as open source projects. Almost none of your constant and exceedingly wordy complaints make any sense.
&gt;And libraries exist for almost every single thing you're complaining about, whether &gt;they are part of the product, provided by third parties or available as open source &gt;projects. I'll try one last time: those are three very, very different alternatives. Take logging: that's nice if there's a third party commercial option available. But what if I'm offering my source code to others? They'll need to have the same third party library or my code won't even compile for them. That means that logging is probably going to be left out. And what if component X uses logging product A and component Y uses logging product B and I own and want to use logging product C for my project? They're all going to be incompatible and in the best case I'll have scattered logs all over the place and no coherent picture. Even with 3rd party options, if there was a default logging unit they could inherit from its class and build on it and offer compatibility with other descendents. With the tool I'm using for a project right now, the documentation for the logging unit states: &gt;The key benefit of having the logging API provided by a standard library module is &gt;that all ... modules can participate in logging, so your application log can include &gt;your own messages integrated with messages from third-party modules. See? Serious software gets it. Let's face it: a lot more people don't use Delphi than do. Do you expect they'll be won over by a product that omits what they take for granted in .NET, Java, Ruby, Python, etc? Imagine buying a car in 2014 that has no radio, no windshield wipers, and heat that only works during January but you can upgrade to the "full version" of the heating unit for an additional $300. When you complain about such a crappy product offering, the salesman tells you you can go to an electronics store and buy a radio yourself, go to an auto parts store and find wipers, and you can dress in layers if you don't want to pay for the heat upgrade and then says your complaint "makes no sense". Real enterprise software today - Delphi's competition - caters to their customers like a five-start hotel. They provide everything they could be expected to need and try to anticipate anything that could make their experience better. Delphi has huge, gaping functionality holes that products like the .NET and JVM platforms don't have. A C# or Java programmer has bigint units. Rudy tells me Delphi doesn't need a bigint unit because some Russian guy published code for one on his blog in 2010 and "it probably still compiles". Do you seriously expect a professional developer to go hunting around Google pulling random, untested code (complex numerical code no less!) off of blog posts to patch up the missing functionality of Delphi? How about when they can get a better, more comprehensive framework for free from open source? I looked at using Delphi for the project I'm working on now. Simply put, out of the box it's completely uncompetitive with other offerings (even free ones). Profiling? Not for 64bit. But you can get the full version for another $640. Logging? A few hundred more dollars for the full version. Comprehensive math, statistics and machine learning libraries? I don't expect those in the box, but Delphi doesn't have bindings for the popular open source ones and thus the only alternative for the three, including source code, came to $1500 from a third party. ORM? Sorry, but you can have one for another $300 from TMS. Need to also run on JVM or Mono? No, but $600-$700 will get you Oxygene. Documentation? Sorry, no JavaDoc or ReStructuredText or LaTeX. But you can write in XML (!!!) and get the full Documentation Insight for $300 - and (unlike popular open source documentation programs, which don't support Delphi) that $300 *doesn't even give you the ability to directly output to PDF* - but you *can* export to CHM, a format both proprietary and dead. On and on... I arrived at a shopping list that did not achieve feature parity with the other solutions I was looking at but had a price tag of about $4000! My needs weren't even unusual but some couldn't even be met with 3rd parties. Please don't tell me that not being able to export HTML or PDF documentation or use a bigint - scroll down to the bottom of this article to see all the languages that include it "out of the box" - http://en.wikipedia.org/wiki/Bigint doesn't make any sense. What doesn't make sense is the idea that Delphi lives in some sort of vacuum where no other development tool exists and it doesn't have to adjust its offerings to meet or exceed its competitors'. You just can't price a tool at enterprise prices and offer no 2014 roadmap, no release date, missing documentation, and charge a four digit price but not offer full profiling, logging, unit testing, mocks, stack traces, documentation, HTML parsing (in 2014!) and a host of other features that are standard in Visual Studio, Eclipse/JVM, etc. 
You seem to be turning your ignorance of the options available to Delphi developers into another very long winded complain against Delphi. Again. Always happy to see you in these threads. :) 
Starts off a bit mild with just questions about the webinar, but actual Unit Testing questions begin about a 1/3 of the way into the log. The log will be updated later with the Q&amp;A from the evening broadcast.
&gt;You seem to be turning your ignorance of the options available to Delphi developers I seem to be utterly incapable of impressing upon you that the subject in question isn't about how Delphi users can patch all the gaps in functionality left by a substandard standard library. &gt;... into another very long winded complain against Delphi. Again. And I'm again faced with trolling from MVPs, TeamB'ers and EMBT employees who can't or won't defend or make the case for their product, e.g. Francois Pettite, Tim del Chiaro, Jim McKeeth, Rudy Vilius, and now you too. :-( Is there anyone left who isn't just pretending to like Delphi? P.S. It isn't "long-winded". It's that one side laboriously documents every fact that leads to their position and is careful to address every counterpoint by those they enter into discussion with, and the other side just replies "Is not!" because they don't really have any intention of engaging in debate because they don't really believe their position. :-( 
Your long winded complaint just demonstrates that you have no knowledge or interest in what's actually available either out of the box or from third parties. So I guess you're right; You leave me utterly unimpressed. And all of these people you accuse of "trolling" you when you write about how Delphi is dead in the Delphi forums - They are happy to help anyone asking even remotely legitimate questions.
Looks decently well written. What I would really like to see though is an automatic xml to pascal object mapper.
I know what's available out of the box and from third parties. Like Nick's alleged figures back in the CodeGear days that "proved" that Delphi.NET was just as popular as Delphi for Win32, you won't share this information you have with the rest of us. &gt;And all of these people you accuse of "trolling" you when you write about how &gt;Delphi is dead in the Delphi forums - They are happy to help anyone asking even &gt;remotely legitimate questions. Why should someone use Delphi is a legitimate question - it's the primary question without which there are no other Delphi questions. All you MVPers claim it's still the greatest thing in the world, etc. but you can't cite one reason why. Warren P says he doesn't have to prove it "because it's been proved a million times over." Jim McKeeth is supposed to be the Chief Evangelist but when point-blank asked to clarify his claims and cite some advantages over C#, he can't/won't specifically name any, not even when given a private e-mail address. EMBT's own CEO refused to cite one advantage of Delphi over VSC++ or C# in an interview. Francois wrote a piece in 2011 about why he loved Delphi and 2 of his 4 points were, I kid you not, "It has a compiler" and "It's not just a language; it's an IDE". It's trolling because these people *know* these points are true. They know EMBT is hanging on by a thread with an understaffed team of fresh-out-of-school Romanians (the cheapest developers off-shoring could buy). They know they're not competitive anymore. They know no enterprises use Delphi. They know there's just a few pockets left in the world where Delphi is taught. They know the books and the jobs are gone and it's just a few old-timers and one-man shops left. They know that if we assembled a group of people who've never used Delphi before they would fail to convince even one to drop their existing development tools and adopt Delphi. So, just like you did here, they completely refuse to address any of these concerns and ignore the questions in the hope they go away. Meanwhile, it's just users that are going away. I've already received private messages from people telling me they want to move away from Delphi and what I would recommend instead. These people see that an MVP has absolutely no answer to any of these *facts* that are presented and just says that there are solutions and/or all these points are wrong but they're just not going to bother addressing them apparently. You're not fooling anyone. 
When I asked PostgreSQL developers to name one thing their database product could do that no other database could, they named ten instead and had a nice PDF article written articulating them. When I ask Delphi MVPs to tell me what features the Delphi language or product has that no other tool has, I couldn't get an answer (let along a valid one) in over a year. Not even the Chief Evangelist or the CEO can answer it. And that's not trolling to continue to loudly proclaim that Delphi is a "secret weapon" (Warren Postma) or the like? 
These things are explained all the time. You should pay more attention.
&gt; Why should someone use Delphi is a legitimate question Embarcadero employees and Delphi users have no problem describing why they like the product and how they think it gives them an advantage. I've gone in to quite some detail on my perspective, and would be happy to spend time discussing it further with anyone who is legitimately curious. Another legitimate question is why someone would literally spend years trolling Delphi forums and blog posts just to write long winded and largely (intentionally?) incorrect condemnations of the product, company, employees and users. And then wonder why no one takes them seriously. I suppose that's two questions...
[**+Stijn Sanders**](https://plus.google.com/105759934778773466450) [_2014-02-18T07:54:38.165Z_](https://plus.google.com/105759934778773466450/posts/LRqD794jd7q) &gt; &gt;I'm sorry, but I _have_ to vent this: (Attention: what follows is a rant about something with programming in Delphi) &gt; &gt;What's up with this? &gt; &gt;[dcc32 Warning] W1050 WideChar reduced to byte char in set expressions. Consider using 'CharInSet' function in 'SysUtils' unit. &gt; &gt;CharInSet?! It contains Result:=C in CharSet, so it is actually just a tiny wrapper. But one that causes an extra jump, stack frame and return! Very wasteful of resources, and typically in places where I want iterations to go as fast as possible. &gt; &gt;TSysCharSet, by the way, is apparently fixed to a set of byte chars. So I suppose some implicit conversion takes place. I wonder why SysUtils' CharInSet doesn't get a warning then? Not even one like this: &gt; &gt;[dcc32 Warning] W1058 Implicit cast with potential data loss from 'WideChar' to 'Char' &gt; &gt;But more importantly, I think it goes against the grain of the language. With Pascal being firmly rooted in the academic and mathematic, it saddens me deeply that I can not describe a set of WideChar literals. They're ordinal constants like any other, or am I mistaken? &gt; &gt;In other words: if I take some old code where s is still just string, is it too much to expect s[i] in ['0'..'9'] to compile to something that checks if the 16-bit value falls between these two 16-bit limit values or not? As far as I know, it's easily done in both 32 and 64 bits machine code. (*1) &gt; &gt;Oh, and one more thing. All of this is darkly overshadowed by this: [http://utf8everywhere.org/](http://utf8everywhere.org/) with which I most strongly agree. Regretfully I do a lot of work on a platform that has decidedly chosen for the 16-bit-character way of handling text, so I have to work with it up to where I can decide to do it otherwise. In practice this means my programming is a mix of WideString and UTF8String complexed by the ennerving equivalence of the latter with AnsiString. &gt; &gt;*1: I know, I know, I should be using Unicode's IsDigit, but I have a lot of existing code for parsing script that uses a lot of while s[i] in [..] do inc(i), (*2) &gt; &gt;*2: I know, I know, I should be using a lexer/tokenizer/compiler-compiler. See also: a lot of existing code. &gt; &gt;*3: Skipping to the last paragraph are we? All right then: &gt; &gt;tl,dr: I strongly regret that "WideChar reduced to byte char in set expressions" 
Someone's posting these things from DelphiFeeds without reading them. The whole point of the post is that you can't use this highly desirable item with Delphi because its "native" compilation won't let it produce x86 Android code. 
The replay and white paper are now available. https://www.embarcadero.com/rad-in-action/delphi-unit-testing?cid=701G0000000WLhl
http://stackoverflow.com/questions/tagged/delphi
Delphi.about.com is a really great resource, especially articles by Zarko Gajic. www.delphibasics.co.uk is another great resource, I even check it once in a while. And please, post in /r/delphi! We love the traffic, it encourages discussion, and inspires posts for my DelphiTips twitter feed! 
Well, the top 16 threads have no comments. On the other hand you guys replied, so I'll give it a shot next time. I don't want to start a new thread just for this but I do have a question... what is the difference between doing draw operations on TImage.picture.bitmap.canvas and TImage.canvas? Is the latter just a shortcut to the former?
I suppose that's true. I catch them when I can, but there's so little activity on this subreddit that it gets hidden by the more popular ones :/ To your question though: I imagine that drawing on TImage.picture.bitmap.canvas writes to the image stored on the TImage, while TImage.canvas draws on the component that is drawing the image. To verify this, trying drawing TImage.canvas, then save the TImage.picture. Then draw on TImage.picture.bitmap.canvas, then save the TImage.picture. The first saved image should not contain the draw, while the 2nd would.
Holy cow, I had no idea there were two separate canvases. I'll definitely have to be more careful in my code. I wonder which one is the best to draw to.
Did you test it out? I'm actually interested in the result!
https://forums.embarcadero.com/
The 16 threads you mentioned, are mostly links for news and not a questions, so you will not see much comments about them, I highly recommended to repost your question as a new thread
The problem I have with these kinds of examples is that it is really simple to get something up and running, but once you start to do something more complex like using Word as a complete document engine with macros running and whatnot, it gets a lot harder to manage. It is fairly hard to get it to run stable without Word hanging your application when you run 100-200 documents in one batch. That is our experience at least.
Did you install with admin rights?
A lot of programs don't work right if all you do is copy files, since usually there are path and registry dependencies. It sounds like the %path% variable is not set, so the program can't find the files it needs. On my computer it includes the Delphi7\bin directory and Delphi7\Projects\Bpl. You would include the full path names in Control Panel &gt; System &gt; Advanced &gt; Environment Variables &gt; System Variables &gt; PATH. If you don't know what you're doing, you should use the Delphi installer since you can hose a lot of programs if you accidentally erase what's already in the path variable. Even then, I have no idea whether Delphi would run, since there could be stuff in the registry it's looking for.
so how do i unistall now? ...its basicly like copy pasted.... should i just delete it? 
It should work fine if you just install right on top of it... I don't think there's anything in a Delphi installation that would cause problems as long as it replaces all files. If your old files are under a \Windows.old path, Delphi isn't even going to install to that path anyway.
That's pretty much what I'm talking about. I'm just not willing to pay $$$$ for something so buggy. Even if it can be made to work eventually.
I talked directly with someone at Embarcadero about this, and he said stability was a huge focus for their next releases (in particular Delphi XE was the main topic of conversation here). I do not know if that was sales person speak, but he did seem sincere about it. Of course, in my own software stability is a huge focus, and I don't always pull it of to my standards either.
No kindle ebook?
My comments.. - **Features and Technologies Expected in 2014** * Complete C++ toolchain for Android *8/10 Toolchain stuff work approved.* * QPS (Quality, Performance, Stability) *11/10 PLEASE FIX ERROR INSIGHT OH GOD!!* * Advertising and Payments components for Android and iOS *7/10 I can see how it would be useful.* * DataSnap middleware enhancements (performance, REST mapping, architectural improvements) *10/10 So much work needed here! I could write a whole blog post on this. You have way too little control over routing and the way you map http requests to methods makes no sense. The verbs that you prepend to method names do not match common REST conventions. I could go on..* * Further enhanced single source multi-platform support with new multi-device visual designers and new, flexible user interface components *5/10 Meh.. I don't use any of this.* * Mobile Backend as a Service (MBaaS components, interfacing with some of the key providers, like Parse and Kinvey *1/10 No idea what this even means. Sounds like YADTF (yet another Delphi toy feature).* * Mobile and desktop applications interoperability *1/10 Uhm.. what?* * Android KitKat specific support *1/10 More toy features..* * Easy-to-use Windows taskbar buttons component for VCL applications *3/10 Again this sounds like a toy feature, but it's for Windows VCL, so I will rate it higher, because I am unfair like that.* * Improvements in VCL styles and in the support for VCL applications on Windows Intel tablets, with specific styles and sensor components *5/10 Windows on tablets is gaining a userbase albeit a small one.* * Direct support for wearable Android devices with particular form factors, particularly Google Glasses *-1/10 STOP WASTING TIME ON STUPID BS MARKETING TOY FEATURES!! WTF?!* * Apache HTTP server modules support for WebBroker and DataSnap, alongside with the current ISAPI IIS support *6/10 Focus on quality before features please. WebBroker and DataSnap are really clunky and buggy and need thorough house cleaning.* * Several run time library (RTL) improvements, implemented for all platforms and involving areas like XML processing, JSON processing, among others. *7/10 XML and JSON processing could be much better. The existing features are badly documented and very clunky. In general dusting up and streamlining stuff is good.* * FireDAC new drivers and enhancements to existing drivers, including support for newer database versions *8/10 Database access should always be a top priority.* * Support for future versions of Android and iOS, expected to be announced by Google and Apple during the current year. *8/10 If you commit to the platform you need to support it of course.* * Bluetooth support (for mobile devices) *8/10 Approved.* * A new release of the C++ compiler for Win32, with full support for the C++ 11 language specification *7/10 A lot of people have been asking for this.* - **Features and Technologies After 2014** * Support for future versions of Android and iOS *8/10 Obvious.* * Linux server support for DataSnap and WebBroker, including RTL and database access *6/10 Not really a big issue, although I can see some use for something like a DataSnap service with a postgresql backend on Debian.* * Wearable devices and HUDs (Head-up Displays), as they become available, including special-purpose Android form factors and APIs *0/10 Stupid toys. Please focus on the basics. There is a lot of stuff to do there. All these toy features are just a waste of time.* * Native and direct integration with new REST APIs, focused on different areas ranging from automated systems to NOSQL databases *6/10 I would have rated this higher if you didn't mention the NOSQL buzzword.* * Mac OS X 64bit compiler, toolchain, and libraries *7/10 Could be nice to have.* * Support for Windows 8 ARM/WinRT(for the Windows Phone and/or the Windows RT desktop) *6/10 Not really a priority. WinRT seems to be somewhat of a misstep by Microsoft.* * Enhancements and additions to BAAS and Cloud components *5/10 I am not going to rate this high, simply on the basis of many cloud services being US based and more and more concerns about security are coming to the forefront.* * Support for future version of desktop Windows that will be announced in 2014 *9/10 Will always be a corner stone feature of Delphi,* * A complete and simplified parallel computing library, to take advantage of modern multi-core CPUs more easily *4/10 We already have OTL. I would much prefer seeing more basic language features like extension methods being first class.* * Android for the Intel platform *3/10 Don't know.*
I believe the purpose of Nick's book was to address newer Delphi features that there hasn't been a book to address yet. For books focusing on Delphi 2010 and previous, I would suggest Marco Cantu's books: http://www.marcocantu.com/books/ 
sweet!
What advantage does your software have over something like DevExpress?
Hi, DevExpress components are much bigger, and more feature rich (most probably there are all needed features ever needed). But, NextGrid (and other controls in suite) are also packed with lot of features. It is snappier, and more easy to use. It may be used in larger apps as complex grid (there are dozens of column types, some quite interesting), or as small grid on other forms. It is written with passion and it is not over-bloated. NextSuite is also a lot cheaper (NextGrid is $59). But, we plan with v6 to move it in higher price range. There is also a NextGrid for .NET version released. Maybe this tutorial is nice place to start and see basic features: http://dn.bergsoft.net/nextgrid-quick-start.htm If you have any more questions, please ask me. Best regards
Oh okay, cool. My work uses Delphi so I'm always on the look for better components. I'll see about checking your guys' stuff out.
Thanks! Best regards
That it some nice code :) ORM will not be part of Spring4D for now but I have talked to Daniele Teti about using it in DORM in the future so both will then be compatible.
The NextGrid component is awesome. Almost every app our team develops uses it. When will XE5 support arrive?
Hi, Free version is only available for Delphi 6 and 7. But for registered users there is already support for XE5. It may be downloaded from users section. If you having problems downloading it, I may help - just contact me. Best regards
I think the book is a nice combination of Design Patterns, Clean Code, Working effectively with legacy code and the Delphi handbooks. So even if you are still using Delphi 7 there are things worth reading. However some things might not apply to you - but may want you to migrate your code to a newer version :)
Is this Firemonkey rebranded?
I'm sure it's shit rebranded
It seems so. Looks like it is RAD Studio with firemonkey rebranded as a SaaS application. They are really trying to push that subscription model for RAD Studio.
I can see what they're trying to do with this re-brand. I'm not sure if it will give them the fresh appeal to new users that they're hoping for.
Rad Studio has everything that AM has, with Windows binary support. AM is only FM with no Windows Binary support. AM does not have the word Delphi in it, because it is an evil word of the 90s, like Visual Basic. It is supposed to have C++ support, but it has always been a bastard of EmbT and languishes months or years behind Delphi focus. If you want to do mobile platform independent work, use existing, nearly free tools that ARE NOT Delphi. It is a dead language that has been static for over a decade and will not help you get a job.
Appmethod has Windows binary support, but only using FireMonkey and not the VCL.
Yes. I can hear taps being played loud and slow for the VCL, reminds me of OWL (old programmers).
What I find interesting is a comparison with Qt. Digia has already solved the Win8 and WinRT problem and support should be rolling out next month with Qt 5.3. They also already support Linux, QNX, Tizen and a few other embedded OSes. They also have C++ support which AppMethod doesn't look like it will get for several more months. While there was some open source work before, Digia proper didn't start working on mobile support until after EMBT and it looks like they've already gained the lead. They supposedly have about 10X the team size as the Delphi team. I think Qt is FM's real competition and I wonder if we'll get to see EMBT address AppMethod's merits vs. Qt soon. I believe they're pricing the product lower than Qt.
At least they've wised up that their pricing model was completely uncompetitive and unrealistic. That's a big plus. The potential minuses I feel are these: more resources will shift to FM and mobile upsetting existing, more lucrative full Delphi users; they're going to discover that their documentation, ecosystem, quality, transparency and IDE don't measure up to current standards. This will tie in with the other minus. 
Good point, I wonder if they'll produce a follow-up announcement for moving Delphi to a similar model?
Are you saying that the VCL is dead? 
I'm saying that VCL = Windows XP and FM = Windows 8. VCL was a framework inextricably tied to Windows. The future (and a lot of the present) is cross-platform. It makes no sense to support two platforms, the older one of which is a subset of the newer one. EMBT doesn't have the resources to do that even if it wanted to. The end game has to be for FireMonkey to be the new standard framework for Delphi. Otherwise, they're going to need to do everything twice (add support for Windows feature X in VCL and in FM). Just as Microsoft declared that all future enhancements to Windows will only be in the WinRT library, expect that almost all new work will be in FM. VCL will hang around just as Win32 will for old software. You'll see the same thing happen with FireDAC replacing dbExpress. Adding FireDAC to Pro for XE5 was step one on that path. 
Well, at least you stopped reflexively declaring things dead. I also think that FM will supplant the VCL eventually.
It would be cool if you could drive a grid control with generic collections/Spring collections, completely without TDataSet. Just an idea.
Hi, NextGrid is having a 2 dimensional array of TCell object. Every Cell include .AsString, .AsFloat etc. properties. But NextDBGrid which is a NextGrid descendant uses a TDataSet. So, there are 2 Grid controls, one DB and one not. Both are inherited from same ascendant. Best regards
Im learning how to create android and ios apps using XE5, am i gonna benifith most from the new or old book? :) Have some java for android background.
Use the Delphi built-in procedure *Read* with a character variable as parameter. Then compare that parameter to your choices and act accordingly.
http://pascal-programming.info/lesson1.php
Delphi starts out automatically in application development mode. I think you need to decide whether you'll be writing an application or a program.. which is set up slightly differently (the code inside would get data from a readln() function rather than a TEdit object).
Would you mind sharing with us which school or which country this is?
I'm not sure what you are asking exactly but you can do something like if MessageDlg('Are you purchasing Titanfall?',mtConfirmation,[mbYes,mbNo],0)=mrYes then begin ShowMessage('Great! I'm glad they didn't use the same annoying launcher that they had for BF3!'); end else begin ShowMessage('Maybe some day it will come out on Steam instead of Origin, so you could buy it there.'); end; You can also use the InputQuery function as a quick way to ask for something.
 const Msg1 = 'Are you purchasing Titanfall?'; Msg2 = 'Great! I'm glad they didn't use the same annoying launcher that they had for BF3!'; Msg3 = 'Maybe some day it will come out on Steam instead of Origin, so you could buy it there.'; var s : String; begin if (MessageDlg(Msg1, mtConfirmation, [mbYes,mbNo], 0) = mrYes) then s := Msg2; else s := Msg3; ShowMessage(s) end;
Looks interesting, but where is TDataSetObjectFactory declared? That seems to be what's doing all of the "magic" here...
True, it is a separate unit. I just meant it to more as an example of how we use Spring. Edit: My workplace is a bit skittish about releasing source code, but I will see what I can do about releasing a more thorough example.
Consider also changing what you have as "const" to "Resourcestring" to make it friendlier for future language translations.
In a real program I'd just load it at program start from a text file :)
Seems to me there are only two ways that could be implemented. Either you register dataset-to-object conversion functions by type with some central registry, or you use RTTI. Either one is fairly simple to set up; I was mostly wondering which way you picked. I have a RTTI dataset (de)serializer that I use in the TURBU project.
Wont the name be a little confusing with squid proxy? Why not extend existing open source IDE like Lazarus or any of the others? what does this even mean? "The Free Pascal compiler is on open-source compiler, but I do not wish to read over the licensing – compatibility/compilability under Free Pascalisdesirable and encouraged but not an overriding concern." .net and delphi 7 are odd choices IMO. eclipse+ideada+objectDB+Your features would save you a whole mess of time on at least a prototype?
[Addressing questions/comments in reverse-order.] &gt; .net and delphi 7 are odd choices IMO. Yes, that's true; though it's Delphi 2007 (not that that makes a lot of difference on the point). I already own D2007 [Professional, non-restricted], so there's $0 cost in obtaining it. (And this'll give me an excuse to break it out and do some work w/ it.) &gt; eclipse+ideada+objectDB+Your features would save you a whole mess of time on at least a prototype? One of the things I'm shooting for is a completely different way of handling the program source -- this will be useful in making tools which 'know' about Ada, later on -- instead of storing things as text, I want to store it in a DB as meaningful data. Thank you for the pointer to ObjectDB, I hadn't heard of it before; from the initial lookover in wikipedia it may be a better choice, I'll have to check it out in a bit (kinda sick today). &gt; what does this even mean? "The Free Pascal compiler is on open-source compiler, but I do not wish to read over the licensing – compatibility/compilability under Free Pascalisdesirable and encouraged but not an overriding concern." Oh, that should be 'an open source [...]'. Thank you for catching that; I've corrected the master document but will wait for a few significant changes to upload it [maybe a bit more emphasis on the tools, esp. WRT documentation/requirements integration]. What it means is that the actual Delphi codebase should be compilable by freepascal if that compatability would be easy to achieve, but neither necessary nor worth expending "a lot" of time/energy on. &gt; Why not extend existing open source IDE like Lazarus or any of the others? Already answered. &gt; Wont the name be a little confusing with squid proxy? Maybe; I had thought there would be enough of a difference in problem-domain that it wouldn't be confusing. As an example, in software, Paradox can refer to [a database](https://en.wikipedia.org/wiki/Paradox_%28database%29) or [a software publisher](https://en.wikipedia.org/wiki/Paradox_Interactive); I've never heard of someone confusing the two.
I'm kind of disappointed that they didn't use Lazarus/FPC 
&gt; I'm kind of disappointed that they didn't use Lazarus/FPC Completely understood; I did consider it, but I want to ensure that the binaries^1 are free and clear of *all* licensing issues, and that would mean delving into the *whole* license, which [in my estimation] would be a waste of time and energy when I have one that I *know* won't have licensing issues. The other issue is the planned toolset: the quality there of would be harmed should they be text-based like the current 'marketplace' of free tools are. As an example, consider versioning: [1] Procedure Swap( A, B : in out Integer ) is [2] Temp : Integer := A; [3] begin [4] A:= B; [5] B:= Temp; [6] end Swap; and [1] Procedure Swap( X, Y : in out Integer ) is [2] Temp : Integer := X; [3] begin [4] X:= Y; [5] Y:= Temp; [6] end Swap; or [1] Procedure Swap( A, B : in out Float ) is [2] Temp : Float := A; [3] begin [4] A:= B; [5] B:= Temp; [6] end Swap; If your version-control is text-based it'll say lines 1,2,4,5 changed (or 1 &amp; 2 in the second case) w/ the change recorded [perhaps as substring data]; whereas if the source-code is stored in a meaningful medium (e.g. database-object) the first case can be covered by something like [SQL-psudeocode] `update parameters of Swap from (A,B) to (X,Y)` (or, in the second case, `update type of parameters of Swap from (Integer) to (Float)` &amp; `update type of Swap.Temp from (Integer) to (Float)`). Another advantage to storing the source as meaningful-data is that "styles" become something under the purview of viewers^2 rather than an attribute of the source itself. ^1 - This is why we'll attempt to keep the codebase compilable w/ freepascal, but not as an overriding concern; this way people who want to compile from the codebase [w/ freepascal] will be able to do so, but project provided/generated binaries/installers can be guaranteed free of licensing issues. 2^ - The trivial example being things like tabs vs spaces; changing the indentation of one to the other is a non-meaningful change which will only add noise to your repository. The same thing can be observed in C-shops w/ the curly brace on the same line or on the next, or whether they must be used w/ single statement conditional statements; some of those arguments can get spectacular despite being about non-meaningful changes.
&gt; I am surprised by your fear of licensing issues. What are they specifically? GNU tools used to make stuff does not preclude using the output as a comercial product, IE using GCC to compile a binary and shipping only that is not a violation. Part of it is the weirdness surrounding GNAT's licensing, there're some oddities about it because of the RTL. The other part stems from having been poking around laws for a bit, "barracks lawyering" you could say and concerns over how the licensing can be used to screw things over. (There was an interesting comment on the "[Don't Ask Me About It License](http://www.reddit.com/r/programming/comments/20qp4f/the_dont_ask_me_about_it_license/)" license that popped up a while back to the effect that the only free software source-code commercial pa lot of] companies will touch is MIT and [IIRC] Apache.) It would be nice if there was an open-source Ada RTL, but I haven't heard anything of the sort. &gt; Edit: Also have you looked at GIT? It's a profoundly smarter differ than what I've encountered before, seems like it might be decent for providing versioning. Git is my main go-to for versioning on my personal projects; you're right that the diff seems to be much smarter than most others... but I think relying on text-handling is not the way to go: programs have inherent rules, structures and meanings -- IMO it'd be better to record something like (`Rename E_mail.valid to Email.Is_Valid` [or a SQL-update] rather than a series of text-diffs.) &gt; Also another benefit of Lazarus is that it compiles to linux,windows,mac natively, so with some care it should require a minimum of fuss to get native binaries for each platform. :) Granted; it's something I really wanted to do... but I don't trust the licenses; I'd like to keep the source-code itself compatible, but I don't think it's worth a whole lot of blood/sweat/tears. &gt; I'm happy to see people using pascal, I'm going to be doing a presentation on FPC/Lazarus at an upcoming conference to try and spread the word about the modern pascal. Awesome / I wholeheartedly agree. I'd like to see an uptick in modern pascal usage, I'd like to see Ada used even more -- I'm rather disgusted with the level of quality that's acceptable being so low; part of which is there's a lot of programmers out there that don't stop to think things through, my simple RL example would be a coworker who said "why'd you do that? just use string-split. Done and done." when I told him about having to write a CSV importation function [in PHP, on a dataset that contained commas]. *sigh*
Im new to delphi trying to learn ios/android. Using wmware fusion on my mac with win8, u need some start menu program for win8 but i think i would go win7 cuz this metroui shit and not being admin on your own computer is really annoying sometimes. I dont know prices on like wmware and dont have something to compare with but its working really nice for me, rad studio compiling time is kinda long but im just compiling to windows most of the time when i change something that dont need testing on the phone.
(Note: Reddit is *not* the best place for asking Delphi questions - there's almost noone here. Try Google+ (eg https://plus.google.com/102570002721714768273/posts and https://plus.google.com/u/0/communities/103113685381486591754 ), Stack Overflow, and forums.embarcadero.com.) I run Delphi under Win7 with VMWare Fusion - I've used Fusion since version 3, it's up to v6 or something now. It works very nicely. Make sure you have a fairly modern / powerful Mac - eg a Macbook Pro from the past couple of years - so the hardware has virtualization instructions. Also have enough RAM to allocate a reasonable amount to the VM; I have 8GB, and split it 4/4 between OSX and the VM. There are plenty more answers about running Delphi on a Mac if you google, especially if you search the Delphi forums. Good luck and have fun!
Go to the G+ group. The emulators cant be run in a vm with any speed for fmx. You need to run it on the host and enable remote debugging. Dont expect too mich for EmbT and Delphi. The VCL is static and practicay unchanged since XE. Everything is FMX, which is quite buggy. Also it wont get you a job, nobody uses Delphi (or AppMethod), concentrate on more mainstream language and cross platform tools for a career growth.
VMWare works like a champ. I had some trouble with VirtualBox on my MacBook Pro because of the Control-Delete key mapping (I couldn't find a combination that worked), but I was over a VPN, and using Remote Desktop to connect to the Windows machine running VirtualBox so your mileage may vary. I do not have the same issue from my Mac Pro with the full keyboard. I use that combo (vpn, remote desktop, virtualbox) at least twice a week. Connecting to the Mac from VMWare is straightforward, so the iOS builds won't pose a problem, provided you have enough memory installed. Android debug may be an issue (the emulator is pretty slow even without being in a VM) but there are some interesting instructions on doing wireless android debugging over TCP/IP [here](http://delphi.org/2013/10/wireless-android-debugging-with-delphi-xe5/) /u/vintagedave is on the money for Reddit and Delphi. There are 5 users on this sub now, and I think that's the most I've seen in the last few months. /u/boulderdrop is more tactful about his impressions of the product than I tend to be. I have found cross platform development with XE5 to be more frustrating than herding cats. Buggy is what you pull with a horse, the Embarcadero IDE is bad enough to send seasoned exterminators running away in blind panic. I spend a fair amount of time coding {if iOS} and {if Android} blocks to accommodate FMX controls that don't work the same across platforms. I turned off the "intellisense" function in the IDE because it just flat out lied to me most of the time, putting red squigglies under perfectly valid code, and not putting squigglies under bad code. Bah, I could go on, but this is already wall of text rant. I apologize. I'd delete it, but I spent too much time typing it up. I hope you can forgive me. oh, P.S. for /u/xoxoleah Take a look at Xamarin. Even if it's as buggy as Delphi, it's c# and those skills should transfer. Thanks again. Sorry for my bad attitude. :) 
I use VMWare on my 2012 Retina MacBook Pro, works like a charm. I use Rad Studio Pro so have both Delphi and C++ installed. 
Thanks vintagedave, I appreciate the great advice. I'll join those Google groups now. I'll also go download VMWare Fusion. Much appreciated.
Thanks; I think you're definitely right with the emulators not running well in a VM. I'm not finding the Android emulator very responsive on my Surface Pro 2 tablet which has 8Gb RAM as it is. I have found it quite exciting to open up some Delphi projects I have had lying around since 2001 and finding they compile and run perfectly. With respect to a job, I'm not doing this for career options but because I believe it will simplify mobile app development, given the single tool and code-base for Android and iOS, and given I have prior Delphi experience (as opposed to Objective C of which I know nothing.)
Thanks for the help; sounds like VMWare definitely is the go, though I'm certainly finding the Android emulator runs terrible even running natively (ie not in a VM) on my Surface Pro 2. What you say about the cross-platform development is a concern though as that's what got me excited about getting back into Delphi.
You're definitely right about the Android emulator. It's painfully slow and just keeps saying 'not responding'. I've now hooked up my Nexus 7 tablet.
This hotfix is to be applied on MacOS and updates the PAServer to work with XCode 5.1 and the latest iOS simulator.
They started a new payment plan push, where developers are on a recurring payment and getting multiple updates a year. It started kicking in pretty full in 2013, and I'm sort of happy with it so far. We'll see how 2014 goes. Here's their 2014 roadmap: http://edn.embarcadero.com/article/43677
Thanks! It's great to see it's still being developed. How is the Delphi Job Market?
Very good, thanks!
I am a happy Delphi XE5 user. You would know it was being sold if you just googled. Do you have a real question?
My question wasn't directly about it being sold or not, but the overall state of Delphi in general. By googling it, I'm going to see more reviews &amp; advertisements. I came here to get the view from current developers I appreciate your positive addition to this discussion. 
No one uses it anymore. It's all .NET.
Did you use Delphi 8 in production? I did, but I haven't heard of many others. You've probably heard that Delphi ran in to a rough patch right around the time you left. I attribute a lot of that to misguided priorities on the part of Borland. Things began to recover with the release of Delphi 2007 and the sale of the developer tools division (CodeGear) to Embarcadero. There are still occasional mis-steps, but for the past several years, Delphi has been doing well both technically and financially.
Yes, Delphi 8 was a mess, but Delphi for .Net was an excellent bridge between native and managed applications. A role better served by Oxygene, these days. Embarcadero published some of the highlights that have been added to Delphi over the years. It doesn't list everything, but it does hit a lot of the big ticket items. http://www.slideshare.net/embarcaderotechnet/delphi-innovations-from-delphi-1-through-delphi-xe5
Non existent. Do a search, you will find a couple for the entire US.
&gt; Delphi on your resume is not going to carry any weight This was true when I left the market as well.
You are smarter than me. I have golden handcuffs, but trying to work something out of it. It really is too bad, walk the clock back 10 years and it really was great. They got a huge splash for making desktop development doable. They know those days are gone and trying with a new paradigm of mobile. All fine and good, but it doesn't help to support their desktop customers... especially when they create a new product, refuse to use the Delphi moniker and bust code portability... you know they got rid of strings. You can no longer say "s:=s+' and your little dog too' ". The single greatest thing and unique feature of Pascal was strong handling.
I wasn't aware they got rid of strings... that just doesn't seem natural.
This question pops up every month. Delphi is still alive, being upgraded slowly, though somewhat inconsistently and maybe with some bad design decisions. It compiles for x86, x64, OSX, Android, iPhone. It's popularity is slowly declining, language of choice for quick UI now is .NET/C#. There are other Delphi-like languages, notably Oxygene which compiles for .NET/iPhone/Android, but they are still not as popular afaik. Free Pascal implements most of Delphi syntax, though Delphi innovates faster than they can catch up.
Every month? Sorry about asking then... I went back several pages on this sub and didn't see it being asked. Thanks for your response.
That is completely false. String handling works completely the same as it has always done on both mobile and desktop platforms. String addition is still a feature on both platforms and will continue to be so. You are probably getting some of the talk there as been about immutable strings mixed up with some false assumptions. Even if strings are immutable you can still add them together like Delphi does, it just creates a new third immutable string which is the concatenation of the two strings. However strings are not immutable yet on either platform as far as I know, so this is irrelevant.
It isn't true, see my other reply.
Ah thanks, I appreciate that.
That's just a comment from some random individual. Both ways are allowed and will continue to be allowed. (Edit: There may be performance differences between the methods, which may even vary between platforms.) He kind of makes a false assumption, I think, based off of comparing the performance of the two methods on the windows implementation, where no doubt the straight forward addition method is a lot faster than the stringbuilder implementation.
??? It's C, then Java, Objective C, C++, and then only C#. Delphi is just under Ruby, at 15th position, not bad for a proprietary language. If you add the "pascal" language (why did they split the two?), you get 0.881+0.682=1.563 it goes up to the 11th place, above Transact-SQL, Perl or Ruby! http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html BTW .NET will get back "native" AFAIK... See http://blogs.msdn.com/b/dotnet/archive/2014/04/02/announcing-net-native-preview.aspx I appreciate being right this time, and stick to Delphi. Faster than alternative, when properly used.... http://robertocschneiders.wordpress.com/2013/01/09/datasnap-analysis-based-on-speed-stability-tests-part-2/ :)
ComboBox1.Items.LoadFromFile('Example.txt');
Thanks
Ever seen the "docwiki" site or delphi basics website?
Nice, Google Glass support.
&gt; they should focus on fixing their IDE and improving the core infrastructure, like the compiler and the language itself. They're doing that, too. http://edn.embarcadero.com/article/43754
There must be some kind of grace window. I'd badger the sales guys. Failing that, there's always the Recharge program.
Feedback is always welcome on our forum, as usual! http://synopse.info/forum/viewtopic.php?id=1707
Well, pretty much I choose stuff from combobox, write info into the edits and press "Add" and I want the added info to appear on the listbox. I think I need to make it so `Add` creates/rewrites the file adding the new info and the file stuff must be displayed on listbox or any other listing object. 
Didn't do the store part yet, but I've been working with .txt files only so it should be txt
Here's a [link](http://www.delphibasics.co.uk/RTL.asp?Name=Append) to some Delphi code that appends to a text file. I don't think you want to re-read the text file each time you add an entry. Just append the added entry to the text file, and then add it to the list box, or list view, or whatever. kind of like this: //add item to listview lItem := lvTaskList.Items.Add; lItem.Text := Village + ':' + population; Append(myFile); WriteLn(myFile, 'Village + ':' + population'); CloseFile(myFile); This will keep your text file and list updated, without having to read and write the whole file for each update.
Thanks, will try it, however, how to make listbox somehow have colums or something. In one column one, in another column another, etc. And at the last big column this big info column which could be read when highlighting/choosing
This sounds like it would be quite hard. What you are describing sounds a lot more like a dbgrid control. Such a control needs to be attached to some kind of database component for it to work.
My teacher says that I need to use record for the records array ( is that how it's called in english), could you somehow do a code for that?
The Delphi Detours Library is a library allowing you to hook delphi and windows API functions .It provides an easy way to insert and remove hook . Features : Support x86 and x64 architecture . Supported Delphi 7/2005-2010/XE-XE6 . Fully thread-safe code hooking and unhooking . 64 bit address is supported . The library does not use any external library . Allow calling the original function via Trampoline function. The library can insert and remove the hook at any time . The library contains InstDecode library , that allow to you to decode asm instructions (x86 &amp; x64). 
Some more details would help. What part is giving you trouble, and what have you tried? Getting the strings from a TStringGrid is simple enough. And once you decide how you wan them saved, writing those strings to a file is straight forward. You can even cheat a little by using a StringList and calling SaveToFile.
Pretty much what I want to do now is: 1. I write in edits, edit.text appears in specific row,column. - Done 2. The whole stringgrid's boxes - record into the txt file 3. When I write down the name of specific box` string, the whole info appears and loads from the txt file. 4. I can configure it and in rewrites the existing line in the .txt file Sorry if I am hard to understand, hard to speak what I want in another language in programming 
There is no reference to TForm1 in the code I posted. These are stand alone procedures. Ideally, these should be in a separate unit, but for testing purposes, you can simply paste them at the top of your implementation section.
Wait, so what do I need to do exactly? Sorry, I am bad at it.
I don't understand what part you don't understand. Just put these procedures in your code.
Oh, I made it work without errors, but now it doesn't do what it should. File is empty.
Try debugging the procedure. Are you getting the correct information from the StringGrid? Are you sure you're saving the file where you think you are? How are you checking the file?
I put it in Project directory ~&gt; Win32 ~&gt; Debug and just say 'filename.txt'
The documentation is also available as pdf, since it may be more convenient and readable - see http://blog.synopse.info/public/Documents/SynMustache.pdf
These procedures work as expected here. I'm not sure how else to help you. What happens when you debug the code?
This is homework? I feel a little bad for pasting code, then. It's up to you, but instead of giving up and moving on to something else, you'll probably learn more by solving this.
I am going to programming school. It's like additional school, but programming, which I attend every saturday. It's my first year and we are working with Delphi. It's my final project. Thing is, I came here to see if I am fit to be a programmer and if I enjoy it. As you see, I suck at it. I won't go to the second course because as you see, I can't really solve things by myself. I got really depressed in the past week for this project as I am working for that project and 3 days in a row I did NOTHING sitting in front of the computer all day. If it worked, you shouldn't feel bad. It would've gave me a morale boost and it won't change anything in my life, tho the programming school was for the better. Imagine how fucked I would be if I actually tried to graduate from IT without knowing how I suck at programming.
Thank you. I found my problem that Ifs/elses doesn't work and it always shows the last option. I say if * then * if * then * else * and it alwys shows the else one.
 procedure TForm1.Button1Click(Sender: TObject); var d : real; // diskriminantas a, b, c : real; // ax + bx^2 + c x1, x2, x11, x22 : real; begin a := StrToFloat(Edit1.Text); b := StrToFloat(Edit2.Text); c := StrToFloat(Edit3.Text); d := (b*b) + (4*a*c); if d &lt; 0 then // Nebus sprendinių Memo1.Lines.Add('Nėra sprendinių') // no solutions else if d = 0 then // 1 Sprendinys // 1 solution x1 := -(b/2*a); Memo1.Lines.Add('Sprendinys:' + FloatToStr(x1)); else x11 := (-b + sqrt(D))/2*a; // 2 sprendiniai // 2 solutions x22 := (-b - sqrt(D))/2*a; Memo1.Lines.Add('Pirmasis sprendinys:' + FloatToStr(x1)); // first solution Memo1.Lines.Add('Antrasis sprendinys:' + FloatToStr(x2)); // second solution That's my code. At first it always went to the last option, now it says "No ; allowed before ELSE" but if I delete that semicolon, it says "END expected but ELSE found"
You have too many lines before your last "else". If you have more than one line in an if statement, you need to surround it with begin/end. Otherwise, the second line gets treated like a separate statement. Note that your x22 assignment at the bottom happens every single time. If you intended it to be included in the else condition above, you need to use another begin/end block. procedure TForm1.Button1Click(Sender: TObject); var d: real; // diskriminantas a, b, c: real; // ax + bx^2 + c x1, x2, x11, x22: real; begin a := StrToFloat(Edit1.Text); b := StrToFloat(Edit2.Text); c := StrToFloat(Edit3.Text); d := (b * b) + (4 * a * c); if d &lt; 0 then // Nebus sprendinių Memo1.Lines.Add('Nėra sprendinių') // no solutions else if d = 0 then // 1 Sprendinys // 1 solution begin x1 := -(b / 2 * a); Memo1.Lines.Add('Sprendinys:' + FloatToStr(x1)); end else x11 := (-b + sqrt(d)) / 2 * a; // 2 sprendiniai // 2 solutions x22 := (-b - sqrt(d)) / 2 * a; Memo1.Lines.Add('Pirmasis sprendinys:' + FloatToStr(x1)); // first solution Memo1.Lines.Add('Antrasis sprendinys:' + FloatToStr(x2)); // second solution end; 
I get this answer in the memo1: Pirmasis sprendinys:1.87199087530602E261 Antrasis sprendinys:1.13964422940379E-316 when I type in a = 10 b = 10 and c = 10. Why are there even letter E in there?
The E is scientific notation. The first number is really big, and the second number is really small. The real problem is that you are showing X1 and X2, but you don't assign a value to either of these in your code, so they just contain random junk. Your code isn't doing what you think it does.
no coupon?
Sorry, I am not affiliated with the course, so I am unaware of any related coupons. I just came across the course and thought it might be of benefit here.
Android and iOS development have been available since XE5 (XE6 is the most recent version).
damnit! thanks for the link :)
Without even looking at the math, the simple answer is that you aren't assigning anything to the variables x1 and y1, so when you display them, you're getting undefined results. If you walk through the code with a debugger, you'll see what I mean. The longer answer is that I think you're losing sight of the objective. What is it you're trying to accomplish, and how would you do it without software? Only then should you try to do it in code. So, write out the problem first, including how you will know whether it's working properly.
What version of Delphi are you using? Try the tips outlined on this page: http://delphi.about.com/od/delphitips2008/qt/format_richedit.htm 
90s called, they want their language back
Xe3
Figured it out. I was putting the app name instead of the the actual certificate name in the Developer Certificate field. I am now getting *unable to locate devicesupport directory matched with connected device info. Please check xcode installation path and run Xcode organizer* Found [this](http://docwiki.embarcadero.com/RADStudio/XE5/en/Release_Notes_for_XE5) so will continue to play around.
Sad. EMBT continues to drop the ball in supporting legacy apps, further alienating the market that supports them as they chase everyone else to the mobile market. What they don't understand is that business facing software is the only place money exists for software. Mobile development is the new web, at least until html5, and the market is free apps to allow access to free services. Only apps in the "top 10" make enough money to live in, everyone else did it to learn a new skill (sadly Pascal is not a hire able skill).
There aren't many Delphi developers on reddit. Try posting on: * [StackOverflow Delphi](http://stackoverflow.com/questions/tagged/delphi) * [Delphi Developers on Google+](https://plus.google.com/communities/103113685381486591754) * The [Embarcadero Delphi forum](https://forums.embarcadero.com/category.jspa?categoryID=12) As a side note, the height of the unresponsive area looks exactly the height of the bar at the top of the screen. Not sure if noting that helps, but it may be to do with position calculations of controls after the rotation, especially if you have any custom layout code.
The Google+ group is very active and would be the best place to start outside of the EMBT forums.
What’s new in pas4ios Version 1.36 New Features/Changes · New Lazarus and Free Pascal Version Intern 3.2 · TpmNSArray upgraded Easy way to get an object Old Version aObject:=aArray.ObjectAtIndex(i); New Version aObject:=aArray[i]; · TpmUIView upgraded Easy way to get a view from a Nib file. Old Version aView:= TpmUIView(View.ViewWithTagAll(100)); · New Version aView:= TpmUIView(View[100]); · Class TpmPFPush (Parse SDK) completed A class which defines a push notification that can be sent from a client device. Bug fixes · Warning when compiling a project with Xcode You've implemented -[&lt;UIApplicationDelegate&gt; application:performFetchWithCompletionHandler:], but you still need to add "fetch" to the list of your supported UIBackgroundModes in your Info.plist. · Class TpmUIPickerview not work with IOS 6.1 Not work on real device. · Class TpmUICollectionView memory leak on IOS 6.1
Microsoft wants to promote C# and the .Net platform for mobile development. The biggest problems with .Net on mobile platforms are deployment complexity and big storage footprint of applications. To fix this they are developing an option to compile the app and the toolchain natively. This is another nail in the coffin for Delphi, because you get all the benefits of native compilation together with the fantastic .Net libraries, for mobile platforms.
Looks good. Thanks!
How did I end up executing that line of code considering the condition of the if-statement and the values of the variables? Also, I would like to clarify that I only added the condition and the line the breakpoint is on for debugging purposes, the code doesn't normally just assign NewValue twice.
That would explain it, but both FValue and NewValue are integers. For the record, I restarted Delphi, removed the code, cleaned and built the project, then rewrote the code and rebuilt. It worked after that.
Interesting. 
Perhaps the optimizer has compiled the two lines to the same assembly code, and the debugger is showing it at this location? Does it actually execute the first line?
Interesting suggestion. It did call the decodeIntegerString function, however, and also stepped past the if separately 
What version of Delphi
2007
Okay, that doesn't make sense then. The only way I can think to make sense of this would be to look at the assembly language instructions the compiler generated. Also, when I write this code, it runs correctly for me.
I've had this happen multiple times before. Sometimes changing seemingly unrelated parts of the code around it will fix it, and sometimes just splitting up the if statement is required. Delphi has a really shitty compiler. At least Delphi 2007 does.
I had my breakpoints not work or if they did, it would stop 2 lines off from the correct line. It turned out I had 2 lines in my code that ended with a CR only, not a CRLF pair. I used an external editor to find and fix that and the debugger worked again.
I simply think - because it's one statement. I never tapped into such a trap but I personally work with boolean variables and evaluate then. Most of the time I use begin ... end anyway. Use ((expr) and/or (expr)). Pascal boolean expressions historically have been designed using a grammar described in fashion of regular expressions.
Nope, local variable in the procedure 
Open your solution directory, search for *.dcu, delete everything (I hope you don't have dcu-only includes lol). Restart Delphi. "Rebuild all". This can also be a sign of stack corruption earlier in the app. Look at other local variables, are they all defined at this point or do some look strange, corrupted? This for example can happen if you call a cdecl function as stdcall earier on, this shifts stack pointer and your app checks the wrong memory for FValue/NewValue (while Delphi, being a separate process, still knows where really FValue/NewValue is).
The only time I've seen inconsistent behaviour like this is when parts of a project are compiled with one set of options and the rest are compiled with another. This was always resolved with a full build. I wonder if this would have done the trick for you without removing and recreating the method.
I work on a team with a developer that mostly uses procedural style pascal and because he is of a certain age he feels it isn't worth it trying to learn new coding styles. It is actually rather depressing, since it feels like we are continually painting ourselves into a corner, technologically. What do you do in this case? Find a new job? That certainly feels tempting a lot of the time.
Don't forget, there's no value in freeing memory on shutdown. From [Raymond Chen](http://blogs.msdn.com/b/oldnewthing/archive/2012/01/05/10253268.aspx): &gt; if the process is exiting, then you should just return without doing anything. &gt; No, really. &gt; Don't worry about freeing memory; it will all go away when the process address space is destroyed. Don't worry about closing handles; handles are closed automatically when the process handle table is destroyed. Don't try to call into other DLLs, because those other DLLs may already have received their DLL_PROCESS_DETACH notifications, in which case they may behave erratically in the same way that a [Delphi](http://blogs.msdn.com/b/oldnewthing/archive/2011/05/23/10167156.aspx#10167462) object behaves erratically if you try to use it after its destructor has run. Of *course*, if you leaking ever increasing amounts of memory during runtime, then you **need** to fix that. But if you have a 150 MB chunk of memory that you use during runtime (e.g. a spell-checker database, a facial recognition data structure, a HAL artifician neural network), you don't *need* to free it on shutdown. Having said that, i *do* free those things on shutdown (even though it wastes the user's time), because i don't want false-positives on FastMM. I *would* register the [BK-tree spell-checker dictionary](http://nullwords.wordpress.com/2013/03/13/the-bk-tree-a-data-structure-for-spell-checking/) as a known memory leak with FastMM: //FreeAndNil(FBKTree); FastMM4.RegisterExpectedMemoryLeak(FBKTree); Except that it doesn't work for a complicated, nested, tree structure. tl;dr: Not freeing memory is not always a memory leak.
&gt;Isn't it that we, Delphi users, claimed since decades? No, Delphi users were claiming that everything else was slow or broken. MS' quote doesn't say there is anything wrong with .NET performance now; it's merely providing an additional option. I could use the same logic and say that Delphi.NET was Borland saying there was something wrong with native code, which would be just as absurd. &gt;I would not trust the Embarcadero marketers by all means, but at least they were &gt;ahead of time and pushing a right argument here... They weren't ahead of anything. They were simply pushing the same technology they've had since the 1980's because that's all they had. This of course doesn't address the downsides, including loss of run-anywhere ability (which is why it's an option and not the default). 
That's what I did, but since I was in a position that enabled me to innovate, I suggested to be a consultant for things like migrations or new technologies whenever they needed, which is working out fine for both me and the company. 
As this article: http://www.fmxexpress.com/build-an-mp3-player-with-delphi-xe5-and-xe6-firemonkey-for-android-and-ios/ it should work on both OSes.
&gt; And you have to know also that even if we are in a scenario with many more writes than 3% of writes and my scalable LW_RWLockX don't scale globally in the timing you have to know that LW_RWLockX will still be useful , cause even if it doen't scale globally in the timing , you have to understand that if from the time t1 to the time t2 there is writes and reads and from the time t2 to time t3 there is only reads, so even if the time from t1 to t2 will add more to the overall time cause there is writes threads, I'm sorry for being that guy who judges a book by its cover, but this reads exactly like some diplomas I have read. "This works perfectly in 1% of cases (actually I haven't tested that but theoretically it should, and I tested some other cases where it didn't work but that's because those were those cases where it shouldn't have worked), and you have to understand that even when this doesn't work it doesn't really make things worse so you can say that it improves the results in all cases (actually it made things worse in my tests but that's just because I cut some corners and if I did everything properly it wouldn't have). So anyway, please? Let me pass?"
This reminds me of Joe Duffy's [improved reader-writer lock](http://joeduffyblog.com/2009/02/20/a-more-scalable-readerwriter-lock-and-a-bit-less-harsh-consideration-of-the-idea/). The lock is meant to be extraordinarily good for frequent reads. - Create an array of `arrayLen := 16 * NumberOfProcessors` - each array entry is a structure with an `int`, padded to `128 bytes` so that it fits in a cache line - a thread that wants to take a read lock interlocked increments one of the array entries - the array entry it uses is a standard hash list bucket algorithm: `threadID mod arrayLen` There's also a separate `writer` flag. Before a reader (or other writer) can take it read, it needs for `writer` to be zero: - for the first 12 spins, do a spinloop 2^spinCount iterations (e.g. 2, 4, 8, 16, 32, ... 4096) - after 12 spins, call `SwitchToThread()` to allow another thread on our CPU to become scheduled - after 32 spins, call `Sleep(0)` to give up the remainder of our timeslice Paste of our code. We also have a `TSlimReaderWriterLock`, which wraps Windows' native `SRWLock`. { From Joe Duffy's "A more scalable reader/writer lock" It favors shared reading speed over slightly slower write taking (the writer has to check an array of reader flags) The improvement comes from keeping a large array of reader flags; each one on its own cache line. This way you avoid false sharing caused by cache lines becoming invalid. } TReadEntry = record //128-bytes total = 2*64 bytes = 1 cache line Taken: Integer; Padding: array[0..123] of Byte; //to keep each ReadEntry on its own cache line end; TSpinLockPerProcReaderWriterLock = class(TInterfacedObject, IReaderWriterLock) private FWriter: Integer; //1 if there is any writer (or writer waiting for readers to release) FReaders: array of TReadEntry; //array of integers to count readers; aligned so one integer per cache line FIsWindowsXPOrHigher: Boolean; function ReadLockIndex: Integer; //converts ThreadID into index into Readers table function NumberProcessors: Integer; procedure SpinOnce(var spin: Integer); //does a spinwait public constructor Create; { IReaderWriterLock } procedure BeginRead; procedure EndRead; procedure BeginWrite; procedure EndWrite; end; { TSpinLockPerProcReaderWriterLock } constructor TSpinLockPerProcReaderWriterLock.Create; begin inherited; //SwitchToThread only exists on Windows XP or higher FIsWindowsXPOrHigher := (Win32MajorVersion &gt; 5) or ((Win32MajorVersion = 5) and (Win32MinorVersion &gt;= 1)); SetLength(FReaders, Self.NumberProcessors*16); end; function TSpinLockPerProcReaderWriterLock.NumberProcessors: Integer; var systemInfo: SYSTEM_INFO; begin { We hash into it based on the calling thread’s unique identifier, so to reduce (but not eliminate) the chance of hashing collisions, we’ll use a few times more buckets than the total number of concurrent threads. Hashing collisions are expensive: they incur some amount of memory contention, and also demand that we use an atomic CAS increment instead of an ordinary ++ } GetSystemInfo({var}systemInfo); Result := systemInfo.dwNumberOfProcessors; end; function TSpinLockPerProcReaderWriterLock.ReadLockIndex: Integer; begin //Hash the threadID into the FReaders table; helps avoid collisions Result := GetCurrentThreadId mod DWORD(Length(FReaders)); end; procedure TSpinLockPerProcReaderWriterLock.BeginRead; var nSpin: Integer; tid: Integer; begin tid := Self.ReadLockIndex; // Wait until there are no writers. while (true) do begin while (FWriter = 1) do Self.SpinOnce({var}nSpin); // Try to take the read lock. InterlockedIncrement({var}FReaders[tid].Taken); if (FWriter = 0) then begin // Success, no writer, proceed. Break; end; // Back off, to let the writer go through. InterlockedDecrement({var}Freaders[tid].Taken); end; end; procedure TSpinLockPerProcReaderWriterLock.EndRead; begin // Just note that the current reader has left the lock. InterlockedDecrement({var}FReaders[Self.ReadLockIndex].Taken); end; procedure TSpinLockPerProcReaderWriterLock.BeginWrite; var nSpin: Integer; i: Integer; begin while (True) do begin if (FWriter = 0) and (InterlockedExchange({var}FWriter, 1) = 0) then begin // We now hold the write lock, and prevent new readers. // But we must ensure no readers exist before proceeding. for i := 0 to Length(FReaders)-1 do begin while (FReaders[i].Taken &lt;&gt; 0) do Self.SpinOnce({var}nSpin); Break; end; // We failed to take the write lock; wait a bit and retry. Self.SpinOnce({var}nSpin); end; end; end; procedure TSpinLockPerProcReaderWriterLock.EndWrite; begin // No need for a CAS. FWriter := 0; end; procedure TSpinLockPerProcReaderWriterLock.SpinOnce(var spin: Integer); var n: Integer; begin Inc(spin); if (spin &gt; 32) then begin Sleep(0); //give up remainder of our time-slice end else if (spin &gt; 12) then begin //SwitchToThread only exists on XP (Windows 5.1) if FIsWindowsXPOrHigher then SwitchToThread() //allow another thread on our CPU to become scheduled else Sleep(0); end else begin n := (2 shl spin); while (n &gt; 0) do Dec(n); end; end; 
A really long one...
Thanks for your time. We're actually using 2010 here and planning the upgrade anytime soon, this whole benchmarking was very helpful.
s/\r\n//g
Stephen Ball is infamous for posting misleading or wrong code and then refusing to approve any comments that point out mistakes or better ideas. Recently he bragged that Interbase was immune to the OpenSSL Heartbleed bug because it used a (much) older version. It took less than 10 seconds to search for the version he cited and discover that it has several outstanding vulnerabilities that were only fixed in later versions! Myself and Luigi Sandon both wrote comments on his post pointing this out and neither of our comments were approved. I was going to check out an EMBT webinar on database security recently until I learned Mr. Ball was the lecturer! I have a feeling my 3-year-old nephew would be a more reliable source on database security. As usual (I don't know why I bother) I posted this comment several days ago to the article posted here: &gt;That’s nice for an object with two simple built-in types, but if the object has &gt;arrays, lists, or custom types is it going to need some helper code &gt;written/registered first to do the serialization? Of course, Ball never approved the comment. He's a real piece of work and I'd advise people not to bother with his posts. He's so bad that after several people, including MVPs, informed him of some poor practices in a code sample he posted, he declined to post their comments yet edited his post anyway. However, he later produced a YouTube tutorial based on the post putting all the bad code back in!
At this point I just assume that any library you've ever written is superior to any similar library EMBT has ever produced. I've yet to be wrong when doing so. :-) 
&gt;It's not really a single line of code when it just calls an external function. I disagree. What counts is that it's a single line of code for YOU, the end developer. However, I have my suspicions that Ball chose a very simple example and that for more complex objects it is not a single line of code. The fact he declined to post my comment about this reinforces that suspicion. 
Please. There have been freely available JSON libraries available for Delphi over a decade now, so it's hardly impressive that they included it. This is nothing but an Embarcadero employee doing some marketing for Delphi XE6.
If I compare from Delphi 6 up to XE6 on our huge mORMot regression tests suite (more than 16,000,000 individual checks), the faster is definitively Delphi 2007.
&gt;Please. There have been freely available JSON libraries available for Delphi over a &gt;decade now, so it's hardly impressive that they included it. Oh, I completely agree with you on that. EMBT have been treating JSON and REST lately like they were some amazing new technological development. I can't wait to see how they react if the standard library ever gains HTML parsing. :-) My disagreement stems from something that began showing up on the EMBT Delphi forum. In discussions some users would be defending Delphi as the fastest development tool in the universe, and then some others would demonstrate that the same program could be written much shorter in another language, often because of more comprehensive standard libraries. The original poster would then claim that this "didn't count" because there's more code unseen (in the standard library). This of course is silly because all that counts for the end user is that function X is built in and they can just import it and call it rather than needing to write 20 lines themselves. I thought your claim was along the same lines when you wrote "It's not really a single line of code when it just calls an external funciton". If I didn't have to write that external function, then it is indeed a single line of code. 
Does Delphi XE6 do hoisting? Converting: for i := 1 to n do begin for j := 1 to n do begin r.x := P[j].x + P[i].x; r.y := P[j].y + P[i].y; r.y := P[j].z + P[i].z; end; end; into: for i := 1 to n do begin ST0 := P[i].x; ST1 := P[i].y; ST2 := P[i].z; for j := 1 to n do begin r.x := P[j].x + ST0; r.y := P[j].y + ST1; r.y := P[j].z + ST2; end; end; Does Delphi XE6 do automatic vectorization? Converting: for i := 1 to 1000 do A[i] := B[i] + C[i]; into i := 1; while (i &lt;= 1000) do begin A[i:i+3] := mulps B[i:i+3], C[i:i+3]; Inc(i, 3); end; Does the XE6 compiler take advantage of - SSE (1999): 128 bit float SIMD instructions - SSE2 (2001): 128 bit int or float SIMD instructions - AVX (2011): 256 bit SIMD instructions 
I believe the answer to all of those things is "no", and that brings us to the elephant in the room: the most important benchmark is comparing Delphi's compiler against other compilers (many users are *convinced* that Delphi is just a hair slower than hand-written assembly). From what I've seen, Delphi's $1500 compiler doesn't hold a candle to the free GCC. It doesn't even convert division into bit-shifting operations, something the TinyC compiler, designed to fit on a floppy disk (alongside a Linux kernel) does. On another note, I can't figure out what the first example of yours is doing. From what I can see, r.y gets assigned to twice and the final values in r are going to be from when both i and j equals n so the whole loop seems superfluous. 
The first example hoists the repeated values outside the loop into registers, so it doesn't reevaluate them every cycle of the inner loop. The syntax is a bit of a misnomer, as you don't really store them in stack variables. I will edit it to call them `ST0`, `ST1`, `ST2`. But that's the idea: variable hoisting.
Thank you Arnaud. In the benchmark discussion several months ago in the EMBT forum which brought the bit-shifting to light there was division by a constant (although I seem to recall it was "100"). The default Delphi code took 6 seconds on my machine while the C version compiled with gcc took about 1.86 seconds. Someone told me that he got the Delphi version down to the same speed by using bit-shifting (but I never saw his code). What was really interesting was that at its highest optimization settings gcc realized the benchmark function that was running in a loop didn't access outside variables or return anything so it completely optimized the loop away! Nothing I tried with Delphi made it realize it could get rid of the loop entirely. It was disappointing when I wrote the benchmark again in Python and used a package that can convert python functions to C automatically and wrap them so that they can be imported and used just like a python function. gcc was so well optimized that even with the slight overhead of calling into the C from Python I was able to have the Python version perform in under 2 seconds without needing to change a line of code while Delphi was at 6 seconds and would require hand optimization to get the same speed. :-( That just shouldn't be. I'm using another package now that can take python math and matrix code and use JIT to compile those functions with not only SSE and AVX support but automatic GPU support via CUDA. Again, faster than Delphi unless you want to pay $600+ for a 3rd party library for Delphi that uses C code. Arnaud you do fantastic work and if the community lost you and a few other people I can count on one hand, I think it would cease to exist. Your valuable open source work helps fill a lot of the gaps in the Delphi ecosystem and give it professional power. If I ever hit the lottery and buy Delphi from EMBT you and Eric Grange are going to be offered to run things. :-) 
Delphi does have data aware components that interact quite nicely with databases, but expecting someone who isn't technical to teach themselves enough of the basics of Delphi to be able to use the data aware stuff seems rather unreasonable. When my former employer decided they wanted me to stop coding in Visual Basic, and mover over to Delphi, they sent me on a 3 day course at Borland. It still took me quite a few months after that to get properly proficient, and I had years of prior programming experience (albeit mainly with VB) so understood most of the concepts in advance.
"I am an admitted non-tech guy" why would he know Java or C#
BTW: This could be a great opportunity for you-it's not often that an employer will let you learn a language on the job.
HOLD THE PRESSES!!!!!!!!!!!!!! Are you SURE you want "Delphi the programming language"??? You mention a hotel. There is hotel management software also called Delphi. You talk about database queries. I think you have the wrong Delphi software!!!!
I think this person has confused Delphi programming language with Delphi hotel management software based on the rest of their comments. Enterprises don't use Delphi anyway. ;-)
Is your ass ok? :-) Sorry I didn't see this post until today, but I believe you have confused the Delphi hotel management software with the Delphi programming language. That's the only thing that makes sense given what you've said and talking about queries, etc. This group is not for the Delphi I believe you're using.
AsyncPro is a VCL component, but since it is non-visual you might be able to get it to work under FMX on Windows only. http://tpapro.sourceforge.net Still maintained. 
Here is one for Android and FMX http://www.fmxexpress.com/access-the-com-port-on-android-with-delphi-xe5-firemonkey-component/
I once looked up how to make CreateFile(PChar('\\\\.\\COM'+IntToStr()),,,OPEN_EXISTING) work, and have never looked back since. I even use it on USB! (getting the 'port name' from QueryDosDevice) Don't know if that'll work with FireMonkey, though.
Sadly these lack many of the features of a tuple type principally because they're being added as a 3rd party library and not gaining native support in the language. It's more like a shorthand for basic records. But nice work though.
Thanks for the reply. I was using this component when I was working with Delphi 7, but now, with Delphi XE5 I can't even compile it. Althought, I don't think that it is still maintained. As I can see the last update was back in 2010-03-10.
I believe you are referencing the wrong Delphi for this subreddit. This subreddit is for software developers using the [Delphi programming language](http://en.wikibooks.org/wiki/Delphi_Programming), not the hospitality sales and catering software from NewMarket.
I described some details on the current capabilites in the forum thread here: https://forums.embarcadero.com/thread.jspa?threadID=106441
Good article. You might want to show step by step (with screenshots) creating a new Jenkins/Hudson job, as this will be "tricky" for people who have never done it before.
404'd? :-(
I was nicely surprised by the good help which is semi integrated into Delphi. This hasn't place since Delphi 7. So I was up and running in about a half an hour (Samsung Galaxy S4 mini). I had problems with LocationSensor component and had to throw it out and use "native" Java support. Thanks to the community it was not so bad. In two days I was able to create an application that makes a photo, put it to the list (wihich displays thumbnails) and geotags it. Then I was able to send all photos via App Tethering to my PC. Debugger sucks, deployment is very very slow (90 seconds) and I got IDE crashes when loading sample tutorials (from time to time). I was able to do what I wanted but I wouldn't call that a pleasure :)
Really nice example of possible improvements to the Delphi language, here the lambda syntax. I really wish Embarcadero would care more about language and compiler stuff.
Global variable hating is stupid. It's a tool, it comes with a price. There are things in the world which are global, and it would be counter-productive to pretend they aren't. Then some things aren't global, but you don't need more than one and why spend time designing Starship Enterprise when you need scissors. The "what if" argument is only so much valid. What if I need to run this code on a server? Guess I'll update the code! I'm a programmer after all. It's not like my job description is "you're going to live 20 years on an uninhabited island and all you can do is reuse one function, write that function".
This is exactly what the blog article says. There is a whole section about "When globals may be used". The "what if" is not premature optimization, but lazy programming. Avoid global variables is not more difficult, nor time consuming that proper OOP design, and it would always save you time and efforts. "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability." https://groups.google.com/forum/#!msg/comp.lang.c++/rYCO5yn4lXw/oITtSkZOtoUJ :) If you are the only one which would ever have to maintain the code, it is your responsibility to do whatever you want. But don't let your weakness make your successors suffer! I've maintained so many code since decades, that I know what I mean. And since I'm myself a violent psychopath, the initial coders cannot testify any more. :s
Nice, thanks for the discount!
Thank you too!
The users on the [Delphi Professionals Google+ Group](https://plus.google.com/communities/103113685381486591754) are very active and helpful. Though you have to be on LinkedIn, the [Delphi Professionals](https://www.linkedin.com/groups?mostRecent=&amp;gid=101829&amp;trk=my_groups-tile-flipgrp) group there is also helpful for answering questions.
Awesome! Thank You! My request to join Delphi Professionals is pending, but I'm excited to start working through it. Thanks again!
Stack Overflow is usually good. The forums have fewer people. There's also the [Delphi Developers Google+ group](https://plus.google.com/communities/103113685381486591754). It's more for news and sharing items of interest, but you can ask for help there too.
Thank You! I just joined the Google+ group (along with the Delphi iOS and Android Developers Group) and it definitely seems to be active! 
Just wanted to say Thanks Again! The Google+ group Rocks!
Just saying Thank You! Questions asked and answered! 
Yes, write ALL your own code. Never use ANYTHING anyone else has created. And don't forget to post YOUR work, so we can all be SOOOO impressed!
Ready to rock the json ini file session!
I, too, have come across the bug in the compiler of interface references that should have been removed staying until the end of the function. I never thought to turn them into a sneaky feature!
Yeah for IDE Fix Pack. That guy is the only one that cares.
This also affects Delphi 2006. For some reason I couldn't delete the file, but I could rename it, which provided a temporary fix until I closed and needed to opened Delphi 2006.
They do fix stuff, and Andreas works quite closely with Embarcadero I believe. You'll notice the contents of the fix pack change slowly over releases - some fixes only apply to certain versions. So, a bug like this will almost certainly get fixed in XE7; some of the other things in the fix pack may not. The fix pack also contains feature changes or tweaks that aren't necessarily things Emb want to change. (IMO they should, but they're not glaring, crash-style bugs, so...)
Also, Jose, three dozen bugs and crashes?! To give a different perspective, I've been using XE6 for months and haven't had one single crash. It's very stable, reliable and fast - to me it's one of the best releases since 2010. So I'm genuinely curious - what are these crashes and bugs, and in what circumstances do they happen? Can you link to the QC bug reports too please?
I've been screenshotting them. Is planning on saving them up for a &gt; [What is needed to get Delphi back on top](http://www.stackprinter.com/export?service=stackoverflow&amp;question=12685&amp;printer=false&amp;linktohome=true) style meta-post somewhere. I feel bad, because I'm the one who has been pushing to get the upgrade from Delphi 5 to something newer. I was looking forward to all the advantages of a fast native compiler, but with all the crashes and memory corruption of Delphi 5 fixed. And I was looking forward to a modern IDE, with intelligent refactoring, find references, etc. So the company shells out $3,000 and we get this mess. Crashes aside, the usability is awful. Usability is important. I believe that usability is more important than bugs. Because usability problems are there every time - bugs only happen occasionally. But I can't report usability problems. Because people will just say I'm being too critical, or will want to debate it to death, or have become used to the poor UI they would fight tooth and nail to have it changed. But as someone who is coming to the UI fresh, there is the natural way us five developers try to do a task, and then there is what we have to do. I'm hoping to screenshot all the usability problems (in addition to the bugs). Perhaps if I can mockup the alternatives, people might be amiable to not rejecting them out of hand. But I sense that since Delphi XE6 has just as much memory corruption and crashes as Delphi 5, and all the new usability problems (i.e. didn't anyone ever use their product), that Embarcadero has no interest in fixing their product. And not because they are stupid, but they cannot justify taking time and resources to simply fix things. Can you imagine how impossible of a sell it would be that XE7 is only a fix release? I world never be able to convince the company to shell out another three grand for a product that adds the feature that now it works. And stepping into the RTL source with all the platform defines, it seems like the Kylix disaster all over again. 
&gt; How is it that, year after year, Delphi still need a fix-pack Fixes in past fix pack have been included in the product. Check Andreas' blog for more details.
Delphi has always had a strong international presence. There are domestic jobs and open source projects going now. In recent years there has been a revival in community activity too.
&gt; If you're looking for a modern high-level strongly-typed programming languages that produce native binaries, then I would look at ...Lazarus.
Usabilty issues are easily reproducible. Crashes: never. The **Find unit** tool crashes with an access violation perhaps 6 out of 10 times. I cannot reproduce it because it doesn't happen consistently. All i can do i provide screenshots *every* time it happens... ...to remind the developers that these bugs exist: whether they choose to acknowledge them or not (i.e. *"closed as not reproducible"*) And, for the love of all that is holy, they could fix `Ctrl+Shift+Space` yet?! Fourteen years later and code-insight is still buggy!?
Thanks. I have never seen the problem with Find Unit, but I don't use it that much. I am doing some new work this week and will make a point of trying to make it happen. Having bugs that you are seeing closed as not reproducible is really frustrating. In a lot of cases, it comes down to giving enough detail. Why is it happening for you but not for them? Finding that missing step or detail is critical. Yes, Code Insight can use some work. My personal pet peeve is Error Insight. Death to phantom squigglies!
As a developer, i certainly understand the frustration of unreproducible bugs. I would have hoped that Delphi would automatically send all crash reports back home. But it seems to either be: - a message box with an exception message - a message box with an exception message and a stack trace - a dialog with the error, that then offers to launch a wizard that guides you through the reporting process, including providing your BDN credentials (or you can check anonymous), and then steps to reproduce the problem, etc They need to send every error, all hundreds and thousands of them, back home. After a few million exceptions, you might be able to discern a pattern. Microsoft solved the reporting issue a decade ago. Send the error report. And if the server asks for it, send a minidump.
&gt; you can try learning C++11 Also available in Rad Studio. http://docwiki.embarcadero.com/RADStudio/XE5/en/C%2B%2B11
Can't do much about the accents since presenters are from all around the world, but almost all of the Delphi resources, tutorials and webinars are in English. Two recent examples include: CodeRage 8 replays: - http://www.embarcadero.com/kr/coderage/embtc-gated-sessions1013 - https://www.youtube.com/playlist?list=PLwUPJvR9mZHiaYvH9Xr7WuFCVYugC4d0w Developer Skill Sprints. New sessions every Tuesday and Thursday with replays posted afterward: - http://www.embarcadero.com/kr/landing-pages/skill-sprints?cid=701G0000000tdHs - https://www.youtube.com/playlist?list=PLwUPJvR9mZHhZTajVWsgaFPLtDA-t1Xwc There seem to be more non-English books, but here are a couple of recent English examples: Coding in Delphi by Nick Hodges (highly recommended): - https://leanpub.com/codingindelphi Courseware from Bob Swart, including four new titles for Delphi XE6: - http://www.drbob42.com/courseware/ - http://www.drbob42.com/courseware/61.htm - http://www.drbob42.com/courseware/62.htm If you decide to go with Free Pascal, at least some of the Delphi resources will still be applicable, and I know some Free Pascal specific books have been published. I'm not sure about webinars.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**MurmurHash**](https://en.wikipedia.org/wiki/MurmurHash): [](#sfw) --- &gt; &gt;__MurmurHash__ is a non-[cryptographic](https://en.wikipedia.org/wiki/Cryptographic_hash_function) [hash function](https://en.wikipedia.org/wiki/Hash_function) suitable for general hash-based lookup. It was created by Austin Appleby in 2008, and exists in a number of variants, all of which have been released into the public domain. When compared to other popular hash functions, MurmurHash performed well in a random distribution of regular keys. &gt;Unlike [cryptographic hash functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function), it is not designed to be difficult to reverse by an adversary, making it unsuitable for cryptographic purposes. &gt; --- ^Interesting: [^CityHash](https://en.wikipedia.org/wiki/CityHash) ^| [^Fowler–Noll–Vo ^hash ^function](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) ^| [^Jenkins ^hash ^function](https://en.wikipedia.org/wiki/Jenkins_hash_function) ^| [^Cdb ^\(software)](https://en.wikipedia.org/wiki/Cdb_\(software\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ck1dg7p) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ck1dg7p)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Perfect. Do you have any other good videos like those?
Originally Delphi was an IDE for the object oriented dialect of pascal made by Borland. At some point some marketing genius came up with the idea of relabeling that dialect of pascal as the Delphi language. So now it is both. Delphi is the both the name of object oriented pascal dialect produced by Embarcadero and the name of the associated RAD IDE. Lazarus uses freepascal which is a different pascal dialect that is only partially compatible with Delphi.
I can't help but thinking, do we really need another REST framework for Delphi?
I definitely believe you there has been some stuff in lazarus I could not do vs using borland delphi 6/7
[Pascal](http://en.wikipedia.org/wiki/Pascal_%28programming_language%29) = programming language [Turbo Pascal](http://en.wikipedia.org/wiki/Turbo_Pascal) = IDE (editor+compiler), uses "Object Pascal" since v5.5 [Object Pascal](http://en.wikipedia.org/wiki/Object_Pascal) = language [Delphi](http://en.wikipedia.org/wiki/Delphi_%28programming_language%29) = IDE (editor+compiler), uses Object Pascal (later renamed to "Delphi Language") [Free Pascal](http://en.wikipedia.org/wiki/Free_Pascal) = compiler, [has different compatibility modes](http://en.wikipedia.org/wiki/Free_Pascal#Supported_dialects) [Lazarus](http://en.wikipedia.org/wiki/Lazarus_%28IDE%29) = IDE (editor, uses Free Pascal as the compiler)
Very interesting. I like the website better than Embarcadero's too. :-) This is what I like most, from the roadmap: &gt;Creation of a new dialect for the FreePascal compiler - a language on par with &gt;Delphi XE2/XE3, developed in the direction of Oxygene. EMBT seem to have given up on language design (letting go of seasoned developers and replacing them with the cheapest they could find no doubt contributed to that). Languages like Oxygene and DWScript show much more desire to evolve the language to make it competitive. I've always said though that the first person to merge DWScript with a plug-in for a major open source IDE (such as Eclipse or one of JetBrains' open source offerings) and a full set of bindings for Qt will have produced the open source tool that renders Delphi obsolete. 
I thought I saw an announcement about this pop on DelphiFeeds as posted in the EMBT Delphi/tools forum, but when I clicked on it the post had been removed. Did EMBT censor the post????
That said, EMBT has recently been calling the language Object Pascal again, with one quote someone found that suggested it was "official". :-) 
The website has no screenshots!
Sadly, yes...
What the heck is he doing? Why all this "create additional component which sets OnClick internally"? Why can't he just set OnClick directly? procedure TForm1.FBtnClick(Sender: TComponent); var pt: TPoint; begin FMenu.PopupComponent := FBtn; Pt := FBtn.ClientToScreen(Point(0, FBtn.ClientHeight)); FMenu.Popup(Pt.X, Pt.Y); end; It's literally three lines of code.
Finally removing the BDE was a good change.
Now i just need a service pack for XE6.
XE6 Update 1 was released in June. http://blog.marcocantu.com/blog/radstudio_xe6_update1.html Here are the fixes: http://edn.embarcadero.com/article/43893 
I've never seen daily crashes in XE6 from myself or anyone I know who is using it. Can you point to any specifics?
I've been taking screenshots every crash or usability problem. Yesterday I was documenting usability issues with the built in crash reporting wizard. If you've seen the crash dialog, you know you can submit the reports either anonymously or give your BDN credentials. Yesterday I finally tried digging out my credentials and see that it creates private QC reports. I know the issues will never be addressed, but I will get some satisfaction by reminding them them that crashes happen. Unfortunately a lot of crashes simply end with a MessageDlg, showing simply an exception message. The most common is **Refactor** -&gt; **Find unit**: - EOutOfMemoryException - EOutOfMemoryException - appears We've also been patching VCL bugs. Some bugs are documented and decades old. Some are documented and years old. Some are new. So many unfixed bugs. After a few months, I hope to dump my hundred or so screenshots in a massive imgur album. Although I suppose nobody will care because I'm no longer running the latest version of XE. It's would be as though I don't have any right to report failures until we shell out another $3k.
This rings a bell. I tried, but haven't been able to duplicate it. Actual bug reports would help instead of hoping that Embarcadero fixes your specific problems. The crash reports are helpful, though. btw, if you have XE6 without SA, you don't have to pay the full price to upgrade. Look at Recharge, for example.
How are you inspecting it in the debugger? Are you sure your debugger view is on the same thread as your variables?
Are you setting a breakpoint, or just stopping the running program to inspect the variables? If the latter, try the former.
When I was programming simple games in Delphi, I put a timer on the main form and activated it in the Form's OnShow handler (only on the first occurence though). When the timer fired, I started a simple "repeat ... until quit;" loop (quit is a boolean variable set elsewhere). In the loop I'd process the game logic and call ProcessMessages. As for your question: handle the keyboard events. Define a variable "go_left" that is set/cleared in the Form's OnKeyDown/OnKeyUp event handlers. In the game logic, move the object around when the variable is set to true. At some point you'll have to switch to DirectX/OpenGL and DirectInput/XInput though (or related libraries).
&gt; In the loop I'd process the game logic and call ProcessMessages. That sounds like a bad idea. Your form never quite "finishes showing", what's more, you're basically reimplementing the main loop: Application. Run() while blah blah do ProcessMessages() &lt;-- main loop ProcessMessage(WM_SHOW) OnShow() while blah blah do ProcessMessage() &lt;-- your internal loop If you're doing that anyway, just write your own loop and call it from project file instead of Application.Run(): Application.RunGame() while blah blah do ProcessMessage() &lt;-- your own main loop You can just copy Application.Run() and strip parts you don't need. This way at least you're not stuck midway through showing form all your game.
No, the Form *does* finish showing. That's what the timer is for. :) When I started, I was on the standard version of Delphi 5, so there was no source code to copy.
Borland Database Engine, I believe. 
It's pretty easy to write your own. I have been using my own set of routines for the last five or so years.
You could look at webfmx: www.cybelesoft.com/webfmx/
I took a quick look and it seems to be able to do what I want. Will I have to host it myself or do you know anywhere (free please) where I could host my app later on?
Why are you adding a string constant to the OpenDialog.FileName string? Doesn't that property already contain the full path? Also, please use spaces...
I was trying to propose the whole question in a succinct pseudo-code manner. If you read above, though, I did find the solution.
Wow. He manages to say so many words about such a simple concept without even going into interesting details. *And* covering only Windows. *And* he writes his own RFolderHelper instead of just implementing TPath.GetXxxPath on older platforms.
Here's the permalink, by the way. http://www.chapmanworld.com/jenkins-build-server-with-embarcadero-rad-studio-delphi-and-no-plugin/
Components: FlexCelVCLNT 6.3 Full Source XE-XE6 TMS Advanced Charts 3.8.0.3 Full Source D6-XE6 TMS Async32 1.9.0.0 Full Source D6-XE6 TMS CETools 1.9.0.0 Full Source D5-XE6 TMS Cloud Pack 2.5.0.0 Full Source D2011-XE6 x86-x64 TMS Component Pack 7.4.2.0 Full Source D5-XE6 TMS Diagram Studio 4.6.1 Full Source D7-XE6 TMS GUIMotions 1.9.0.0 Full Source D5-XE6 TMS Instrumentation Workshop 1.9.0.0 Full Source D5-XE6 TMS Mail Merge Wizards 1.3 Full Source D5-D2010 TMS MultiTouch 2011 Full Source D2010-XE3 x86-x64 TMS Plugin Framework 6.2.0 Full Source D5-XE6 TMS Query Studio 1.8.1 Full Source D7-XE6 TMS Scripter 6.3.1 Full Source D7-XE6 TMS Security System 2.7 Full Source D6-XE6 TMS Skin Factory 1.7.0 Full Source D5-XE6 TMS Unicode Component Pack 2.0.0.0 Full Source D6-XE6 TMS WebGMaps 1.9.5.0 Full Source D7-XE6 TMS WebOSMaps 1.3.0.0 Full Source D2007-XE6 TMS Workflow Studio 1.9.2 Full Source D7-XE6
It contains components and classes for Borland Delphi 7, 9, 2005, 2006, CodeGear Delphi 2007, CodeGear RAD Studio 2009, Embarcadero RAD Studio 2010, XE, X2 and RAD Studio XE7, intended to increase capacity of the client part of database application in part of interaction with applications user. 
Used it with Delphi 7. Powerful stuff.
WebSocket is a web technology providing for bi-directional, full-duplex communications channels, over a single Transmission Control Protocol (TCP) socket. The WebSocket API is being standardized by the W3C, and the WebSocket protocol has been standardized by the IETF as RFC 6455. WebSocket is designed to be implemented in web browsers and web servers, but it can be used by any client or server application. The WebSocket protocol makes possible more interaction between a browser and a web site, facilitating live content and the creation of real-time games. This is made possible by providing a standardized way for the server to send content to the browser without being solicited by the client, and allowing for messages to be passed back and forth while keeping the connection open. In this way a two-way (bi-direction) ongoing conversation can take place between a browser and the server. A similar effect has been done in non-standardized ways using stop-gap technologies such as comet.
SMExport suite 4.99 is a set of component that export data from TDataSet or TDBGrid or any other VCL control (such as TStringGrid, TListView and so on) into such formats as Paradox (if using the BDE) and DBase tables or into a text file (fixed or comma-delimited), HTML, XML, MS Excel, MS Word, PDF, MS Access, SQL-script, Lotus 1-2-3, Quattro, SYLK, DIF, LDAP DIF and other formats. 
AlphaControls - a set of common and some unique components that support skins (AlphaSkins), as well as having some additional features. All skin elements can have their own properties for advanced drawing the gradient, realistic framework, semi-transparent and blurry shadows. Graphics functions produce all the calculations and drawing in real-time. Added property BoundLabel for editing elements. Handled various mouse events, which gives some additional features components. Manager prompts controls the tips in the application and gives them a beautiful view with a lot of settings that can be changed by a special designer. Analogs of standard components provide all the functionality and add a lot of new solutions to improve software quality and their appearance. 
Dew Lab Studio 2014 with support for Rad Studio XE7 is now available. DSP Master received support for the new audio API available from Windows Vista onward. The codebase now also compiles for OSx and Android, although no official support yet.
A server can be 'online' in a number of ways. You're pretty vague about that. If you want to check if the server responds, you'll have to select a protocol or service to send a request over. A good example is ping (which uses ICMP as underlying protocol), but not all servers respond to ping requests for security reasons (also some firewalls block ping requests and responses for security reasons). Some examples: https://duckduckgo.com/?q=delphi+ping
I am really impressed by the XData framework. If it was only my choice I would switch to it from Datasnap right now. The fact that there is an Absolute Database driver included really gives a good migration path for us as well to be able to switch to a server database at a later time when we are ready. When this was first announced, I was sceptical, because there is really a lot of ORMs/Api server frameworks available for Delphi already, but XData seems to take a simple and fresh approach and from the tests I have seen has top performance..
The question, as stijnsanders suggests, is what port/protocol and ok signifying response you are expecting to be able to reach on that server in order to determine it as available for your intended purpose? 
I'm curious, which tests did you see? Are you talking about http://datasnapperformance.wordpress.com ? This test is just a "hello world" test, without any DB access, nor JSON serialization of real data. Don't jump too fast into the conclusion that the whole HTTP/JSON/ORM stack has top performance. The HTTP transmission layer is optimized (TMS Sparkle) since it is an encapsulation of the http.sys API. Aurelius and XData are great, but seems not so optimized for speed. But XData may be faster than DataSnap, since it does not suffer from the whole complex DBExpress/WebBroker technology.
I am sure everything isn't microoptimized like you would do. :D Pretty much anything would be better than Datasnap. I was trying to debug why the Content-Type header didn't come out right in certain datasnap configurations a long while back, and it was just a nightmare. Layer upon layer of wrapper code build one on top of the other for every internet technology that has ever been in Delphi. It's seriously terrible. I honestly don't think anyone should be using this stuff.
I can add another example. Here is part of some code which serializes Spring4d Nullable&lt;T&gt; to JSON. It sets the json field value to null if no value is assigned to the nullable property, otherwise is use type information on the contained value to set the field value to the appropriate type. procedure TJSONObjectMapper.SetNullableProperty(prop: TRttiProperty; obj: TPersistent; jsonObj: TJSONObject); var nullablePropValue: TValue; nullableContainedValue: TValue; begin nullablePropValue := prop.GetValue(obj); if GetNullableValueHasValue(nullablePropValue) then begin case GetNullableContainedValue(nullablePropValue).Kind of tkInteger: SetIntegerProperty(jsonObj, prop.Name, GetNullableContainedValue(nullablePropValue)); tkFloat: SetFloatProperty(jsonObj, prop.Name, GetNullableContainedValue(nullablePropValue)); tkInt64: SetInt64Property(jsonObj, prop.Name, GetNullableContainedValue(nullablePropValue)); tkUString: SetStringProperty(jsonObj, prop.Name, GetNullableContainedValue(nullablePropValue)); else raise EUtilJSON.CreateFmt('TJSONObjectMapper.SetNullableProperty, unsupported nullable type. Property name: %s - TypeName: %s - TypeKind: %d.', [prop.Name, prop.PropertyType.Name, Ord(prop.PropertyType.TypeKind)]); end; end else begin jsonObj[prop.Name].AsValue := TJSONNull.Create; end; end; function TJSONObjectMapper.GetNullableValueHasValue( nullableValue: TValue): Boolean; var nullableRttiType: TRttiRecordType; begin nullableRttiType := context.GetType(nullableValue.TypeInfo).AsRecord; Exit(nullableRttiType.GetField('fHasValue').GetValue(nullableValue.GetReferenceToRawData()).AsString.Length &gt; 0); end; function TJSONObjectMapper.GetNullableContainedValue( nullableValue: TValue): TValue; var nullableRttiType: TRttiRecordType; begin nullableRttiType := context.GetType(nullableValue.TypeInfo).AsRecord; Exit(nullableRttiType.GetField('fValue').GetValue(nullableValue.GetReferenceToRawData())); end; Because Embarcadero doesn't seem to think that you would want Rtti for record properties, I had to reimplement the GetHasValue Getter method of Spring.Nullable&lt;T&gt; in GetNullableValueHasValue. (Embarcadero Pls fix!!!) 
Extremely good product, easy to translate, very stable and customizable. 10/10 would use every chance
Cary Jensen is also working on a 2nd edition of his book "Delphi in Depth: ClientDatasets". Looks like it is scheduled to be released before the end of 2014. http://www.jensendatasystems.com/cdsbook/ 
&gt; http://www.jensendatasystems.com/cdsbook/ I learned about this today listening to Cary's CodeRage sessions. Neat!
Does anyone here have good experience with this? Would you recommend it?
Hmm I'll have to look into it. Still using the BDE. 
You are on the right track We migrated from BDE to IBO when i worked at wokadat.ro (~ 14 years ago) and never looked back http://www.ibobjects.com/ibowhatis.html
It's almost like they didn't fix any of the longstanding bugs that have been on QC for years. Well, it's not almost like it - it's *exactly* like it. I get the sense that there is a disconnect between the team and the users. They keep adding features they think are neat and cool, without stopping to look at the product and deal with the real world issues. 
Actually it's almost the opposite of what you're describing. Or exactly the opposite. For example, here is an incomplete list of fixes from XE6 and XE7: - http://edn.embarcadero.com/article/43754 - http://edn.embarcadero.com/article/43893 - http://edn.embarcadero.com/article/44049 - http://edn.embarcadero.com/article/44156 You can argue that they haven't fixed something important to you (provide QCs, please), but claiming that they aren't fixing bugs is pure nonsense.
I got XE6 in late August. After two weeks i started taking screenshots of every crash, hang, bug, limitation, or usability issue. I'm up to 137 screenshots. After three weeks i started sending the crash reports *not* anonymously, so they would pile-up. I would hope that having a few hundred crash reports, they might consider fixing them. Shortly after XE7 came out, [they stopped accepting my crash reports](http://i.imgur.com/jBKS3YN.png). The frustrating thing about that list is that the majority of them deal with Firemonkey, Parallel, or something related to cross platform development. And then we started to discover all the bugs in the VCL. Fortunately a lot of them have been well-documented in the QC. We were able to take the code fixes listed in QC and start patching the VCL. One example is an issue [first reported nine years ago, and they refuse to fix](http://qc.embarcadero.com/wc/qcmain.aspx?d=22672). The code is there; they just can't be bothered to test Delphi, or fix issues that actual customers are having. [Another](http://qc.embarcadero.com/wc/qcmain.aspx?d=30134). Fixed in 2012? Not at all. Embarcadero needs to step back and really engage the community to address the issues. There's so much push for new cross-platform code, cross-platform UI, cross-platform database, etc. They need to take a breath, look at the bugs, look at the issues, look at the complains, look at the UI, and give the product some polish. And then there's the [intentionally *sloooow* startup time of Delphi](http://andy.jgknet.de/blog/2012/09/xe3updated-copy-protection-or-how-to-slow-down-the-ide-start/). Bo...Imp....CodeG....Embarcardeo needs to step back and focus on developer quality-of-life. This means bringing an excellent IDE experience, not just adding new platforms and classes.
I remember you reporting things that no one else can reproduce. I think more information is needed and not more screen of the same issue over and over again.
Delphi sends a crash dump. Hard crash error reports can be picked up at WinQual. And there are some errors that, rather than letting the IDE crash, are eaten and show a message box. Embarcadero needs to work to resolve these things. That includes: - looking at the QC entries, and especially the fixes already provided, and implement them - monitor stackoverflow for the abundance of bugs well-known by the community, but seemingly not by Embarcadero itself (it's also as if they don't have someone whose job it is if to only go through all Delphi stackoverflow questions) - change the IDE to never, ever, ever, eat an exception. Either send the exception (automatically) home, or let the IDE crash and get the exception off winqual. - run the IDE full time with the Windows Application Verifier. There are a number of common VCL bugs that Microsoft already catches for them (with details already on QC). But unless they dogfood it, no developer there will see it. And they won't take the time to find the bug themselves unless it is spoonfed. Microsoft learned a decade ago the value of crash dumps and telemetry. I would like embarcadero to stop with any new features and dedicate XE8 to helping fix things. Automatic crash dumps. Telemetry. Code analysis to ensure no exceptions are eaten. Use Windows apprestart to recover when the IDE crashes. Run experts and tools isolated in their own processes. Stability. Right now Delphi has the quality feel of an open source Java app.
All of these things are being done (well, except griding to a halt to fix "all bugs") , so claiming that old bugs aren't being fixed is still nonsense. In fact, many more bugs were fixed in the XE6 and XE7 cycles than are included in the public lists. Marco hinted at some of the reasons in his post. So instead of making sweeping and incorrect statements, you serve your own interests better by focusing on the areas where Embarcadero is legitimately falling down. The regressions you point out are good examples.
I wouldn't expect any more fixes for XE6. btw, I'm not convinced that the error you are seeing means they stopped accepting your reports. That's a bit of a leap. Aren't you using XE7? You mentioned that your reports include things dealing with "parallel". I assumed that you meant the parallel library, which was introduced in XE7. Did you mean something else?
Delphi doesn't has main method, but the begin .. end. is where the code start executed as : Program Demo; begin Writeln('Hello Delphi'); end.
How do I call a declared procedure there? As in Program Demo; type tform2 = class(Tform) private { Private declarations } public { Public declarations } end; var Form2: TForm2; TitlesSL : TStringList; implementation {$R *.dfm} procedure (var : var); procedure 2; begin Writeln('Hello Delphi'); procedure2; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Error end.
First of all, the end of procedure is end; such as procedure Demo (var x : integer) begin writeln(x); end; also you are using VCL application, not console application, because you are using Forms, DelphiBasic is very helpful for you, http://www.delphibasics.co.uk/Article.asp?Name=Routines
also there are two free ebooks from Marco Cantu Essential Pascal http://www.marcocantu.com/epascal/default.htm Essential Delphi http://www.marcocantu.com/edelphi/default.htm 
**The** bug fixes (listed in the fix list) dealt with parallel.
I switched from using mostly C++ to using Delphi about nine months ago, when I started my own Delphi-related company. Delphi is in an odd situation, which is predominantly a social situation. It doesn't seem to be used much in the USA, and so you don't hear about it much in tech news (mostly US-based) or from developers (often US-based.) You can see this in news coverage, for example - a site like Ars Technica covers open-sourcing of .Net and it becoming cross-platform, but doesn't cover the already cross-platform Delphi and C++ Builder. The only reason I can think of for this is that Ars is a US-based tech site, its writers mostly are on the US pulse, and the US tech pulse doesn't include Delphi. But the tech pulse of other countries does: it's common in Europe, especially Germany and Russia, also China, Brazil and South America, etc. I used to live in Australia, and even there a reasonable number of people use it - you'd never know from Australian coders, though. Now I live in Europe and it's far more common. So with that said: if you live in the US, you may have trouble finding a job. WideOrbit is the biggest company who use it (and they're currently hiring in both the US and in Paris, so if you want to go work in Paris...) On the other hand, if you live in Germany, you'll have work fine. So that's the work situation - second is the language itself. And the language is lovely, elegant, and a pleasure to write. Your knowledge of the language will help you with any other languages you want to learn, such as C#. If you can't find Delphi work, other languages will help, but you may end up using Delphi out of personal preference in your own personal projects - lots of people do.
I used Delphi for a long time for both my own projects and professionally and would have been happy staying with it except there is now very limited demand for Delphi coders in UK. I'd suggest checking job sites for demand locally but it is likely C#/Java/C++/C will be in considerable more demand (about 100x as many jobs in each than mention Delphi in adverts ) and having skills to make you employable in your chosen field is first priority.
My first piece of advice for anyone getting in to software development, regardless of the languages or platforms they use, is "learn about databases". Know how to create one from scratch, design tables and create indexes. Know how to add, update and retrieve data. Know how and when to use SQL. Learn how to connect to a database from your favourite programming languages. Basically, understand all of these things well enough to remove the mystery. This doesn't have to be expensive, either. There are a lot of free databases available. Someone usually speaks up about how proud they are that they have never used a database in their professional software development career. Good for them. I still consider it to be an essential tool for any developer to have in their toolbox and it helps makes them more marketable. Now, about programming languages. Do not, under any circumstances, limit yourself to a single programming language. Learning about other languages and technologies helps provide perspective, gives more options for solving a given problem and, again, improves marketability. There is a world of difference between someone who makes an informed decision to use a given language and someone who doesn't know (or want to know) how to use anything else. Be the first one. Delphi. This might be more contentious than the database thing. I'm an unapologetic Delphi supporter, so feel free to take my suggestions with a healthy grain of salt. Along those same lines, anyone who goes out of their way to tell you how dead Delphi is has an axe to grind and can safely be ignored. Speaking for myself, unless there is a really good reason to use something else, Delphi is my first choice for any kind of software development. It does the things that I need the most (mostly Windows up to now) better than any other tool I have looked at. And I have looked. Very productive. Makes fast, native executables that don't rely on external dependencies. Easy, reliable deployment. Very good for database work (and you know how much I like my databases). Source code is highly compatible between versions of the compiler (with some notable exceptions), so maintaining code bases across projects and even compiler versions over the course of years is surprisingly easy. I strongly recommend continuing to use Delphi. If I were just coming out of school, knowing what I know now, it's what I would do. One caveat - it's not cheap. And there are two releases per year. If someone chooses to use Delphi then they should bite the bullet and invest in the proper SKU (Rad Studio Enterprise for me) along with a subscription.
I have been using delphi since version 1. I really would not recommend getting into it now. It is still reasonably good, but it is effectively a niche choice, which impacts articles, books, libraries and jobs. I have also found that most delphi releases add minimum value lately. If you really, really love pascal look into remobjects, which has a nice .net pascal which used to be sold as delphi prism (and also allows you to compile to java, osx, android and ios, although you need to write the ui natively). Check out C#, it has some nice features and there is a very nice free version.
I have an early-2011 model MBP, which has a quad core i7. Even it sometimes slows down. I never considered the 15 when buying it. If you get a quad-core, you can dedicate 2 cores exclusively to the VM, which will keep both your host OS and Windows running snappily. The other thing to consider is if you will want a Retina external display at some point - make sure you buy a model which can power one. Not all laptops can.
I have a 2013 2Ghz Core i7 15" retina MBP, it's a beast. I have 2 'work' VMWare Fusion VMs, both Win7; one 32bit, one 64bit, sometimes I have them both running, usually though it is one or the other. Both have Visual Studio 2013, Delphi XE2 and SQL Server 2008R2 running. Only 8Gb ram in it right now, but it doesn't feel too constrained. The whole thing is a beast, easily the best set-up I've ever had, neither the host OS X or the VMs ever seem to pause or slow down. I use the Mac for browsing, email, office type stuff, Xcode and Xamarin Studio. When using Xamarin Studio I often run an Android emulator (their new one is much better than the stock Google one). I don't develop Firemonkey or use the cross-system tools to piggyback from XE2 into Xcode etc, so i can't comment on that stuff. Definitely concur with /u/vintagedave's comment about the display - important to check that what you've got will happily drive whatever external display(s) you're thinking of. I have a 2012 Mac Mini with a 2.3Ghz i7 and 16Gb which often runs the same VMs but for some reason the MBP seems quicker - that might be the SSD I guess (the Mini has a HDD). If you have the cash, get the i7. I don't know when the line is next due for a refresh, you might want to become aware of that in case there's an imminent spec bump. Apple don't tend to mess with the price points, they just gently increase whatever is in the box at that particular price point.
I have an early 2012 MacBook Pro with Retina. Quad core i7, 16GB RAM and a 500GB SSD. I run Win64 under VMWare with 2 cores and 2GB of memory and Rad Studio runs just fine. Perfectly. I recently went back to an older laptop for some quick work, a dual core i7 with a slower SSD. Same virtual machine. Compiles are quick, but the IDE , particularly code insite, is a dog. Makes me think that the drive speed is making a huge a different for me on my normal laptop. 
FireMonkey is much better in XE7 than in XE2 - the version around (I think) XE4 was named FireMonkey 2, to differentiate it. It's faster, renders much better (for example will use D2D on Windows usually, instead of GDI+), etc. Personally I'd install the XE7 trial, see what it's like compared to XE2, and ask your boss to buy a license because it's better ;) But in terms of breaking changes - I haven't upgraded any apps built in FMX in XE2 to later versions, only an [unusual component](http://parnassus.co/open-source/tfiremonkeycontainer/). I think most property names etc will be the same - what might change are the internals. You can expect some things to break, and to have to upgrade some forms and properties manually. But if you must use XE2, there's no real harm. It won't look or behave nearly as nicely as it will using a later version. Themes / styles may not be compatible too, so if 'look' is important, start off with the latest. But I personally would start off in XE7. Not only is it much better quality, but workarounds or things you do in XE2 might actually negatively affect your code (or have to be changed / replaced) in XE7. So start with the modern / best version and continue from there. In terms of look: are you aware of [VCL Styles](http://blog.marcocantu.com/blog/2014-september-vcl-xe7-styles.html)? You can use them to give a radically different look to a VCL app. Again - much better in XE7, since some things (like styling menus) have been improved.
Thanks vintagedave, that more or less confirms what I thought the state of play might be. We're not in a position to upgrade to XE7 at the moment, but here (and elsewhere) I've been persuaded that the FireMonkey in XE2 isn't worth the trouble. The kind of workarounds you're alluding to are the kind of thing I was worried about - things that take a while to work around and we find that in XE7 they're fixed/much better, but because we couldn't buy the XE7 license right now we're wasting development time on things that are already fixed, if you see what I mean. I haven't really looked at VCL styles, but I will now - thank you!
The IDE is the big reason to upgrade. Xe2 has a tonne of IDE and compiler bugs. Firemonkey is better too and so is the VCL.
Ah, thanks for that. I can't get an upgrade past anyone right now, but it's all potential fuel to the fire. :-)
If you end up going the VCL Styles route, and you're not using XE7, look at the VCL Styles Utils - an open source set of patches / hooks / extra functionality that brings earlier versions up to speed. http://theroadtodelphi.wordpress.com/vcl-style-utils/ Some of it I think has been integrated by Embarcadero in newer versions of Delphi. It does things like let you style an embedded web browser control, message boxes, menus, etc, ie makes sure the style applies to the entire application.
Nice looking game! I'll have to check this out after work :)
Please note, that due to legal concerns, KaM Remake installer checks for original KaM game to be installed on your PC.
Odds are any custom components you had need major rewriting. Around D6 the designtime packages got split. All your strings become unicode somewhere in one of the XE versions so that's a major one too. You'll probably need latest Fast Reports + other commercial components (if you can, drop Crystal)
Starting with Delphi 2009 Unicode standardization was brought in to the IDE. Meaning you may need to make some Unicode conversions to your code, based on how you are using Strings and Chars, such as String is replaced by AnsiString. It could be as little as 0 changes needed. It really all depends on how you are using Strings and Chars in your application. For Unicode, check out the following page that has a compilation of Unicode migration resources: http://softwareonastring.com/2014/10/06/20-resources-on-migrating-to-unicode-with-delphi The 3rd party plug-ins (libraries) need to be rebuilt in Delphi XE7. Having the source code makes this easier. You will need to re-compile your 3rd party components / libraries from older Delphi using Delphi XE7 so the components and libraries can be used in Delphi XE7 projects. Any 3rd party components / libraries without the source code may need updated versions for XE7. You will also need to review updating your data access components. The BDE has been deprecated for some time and is not included in XE7 (still available as separate download, though). dbExpress or FireDAC are better options moving forward, as they support newer editions of many SQL databases and offer higher performance options. Lastly, namespace changes were made in either XE or XE2; such as Forms.pas changing to Vcl.Forms.pas .
much appreciated, We're using Direct Oracle Access, so bde shouldn't be an issue, And i believe we just recently updated all of our libraries so that they are compatible with xe7. The huge issue seems to be Crystal reports. Crystal Reports doesnt seem to be objects for Crystal reports for xe7. We've known that for a while, and quit using Crystal reports for generating (currently using fastreports) However we have a few hundred legacy crystal reports. Any ideas on work arounds?
Since SAP Crystal Solutions no longer provide a Delphi library / component set for working with Crystal Reports, options for maintenance of applications which used Crystal Reports is limited. It’s my understanding that SAP do provide a .NET Assembly dll for working with Crystal Reports. Provided the assembly exports COM objects (which is typical of .NET Assembly based API’s), it should be possible to use the Delphi TypeLibrary import feature to make use of this DLL. The API has likely changed significantly over time however, especially with the move into .NET, and therefore some rework may be required to make use of the controls. SDK information for Crystal Reports can be seen here http://scn.sap.com/docs/DOC-35632 The .NET assemblies that I speak of are listed under the‘.NET’ language column. 
You will have a *lot* of warnings about: - suspicious typecasts of strings - casts of string with data loss Any time you ever handled a string as a series of bytes will have to be changed to use `AnsiString`. Quite a few event handler declarations have changed (e.g. Virtual Treeview, TUpDown, TWebBrowser) You will find every form will be drawn incorrectly. Be sure to go into every `TPanel` on every form and turn off `ParentBackground`. The default record alignment has changed from Delphi 5. Delphi no longer defaults to correct Windows applications. Have have to be sure to add: {$ALIGN ON} {$MINENUMSIZE 4} to the top of every unit that declares a structure that you pass to Windows. Check your new project's options, and ensure that the **Record field alignment** (which is also the alignment for classes) is on the default **Quad Word**. Sometimes things can go screwy and get set to **Byte**, which is incorrect for Windows applications. It won't be a problem as long as you stick to only targetting 32-bit, but anywhere you stuffed a `Pointer` into an `Integer` or a `DWORD` is wrong. You should stuff them into a `NativeInt` or `NativeUInt`. NetMaster components (NMSMTP) is gone. You'll have to re-write [sending e-mail using Indy](http://stackoverflow.com/a/27237415/12597). `InterlockedCompareExchange` changed. It is no longer takes a `Pointer` but an `Integer`. If you have a library of code and components, i ***HIGHLY*** recommend you branch them; having two separate folder trees on everyone's development machines and in source control. We tried heroic efforts to make the source code compatible with D5 and XEx (heroic efforts with DEFINEs and IFDEFs). But in the end there are fundamental problems with components that cause parameter types to be wrong for one or the other. Rather than casting the parameters of `SendMessage` to `Integer` or `DWORD`, you should have been casting them to `WPARAM` and `LPARAM` respectively: SendMessage(WM_foo, WPARAM(foox), LPARAM(fooy)); On 32-bit Windows it's not a problem. But on 64-bit Windows it's a huge screwup: | Parameter| Win16 | Win32 | Win64 | |-----------|-------|------------|---------| | `WPARAM` | unsigned 16-bits | unsigned 32 bits | unsigned 64 bits | | `LPARAM` | signed 32-bits | signed 32-bits | signed 64-bits | So you can see why we had to fix: SendMessage(FHandle, TTM_TRACKACTIVATE, Integer(Visible), Integer(@FToolInfo)); to SendMessage(FHandle, TTM_TRACKACTIVATE, WPARAM(Visible), LPARAM(@FToolInfo)); everywhere. There will be plenty of spots where you called: OutputDebugStringA(PChar(...)); or OutputDebugString(PAnsiChar(...)); those are both wrong, as: - Delphi 5: OutputDebugString ==&gt; OutputDebugStringA - Delphi XE7: OutputDebugString ==&gt; OutputDebugStringW - Delphi 5: PChar ==&gt; PAnsiChar - Delphi XE7: PChar ==&gt; PWideChar In the 64-bit compiler there is no such thing as `Extended` anymore. There is only `Real`. You should stop using `Extended` (it's only an alias of `Real` now anyway). You should have use `HMODULE` and not `Cardinal`. You should have used `INVALID_HANDLE_VALUE`, and not `$ffffffff`. The unit `Excel97` is gone. You should import the Excel type library yourself, and call it `Excel11.pas`. Delphi no longer can handle variants of type `VT_DECIMAL` (or `varDecimal`). If you try to copy a variant that contains a decimal Delphi will fall over dead, rather than simply copying two numbers. That's all i have for now.
Huge thanks to everyone that has posted to here! I'll be checking this as I go through the change over and let you know how it goes.
Feel free to drop me a line if you encounter any issues! 